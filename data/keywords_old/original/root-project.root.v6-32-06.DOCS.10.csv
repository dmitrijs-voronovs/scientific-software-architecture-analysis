id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/FAQ.rst:525,Availability,error,error,525,"================================; Frequently Asked Questions (FAQ); ================================. .. contents::; :local:. Driver; ======. I run ``clang -cc1 ...`` and get weird errors about missing headers; -------------------------------------------------------------------. Given this source file:. .. code-block:: c. #include <stdio.h>. int main() {; printf(""Hello world\n"");; }. If you run:. .. code-block:: console. $ clang -cc1 hello.c; hello.c:1:10: fatal error: 'stdio.h' file not found; #include <stdio.h>; ^; 1 error generated. ``clang -cc1`` is the frontend, ``clang`` is the :doc:`driver; <DriverInternals>`. The driver invokes the frontend with options appropriate; for your system. To see these options, run:. .. code-block:: console. $ clang -### -c hello.c. Some clang command line options are driver-only options, some are frontend-only; options. Frontend-only options are intended to be used only by clang developers.; Users should not run ``clang -cc1`` directly, because ``-cc1`` options are not; guaranteed to be stable. If you want to use a frontend-only option (""a ``-cc1`` option""), for example; ``-ast-dump``, then you need to take the ``clang -cc1`` line generated by the; driver and add the option you need. Alternatively, you can run; ``clang -Xclang <option> ...`` to force the driver pass ``<option>`` to; ``clang -cc1``. I get errors about some headers being missing (``stddef.h``, ``stdarg.h``); --------------------------------------------------------------------------. Some header files (``stddef.h``, ``stdarg.h``, and others) are shipped with; Clang --- these are called builtin includes. Clang searches for them in a; directory relative to the location of the ``clang`` binary. If you moved the; ``clang`` binary, you need to move the builtin headers, too. More information can be found in the :ref:`libtooling_builtin_includes`; section. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/FAQ.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/FAQ.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/FAQ.rst:1362,Availability,error,errors,1362,"================================; Frequently Asked Questions (FAQ); ================================. .. contents::; :local:. Driver; ======. I run ``clang -cc1 ...`` and get weird errors about missing headers; -------------------------------------------------------------------. Given this source file:. .. code-block:: c. #include <stdio.h>. int main() {; printf(""Hello world\n"");; }. If you run:. .. code-block:: console. $ clang -cc1 hello.c; hello.c:1:10: fatal error: 'stdio.h' file not found; #include <stdio.h>; ^; 1 error generated. ``clang -cc1`` is the frontend, ``clang`` is the :doc:`driver; <DriverInternals>`. The driver invokes the frontend with options appropriate; for your system. To see these options, run:. .. code-block:: console. $ clang -### -c hello.c. Some clang command line options are driver-only options, some are frontend-only; options. Frontend-only options are intended to be used only by clang developers.; Users should not run ``clang -cc1`` directly, because ``-cc1`` options are not; guaranteed to be stable. If you want to use a frontend-only option (""a ``-cc1`` option""), for example; ``-ast-dump``, then you need to take the ``clang -cc1`` line generated by the; driver and add the option you need. Alternatively, you can run; ``clang -Xclang <option> ...`` to force the driver pass ``<option>`` to; ``clang -cc1``. I get errors about some headers being missing (``stddef.h``, ``stdarg.h``); --------------------------------------------------------------------------. Some header files (``stddef.h``, ``stdarg.h``, and others) are shipped with; Clang --- these are called builtin includes. Clang searches for them in a; directory relative to the location of the ``clang`` binary. If you moved the; ``clang`` binary, you need to move the builtin headers, too. More information can be found in the :ref:`libtooling_builtin_includes`; section. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/FAQ.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/FAQ.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:1214,Availability,avail,available,1214,"is page is a design document for; **hardware-assisted AddressSanitizer** (or **HWASAN**); a tool similar to :doc:`AddressSanitizer`,; but based on partial hardware assistance. Introduction; ============. :doc:`AddressSanitizer`; tags every 8 bytes of the application memory with a 1 byte tag (using *shadow memory*),; uses *redzones* to find buffer-overflows and; *quarantine* to find use-after-free.; The redzones, the quarantine, and, to a less extent, the shadow, are the; sources of AddressSanitizer's memory overhead.; See the `AddressSanitizer paper`_ for details. AArch64 has `Address Tagging`_ (or top-byte-ignore, TBI), a hardware feature that allows; software to use the 8 most significant bits of a 64-bit pointer as; a tag. HWASAN uses `Address Tagging`_; to implement a memory safety tool, similar to :doc:`AddressSanitizer`,; but with smaller memory overhead and slightly different (mostly better); accuracy guarantees. Intel's `Linear Address Masking`_ (LAM) also provides address tagging for; x86_64, though it is not widely available in hardware yet. For x86_64, HWASAN; has a limited implementation using page aliasing instead. Algorithm; =========; * Every heap/stack/global memory object is forcibly aligned by `TG` bytes; (`TG` is e.g. 16 or 64). We call `TG` the **tagging granularity**.; * For every such object a random `TS`-bit tag `T` is chosen (`TS`, or tag size, is e.g. 4 or 8); * The pointer to the object is tagged with `T`.; * The memory for the object is also tagged with `T` (using a `TG=>1` shadow memory); * Every load and store is instrumented to read the memory tag and compare it; with the pointer tag, exception is raised on tag mismatch. For a more detailed discussion of this approach see https://arxiv.org/pdf/1802.09517.pdf. Short granules; --------------. A short granule is a granule of size between 1 and `TG-1` bytes. The size; of a short granule is stored at the location in shadow memory where the; granule's tag is normally stored, while the granule",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:2971,Availability,error,error,2971,"een 1 and `TG-1` bytes. The size; of a short granule is stored at the location in shadow memory where the; granule's tag is normally stored, while the granule's actual tag is stored; in the last byte of the granule. This means that in order to verify that a; pointer tag matches a memory tag, HWASAN must check for two possibilities:. * the pointer tag is equal to the memory tag in shadow memory, or; * the shadow memory tag is actually a short granule size, the value being loaded; is in bounds of the granule and the pointer tag is equal to the last byte of; the granule. Pointer tags between 1 to `TG-1` are possible and are as likely as any other; tag. This means that these tags in memory have two interpretations: the full; tag interpretation (where the pointer tag is between 1 and `TG-1` and the; last byte of the granule is ordinary data) and the short tag interpretation; (where the pointer tag is stored in the granule). When HWASAN detects an error near a memory tag between 1 and `TG-1`, it; will show both the memory tag and the last byte of the granule. Currently,; it is up to the user to disambiguate the two possibilities. Instrumentation; ===============. Memory Accesses; ---------------; In the majority of cases, memory accesses are prefixed with a call to; an outlined instruction sequence that verifies the tags. The code size; and performance overhead of the call is reduced by using a custom calling; convention that. * preserves most registers, and; * is specialized to the register containing the address, and the type and; size of the memory access. Currently, the following sequence is used:. .. code-block:: none. // int foo(int *a) { return *a; }; // clang -O2 --target=aarch64-linux-android30 -fsanitize=hwaddress -S -o - load.c; [...]; foo:; stp x30, x20, [sp, #-16]!; adrp x20, :got:__hwasan_shadow // load shadow address from GOT into x20; ldr x20, [x20, :got_lo12:__hwasan_shadow]; bl __hwasan_check_x0_2_short_v2 // call outlined tag check; // (arguments: x0 = a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:4472,Availability,error,error,4472," and; size of the memory access. Currently, the following sequence is used:. .. code-block:: none. // int foo(int *a) { return *a; }; // clang -O2 --target=aarch64-linux-android30 -fsanitize=hwaddress -S -o - load.c; [...]; foo:; stp x30, x20, [sp, #-16]!; adrp x20, :got:__hwasan_shadow // load shadow address from GOT into x20; ldr x20, [x20, :got_lo12:__hwasan_shadow]; bl __hwasan_check_x0_2_short_v2 // call outlined tag check; // (arguments: x0 = address, x20 = shadow base;; // ""2"" encodes the access type and size); ldr w0, [x0] // inline load; ldp x30, x20, [sp], #16; ret. [...]; __hwasan_check_x0_2_short_v2:; sbfx x16, x0, #4, #52 // shadow offset; ldrb w16, [x20, x16] // load shadow tag; cmp x16, x0, lsr #56 // extract address tag, compare with shadow tag; b.ne .Ltmp0 // jump to short tag handler on mismatch; .Ltmp1:; ret; .Ltmp0:; cmp w16, #15 // is this a short tag?; b.hi .Ltmp2 // if not, error; and x17, x0, #0xf // find the address's position in the short granule; add x17, x17, #3 // adjust to the position of the last byte loaded; cmp w16, w17 // check that position is in bounds; b.ls .Ltmp2 // if not, error; orr x16, x0, #0xf // compute address of last byte of granule; ldrb w16, [x16] // load tag from it; cmp x16, x0, lsr #56 // compare with pointer tag; b.eq .Ltmp1 // if matches, continue; .Ltmp2:; stp x0, x1, [sp, #-256]! // save original x0, x1 on stack (they will be overwritten); stp x29, x30, [sp, #232] // create frame record; mov x1, #2 // set x1 to a constant indicating the type of failure; adrp x16, :got:__hwasan_tag_mismatch_v2 // call runtime function to save remaining registers and report error; ldr x16, [x16, :got_lo12:__hwasan_tag_mismatch_v2] // (load address from GOT to avoid potential register clobbers in delay load handler); br x16. Heap; ----. Tagging the heap memory/pointers is done by `malloc`.; This can be based on any malloc that forces all objects to be TG-aligned.; `free` tags the memory with a different tag. Stack; -----. Stack fram",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:4691,Availability,error,error,4691,"s -S -o - load.c; [...]; foo:; stp x30, x20, [sp, #-16]!; adrp x20, :got:__hwasan_shadow // load shadow address from GOT into x20; ldr x20, [x20, :got_lo12:__hwasan_shadow]; bl __hwasan_check_x0_2_short_v2 // call outlined tag check; // (arguments: x0 = address, x20 = shadow base;; // ""2"" encodes the access type and size); ldr w0, [x0] // inline load; ldp x30, x20, [sp], #16; ret. [...]; __hwasan_check_x0_2_short_v2:; sbfx x16, x0, #4, #52 // shadow offset; ldrb w16, [x20, x16] // load shadow tag; cmp x16, x0, lsr #56 // extract address tag, compare with shadow tag; b.ne .Ltmp0 // jump to short tag handler on mismatch; .Ltmp1:; ret; .Ltmp0:; cmp w16, #15 // is this a short tag?; b.hi .Ltmp2 // if not, error; and x17, x0, #0xf // find the address's position in the short granule; add x17, x17, #3 // adjust to the position of the last byte loaded; cmp w16, w17 // check that position is in bounds; b.ls .Ltmp2 // if not, error; orr x16, x0, #0xf // compute address of last byte of granule; ldrb w16, [x16] // load tag from it; cmp x16, x0, lsr #56 // compare with pointer tag; b.eq .Ltmp1 // if matches, continue; .Ltmp2:; stp x0, x1, [sp, #-256]! // save original x0, x1 on stack (they will be overwritten); stp x29, x30, [sp, #232] // create frame record; mov x1, #2 // set x1 to a constant indicating the type of failure; adrp x16, :got:__hwasan_tag_mismatch_v2 // call runtime function to save remaining registers and report error; ldr x16, [x16, :got_lo12:__hwasan_tag_mismatch_v2] // (load address from GOT to avoid potential register clobbers in delay load handler); br x16. Heap; ----. Tagging the heap memory/pointers is done by `malloc`.; This can be based on any malloc that forces all objects to be TG-aligned.; `free` tags the memory with a different tag. Stack; -----. Stack frames are instrumented by aligning all non-promotable allocas; by `TG` and tagging stack memory in function prologue and epilogue. Tags for different allocas in one function are **not** generated; indep",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:5086,Availability,failure,failure,5086," x30, x20, [sp], #16; ret. [...]; __hwasan_check_x0_2_short_v2:; sbfx x16, x0, #4, #52 // shadow offset; ldrb w16, [x20, x16] // load shadow tag; cmp x16, x0, lsr #56 // extract address tag, compare with shadow tag; b.ne .Ltmp0 // jump to short tag handler on mismatch; .Ltmp1:; ret; .Ltmp0:; cmp w16, #15 // is this a short tag?; b.hi .Ltmp2 // if not, error; and x17, x0, #0xf // find the address's position in the short granule; add x17, x17, #3 // adjust to the position of the last byte loaded; cmp w16, w17 // check that position is in bounds; b.ls .Ltmp2 // if not, error; orr x16, x0, #0xf // compute address of last byte of granule; ldrb w16, [x16] // load tag from it; cmp x16, x0, lsr #56 // compare with pointer tag; b.eq .Ltmp1 // if matches, continue; .Ltmp2:; stp x0, x1, [sp, #-256]! // save original x0, x1 on stack (they will be overwritten); stp x29, x30, [sp, #232] // create frame record; mov x1, #2 // set x1 to a constant indicating the type of failure; adrp x16, :got:__hwasan_tag_mismatch_v2 // call runtime function to save remaining registers and report error; ldr x16, [x16, :got_lo12:__hwasan_tag_mismatch_v2] // (load address from GOT to avoid potential register clobbers in delay load handler); br x16. Heap; ----. Tagging the heap memory/pointers is done by `malloc`.; This can be based on any malloc that forces all objects to be TG-aligned.; `free` tags the memory with a different tag. Stack; -----. Stack frames are instrumented by aligning all non-promotable allocas; by `TG` and tagging stack memory in function prologue and epilogue. Tags for different allocas in one function are **not** generated; independently; doing that in a function with `M` allocas would require; maintaining `M` live stack pointers, significantly increasing register; pressure. Instead we generate a single base tag value in the prologue,; and build the tag for alloca number `M` as `ReTag(BaseTag, M)`, where; ReTag can be as simple as exclusive-or with constant `M`. Stack instrument",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:5199,Availability,error,error,5199," x30, x20, [sp], #16; ret. [...]; __hwasan_check_x0_2_short_v2:; sbfx x16, x0, #4, #52 // shadow offset; ldrb w16, [x20, x16] // load shadow tag; cmp x16, x0, lsr #56 // extract address tag, compare with shadow tag; b.ne .Ltmp0 // jump to short tag handler on mismatch; .Ltmp1:; ret; .Ltmp0:; cmp w16, #15 // is this a short tag?; b.hi .Ltmp2 // if not, error; and x17, x0, #0xf // find the address's position in the short granule; add x17, x17, #3 // adjust to the position of the last byte loaded; cmp w16, w17 // check that position is in bounds; b.ls .Ltmp2 // if not, error; orr x16, x0, #0xf // compute address of last byte of granule; ldrb w16, [x16] // load tag from it; cmp x16, x0, lsr #56 // compare with pointer tag; b.eq .Ltmp1 // if matches, continue; .Ltmp2:; stp x0, x1, [sp, #-256]! // save original x0, x1 on stack (they will be overwritten); stp x29, x30, [sp, #232] // create frame record; mov x1, #2 // set x1 to a constant indicating the type of failure; adrp x16, :got:__hwasan_tag_mismatch_v2 // call runtime function to save remaining registers and report error; ldr x16, [x16, :got_lo12:__hwasan_tag_mismatch_v2] // (load address from GOT to avoid potential register clobbers in delay load handler); br x16. Heap; ----. Tagging the heap memory/pointers is done by `malloc`.; This can be based on any malloc that forces all objects to be TG-aligned.; `free` tags the memory with a different tag. Stack; -----. Stack frames are instrumented by aligning all non-promotable allocas; by `TG` and tagging stack memory in function prologue and epilogue. Tags for different allocas in one function are **not** generated; independently; doing that in a function with `M` allocas would require; maintaining `M` live stack pointers, significantly increasing register; pressure. Instead we generate a single base tag value in the prologue,; and build the tag for alloca number `M` as `ReTag(BaseTag, M)`, where; ReTag can be as simple as exclusive-or with constant `M`. Stack instrument",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:10494,Availability,avail,available,10494,"e tags before; any load or store, which is infeasible in any realistic environment; that contains non-instrumented code.; * May have compatibility problems if the target code uses higher; pointer bits for other purposes.; * May require changes in the OS kernels (e.g. Linux seems to dislike; tagged pointers passed from address space:; https://www.kernel.org/doc/Documentation/arm64/tagged-pointers.txt).; * **Does not require redzones to detect buffer overflows**,; but the buffer overflow detection is probabilistic, with roughly; `1/(2**TS)` chance of missing a bug (6.25% or 0.39% with 4 and 8-bit TS; respectively).; * **Does not require quarantine to detect heap-use-after-free,; or stack-use-after-return**.; The detection is similarly probabilistic. The memory overhead of HWASAN is expected to be much smaller; than that of AddressSanitizer:; `1/TG` extra memory for the shadow; and some overhead due to `TG`-aligning all objects. Supported architectures; =======================; HWASAN relies on `Address Tagging`_ which is only available on AArch64.; For other 64-bit architectures it is possible to remove the address tags; before every load and store by compiler instrumentation, but this variant; will have limited deployability since not all of the code is; typically instrumented. On x86_64, HWASAN utilizes page aliasing to place tags in userspace address; bits. Currently only heap tagging is supported. The page aliases rely on; shared memory, which will cause heap memory to be shared between processes if; the application calls ``fork()``. Therefore x86_64 is really only safe for; applications that do not fork. HWASAN does not currently support 32-bit architectures since they do not; support `Address Tagging`_ and the address space is too constrained to easily; implement page aliasing. Related Work; ============; * `SPARC ADI`_ implements a similar tool mostly in hardware.; * `Effective and Efficient Memory Protection Using Dynamic Tainting`_ discusses; similar approach",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:12218,Availability,down,download,12218,"er:; `1/TG` extra memory for the shadow; and some overhead due to `TG`-aligning all objects. Supported architectures; =======================; HWASAN relies on `Address Tagging`_ which is only available on AArch64.; For other 64-bit architectures it is possible to remove the address tags; before every load and store by compiler instrumentation, but this variant; will have limited deployability since not all of the code is; typically instrumented. On x86_64, HWASAN utilizes page aliasing to place tags in userspace address; bits. Currently only heap tagging is supported. The page aliases rely on; shared memory, which will cause heap memory to be shared between processes if; the application calls ``fork()``. Therefore x86_64 is really only safe for; applications that do not fork. HWASAN does not currently support 32-bit architectures since they do not; support `Address Tagging`_ and the address space is too constrained to easily; implement page aliasing. Related Work; ============; * `SPARC ADI`_ implements a similar tool mostly in hardware.; * `Effective and Efficient Memory Protection Using Dynamic Tainting`_ discusses; similar approaches (""lock & key"").; * `Watchdog`_ discussed a heavier, but still somewhat similar; ""lock & key"" approach.; * *TODO: add more ""related work"" links. Suggestions are welcome.*. .. _Watchdog: https://www.cis.upenn.edu/acg/papers/isca12_watchdog.pdf; .. _Effective and Efficient Memory Protection Using Dynamic Tainting: https://www.cc.gatech.edu/~orso/papers/clause.doudalis.orso.prvulovic.pdf; .. _SPARC ADI: https://lazytyped.blogspot.com/2017/09/getting-started-with-adi.html; .. _AddressSanitizer paper: https://www.usenix.org/system/files/conference/atc12/atc12-final39.pdf; .. _Address Tagging: http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch12s05s01.html; .. _Linear Address Masking: https://software.intel.com/content/www/us/en/develop/download/intel-architecture-instruction-set-extensions-programming-reference.html; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:10684,Deployability,deploy,deployability,10684," higher; pointer bits for other purposes.; * May require changes in the OS kernels (e.g. Linux seems to dislike; tagged pointers passed from address space:; https://www.kernel.org/doc/Documentation/arm64/tagged-pointers.txt).; * **Does not require redzones to detect buffer overflows**,; but the buffer overflow detection is probabilistic, with roughly; `1/(2**TS)` chance of missing a bug (6.25% or 0.39% with 4 and 8-bit TS; respectively).; * **Does not require quarantine to detect heap-use-after-free,; or stack-use-after-return**.; The detection is similarly probabilistic. The memory overhead of HWASAN is expected to be much smaller; than that of AddressSanitizer:; `1/TG` extra memory for the shadow; and some overhead due to `TG`-aligning all objects. Supported architectures; =======================; HWASAN relies on `Address Tagging`_ which is only available on AArch64.; For other 64-bit architectures it is possible to remove the address tags; before every load and store by compiler instrumentation, but this variant; will have limited deployability since not all of the code is; typically instrumented. On x86_64, HWASAN utilizes page aliasing to place tags in userspace address; bits. Currently only heap tagging is supported. The page aliases rely on; shared memory, which will cause heap memory to be shared between processes if; the application calls ``fork()``. Therefore x86_64 is really only safe for; applications that do not fork. HWASAN does not currently support 32-bit architectures since they do not; support `Address Tagging`_ and the address space is too constrained to easily; implement page aliasing. Related Work; ============; * `SPARC ADI`_ implements a similar tool mostly in hardware.; * `Effective and Efficient Memory Protection Using Dynamic Tainting`_ discusses; similar approaches (""lock & key"").; * `Watchdog`_ discussed a heavier, but still somewhat similar; ""lock & key"" approach.; * *TODO: add more ""related work"" links. Suggestions are welcome.*. .. _W",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:3408,Energy Efficiency,reduce,reduced,3408,"memory, or; * the shadow memory tag is actually a short granule size, the value being loaded; is in bounds of the granule and the pointer tag is equal to the last byte of; the granule. Pointer tags between 1 to `TG-1` are possible and are as likely as any other; tag. This means that these tags in memory have two interpretations: the full; tag interpretation (where the pointer tag is between 1 and `TG-1` and the; last byte of the granule is ordinary data) and the short tag interpretation; (where the pointer tag is stored in the granule). When HWASAN detects an error near a memory tag between 1 and `TG-1`, it; will show both the memory tag and the last byte of the granule. Currently,; it is up to the user to disambiguate the two possibilities. Instrumentation; ===============. Memory Accesses; ---------------; In the majority of cases, memory accesses are prefixed with a call to; an outlined instruction sequence that verifies the tags. The code size; and performance overhead of the call is reduced by using a custom calling; convention that. * preserves most registers, and; * is specialized to the register containing the address, and the type and; size of the memory access. Currently, the following sequence is used:. .. code-block:: none. // int foo(int *a) { return *a; }; // clang -O2 --target=aarch64-linux-android30 -fsanitize=hwaddress -S -o - load.c; [...]; foo:; stp x30, x20, [sp, #-16]!; adrp x20, :got:__hwasan_shadow // load shadow address from GOT into x20; ldr x20, [x20, :got_lo12:__hwasan_shadow]; bl __hwasan_check_x0_2_short_v2 // call outlined tag check; // (arguments: x0 = address, x20 = shadow base;; // ""2"" encodes the access type and size); ldr w0, [x0] // inline load; ldp x30, x20, [sp], #16; ret. [...]; __hwasan_check_x0_2_short_v2:; sbfx x16, x0, #4, #52 // shadow offset; ldrb w16, [x20, x16] // load shadow tag; cmp x16, x0, lsr #56 // extract address tag, compare with shadow tag; b.ne .Ltmp0 // jump to short tag handler on mismatch; .Ltmp1:; ret; .Ltm",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:9243,Modifiability,portab,portable,9243,"Lx.hwasan,unique,2; .Lx.hwasan.descriptor:; .word .Lx.hwasan-.Lx.hwasan.descriptor; .word 0x2d000004 // tag = 0x2d, size = 4. Error reporting; ---------------. Errors are generated by the `HLT` instruction and are handled by a signal handler. Attribute; ---------. HWASAN uses its own LLVM IR Attribute `sanitize_hwaddress` and a matching; C function attribute. An alternative would be to re-use ASAN's attribute; `sanitize_address`. The reasons to use a separate attribute are:. * Users may need to disable ASAN but not HWASAN, or vise versa,; because the tools have different trade-offs and compatibility issues.; * LLVM (ideally) does not use flags to decide which pass is being used,; ASAN or HWASAN are being applied, based on the function attributes. This does mean that users of HWASAN may need to add the new attribute; to the code that already uses the old attribute. Comparison with AddressSanitizer; ================================. HWASAN:; * Is less portable than :doc:`AddressSanitizer`; as it relies on hardware `Address Tagging`_ (AArch64).; Address Tagging can be emulated with compiler instrumentation,; but it will require the instrumentation to remove the tags before; any load or store, which is infeasible in any realistic environment; that contains non-instrumented code.; * May have compatibility problems if the target code uses higher; pointer bits for other purposes.; * May require changes in the OS kernels (e.g. Linux seems to dislike; tagged pointers passed from address space:; https://www.kernel.org/doc/Documentation/arm64/tagged-pointers.txt).; * **Does not require redzones to detect buffer overflows**,; but the buffer overflow detection is probabilistic, with roughly; `1/(2**TS)` chance of missing a bug (6.25% or 0.39% with 4 and 8-bit TS; respectively).; * **Does not require quarantine to detect heap-use-after-free,; or stack-use-after-return**.; The detection is similarly probabilistic. The memory overhead of HWASAN is expected to be much smaller; than t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:1723,Performance,load,load,1723,"ils. AArch64 has `Address Tagging`_ (or top-byte-ignore, TBI), a hardware feature that allows; software to use the 8 most significant bits of a 64-bit pointer as; a tag. HWASAN uses `Address Tagging`_; to implement a memory safety tool, similar to :doc:`AddressSanitizer`,; but with smaller memory overhead and slightly different (mostly better); accuracy guarantees. Intel's `Linear Address Masking`_ (LAM) also provides address tagging for; x86_64, though it is not widely available in hardware yet. For x86_64, HWASAN; has a limited implementation using page aliasing instead. Algorithm; =========; * Every heap/stack/global memory object is forcibly aligned by `TG` bytes; (`TG` is e.g. 16 or 64). We call `TG` the **tagging granularity**.; * For every such object a random `TS`-bit tag `T` is chosen (`TS`, or tag size, is e.g. 4 or 8); * The pointer to the object is tagged with `T`.; * The memory for the object is also tagged with `T` (using a `TG=>1` shadow memory); * Every load and store is instrumented to read the memory tag and compare it; with the pointer tag, exception is raised on tag mismatch. For a more detailed discussion of this approach see https://arxiv.org/pdf/1802.09517.pdf. Short granules; --------------. A short granule is a granule of size between 1 and `TG-1` bytes. The size; of a short granule is stored at the location in shadow memory where the; granule's tag is normally stored, while the granule's actual tag is stored; in the last byte of the granule. This means that in order to verify that a; pointer tag matches a memory tag, HWASAN must check for two possibilities:. * the pointer tag is equal to the memory tag in shadow memory, or; * the shadow memory tag is actually a short granule size, the value being loaded; is in bounds of the granule and the pointer tag is equal to the last byte of; the granule. Pointer tags between 1 to `TG-1` are possible and are as likely as any other; tag. This means that these tags in memory have two interpretations: the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:2491,Performance,load,loaded,2491,"ranularity**.; * For every such object a random `TS`-bit tag `T` is chosen (`TS`, or tag size, is e.g. 4 or 8); * The pointer to the object is tagged with `T`.; * The memory for the object is also tagged with `T` (using a `TG=>1` shadow memory); * Every load and store is instrumented to read the memory tag and compare it; with the pointer tag, exception is raised on tag mismatch. For a more detailed discussion of this approach see https://arxiv.org/pdf/1802.09517.pdf. Short granules; --------------. A short granule is a granule of size between 1 and `TG-1` bytes. The size; of a short granule is stored at the location in shadow memory where the; granule's tag is normally stored, while the granule's actual tag is stored; in the last byte of the granule. This means that in order to verify that a; pointer tag matches a memory tag, HWASAN must check for two possibilities:. * the pointer tag is equal to the memory tag in shadow memory, or; * the shadow memory tag is actually a short granule size, the value being loaded; is in bounds of the granule and the pointer tag is equal to the last byte of; the granule. Pointer tags between 1 to `TG-1` are possible and are as likely as any other; tag. This means that these tags in memory have two interpretations: the full; tag interpretation (where the pointer tag is between 1 and `TG-1` and the; last byte of the granule is ordinary data) and the short tag interpretation; (where the pointer tag is stored in the granule). When HWASAN detects an error near a memory tag between 1 and `TG-1`, it; will show both the memory tag and the last byte of the granule. Currently,; it is up to the user to disambiguate the two possibilities. Instrumentation; ===============. Memory Accesses; ---------------; In the majority of cases, memory accesses are prefixed with a call to; an outlined instruction sequence that verifies the tags. The code size; and performance overhead of the call is reduced by using a custom calling; convention that. * preserv",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:3372,Performance,perform,performance,3372,"memory, or; * the shadow memory tag is actually a short granule size, the value being loaded; is in bounds of the granule and the pointer tag is equal to the last byte of; the granule. Pointer tags between 1 to `TG-1` are possible and are as likely as any other; tag. This means that these tags in memory have two interpretations: the full; tag interpretation (where the pointer tag is between 1 and `TG-1` and the; last byte of the granule is ordinary data) and the short tag interpretation; (where the pointer tag is stored in the granule). When HWASAN detects an error near a memory tag between 1 and `TG-1`, it; will show both the memory tag and the last byte of the granule. Currently,; it is up to the user to disambiguate the two possibilities. Instrumentation; ===============. Memory Accesses; ---------------; In the majority of cases, memory accesses are prefixed with a call to; an outlined instruction sequence that verifies the tags. The code size; and performance overhead of the call is reduced by using a custom calling; convention that. * preserves most registers, and; * is specialized to the register containing the address, and the type and; size of the memory access. Currently, the following sequence is used:. .. code-block:: none. // int foo(int *a) { return *a; }; // clang -O2 --target=aarch64-linux-android30 -fsanitize=hwaddress -S -o - load.c; [...]; foo:; stp x30, x20, [sp, #-16]!; adrp x20, :got:__hwasan_shadow // load shadow address from GOT into x20; ldr x20, [x20, :got_lo12:__hwasan_shadow]; bl __hwasan_check_x0_2_short_v2 // call outlined tag check; // (arguments: x0 = address, x20 = shadow base;; // ""2"" encodes the access type and size); ldr w0, [x0] // inline load; ldp x30, x20, [sp], #16; ret. [...]; __hwasan_check_x0_2_short_v2:; sbfx x16, x0, #4, #52 // shadow offset; ldrb w16, [x20, x16] // load shadow tag; cmp x16, x0, lsr #56 // extract address tag, compare with shadow tag; b.ne .Ltmp0 // jump to short tag handler on mismatch; .Ltmp1:; ret; .Ltm",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:3771,Performance,load,load,3771," interpretations: the full; tag interpretation (where the pointer tag is between 1 and `TG-1` and the; last byte of the granule is ordinary data) and the short tag interpretation; (where the pointer tag is stored in the granule). When HWASAN detects an error near a memory tag between 1 and `TG-1`, it; will show both the memory tag and the last byte of the granule. Currently,; it is up to the user to disambiguate the two possibilities. Instrumentation; ===============. Memory Accesses; ---------------; In the majority of cases, memory accesses are prefixed with a call to; an outlined instruction sequence that verifies the tags. The code size; and performance overhead of the call is reduced by using a custom calling; convention that. * preserves most registers, and; * is specialized to the register containing the address, and the type and; size of the memory access. Currently, the following sequence is used:. .. code-block:: none. // int foo(int *a) { return *a; }; // clang -O2 --target=aarch64-linux-android30 -fsanitize=hwaddress -S -o - load.c; [...]; foo:; stp x30, x20, [sp, #-16]!; adrp x20, :got:__hwasan_shadow // load shadow address from GOT into x20; ldr x20, [x20, :got_lo12:__hwasan_shadow]; bl __hwasan_check_x0_2_short_v2 // call outlined tag check; // (arguments: x0 = address, x20 = shadow base;; // ""2"" encodes the access type and size); ldr w0, [x0] // inline load; ldp x30, x20, [sp], #16; ret. [...]; __hwasan_check_x0_2_short_v2:; sbfx x16, x0, #4, #52 // shadow offset; ldrb w16, [x20, x16] // load shadow tag; cmp x16, x0, lsr #56 // extract address tag, compare with shadow tag; b.ne .Ltmp0 // jump to short tag handler on mismatch; .Ltmp1:; ret; .Ltmp0:; cmp w16, #15 // is this a short tag?; b.hi .Ltmp2 // if not, error; and x17, x0, #0xf // find the address's position in the short granule; add x17, x17, #3 // adjust to the position of the last byte loaded; cmp w16, w17 // check that position is in bounds; b.ls .Ltmp2 // if not, error; orr x16, x0, #0xf //",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:3853,Performance,load,load,3853,"ects an error near a memory tag between 1 and `TG-1`, it; will show both the memory tag and the last byte of the granule. Currently,; it is up to the user to disambiguate the two possibilities. Instrumentation; ===============. Memory Accesses; ---------------; In the majority of cases, memory accesses are prefixed with a call to; an outlined instruction sequence that verifies the tags. The code size; and performance overhead of the call is reduced by using a custom calling; convention that. * preserves most registers, and; * is specialized to the register containing the address, and the type and; size of the memory access. Currently, the following sequence is used:. .. code-block:: none. // int foo(int *a) { return *a; }; // clang -O2 --target=aarch64-linux-android30 -fsanitize=hwaddress -S -o - load.c; [...]; foo:; stp x30, x20, [sp, #-16]!; adrp x20, :got:__hwasan_shadow // load shadow address from GOT into x20; ldr x20, [x20, :got_lo12:__hwasan_shadow]; bl __hwasan_check_x0_2_short_v2 // call outlined tag check; // (arguments: x0 = address, x20 = shadow base;; // ""2"" encodes the access type and size); ldr w0, [x0] // inline load; ldp x30, x20, [sp], #16; ret. [...]; __hwasan_check_x0_2_short_v2:; sbfx x16, x0, #4, #52 // shadow offset; ldrb w16, [x20, x16] // load shadow tag; cmp x16, x0, lsr #56 // extract address tag, compare with shadow tag; b.ne .Ltmp0 // jump to short tag handler on mismatch; .Ltmp1:; ret; .Ltmp0:; cmp w16, #15 // is this a short tag?; b.hi .Ltmp2 // if not, error; and x17, x0, #0xf // find the address's position in the short granule; add x17, x17, #3 // adjust to the position of the last byte loaded; cmp w16, w17 // check that position is in bounds; b.ls .Ltmp2 // if not, error; orr x16, x0, #0xf // compute address of last byte of granule; ldrb w16, [x16] // load tag from it; cmp x16, x0, lsr #56 // compare with pointer tag; b.eq .Ltmp1 // if matches, continue; .Ltmp2:; stp x0, x1, [sp, #-256]! // save original x0, x1 on stack (they will be",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:4109,Performance,load,load,4109,"ects an error near a memory tag between 1 and `TG-1`, it; will show both the memory tag and the last byte of the granule. Currently,; it is up to the user to disambiguate the two possibilities. Instrumentation; ===============. Memory Accesses; ---------------; In the majority of cases, memory accesses are prefixed with a call to; an outlined instruction sequence that verifies the tags. The code size; and performance overhead of the call is reduced by using a custom calling; convention that. * preserves most registers, and; * is specialized to the register containing the address, and the type and; size of the memory access. Currently, the following sequence is used:. .. code-block:: none. // int foo(int *a) { return *a; }; // clang -O2 --target=aarch64-linux-android30 -fsanitize=hwaddress -S -o - load.c; [...]; foo:; stp x30, x20, [sp, #-16]!; adrp x20, :got:__hwasan_shadow // load shadow address from GOT into x20; ldr x20, [x20, :got_lo12:__hwasan_shadow]; bl __hwasan_check_x0_2_short_v2 // call outlined tag check; // (arguments: x0 = address, x20 = shadow base;; // ""2"" encodes the access type and size); ldr w0, [x0] // inline load; ldp x30, x20, [sp], #16; ret. [...]; __hwasan_check_x0_2_short_v2:; sbfx x16, x0, #4, #52 // shadow offset; ldrb w16, [x20, x16] // load shadow tag; cmp x16, x0, lsr #56 // extract address tag, compare with shadow tag; b.ne .Ltmp0 // jump to short tag handler on mismatch; .Ltmp1:; ret; .Ltmp0:; cmp w16, #15 // is this a short tag?; b.hi .Ltmp2 // if not, error; and x17, x0, #0xf // find the address's position in the short granule; add x17, x17, #3 // adjust to the position of the last byte loaded; cmp w16, w17 // check that position is in bounds; b.ls .Ltmp2 // if not, error; orr x16, x0, #0xf // compute address of last byte of granule; ldrb w16, [x16] // load tag from it; cmp x16, x0, lsr #56 // compare with pointer tag; b.eq .Ltmp1 // if matches, continue; .Ltmp2:; stp x0, x1, [sp, #-256]! // save original x0, x1 on stack (they will be",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:4247,Performance,load,load,4247,"f cases, memory accesses are prefixed with a call to; an outlined instruction sequence that verifies the tags. The code size; and performance overhead of the call is reduced by using a custom calling; convention that. * preserves most registers, and; * is specialized to the register containing the address, and the type and; size of the memory access. Currently, the following sequence is used:. .. code-block:: none. // int foo(int *a) { return *a; }; // clang -O2 --target=aarch64-linux-android30 -fsanitize=hwaddress -S -o - load.c; [...]; foo:; stp x30, x20, [sp, #-16]!; adrp x20, :got:__hwasan_shadow // load shadow address from GOT into x20; ldr x20, [x20, :got_lo12:__hwasan_shadow]; bl __hwasan_check_x0_2_short_v2 // call outlined tag check; // (arguments: x0 = address, x20 = shadow base;; // ""2"" encodes the access type and size); ldr w0, [x0] // inline load; ldp x30, x20, [sp], #16; ret. [...]; __hwasan_check_x0_2_short_v2:; sbfx x16, x0, #4, #52 // shadow offset; ldrb w16, [x20, x16] // load shadow tag; cmp x16, x0, lsr #56 // extract address tag, compare with shadow tag; b.ne .Ltmp0 // jump to short tag handler on mismatch; .Ltmp1:; ret; .Ltmp0:; cmp w16, #15 // is this a short tag?; b.hi .Ltmp2 // if not, error; and x17, x0, #0xf // find the address's position in the short granule; add x17, x17, #3 // adjust to the position of the last byte loaded; cmp w16, w17 // check that position is in bounds; b.ls .Ltmp2 // if not, error; orr x16, x0, #0xf // compute address of last byte of granule; ldrb w16, [x16] // load tag from it; cmp x16, x0, lsr #56 // compare with pointer tag; b.eq .Ltmp1 // if matches, continue; .Ltmp2:; stp x0, x1, [sp, #-256]! // save original x0, x1 on stack (they will be overwritten); stp x29, x30, [sp, #232] // create frame record; mov x1, #2 // set x1 to a constant indicating the type of failure; adrp x16, :got:__hwasan_tag_mismatch_v2 // call runtime function to save remaining registers and report error; ldr x16, [x16, :got_lo12:__hwasan_tag",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:4610,Performance,load,loaded,4610," and; size of the memory access. Currently, the following sequence is used:. .. code-block:: none. // int foo(int *a) { return *a; }; // clang -O2 --target=aarch64-linux-android30 -fsanitize=hwaddress -S -o - load.c; [...]; foo:; stp x30, x20, [sp, #-16]!; adrp x20, :got:__hwasan_shadow // load shadow address from GOT into x20; ldr x20, [x20, :got_lo12:__hwasan_shadow]; bl __hwasan_check_x0_2_short_v2 // call outlined tag check; // (arguments: x0 = address, x20 = shadow base;; // ""2"" encodes the access type and size); ldr w0, [x0] // inline load; ldp x30, x20, [sp], #16; ret. [...]; __hwasan_check_x0_2_short_v2:; sbfx x16, x0, #4, #52 // shadow offset; ldrb w16, [x20, x16] // load shadow tag; cmp x16, x0, lsr #56 // extract address tag, compare with shadow tag; b.ne .Ltmp0 // jump to short tag handler on mismatch; .Ltmp1:; ret; .Ltmp0:; cmp w16, #15 // is this a short tag?; b.hi .Ltmp2 // if not, error; and x17, x0, #0xf // find the address's position in the short granule; add x17, x17, #3 // adjust to the position of the last byte loaded; cmp w16, w17 // check that position is in bounds; b.ls .Ltmp2 // if not, error; orr x16, x0, #0xf // compute address of last byte of granule; ldrb w16, [x16] // load tag from it; cmp x16, x0, lsr #56 // compare with pointer tag; b.eq .Ltmp1 // if matches, continue; .Ltmp2:; stp x0, x1, [sp, #-256]! // save original x0, x1 on stack (they will be overwritten); stp x29, x30, [sp, #232] // create frame record; mov x1, #2 // set x1 to a constant indicating the type of failure; adrp x16, :got:__hwasan_tag_mismatch_v2 // call runtime function to save remaining registers and report error; ldr x16, [x16, :got_lo12:__hwasan_tag_mismatch_v2] // (load address from GOT to avoid potential register clobbers in delay load handler); br x16. Heap; ----. Tagging the heap memory/pointers is done by `malloc`.; This can be based on any malloc that forces all objects to be TG-aligned.; `free` tags the memory with a different tag. Stack; -----. Stack fram",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:4779,Performance,load,load,4779,"s -S -o - load.c; [...]; foo:; stp x30, x20, [sp, #-16]!; adrp x20, :got:__hwasan_shadow // load shadow address from GOT into x20; ldr x20, [x20, :got_lo12:__hwasan_shadow]; bl __hwasan_check_x0_2_short_v2 // call outlined tag check; // (arguments: x0 = address, x20 = shadow base;; // ""2"" encodes the access type and size); ldr w0, [x0] // inline load; ldp x30, x20, [sp], #16; ret. [...]; __hwasan_check_x0_2_short_v2:; sbfx x16, x0, #4, #52 // shadow offset; ldrb w16, [x20, x16] // load shadow tag; cmp x16, x0, lsr #56 // extract address tag, compare with shadow tag; b.ne .Ltmp0 // jump to short tag handler on mismatch; .Ltmp1:; ret; .Ltmp0:; cmp w16, #15 // is this a short tag?; b.hi .Ltmp2 // if not, error; and x17, x0, #0xf // find the address's position in the short granule; add x17, x17, #3 // adjust to the position of the last byte loaded; cmp w16, w17 // check that position is in bounds; b.ls .Ltmp2 // if not, error; orr x16, x0, #0xf // compute address of last byte of granule; ldrb w16, [x16] // load tag from it; cmp x16, x0, lsr #56 // compare with pointer tag; b.eq .Ltmp1 // if matches, continue; .Ltmp2:; stp x0, x1, [sp, #-256]! // save original x0, x1 on stack (they will be overwritten); stp x29, x30, [sp, #232] // create frame record; mov x1, #2 // set x1 to a constant indicating the type of failure; adrp x16, :got:__hwasan_tag_mismatch_v2 // call runtime function to save remaining registers and report error; ldr x16, [x16, :got_lo12:__hwasan_tag_mismatch_v2] // (load address from GOT to avoid potential register clobbers in delay load handler); br x16. Heap; ----. Tagging the heap memory/pointers is done by `malloc`.; This can be based on any malloc that forces all objects to be TG-aligned.; `free` tags the memory with a different tag. Stack; -----. Stack frames are instrumented by aligning all non-promotable allocas; by `TG` and tagging stack memory in function prologue and epilogue. Tags for different allocas in one function are **not** generated; indep",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:5261,Performance,load,load,5261," x30, x20, [sp], #16; ret. [...]; __hwasan_check_x0_2_short_v2:; sbfx x16, x0, #4, #52 // shadow offset; ldrb w16, [x20, x16] // load shadow tag; cmp x16, x0, lsr #56 // extract address tag, compare with shadow tag; b.ne .Ltmp0 // jump to short tag handler on mismatch; .Ltmp1:; ret; .Ltmp0:; cmp w16, #15 // is this a short tag?; b.hi .Ltmp2 // if not, error; and x17, x0, #0xf // find the address's position in the short granule; add x17, x17, #3 // adjust to the position of the last byte loaded; cmp w16, w17 // check that position is in bounds; b.ls .Ltmp2 // if not, error; orr x16, x0, #0xf // compute address of last byte of granule; ldrb w16, [x16] // load tag from it; cmp x16, x0, lsr #56 // compare with pointer tag; b.eq .Ltmp1 // if matches, continue; .Ltmp2:; stp x0, x1, [sp, #-256]! // save original x0, x1 on stack (they will be overwritten); stp x29, x30, [sp, #232] // create frame record; mov x1, #2 // set x1 to a constant indicating the type of failure; adrp x16, :got:__hwasan_tag_mismatch_v2 // call runtime function to save remaining registers and report error; ldr x16, [x16, :got_lo12:__hwasan_tag_mismatch_v2] // (load address from GOT to avoid potential register clobbers in delay load handler); br x16. Heap; ----. Tagging the heap memory/pointers is done by `malloc`.; This can be based on any malloc that forces all objects to be TG-aligned.; `free` tags the memory with a different tag. Stack; -----. Stack frames are instrumented by aligning all non-promotable allocas; by `TG` and tagging stack memory in function prologue and epilogue. Tags for different allocas in one function are **not** generated; independently; doing that in a function with `M` allocas would require; maintaining `M` live stack pointers, significantly increasing register; pressure. Instead we generate a single base tag value in the prologue,; and build the tag for alloca number `M` as `ReTag(BaseTag, M)`, where; ReTag can be as simple as exclusive-or with constant `M`. Stack instrument",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:5329,Performance,load,load,5329," x30, x20, [sp], #16; ret. [...]; __hwasan_check_x0_2_short_v2:; sbfx x16, x0, #4, #52 // shadow offset; ldrb w16, [x20, x16] // load shadow tag; cmp x16, x0, lsr #56 // extract address tag, compare with shadow tag; b.ne .Ltmp0 // jump to short tag handler on mismatch; .Ltmp1:; ret; .Ltmp0:; cmp w16, #15 // is this a short tag?; b.hi .Ltmp2 // if not, error; and x17, x0, #0xf // find the address's position in the short granule; add x17, x17, #3 // adjust to the position of the last byte loaded; cmp w16, w17 // check that position is in bounds; b.ls .Ltmp2 // if not, error; orr x16, x0, #0xf // compute address of last byte of granule; ldrb w16, [x16] // load tag from it; cmp x16, x0, lsr #56 // compare with pointer tag; b.eq .Ltmp1 // if matches, continue; .Ltmp2:; stp x0, x1, [sp, #-256]! // save original x0, x1 on stack (they will be overwritten); stp x29, x30, [sp, #232] // create frame record; mov x1, #2 // set x1 to a constant indicating the type of failure; adrp x16, :got:__hwasan_tag_mismatch_v2 // call runtime function to save remaining registers and report error; ldr x16, [x16, :got_lo12:__hwasan_tag_mismatch_v2] // (load address from GOT to avoid potential register clobbers in delay load handler); br x16. Heap; ----. Tagging the heap memory/pointers is done by `malloc`.; This can be based on any malloc that forces all objects to be TG-aligned.; `free` tags the memory with a different tag. Stack; -----. Stack frames are instrumented by aligning all non-promotable allocas; by `TG` and tagging stack memory in function prologue and epilogue. Tags for different allocas in one function are **not** generated; independently; doing that in a function with `M` allocas would require; maintaining `M` live stack pointers, significantly increasing register; pressure. Instead we generate a single base tag value in the prologue,; and build the tag for alloca number `M` as `ReTag(BaseTag, M)`, where; ReTag can be as simple as exclusive-or with constant `M`. Stack instrument",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:7428,Performance,load,loaded,7428,"ciated with it. The first; defined global in a translation unit has a pseudorandom tag associated; with it, based on the hash of the file path. Subsequent global tags are; incremental from the previously-assigned tag. * The global's tag is added to its symbol address in the object file's symbol; table. This causes the global's address to be tagged when its address is; taken. * When the address of a global is taken directly (i.e. not via the GOT), a special; instruction sequence needs to be used to add the tag to the address,; because the tag would otherwise take the address outside of the small code; model (4GB on AArch64). No changes are required when the address is taken; via the GOT because the address stored in the GOT will contain the tag. * An associated ``hwasan_globals`` section is emitted for each tagged global,; which indicates the address of the global, its size and its tag. These; sections are concatenated by the linker into a single ``hwasan_globals``; section that is enumerated by the runtime (via an ELF note) when a binary; is loaded and the memory is tagged accordingly. A complete example is given below:. .. code-block:: none. // int x = 1; int *f() { return &x; }; // clang -O2 --target=aarch64-linux-android30 -fsanitize=hwaddress -S -o - global.c. [...]; f:; adrp x0, :pg_hi21_nc:x // set bits 12-63 to upper bits of untagged address; movk x0, #:prel_g3:x+0x100000000 // set bits 48-63 to tag; add x0, x0, :lo12:x // set bits 0-11 to lower bits of address; ret. [...]; .data; .Lx.hwasan:; .word 1. .globl x; .set x, .Lx.hwasan+0x2d00000000000000. [...]; .section .note.hwasan.globals,""aG"",@note,hwasan.module_ctor,comdat; .Lhwasan.note:; .word 8 // namesz; .word 8 // descsz; .word 3 // NT_LLVM_HWASAN_GLOBALS; .asciz ""LLVM\000\000\000""; .word __start_hwasan_globals-.Lhwasan.note; .word __stop_hwasan_globals-.Lhwasan.note. [...]; .section hwasan_globals,""ao"",@progbits,.Lx.hwasan,unique,2; .Lx.hwasan.descriptor:; .word .Lx.hwasan-.Lx.hwasan.descriptor; .word 0",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:9473,Performance,load,load,9473,"ated by the `HLT` instruction and are handled by a signal handler. Attribute; ---------. HWASAN uses its own LLVM IR Attribute `sanitize_hwaddress` and a matching; C function attribute. An alternative would be to re-use ASAN's attribute; `sanitize_address`. The reasons to use a separate attribute are:. * Users may need to disable ASAN but not HWASAN, or vise versa,; because the tools have different trade-offs and compatibility issues.; * LLVM (ideally) does not use flags to decide which pass is being used,; ASAN or HWASAN are being applied, based on the function attributes. This does mean that users of HWASAN may need to add the new attribute; to the code that already uses the old attribute. Comparison with AddressSanitizer; ================================. HWASAN:; * Is less portable than :doc:`AddressSanitizer`; as it relies on hardware `Address Tagging`_ (AArch64).; Address Tagging can be emulated with compiler instrumentation,; but it will require the instrumentation to remove the tags before; any load or store, which is infeasible in any realistic environment; that contains non-instrumented code.; * May have compatibility problems if the target code uses higher; pointer bits for other purposes.; * May require changes in the OS kernels (e.g. Linux seems to dislike; tagged pointers passed from address space:; https://www.kernel.org/doc/Documentation/arm64/tagged-pointers.txt).; * **Does not require redzones to detect buffer overflows**,; but the buffer overflow detection is probabilistic, with roughly; `1/(2**TS)` chance of missing a bug (6.25% or 0.39% with 4 and 8-bit TS; respectively).; * **Does not require quarantine to detect heap-use-after-free,; or stack-use-after-return**.; The detection is similarly probabilistic. The memory overhead of HWASAN is expected to be much smaller; than that of AddressSanitizer:; `1/TG` extra memory for the shadow; and some overhead due to `TG`-aligning all objects. Supported architectures; =======================; HWASAN reli",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:10604,Performance,load,load,10604," higher; pointer bits for other purposes.; * May require changes in the OS kernels (e.g. Linux seems to dislike; tagged pointers passed from address space:; https://www.kernel.org/doc/Documentation/arm64/tagged-pointers.txt).; * **Does not require redzones to detect buffer overflows**,; but the buffer overflow detection is probabilistic, with roughly; `1/(2**TS)` chance of missing a bug (6.25% or 0.39% with 4 and 8-bit TS; respectively).; * **Does not require quarantine to detect heap-use-after-free,; or stack-use-after-return**.; The detection is similarly probabilistic. The memory overhead of HWASAN is expected to be much smaller; than that of AddressSanitizer:; `1/TG` extra memory for the shadow; and some overhead due to `TG`-aligning all objects. Supported architectures; =======================; HWASAN relies on `Address Tagging`_ which is only available on AArch64.; For other 64-bit architectures it is possible to remove the address tags; before every load and store by compiler instrumentation, but this variant; will have limited deployability since not all of the code is; typically instrumented. On x86_64, HWASAN utilizes page aliasing to place tags in userspace address; bits. Currently only heap tagging is supported. The page aliases rely on; shared memory, which will cause heap memory to be shared between processes if; the application calls ``fork()``. Therefore x86_64 is really only safe for; applications that do not fork. HWASAN does not currently support 32-bit architectures since they do not; support `Address Tagging`_ and the address space is too constrained to easily; implement page aliasing. Related Work; ============; * `SPARC ADI`_ implements a similar tool mostly in hardware.; * `Effective and Efficient Memory Protection Using Dynamic Tainting`_ discusses; similar approaches (""lock & key"").; * `Watchdog`_ discussed a heavier, but still somewhat similar; ""lock & key"" approach.; * *TODO: add more ""related work"" links. Suggestions are welcome.*. .. _W",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:963,Safety,safe,safety,963,"================================================; Hardware-assisted AddressSanitizer Design Documentation; =======================================================. This page is a design document for; **hardware-assisted AddressSanitizer** (or **HWASAN**); a tool similar to :doc:`AddressSanitizer`,; but based on partial hardware assistance. Introduction; ============. :doc:`AddressSanitizer`; tags every 8 bytes of the application memory with a 1 byte tag (using *shadow memory*),; uses *redzones* to find buffer-overflows and; *quarantine* to find use-after-free.; The redzones, the quarantine, and, to a less extent, the shadow, are the; sources of AddressSanitizer's memory overhead.; See the `AddressSanitizer paper`_ for details. AArch64 has `Address Tagging`_ (or top-byte-ignore, TBI), a hardware feature that allows; software to use the 8 most significant bits of a 64-bit pointer as; a tag. HWASAN uses `Address Tagging`_; to implement a memory safety tool, similar to :doc:`AddressSanitizer`,; but with smaller memory overhead and slightly different (mostly better); accuracy guarantees. Intel's `Linear Address Masking`_ (LAM) also provides address tagging for; x86_64, though it is not widely available in hardware yet. For x86_64, HWASAN; has a limited implementation using page aliasing instead. Algorithm; =========; * Every heap/stack/global memory object is forcibly aligned by `TG` bytes; (`TG` is e.g. 16 or 64). We call `TG` the **tagging granularity**.; * For every such object a random `TS`-bit tag `T` is chosen (`TS`, or tag size, is e.g. 4 or 8); * The pointer to the object is tagged with `T`.; * The memory for the object is also tagged with `T` (using a `TG=>1` shadow memory); * Every load and store is instrumented to read the memory tag and compare it; with the pointer tag, exception is raised on tag mismatch. For a more detailed discussion of this approach see https://arxiv.org/pdf/1802.09517.pdf. Short granules; --------------. A short granule is a granule of s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:2960,Safety,detect,detects,2960,"een 1 and `TG-1` bytes. The size; of a short granule is stored at the location in shadow memory where the; granule's tag is normally stored, while the granule's actual tag is stored; in the last byte of the granule. This means that in order to verify that a; pointer tag matches a memory tag, HWASAN must check for two possibilities:. * the pointer tag is equal to the memory tag in shadow memory, or; * the shadow memory tag is actually a short granule size, the value being loaded; is in bounds of the granule and the pointer tag is equal to the last byte of; the granule. Pointer tags between 1 to `TG-1` are possible and are as likely as any other; tag. This means that these tags in memory have two interpretations: the full; tag interpretation (where the pointer tag is between 1 and `TG-1` and the; last byte of the granule is ordinary data) and the short tag interpretation; (where the pointer tag is stored in the granule). When HWASAN detects an error near a memory tag between 1 and `TG-1`, it; will show both the memory tag and the last byte of the granule. Currently,; it is up to the user to disambiguate the two possibilities. Instrumentation; ===============. Memory Accesses; ---------------; In the majority of cases, memory accesses are prefixed with a call to; an outlined instruction sequence that verifies the tags. The code size; and performance overhead of the call is reduced by using a custom calling; convention that. * preserves most registers, and; * is specialized to the register containing the address, and the type and; size of the memory access. Currently, the following sequence is used:. .. code-block:: none. // int foo(int *a) { return *a; }; // clang -O2 --target=aarch64-linux-android30 -fsanitize=hwaddress -S -o - load.c; [...]; foo:; stp x30, x20, [sp, #-16]!; adrp x20, :got:__hwasan_shadow // load shadow address from GOT into x20; ldr x20, [x20, :got_lo12:__hwasan_shadow]; bl __hwasan_check_x0_2_short_v2 // call outlined tag check; // (arguments: x0 = a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:5286,Safety,avoid,avoid,5286," x30, x20, [sp], #16; ret. [...]; __hwasan_check_x0_2_short_v2:; sbfx x16, x0, #4, #52 // shadow offset; ldrb w16, [x20, x16] // load shadow tag; cmp x16, x0, lsr #56 // extract address tag, compare with shadow tag; b.ne .Ltmp0 // jump to short tag handler on mismatch; .Ltmp1:; ret; .Ltmp0:; cmp w16, #15 // is this a short tag?; b.hi .Ltmp2 // if not, error; and x17, x0, #0xf // find the address's position in the short granule; add x17, x17, #3 // adjust to the position of the last byte loaded; cmp w16, w17 // check that position is in bounds; b.ls .Ltmp2 // if not, error; orr x16, x0, #0xf // compute address of last byte of granule; ldrb w16, [x16] // load tag from it; cmp x16, x0, lsr #56 // compare with pointer tag; b.eq .Ltmp1 // if matches, continue; .Ltmp2:; stp x0, x1, [sp, #-256]! // save original x0, x1 on stack (they will be overwritten); stp x29, x30, [sp, #232] // create frame record; mov x1, #2 // set x1 to a constant indicating the type of failure; adrp x16, :got:__hwasan_tag_mismatch_v2 // call runtime function to save remaining registers and report error; ldr x16, [x16, :got_lo12:__hwasan_tag_mismatch_v2] // (load address from GOT to avoid potential register clobbers in delay load handler); br x16. Heap; ----. Tagging the heap memory/pointers is done by `malloc`.; This can be based on any malloc that forces all objects to be TG-aligned.; `free` tags the memory with a different tag. Stack; -----. Stack frames are instrumented by aligning all non-promotable allocas; by `TG` and tagging stack memory in function prologue and epilogue. Tags for different allocas in one function are **not** generated; independently; doing that in a function with `M` allocas would require; maintaining `M` live stack pointers, significantly increasing register; pressure. Instead we generate a single base tag value in the prologue,; and build the tag for alloca number `M` as `ReTag(BaseTag, M)`, where; ReTag can be as simple as exclusive-or with constant `M`. Stack instrument",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:9893,Safety,detect,detect,9893,"hich pass is being used,; ASAN or HWASAN are being applied, based on the function attributes. This does mean that users of HWASAN may need to add the new attribute; to the code that already uses the old attribute. Comparison with AddressSanitizer; ================================. HWASAN:; * Is less portable than :doc:`AddressSanitizer`; as it relies on hardware `Address Tagging`_ (AArch64).; Address Tagging can be emulated with compiler instrumentation,; but it will require the instrumentation to remove the tags before; any load or store, which is infeasible in any realistic environment; that contains non-instrumented code.; * May have compatibility problems if the target code uses higher; pointer bits for other purposes.; * May require changes in the OS kernels (e.g. Linux seems to dislike; tagged pointers passed from address space:; https://www.kernel.org/doc/Documentation/arm64/tagged-pointers.txt).; * **Does not require redzones to detect buffer overflows**,; but the buffer overflow detection is probabilistic, with roughly; `1/(2**TS)` chance of missing a bug (6.25% or 0.39% with 4 and 8-bit TS; respectively).; * **Does not require quarantine to detect heap-use-after-free,; or stack-use-after-return**.; The detection is similarly probabilistic. The memory overhead of HWASAN is expected to be much smaller; than that of AddressSanitizer:; `1/TG` extra memory for the shadow; and some overhead due to `TG`-aligning all objects. Supported architectures; =======================; HWASAN relies on `Address Tagging`_ which is only available on AArch64.; For other 64-bit architectures it is possible to remove the address tags; before every load and store by compiler instrumentation, but this variant; will have limited deployability since not all of the code is; typically instrumented. On x86_64, HWASAN utilizes page aliasing to place tags in userspace address; bits. Currently only heap tagging is supported. The page aliases rely on; shared memory, which will cause heap me",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:9945,Safety,detect,detection,9945,"hich pass is being used,; ASAN or HWASAN are being applied, based on the function attributes. This does mean that users of HWASAN may need to add the new attribute; to the code that already uses the old attribute. Comparison with AddressSanitizer; ================================. HWASAN:; * Is less portable than :doc:`AddressSanitizer`; as it relies on hardware `Address Tagging`_ (AArch64).; Address Tagging can be emulated with compiler instrumentation,; but it will require the instrumentation to remove the tags before; any load or store, which is infeasible in any realistic environment; that contains non-instrumented code.; * May have compatibility problems if the target code uses higher; pointer bits for other purposes.; * May require changes in the OS kernels (e.g. Linux seems to dislike; tagged pointers passed from address space:; https://www.kernel.org/doc/Documentation/arm64/tagged-pointers.txt).; * **Does not require redzones to detect buffer overflows**,; but the buffer overflow detection is probabilistic, with roughly; `1/(2**TS)` chance of missing a bug (6.25% or 0.39% with 4 and 8-bit TS; respectively).; * **Does not require quarantine to detect heap-use-after-free,; or stack-use-after-return**.; The detection is similarly probabilistic. The memory overhead of HWASAN is expected to be much smaller; than that of AddressSanitizer:; `1/TG` extra memory for the shadow; and some overhead due to `TG`-aligning all objects. Supported architectures; =======================; HWASAN relies on `Address Tagging`_ which is only available on AArch64.; For other 64-bit architectures it is possible to remove the address tags; before every load and store by compiler instrumentation, but this variant; will have limited deployability since not all of the code is; typically instrumented. On x86_64, HWASAN utilizes page aliasing to place tags in userspace address; bits. Currently only heap tagging is supported. The page aliases rely on; shared memory, which will cause heap me",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:10111,Safety,detect,detect,10111,"at already uses the old attribute. Comparison with AddressSanitizer; ================================. HWASAN:; * Is less portable than :doc:`AddressSanitizer`; as it relies on hardware `Address Tagging`_ (AArch64).; Address Tagging can be emulated with compiler instrumentation,; but it will require the instrumentation to remove the tags before; any load or store, which is infeasible in any realistic environment; that contains non-instrumented code.; * May have compatibility problems if the target code uses higher; pointer bits for other purposes.; * May require changes in the OS kernels (e.g. Linux seems to dislike; tagged pointers passed from address space:; https://www.kernel.org/doc/Documentation/arm64/tagged-pointers.txt).; * **Does not require redzones to detect buffer overflows**,; but the buffer overflow detection is probabilistic, with roughly; `1/(2**TS)` chance of missing a bug (6.25% or 0.39% with 4 and 8-bit TS; respectively).; * **Does not require quarantine to detect heap-use-after-free,; or stack-use-after-return**.; The detection is similarly probabilistic. The memory overhead of HWASAN is expected to be much smaller; than that of AddressSanitizer:; `1/TG` extra memory for the shadow; and some overhead due to `TG`-aligning all objects. Supported architectures; =======================; HWASAN relies on `Address Tagging`_ which is only available on AArch64.; For other 64-bit architectures it is possible to remove the address tags; before every load and store by compiler instrumentation, but this variant; will have limited deployability since not all of the code is; typically instrumented. On x86_64, HWASAN utilizes page aliasing to place tags in userspace address; bits. Currently only heap tagging is supported. The page aliases rely on; shared memory, which will cause heap memory to be shared between processes if; the application calls ``fork()``. Therefore x86_64 is really only safe for; applications that do not fork. HWASAN does not currently suppor",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:10174,Safety,detect,detection,10174," ================================. HWASAN:; * Is less portable than :doc:`AddressSanitizer`; as it relies on hardware `Address Tagging`_ (AArch64).; Address Tagging can be emulated with compiler instrumentation,; but it will require the instrumentation to remove the tags before; any load or store, which is infeasible in any realistic environment; that contains non-instrumented code.; * May have compatibility problems if the target code uses higher; pointer bits for other purposes.; * May require changes in the OS kernels (e.g. Linux seems to dislike; tagged pointers passed from address space:; https://www.kernel.org/doc/Documentation/arm64/tagged-pointers.txt).; * **Does not require redzones to detect buffer overflows**,; but the buffer overflow detection is probabilistic, with roughly; `1/(2**TS)` chance of missing a bug (6.25% or 0.39% with 4 and 8-bit TS; respectively).; * **Does not require quarantine to detect heap-use-after-free,; or stack-use-after-return**.; The detection is similarly probabilistic. The memory overhead of HWASAN is expected to be much smaller; than that of AddressSanitizer:; `1/TG` extra memory for the shadow; and some overhead due to `TG`-aligning all objects. Supported architectures; =======================; HWASAN relies on `Address Tagging`_ which is only available on AArch64.; For other 64-bit architectures it is possible to remove the address tags; before every load and store by compiler instrumentation, but this variant; will have limited deployability since not all of the code is; typically instrumented. On x86_64, HWASAN utilizes page aliasing to place tags in userspace address; bits. Currently only heap tagging is supported. The page aliases rely on; shared memory, which will cause heap memory to be shared between processes if; the application calls ``fork()``. Therefore x86_64 is really only safe for; applications that do not fork. HWASAN does not currently support 32-bit architectures since they do not; support `Address Tagging`_ ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:11048,Safety,safe,safe,11048,"-bit TS; respectively).; * **Does not require quarantine to detect heap-use-after-free,; or stack-use-after-return**.; The detection is similarly probabilistic. The memory overhead of HWASAN is expected to be much smaller; than that of AddressSanitizer:; `1/TG` extra memory for the shadow; and some overhead due to `TG`-aligning all objects. Supported architectures; =======================; HWASAN relies on `Address Tagging`_ which is only available on AArch64.; For other 64-bit architectures it is possible to remove the address tags; before every load and store by compiler instrumentation, but this variant; will have limited deployability since not all of the code is; typically instrumented. On x86_64, HWASAN utilizes page aliasing to place tags in userspace address; bits. Currently only heap tagging is supported. The page aliases rely on; shared memory, which will cause heap memory to be shared between processes if; the application calls ``fork()``. Therefore x86_64 is really only safe for; applications that do not fork. HWASAN does not currently support 32-bit architectures since they do not; support `Address Tagging`_ and the address space is too constrained to easily; implement page aliasing. Related Work; ============; * `SPARC ADI`_ implements a similar tool mostly in hardware.; * `Effective and Efficient Memory Protection Using Dynamic Tainting`_ discusses; similar approaches (""lock & key"").; * `Watchdog`_ discussed a heavier, but still somewhat similar; ""lock & key"" approach.; * *TODO: add more ""related work"" links. Suggestions are welcome.*. .. _Watchdog: https://www.cis.upenn.edu/acg/papers/isca12_watchdog.pdf; .. _Effective and Efficient Memory Protection Using Dynamic Tainting: https://www.cc.gatech.edu/~orso/papers/clause.doudalis.orso.prvulovic.pdf; .. _SPARC ADI: https://lazytyped.blogspot.com/2017/09/getting-started-with-adi.html; .. _AddressSanitizer paper: https://www.usenix.org/system/files/conference/atc12/atc12-final39.pdf; .. _Address Tagging: h",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:3258,Security,access,accesses,3258,"a; pointer tag matches a memory tag, HWASAN must check for two possibilities:. * the pointer tag is equal to the memory tag in shadow memory, or; * the shadow memory tag is actually a short granule size, the value being loaded; is in bounds of the granule and the pointer tag is equal to the last byte of; the granule. Pointer tags between 1 to `TG-1` are possible and are as likely as any other; tag. This means that these tags in memory have two interpretations: the full; tag interpretation (where the pointer tag is between 1 and `TG-1` and the; last byte of the granule is ordinary data) and the short tag interpretation; (where the pointer tag is stored in the granule). When HWASAN detects an error near a memory tag between 1 and `TG-1`, it; will show both the memory tag and the last byte of the granule. Currently,; it is up to the user to disambiguate the two possibilities. Instrumentation; ===============. Memory Accesses; ---------------; In the majority of cases, memory accesses are prefixed with a call to; an outlined instruction sequence that verifies the tags. The code size; and performance overhead of the call is reduced by using a custom calling; convention that. * preserves most registers, and; * is specialized to the register containing the address, and the type and; size of the memory access. Currently, the following sequence is used:. .. code-block:: none. // int foo(int *a) { return *a; }; // clang -O2 --target=aarch64-linux-android30 -fsanitize=hwaddress -S -o - load.c; [...]; foo:; stp x30, x20, [sp, #-16]!; adrp x20, :got:__hwasan_shadow // load shadow address from GOT into x20; ldr x20, [x20, :got_lo12:__hwasan_shadow]; bl __hwasan_check_x0_2_short_v2 // call outlined tag check; // (arguments: x0 = address, x20 = shadow base;; // ""2"" encodes the access type and size); ldr w0, [x0] // inline load; ldp x30, x20, [sp], #16; ret. [...]; __hwasan_check_x0_2_short_v2:; sbfx x16, x0, #4, #52 // shadow offset; ldrb w16, [x20, x16] // load shadow tag; cmp x16",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:3587,Security,access,access,3587," and the pointer tag is equal to the last byte of; the granule. Pointer tags between 1 to `TG-1` are possible and are as likely as any other; tag. This means that these tags in memory have two interpretations: the full; tag interpretation (where the pointer tag is between 1 and `TG-1` and the; last byte of the granule is ordinary data) and the short tag interpretation; (where the pointer tag is stored in the granule). When HWASAN detects an error near a memory tag between 1 and `TG-1`, it; will show both the memory tag and the last byte of the granule. Currently,; it is up to the user to disambiguate the two possibilities. Instrumentation; ===============. Memory Accesses; ---------------; In the majority of cases, memory accesses are prefixed with a call to; an outlined instruction sequence that verifies the tags. The code size; and performance overhead of the call is reduced by using a custom calling; convention that. * preserves most registers, and; * is specialized to the register containing the address, and the type and; size of the memory access. Currently, the following sequence is used:. .. code-block:: none. // int foo(int *a) { return *a; }; // clang -O2 --target=aarch64-linux-android30 -fsanitize=hwaddress -S -o - load.c; [...]; foo:; stp x30, x20, [sp, #-16]!; adrp x20, :got:__hwasan_shadow // load shadow address from GOT into x20; ldr x20, [x20, :got_lo12:__hwasan_shadow]; bl __hwasan_check_x0_2_short_v2 // call outlined tag check; // (arguments: x0 = address, x20 = shadow base;; // ""2"" encodes the access type and size); ldr w0, [x0] // inline load; ldp x30, x20, [sp], #16; ret. [...]; __hwasan_check_x0_2_short_v2:; sbfx x16, x0, #4, #52 // shadow offset; ldrb w16, [x20, x16] // load shadow tag; cmp x16, x0, lsr #56 // extract address tag, compare with shadow tag; b.ne .Ltmp0 // jump to short tag handler on mismatch; .Ltmp1:; ret; .Ltmp0:; cmp w16, #15 // is this a short tag?; b.hi .Ltmp2 // if not, error; and x17, x0, #0xf // find the address's position",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:4063,Security,access,access,4063,"ects an error near a memory tag between 1 and `TG-1`, it; will show both the memory tag and the last byte of the granule. Currently,; it is up to the user to disambiguate the two possibilities. Instrumentation; ===============. Memory Accesses; ---------------; In the majority of cases, memory accesses are prefixed with a call to; an outlined instruction sequence that verifies the tags. The code size; and performance overhead of the call is reduced by using a custom calling; convention that. * preserves most registers, and; * is specialized to the register containing the address, and the type and; size of the memory access. Currently, the following sequence is used:. .. code-block:: none. // int foo(int *a) { return *a; }; // clang -O2 --target=aarch64-linux-android30 -fsanitize=hwaddress -S -o - load.c; [...]; foo:; stp x30, x20, [sp, #-16]!; adrp x20, :got:__hwasan_shadow // load shadow address from GOT into x20; ldr x20, [x20, :got_lo12:__hwasan_shadow]; bl __hwasan_check_x0_2_short_v2 // call outlined tag check; // (arguments: x0 = address, x20 = shadow base;; // ""2"" encodes the access type and size); ldr w0, [x0] // inline load; ldp x30, x20, [sp], #16; ret. [...]; __hwasan_check_x0_2_short_v2:; sbfx x16, x0, #4, #52 // shadow offset; ldrb w16, [x20, x16] // load shadow tag; cmp x16, x0, lsr #56 // extract address tag, compare with shadow tag; b.ne .Ltmp0 // jump to short tag handler on mismatch; .Ltmp1:; ret; .Ltmp0:; cmp w16, #15 // is this a short tag?; b.hi .Ltmp2 // if not, error; and x17, x0, #0xf // find the address's position in the short granule; add x17, x17, #3 // adjust to the position of the last byte loaded; cmp w16, w17 // check that position is in bounds; b.ls .Ltmp2 // if not, error; orr x16, x0, #0xf // compute address of last byte of granule; ldrb w16, [x16] // load tag from it; cmp x16, x0, lsr #56 // compare with pointer tag; b.eq .Ltmp1 // if matches, continue; .Ltmp2:; stp x0, x1, [sp, #-256]! // save original x0, x1 on stack (they will be",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:6491,Security,hash,hash,6491,"c that forces all objects to be TG-aligned.; `free` tags the memory with a different tag. Stack; -----. Stack frames are instrumented by aligning all non-promotable allocas; by `TG` and tagging stack memory in function prologue and epilogue. Tags for different allocas in one function are **not** generated; independently; doing that in a function with `M` allocas would require; maintaining `M` live stack pointers, significantly increasing register; pressure. Instead we generate a single base tag value in the prologue,; and build the tag for alloca number `M` as `ReTag(BaseTag, M)`, where; ReTag can be as simple as exclusive-or with constant `M`. Stack instrumentation is expected to be a major source of overhead,; but could be optional. Globals; -------. Most globals in HWASAN instrumented code are tagged. This is accomplished; using the following mechanisms:. * The address of each global has a static tag associated with it. The first; defined global in a translation unit has a pseudorandom tag associated; with it, based on the hash of the file path. Subsequent global tags are; incremental from the previously-assigned tag. * The global's tag is added to its symbol address in the object file's symbol; table. This causes the global's address to be tagged when its address is; taken. * When the address of a global is taken directly (i.e. not via the GOT), a special; instruction sequence needs to be used to add the tag to the address,; because the tag would otherwise take the address outside of the small code; model (4GB on AArch64). No changes are required when the address is taken; via the GOT because the address stored in the GOT will contain the tag. * An associated ``hwasan_globals`` section is emitted for each tagged global,; which indicates the address of the global, its size and its tag. These; sections are concatenated by the linker into a single ``hwasan_globals``; section that is enumerated by the runtime (via an ELF note) when a binary; is loaded and the memory",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:6060,Usability,simpl,simple,6060,"/ create frame record; mov x1, #2 // set x1 to a constant indicating the type of failure; adrp x16, :got:__hwasan_tag_mismatch_v2 // call runtime function to save remaining registers and report error; ldr x16, [x16, :got_lo12:__hwasan_tag_mismatch_v2] // (load address from GOT to avoid potential register clobbers in delay load handler); br x16. Heap; ----. Tagging the heap memory/pointers is done by `malloc`.; This can be based on any malloc that forces all objects to be TG-aligned.; `free` tags the memory with a different tag. Stack; -----. Stack frames are instrumented by aligning all non-promotable allocas; by `TG` and tagging stack memory in function prologue and epilogue. Tags for different allocas in one function are **not** generated; independently; doing that in a function with `M` allocas would require; maintaining `M` live stack pointers, significantly increasing register; pressure. Instead we generate a single base tag value in the prologue,; and build the tag for alloca number `M` as `ReTag(BaseTag, M)`, where; ReTag can be as simple as exclusive-or with constant `M`. Stack instrumentation is expected to be a major source of overhead,; but could be optional. Globals; -------. Most globals in HWASAN instrumented code are tagged. This is accomplished; using the following mechanisms:. * The address of each global has a static tag associated with it. The first; defined global in a translation unit has a pseudorandom tag associated; with it, based on the hash of the file path. Subsequent global tags are; incremental from the previously-assigned tag. * The global's tag is added to its symbol address in the object file's symbol; table. This causes the global's address to be tagged when its address is; taken. * When the address of a global is taken directly (i.e. not via the GOT), a special; instruction sequence needs to be used to add the tag to the address,; because the tag would otherwise take the address outside of the small code; model (4GB on AArch64). No c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:1945,Availability,avail,available,1945,"d code is then bundled and embedded in the host executables. Intel GPU Support; =================. Clang provides partial HIP support on Intel GPUs using the CHIP-Star project `<https://github.com/CHIP-SPV/chipStar>`_.; CHIP-Star implements the HIP runtime over oneAPI Level Zero or OpenCL runtime. The Clang driver uses the HIPSPV; toolchain to compile HIP device code into LLVM IR, which is subsequently translated to SPIR-V via the SPIR-V; backend or the out-of-tree LLVM-SPIRV translator. The SPIR-V is then bundled and embedded into the host executables. .. note::; While Clang does not directly provide HIP support for NVIDIA GPUs and CPUs, these platforms are supported via other means:. - NVIDIA GPUs: HIP support is offered through the HIP project `<https://github.com/ROCm-Developer-Tools/HIP>`_, which provides a header-only library for translating HIP runtime APIs into CUDA runtime APIs. The code is subsequently compiled using NVIDIA's `nvcc`. - CPUs: HIP support is available through the HIP-CPU runtime library `<https://github.com/ROCm-Developer-Tools/HIP-CPU>`_. This header-only library enables CPUs to execute unmodified HIP code. Example Usage; =============. To compile a HIP program, use the following command:. .. code-block:: shell. clang++ -c --offload-arch=gfx906 -xhip sample.cpp -o sample.o. The ``-xhip`` option indicates that the source is a HIP program. If the file has a ``.hip`` extension,; Clang will automatically recognize it as a HIP program:. .. code-block:: shell. clang++ -c --offload-arch=gfx906 sample.hip -o sample.o. To link a HIP program, use this command:. .. code-block:: shell. clang++ --hip-link --offload-arch=gfx906 sample.o -o sample. In the above command, the ``--hip-link`` flag instructs Clang to link the HIP runtime library. However,; the use of this flag is unnecessary if a HIP input file is already present in your program. For convenience, Clang also supports compiling and linking in a single step:. .. code-block:: shell. clang++ --offlo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HIPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:3904,Deployability,install,installation,3904,"ts compiling and linking in a single step:. .. code-block:: shell. clang++ --offload-arch=gfx906 -xhip sample.cpp -o sample. In the above commands, ``gfx906`` is the GPU architecture that the code is being compiled for. The supported GPU; architectures can be found in the `AMDGPU Processor Table <https://llvm.org/docs/AMDGPUUsage.html#processors>`_.; Alternatively, you can use the ``amdgpu-arch`` tool that comes with Clang to list the GPU architecture on your system:. .. code-block:: shell. amdgpu-arch. You can use ``--offload-arch=native`` to automatically detect the GPU architectures on your system:. .. code-block:: shell. clang++ --offload-arch=native -xhip sample.cpp -o sample. Path Setting for Dependencies; =============================. Compiling a HIP program depends on the HIP runtime and device library. The paths to the HIP runtime and device libraries; can be specified either using compiler options or environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation pa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HIPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:4269,Deployability,install,installation,4269,"vely, you can use the ``amdgpu-arch`` tool that comes with Clang to list the GPU architecture on your system:. .. code-block:: shell. amdgpu-arch. You can use ``--offload-arch=native`` to automatically detect the GPU architectures on your system:. .. code-block:: shell. clang++ --offload-arch=native -xhip sample.cpp -o sample. Path Setting for Dependencies; =============================. Compiling a HIP program depends on the HIP runtime and device library. The paths to the HIP runtime and device libraries; can be specified either using compiler options or environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - Determined by ROCm directory structure. .. note::. We recommend using the comp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HIPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:4668,Deployability,install,installation,4668,"g a HIP program depends on the HIP runtime and device library. The paths to the HIP runtime and device libraries; can be specified either using compiler options or environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - Determined by ROCm directory structure. .. note::. We recommend using the compiler options as the primary method for specifying these paths. While the environment variables ``ROCM_PATH``, ``HIP_PATH``, and ``HIP_DEVICE_LIB_PATH`` are supported, their use can lead to implicit dependencies that might cause issues in the long run. Use them with caution. Predefined Macros; =================. .. list-table::; :header-rows: 1. * - Macro; - Description; * - ``__CLANG_RDC__``; - D",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HIPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:4869,Deployability,install,installation,4869,"r environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - Determined by ROCm directory structure. .. note::. We recommend using the compiler options as the primary method for specifying these paths. While the environment variables ``ROCM_PATH``, ``HIP_PATH``, and ``HIP_DEVICE_LIB_PATH`` are supported, their use can lead to implicit dependencies that might cause issues in the long run. Use them with caution. Predefined Macros; =================. .. list-table::; :header-rows: 1. * - Macro; - Description; * - ``__CLANG_RDC__``; - Defined when Clang is compiling code in Relocatable Device Code (RDC) mode. RDC, enabled with the ``-fgpu-rdc`` compiler option, is necessary for linking device co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HIPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:4983,Deployability,install,installation,4983,"of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - Determined by ROCm directory structure. .. note::. We recommend using the compiler options as the primary method for specifying these paths. While the environment variables ``ROCM_PATH``, ``HIP_PATH``, and ``HIP_DEVICE_LIB_PATH`` are supported, their use can lead to implicit dependencies that might cause issues in the long run. Use them with caution. Predefined Macros; =================. .. list-table::; :header-rows: 1. * - Macro; - Description; * - ``__CLANG_RDC__``; - Defined when Clang is compiling code in Relocatable Device Code (RDC) mode. RDC, enabled with the ``-fgpu-rdc`` compiler option, is necessary for linking device codes across translation units.; * - ``__HIP__``; - Defined when compiling with HIP language support, indicating that the code targets the H",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HIPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:5145,Deployability,install,installation,5145,"e with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - Determined by ROCm directory structure. .. note::. We recommend using the compiler options as the primary method for specifying these paths. While the environment variables ``ROCM_PATH``, ``HIP_PATH``, and ``HIP_DEVICE_LIB_PATH`` are supported, their use can lead to implicit dependencies that might cause issues in the long run. Use them with caution. Predefined Macros; =================. .. list-table::; :header-rows: 1. * - Macro; - Description; * - ``__CLANG_RDC__``; - Defined when Clang is compiling code in Relocatable Device Code (RDC) mode. RDC, enabled with the ``-fgpu-rdc`` compiler option, is necessary for linking device codes across translation units.; * - ``__HIP__``; - Defined when compiling with HIP language support, indicating that the code targets the HIP environment.; * - ``__HIPCC__``; - Alias to ``__HIP__``.; * - ``__HIP_DEVICE_COMPILE__``; - Defined during device code compilation in C",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HIPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:3660,Integrability,depend,depends,3660,"nd, the ``--hip-link`` flag instructs Clang to link the HIP runtime library. However,; the use of this flag is unnecessary if a HIP input file is already present in your program. For convenience, Clang also supports compiling and linking in a single step:. .. code-block:: shell. clang++ --offload-arch=gfx906 -xhip sample.cpp -o sample. In the above commands, ``gfx906`` is the GPU architecture that the code is being compiled for. The supported GPU; architectures can be found in the `AMDGPU Processor Table <https://llvm.org/docs/AMDGPUUsage.html#processors>`_.; Alternatively, you can use the ``amdgpu-arch`` tool that comes with Clang to list the GPU architecture on your system:. .. code-block:: shell. amdgpu-arch. You can use ``--offload-arch=native`` to automatically detect the GPU architectures on your system:. .. code-block:: shell. clang++ --offload-arch=native -xhip sample.cpp -o sample. Path Setting for Dependencies; =============================. Compiling a HIP program depends on the HIP runtime and device library. The paths to the HIP runtime and device libraries; can be specified either using compiler options or environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm ins",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HIPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:5443,Integrability,depend,dependencies,5443,"lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - Determined by ROCm directory structure. .. note::. We recommend using the compiler options as the primary method for specifying these paths. While the environment variables ``ROCM_PATH``, ``HIP_PATH``, and ``HIP_DEVICE_LIB_PATH`` are supported, their use can lead to implicit dependencies that might cause issues in the long run. Use them with caution. Predefined Macros; =================. .. list-table::; :header-rows: 1. * - Macro; - Description; * - ``__CLANG_RDC__``; - Defined when Clang is compiling code in Relocatable Device Code (RDC) mode. RDC, enabled with the ``-fgpu-rdc`` compiler option, is necessary for linking device codes across translation units.; * - ``__HIP__``; - Defined when compiling with HIP language support, indicating that the code targets the HIP environment.; * - ``__HIPCC__``; - Alias to ``__HIP__``.; * - ``__HIP_DEVICE_COMPILE__``; - Defined during device code compilation in Clang's separate compilation process for the host and each offloading GPU architecture.; * - ``__HIP_MEMORY_SCOPE_SINGLETHREAD``; - Represents single-thread memory scope in HIP (value is 1).; * - ``__HIP_MEMORY_SCOPE_WAVEFRONT``; - Represents wavefront memory scope in HIP (value is 2).; * - ``__HIP_MEMORY_SCOPE_WORKGROU",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HIPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:454,Modifiability,portab,portable,454,".. raw:: html. <style type=""text/css"">; .none { background-color: #FFCCCC }; .part { background-color: #FFFF99 }; .good { background-color: #CCFF99 }; </style>. .. role:: none; .. role:: part; .. role:: good. .. contents::; :local:. =============; HIP Support; =============. HIP (Heterogeneous-Compute Interface for Portability) `<https://github.com/ROCm-Developer-Tools/HIP>`_ is; a C++ Runtime API and Kernel Language. It enables developers to create portable applications for; offloading computation to different hardware platforms from a single source code. AMD GPU Support; ===============. Clang provides HIP support on AMD GPUs via the ROCm platform `<https://rocm.docs.amd.com/en/latest/#>`_.; The ROCm runtime forms the base for HIP host APIs, while HIP device APIs are realized through HIP header; files and the ROCm device library. The Clang driver uses the HIPAMD toolchain to compile HIP device code; to AMDGPU ISA via the AMDGPU backend. The compiled code is then bundled and embedded in the host executables. Intel GPU Support; =================. Clang provides partial HIP support on Intel GPUs using the CHIP-Star project `<https://github.com/CHIP-SPV/chipStar>`_.; CHIP-Star implements the HIP runtime over oneAPI Level Zero or OpenCL runtime. The Clang driver uses the HIPSPV; toolchain to compile HIP device code into LLVM IR, which is subsequently translated to SPIR-V via the SPIR-V; backend or the out-of-tree LLVM-SPIRV translator. The SPIR-V is then bundled and embedded into the host executables. .. note::; While Clang does not directly provide HIP support for NVIDIA GPUs and CPUs, these platforms are supported via other means:. - NVIDIA GPUs: HIP support is offered through the HIP project `<https://github.com/ROCm-Developer-Tools/HIP>`_, which provides a header-only library for translating HIP runtime APIs into CUDA runtime APIs. The code is subsequently compiled using NVIDIA's `nvcc`. - CPUs: HIP support is available through the HIP-CPU runtime library `<https://",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HIPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:3820,Modifiability,variab,variables,3820,"this flag is unnecessary if a HIP input file is already present in your program. For convenience, Clang also supports compiling and linking in a single step:. .. code-block:: shell. clang++ --offload-arch=gfx906 -xhip sample.cpp -o sample. In the above commands, ``gfx906`` is the GPU architecture that the code is being compiled for. The supported GPU; architectures can be found in the `AMDGPU Processor Table <https://llvm.org/docs/AMDGPUUsage.html#processors>`_.; Alternatively, you can use the ``amdgpu-arch`` tool that comes with Clang to list the GPU architecture on your system:. .. code-block:: shell. amdgpu-arch. You can use ``--offload-arch=native`` to automatically detect the GPU architectures on your system:. .. code-block:: shell. clang++ --offload-arch=native -xhip sample.cpp -o sample. Path Setting for Dependencies; =============================. Compiling a HIP program depends on the HIP runtime and device library. The paths to the HIP runtime and device libraries; can be specified either using compiler options or environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variabl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HIPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:4069,Modifiability,variab,variable,4069,"he code is being compiled for. The supported GPU; architectures can be found in the `AMDGPU Processor Table <https://llvm.org/docs/AMDGPUUsage.html#processors>`_.; Alternatively, you can use the ``amdgpu-arch`` tool that comes with Clang to list the GPU architecture on your system:. .. code-block:: shell. amdgpu-arch. You can use ``--offload-arch=native`` to automatically detect the GPU architectures on your system:. .. code-block:: shell. clang++ --offload-arch=native -xhip sample.cpp -o sample. Path Setting for Dependencies; =============================. Compiling a HIP program depends on the HIP runtime and device library. The paths to the HIP runtime and device libraries; can be specified either using compiler options or environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HIPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:4165,Modifiability,variab,variable,4165,"essor Table <https://llvm.org/docs/AMDGPUUsage.html#processors>`_.; Alternatively, you can use the ``amdgpu-arch`` tool that comes with Clang to list the GPU architecture on your system:. .. code-block:: shell. amdgpu-arch. You can use ``--offload-arch=native`` to automatically detect the GPU architectures on your system:. .. code-block:: shell. clang++ --offload-arch=native -xhip sample.cpp -o sample. Path Setting for Dependencies; =============================. Compiling a HIP program depends on the HIP runtime and device library. The paths to the HIP runtime and device libraries; can be specified either using compiler options or environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - D",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HIPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:4468,Modifiability,variab,variable,4468,"itectures on your system:. .. code-block:: shell. clang++ --offload-arch=native -xhip sample.cpp -o sample. Path Setting for Dependencies; =============================. Compiling a HIP program depends on the HIP runtime and device library. The paths to the HIP runtime and device libraries; can be specified either using compiler options or environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - Determined by ROCm directory structure. .. note::. We recommend using the compiler options as the primary method for specifying these paths. While the environment variables ``ROCM_PATH``, ``HIP_PATH``, and ``HIP_DEVICE_LIB_PATH`` are supported, their use can lead to implicit dependencies that might",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HIPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:4564,Modifiability,variab,variable,4564,"ample. Path Setting for Dependencies; =============================. Compiling a HIP program depends on the HIP runtime and device library. The paths to the HIP runtime and device libraries; can be specified either using compiler options or environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - Determined by ROCm directory structure. .. note::. We recommend using the compiler options as the primary method for specifying these paths. While the environment variables ``ROCM_PATH``, ``HIP_PATH``, and ``HIP_DEVICE_LIB_PATH`` are supported, their use can lead to implicit dependencies that might cause issues in the long run. Use them with caution. Predefined Macros; =================. .. list-t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HIPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:5330,Modifiability,variab,variables,5330,"lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - Determined by ROCm directory structure. .. note::. We recommend using the compiler options as the primary method for specifying these paths. While the environment variables ``ROCM_PATH``, ``HIP_PATH``, and ``HIP_DEVICE_LIB_PATH`` are supported, their use can lead to implicit dependencies that might cause issues in the long run. Use them with caution. Predefined Macros; =================. .. list-table::; :header-rows: 1. * - Macro; - Description; * - ``__CLANG_RDC__``; - Defined when Clang is compiling code in Relocatable Device Code (RDC) mode. RDC, enabled with the ``-fgpu-rdc`` compiler option, is necessary for linking device codes across translation units.; * - ``__HIP__``; - Defined when compiling with HIP language support, indicating that the code targets the HIP environment.; * - ``__HIPCC__``; - Alias to ``__HIP__``.; * - ``__HIP_DEVICE_COMPILE__``; - Defined during device code compilation in Clang's separate compilation process for the host and each offloading GPU architecture.; * - ``__HIP_MEMORY_SCOPE_SINGLETHREAD``; - Represents single-thread memory scope in HIP (value is 1).; * - ``__HIP_MEMORY_SCOPE_WAVEFRONT``; - Represents wavefront memory scope in HIP (value is 2).; * - ``__HIP_MEMORY_SCOPE_WORKGROU",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HIPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:3447,Safety,detect,detect,3447,"am:. .. code-block:: shell. clang++ -c --offload-arch=gfx906 sample.hip -o sample.o. To link a HIP program, use this command:. .. code-block:: shell. clang++ --hip-link --offload-arch=gfx906 sample.o -o sample. In the above command, the ``--hip-link`` flag instructs Clang to link the HIP runtime library. However,; the use of this flag is unnecessary if a HIP input file is already present in your program. For convenience, Clang also supports compiling and linking in a single step:. .. code-block:: shell. clang++ --offload-arch=gfx906 -xhip sample.cpp -o sample. In the above commands, ``gfx906`` is the GPU architecture that the code is being compiled for. The supported GPU; architectures can be found in the `AMDGPU Processor Table <https://llvm.org/docs/AMDGPUUsage.html#processors>`_.; Alternatively, you can use the ``amdgpu-arch`` tool that comes with Clang to list the GPU architecture on your system:. .. code-block:: shell. amdgpu-arch. You can use ``--offload-arch=native`` to automatically detect the GPU architectures on your system:. .. code-block:: shell. clang++ --offload-arch=native -xhip sample.cpp -o sample. Path Setting for Dependencies; =============================. Compiling a HIP program depends on the HIP runtime and device library. The paths to the HIP runtime and device libraries; can be specified either using compiler options or environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVI",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HIPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:4217,Safety,detect,detection,4217,"vely, you can use the ``amdgpu-arch`` tool that comes with Clang to list the GPU architecture on your system:. .. code-block:: shell. amdgpu-arch. You can use ``--offload-arch=native`` to automatically detect the GPU architectures on your system:. .. code-block:: shell. clang++ --offload-arch=native -xhip sample.cpp -o sample. Path Setting for Dependencies; =============================. Compiling a HIP program depends on the HIP runtime and device library. The paths to the HIP runtime and device libraries; can be specified either using compiler options or environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - Determined by ROCm directory structure. .. note::. We recommend using the comp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HIPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:4616,Safety,detect,detection,4616,"g a HIP program depends on the HIP runtime and device library. The paths to the HIP runtime and device libraries; can be specified either using compiler options or environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - Determined by ROCm directory structure. .. note::. We recommend using the compiler options as the primary method for specifying these paths. While the environment variables ``ROCM_PATH``, ``HIP_PATH``, and ``HIP_DEVICE_LIB_PATH`` are supported, their use can lead to implicit dependencies that might cause issues in the long run. Use them with caution. Predefined Macros; =================. .. list-table::; :header-rows: 1. * - Macro; - Description; * - ``__CLANG_RDC__``; - D",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HIPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:4901,Safety,detect,detection,4901,"of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - Determined by ROCm directory structure. .. note::. We recommend using the compiler options as the primary method for specifying these paths. While the environment variables ``ROCM_PATH``, ``HIP_PATH``, and ``HIP_DEVICE_LIB_PATH`` are supported, their use can lead to implicit dependencies that might cause issues in the long run. Use them with caution. Predefined Macros; =================. .. list-table::; :header-rows: 1. * - Macro; - Description; * - ``__CLANG_RDC__``; - Defined when Clang is compiling code in Relocatable Device Code (RDC) mode. RDC, enabled with the ``-fgpu-rdc`` compiler option, is necessary for linking device codes across translation units.; * - ``__HIP__``; - Defined when compiling with HIP language support, indicating that the code targets the H",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HIPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:9951,Security,access,accessible,9951,"fined in a different TU due to the possibility of incorrect resource usage calculations, leading to undefined behavior. On the other hand, the ``-fgpu-rdc`` mode allows the definition and use of function pointers across different TUs, as resource usage calculations can accommodate functions from disparate TUs. Virtual Function Support; ========================. In Clang with HIP, support for calling virtual functions of an object in device or host code is contingent on where the object is constructed. - **Constructed in Device Code**: Virtual functions of an object can be called in device code on a specific offloading device if the object is constructed in device code on an offloading device with the same architecture.; - **Constructed in Host Code**: Virtual functions of an object can be called in host code if the object is constructed in host code. In other scenarios, calling virtual functions is not allowed. Explanation; -----------. An object constructed on the device side contains a pointer to the virtual function table on the device side, which is not accessible in host code, and vice versa. Thus, trying to invoke virtual functions from a context different from where the object was constructed will be disallowed because the appropriate virtual table cannot be accessed. The virtual function tables for offloading devices with different architecures are different, therefore trying to invoke virtual functions from an offloading device with a different architecture than where the object is constructed is also disallowed. Example Usage; -------------. .. code-block:: c++. class Base {; public:; __device__ virtual void virtualFunction() {; // Base virtual function implementation; }; };. class Derived : public Base {; public:; __device__ void virtualFunction() override {; // Derived virtual function implementation; }; };. __global__ void kernel() {; Derived obj;; Base* basePtr = &obj;; basePtr->virtualFunction(); // Allowed since obj is constructed in device code; }; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HIPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:10163,Security,access,accessed,10163,"fined in a different TU due to the possibility of incorrect resource usage calculations, leading to undefined behavior. On the other hand, the ``-fgpu-rdc`` mode allows the definition and use of function pointers across different TUs, as resource usage calculations can accommodate functions from disparate TUs. Virtual Function Support; ========================. In Clang with HIP, support for calling virtual functions of an object in device or host code is contingent on where the object is constructed. - **Constructed in Device Code**: Virtual functions of an object can be called in device code on a specific offloading device if the object is constructed in device code on an offloading device with the same architecture.; - **Constructed in Host Code**: Virtual functions of an object can be called in host code if the object is constructed in host code. In other scenarios, calling virtual functions is not allowed. Explanation; -----------. An object constructed on the device side contains a pointer to the virtual function table on the device side, which is not accessible in host code, and vice versa. Thus, trying to invoke virtual functions from a context different from where the object was constructed will be disallowed because the appropriate virtual table cannot be accessed. The virtual function tables for offloading devices with different architecures are different, therefore trying to invoke virtual functions from an offloading device with a different architecture than where the object is constructed is also disallowed. Example Usage; -------------. .. code-block:: c++. class Base {; public:; __device__ virtual void virtualFunction() {; // Base virtual function implementation; }; };. class Derived : public Base {; public:; __device__ void virtualFunction() override {; // Derived virtual function implementation; }; };. __global__ void kernel() {; Derived obj;; Base* basePtr = &obj;; basePtr->virtualFunction(); // Allowed since obj is constructed in device code; }; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HIPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:5027,Availability,echo,echo,5027," environment variables,; you may need to run any Clang Tooling executables through a command prompt; window created for use with Visual Studio as described above. An; alternative, e.g. for using the Visual Studio debugger on a Clang Tooling; executable, is to ensure that the environment variables are also visible; to the debugger settings. This can be done locally in Visual Studio's; debugger configuration locally or globally by launching the Visual Studio; IDE from a suitable command-prompt window. Using Clang Tools; =================. After you completed the previous steps, you are ready to run clang tools. If; you have a recent clang installed, you should have ``clang-check`` in; ``$PATH``. Try to run it on any ``.cpp`` file inside the LLVM source tree:. .. code-block:: console. $ clang-check tools/clang/lib/Tooling/CompilationDatabase.cpp. If you're using vim, it's convenient to have clang-check integrated. Put; this into your ``.vimrc``:. ::. function! ClangCheckImpl(cmd); if &autowrite | wall | endif; echo ""Running "" . a:cmd . "" ...""; let l:output = system(a:cmd); cexpr l:output; cwindow; let w:quickfix_title = a:cmd; if v:shell_error != 0; cc; endif; let g:clang_check_last_cmd = a:cmd; endfunction. function! ClangCheck(); let l:filename = expand('%'); if l:filename =~ '\.\(cpp\|cxx\|cc\|c\)$'; call ClangCheckImpl(""clang-check "" . l:filename); elseif exists(""g:clang_check_last_cmd""); call ClangCheckImpl(g:clang_check_last_cmd); else; echo ""Can't detect file's compilation arguments and no previous clang-check invocation!""; endif; endfunction. nmap <silent> <F5> :call ClangCheck()<CR><CR>. When editing a .cpp/.cxx/.cc/.c file, hit F5 to reparse the file. In; case the current file has a different extension (for example, .h), F5; will re-run the last clang-check invocation made from this vim instance; (if any). The output will go into the error window, which is opened; automatically when clang-check finds errors, and can be re-opened with; ``:cope``. Other ``clang-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:5468,Availability,echo,echo,5468," from a suitable command-prompt window. Using Clang Tools; =================. After you completed the previous steps, you are ready to run clang tools. If; you have a recent clang installed, you should have ``clang-check`` in; ``$PATH``. Try to run it on any ``.cpp`` file inside the LLVM source tree:. .. code-block:: console. $ clang-check tools/clang/lib/Tooling/CompilationDatabase.cpp. If you're using vim, it's convenient to have clang-check integrated. Put; this into your ``.vimrc``:. ::. function! ClangCheckImpl(cmd); if &autowrite | wall | endif; echo ""Running "" . a:cmd . "" ...""; let l:output = system(a:cmd); cexpr l:output; cwindow; let w:quickfix_title = a:cmd; if v:shell_error != 0; cc; endif; let g:clang_check_last_cmd = a:cmd; endfunction. function! ClangCheck(); let l:filename = expand('%'); if l:filename =~ '\.\(cpp\|cxx\|cc\|c\)$'; call ClangCheckImpl(""clang-check "" . l:filename); elseif exists(""g:clang_check_last_cmd""); call ClangCheckImpl(g:clang_check_last_cmd); else; echo ""Can't detect file's compilation arguments and no previous clang-check invocation!""; endif; endfunction. nmap <silent> <F5> :call ClangCheck()<CR><CR>. When editing a .cpp/.cxx/.cc/.c file, hit F5 to reparse the file. In; case the current file has a different extension (for example, .h), F5; will re-run the last clang-check invocation made from this vim instance; (if any). The output will go into the error window, which is opened; automatically when clang-check finds errors, and can be re-opened with; ``:cope``. Other ``clang-check`` options that can be useful when working with clang; AST:. * ``-ast-print`` --- Build ASTs and then pretty-print them.; * ``-ast-dump`` --- Build ASTs and then debug dump them.; * ``-ast-dump-filter=<string>`` --- Use with ``-ast-dump`` or ``-ast-print`` to; dump/print only AST declaration nodes having a certain substring in a; qualified name. Use ``-ast-list`` to list all filterable declaration node; names.; * ``-ast-list`` --- Build ASTs and print the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:5877,Availability,error,error,5877,"tegrated. Put; this into your ``.vimrc``:. ::. function! ClangCheckImpl(cmd); if &autowrite | wall | endif; echo ""Running "" . a:cmd . "" ...""; let l:output = system(a:cmd); cexpr l:output; cwindow; let w:quickfix_title = a:cmd; if v:shell_error != 0; cc; endif; let g:clang_check_last_cmd = a:cmd; endfunction. function! ClangCheck(); let l:filename = expand('%'); if l:filename =~ '\.\(cpp\|cxx\|cc\|c\)$'; call ClangCheckImpl(""clang-check "" . l:filename); elseif exists(""g:clang_check_last_cmd""); call ClangCheckImpl(g:clang_check_last_cmd); else; echo ""Can't detect file's compilation arguments and no previous clang-check invocation!""; endif; endfunction. nmap <silent> <F5> :call ClangCheck()<CR><CR>. When editing a .cpp/.cxx/.cc/.c file, hit F5 to reparse the file. In; case the current file has a different extension (for example, .h), F5; will re-run the last clang-check invocation made from this vim instance; (if any). The output will go into the error window, which is opened; automatically when clang-check finds errors, and can be re-opened with; ``:cope``. Other ``clang-check`` options that can be useful when working with clang; AST:. * ``-ast-print`` --- Build ASTs and then pretty-print them.; * ``-ast-dump`` --- Build ASTs and then debug dump them.; * ``-ast-dump-filter=<string>`` --- Use with ``-ast-dump`` or ``-ast-print`` to; dump/print only AST declaration nodes having a certain substring in a; qualified name. Use ``-ast-list`` to list all filterable declaration node; names.; * ``-ast-list`` --- Build ASTs and print the list of declaration node qualified; names. Examples:. .. code-block:: console. $ clang-check tools/clang/tools/clang-check/ClangCheck.cpp -ast-dump -ast-dump-filter ActionFactory::newASTConsumer; Processing: tools/clang/tools/clang-check/ClangCheck.cpp.; Dumping ::ActionFactory::newASTConsumer:; clang::ASTConsumer *newASTConsumer() (CompoundStmt 0x44da290 </home/alexfh/local/llvm/tools/clang/tools/clang-check/ClangCheck.cpp:64:40, line:72:3>; (I",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:5945,Availability,error,errors,5945,"tegrated. Put; this into your ``.vimrc``:. ::. function! ClangCheckImpl(cmd); if &autowrite | wall | endif; echo ""Running "" . a:cmd . "" ...""; let l:output = system(a:cmd); cexpr l:output; cwindow; let w:quickfix_title = a:cmd; if v:shell_error != 0; cc; endif; let g:clang_check_last_cmd = a:cmd; endfunction. function! ClangCheck(); let l:filename = expand('%'); if l:filename =~ '\.\(cpp\|cxx\|cc\|c\)$'; call ClangCheckImpl(""clang-check "" . l:filename); elseif exists(""g:clang_check_last_cmd""); call ClangCheckImpl(g:clang_check_last_cmd); else; echo ""Can't detect file's compilation arguments and no previous clang-check invocation!""; endif; endfunction. nmap <silent> <F5> :call ClangCheck()<CR><CR>. When editing a .cpp/.cxx/.cc/.c file, hit F5 to reparse the file. In; case the current file has a different extension (for example, .h), F5; will re-run the last clang-check invocation made from this vim instance; (if any). The output will go into the error window, which is opened; automatically when clang-check finds errors, and can be re-opened with; ``:cope``. Other ``clang-check`` options that can be useful when working with clang; AST:. * ``-ast-print`` --- Build ASTs and then pretty-print them.; * ``-ast-dump`` --- Build ASTs and then debug dump them.; * ``-ast-dump-filter=<string>`` --- Use with ``-ast-dump`` or ``-ast-print`` to; dump/print only AST declaration nodes having a certain substring in a; qualified name. Use ``-ast-list`` to list all filterable declaration node; names.; * ``-ast-list`` --- Build ASTs and print the list of declaration node qualified; names. Examples:. .. code-block:: console. $ clang-check tools/clang/tools/clang-check/ClangCheck.cpp -ast-dump -ast-dump-filter ActionFactory::newASTConsumer; Processing: tools/clang/tools/clang-check/ClangCheck.cpp.; Dumping ::ActionFactory::newASTConsumer:; clang::ASTConsumer *newASTConsumer() (CompoundStmt 0x44da290 </home/alexfh/local/llvm/tools/clang/tools/clang-check/ClangCheck.cpp:64:40, line:72:3>; (I",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:1083,Deployability,install,installed,1083,"==========. Clang Tooling provides infrastructure to write tools that need syntactic; and semantic information about a program. This term also relates to a set; of specific tools using this infrastructure (e.g. ``clang-check``). This; document provides information on how to set up and use Clang Tooling for; the LLVM source code. Introduction; ============. Clang Tooling needs a compilation database to figure out specific build; options for each file. Currently it can create a compilation database; from the ``compile_commands.json`` file, generated by CMake. When; invoking clang tools, you can either specify a path to a build directory; using a command line parameter ``-p`` or let Clang Tooling find this; file in your source tree. In either case you need to configure your; build using CMake to use clang tools. Setup Clang Tooling Using CMake and Make; ========================================. If you intend to use make to build LLVM, you should have CMake 2.8.6 or; later installed (can be found `here <https://cmake.org>`_). First, you need to generate Makefiles for LLVM with CMake. You need to; make a build directory and run CMake from it:. .. code-block:: console. $ mkdir your/build/directory; $ cd your/build/directory; $ cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. If you want to use clang instead of GCC, you can add; ``-DCMAKE_C_COMPILER=/path/to/clang -DCMAKE_CXX_COMPILER=/path/to/clang++``.; You can also use ``ccmake``, which provides a curses interface to configure; CMake variables. As a result, the new ``compile_commands.json`` file should appear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using make:. .. code-block:: console. $ make check-all. Setup Clang Tooling Using CMake on Windows; ==========================================. For Windows developers, t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:2469,Deployability,install,install,2469,"E_C_COMPILER=/path/to/clang -DCMAKE_CXX_COMPILER=/path/to/clang++``.; You can also use ``ccmake``, which provides a curses interface to configure; CMake variables. As a result, the new ``compile_commands.json`` file should appear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using make:. .. code-block:: console. $ make check-all. Setup Clang Tooling Using CMake on Windows; ==========================================. For Windows developers, the Visual Studio project generators in CMake do; not support `CMAKE_EXPORT_COMPILE_COMMANDS; <https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html>`_.; However, the Ninja generator does support this variable and can be used; on Windows to generate a suitable ``compile_commands.json`` that invokes; the MSVC compiler. First, you will need to install `Ninja`_. Once installed, the Ninja; executable will need to be in your search path for CMake to locate it. Next, assuming you already have Visual Studio installed on your machine, you; need to have the appropriate environment variables configured so that CMake; will locate the MSVC compiler for the Ninja generator. The `documentation; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#path_and_environment>`_; describes the necessary environment variable settings, but the simplest thing; is to use a `developer command-prompt window; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_prompt_shortcuts>`_; or call a `developer command file; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_file_locations>`_; to set the environment variables appropriately. Now you can run CMake with the Ninja generator to export a compilation; database",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:2492,Deployability,install,installed,2492,"You can also use ``ccmake``, which provides a curses interface to configure; CMake variables. As a result, the new ``compile_commands.json`` file should appear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using make:. .. code-block:: console. $ make check-all. Setup Clang Tooling Using CMake on Windows; ==========================================. For Windows developers, the Visual Studio project generators in CMake do; not support `CMAKE_EXPORT_COMPILE_COMMANDS; <https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html>`_.; However, the Ninja generator does support this variable and can be used; on Windows to generate a suitable ``compile_commands.json`` that invokes; the MSVC compiler. First, you will need to install `Ninja`_. Once installed, the Ninja; executable will need to be in your search path for CMake to locate it. Next, assuming you already have Visual Studio installed on your machine, you; need to have the appropriate environment variables configured so that CMake; will locate the MSVC compiler for the Ninja generator. The `documentation; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#path_and_environment>`_; describes the necessary environment variable settings, but the simplest thing; is to use a `developer command-prompt window; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_prompt_shortcuts>`_; or call a `developer command file; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_file_locations>`_; to set the environment variables appropriately. Now you can run CMake with the Ninja generator to export a compilation; database:. .. code-block:: console. C:\> mkdir build-ninja; C:\> cd build-ninj",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:2631,Deployability,install,installed,2631,"ppear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using make:. .. code-block:: console. $ make check-all. Setup Clang Tooling Using CMake on Windows; ==========================================. For Windows developers, the Visual Studio project generators in CMake do; not support `CMAKE_EXPORT_COMPILE_COMMANDS; <https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html>`_.; However, the Ninja generator does support this variable and can be used; on Windows to generate a suitable ``compile_commands.json`` that invokes; the MSVC compiler. First, you will need to install `Ninja`_. Once installed, the Ninja; executable will need to be in your search path for CMake to locate it. Next, assuming you already have Visual Studio installed on your machine, you; need to have the appropriate environment variables configured so that CMake; will locate the MSVC compiler for the Ninja generator. The `documentation; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#path_and_environment>`_; describes the necessary environment variable settings, but the simplest thing; is to use a `developer command-prompt window; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_prompt_shortcuts>`_; or call a `developer command file; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_file_locations>`_; to set the environment variables appropriately. Now you can run CMake with the Ninja generator to export a compilation; database:. .. code-block:: console. C:\> mkdir build-ninja; C:\> cd build-ninja; C:\build-ninja> cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. It is best to keep your Visual Studio IDE build folder separate",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:4400,Deployability,configurat,configuration,4400,"rator to export a compilation; database:. .. code-block:: console. C:\> mkdir build-ninja; C:\> cd build-ninja; C:\build-ninja> cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. It is best to keep your Visual Studio IDE build folder separate from the; Ninja build folder. This prevents the two build systems from negatively; interacting with each other. Once the ``compile_commands.json`` file has been created by Ninja, you can; use that compilation database with Clang Tooling. One caveat is that because; there are indirect settings obtained through the environment variables,; you may need to run any Clang Tooling executables through a command prompt; window created for use with Visual Studio as described above. An; alternative, e.g. for using the Visual Studio debugger on a Clang Tooling; executable, is to ensure that the environment variables are also visible; to the debugger settings. This can be done locally in Visual Studio's; debugger configuration locally or globally by launching the Visual Studio; IDE from a suitable command-prompt window. Using Clang Tools; =================. After you completed the previous steps, you are ready to run clang tools. If; you have a recent clang installed, you should have ``clang-check`` in; ``$PATH``. Try to run it on any ``.cpp`` file inside the LLVM source tree:. .. code-block:: console. $ clang-check tools/clang/lib/Tooling/CompilationDatabase.cpp. If you're using vim, it's convenient to have clang-check integrated. Put; this into your ``.vimrc``:. ::. function! ClangCheckImpl(cmd); if &autowrite | wall | endif; echo ""Running "" . a:cmd . "" ...""; let l:output = system(a:cmd); cexpr l:output; cwindow; let w:quickfix_title = a:cmd; if v:shell_error != 0; cc; endif; let g:clang_check_last_cmd = a:cmd; endfunction. function! ClangCheck(); let l:filename = expand('%'); if l:filename =~ '\.\(cpp\|cxx\|cc\|c\)$'; call ClangCheckImpl(""clang-check "" . l:filename); elseif exists(""g:clang_check_last_cmd""); call Clang",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:4649,Deployability,install,installed,4649," IDE build folder separate from the; Ninja build folder. This prevents the two build systems from negatively; interacting with each other. Once the ``compile_commands.json`` file has been created by Ninja, you can; use that compilation database with Clang Tooling. One caveat is that because; there are indirect settings obtained through the environment variables,; you may need to run any Clang Tooling executables through a command prompt; window created for use with Visual Studio as described above. An; alternative, e.g. for using the Visual Studio debugger on a Clang Tooling; executable, is to ensure that the environment variables are also visible; to the debugger settings. This can be done locally in Visual Studio's; debugger configuration locally or globally by launching the Visual Studio; IDE from a suitable command-prompt window. Using Clang Tools; =================. After you completed the previous steps, you are ready to run clang tools. If; you have a recent clang installed, you should have ``clang-check`` in; ``$PATH``. Try to run it on any ``.cpp`` file inside the LLVM source tree:. .. code-block:: console. $ clang-check tools/clang/lib/Tooling/CompilationDatabase.cpp. If you're using vim, it's convenient to have clang-check integrated. Put; this into your ``.vimrc``:. ::. function! ClangCheckImpl(cmd); if &autowrite | wall | endif; echo ""Running "" . a:cmd . "" ...""; let l:output = system(a:cmd); cexpr l:output; cwindow; let w:quickfix_title = a:cmd; if v:shell_error != 0; cc; endif; let g:clang_check_last_cmd = a:cmd; endfunction. function! ClangCheck(); let l:filename = expand('%'); if l:filename =~ '\.\(cpp\|cxx\|cc\|c\)$'; call ClangCheckImpl(""clang-check "" . l:filename); elseif exists(""g:clang_check_last_cmd""); call ClangCheckImpl(g:clang_check_last_cmd); else; echo ""Can't detect file's compilation arguments and no previous clang-check invocation!""; endif; endfunction. nmap <silent> <F5> :call ClangCheck()<CR><CR>. When editing a .cpp/.cxx/.cc/.c file, ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:4917,Deployability,integrat,integrated,4917,"ation database with Clang Tooling. One caveat is that because; there are indirect settings obtained through the environment variables,; you may need to run any Clang Tooling executables through a command prompt; window created for use with Visual Studio as described above. An; alternative, e.g. for using the Visual Studio debugger on a Clang Tooling; executable, is to ensure that the environment variables are also visible; to the debugger settings. This can be done locally in Visual Studio's; debugger configuration locally or globally by launching the Visual Studio; IDE from a suitable command-prompt window. Using Clang Tools; =================. After you completed the previous steps, you are ready to run clang tools. If; you have a recent clang installed, you should have ``clang-check`` in; ``$PATH``. Try to run it on any ``.cpp`` file inside the LLVM source tree:. .. code-block:: console. $ clang-check tools/clang/lib/Tooling/CompilationDatabase.cpp. If you're using vim, it's convenient to have clang-check integrated. Put; this into your ``.vimrc``:. ::. function! ClangCheckImpl(cmd); if &autowrite | wall | endif; echo ""Running "" . a:cmd . "" ...""; let l:output = system(a:cmd); cexpr l:output; cwindow; let w:quickfix_title = a:cmd; if v:shell_error != 0; cc; endif; let g:clang_check_last_cmd = a:cmd; endfunction. function! ClangCheck(); let l:filename = expand('%'); if l:filename =~ '\.\(cpp\|cxx\|cc\|c\)$'; call ClangCheckImpl(""clang-check "" . l:filename); elseif exists(""g:clang_check_last_cmd""); call ClangCheckImpl(g:clang_check_last_cmd); else; echo ""Can't detect file's compilation arguments and no previous clang-check invocation!""; endif; endfunction. nmap <silent> <F5> :call ClangCheck()<CR><CR>. When editing a .cpp/.cxx/.cc/.c file, hit F5 to reparse the file. In; case the current file has a different extension (for example, .h), F5; will re-run the last clang-check invocation made from this vim instance; (if any). The output will go into the error window, whi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:8265,Deployability,install,installation,8265,"onsumer *newASTConsumer() {; if (this->ASTList.operator _Bool()); return clang::CreateASTDeclNodeLister();; if (this->ASTDump.operator _Bool()); return clang::CreateASTDumper(nullptr /*Dump to stdout.*/,; this->ASTDumpFilter);; if (this->ASTPrint.operator _Bool()); return clang::CreateASTPrinter(&llvm::outs(), this->ASTDumpFilter);; return new clang::ASTConsumer();; }. Using Ninja Build System; =======================================. Optionally you can use the `Ninja`_ build system instead of make. It is; aimed at making your builds faster. Currently this step will require; building Ninja from sources. To take advantage of using Clang Tools along with Ninja build you need; at least CMake 2.8.9. Clone the Ninja git repository and build Ninja from sources:. .. code-block:: console. $ git clone git://github.com/martine/ninja.git; $ cd ninja/; $ ./bootstrap.py. This will result in a single binary ``ninja`` in the current directory.; It doesn't require installation and can just be copied to any location; inside ``$PATH``, say ``/usr/local/bin/``:. .. code-block:: console. $ sudo cp ninja /usr/local/bin/; $ sudo chmod a+rx /usr/local/bin/ninja. After doing all of this, you'll need to generate Ninja build files for; LLVM with CMake. You need to make a build directory and run CMake from; it:. .. code-block:: console. $ mkdir your/build/directory; $ cd your/build/directory; $ cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. If you want to use clang instead of GCC, you can add; ``-DCMAKE_C_COMPILER=/path/to/clang -DCMAKE_CXX_COMPILER=/path/to/clang++``.; You can also use ``ccmake``, which provides a curses interface to configure; CMake variables in an interactive manner. As a result, the new ``compile_commands.json`` file should appear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:1588,Integrability,interface,interface,1588,"compilation database; from the ``compile_commands.json`` file, generated by CMake. When; invoking clang tools, you can either specify a path to a build directory; using a command line parameter ``-p`` or let Clang Tooling find this; file in your source tree. In either case you need to configure your; build using CMake to use clang tools. Setup Clang Tooling Using CMake and Make; ========================================. If you intend to use make to build LLVM, you should have CMake 2.8.6 or; later installed (can be found `here <https://cmake.org>`_). First, you need to generate Makefiles for LLVM with CMake. You need to; make a build directory and run CMake from it:. .. code-block:: console. $ mkdir your/build/directory; $ cd your/build/directory; $ cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. If you want to use clang instead of GCC, you can add; ``-DCMAKE_C_COMPILER=/path/to/clang -DCMAKE_CXX_COMPILER=/path/to/clang++``.; You can also use ``ccmake``, which provides a curses interface to configure; CMake variables. As a result, the new ``compile_commands.json`` file should appear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using make:. .. code-block:: console. $ make check-all. Setup Clang Tooling Using CMake on Windows; ==========================================. For Windows developers, the Visual Studio project generators in CMake do; not support `CMAKE_EXPORT_COMPILE_COMMANDS; <https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html>`_.; However, the Ninja generator does support this variable and can be used; on Windows to generate a suitable ``compile_commands.json`` that invokes; the MSVC compiler. First, you will need to install `Ninja`_. Once installed, the Ninja; executable will need to be in your search path for CMake to locate ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:4917,Integrability,integrat,integrated,4917,"ation database with Clang Tooling. One caveat is that because; there are indirect settings obtained through the environment variables,; you may need to run any Clang Tooling executables through a command prompt; window created for use with Visual Studio as described above. An; alternative, e.g. for using the Visual Studio debugger on a Clang Tooling; executable, is to ensure that the environment variables are also visible; to the debugger settings. This can be done locally in Visual Studio's; debugger configuration locally or globally by launching the Visual Studio; IDE from a suitable command-prompt window. Using Clang Tools; =================. After you completed the previous steps, you are ready to run clang tools. If; you have a recent clang installed, you should have ``clang-check`` in; ``$PATH``. Try to run it on any ``.cpp`` file inside the LLVM source tree:. .. code-block:: console. $ clang-check tools/clang/lib/Tooling/CompilationDatabase.cpp. If you're using vim, it's convenient to have clang-check integrated. Put; this into your ``.vimrc``:. ::. function! ClangCheckImpl(cmd); if &autowrite | wall | endif; echo ""Running "" . a:cmd . "" ...""; let l:output = system(a:cmd); cexpr l:output; cwindow; let w:quickfix_title = a:cmd; if v:shell_error != 0; cc; endif; let g:clang_check_last_cmd = a:cmd; endfunction. function! ClangCheck(); let l:filename = expand('%'); if l:filename =~ '\.\(cpp\|cxx\|cc\|c\)$'; call ClangCheckImpl(""clang-check "" . l:filename); elseif exists(""g:clang_check_last_cmd""); call ClangCheckImpl(g:clang_check_last_cmd); else; echo ""Can't detect file's compilation arguments and no previous clang-check invocation!""; endif; endfunction. nmap <silent> <F5> :call ClangCheck()<CR><CR>. When editing a .cpp/.cxx/.cc/.c file, hit F5 to reparse the file. In; case the current file has a different extension (for example, .h), F5; will re-run the last clang-check invocation made from this vim instance; (if any). The output will go into the error window, whi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:8950,Integrability,interface,interface,8950,"er(nullptr /*Dump to stdout.*/,; this->ASTDumpFilter);; if (this->ASTPrint.operator _Bool()); return clang::CreateASTPrinter(&llvm::outs(), this->ASTDumpFilter);; return new clang::ASTConsumer();; }. Using Ninja Build System; =======================================. Optionally you can use the `Ninja`_ build system instead of make. It is; aimed at making your builds faster. Currently this step will require; building Ninja from sources. To take advantage of using Clang Tools along with Ninja build you need; at least CMake 2.8.9. Clone the Ninja git repository and build Ninja from sources:. .. code-block:: console. $ git clone git://github.com/martine/ninja.git; $ cd ninja/; $ ./bootstrap.py. This will result in a single binary ``ninja`` in the current directory.; It doesn't require installation and can just be copied to any location; inside ``$PATH``, say ``/usr/local/bin/``:. .. code-block:: console. $ sudo cp ninja /usr/local/bin/; $ sudo chmod a+rx /usr/local/bin/ninja. After doing all of this, you'll need to generate Ninja build files for; LLVM with CMake. You need to make a build directory and run CMake from; it:. .. code-block:: console. $ mkdir your/build/directory; $ cd your/build/directory; $ cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. If you want to use clang instead of GCC, you can add; ``-DCMAKE_C_COMPILER=/path/to/clang -DCMAKE_CXX_COMPILER=/path/to/clang++``.; You can also use ``ccmake``, which provides a curses interface to configure; CMake variables in an interactive manner. As a result, the new ``compile_commands.json`` file should appear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using Ninja:. .. code-block:: console. $ ninja check-all. Other target names can be used in the same way as with make. .. _Ninja: https://ninja-build.org/; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:866,Modifiability,config,configure,866,"===================================; How To Setup Clang Tooling For LLVM; ===================================. Clang Tooling provides infrastructure to write tools that need syntactic; and semantic information about a program. This term also relates to a set; of specific tools using this infrastructure (e.g. ``clang-check``). This; document provides information on how to set up and use Clang Tooling for; the LLVM source code. Introduction; ============. Clang Tooling needs a compilation database to figure out specific build; options for each file. Currently it can create a compilation database; from the ``compile_commands.json`` file, generated by CMake. When; invoking clang tools, you can either specify a path to a build directory; using a command line parameter ``-p`` or let Clang Tooling find this; file in your source tree. In either case you need to configure your; build using CMake to use clang tools. Setup Clang Tooling Using CMake and Make; ========================================. If you intend to use make to build LLVM, you should have CMake 2.8.6 or; later installed (can be found `here <https://cmake.org>`_). First, you need to generate Makefiles for LLVM with CMake. You need to; make a build directory and run CMake from it:. .. code-block:: console. $ mkdir your/build/directory; $ cd your/build/directory; $ cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. If you want to use clang instead of GCC, you can add; ``-DCMAKE_C_COMPILER=/path/to/clang -DCMAKE_CXX_COMPILER=/path/to/clang++``.; You can also use ``ccmake``, which provides a curses interface to configure; CMake variables. As a result, the new ``compile_commands.json`` file should appear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using make:. .. code-block:: console. $ make check-all. Setup Clang To",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:1601,Modifiability,config,configure,1601,"compilation database; from the ``compile_commands.json`` file, generated by CMake. When; invoking clang tools, you can either specify a path to a build directory; using a command line parameter ``-p`` or let Clang Tooling find this; file in your source tree. In either case you need to configure your; build using CMake to use clang tools. Setup Clang Tooling Using CMake and Make; ========================================. If you intend to use make to build LLVM, you should have CMake 2.8.6 or; later installed (can be found `here <https://cmake.org>`_). First, you need to generate Makefiles for LLVM with CMake. You need to; make a build directory and run CMake from it:. .. code-block:: console. $ mkdir your/build/directory; $ cd your/build/directory; $ cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. If you want to use clang instead of GCC, you can add; ``-DCMAKE_C_COMPILER=/path/to/clang -DCMAKE_CXX_COMPILER=/path/to/clang++``.; You can also use ``ccmake``, which provides a curses interface to configure; CMake variables. As a result, the new ``compile_commands.json`` file should appear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using make:. .. code-block:: console. $ make check-all. Setup Clang Tooling Using CMake on Windows; ==========================================. For Windows developers, the Visual Studio project generators in CMake do; not support `CMAKE_EXPORT_COMPILE_COMMANDS; <https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html>`_.; However, the Ninja generator does support this variable and can be used; on Windows to generate a suitable ``compile_commands.json`` that invokes; the MSVC compiler. First, you will need to install `Ninja`_. Once installed, the Ninja; executable will need to be in your search path for CMake to locate ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:1618,Modifiability,variab,variables,1618,"compilation database; from the ``compile_commands.json`` file, generated by CMake. When; invoking clang tools, you can either specify a path to a build directory; using a command line parameter ``-p`` or let Clang Tooling find this; file in your source tree. In either case you need to configure your; build using CMake to use clang tools. Setup Clang Tooling Using CMake and Make; ========================================. If you intend to use make to build LLVM, you should have CMake 2.8.6 or; later installed (can be found `here <https://cmake.org>`_). First, you need to generate Makefiles for LLVM with CMake. You need to; make a build directory and run CMake from it:. .. code-block:: console. $ mkdir your/build/directory; $ cd your/build/directory; $ cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. If you want to use clang instead of GCC, you can add; ``-DCMAKE_C_COMPILER=/path/to/clang -DCMAKE_CXX_COMPILER=/path/to/clang++``.; You can also use ``ccmake``, which provides a curses interface to configure; CMake variables. As a result, the new ``compile_commands.json`` file should appear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using make:. .. code-block:: console. $ make check-all. Setup Clang Tooling Using CMake on Windows; ==========================================. For Windows developers, the Visual Studio project generators in CMake do; not support `CMAKE_EXPORT_COMPILE_COMMANDS; <https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html>`_.; However, the Ninja generator does support this variable and can be used; on Windows to generate a suitable ``compile_commands.json`` that invokes; the MSVC compiler. First, you will need to install `Ninja`_. Once installed, the Ninja; executable will need to be in your search path for CMake to locate ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:2230,Modifiability,variab,variable,2230,"n CMake from it:. .. code-block:: console. $ mkdir your/build/directory; $ cd your/build/directory; $ cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. If you want to use clang instead of GCC, you can add; ``-DCMAKE_C_COMPILER=/path/to/clang -DCMAKE_CXX_COMPILER=/path/to/clang++``.; You can also use ``ccmake``, which provides a curses interface to configure; CMake variables. As a result, the new ``compile_commands.json`` file should appear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using make:. .. code-block:: console. $ make check-all. Setup Clang Tooling Using CMake on Windows; ==========================================. For Windows developers, the Visual Studio project generators in CMake do; not support `CMAKE_EXPORT_COMPILE_COMMANDS; <https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html>`_.; However, the Ninja generator does support this variable and can be used; on Windows to generate a suitable ``compile_commands.json`` that invokes; the MSVC compiler. First, you will need to install `Ninja`_. Once installed, the Ninja; executable will need to be in your search path for CMake to locate it. Next, assuming you already have Visual Studio installed on your machine, you; need to have the appropriate environment variables configured so that CMake; will locate the MSVC compiler for the Ninja generator. The `documentation; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#path_and_environment>`_; describes the necessary environment variable settings, but the simplest thing; is to use a `developer command-prompt window; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_prompt_shortcuts>`_; or call a `developer command file; <https://docs.microsoft.co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:2326,Modifiability,variab,variable,2326,"make -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. If you want to use clang instead of GCC, you can add; ``-DCMAKE_C_COMPILER=/path/to/clang -DCMAKE_CXX_COMPILER=/path/to/clang++``.; You can also use ``ccmake``, which provides a curses interface to configure; CMake variables. As a result, the new ``compile_commands.json`` file should appear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using make:. .. code-block:: console. $ make check-all. Setup Clang Tooling Using CMake on Windows; ==========================================. For Windows developers, the Visual Studio project generators in CMake do; not support `CMAKE_EXPORT_COMPILE_COMMANDS; <https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html>`_.; However, the Ninja generator does support this variable and can be used; on Windows to generate a suitable ``compile_commands.json`` that invokes; the MSVC compiler. First, you will need to install `Ninja`_. Once installed, the Ninja; executable will need to be in your search path for CMake to locate it. Next, assuming you already have Visual Studio installed on your machine, you; need to have the appropriate environment variables configured so that CMake; will locate the MSVC compiler for the Ninja generator. The `documentation; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#path_and_environment>`_; describes the necessary environment variable settings, but the simplest thing; is to use a `developer command-prompt window; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_prompt_shortcuts>`_; or call a `developer command file; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_file_locations>`_; to s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:2704,Modifiability,variab,variables,2704,"ppear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using make:. .. code-block:: console. $ make check-all. Setup Clang Tooling Using CMake on Windows; ==========================================. For Windows developers, the Visual Studio project generators in CMake do; not support `CMAKE_EXPORT_COMPILE_COMMANDS; <https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html>`_.; However, the Ninja generator does support this variable and can be used; on Windows to generate a suitable ``compile_commands.json`` that invokes; the MSVC compiler. First, you will need to install `Ninja`_. Once installed, the Ninja; executable will need to be in your search path for CMake to locate it. Next, assuming you already have Visual Studio installed on your machine, you; need to have the appropriate environment variables configured so that CMake; will locate the MSVC compiler for the Ninja generator. The `documentation; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#path_and_environment>`_; describes the necessary environment variable settings, but the simplest thing; is to use a `developer command-prompt window; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_prompt_shortcuts>`_; or call a `developer command file; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_file_locations>`_; to set the environment variables appropriately. Now you can run CMake with the Ninja generator to export a compilation; database:. .. code-block:: console. C:\> mkdir build-ninja; C:\> cd build-ninja; C:\build-ninja> cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. It is best to keep your Visual Studio IDE build folder separate",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:2714,Modifiability,config,configured,2714,"ppear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using make:. .. code-block:: console. $ make check-all. Setup Clang Tooling Using CMake on Windows; ==========================================. For Windows developers, the Visual Studio project generators in CMake do; not support `CMAKE_EXPORT_COMPILE_COMMANDS; <https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html>`_.; However, the Ninja generator does support this variable and can be used; on Windows to generate a suitable ``compile_commands.json`` that invokes; the MSVC compiler. First, you will need to install `Ninja`_. Once installed, the Ninja; executable will need to be in your search path for CMake to locate it. Next, assuming you already have Visual Studio installed on your machine, you; need to have the appropriate environment variables configured so that CMake; will locate the MSVC compiler for the Ninja generator. The `documentation; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#path_and_environment>`_; describes the necessary environment variable settings, but the simplest thing; is to use a `developer command-prompt window; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_prompt_shortcuts>`_; or call a `developer command file; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_file_locations>`_; to set the environment variables appropriately. Now you can run CMake with the Ninja generator to export a compilation; database:. .. code-block:: console. C:\> mkdir build-ninja; C:\> cd build-ninja; C:\build-ninja> cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. It is best to keep your Visual Studio IDE build folder separate",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:2963,Modifiability,variab,variable,2963,"block:: console. $ make check-all. Setup Clang Tooling Using CMake on Windows; ==========================================. For Windows developers, the Visual Studio project generators in CMake do; not support `CMAKE_EXPORT_COMPILE_COMMANDS; <https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html>`_.; However, the Ninja generator does support this variable and can be used; on Windows to generate a suitable ``compile_commands.json`` that invokes; the MSVC compiler. First, you will need to install `Ninja`_. Once installed, the Ninja; executable will need to be in your search path for CMake to locate it. Next, assuming you already have Visual Studio installed on your machine, you; need to have the appropriate environment variables configured so that CMake; will locate the MSVC compiler for the Ninja generator. The `documentation; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#path_and_environment>`_; describes the necessary environment variable settings, but the simplest thing; is to use a `developer command-prompt window; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_prompt_shortcuts>`_; or call a `developer command file; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_file_locations>`_; to set the environment variables appropriately. Now you can run CMake with the Ninja generator to export a compilation; database:. .. code-block:: console. C:\> mkdir build-ninja; C:\> cd build-ninja; C:\build-ninja> cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. It is best to keep your Visual Studio IDE build folder separate from the; Ninja build folder. This prevents the two build systems from negatively; interacting with each other. Once the ``compile_commands.json`` file has been created by Ninja, you can; use that compilation database with Clang Tooling. One caveat is that becaus",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:3360,Modifiability,variab,variables,3360,"es support this variable and can be used; on Windows to generate a suitable ``compile_commands.json`` that invokes; the MSVC compiler. First, you will need to install `Ninja`_. Once installed, the Ninja; executable will need to be in your search path for CMake to locate it. Next, assuming you already have Visual Studio installed on your machine, you; need to have the appropriate environment variables configured so that CMake; will locate the MSVC compiler for the Ninja generator. The `documentation; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#path_and_environment>`_; describes the necessary environment variable settings, but the simplest thing; is to use a `developer command-prompt window; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_prompt_shortcuts>`_; or call a `developer command file; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_file_locations>`_; to set the environment variables appropriately. Now you can run CMake with the Ninja generator to export a compilation; database:. .. code-block:: console. C:\> mkdir build-ninja; C:\> cd build-ninja; C:\build-ninja> cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. It is best to keep your Visual Studio IDE build folder separate from the; Ninja build folder. This prevents the two build systems from negatively; interacting with each other. Once the ``compile_commands.json`` file has been created by Ninja, you can; use that compilation database with Clang Tooling. One caveat is that because; there are indirect settings obtained through the environment variables,; you may need to run any Clang Tooling executables through a command prompt; window created for use with Visual Studio as described above. An; alternative, e.g. for using the Visual Studio debugger on a Clang Tooling; executable, is to ensure that the environment variables are also ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:4017,Modifiability,variab,variables,4017,"ndow; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_prompt_shortcuts>`_; or call a `developer command file; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_file_locations>`_; to set the environment variables appropriately. Now you can run CMake with the Ninja generator to export a compilation; database:. .. code-block:: console. C:\> mkdir build-ninja; C:\> cd build-ninja; C:\build-ninja> cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. It is best to keep your Visual Studio IDE build folder separate from the; Ninja build folder. This prevents the two build systems from negatively; interacting with each other. Once the ``compile_commands.json`` file has been created by Ninja, you can; use that compilation database with Clang Tooling. One caveat is that because; there are indirect settings obtained through the environment variables,; you may need to run any Clang Tooling executables through a command prompt; window created for use with Visual Studio as described above. An; alternative, e.g. for using the Visual Studio debugger on a Clang Tooling; executable, is to ensure that the environment variables are also visible; to the debugger settings. This can be done locally in Visual Studio's; debugger configuration locally or globally by launching the Visual Studio; IDE from a suitable command-prompt window. Using Clang Tools; =================. After you completed the previous steps, you are ready to run clang tools. If; you have a recent clang installed, you should have ``clang-check`` in; ``$PATH``. Try to run it on any ``.cpp`` file inside the LLVM source tree:. .. code-block:: console. $ clang-check tools/clang/lib/Tooling/CompilationDatabase.cpp. If you're using vim, it's convenient to have clang-check integrated. Put; this into your ``.vimrc``:. ::. function! ClangCheckImpl(cmd); if &autowrite | wall | endif; echo ""Running "" . a:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:4292,Modifiability,variab,variables,4292,"on-the-command-line?view=msvc-170#developer_command_file_locations>`_; to set the environment variables appropriately. Now you can run CMake with the Ninja generator to export a compilation; database:. .. code-block:: console. C:\> mkdir build-ninja; C:\> cd build-ninja; C:\build-ninja> cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. It is best to keep your Visual Studio IDE build folder separate from the; Ninja build folder. This prevents the two build systems from negatively; interacting with each other. Once the ``compile_commands.json`` file has been created by Ninja, you can; use that compilation database with Clang Tooling. One caveat is that because; there are indirect settings obtained through the environment variables,; you may need to run any Clang Tooling executables through a command prompt; window created for use with Visual Studio as described above. An; alternative, e.g. for using the Visual Studio debugger on a Clang Tooling; executable, is to ensure that the environment variables are also visible; to the debugger settings. This can be done locally in Visual Studio's; debugger configuration locally or globally by launching the Visual Studio; IDE from a suitable command-prompt window. Using Clang Tools; =================. After you completed the previous steps, you are ready to run clang tools. If; you have a recent clang installed, you should have ``clang-check`` in; ``$PATH``. Try to run it on any ``.cpp`` file inside the LLVM source tree:. .. code-block:: console. $ clang-check tools/clang/lib/Tooling/CompilationDatabase.cpp. If you're using vim, it's convenient to have clang-check integrated. Put; this into your ``.vimrc``:. ::. function! ClangCheckImpl(cmd); if &autowrite | wall | endif; echo ""Running "" . a:cmd . "" ...""; let l:output = system(a:cmd); cexpr l:output; cwindow; let w:quickfix_title = a:cmd; if v:shell_error != 0; cc; endif; let g:clang_check_last_cmd = a:cmd; endfunction. function! ClangCheck(); let l:filename",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:4400,Modifiability,config,configuration,4400,"rator to export a compilation; database:. .. code-block:: console. C:\> mkdir build-ninja; C:\> cd build-ninja; C:\build-ninja> cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. It is best to keep your Visual Studio IDE build folder separate from the; Ninja build folder. This prevents the two build systems from negatively; interacting with each other. Once the ``compile_commands.json`` file has been created by Ninja, you can; use that compilation database with Clang Tooling. One caveat is that because; there are indirect settings obtained through the environment variables,; you may need to run any Clang Tooling executables through a command prompt; window created for use with Visual Studio as described above. An; alternative, e.g. for using the Visual Studio debugger on a Clang Tooling; executable, is to ensure that the environment variables are also visible; to the debugger settings. This can be done locally in Visual Studio's; debugger configuration locally or globally by launching the Visual Studio; IDE from a suitable command-prompt window. Using Clang Tools; =================. After you completed the previous steps, you are ready to run clang tools. If; you have a recent clang installed, you should have ``clang-check`` in; ``$PATH``. Try to run it on any ``.cpp`` file inside the LLVM source tree:. .. code-block:: console. $ clang-check tools/clang/lib/Tooling/CompilationDatabase.cpp. If you're using vim, it's convenient to have clang-check integrated. Put; this into your ``.vimrc``:. ::. function! ClangCheckImpl(cmd); if &autowrite | wall | endif; echo ""Running "" . a:cmd . "" ...""; let l:output = system(a:cmd); cexpr l:output; cwindow; let w:quickfix_title = a:cmd; if v:shell_error != 0; cc; endif; let g:clang_check_last_cmd = a:cmd; endfunction. function! ClangCheck(); let l:filename = expand('%'); if l:filename =~ '\.\(cpp\|cxx\|cc\|c\)$'; call ClangCheckImpl(""clang-check "" . l:filename); elseif exists(""g:clang_check_last_cmd""); call Clang",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:8963,Modifiability,config,configure,8963,"er(nullptr /*Dump to stdout.*/,; this->ASTDumpFilter);; if (this->ASTPrint.operator _Bool()); return clang::CreateASTPrinter(&llvm::outs(), this->ASTDumpFilter);; return new clang::ASTConsumer();; }. Using Ninja Build System; =======================================. Optionally you can use the `Ninja`_ build system instead of make. It is; aimed at making your builds faster. Currently this step will require; building Ninja from sources. To take advantage of using Clang Tools along with Ninja build you need; at least CMake 2.8.9. Clone the Ninja git repository and build Ninja from sources:. .. code-block:: console. $ git clone git://github.com/martine/ninja.git; $ cd ninja/; $ ./bootstrap.py. This will result in a single binary ``ninja`` in the current directory.; It doesn't require installation and can just be copied to any location; inside ``$PATH``, say ``/usr/local/bin/``:. .. code-block:: console. $ sudo cp ninja /usr/local/bin/; $ sudo chmod a+rx /usr/local/bin/ninja. After doing all of this, you'll need to generate Ninja build files for; LLVM with CMake. You need to make a build directory and run CMake from; it:. .. code-block:: console. $ mkdir your/build/directory; $ cd your/build/directory; $ cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. If you want to use clang instead of GCC, you can add; ``-DCMAKE_C_COMPILER=/path/to/clang -DCMAKE_CXX_COMPILER=/path/to/clang++``.; You can also use ``ccmake``, which provides a curses interface to configure; CMake variables in an interactive manner. As a result, the new ``compile_commands.json`` file should appear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using Ninja:. .. code-block:: console. $ ninja check-all. Other target names can be used in the same way as with make. .. _Ninja: https://ninja-build.org/; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:8980,Modifiability,variab,variables,8980,"er(nullptr /*Dump to stdout.*/,; this->ASTDumpFilter);; if (this->ASTPrint.operator _Bool()); return clang::CreateASTPrinter(&llvm::outs(), this->ASTDumpFilter);; return new clang::ASTConsumer();; }. Using Ninja Build System; =======================================. Optionally you can use the `Ninja`_ build system instead of make. It is; aimed at making your builds faster. Currently this step will require; building Ninja from sources. To take advantage of using Clang Tools along with Ninja build you need; at least CMake 2.8.9. Clone the Ninja git repository and build Ninja from sources:. .. code-block:: console. $ git clone git://github.com/martine/ninja.git; $ cd ninja/; $ ./bootstrap.py. This will result in a single binary ``ninja`` in the current directory.; It doesn't require installation and can just be copied to any location; inside ``$PATH``, say ``/usr/local/bin/``:. .. code-block:: console. $ sudo cp ninja /usr/local/bin/; $ sudo chmod a+rx /usr/local/bin/ninja. After doing all of this, you'll need to generate Ninja build files for; LLVM with CMake. You need to make a build directory and run CMake from; it:. .. code-block:: console. $ mkdir your/build/directory; $ cd your/build/directory; $ cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. If you want to use clang instead of GCC, you can add; ``-DCMAKE_C_COMPILER=/path/to/clang -DCMAKE_CXX_COMPILER=/path/to/clang++``.; You can also use ``ccmake``, which provides a curses interface to configure; CMake variables in an interactive manner. As a result, the new ``compile_commands.json`` file should appear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using Ninja:. .. code-block:: console. $ ninja check-all. Other target names can be used in the same way as with make. .. _Ninja: https://ninja-build.org/; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:5480,Safety,detect,detect,5480," from a suitable command-prompt window. Using Clang Tools; =================. After you completed the previous steps, you are ready to run clang tools. If; you have a recent clang installed, you should have ``clang-check`` in; ``$PATH``. Try to run it on any ``.cpp`` file inside the LLVM source tree:. .. code-block:: console. $ clang-check tools/clang/lib/Tooling/CompilationDatabase.cpp. If you're using vim, it's convenient to have clang-check integrated. Put; this into your ``.vimrc``:. ::. function! ClangCheckImpl(cmd); if &autowrite | wall | endif; echo ""Running "" . a:cmd . "" ...""; let l:output = system(a:cmd); cexpr l:output; cwindow; let w:quickfix_title = a:cmd; if v:shell_error != 0; cc; endif; let g:clang_check_last_cmd = a:cmd; endfunction. function! ClangCheck(); let l:filename = expand('%'); if l:filename =~ '\.\(cpp\|cxx\|cc\|c\)$'; call ClangCheckImpl(""clang-check "" . l:filename); elseif exists(""g:clang_check_last_cmd""); call ClangCheckImpl(g:clang_check_last_cmd); else; echo ""Can't detect file's compilation arguments and no previous clang-check invocation!""; endif; endfunction. nmap <silent> <F5> :call ClangCheck()<CR><CR>. When editing a .cpp/.cxx/.cc/.c file, hit F5 to reparse the file. In; case the current file has a different extension (for example, .h), F5; will re-run the last clang-check invocation made from this vim instance; (if any). The output will go into the error window, which is opened; automatically when clang-check finds errors, and can be re-opened with; ``:cope``. Other ``clang-check`` options that can be useful when working with clang; AST:. * ``-ast-print`` --- Build ASTs and then pretty-print them.; * ``-ast-dump`` --- Build ASTs and then debug dump them.; * ``-ast-dump-filter=<string>`` --- Use with ``-ast-dump`` or ``-ast-print`` to; dump/print only AST declaration nodes having a certain substring in a; qualified name. Use ``-ast-list`` to list all filterable declaration node; names.; * ``-ast-list`` --- Build ASTs and print the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:1921,Testability,test,test,1921,"ls. Setup Clang Tooling Using CMake and Make; ========================================. If you intend to use make to build LLVM, you should have CMake 2.8.6 or; later installed (can be found `here <https://cmake.org>`_). First, you need to generate Makefiles for LLVM with CMake. You need to; make a build directory and run CMake from it:. .. code-block:: console. $ mkdir your/build/directory; $ cd your/build/directory; $ cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. If you want to use clang instead of GCC, you can add; ``-DCMAKE_C_COMPILER=/path/to/clang -DCMAKE_CXX_COMPILER=/path/to/clang++``.; You can also use ``ccmake``, which provides a curses interface to configure; CMake variables. As a result, the new ``compile_commands.json`` file should appear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using make:. .. code-block:: console. $ make check-all. Setup Clang Tooling Using CMake on Windows; ==========================================. For Windows developers, the Visual Studio project generators in CMake do; not support `CMAKE_EXPORT_COMPILE_COMMANDS; <https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html>`_.; However, the Ninja generator does support this variable and can be used; on Windows to generate a suitable ``compile_commands.json`` that invokes; the MSVC compiler. First, you will need to install `Ninja`_. Once installed, the Ninja; executable will need to be in your search path for CMake to locate it. Next, assuming you already have Visual Studio installed on your machine, you; need to have the appropriate environment variables configured so that CMake; will locate the MSVC compiler for the Ninja generator. The `documentation; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#path_and_envir",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:9308,Testability,test,test,9308,"er(nullptr /*Dump to stdout.*/,; this->ASTDumpFilter);; if (this->ASTPrint.operator _Bool()); return clang::CreateASTPrinter(&llvm::outs(), this->ASTDumpFilter);; return new clang::ASTConsumer();; }. Using Ninja Build System; =======================================. Optionally you can use the `Ninja`_ build system instead of make. It is; aimed at making your builds faster. Currently this step will require; building Ninja from sources. To take advantage of using Clang Tools along with Ninja build you need; at least CMake 2.8.9. Clone the Ninja git repository and build Ninja from sources:. .. code-block:: console. $ git clone git://github.com/martine/ninja.git; $ cd ninja/; $ ./bootstrap.py. This will result in a single binary ``ninja`` in the current directory.; It doesn't require installation and can just be copied to any location; inside ``$PATH``, say ``/usr/local/bin/``:. .. code-block:: console. $ sudo cp ninja /usr/local/bin/; $ sudo chmod a+rx /usr/local/bin/ninja. After doing all of this, you'll need to generate Ninja build files for; LLVM with CMake. You need to make a build directory and run CMake from; it:. .. code-block:: console. $ mkdir your/build/directory; $ cd your/build/directory; $ cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. If you want to use clang instead of GCC, you can add; ``-DCMAKE_C_COMPILER=/path/to/clang -DCMAKE_CXX_COMPILER=/path/to/clang++``.; You can also use ``ccmake``, which provides a curses interface to configure; CMake variables in an interactive manner. As a result, the new ``compile_commands.json`` file should appear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using Ninja:. .. code-block:: console. $ ninja check-all. Other target names can be used in the same way as with make. .. _Ninja: https://ninja-build.org/; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:2990,Usability,simpl,simplest,2990,"block:: console. $ make check-all. Setup Clang Tooling Using CMake on Windows; ==========================================. For Windows developers, the Visual Studio project generators in CMake do; not support `CMAKE_EXPORT_COMPILE_COMMANDS; <https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html>`_.; However, the Ninja generator does support this variable and can be used; on Windows to generate a suitable ``compile_commands.json`` that invokes; the MSVC compiler. First, you will need to install `Ninja`_. Once installed, the Ninja; executable will need to be in your search path for CMake to locate it. Next, assuming you already have Visual Studio installed on your machine, you; need to have the appropriate environment variables configured so that CMake; will locate the MSVC compiler for the Ninja generator. The `documentation; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#path_and_environment>`_; describes the necessary environment variable settings, but the simplest thing; is to use a `developer command-prompt window; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_prompt_shortcuts>`_; or call a `developer command file; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_file_locations>`_; to set the environment variables appropriately. Now you can run CMake with the Ninja generator to export a compilation; database:. .. code-block:: console. C:\> mkdir build-ninja; C:\> cd build-ninja; C:\build-ninja> cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. It is best to keep your Visual Studio IDE build folder separate from the; Ninja build folder. This prevents the two build systems from negatively; interacting with each other. Once the ``compile_commands.json`` file has been created by Ninja, you can; use that compilation database with Clang Tooling. One caveat is that becaus",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/index.rst:103,Energy Efficiency,adapt,adapt,103,".. Clang documentation master file, created by; sphinx-quickstart on Sun Dec 9 20:01:55 2012.; You can adapt this file completely to your liking, but it should at least; contain the root `toctree` directive. .. title:: Welcome to Clang's documentation!. .. toctree::; :maxdepth: 1. ReleaseNotes. Using Clang as a Compiler; =========================. .. toctree::; :maxdepth: 1. UsersManual; Toolchain; LanguageExtensions; ClangCommandLineReference; AttributeReference; DiagnosticsReference; CrossCompilation; ClangStaticAnalyzer; ThreadSafetyAnalysis; DataFlowAnalysisIntro; AddressSanitizer; ThreadSanitizer; MemorySanitizer; UndefinedBehaviorSanitizer; DataFlowSanitizer; LeakSanitizer; SanitizerCoverage; SanitizerStats; SanitizerSpecialCaseList; BoundsSafety; BoundsSafetyImplPlans; ControlFlowIntegrity; LTOVisibility; SafeStack; ShadowCallStack; SourceBasedCodeCoverage; StandardCPlusPlusModules; Modules; MSVCCompatibility; MisExpect; OpenCLSupport; OpenMPSupport; SYCLSupport; HIPSupport; HLSL/HLSLDocs; ThinLTO; APINotes; DebuggingCoroutines; AMDGPUSupport; CommandGuide/index; FAQ. Using Clang as a Library; ========================. .. toctree::; :maxdepth: 1. Tooling; ExternalClangExamples; IntroductionToTheClangAST; LibTooling; LibClang; LibFormat; ClangPlugins; RAVFrontendAction; LibASTMatchersTutorial; LibASTMatchers; ClangTransformerTutorial; LibASTImporter; HowToSetupToolingForLLVM; JSONCompilationDatabase; RefactoringEngine. Using Clang Tools; =================. .. toctree::; :maxdepth: 1. ClangTools; ClangCheck; ClangFormat; ClangFormatStyleOptions; ClangFormattedStatus; ClangLinkerWrapper; ClangOffloadBundler; ClangOffloadPackager; ClangRepl. Design Documents; ================. .. toctree::; :maxdepth: 1. CodeOwners; InternalsManual; DriverInternals; Multilib; OffloadingDesign; PCHInternals; ItaniumMangleAbiTags; HardwareAssistedAddressSanitizerDesign.rst; ConstantInterpreter. Indices and tables; ==================. * :ref:`genindex`; * :ref:`search`. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/index.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/index.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/index.rst:103,Modifiability,adapt,adapt,103,".. Clang documentation master file, created by; sphinx-quickstart on Sun Dec 9 20:01:55 2012.; You can adapt this file completely to your liking, but it should at least; contain the root `toctree` directive. .. title:: Welcome to Clang's documentation!. .. toctree::; :maxdepth: 1. ReleaseNotes. Using Clang as a Compiler; =========================. .. toctree::; :maxdepth: 1. UsersManual; Toolchain; LanguageExtensions; ClangCommandLineReference; AttributeReference; DiagnosticsReference; CrossCompilation; ClangStaticAnalyzer; ThreadSafetyAnalysis; DataFlowAnalysisIntro; AddressSanitizer; ThreadSanitizer; MemorySanitizer; UndefinedBehaviorSanitizer; DataFlowSanitizer; LeakSanitizer; SanitizerCoverage; SanitizerStats; SanitizerSpecialCaseList; BoundsSafety; BoundsSafetyImplPlans; ControlFlowIntegrity; LTOVisibility; SafeStack; ShadowCallStack; SourceBasedCodeCoverage; StandardCPlusPlusModules; Modules; MSVCCompatibility; MisExpect; OpenCLSupport; OpenMPSupport; SYCLSupport; HIPSupport; HLSL/HLSLDocs; ThinLTO; APINotes; DebuggingCoroutines; AMDGPUSupport; CommandGuide/index; FAQ. Using Clang as a Library; ========================. .. toctree::; :maxdepth: 1. Tooling; ExternalClangExamples; IntroductionToTheClangAST; LibTooling; LibClang; LibFormat; ClangPlugins; RAVFrontendAction; LibASTMatchersTutorial; LibASTMatchers; ClangTransformerTutorial; LibASTImporter; HowToSetupToolingForLLVM; JSONCompilationDatabase; RefactoringEngine. Using Clang Tools; =================. .. toctree::; :maxdepth: 1. ClangTools; ClangCheck; ClangFormat; ClangFormatStyleOptions; ClangFormattedStatus; ClangLinkerWrapper; ClangOffloadBundler; ClangOffloadPackager; ClangRepl. Design Documents; ================. .. toctree::; :maxdepth: 1. CodeOwners; InternalsManual; DriverInternals; Multilib; OffloadingDesign; PCHInternals; ItaniumMangleAbiTags; HardwareAssistedAddressSanitizerDesign.rst; ConstantInterpreter. Indices and tables; ==================. * :ref:`genindex`; * :ref:`search`. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/index.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/index.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:1919,Availability,error,errors,1919,"rary; =========================. This library certainly needs a better name. The ""basic"" library contains a; number of low-level utilities for tracking and manipulating source buffers,; locations within the source buffers, diagnostics, tokens, target abstraction,; and information about the subset of the language being compiled for. Part of this infrastructure is specific to C (such as the ``TargetInfo``; class), other parts could be reused for other non-C-based languages; (``SourceLocation``, ``SourceManager``, ``Diagnostics``, ``FileManager``).; When and if there is future demand we can figure out if it makes sense to; introduce a new library, move the general classes somewhere else, or introduce; some other solution. We describe the roles of these classes in order of their dependencies. The Diagnostics Subsystem; -------------------------. The Clang Diagnostics subsystem is an important part of how the compiler; communicates with the human. Diagnostics are the warnings and errors produced; when the code is incorrect or dubious. In Clang, each diagnostic produced has; (at the minimum) a unique ID, an English translation associated with it, a; :ref:`SourceLocation <SourceLocation>` to ""put the caret"", and a severity; (e.g., ``WARNING`` or ``ERROR``). They can also optionally include a number of; arguments to the diagnostic (which fill in ""%0""'s in the string) as well as a; number of source ranges that related to the diagnostic. In this section, we'll be giving examples produced by the Clang command line; driver, but diagnostics can be :ref:`rendered in many different ways; <DiagnosticConsumer>` depending on how the ``DiagnosticConsumer`` interface is; implemented. A representative example of a diagnostic is:. .. code-block:: text. t.c:38:15: error: invalid operands to binary expression ('int *' and '_Complex float'); P = (P-42) + Gamma*4;; ~~~~~~ ^ ~~~~~~~. In this example, you can see the English translation, the severity (error), you; can see the source location (t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:2701,Availability,error,error,2701," -------------------------. The Clang Diagnostics subsystem is an important part of how the compiler; communicates with the human. Diagnostics are the warnings and errors produced; when the code is incorrect or dubious. In Clang, each diagnostic produced has; (at the minimum) a unique ID, an English translation associated with it, a; :ref:`SourceLocation <SourceLocation>` to ""put the caret"", and a severity; (e.g., ``WARNING`` or ``ERROR``). They can also optionally include a number of; arguments to the diagnostic (which fill in ""%0""'s in the string) as well as a; number of source ranges that related to the diagnostic. In this section, we'll be giving examples produced by the Clang command line; driver, but diagnostics can be :ref:`rendered in many different ways; <DiagnosticConsumer>` depending on how the ``DiagnosticConsumer`` interface is; implemented. A representative example of a diagnostic is:. .. code-block:: text. t.c:38:15: error: invalid operands to binary expression ('int *' and '_Complex float'); P = (P-42) + Gamma*4;; ~~~~~~ ^ ~~~~~~~. In this example, you can see the English translation, the severity (error), you; can see the source location (the caret (""``^``"") and file/line/column info),; the source ranges ""``~~~~``"", arguments to the diagnostic (""``int*``"" and; ""``_Complex float``""). You'll have to believe me that there is a unique ID; backing the diagnostic :). Getting all of this to happen has several steps and involves many moving; pieces, this section describes them and talks about best practices when adding; a new diagnostic. The ``Diagnostic*Kinds.td`` files; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Diagnostics are created by adding an entry to one of the; ``clang/Basic/Diagnostic*Kinds.td`` files, depending on what library will be; using it. From this file, :program:`tblgen` generates the unique ID of the; diagnostic, the severity of the diagnostic and the English translation + format; string. There is little sanity with the naming of the unique ID'",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:2887,Availability,error,error,2887,"ode is incorrect or dubious. In Clang, each diagnostic produced has; (at the minimum) a unique ID, an English translation associated with it, a; :ref:`SourceLocation <SourceLocation>` to ""put the caret"", and a severity; (e.g., ``WARNING`` or ``ERROR``). They can also optionally include a number of; arguments to the diagnostic (which fill in ""%0""'s in the string) as well as a; number of source ranges that related to the diagnostic. In this section, we'll be giving examples produced by the Clang command line; driver, but diagnostics can be :ref:`rendered in many different ways; <DiagnosticConsumer>` depending on how the ``DiagnosticConsumer`` interface is; implemented. A representative example of a diagnostic is:. .. code-block:: text. t.c:38:15: error: invalid operands to binary expression ('int *' and '_Complex float'); P = (P-42) + Gamma*4;; ~~~~~~ ^ ~~~~~~~. In this example, you can see the English translation, the severity (error), you; can see the source location (the caret (""``^``"") and file/line/column info),; the source ranges ""``~~~~``"", arguments to the diagnostic (""``int*``"" and; ""``_Complex float``""). You'll have to believe me that there is a unique ID; backing the diagnostic :). Getting all of this to happen has several steps and involves many moving; pieces, this section describes them and talks about best practices when adding; a new diagnostic. The ``Diagnostic*Kinds.td`` files; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Diagnostics are created by adding an entry to one of the; ``clang/Basic/Diagnostic*Kinds.td`` files, depending on what library will be; using it. From this file, :program:`tblgen` generates the unique ID of the; diagnostic, the severity of the diagnostic and the English translation + format; string. There is little sanity with the naming of the unique ID's right now. Some; start with ``err_``, ``warn_``, ``ext_`` to encode the severity into the name.; Since the enum is referenced in the C++ code that produces the diagnostic, it; is somewhat us",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:4236,Availability,error,error,4236," and talks about best practices when adding; a new diagnostic. The ``Diagnostic*Kinds.td`` files; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Diagnostics are created by adding an entry to one of the; ``clang/Basic/Diagnostic*Kinds.td`` files, depending on what library will be; using it. From this file, :program:`tblgen` generates the unique ID of the; diagnostic, the severity of the diagnostic and the English translation + format; string. There is little sanity with the naming of the unique ID's right now. Some; start with ``err_``, ``warn_``, ``ext_`` to encode the severity into the name.; Since the enum is referenced in the C++ code that produces the diagnostic, it; is somewhat useful for it to be reasonably short. The severity of the diagnostic comes from the set {``NOTE``, ``REMARK``,; ``WARNING``,; ``EXTENSION``, ``EXTWARN``, ``ERROR``}. The ``ERROR`` severity is used for; diagnostics indicating the program is never acceptable under any circumstances.; When an error is emitted, the AST for the input code may not be fully built.; The ``EXTENSION`` and ``EXTWARN`` severities are used for extensions to the; language that Clang accepts. This means that Clang fully understands and can; represent them in the AST, but we produce diagnostics to tell the user their; code is non-portable. The difference is that the former are ignored by; default, and the later warn by default. The ``WARNING`` severity is used for; constructs that are valid in the currently selected source language but that; are dubious in some way. The ``REMARK`` severity provides generic information; about the compilation that is not necessarily related to any dubious code. The; ``NOTE`` level is used to staple more information onto previous diagnostics. These *severities* are mapped into a smaller set (the ``Diagnostic::Level``; enum, {``Ignored``, ``Note``, ``Remark``, ``Warning``, ``Error``, ``Fatal``}) of; output; *levels* by the diagnostics subsystem based on various configuration options.; Clang internally",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:5615,Availability,error,error,5615," the user their; code is non-portable. The difference is that the former are ignored by; default, and the later warn by default. The ``WARNING`` severity is used for; constructs that are valid in the currently selected source language but that; are dubious in some way. The ``REMARK`` severity provides generic information; about the compilation that is not necessarily related to any dubious code. The; ``NOTE`` level is used to staple more information onto previous diagnostics. These *severities* are mapped into a smaller set (the ``Diagnostic::Level``; enum, {``Ignored``, ``Note``, ``Remark``, ``Warning``, ``Error``, ``Fatal``}) of; output; *levels* by the diagnostics subsystem based on various configuration options.; Clang internally supports a fully fine grained mapping mechanism that allows; you to map almost any diagnostic to the output level that you want. The only; diagnostics that cannot be mapped are ``NOTE``\ s, which always follow the; severity of the previously emitted diagnostic and ``ERROR``\ s, which can only; be mapped to ``Fatal`` (it is not possible to turn an error into a warning, for; example). Diagnostic mappings are used in many ways. For example, if the user specifies; ``-pedantic``, ``EXTENSION`` maps to ``Warning``, if they specify; ``-pedantic-errors``, it turns into ``Error``. This is used to implement; options like ``-Wunused_macros``, ``-Wundef`` etc. Mapping to ``Fatal`` should only be used for diagnostics that are considered so; severe that error recovery won't be able to recover sensibly from them (thus; spewing a ton of bogus errors). One example of this class of error are failure; to ``#include`` a file. The Format String; ^^^^^^^^^^^^^^^^^. The format string for the diagnostic is very simple, but it has some power. It; takes the form of a string in English with markers that indicate where and how; arguments to the diagnostic are inserted and formatted. For example, here are; some simple format strings:. .. code-block:: c++. ""binary in",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:5810,Availability,error,errors,5810,"e dubious in some way. The ``REMARK`` severity provides generic information; about the compilation that is not necessarily related to any dubious code. The; ``NOTE`` level is used to staple more information onto previous diagnostics. These *severities* are mapped into a smaller set (the ``Diagnostic::Level``; enum, {``Ignored``, ``Note``, ``Remark``, ``Warning``, ``Error``, ``Fatal``}) of; output; *levels* by the diagnostics subsystem based on various configuration options.; Clang internally supports a fully fine grained mapping mechanism that allows; you to map almost any diagnostic to the output level that you want. The only; diagnostics that cannot be mapped are ``NOTE``\ s, which always follow the; severity of the previously emitted diagnostic and ``ERROR``\ s, which can only; be mapped to ``Fatal`` (it is not possible to turn an error into a warning, for; example). Diagnostic mappings are used in many ways. For example, if the user specifies; ``-pedantic``, ``EXTENSION`` maps to ``Warning``, if they specify; ``-pedantic-errors``, it turns into ``Error``. This is used to implement; options like ``-Wunused_macros``, ``-Wundef`` etc. Mapping to ``Fatal`` should only be used for diagnostics that are considered so; severe that error recovery won't be able to recover sensibly from them (thus; spewing a ton of bogus errors). One example of this class of error are failure; to ``#include`` a file. The Format String; ^^^^^^^^^^^^^^^^^. The format string for the diagnostic is very simple, but it has some power. It; takes the form of a string in English with markers that indicate where and how; arguments to the diagnostic are inserted and formatted. For example, here are; some simple format strings:. .. code-block:: c++. ""binary integer literals are an extension""; ""format string contains '\\0' within the string body""; ""more '%%' conversions than data arguments""; ""invalid operands to binary expression (%0 and %1)""; ""overloaded '%0' must be a %select{unary|binary|unary or bi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:6016,Availability,error,error,6016,"ies* are mapped into a smaller set (the ``Diagnostic::Level``; enum, {``Ignored``, ``Note``, ``Remark``, ``Warning``, ``Error``, ``Fatal``}) of; output; *levels* by the diagnostics subsystem based on various configuration options.; Clang internally supports a fully fine grained mapping mechanism that allows; you to map almost any diagnostic to the output level that you want. The only; diagnostics that cannot be mapped are ``NOTE``\ s, which always follow the; severity of the previously emitted diagnostic and ``ERROR``\ s, which can only; be mapped to ``Fatal`` (it is not possible to turn an error into a warning, for; example). Diagnostic mappings are used in many ways. For example, if the user specifies; ``-pedantic``, ``EXTENSION`` maps to ``Warning``, if they specify; ``-pedantic-errors``, it turns into ``Error``. This is used to implement; options like ``-Wunused_macros``, ``-Wundef`` etc. Mapping to ``Fatal`` should only be used for diagnostics that are considered so; severe that error recovery won't be able to recover sensibly from them (thus; spewing a ton of bogus errors). One example of this class of error are failure; to ``#include`` a file. The Format String; ^^^^^^^^^^^^^^^^^. The format string for the diagnostic is very simple, but it has some power. It; takes the form of a string in English with markers that indicate where and how; arguments to the diagnostic are inserted and formatted. For example, here are; some simple format strings:. .. code-block:: c++. ""binary integer literals are an extension""; ""format string contains '\\0' within the string body""; ""more '%%' conversions than data arguments""; ""invalid operands to binary expression (%0 and %1)""; ""overloaded '%0' must be a %select{unary|binary|unary or binary}2 operator""; "" (has %1 parameter%s1)"". These examples show some important points of format strings. You can use any; plain ASCII character in the diagnostic string except ""``%``"" without a; problem, but these are C strings, so you have to use a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:6022,Availability,recover,recovery,6022,"ies* are mapped into a smaller set (the ``Diagnostic::Level``; enum, {``Ignored``, ``Note``, ``Remark``, ``Warning``, ``Error``, ``Fatal``}) of; output; *levels* by the diagnostics subsystem based on various configuration options.; Clang internally supports a fully fine grained mapping mechanism that allows; you to map almost any diagnostic to the output level that you want. The only; diagnostics that cannot be mapped are ``NOTE``\ s, which always follow the; severity of the previously emitted diagnostic and ``ERROR``\ s, which can only; be mapped to ``Fatal`` (it is not possible to turn an error into a warning, for; example). Diagnostic mappings are used in many ways. For example, if the user specifies; ``-pedantic``, ``EXTENSION`` maps to ``Warning``, if they specify; ``-pedantic-errors``, it turns into ``Error``. This is used to implement; options like ``-Wunused_macros``, ``-Wundef`` etc. Mapping to ``Fatal`` should only be used for diagnostics that are considered so; severe that error recovery won't be able to recover sensibly from them (thus; spewing a ton of bogus errors). One example of this class of error are failure; to ``#include`` a file. The Format String; ^^^^^^^^^^^^^^^^^. The format string for the diagnostic is very simple, but it has some power. It; takes the form of a string in English with markers that indicate where and how; arguments to the diagnostic are inserted and formatted. For example, here are; some simple format strings:. .. code-block:: c++. ""binary integer literals are an extension""; ""format string contains '\\0' within the string body""; ""more '%%' conversions than data arguments""; ""invalid operands to binary expression (%0 and %1)""; ""overloaded '%0' must be a %select{unary|binary|unary or binary}2 operator""; "" (has %1 parameter%s1)"". These examples show some important points of format strings. You can use any; plain ASCII character in the diagnostic string except ""``%``"" without a; problem, but these are C strings, so you have to use a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:6048,Availability,recover,recover,6048,"ies* are mapped into a smaller set (the ``Diagnostic::Level``; enum, {``Ignored``, ``Note``, ``Remark``, ``Warning``, ``Error``, ``Fatal``}) of; output; *levels* by the diagnostics subsystem based on various configuration options.; Clang internally supports a fully fine grained mapping mechanism that allows; you to map almost any diagnostic to the output level that you want. The only; diagnostics that cannot be mapped are ``NOTE``\ s, which always follow the; severity of the previously emitted diagnostic and ``ERROR``\ s, which can only; be mapped to ``Fatal`` (it is not possible to turn an error into a warning, for; example). Diagnostic mappings are used in many ways. For example, if the user specifies; ``-pedantic``, ``EXTENSION`` maps to ``Warning``, if they specify; ``-pedantic-errors``, it turns into ``Error``. This is used to implement; options like ``-Wunused_macros``, ``-Wundef`` etc. Mapping to ``Fatal`` should only be used for diagnostics that are considered so; severe that error recovery won't be able to recover sensibly from them (thus; spewing a ton of bogus errors). One example of this class of error are failure; to ``#include`` a file. The Format String; ^^^^^^^^^^^^^^^^^. The format string for the diagnostic is very simple, but it has some power. It; takes the form of a string in English with markers that indicate where and how; arguments to the diagnostic are inserted and formatted. For example, here are; some simple format strings:. .. code-block:: c++. ""binary integer literals are an extension""; ""format string contains '\\0' within the string body""; ""more '%%' conversions than data arguments""; ""invalid operands to binary expression (%0 and %1)""; ""overloaded '%0' must be a %select{unary|binary|unary or binary}2 operator""; "" (has %1 parameter%s1)"". These examples show some important points of format strings. You can use any; plain ASCII character in the diagnostic string except ""``%``"" without a; problem, but these are C strings, so you have to use a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:6105,Availability,error,errors,6105,"ies* are mapped into a smaller set (the ``Diagnostic::Level``; enum, {``Ignored``, ``Note``, ``Remark``, ``Warning``, ``Error``, ``Fatal``}) of; output; *levels* by the diagnostics subsystem based on various configuration options.; Clang internally supports a fully fine grained mapping mechanism that allows; you to map almost any diagnostic to the output level that you want. The only; diagnostics that cannot be mapped are ``NOTE``\ s, which always follow the; severity of the previously emitted diagnostic and ``ERROR``\ s, which can only; be mapped to ``Fatal`` (it is not possible to turn an error into a warning, for; example). Diagnostic mappings are used in many ways. For example, if the user specifies; ``-pedantic``, ``EXTENSION`` maps to ``Warning``, if they specify; ``-pedantic-errors``, it turns into ``Error``. This is used to implement; options like ``-Wunused_macros``, ``-Wundef`` etc. Mapping to ``Fatal`` should only be used for diagnostics that are considered so; severe that error recovery won't be able to recover sensibly from them (thus; spewing a ton of bogus errors). One example of this class of error are failure; to ``#include`` a file. The Format String; ^^^^^^^^^^^^^^^^^. The format string for the diagnostic is very simple, but it has some power. It; takes the form of a string in English with markers that indicate where and how; arguments to the diagnostic are inserted and formatted. For example, here are; some simple format strings:. .. code-block:: c++. ""binary integer literals are an extension""; ""format string contains '\\0' within the string body""; ""more '%%' conversions than data arguments""; ""invalid operands to binary expression (%0 and %1)""; ""overloaded '%0' must be a %select{unary|binary|unary or binary}2 operator""; "" (has %1 parameter%s1)"". These examples show some important points of format strings. You can use any; plain ASCII character in the diagnostic string except ""``%``"" without a; problem, but these are C strings, so you have to use a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:6143,Availability,error,error,6143,"atal``}) of; output; *levels* by the diagnostics subsystem based on various configuration options.; Clang internally supports a fully fine grained mapping mechanism that allows; you to map almost any diagnostic to the output level that you want. The only; diagnostics that cannot be mapped are ``NOTE``\ s, which always follow the; severity of the previously emitted diagnostic and ``ERROR``\ s, which can only; be mapped to ``Fatal`` (it is not possible to turn an error into a warning, for; example). Diagnostic mappings are used in many ways. For example, if the user specifies; ``-pedantic``, ``EXTENSION`` maps to ``Warning``, if they specify; ``-pedantic-errors``, it turns into ``Error``. This is used to implement; options like ``-Wunused_macros``, ``-Wundef`` etc. Mapping to ``Fatal`` should only be used for diagnostics that are considered so; severe that error recovery won't be able to recover sensibly from them (thus; spewing a ton of bogus errors). One example of this class of error are failure; to ``#include`` a file. The Format String; ^^^^^^^^^^^^^^^^^. The format string for the diagnostic is very simple, but it has some power. It; takes the form of a string in English with markers that indicate where and how; arguments to the diagnostic are inserted and formatted. For example, here are; some simple format strings:. .. code-block:: c++. ""binary integer literals are an extension""; ""format string contains '\\0' within the string body""; ""more '%%' conversions than data arguments""; ""invalid operands to binary expression (%0 and %1)""; ""overloaded '%0' must be a %select{unary|binary|unary or binary}2 operator""; "" (has %1 parameter%s1)"". These examples show some important points of format strings. You can use any; plain ASCII character in the diagnostic string except ""``%``"" without a; problem, but these are C strings, so you have to use and be aware of all the C; escape sequences (as in the second example). If you want to produce a ""``%``""; in the output, use the ""``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:6153,Availability,failure,failure,6153,"atal``}) of; output; *levels* by the diagnostics subsystem based on various configuration options.; Clang internally supports a fully fine grained mapping mechanism that allows; you to map almost any diagnostic to the output level that you want. The only; diagnostics that cannot be mapped are ``NOTE``\ s, which always follow the; severity of the previously emitted diagnostic and ``ERROR``\ s, which can only; be mapped to ``Fatal`` (it is not possible to turn an error into a warning, for; example). Diagnostic mappings are used in many ways. For example, if the user specifies; ``-pedantic``, ``EXTENSION`` maps to ``Warning``, if they specify; ``-pedantic-errors``, it turns into ``Error``. This is used to implement; options like ``-Wunused_macros``, ``-Wundef`` etc. Mapping to ``Fatal`` should only be used for diagnostics that are considered so; severe that error recovery won't be able to recover sensibly from them (thus; spewing a ton of bogus errors). One example of this class of error are failure; to ``#include`` a file. The Format String; ^^^^^^^^^^^^^^^^^. The format string for the diagnostic is very simple, but it has some power. It; takes the form of a string in English with markers that indicate where and how; arguments to the diagnostic are inserted and formatted. For example, here are; some simple format strings:. .. code-block:: c++. ""binary integer literals are an extension""; ""format string contains '\\0' within the string body""; ""more '%%' conversions than data arguments""; ""invalid operands to binary expression (%0 and %1)""; ""overloaded '%0' must be a %select{unary|binary|unary or binary}2 operator""; "" (has %1 parameter%s1)"". These examples show some important points of format strings. You can use any; plain ASCII character in the diagnostic string except ""``%``"" without a; problem, but these are C strings, so you have to use and be aware of all the C; escape sequences (as in the second example). If you want to produce a ""``%``""; in the output, use the ""``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:13256,Availability,error,error,13256," to true is; the result of the modifier. An expression can be empty, in which case it is always true. See the example; at the top. Otherwise, it is a series of one or more numeric conditions,; separated by "","". If any condition matches, the expression matches. Each; numeric condition can take one of three forms. * number: A simple decimal number matches if the argument is the same as the; number. Example: ``""%plural{1:mouse|:mice}0""``; * range: A range in square brackets matches if the argument is within the; range. Then range is inclusive on both ends. Example:; ``""%plural{0:none|1:one|[2,5]:some|:many}0""``; * modulo: A modulo operator is followed by a number, and equals sign and; either a number or a range. The tests are the same as for plain numbers; and ranges, but the argument is taken modulo the number first. Example:; ``""%plural{%100=0:even hundred|%100=[1,50]:lower half|:everything else}1""``. The parser is very unforgiving. A syntax error, even whitespace, will abort,; as will a failure to match the argument against any expression. **""ordinal"" format**. Example:; ``""ambiguity in %ordinal0 argument""``; Class:; Integers; Description:; This is a formatter which represents the argument number as an ordinal: the; value ``1`` becomes ``1st``, ``3`` becomes ``3rd``, and so on. Values less; than ``1`` are not supported. This formatter is currently hard-coded to use; English ordinals. **""objcclass"" format**. Example:; ``""method %objcclass0 not found""``; Class:; ``DeclarationName``; Description:; This is a simple formatter that indicates the ``DeclarationName`` corresponds; to an Objective-C class method selector. As such, it prints the selector; with a leading ""``+``"". **""objcinstance"" format**. Example:; ``""method %objcinstance0 not found""``; Class:; ``DeclarationName``; Description:; This is a simple formatter that indicates the ``DeclarationName`` corresponds; to an Objective-C instance method selector. As such, it prints the selector; with a leading ""``-``"". **""q",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:13303,Availability,failure,failure,13303," to true is; the result of the modifier. An expression can be empty, in which case it is always true. See the example; at the top. Otherwise, it is a series of one or more numeric conditions,; separated by "","". If any condition matches, the expression matches. Each; numeric condition can take one of three forms. * number: A simple decimal number matches if the argument is the same as the; number. Example: ``""%plural{1:mouse|:mice}0""``; * range: A range in square brackets matches if the argument is within the; range. Then range is inclusive on both ends. Example:; ``""%plural{0:none|1:one|[2,5]:some|:many}0""``; * modulo: A modulo operator is followed by a number, and equals sign and; either a number or a range. The tests are the same as for plain numbers; and ranges, but the argument is taken modulo the number first. Example:; ``""%plural{%100=0:even hundred|%100=[1,50]:lower half|:everything else}1""``. The parser is very unforgiving. A syntax error, even whitespace, will abort,; as will a failure to match the argument against any expression. **""ordinal"" format**. Example:; ``""ambiguity in %ordinal0 argument""``; Class:; Integers; Description:; This is a formatter which represents the argument number as an ordinal: the; value ``1`` becomes ``1st``, ``3`` becomes ``3rd``, and so on. Values less; than ``1`` are not supported. This formatter is currently hard-coded to use; English ordinals. **""objcclass"" format**. Example:; ``""method %objcclass0 not found""``; Class:; ``DeclarationName``; Description:; This is a simple formatter that indicates the ``DeclarationName`` corresponds; to an Objective-C class method selector. As such, it prints the selector; with a leading ""``+``"". **""objcinstance"" format**. Example:; ``""method %objcinstance0 not found""``; Class:; ``DeclarationName``; Description:; This is a simple formatter that indicates the ``DeclarationName`` corresponds; to an Objective-C instance method selector. As such, it prints the selector; with a leading ""``-``"". **""q",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:16441,Availability,error,error,16441,"``""candidate %select{function|constructor}3%select{| template| %1}2 not viable""``.; Description:; This format specifier is used to avoid repeating strings verbatim in multiple; diagnostics. The argument to ``%sub`` must name a ``TextSubstitution`` tblgen; record. The substitution must specify all arguments used by the substitution,; and the modifier indexes in the substitution are re-numbered accordingly. The; substituted text must itself be a valid format string before substitution. .. _internals-producing-diag:. Producing the Diagnostic; ^^^^^^^^^^^^^^^^^^^^^^^^. Now that you've created the diagnostic in the ``Diagnostic*Kinds.td`` file, you; need to write the code that detects the condition in question and emits the new; diagnostic. Various components of Clang (e.g., the preprocessor, ``Sema``,; etc.) provide a helper function named ""``Diag``"". It creates a diagnostic and; accepts the arguments, ranges, and other information that goes along with it. For example, the binary expression error comes from code like this:. .. code-block:: c++. if (various things that are bad); Diag(Loc, diag::err_typecheck_invalid_operands); << lex->getType() << rex->getType(); << lex->getSourceRange() << rex->getSourceRange();. This shows that use of the ``Diag`` method: it takes a location (a; :ref:`SourceLocation <SourceLocation>` object) and a diagnostic enum value; (which matches the name from ``Diagnostic*Kinds.td``). If the diagnostic takes; arguments, they are specified with the ``<<`` operator: the first argument; becomes ``%0``, the second becomes ``%1``, etc. The diagnostic interface; allows you to specify arguments of many different types, including ``int`` and; ``unsigned`` for integer arguments, ``const char*`` and ``std::string`` for; string arguments, ``DeclarationName`` and ``const IdentifierInfo *`` for names,; ``QualType`` for types, etc. ``SourceRange``\ s are also specified with the; ``<<`` operator, but do not have a specific ordering requirement. As you can see, a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:18182,Availability,recover,recover,18182,"``std::string`` for; string arguments, ``DeclarationName`` and ``const IdentifierInfo *`` for names,; ``QualType`` for types, etc. ``SourceRange``\ s are also specified with the; ``<<`` operator, but do not have a specific ordering requirement. As you can see, adding and producing a diagnostic is pretty straightforward.; The hard part is deciding exactly what you need to say to help the user,; picking a suitable wording, and providing the information needed to format it; correctly. The good news is that the call site that issues a diagnostic should; be completely independent of how the diagnostic is formatted and in what; language it is rendered. Fix-It Hints; ^^^^^^^^^^^^. In some cases, the front end emits diagnostics when it is clear that some small; change to the source code would fix the problem. For example, a missing; semicolon at the end of a statement or a use of deprecated syntax that is; easily rewritten into a more modern form. Clang tries very hard to emit the; diagnostic and recover gracefully in these and other cases. However, for these cases where the fix is obvious, the diagnostic can be; annotated with a hint (referred to as a ""fix-it hint"") that describes how to; change the code referenced by the diagnostic to fix the problem. For example,; it might add the missing semicolon at the end of the statement or rewrite the; use of a deprecated construct into something more palatable. Here is one such; example from the C++ front end, where we warn about the right-shift operator; changing meaning from C++98 to C++11:. .. code-block:: text. test.cpp:3:7: warning: use of right-shift operator ('>>') in template argument; will require parentheses in C++11; A<100 >> 2> *a;; ^; ( ). Here, the fix-it hint is suggesting that parentheses be added, and showing; exactly where those parentheses would be inserted into the source code. The; fix-it hints themselves describe what changes to make to the source code in an; abstract manner, which the text diagnostic printer ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:19445,Availability,error,errors,19445,"t might add the missing semicolon at the end of the statement or rewrite the; use of a deprecated construct into something more palatable. Here is one such; example from the C++ front end, where we warn about the right-shift operator; changing meaning from C++98 to C++11:. .. code-block:: text. test.cpp:3:7: warning: use of right-shift operator ('>>') in template argument; will require parentheses in C++11; A<100 >> 2> *a;; ^; ( ). Here, the fix-it hint is suggesting that parentheses be added, and showing; exactly where those parentheses would be inserted into the source code. The; fix-it hints themselves describe what changes to make to the source code in an; abstract manner, which the text diagnostic printer renders as a line of; ""insertions"" below the caret line. :ref:`Other diagnostic clients; <DiagnosticConsumer>` might choose to render the code differently (e.g., as; markup inline) or even give the user the ability to automatically fix the; problem. Fix-it hints on errors and warnings need to obey these rules:. * Since they are automatically applied if ``-Xclang -fixit`` is passed to the; driver, they should only be used when it's very likely they match the user's; intent.; * Clang must recover from errors as if the fix-it had been applied.; * Fix-it hints on a warning must not change the meaning of the code.; However, a hint may clarify the meaning as intentional, for example by adding; parentheses when the precedence of operators isn't obvious. If a fix-it can't obey these rules, put the fix-it on a note. Fix-its on notes; are not applied automatically. All fix-it hints are described by the ``FixItHint`` class, instances of which; should be attached to the diagnostic using the ``<<`` operator in the same way; that highlighted source ranges and arguments are passed to the diagnostic.; Fix-it hints can be created with one of three constructors:. * ``FixItHint::CreateInsertion(Loc, Code)``. Specifies that the given ``Code`` (a string) should be inserted before t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:19671,Availability,recover,recover,19671,"or; changing meaning from C++98 to C++11:. .. code-block:: text. test.cpp:3:7: warning: use of right-shift operator ('>>') in template argument; will require parentheses in C++11; A<100 >> 2> *a;; ^; ( ). Here, the fix-it hint is suggesting that parentheses be added, and showing; exactly where those parentheses would be inserted into the source code. The; fix-it hints themselves describe what changes to make to the source code in an; abstract manner, which the text diagnostic printer renders as a line of; ""insertions"" below the caret line. :ref:`Other diagnostic clients; <DiagnosticConsumer>` might choose to render the code differently (e.g., as; markup inline) or even give the user the ability to automatically fix the; problem. Fix-it hints on errors and warnings need to obey these rules:. * Since they are automatically applied if ``-Xclang -fixit`` is passed to the; driver, they should only be used when it's very likely they match the user's; intent.; * Clang must recover from errors as if the fix-it had been applied.; * Fix-it hints on a warning must not change the meaning of the code.; However, a hint may clarify the meaning as intentional, for example by adding; parentheses when the precedence of operators isn't obvious. If a fix-it can't obey these rules, put the fix-it on a note. Fix-its on notes; are not applied automatically. All fix-it hints are described by the ``FixItHint`` class, instances of which; should be attached to the diagnostic using the ``<<`` operator in the same way; that highlighted source ranges and arguments are passed to the diagnostic.; Fix-it hints can be created with one of three constructors:. * ``FixItHint::CreateInsertion(Loc, Code)``. Specifies that the given ``Code`` (a string) should be inserted before the; source location ``Loc``. * ``FixItHint::CreateRemoval(Range)``. Specifies that the code in the given source ``Range`` should be removed. * ``FixItHint::CreateReplacement(Range, Code)``. Specifies that the code in the given sour",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:19684,Availability,error,errors,19684,"or; changing meaning from C++98 to C++11:. .. code-block:: text. test.cpp:3:7: warning: use of right-shift operator ('>>') in template argument; will require parentheses in C++11; A<100 >> 2> *a;; ^; ( ). Here, the fix-it hint is suggesting that parentheses be added, and showing; exactly where those parentheses would be inserted into the source code. The; fix-it hints themselves describe what changes to make to the source code in an; abstract manner, which the text diagnostic printer renders as a line of; ""insertions"" below the caret line. :ref:`Other diagnostic clients; <DiagnosticConsumer>` might choose to render the code differently (e.g., as; markup inline) or even give the user the ability to automatically fix the; problem. Fix-it hints on errors and warnings need to obey these rules:. * Since they are automatically applied if ``-Xclang -fixit`` is passed to the; driver, they should only be used when it's very likely they match the user's; intent.; * Clang must recover from errors as if the fix-it had been applied.; * Fix-it hints on a warning must not change the meaning of the code.; However, a hint may clarify the meaning as intentional, for example by adding; parentheses when the precedence of operators isn't obvious. If a fix-it can't obey these rules, put the fix-it on a note. Fix-its on notes; are not applied automatically. All fix-it hints are described by the ``FixItHint`` class, instances of which; should be attached to the diagnostic using the ``<<`` operator in the same way; that highlighted source ranges and arguments are passed to the diagnostic.; Fix-it hints can be created with one of three constructors:. * ``FixItHint::CreateInsertion(Loc, Code)``. Specifies that the given ``Code`` (a string) should be inserted before the; source location ``Loc``. * ``FixItHint::CreateRemoval(Range)``. Specifies that the code in the given source ``Range`` should be removed. * ``FixItHint::CreateReplacement(Range, Code)``. Specifies that the code in the given sour",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:22331,Availability,down,down,22331,"s possible to implement this interface in many different ways. For; example, the normal Clang ``DiagnosticConsumer`` (named; ``TextDiagnosticPrinter``) turns the arguments into strings (according to the; various formatting rules), prints out the file/line/column information and the; string, then prints out the line of code, the source ranges, and the caret.; However, this behavior isn't required. Another implementation of the ``DiagnosticConsumer`` interface is the; ``TextDiagnosticBuffer`` class, which is used when Clang is in ``-verify``; mode. Instead of formatting and printing out the diagnostics, this; implementation just captures and remembers the diagnostics as they fly by.; Then ``-verify`` compares the list of produced diagnostics to the list of; expected ones. If they disagree, it prints out its own output. Full; documentation for the ``-verify`` mode can be found at; :ref:`verifying-diagnostics`. There are many other possible implementations of this interface, and this is; why we prefer diagnostics to pass down rich structured information in; arguments. For example, an HTML output might want declaration names be; linkified to where they come from in the source. Another example is that a GUI; might let you click on typedefs to expand them. This application would want to; pass significantly more information about types through to the GUI than a; simple flat string. The interface allows this to happen. .. _internals-diag-translation:. Adding Translations to Clang; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Not possible yet! Diagnostic strings should be written in UTF-8, the client can; translate to the relevant code page if needed. Each translation completely; replaces the format string for the diagnostic. .. _SourceLocation:; .. _SourceManager:. The ``SourceLocation`` and ``SourceManager`` classes; ----------------------------------------------------. Strangely enough, the ``SourceLocation`` class represents a location within the; source code of the program. Important d",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:30528,Availability,avail,available,30528,"argument,; * ``JoinedOrSeparate`` - the value can be specified either as ``Joined`` or; ``Separate``,; * ``CommaJoined`` - the values are comma-separated and must immediately follow; the option name within the same argument (see ``Wl,`` for an example). The helper classes take a list of acceptable prefixes of the option (e.g.; ``""-""``, ``""--""`` or ``""/""``) and the option name:. .. code-block:: diff. // Options.td. + def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">;. Then, specify additional attributes via mix-ins:. * ``HelpText`` holds the text that will be printed besides the option name when; the user requests help (e.g. via ``clang --help``).; * ``Group`` specifies the ""category"" of options this option belongs to. This is; used by various tools to categorize and sometimes filter options.; * ``Flags`` may contain ""tags"" associated with the option. These may affect how; the option is rendered, or if it's hidden in some contexts.; * ``Visibility`` should be used to specify the drivers in which a particular; option would be available. This attribute will impact tool --help; * ``Alias`` denotes that the option is an alias of another option. This may be; combined with ``AliasArgs`` that holds the implied value. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; + Group<f_Group>, Visibility<[ClangOption, CC1Option]>,; + HelpText<""Load pass plugin from a dynamic shared object file."">;. New options are recognized by the ``clang`` driver mode if ``Visibility`` is; not specified or contains ``ClangOption``. Options intended for ``clang -cc1``; must be explicitly marked with the ``CC1Option`` flag. Flags that specify; ``CC1Option`` but not ``ClangOption`` will only be accessible via ``-cc1``.; This is similar for other driver modes, such as ``clang-cl`` or ``flang``. Next, parse (or manufacture) the command line arguments in the Clang driver and; use them to construct the ``-cc1`` job:. .. code-block:: diff. void Clang::ConstructJ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:32399,Availability,avail,available,32399,"n the Clang driver and; use them to construct the ``-cc1`` job:. .. code-block:: diff. void Clang::ConstructJob(const ArgList &Args /*...*/) const {; ArgStringList CmdArgs;; // ... + for (const Arg *A : Args.filtered(OPT_fpass_plugin_EQ)) {; + CmdArgs.push_back(Args.MakeArgString(Twine(""-fpass-plugin="") + A->getValue()));; + A->claim();; + }; }. The last step is implementing the ``-cc1`` command line argument; parsing/generation that initializes/serializes the option class (in our case; ``CodeGenOptions``) stored within ``CompilerInvocation``. This can be done; automatically by using the marshalling annotations on the option definition:. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; Group<f_Group>, Flags<[CC1Option]>,; HelpText<""Load pass plugin from a dynamic shared object file."">,; + MarshallingInfoStringVector<CodeGenOpts<""PassPlugins"">>;. Inner workings of the system are introduced in the :ref:`marshalling; infrastructure <OptionMarshalling>` section and the available annotations are; listed :ref:`here <OptionMarshallingAnnotations>`. In case the marshalling infrastructure does not support the desired semantics,; consider simplifying it to fit the existing model. This makes the command line; more uniform and reduces the amount of custom, manually written code. Remember; that the ``-cc1`` command line interface is intended only for Clang developers,; meaning it does not need to mirror the driver interface, maintain backward; compatibility or be compatible with GCC. If the option semantics cannot be encoded via marshalling annotations, you can; resort to parsing/serializing the command line arguments manually:. .. code-block:: diff. // CompilerInvocation.cpp. static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args /*...*/) {; // ... + Opts.PassPlugins = Args.getAllArgValues(OPT_fpass_plugin_EQ);; }. static void GenerateCodeGenArgs(const CodeGenOptions &Opts,; SmallVectorImpl<const char *> &Args,; CompilerInvoc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:42088,Availability,error,error,42088,"on the command line are appended to the; vector. .. code-block:: text. def frewrite_map_file : Separate<[""-""], ""frewrite-map-file"">,; Visibility<[ClangOption, CC1Option]>,; MarshallingInfoStringVector<CodeGenOpts<""RewriteMapFiles"">>;. **Integer**. The key path defaults to the specified integer value, or ``0`` if omitted. When; the option appears on the command line, its value gets parsed by ``llvm::APInt``; and the result is assigned to the key path on success. .. code-block:: text. def mstack_probe_size : Joined<[""-""], ""mstack-probe-size="">,; Visibility<[ClangOption, CC1Option]>,; MarshallingInfoInt<CodeGenOpts<""StackProbeSize"">, ""4096"">;. **Enumeration**. The key path defaults to the value specified in ``MarshallingInfoEnum`` prefixed; by the contents of ``NormalizedValuesScope`` and ``::``. This ensures correct; reference to an enum case is formed even if the enum resides in different; namespace or is an enum class. If the value present on command line does not; match any of the comma-separated values from ``Values``, an error diagnostics is; issued. Otherwise, the corresponding element from ``NormalizedValues`` at the; same index is assigned to the key path (also correctly scoped). The number of; comma-separated string values and elements of the array within; ``NormalizedValues`` must match. .. code-block:: text. def mthread_model : Separate<[""-""], ""mthread-model"">,; Visibility<[ClangOption, CC1Option]>,; Values<""posix,single"">, NormalizedValues<[""POSIX"", ""Single""]>,; NormalizedValuesScope<""LangOptions::ThreadModelKind"">,; MarshallingInfoEnum<LangOpts<""ThreadModel"">, ""POSIX"">;. ..; Intentionally omitting MarshallingInfoBitfieldFlag. It's adding some; complexity to the marshalling infrastructure and might be removed. It is also possible to define relationships between options. **Implication**. The key path defaults to the default value from the primary ``Marshalling``; annotation. Then, if any of the elements of ``ImpliedByAnyOf`` evaluate to true,; the key path v",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:54382,Availability,error,error,54382,"token. .. _Lexer:. The ``Lexer`` class; -------------------. The ``Lexer`` class provides the mechanics of lexing tokens out of a source; buffer and deciding what they mean. The ``Lexer`` is complicated by the fact; that it operates on raw buffers that have not had spelling eliminated (this is; a necessity to get decent performance), but this is countered with careful; coding as well as standard performance techniques (for example, the comment; handling code is vectorized on X86 and PowerPC hosts). The lexer has a couple of interesting modal features:. * The lexer can operate in ""raw"" mode. This mode has several features that; make it possible to quickly lex the file (e.g., it stops identifier lookup,; doesn't specially handle preprocessor tokens, handles EOF differently, etc).; This mode is used for lexing within an ""``#if 0``"" block, for example.; * The lexer can capture and return comments as tokens. This is required to; support the ``-C`` preprocessor mode, which passes comments through, and is; used by the diagnostic checker to identifier expect-error annotations.; * The lexer can be in ``ParsingFilename`` mode, which happens when; preprocessing after reading a ``#include`` directive. This mode changes the; parsing of ""``<``"" to return an ""angled string"" instead of a bunch of tokens; for each thing within the filename.; * When parsing a preprocessor directive (after ""``#``"") the; ``ParsingPreprocessorDirective`` mode is entered. This changes the parser to; return EOD at a newline.; * The ``Lexer`` uses a ``LangOptions`` object to know whether trigraphs are; enabled, whether C++ or ObjC keywords are recognized, etc. In addition to these modes, the lexer keeps track of a couple of other features; that are local to a lexed buffer, which change as the buffer is lexed:. * The ``Lexer`` uses ``BufferPtr`` to keep track of the current character being; lexed.; * The ``Lexer`` uses ``IsAtStartOfLine`` to keep track of whether the next; lexed token will start with its ""st",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:61961,Availability,error,error,61961,"used when representing different (but related) syntaxes for nodes; with the same or similar semantics. .. _Type:. The ``Type`` class and its subclasses; -------------------------------------. The ``Type`` class (and its subclasses) are an important part of the AST.; Types are accessed through the ``ASTContext`` class, which implicitly creates; and uniques them as they are needed. Types have a couple of non-obvious; features: 1) they do not capture type qualifiers like ``const`` or ``volatile``; (see :ref:`QualType <QualType>`), and 2) they implicitly capture typedef; information. Once created, types are immutable (unlike decls). Typedefs in C make semantic analysis a bit more complex than it would be without; them. The issue is that we want to capture typedef information and represent it; in the AST perfectly, but the semantics of operations need to ""see through""; typedefs. For example, consider this code:. .. code-block:: c++. void func() {; typedef int foo;; foo X, *Y;; typedef foo *bar;; bar Z;; *X; // error; **Y; // error; **Z; // error; }. The code above is illegal, and thus we expect there to be diagnostics emitted; on the annotated lines. In this example, we expect to get:. .. code-block:: text. test.c:6:1: error: indirection requires pointer operand ('foo' invalid); *X; // error; ^~; test.c:7:1: error: indirection requires pointer operand ('foo' invalid); **Y; // error; ^~~; test.c:8:1: error: indirection requires pointer operand ('foo' invalid); **Z; // error; ^~~. While this example is somewhat silly, it illustrates the point: we want to; retain typedef information where possible, so that we can emit errors about; ""``std::string``"" instead of ""``std::basic_string<char, std:...``"". Doing this; requires properly keeping typedef information (for example, the type of ``X``; is ""``foo``"", not ""``int``""), and requires properly propagating it through the; various operators (for example, the type of ``*Y`` is ""``foo``"", not; ""``int``""). In order to retain this info",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:61976,Availability,error,error,61976,"used when representing different (but related) syntaxes for nodes; with the same or similar semantics. .. _Type:. The ``Type`` class and its subclasses; -------------------------------------. The ``Type`` class (and its subclasses) are an important part of the AST.; Types are accessed through the ``ASTContext`` class, which implicitly creates; and uniques them as they are needed. Types have a couple of non-obvious; features: 1) they do not capture type qualifiers like ``const`` or ``volatile``; (see :ref:`QualType <QualType>`), and 2) they implicitly capture typedef; information. Once created, types are immutable (unlike decls). Typedefs in C make semantic analysis a bit more complex than it would be without; them. The issue is that we want to capture typedef information and represent it; in the AST perfectly, but the semantics of operations need to ""see through""; typedefs. For example, consider this code:. .. code-block:: c++. void func() {; typedef int foo;; foo X, *Y;; typedef foo *bar;; bar Z;; *X; // error; **Y; // error; **Z; // error; }. The code above is illegal, and thus we expect there to be diagnostics emitted; on the annotated lines. In this example, we expect to get:. .. code-block:: text. test.c:6:1: error: indirection requires pointer operand ('foo' invalid); *X; // error; ^~; test.c:7:1: error: indirection requires pointer operand ('foo' invalid); **Y; // error; ^~~; test.c:8:1: error: indirection requires pointer operand ('foo' invalid); **Z; // error; ^~~. While this example is somewhat silly, it illustrates the point: we want to; retain typedef information where possible, so that we can emit errors about; ""``std::string``"" instead of ""``std::basic_string<char, std:...``"". Doing this; requires properly keeping typedef information (for example, the type of ``X``; is ""``foo``"", not ""``int``""), and requires properly propagating it through the; various operators (for example, the type of ``*Y`` is ""``foo``"", not; ""``int``""). In order to retain this info",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:61991,Availability,error,error,61991,"used when representing different (but related) syntaxes for nodes; with the same or similar semantics. .. _Type:. The ``Type`` class and its subclasses; -------------------------------------. The ``Type`` class (and its subclasses) are an important part of the AST.; Types are accessed through the ``ASTContext`` class, which implicitly creates; and uniques them as they are needed. Types have a couple of non-obvious; features: 1) they do not capture type qualifiers like ``const`` or ``volatile``; (see :ref:`QualType <QualType>`), and 2) they implicitly capture typedef; information. Once created, types are immutable (unlike decls). Typedefs in C make semantic analysis a bit more complex than it would be without; them. The issue is that we want to capture typedef information and represent it; in the AST perfectly, but the semantics of operations need to ""see through""; typedefs. For example, consider this code:. .. code-block:: c++. void func() {; typedef int foo;; foo X, *Y;; typedef foo *bar;; bar Z;; *X; // error; **Y; // error; **Z; // error; }. The code above is illegal, and thus we expect there to be diagnostics emitted; on the annotated lines. In this example, we expect to get:. .. code-block:: text. test.c:6:1: error: indirection requires pointer operand ('foo' invalid); *X; // error; ^~; test.c:7:1: error: indirection requires pointer operand ('foo' invalid); **Y; // error; ^~~; test.c:8:1: error: indirection requires pointer operand ('foo' invalid); **Z; // error; ^~~. While this example is somewhat silly, it illustrates the point: we want to; retain typedef information where possible, so that we can emit errors about; ""``std::string``"" instead of ""``std::basic_string<char, std:...``"". Doing this; requires properly keeping typedef information (for example, the type of ``X``; is ""``foo``"", not ""``int``""), and requires properly propagating it through the; various operators (for example, the type of ``*Y`` is ""``foo``"", not; ""``int``""). In order to retain this info",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:62174,Availability,error,error,62174," are accessed through the ``ASTContext`` class, which implicitly creates; and uniques them as they are needed. Types have a couple of non-obvious; features: 1) they do not capture type qualifiers like ``const`` or ``volatile``; (see :ref:`QualType <QualType>`), and 2) they implicitly capture typedef; information. Once created, types are immutable (unlike decls). Typedefs in C make semantic analysis a bit more complex than it would be without; them. The issue is that we want to capture typedef information and represent it; in the AST perfectly, but the semantics of operations need to ""see through""; typedefs. For example, consider this code:. .. code-block:: c++. void func() {; typedef int foo;; foo X, *Y;; typedef foo *bar;; bar Z;; *X; // error; **Y; // error; **Z; // error; }. The code above is illegal, and thus we expect there to be diagnostics emitted; on the annotated lines. In this example, we expect to get:. .. code-block:: text. test.c:6:1: error: indirection requires pointer operand ('foo' invalid); *X; // error; ^~; test.c:7:1: error: indirection requires pointer operand ('foo' invalid); **Y; // error; ^~~; test.c:8:1: error: indirection requires pointer operand ('foo' invalid); **Z; // error; ^~~. While this example is somewhat silly, it illustrates the point: we want to; retain typedef information where possible, so that we can emit errors about; ""``std::string``"" instead of ""``std::basic_string<char, std:...``"". Doing this; requires properly keeping typedef information (for example, the type of ``X``; is ""``foo``"", not ""``int``""), and requires properly propagating it through the; various operators (for example, the type of ``*Y`` is ""``foo``"", not; ""``int``""). In order to retain this information, the type of these expressions; is an instance of the ``TypedefType`` class, which indicates that the type of; these expressions is a typedef for ""``foo``"". Representing types like this is great for diagnostics, because the; user-specified type is always immediate",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:62242,Availability,error,error,62242," are accessed through the ``ASTContext`` class, which implicitly creates; and uniques them as they are needed. Types have a couple of non-obvious; features: 1) they do not capture type qualifiers like ``const`` or ``volatile``; (see :ref:`QualType <QualType>`), and 2) they implicitly capture typedef; information. Once created, types are immutable (unlike decls). Typedefs in C make semantic analysis a bit more complex than it would be without; them. The issue is that we want to capture typedef information and represent it; in the AST perfectly, but the semantics of operations need to ""see through""; typedefs. For example, consider this code:. .. code-block:: c++. void func() {; typedef int foo;; foo X, *Y;; typedef foo *bar;; bar Z;; *X; // error; **Y; // error; **Z; // error; }. The code above is illegal, and thus we expect there to be diagnostics emitted; on the annotated lines. In this example, we expect to get:. .. code-block:: text. test.c:6:1: error: indirection requires pointer operand ('foo' invalid); *X; // error; ^~; test.c:7:1: error: indirection requires pointer operand ('foo' invalid); **Y; // error; ^~~; test.c:8:1: error: indirection requires pointer operand ('foo' invalid); **Z; // error; ^~~. While this example is somewhat silly, it illustrates the point: we want to; retain typedef information where possible, so that we can emit errors about; ""``std::string``"" instead of ""``std::basic_string<char, std:...``"". Doing this; requires properly keeping typedef information (for example, the type of ``X``; is ""``foo``"", not ""``int``""), and requires properly propagating it through the; various operators (for example, the type of ``*Y`` is ""``foo``"", not; ""``int``""). In order to retain this information, the type of these expressions; is an instance of the ``TypedefType`` class, which indicates that the type of; these expressions is a typedef for ""``foo``"". Representing types like this is great for diagnostics, because the; user-specified type is always immediate",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:62265,Availability,error,error,62265,"s they are needed. Types have a couple of non-obvious; features: 1) they do not capture type qualifiers like ``const`` or ``volatile``; (see :ref:`QualType <QualType>`), and 2) they implicitly capture typedef; information. Once created, types are immutable (unlike decls). Typedefs in C make semantic analysis a bit more complex than it would be without; them. The issue is that we want to capture typedef information and represent it; in the AST perfectly, but the semantics of operations need to ""see through""; typedefs. For example, consider this code:. .. code-block:: c++. void func() {; typedef int foo;; foo X, *Y;; typedef foo *bar;; bar Z;; *X; // error; **Y; // error; **Z; // error; }. The code above is illegal, and thus we expect there to be diagnostics emitted; on the annotated lines. In this example, we expect to get:. .. code-block:: text. test.c:6:1: error: indirection requires pointer operand ('foo' invalid); *X; // error; ^~; test.c:7:1: error: indirection requires pointer operand ('foo' invalid); **Y; // error; ^~~; test.c:8:1: error: indirection requires pointer operand ('foo' invalid); **Z; // error; ^~~. While this example is somewhat silly, it illustrates the point: we want to; retain typedef information where possible, so that we can emit errors about; ""``std::string``"" instead of ""``std::basic_string<char, std:...``"". Doing this; requires properly keeping typedef information (for example, the type of ``X``; is ""``foo``"", not ""``int``""), and requires properly propagating it through the; various operators (for example, the type of ``*Y`` is ""``foo``"", not; ""``int``""). In order to retain this information, the type of these expressions; is an instance of the ``TypedefType`` class, which indicates that the type of; these expressions is a typedef for ""``foo``"". Representing types like this is great for diagnostics, because the; user-specified type is always immediately available. There are two problems; with this: first, various semantic checks need to make",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:62334,Availability,error,error,62334,"s they are needed. Types have a couple of non-obvious; features: 1) they do not capture type qualifiers like ``const`` or ``volatile``; (see :ref:`QualType <QualType>`), and 2) they implicitly capture typedef; information. Once created, types are immutable (unlike decls). Typedefs in C make semantic analysis a bit more complex than it would be without; them. The issue is that we want to capture typedef information and represent it; in the AST perfectly, but the semantics of operations need to ""see through""; typedefs. For example, consider this code:. .. code-block:: c++. void func() {; typedef int foo;; foo X, *Y;; typedef foo *bar;; bar Z;; *X; // error; **Y; // error; **Z; // error; }. The code above is illegal, and thus we expect there to be diagnostics emitted; on the annotated lines. In this example, we expect to get:. .. code-block:: text. test.c:6:1: error: indirection requires pointer operand ('foo' invalid); *X; // error; ^~; test.c:7:1: error: indirection requires pointer operand ('foo' invalid); **Y; // error; ^~~; test.c:8:1: error: indirection requires pointer operand ('foo' invalid); **Z; // error; ^~~. While this example is somewhat silly, it illustrates the point: we want to; retain typedef information where possible, so that we can emit errors about; ""``std::string``"" instead of ""``std::basic_string<char, std:...``"". Doing this; requires properly keeping typedef information (for example, the type of ``X``; is ""``foo``"", not ""``int``""), and requires properly propagating it through the; various operators (for example, the type of ``*Y`` is ""``foo``"", not; ""``int``""). In order to retain this information, the type of these expressions; is an instance of the ``TypedefType`` class, which indicates that the type of; these expressions is a typedef for ""``foo``"". Representing types like this is great for diagnostics, because the; user-specified type is always immediately available. There are two problems; with this: first, various semantic checks need to make",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:62358,Availability,error,error,62358,"pe qualifiers like ``const`` or ``volatile``; (see :ref:`QualType <QualType>`), and 2) they implicitly capture typedef; information. Once created, types are immutable (unlike decls). Typedefs in C make semantic analysis a bit more complex than it would be without; them. The issue is that we want to capture typedef information and represent it; in the AST perfectly, but the semantics of operations need to ""see through""; typedefs. For example, consider this code:. .. code-block:: c++. void func() {; typedef int foo;; foo X, *Y;; typedef foo *bar;; bar Z;; *X; // error; **Y; // error; **Z; // error; }. The code above is illegal, and thus we expect there to be diagnostics emitted; on the annotated lines. In this example, we expect to get:. .. code-block:: text. test.c:6:1: error: indirection requires pointer operand ('foo' invalid); *X; // error; ^~; test.c:7:1: error: indirection requires pointer operand ('foo' invalid); **Y; // error; ^~~; test.c:8:1: error: indirection requires pointer operand ('foo' invalid); **Z; // error; ^~~. While this example is somewhat silly, it illustrates the point: we want to; retain typedef information where possible, so that we can emit errors about; ""``std::string``"" instead of ""``std::basic_string<char, std:...``"". Doing this; requires properly keeping typedef information (for example, the type of ``X``; is ""``foo``"", not ""``int``""), and requires properly propagating it through the; various operators (for example, the type of ``*Y`` is ""``foo``"", not; ""``int``""). In order to retain this information, the type of these expressions; is an instance of the ``TypedefType`` class, which indicates that the type of; these expressions is a typedef for ""``foo``"". Representing types like this is great for diagnostics, because the; user-specified type is always immediately available. There are two problems; with this: first, various semantic checks need to make judgements about the; *actual structure* of a type, ignoring typedefs. Second, we need an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:62427,Availability,error,error,62427,"pe qualifiers like ``const`` or ``volatile``; (see :ref:`QualType <QualType>`), and 2) they implicitly capture typedef; information. Once created, types are immutable (unlike decls). Typedefs in C make semantic analysis a bit more complex than it would be without; them. The issue is that we want to capture typedef information and represent it; in the AST perfectly, but the semantics of operations need to ""see through""; typedefs. For example, consider this code:. .. code-block:: c++. void func() {; typedef int foo;; foo X, *Y;; typedef foo *bar;; bar Z;; *X; // error; **Y; // error; **Z; // error; }. The code above is illegal, and thus we expect there to be diagnostics emitted; on the annotated lines. In this example, we expect to get:. .. code-block:: text. test.c:6:1: error: indirection requires pointer operand ('foo' invalid); *X; // error; ^~; test.c:7:1: error: indirection requires pointer operand ('foo' invalid); **Y; // error; ^~~; test.c:8:1: error: indirection requires pointer operand ('foo' invalid); **Z; // error; ^~~. While this example is somewhat silly, it illustrates the point: we want to; retain typedef information where possible, so that we can emit errors about; ""``std::string``"" instead of ""``std::basic_string<char, std:...``"". Doing this; requires properly keeping typedef information (for example, the type of ``X``; is ""``foo``"", not ""``int``""), and requires properly propagating it through the; various operators (for example, the type of ``*Y`` is ""``foo``"", not; ""``int``""). In order to retain this information, the type of these expressions; is an instance of the ``TypedefType`` class, which indicates that the type of; these expressions is a typedef for ""``foo``"". Representing types like this is great for diagnostics, because the; user-specified type is always immediately available. There are two problems; with this: first, various semantic checks need to make judgements about the; *actual structure* of a type, ignoring typedefs. Second, we need an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:62578,Availability,error,errors,62578,"s are immutable (unlike decls). Typedefs in C make semantic analysis a bit more complex than it would be without; them. The issue is that we want to capture typedef information and represent it; in the AST perfectly, but the semantics of operations need to ""see through""; typedefs. For example, consider this code:. .. code-block:: c++. void func() {; typedef int foo;; foo X, *Y;; typedef foo *bar;; bar Z;; *X; // error; **Y; // error; **Z; // error; }. The code above is illegal, and thus we expect there to be diagnostics emitted; on the annotated lines. In this example, we expect to get:. .. code-block:: text. test.c:6:1: error: indirection requires pointer operand ('foo' invalid); *X; // error; ^~; test.c:7:1: error: indirection requires pointer operand ('foo' invalid); **Y; // error; ^~~; test.c:8:1: error: indirection requires pointer operand ('foo' invalid); **Z; // error; ^~~. While this example is somewhat silly, it illustrates the point: we want to; retain typedef information where possible, so that we can emit errors about; ""``std::string``"" instead of ""``std::basic_string<char, std:...``"". Doing this; requires properly keeping typedef information (for example, the type of ``X``; is ""``foo``"", not ""``int``""), and requires properly propagating it through the; various operators (for example, the type of ``*Y`` is ""``foo``"", not; ""``int``""). In order to retain this information, the type of these expressions; is an instance of the ``TypedefType`` class, which indicates that the type of; these expressions is a typedef for ""``foo``"". Representing types like this is great for diagnostics, because the; user-specified type is always immediately available. There are two problems; with this: first, various semantic checks need to make judgements about the; *actual structure* of a type, ignoring typedefs. Second, we need an efficient; way to query whether two types are structurally identical to each other,; ignoring typedefs. The solution to both of these problems is the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:63216,Availability,avail,available,63216,"t.c:6:1: error: indirection requires pointer operand ('foo' invalid); *X; // error; ^~; test.c:7:1: error: indirection requires pointer operand ('foo' invalid); **Y; // error; ^~~; test.c:8:1: error: indirection requires pointer operand ('foo' invalid); **Z; // error; ^~~. While this example is somewhat silly, it illustrates the point: we want to; retain typedef information where possible, so that we can emit errors about; ""``std::string``"" instead of ""``std::basic_string<char, std:...``"". Doing this; requires properly keeping typedef information (for example, the type of ``X``; is ""``foo``"", not ""``int``""), and requires properly propagating it through the; various operators (for example, the type of ``*Y`` is ""``foo``"", not; ""``int``""). In order to retain this information, the type of these expressions; is an instance of the ``TypedefType`` class, which indicates that the type of; these expressions is a typedef for ""``foo``"". Representing types like this is great for diagnostics, because the; user-specified type is always immediately available. There are two problems; with this: first, various semantic checks need to make judgements about the; *actual structure* of a type, ignoring typedefs. Second, we need an efficient; way to query whether two types are structurally identical to each other,; ignoring typedefs. The solution to both of these problems is the idea of; canonical types. .. _CanonicalType:. Canonical Types; ^^^^^^^^^^^^^^^. Every instance of the ``Type`` class contains a canonical type pointer. For; simple types with no typedefs involved (e.g., ""``int``"", ""``int*``"",; ""``int**``""), the type just points to itself. For types that have a typedef; somewhere in their structure (e.g., ""``foo``"", ""``foo*``"", ""``foo**``"",; ""``bar``""), the canonical type pointer points to their structurally equivalent; type without any typedefs (e.g., ""``int``"", ""``int*``"", ""``int**``"", and; ""``int*``"" respectively). This design provides a constant time operation (dereferencing t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:69885,Availability,mask,masked,69885,"entities --- variables,; functions, Objective-C methods, C++ constructors, destructors, and operators; --- are represented as subclasses of Clang's common ``NamedDecl`` class,; ``DeclarationName`` is designed to efficiently represent any kind of name. Given a ``DeclarationName`` ``N``, ``N.getNameKind()`` will produce a value; that describes what kind of name ``N`` stores. There are 10 options (all of; the names are inside the ``DeclarationName`` class). ``Identifier``. The name is a simple identifier. Use ``N.getAsIdentifierInfo()`` to retrieve; the corresponding ``IdentifierInfo*`` pointing to the actual identifier. ``ObjCZeroArgSelector``, ``ObjCOneArgSelector``, ``ObjCMultiArgSelector``. The name is an Objective-C selector, which can be retrieved as a ``Selector``; instance via ``N.getObjCSelector()``. The three possible name kinds for; Objective-C reflect an optimization within the ``DeclarationName`` class:; both zero- and one-argument selectors are stored as a masked; ``IdentifierInfo`` pointer, and therefore require very little space, since; zero- and one-argument selectors are far more common than multi-argument; selectors (which use a different structure). ``CXXConstructorName``. The name is a C++ constructor name. Use ``N.getCXXNameType()`` to retrieve; the :ref:`type <QualType>` that this constructor is meant to construct. The; type is always the canonical type, since all constructors for a given type; have the same name. ``CXXDestructorName``. The name is a C++ destructor name. Use ``N.getCXXNameType()`` to retrieve; the :ref:`type <QualType>` whose destructor is being named. This type is; always a canonical type. ``CXXConversionFunctionName``. The name is a C++ conversion function. Conversion functions are named; according to the type they convert to, e.g., ""``operator void const *``"".; Use ``N.getCXXNameType()`` to retrieve the type that this conversion function; converts to. This type is always a canonical type. ``CXXOperatorName``. The name is a C++ ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:72748,Availability,avail,available,72748,"ext; effectively. ``DeclarationName``\ s are cheap to create, copy, and compare. They require; only a single pointer's worth of storage in the common cases (identifiers,; zero- and one-argument Objective-C selectors) and use dense, uniqued storage; for the other kinds of names. Two ``DeclarationName``\ s can be compared for; equality (``==``, ``!=``) using a simple bitwise comparison, can be ordered; with ``<``, ``>``, ``<=``, and ``>=`` (which provide a lexicographical ordering; for normal identifiers but an unspecified ordering for other kinds of names),; and can be placed into LLVM ``DenseMap``\ s and ``DenseSet``\ s. ``DeclarationName`` instances can be created in different ways depending on; what kind of name the instance will store. Normal identifiers; (``IdentifierInfo`` pointers) and Objective-C selectors (``Selector``) can be; implicitly converted to ``DeclarationNames``. Names for C++ constructors,; destructors, conversion functions, and overloaded operators can be retrieved; from the ``DeclarationNameTable``, an instance of which is available as; ``ASTContext::DeclarationNames``. The member functions; ``getCXXConstructorName``, ``getCXXDestructorName``,; ``getCXXConversionFunctionName``, and ``getCXXOperatorName``, respectively,; return ``DeclarationName`` instances for the four kinds of C++ special function; names. .. _DeclContext:. Declaration contexts; --------------------. Every declaration in a program exists within some *declaration context*, such; as a translation unit, namespace, class, or function. Declaration contexts in; Clang are represented by the ``DeclContext`` class, from which the various; declaration-context AST nodes (``TranslationUnitDecl``, ``NamespaceDecl``,; ``RecordDecl``, ``FunctionDecl``, etc.) will derive. The ``DeclContext`` class; provides several facilities common to each declaration context:. Source-centric vs. Semantics-centric View of Declarations. ``DeclContext`` provides two views of the declarations stored within a; dec",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:84381,Availability,error,errors,84381,"llContexts``. Note that these functions are used; internally within the lookup and insertion methods of the ``DeclContext``, so; the vast majority of clients can ignore them. Because the same entity can be defined multiple times in different modules,; it is also possible for there to be multiple definitions of (for instance); a ``CXXRecordDecl``, all of which describe a definition of the same class.; In such a case, only one of those ""definitions"" is considered by Clang to be; the definition of the class, and the others are treated as non-defining; declarations that happen to also contain member declarations. Corresponding; members in each definition of such multiply-defined classes are identified; either by redeclaration chains (if the members are ``Redeclarable``); or by simply a pointer to the canonical declaration (if the declarations; are not ``Redeclarable`` -- in that case, a ``Mergeable`` base class is used; instead). Error Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we dont have; graceful recovery. Prior to R",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:84491,Availability,error,errors,84491,"on methods of the ``DeclContext``, so; the vast majority of clients can ignore them. Because the same entity can be defined multiple times in different modules,; it is also possible for there to be multiple definitions of (for instance); a ``CXXRecordDecl``, all of which describe a definition of the same class.; In such a case, only one of those ""definitions"" is considered by Clang to be; the definition of the class, and the others are treated as non-defining; declarations that happen to also contain member declarations. Corresponding; members in each definition of such multiply-defined classes are identified; either by redeclaration chains (if the members are ``Redeclarable``); or by simply a pointer to the canonical declaration (if the declarations; are not ``Redeclarable`` -- in that case, a ``Mergeable`` base class is used; instead). Error Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we dont have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:84644,Availability,error,errors,84644,"nce); a ``CXXRecordDecl``, all of which describe a definition of the same class.; In such a case, only one of those ""definitions"" is considered by Clang to be; the definition of the class, and the others are treated as non-defining; declarations that happen to also contain member declarations. Corresponding; members in each definition of such multiply-defined classes are identified; either by redeclaration chains (if the members are ``Redeclarable``); or by simply a pointer to the canonical declaration (if the declarations; are not ``Redeclarable`` -- in that case, a ``Mergeable`` base class is used; instead). Error Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we dont have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr was created for semantic analysis. With these strategies, clang surfaces better diagnostics, and provides AST; consumers a rich AST reflecting the written source code as much as possible even; for broken code. Recovery AST; ^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:84669,Availability,error,error-recovery,84669,"nce); a ``CXXRecordDecl``, all of which describe a definition of the same class.; In such a case, only one of those ""definitions"" is considered by Clang to be; the definition of the class, and the others are treated as non-defining; declarations that happen to also contain member declarations. Corresponding; members in each definition of such multiply-defined classes are identified; either by redeclaration chains (if the members are ``Redeclarable``); or by simply a pointer to the canonical declaration (if the declarations; are not ``Redeclarable`` -- in that case, a ``Mergeable`` base class is used; instead). Error Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we dont have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr was created for semantic analysis. With these strategies, clang surfaces better diagnostics, and provides AST; consumers a rich AST reflecting the written source code as much as possible even; for broken code. Recovery AST; ^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:84749,Availability,error,errors,84749," be; the definition of the class, and the others are treated as non-defining; declarations that happen to also contain member declarations. Corresponding; members in each definition of such multiply-defined classes are identified; either by redeclaration chains (if the members are ``Redeclarable``); or by simply a pointer to the canonical declaration (if the declarations; are not ``Redeclarable`` -- in that case, a ``Mergeable`` base class is used; instead). Error Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we dont have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr was created for semantic analysis. With these strategies, clang surfaces better diagnostics, and provides AST; consumers a rich AST reflecting the written source code as much as possible even; for broken code. Recovery AST; ^^^^^^^^^^^^. The idea of Recovery AST is to use recovery nodes which act as a placeholder to; maintain the rough structure of the parsing tree, preserve locations",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:84844,Availability,error,error,84844," be; the definition of the class, and the others are treated as non-defining; declarations that happen to also contain member declarations. Corresponding; members in each definition of such multiply-defined classes are identified; either by redeclaration chains (if the members are ``Redeclarable``); or by simply a pointer to the canonical declaration (if the declarations; are not ``Redeclarable`` -- in that case, a ``Mergeable`` base class is used; instead). Error Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we dont have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr was created for semantic analysis. With these strategies, clang surfaces better diagnostics, and provides AST; consumers a rich AST reflecting the written source code as much as possible even; for broken code. Recovery AST; ^^^^^^^^^^^^. The idea of Recovery AST is to use recovery nodes which act as a placeholder to; maintain the rough structure of the parsing tree, preserve locations",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:85210,Availability,error,errors,85210,"eclarations; are not ``Redeclarable`` -- in that case, a ``Mergeable`` base class is used; instead). Error Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we dont have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr was created for semantic analysis. With these strategies, clang surfaces better diagnostics, and provides AST; consumers a rich AST reflecting the written source code as much as possible even; for broken code. Recovery AST; ^^^^^^^^^^^^. The idea of Recovery AST is to use recovery nodes which act as a placeholder to; maintain the rough structure of the parsing tree, preserve locations and; children but have no language semantics attached to them. For example, consider the following mismatched function call:. .. code-block:: c++. int NoArg();; void test(int abc) {; NoArg(abc); // oops, mismatched function arguments.; }. Without Recovery AST, the invalid function call expression (and its child; expressions) would be dropped in the AST:. ::.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:85303,Availability,error,errors,85303,"rror Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we dont have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr was created for semantic analysis. With these strategies, clang surfaces better diagnostics, and provides AST; consumers a rich AST reflecting the written source code as much as possible even; for broken code. Recovery AST; ^^^^^^^^^^^^. The idea of Recovery AST is to use recovery nodes which act as a placeholder to; maintain the rough structure of the parsing tree, preserve locations and; children but have no language semantics attached to them. For example, consider the following mismatched function call:. .. code-block:: c++. int NoArg();; void test(int abc) {; NoArg(abc); // oops, mismatched function arguments.; }. Without Recovery AST, the invalid function call expression (and its child; expressions) would be dropped in the AST:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:85339,Availability,recover,recovery,85339,"rror Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we dont have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr was created for semantic analysis. With these strategies, clang surfaces better diagnostics, and provides AST; consumers a rich AST reflecting the written source code as much as possible even; for broken code. Recovery AST; ^^^^^^^^^^^^. The idea of Recovery AST is to use recovery nodes which act as a placeholder to; maintain the rough structure of the parsing tree, preserve locations and; children but have no language semantics attached to them. For example, consider the following mismatched function call:. .. code-block:: c++. int NoArg();; void test(int abc) {; NoArg(abc); // oops, mismatched function arguments.; }. Without Recovery AST, the invalid function call expression (and its child; expressions) would be dropped in the AST:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:85723,Availability,recover,recovery,85723,"out the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we dont have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr was created for semantic analysis. With these strategies, clang surfaces better diagnostics, and provides AST; consumers a rich AST reflecting the written source code as much as possible even; for broken code. Recovery AST; ^^^^^^^^^^^^. The idea of Recovery AST is to use recovery nodes which act as a placeholder to; maintain the rough structure of the parsing tree, preserve locations and; children but have no language semantics attached to them. For example, consider the following mismatched function call:. .. code-block:: c++. int NoArg();; void test(int abc) {; NoArg(abc); // oops, mismatched function arguments.; }. Without Recovery AST, the invalid function call expression (and its child; expressions) would be dropped in the AST:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> col:15 used abc 'int'; `-CompoundStmt <col:20, line:4:1>. With Recovery AST, the AST looks like:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> used abc 'int'; `-CompoundStmt <col:20, line:4:1>; `-RecoveryExpr <line:3:3, col:12> 'int' contains-errors; |-UnresolvedLookupExpr <col:3> '<overloaded function type>' lvalue (ADL) = 'NoArg'; `-DeclRefExpr <col:9> 'int' l",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:86673,Availability,error,errors,86673,"possible even; for broken code. Recovery AST; ^^^^^^^^^^^^. The idea of Recovery AST is to use recovery nodes which act as a placeholder to; maintain the rough structure of the parsing tree, preserve locations and; children but have no language semantics attached to them. For example, consider the following mismatched function call:. .. code-block:: c++. int NoArg();; void test(int abc) {; NoArg(abc); // oops, mismatched function arguments.; }. Without Recovery AST, the invalid function call expression (and its child; expressions) would be dropped in the AST:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> col:15 used abc 'int'; `-CompoundStmt <col:20, line:4:1>. With Recovery AST, the AST looks like:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> used abc 'int'; `-CompoundStmt <col:20, line:4:1>; `-RecoveryExpr <line:3:3, col:12> 'int' contains-errors; |-UnresolvedLookupExpr <col:3> '<overloaded function type>' lvalue (ADL) = 'NoArg'; `-DeclRefExpr <col:9> 'int' lvalue ParmVar 'abc' 'int'. An alternative is to use existing Exprs, e.g. CallExpr for the above example.; This would capture more call details (e.g. locations of parentheses) and allow; it to be treated uniformly with valid CallExprs. However, jamming the data we; have into CallExpr forces us to weaken its invariants, e.g. arg count may be; wrong. This would introduce a huge burden on consumers of the AST to handle such; ""impossible"" cases. So when we're representing (rather than correcting) errors,; we use a distinct recovery node type with extremely weak invariants instead. ``RecoveryExpr`` is the only recovery node so far. In practice, broken decls; need more detailed semantics preserved (the current ``Invalid`` flag works; fairly well), and completely broken statements with interesting internal; structure are rare (so ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:87291,Availability,error,errors,87291,"armVarDecl <col:11, col:15> col:15 used abc 'int'; `-CompoundStmt <col:20, line:4:1>. With Recovery AST, the AST looks like:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> used abc 'int'; `-CompoundStmt <col:20, line:4:1>; `-RecoveryExpr <line:3:3, col:12> 'int' contains-errors; |-UnresolvedLookupExpr <col:3> '<overloaded function type>' lvalue (ADL) = 'NoArg'; `-DeclRefExpr <col:9> 'int' lvalue ParmVar 'abc' 'int'. An alternative is to use existing Exprs, e.g. CallExpr for the above example.; This would capture more call details (e.g. locations of parentheses) and allow; it to be treated uniformly with valid CallExprs. However, jamming the data we; have into CallExpr forces us to weaken its invariants, e.g. arg count may be; wrong. This would introduce a huge burden on consumers of the AST to handle such; ""impossible"" cases. So when we're representing (rather than correcting) errors,; we use a distinct recovery node type with extremely weak invariants instead. ``RecoveryExpr`` is the only recovery node so far. In practice, broken decls; need more detailed semantics preserved (the current ``Invalid`` flag works; fairly well), and completely broken statements with interesting internal; structure are rare (so dropping the statements is OK). Types and dependence; ^^^^^^^^^^^^^^^^^^^^. ``RecoveryExpr`` is an ``Expr``, so it must have a type. In many cases the true; type can't really be known until the code is corrected (e.g. a call to a; function that doesn't exist). And it means that we can't properly perform type; checks on some containing constructs, such as ``return 42 + unknownFunction()``. To model this, we generalize the concept of dependence from C++ templates to; mean dependence on a template parameter or how an error is repaired. The; ``RecoveryExpr`` ``unknownFunction()`` has the totally unknown type; ``DependentTy``, and this suppresses type-based analysis in the sa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:87318,Availability,recover,recovery,87318,"armVarDecl <col:11, col:15> col:15 used abc 'int'; `-CompoundStmt <col:20, line:4:1>. With Recovery AST, the AST looks like:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> used abc 'int'; `-CompoundStmt <col:20, line:4:1>; `-RecoveryExpr <line:3:3, col:12> 'int' contains-errors; |-UnresolvedLookupExpr <col:3> '<overloaded function type>' lvalue (ADL) = 'NoArg'; `-DeclRefExpr <col:9> 'int' lvalue ParmVar 'abc' 'int'. An alternative is to use existing Exprs, e.g. CallExpr for the above example.; This would capture more call details (e.g. locations of parentheses) and allow; it to be treated uniformly with valid CallExprs. However, jamming the data we; have into CallExpr forces us to weaken its invariants, e.g. arg count may be; wrong. This would introduce a huge burden on consumers of the AST to handle such; ""impossible"" cases. So when we're representing (rather than correcting) errors,; we use a distinct recovery node type with extremely weak invariants instead. ``RecoveryExpr`` is the only recovery node so far. In practice, broken decls; need more detailed semantics preserved (the current ``Invalid`` flag works; fairly well), and completely broken statements with interesting internal; structure are rare (so dropping the statements is OK). Types and dependence; ^^^^^^^^^^^^^^^^^^^^. ``RecoveryExpr`` is an ``Expr``, so it must have a type. In many cases the true; type can't really be known until the code is corrected (e.g. a call to a; function that doesn't exist). And it means that we can't properly perform type; checks on some containing constructs, such as ``return 42 + unknownFunction()``. To model this, we generalize the concept of dependence from C++ templates to; mean dependence on a template parameter or how an error is repaired. The; ``RecoveryExpr`` ``unknownFunction()`` has the totally unknown type; ``DependentTy``, and this suppresses type-based analysis in the sa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:87406,Availability,recover,recovery,87406,"overy AST, the AST looks like:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> used abc 'int'; `-CompoundStmt <col:20, line:4:1>; `-RecoveryExpr <line:3:3, col:12> 'int' contains-errors; |-UnresolvedLookupExpr <col:3> '<overloaded function type>' lvalue (ADL) = 'NoArg'; `-DeclRefExpr <col:9> 'int' lvalue ParmVar 'abc' 'int'. An alternative is to use existing Exprs, e.g. CallExpr for the above example.; This would capture more call details (e.g. locations of parentheses) and allow; it to be treated uniformly with valid CallExprs. However, jamming the data we; have into CallExpr forces us to weaken its invariants, e.g. arg count may be; wrong. This would introduce a huge burden on consumers of the AST to handle such; ""impossible"" cases. So when we're representing (rather than correcting) errors,; we use a distinct recovery node type with extremely weak invariants instead. ``RecoveryExpr`` is the only recovery node so far. In practice, broken decls; need more detailed semantics preserved (the current ``Invalid`` flag works; fairly well), and completely broken statements with interesting internal; structure are rare (so dropping the statements is OK). Types and dependence; ^^^^^^^^^^^^^^^^^^^^. ``RecoveryExpr`` is an ``Expr``, so it must have a type. In many cases the true; type can't really be known until the code is corrected (e.g. a call to a; function that doesn't exist). And it means that we can't properly perform type; checks on some containing constructs, such as ``return 42 + unknownFunction()``. To model this, we generalize the concept of dependence from C++ templates to; mean dependence on a template parameter or how an error is repaired. The; ``RecoveryExpr`` ``unknownFunction()`` has the totally unknown type; ``DependentTy``, and this suppresses type-based analysis in the same way it; would inside a template. In cases where we are confident about the concrete type (e.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:88148,Availability,error,error,88148,"eaken its invariants, e.g. arg count may be; wrong. This would introduce a huge burden on consumers of the AST to handle such; ""impossible"" cases. So when we're representing (rather than correcting) errors,; we use a distinct recovery node type with extremely weak invariants instead. ``RecoveryExpr`` is the only recovery node so far. In practice, broken decls; need more detailed semantics preserved (the current ``Invalid`` flag works; fairly well), and completely broken statements with interesting internal; structure are rare (so dropping the statements is OK). Types and dependence; ^^^^^^^^^^^^^^^^^^^^. ``RecoveryExpr`` is an ``Expr``, so it must have a type. In many cases the true; type can't really be known until the code is corrected (e.g. a call to a; function that doesn't exist). And it means that we can't properly perform type; checks on some containing constructs, such as ``return 42 + unknownFunction()``. To model this, we generalize the concept of dependence from C++ templates to; mean dependence on a template parameter or how an error is repaired. The; ``RecoveryExpr`` ``unknownFunction()`` has the totally unknown type; ``DependentTy``, and this suppresses type-based analysis in the same way it; would inside a template. In cases where we are confident about the concrete type (e.g. the return type; for a broken non-overloaded function call), the ``RecoveryExpr`` will have this; type. This allows more code to be typechecked, and produces a better AST and; more diagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:88157,Availability,repair,repaired,88157,"eaken its invariants, e.g. arg count may be; wrong. This would introduce a huge burden on consumers of the AST to handle such; ""impossible"" cases. So when we're representing (rather than correcting) errors,; we use a distinct recovery node type with extremely weak invariants instead. ``RecoveryExpr`` is the only recovery node so far. In practice, broken decls; need more detailed semantics preserved (the current ``Invalid`` flag works; fairly well), and completely broken statements with interesting internal; structure are rare (so dropping the statements is OK). Types and dependence; ^^^^^^^^^^^^^^^^^^^^. ``RecoveryExpr`` is an ``Expr``, so it must have a type. In many cases the true; type can't really be known until the code is corrected (e.g. a call to a; function that doesn't exist). And it means that we can't properly perform type; checks on some containing constructs, such as ``return 42 + unknownFunction()``. To model this, we generalize the concept of dependence from C++ templates to; mean dependence on a template parameter or how an error is repaired. The; ``RecoveryExpr`` ``unknownFunction()`` has the totally unknown type; ``DependentTy``, and this suppresses type-based analysis in the same way it; would inside a template. In cases where we are confident about the concrete type (e.g. the return type; for a broken non-overloaded function call), the ``RecoveryExpr`` will have this; type. This allows more code to be typechecked, and produces a better AST and; more diagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:88911,Availability,error,error,88911,"a call to a; function that doesn't exist). And it means that we can't properly perform type; checks on some containing constructs, such as ``return 42 + unknownFunction()``. To model this, we generalize the concept of dependence from C++ templates to; mean dependence on a template parameter or how an error is repaired. The; ``RecoveryExpr`` ``unknownFunction()`` has the totally unknown type; ``DependentTy``, and this suppresses type-based analysis in the same way it; would inside a template. In cases where we are confident about the concrete type (e.g. the return type; for a broken non-overloaded function call), the ``RecoveryExpr`` will have this; type. This allows more code to be typechecked, and produces a better AST and; more diagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new ContainsErrors bit to; express Does this expression or anything within it contain errors semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:88991,Availability,error,errors,88991,"return 42 + unknownFunction()``. To model this, we generalize the concept of dependence from C++ templates to; mean dependence on a template parameter or how an error is repaired. The; ``RecoveryExpr`` ``unknownFunction()`` has the totally unknown type; ``DependentTy``, and this suppresses type-based analysis in the same way it; would inside a template. In cases where we are confident about the concrete type (e.g. the return type; for a broken non-overloaded function call), the ``RecoveryExpr`` will have this; type. This allows more code to be typechecked, and produces a better AST and; more diagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new ContainsErrors bit to; express Does this expression or anything within it contain errors semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89272,Availability,error,errors,89272,"y``, and this suppresses type-based analysis in the same way it; would inside a template. In cases where we are confident about the concrete type (e.g. the return type; for a broken non-overloaded function call), the ``RecoveryExpr`` will have this; type. This allows more code to be typechecked, and produces a better AST and; more diagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new ContainsErrors bit to; express Does this expression or anything within it contain errors semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89461,Availability,error,error,89461,"verloaded function call), the ``RecoveryExpr`` will have this; type. This allows more code to be typechecked, and produces a better AST and; more diagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new ContainsErrors bit to; express Does this expression or anything within it contain errors semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89546,Availability,recover,recoveryExpr,89546,"iagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new ContainsErrors bit to; express Does this expression or anything within it contain errors semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not a tree. It is a directed graph with; cycles. One example of a cycle is the connection between a; ``ClassTemplateDecl`` and its ""templated"" ``CXXRe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89635,Availability,error,errors,89635,"iagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new ContainsErrors bit to; express Does this expression or anything within it contain errors semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not a tree. It is a directed graph with; cycles. One example of a cycle is the connection between a; ``ClassTemplateDecl`` and its ""templated"" ``CXXRe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89696,Availability,error,errors,89696,"ing(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new ContainsErrors bit to; express Does this expression or anything within it contain errors semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not a tree. It is a directed graph with; cycles. One example of a cycle is the connection between a; ``ClassTemplateDecl`` and its ""templated"" ``CXXRecordDecl``. The *templated*; ``CXXRecordDecl`` represents all the fields and methods inside the class; template, while the ``C",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89797,Availability,recover,recoveryExpr,89797,"idered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new ContainsErrors bit to; express Does this expression or anything within it contain errors semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not a tree. It is a directed graph with; cycles. One example of a cycle is the connection between a; ``ClassTemplateDecl`` and its ""templated"" ``CXXRecordDecl``. The *templated*; ``CXXRecordDecl`` represents all the fields and methods inside the class; template, while the ``ClassTemplateDecl`` holds the information which is; related to being a template, i.e. template arguments, etc. We can get the; *",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89885,Availability,error,errors,89885,"idered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new ContainsErrors bit to; express Does this expression or anything within it contain errors semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not a tree. It is a directed graph with; cycles. One example of a cycle is the connection between a; ``ClassTemplateDecl`` and its ""templated"" ``CXXRecordDecl``. The *templated*; ``CXXRecordDecl`` represents all the fields and methods inside the class; template, while the ``ClassTemplateDecl`` holds the information which is; related to being a template, i.e. template arguments, etc. We can get the; *",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:99374,Availability,error,errors,99374," the ``FunctionDecl`` and only then we import the; body of the function. This means there are implicit dependencies between AST; nodes. These dependencies determine the order in which we visit nodes in the; ""from"" context. As with the regular graph traversal algorithms like DFS, we; keep track which nodes we have already visited in; ``ASTImporter::ImportedDecls``. Whenever we create a node then we immediately; add that to the ``ImportedDecls``. We must not start the import of any other; declarations before we keep track of the newly created one. This is essential,; otherwise, we would not be able to handle circular dependencies. To enforce; this, we wrap all constructor calls of all AST nodes in; ``GetImportedOrCreateDecl()``. This wrapper ensures that all newly created; declarations are immediately marked as imported; also, if a declaration is; already marked as imported then we just return its counterpart in the ""to""; context. Consequently, calling a declaration's ``::Create()`` function directly; would lead to errors, please don't do that!. Even with the use of ``GetImportedOrCreateDecl()`` there is still a; probability of having an infinite import recursion if things are imported from; each other in wrong way. Imagine that during the import of ``A``, the import of; ``B`` is requested before we could create the node for ``A`` (the constructor; needs a reference to ``B``). And the same could be true for the import of ``B``; (``A`` is requested to be imported before we could create the node for ``B``).; In case of the :ref:`templated-described swing <templated>` we take; extra attention to break the cyclical dependency: we import and set the; described template only after the ``CXXRecordDecl`` is created. As a best; practice, before creating the node in the ""to"" context, avoid importing of; other nodes which are not needed for the constructor of node ``A``. Error Handling; ^^^^^^^^^^^^^^. Every import function returns with either an ``llvm::Error`` or an; ``llvm::Ex",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:100448,Availability,error,error,100448,"ill a; probability of having an infinite import recursion if things are imported from; each other in wrong way. Imagine that during the import of ``A``, the import of; ``B`` is requested before we could create the node for ``A`` (the constructor; needs a reference to ``B``). And the same could be true for the import of ``B``; (``A`` is requested to be imported before we could create the node for ``B``).; In case of the :ref:`templated-described swing <templated>` we take; extra attention to break the cyclical dependency: we import and set the; described template only after the ``CXXRecordDecl`` is created. As a best; practice, before creating the node in the ""to"" context, avoid importing of; other nodes which are not needed for the constructor of node ``A``. Error Handling; ^^^^^^^^^^^^^^. Every import function returns with either an ``llvm::Error`` or an; ``llvm::Expected<T>`` object. This enforces to check the return value of the; import functions. If there was an error during one import then we return with; that error. (Exception: when we import the members of a class, we collect the; individual errors with each member and we concatenate them in one Error; object.) We cache these errors in cases of declarations. During the next import; call if there is an existing error we just return with that. So, clients of the; library receive an Error object, which they must check. During import of a specific declaration, it may happen that some AST nodes had; already been created before we recognize an error. In this case, we signal back; the error to the caller, but the ""to"" context remains polluted with those nodes; which had been created. Ideally, those nodes should not had been created, but; that time we did not know about the error, the error happened later. Since the; AST is immutable (most of the cases we can't remove existing nodes) we choose; to mark these nodes as erroneous. We cache the errors associated with declarations in the ""from"" context in; ``ASTImporter::I",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:100498,Availability,error,error,100498,"ill a; probability of having an infinite import recursion if things are imported from; each other in wrong way. Imagine that during the import of ``A``, the import of; ``B`` is requested before we could create the node for ``A`` (the constructor; needs a reference to ``B``). And the same could be true for the import of ``B``; (``A`` is requested to be imported before we could create the node for ``B``).; In case of the :ref:`templated-described swing <templated>` we take; extra attention to break the cyclical dependency: we import and set the; described template only after the ``CXXRecordDecl`` is created. As a best; practice, before creating the node in the ""to"" context, avoid importing of; other nodes which are not needed for the constructor of node ``A``. Error Handling; ^^^^^^^^^^^^^^. Every import function returns with either an ``llvm::Error`` or an; ``llvm::Expected<T>`` object. This enforces to check the return value of the; import functions. If there was an error during one import then we return with; that error. (Exception: when we import the members of a class, we collect the; individual errors with each member and we concatenate them in one Error; object.) We cache these errors in cases of declarations. During the next import; call if there is an existing error we just return with that. So, clients of the; library receive an Error object, which they must check. During import of a specific declaration, it may happen that some AST nodes had; already been created before we recognize an error. In this case, we signal back; the error to the caller, but the ""to"" context remains polluted with those nodes; which had been created. Ideally, those nodes should not had been created, but; that time we did not know about the error, the error happened later. Since the; AST is immutable (most of the cases we can't remove existing nodes) we choose; to mark these nodes as erroneous. We cache the errors associated with declarations in the ""from"" context in; ``ASTImporter::I",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:100583,Availability,error,errors,100583," Imagine that during the import of ``A``, the import of; ``B`` is requested before we could create the node for ``A`` (the constructor; needs a reference to ``B``). And the same could be true for the import of ``B``; (``A`` is requested to be imported before we could create the node for ``B``).; In case of the :ref:`templated-described swing <templated>` we take; extra attention to break the cyclical dependency: we import and set the; described template only after the ``CXXRecordDecl`` is created. As a best; practice, before creating the node in the ""to"" context, avoid importing of; other nodes which are not needed for the constructor of node ``A``. Error Handling; ^^^^^^^^^^^^^^. Every import function returns with either an ``llvm::Error`` or an; ``llvm::Expected<T>`` object. This enforces to check the return value of the; import functions. If there was an error during one import then we return with; that error. (Exception: when we import the members of a class, we collect the; individual errors with each member and we concatenate them in one Error; object.) We cache these errors in cases of declarations. During the next import; call if there is an existing error we just return with that. So, clients of the; library receive an Error object, which they must check. During import of a specific declaration, it may happen that some AST nodes had; already been created before we recognize an error. In this case, we signal back; the error to the caller, but the ""to"" context remains polluted with those nodes; which had been created. Ideally, those nodes should not had been created, but; that time we did not know about the error, the error happened later. Since the; AST is immutable (most of the cases we can't remove existing nodes) we choose; to mark these nodes as erroneous. We cache the errors associated with declarations in the ""from"" context in; ``ASTImporter::ImportDeclErrors`` and the ones which are associated with the; ""to"" context in ``ASTImporterSharedState::Import",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:100669,Availability,error,errors,100669," the node for ``A`` (the constructor; needs a reference to ``B``). And the same could be true for the import of ``B``; (``A`` is requested to be imported before we could create the node for ``B``).; In case of the :ref:`templated-described swing <templated>` we take; extra attention to break the cyclical dependency: we import and set the; described template only after the ``CXXRecordDecl`` is created. As a best; practice, before creating the node in the ""to"" context, avoid importing of; other nodes which are not needed for the constructor of node ``A``. Error Handling; ^^^^^^^^^^^^^^. Every import function returns with either an ``llvm::Error`` or an; ``llvm::Expected<T>`` object. This enforces to check the return value of the; import functions. If there was an error during one import then we return with; that error. (Exception: when we import the members of a class, we collect the; individual errors with each member and we concatenate them in one Error; object.) We cache these errors in cases of declarations. During the next import; call if there is an existing error we just return with that. So, clients of the; library receive an Error object, which they must check. During import of a specific declaration, it may happen that some AST nodes had; already been created before we recognize an error. In this case, we signal back; the error to the caller, but the ""to"" context remains polluted with those nodes; which had been created. Ideally, those nodes should not had been created, but; that time we did not know about the error, the error happened later. Since the; AST is immutable (most of the cases we can't remove existing nodes) we choose; to mark these nodes as erroneous. We cache the errors associated with declarations in the ""from"" context in; ``ASTImporter::ImportDeclErrors`` and the ones which are associated with the; ""to"" context in ``ASTImporterSharedState::ImportErrors``. Note that, there may; be several ASTImporter objects which import into the same ""to"" cont",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:100755,Availability,error,error,100755,"And the same could be true for the import of ``B``; (``A`` is requested to be imported before we could create the node for ``B``).; In case of the :ref:`templated-described swing <templated>` we take; extra attention to break the cyclical dependency: we import and set the; described template only after the ``CXXRecordDecl`` is created. As a best; practice, before creating the node in the ""to"" context, avoid importing of; other nodes which are not needed for the constructor of node ``A``. Error Handling; ^^^^^^^^^^^^^^. Every import function returns with either an ``llvm::Error`` or an; ``llvm::Expected<T>`` object. This enforces to check the return value of the; import functions. If there was an error during one import then we return with; that error. (Exception: when we import the members of a class, we collect the; individual errors with each member and we concatenate them in one Error; object.) We cache these errors in cases of declarations. During the next import; call if there is an existing error we just return with that. So, clients of the; library receive an Error object, which they must check. During import of a specific declaration, it may happen that some AST nodes had; already been created before we recognize an error. In this case, we signal back; the error to the caller, but the ""to"" context remains polluted with those nodes; which had been created. Ideally, those nodes should not had been created, but; that time we did not know about the error, the error happened later. Since the; AST is immutable (most of the cases we can't remove existing nodes) we choose; to mark these nodes as erroneous. We cache the errors associated with declarations in the ""from"" context in; ``ASTImporter::ImportDeclErrors`` and the ones which are associated with the; ""to"" context in ``ASTImporterSharedState::ImportErrors``. Note that, there may; be several ASTImporter objects which import into the same ""to"" context but from; different ""from"" contexts; in this case, they have to",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:100987,Availability,error,error,100987,"lated>` we take; extra attention to break the cyclical dependency: we import and set the; described template only after the ``CXXRecordDecl`` is created. As a best; practice, before creating the node in the ""to"" context, avoid importing of; other nodes which are not needed for the constructor of node ``A``. Error Handling; ^^^^^^^^^^^^^^. Every import function returns with either an ``llvm::Error`` or an; ``llvm::Expected<T>`` object. This enforces to check the return value of the; import functions. If there was an error during one import then we return with; that error. (Exception: when we import the members of a class, we collect the; individual errors with each member and we concatenate them in one Error; object.) We cache these errors in cases of declarations. During the next import; call if there is an existing error we just return with that. So, clients of the; library receive an Error object, which they must check. During import of a specific declaration, it may happen that some AST nodes had; already been created before we recognize an error. In this case, we signal back; the error to the caller, but the ""to"" context remains polluted with those nodes; which had been created. Ideally, those nodes should not had been created, but; that time we did not know about the error, the error happened later. Since the; AST is immutable (most of the cases we can't remove existing nodes) we choose; to mark these nodes as erroneous. We cache the errors associated with declarations in the ""from"" context in; ``ASTImporter::ImportDeclErrors`` and the ones which are associated with the; ""to"" context in ``ASTImporterSharedState::ImportErrors``. Note that, there may; be several ASTImporter objects which import into the same ""to"" context but from; different ""from"" contexts; in this case, they have to share the associated; errors of the ""to"" context. When an error happens, that propagates through the call stack, through all the; dependant nodes. However, in case of dependency cycle",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:101028,Availability,error,error,101028,"rdDecl`` is created. As a best; practice, before creating the node in the ""to"" context, avoid importing of; other nodes which are not needed for the constructor of node ``A``. Error Handling; ^^^^^^^^^^^^^^. Every import function returns with either an ``llvm::Error`` or an; ``llvm::Expected<T>`` object. This enforces to check the return value of the; import functions. If there was an error during one import then we return with; that error. (Exception: when we import the members of a class, we collect the; individual errors with each member and we concatenate them in one Error; object.) We cache these errors in cases of declarations. During the next import; call if there is an existing error we just return with that. So, clients of the; library receive an Error object, which they must check. During import of a specific declaration, it may happen that some AST nodes had; already been created before we recognize an error. In this case, we signal back; the error to the caller, but the ""to"" context remains polluted with those nodes; which had been created. Ideally, those nodes should not had been created, but; that time we did not know about the error, the error happened later. Since the; AST is immutable (most of the cases we can't remove existing nodes) we choose; to mark these nodes as erroneous. We cache the errors associated with declarations in the ""from"" context in; ``ASTImporter::ImportDeclErrors`` and the ones which are associated with the; ""to"" context in ``ASTImporterSharedState::ImportErrors``. Note that, there may; be several ASTImporter objects which import into the same ""to"" context but from; different ""from"" contexts; in this case, they have to share the associated; errors of the ""to"" context. When an error happens, that propagates through the call stack, through all the; dependant nodes. However, in case of dependency cycles, this is not enough,; because we strive to mark the erroneous nodes so clients can act upon. In those; cases, we have to keep track",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:101220,Availability,error,error,101220,"not needed for the constructor of node ``A``. Error Handling; ^^^^^^^^^^^^^^. Every import function returns with either an ``llvm::Error`` or an; ``llvm::Expected<T>`` object. This enforces to check the return value of the; import functions. If there was an error during one import then we return with; that error. (Exception: when we import the members of a class, we collect the; individual errors with each member and we concatenate them in one Error; object.) We cache these errors in cases of declarations. During the next import; call if there is an existing error we just return with that. So, clients of the; library receive an Error object, which they must check. During import of a specific declaration, it may happen that some AST nodes had; already been created before we recognize an error. In this case, we signal back; the error to the caller, but the ""to"" context remains polluted with those nodes; which had been created. Ideally, those nodes should not had been created, but; that time we did not know about the error, the error happened later. Since the; AST is immutable (most of the cases we can't remove existing nodes) we choose; to mark these nodes as erroneous. We cache the errors associated with declarations in the ""from"" context in; ``ASTImporter::ImportDeclErrors`` and the ones which are associated with the; ""to"" context in ``ASTImporterSharedState::ImportErrors``. Note that, there may; be several ASTImporter objects which import into the same ""to"" context but from; different ""from"" contexts; in this case, they have to share the associated; errors of the ""to"" context. When an error happens, that propagates through the call stack, through all the; dependant nodes. However, in case of dependency cycles, this is not enough,; because we strive to mark the erroneous nodes so clients can act upon. In those; cases, we have to keep track of the errors for those nodes which are; intermediate nodes of a cycle. An **import path** is the list of the AST nodes which we",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:101231,Availability,error,error,101231,"not needed for the constructor of node ``A``. Error Handling; ^^^^^^^^^^^^^^. Every import function returns with either an ``llvm::Error`` or an; ``llvm::Expected<T>`` object. This enforces to check the return value of the; import functions. If there was an error during one import then we return with; that error. (Exception: when we import the members of a class, we collect the; individual errors with each member and we concatenate them in one Error; object.) We cache these errors in cases of declarations. During the next import; call if there is an existing error we just return with that. So, clients of the; library receive an Error object, which they must check. During import of a specific declaration, it may happen that some AST nodes had; already been created before we recognize an error. In this case, we signal back; the error to the caller, but the ""to"" context remains polluted with those nodes; which had been created. Ideally, those nodes should not had been created, but; that time we did not know about the error, the error happened later. Since the; AST is immutable (most of the cases we can't remove existing nodes) we choose; to mark these nodes as erroneous. We cache the errors associated with declarations in the ""from"" context in; ``ASTImporter::ImportDeclErrors`` and the ones which are associated with the; ""to"" context in ``ASTImporterSharedState::ImportErrors``. Note that, there may; be several ASTImporter objects which import into the same ""to"" context but from; different ""from"" contexts; in this case, they have to share the associated; errors of the ""to"" context. When an error happens, that propagates through the call stack, through all the; dependant nodes. However, in case of dependency cycles, this is not enough,; because we strive to mark the erroneous nodes so clients can act upon. In those; cases, we have to keep track of the errors for those nodes which are; intermediate nodes of a cycle. An **import path** is the list of the AST nodes which we",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:101390,Availability,error,errors,101390,"eturn with; that error. (Exception: when we import the members of a class, we collect the; individual errors with each member and we concatenate them in one Error; object.) We cache these errors in cases of declarations. During the next import; call if there is an existing error we just return with that. So, clients of the; library receive an Error object, which they must check. During import of a specific declaration, it may happen that some AST nodes had; already been created before we recognize an error. In this case, we signal back; the error to the caller, but the ""to"" context remains polluted with those nodes; which had been created. Ideally, those nodes should not had been created, but; that time we did not know about the error, the error happened later. Since the; AST is immutable (most of the cases we can't remove existing nodes) we choose; to mark these nodes as erroneous. We cache the errors associated with declarations in the ""from"" context in; ``ASTImporter::ImportDeclErrors`` and the ones which are associated with the; ""to"" context in ``ASTImporterSharedState::ImportErrors``. Note that, there may; be several ASTImporter objects which import into the same ""to"" context but from; different ""from"" contexts; in this case, they have to share the associated; errors of the ""to"" context. When an error happens, that propagates through the call stack, through all the; dependant nodes. However, in case of dependency cycles, this is not enough,; because we strive to mark the erroneous nodes so clients can act upon. In those; cases, we have to keep track of the errors for those nodes which are; intermediate nodes of a cycle. An **import path** is the list of the AST nodes which we visit during an Import; call. If node ``A`` depends on node ``B`` then the path contains an ``A->B``; edge. From the call stack of the import functions, we can read the very same; path. Now imagine the following AST, where the ``->`` represents dependency in terms; of the import (all nodes ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:101767,Availability,error,errors,101767,"clarations. During the next import; call if there is an existing error we just return with that. So, clients of the; library receive an Error object, which they must check. During import of a specific declaration, it may happen that some AST nodes had; already been created before we recognize an error. In this case, we signal back; the error to the caller, but the ""to"" context remains polluted with those nodes; which had been created. Ideally, those nodes should not had been created, but; that time we did not know about the error, the error happened later. Since the; AST is immutable (most of the cases we can't remove existing nodes) we choose; to mark these nodes as erroneous. We cache the errors associated with declarations in the ""from"" context in; ``ASTImporter::ImportDeclErrors`` and the ones which are associated with the; ""to"" context in ``ASTImporterSharedState::ImportErrors``. Note that, there may; be several ASTImporter objects which import into the same ""to"" context but from; different ""from"" contexts; in this case, they have to share the associated; errors of the ""to"" context. When an error happens, that propagates through the call stack, through all the; dependant nodes. However, in case of dependency cycles, this is not enough,; because we strive to mark the erroneous nodes so clients can act upon. In those; cases, we have to keep track of the errors for those nodes which are; intermediate nodes of a cycle. An **import path** is the list of the AST nodes which we visit during an Import; call. If node ``A`` depends on node ``B`` then the path contains an ``A->B``; edge. From the call stack of the import functions, we can read the very same; path. Now imagine the following AST, where the ``->`` represents dependency in terms; of the import (all nodes are declarations). .. code-block:: text. A->B->C->D; `->E. We would like to import A.; The import behaves like a DFS, so we will visit the nodes in this order: ABCDE.; During the visitation we will have the fo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:101803,Availability,error,error,101803,"ich they must check. During import of a specific declaration, it may happen that some AST nodes had; already been created before we recognize an error. In this case, we signal back; the error to the caller, but the ""to"" context remains polluted with those nodes; which had been created. Ideally, those nodes should not had been created, but; that time we did not know about the error, the error happened later. Since the; AST is immutable (most of the cases we can't remove existing nodes) we choose; to mark these nodes as erroneous. We cache the errors associated with declarations in the ""from"" context in; ``ASTImporter::ImportDeclErrors`` and the ones which are associated with the; ""to"" context in ``ASTImporterSharedState::ImportErrors``. Note that, there may; be several ASTImporter objects which import into the same ""to"" context but from; different ""from"" contexts; in this case, they have to share the associated; errors of the ""to"" context. When an error happens, that propagates through the call stack, through all the; dependant nodes. However, in case of dependency cycles, this is not enough,; because we strive to mark the erroneous nodes so clients can act upon. In those; cases, we have to keep track of the errors for those nodes which are; intermediate nodes of a cycle. An **import path** is the list of the AST nodes which we visit during an Import; call. If node ``A`` depends on node ``B`` then the path contains an ``A->B``; edge. From the call stack of the import functions, we can read the very same; path. Now imagine the following AST, where the ``->`` represents dependency in terms; of the import (all nodes are declarations). .. code-block:: text. A->B->C->D; `->E. We would like to import A.; The import behaves like a DFS, so we will visit the nodes in this order: ABCDE.; During the visitation we will have the following import paths:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:102069,Availability,error,errors,102069," polluted with those nodes; which had been created. Ideally, those nodes should not had been created, but; that time we did not know about the error, the error happened later. Since the; AST is immutable (most of the cases we can't remove existing nodes) we choose; to mark these nodes as erroneous. We cache the errors associated with declarations in the ""from"" context in; ``ASTImporter::ImportDeclErrors`` and the ones which are associated with the; ""to"" context in ``ASTImporterSharedState::ImportErrors``. Note that, there may; be several ASTImporter objects which import into the same ""to"" context but from; different ""from"" contexts; in this case, they have to share the associated; errors of the ""to"" context. When an error happens, that propagates through the call stack, through all the; dependant nodes. However, in case of dependency cycles, this is not enough,; because we strive to mark the erroneous nodes so clients can act upon. In those; cases, we have to keep track of the errors for those nodes which are; intermediate nodes of a cycle. An **import path** is the list of the AST nodes which we visit during an Import; call. If node ``A`` depends on node ``B`` then the path contains an ``A->B``; edge. From the call stack of the import functions, we can read the very same; path. Now imagine the following AST, where the ``->`` represents dependency in terms; of the import (all nodes are declarations). .. code-block:: text. A->B->C->D; `->E. We would like to import A.; The import behaves like a DFS, so we will visit the nodes in this order: ABCDE.; During the visitation we will have the following import paths:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for E, then as; the call stack shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. However, during the import we could import C and ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:102812,Availability,error,error,102812,"hrough the call stack, through all the; dependant nodes. However, in case of dependency cycles, this is not enough,; because we strive to mark the erroneous nodes so clients can act upon. In those; cases, we have to keep track of the errors for those nodes which are; intermediate nodes of a cycle. An **import path** is the list of the AST nodes which we visit during an Import; call. If node ``A`` depends on node ``B`` then the path contains an ``A->B``; edge. From the call stack of the import functions, we can read the very same; path. Now imagine the following AST, where the ``->`` represents dependency in terms; of the import (all nodes are declarations). .. code-block:: text. A->B->C->D; `->E. We would like to import A.; The import behaves like a DFS, so we will visit the nodes in this order: ABCDE.; During the visitation we will have the following import paths:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for E, then as; the call stack shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. However, during the import we could import C and D without any error and they; are independent of A,B and E. We must not set up an error for C and D. So, at; the end of the import we have an entry in ``ImportDeclErrors`` for A,B,E but; not for C,D. Now, what happens if there is a cycle in the import path? Let's consider this; AST:. .. code-block:: text. A->B->C->A; `->E. During the visitation, we will have the below import paths and if during the; visit of E there is an error then we will set up an error for E,B,A. But what's; up with C?. .. code-block:: text. A; AB; ABC; ABCA; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. This time we know that both B and C are dependent on A. This means we must set; up an error for C too. As the call stack reverses b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:102833,Availability,error,error,102833,"hrough the call stack, through all the; dependant nodes. However, in case of dependency cycles, this is not enough,; because we strive to mark the erroneous nodes so clients can act upon. In those; cases, we have to keep track of the errors for those nodes which are; intermediate nodes of a cycle. An **import path** is the list of the AST nodes which we visit during an Import; call. If node ``A`` depends on node ``B`` then the path contains an ``A->B``; edge. From the call stack of the import functions, we can read the very same; path. Now imagine the following AST, where the ``->`` represents dependency in terms; of the import (all nodes are declarations). .. code-block:: text. A->B->C->D; `->E. We would like to import A.; The import behaves like a DFS, so we will visit the nodes in this order: ABCDE.; During the visitation we will have the following import paths:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for E, then as; the call stack shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. However, during the import we could import C and D without any error and they; are independent of A,B and E. We must not set up an error for C and D. So, at; the end of the import we have an entry in ``ImportDeclErrors`` for A,B,E but; not for C,D. Now, what happens if there is a cycle in the import path? Let's consider this; AST:. .. code-block:: text. A->B->C->A; `->E. During the visitation, we will have the below import paths and if during the; visit of E there is an error then we will set up an error for E,B,A. But what's; up with C?. .. code-block:: text. A; AB; ABC; ABCA; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. This time we know that both B and C are dependent on A. This means we must set; up an error for C too. As the call stack reverses b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:102968,Availability,error,error,102968,"mark the erroneous nodes so clients can act upon. In those; cases, we have to keep track of the errors for those nodes which are; intermediate nodes of a cycle. An **import path** is the list of the AST nodes which we visit during an Import; call. If node ``A`` depends on node ``B`` then the path contains an ``A->B``; edge. From the call stack of the import functions, we can read the very same; path. Now imagine the following AST, where the ``->`` represents dependency in terms; of the import (all nodes are declarations). .. code-block:: text. A->B->C->D; `->E. We would like to import A.; The import behaves like a DFS, so we will visit the nodes in this order: ABCDE.; During the visitation we will have the following import paths:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for E, then as; the call stack shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. However, during the import we could import C and D without any error and they; are independent of A,B and E. We must not set up an error for C and D. So, at; the end of the import we have an entry in ``ImportDeclErrors`` for A,B,E but; not for C,D. Now, what happens if there is a cycle in the import path? Let's consider this; AST:. .. code-block:: text. A->B->C->A; `->E. During the visitation, we will have the below import paths and if during the; visit of E there is an error then we will set up an error for E,B,A. But what's; up with C?. .. code-block:: text. A; AB; ABC; ABCA; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. This time we know that both B and C are dependent on A. This means we must set; up an error for C too. As the call stack reverses back we get to A and we must; set up an error to all nodes which depend on A (this includes C). But C is no; longer on the import path, it ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:102993,Availability,error,error,102993,"mark the erroneous nodes so clients can act upon. In those; cases, we have to keep track of the errors for those nodes which are; intermediate nodes of a cycle. An **import path** is the list of the AST nodes which we visit during an Import; call. If node ``A`` depends on node ``B`` then the path contains an ``A->B``; edge. From the call stack of the import functions, we can read the very same; path. Now imagine the following AST, where the ``->`` represents dependency in terms; of the import (all nodes are declarations). .. code-block:: text. A->B->C->D; `->E. We would like to import A.; The import behaves like a DFS, so we will visit the nodes in this order: ABCDE.; During the visitation we will have the following import paths:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for E, then as; the call stack shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. However, during the import we could import C and D without any error and they; are independent of A,B and E. We must not set up an error for C and D. So, at; the end of the import we have an entry in ``ImportDeclErrors`` for A,B,E but; not for C,D. Now, what happens if there is a cycle in the import path? Let's consider this; AST:. .. code-block:: text. A->B->C->A; `->E. During the visitation, we will have the below import paths and if during the; visit of E there is an error then we will set up an error for E,B,A. But what's; up with C?. .. code-block:: text. A; AB; ABC; ABCA; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. This time we know that both B and C are dependent on A. This means we must set; up an error for C too. As the call stack reverses back we get to A and we must; set up an error to all nodes which depend on A (this includes C). But C is no; longer on the import path, it ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:103017,Availability,error,error,103017,"mark the erroneous nodes so clients can act upon. In those; cases, we have to keep track of the errors for those nodes which are; intermediate nodes of a cycle. An **import path** is the list of the AST nodes which we visit during an Import; call. If node ``A`` depends on node ``B`` then the path contains an ``A->B``; edge. From the call stack of the import functions, we can read the very same; path. Now imagine the following AST, where the ``->`` represents dependency in terms; of the import (all nodes are declarations). .. code-block:: text. A->B->C->D; `->E. We would like to import A.; The import behaves like a DFS, so we will visit the nodes in this order: ABCDE.; During the visitation we will have the following import paths:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for E, then as; the call stack shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. However, during the import we could import C and D without any error and they; are independent of A,B and E. We must not set up an error for C and D. So, at; the end of the import we have an entry in ``ImportDeclErrors`` for A,B,E but; not for C,D. Now, what happens if there is a cycle in the import path? Let's consider this; AST:. .. code-block:: text. A->B->C->A; `->E. During the visitation, we will have the below import paths and if during the; visit of E there is an error then we will set up an error for E,B,A. But what's; up with C?. .. code-block:: text. A; AB; ABC; ABCA; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. This time we know that both B and C are dependent on A. This means we must set; up an error for C too. As the call stack reverses back we get to A and we must; set up an error to all nodes which depend on A (this includes C). But C is no; longer on the import path, it ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:103092,Availability,error,error,103092,"ose nodes which are; intermediate nodes of a cycle. An **import path** is the list of the AST nodes which we visit during an Import; call. If node ``A`` depends on node ``B`` then the path contains an ``A->B``; edge. From the call stack of the import functions, we can read the very same; path. Now imagine the following AST, where the ``->`` represents dependency in terms; of the import (all nodes are declarations). .. code-block:: text. A->B->C->D; `->E. We would like to import A.; The import behaves like a DFS, so we will visit the nodes in this order: ABCDE.; During the visitation we will have the following import paths:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for E, then as; the call stack shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. However, during the import we could import C and D without any error and they; are independent of A,B and E. We must not set up an error for C and D. So, at; the end of the import we have an entry in ``ImportDeclErrors`` for A,B,E but; not for C,D. Now, what happens if there is a cycle in the import path? Let's consider this; AST:. .. code-block:: text. A->B->C->A; `->E. During the visitation, we will have the below import paths and if during the; visit of E there is an error then we will set up an error for E,B,A. But what's; up with C?. .. code-block:: text. A; AB; ABC; ABCA; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. This time we know that both B and C are dependent on A. This means we must set; up an error for C too. As the call stack reverses back we get to A and we must; set up an error to all nodes which depend on A (this includes C). But C is no; longer on the import path, it just had been previously. Such a situation can; happen only if during the visitation we had a cycle. If we di",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:103160,Availability,error,error,103160,"he list of the AST nodes which we visit during an Import; call. If node ``A`` depends on node ``B`` then the path contains an ``A->B``; edge. From the call stack of the import functions, we can read the very same; path. Now imagine the following AST, where the ``->`` represents dependency in terms; of the import (all nodes are declarations). .. code-block:: text. A->B->C->D; `->E. We would like to import A.; The import behaves like a DFS, so we will visit the nodes in this order: ABCDE.; During the visitation we will have the following import paths:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for E, then as; the call stack shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. However, during the import we could import C and D without any error and they; are independent of A,B and E. We must not set up an error for C and D. So, at; the end of the import we have an entry in ``ImportDeclErrors`` for A,B,E but; not for C,D. Now, what happens if there is a cycle in the import path? Let's consider this; AST:. .. code-block:: text. A->B->C->A; `->E. During the visitation, we will have the below import paths and if during the; visit of E there is an error then we will set up an error for E,B,A. But what's; up with C?. .. code-block:: text. A; AB; ABC; ABCA; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. This time we know that both B and C are dependent on A. This means we must set; up an error for C too. As the call stack reverses back we get to A and we must; set up an error to all nodes which depend on A (this includes C). But C is no; longer on the import path, it just had been previously. Such a situation can; happen only if during the visitation we had a cycle. If we didn't have any; cycle, then the normal way of passing an Error object throug",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:103504,Availability,error,error,103504," nodes are declarations). .. code-block:: text. A->B->C->D; `->E. We would like to import A.; The import behaves like a DFS, so we will visit the nodes in this order: ABCDE.; During the visitation we will have the following import paths:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for E, then as; the call stack shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. However, during the import we could import C and D without any error and they; are independent of A,B and E. We must not set up an error for C and D. So, at; the end of the import we have an entry in ``ImportDeclErrors`` for A,B,E but; not for C,D. Now, what happens if there is a cycle in the import path? Let's consider this; AST:. .. code-block:: text. A->B->C->A; `->E. During the visitation, we will have the below import paths and if during the; visit of E there is an error then we will set up an error for E,B,A. But what's; up with C?. .. code-block:: text. A; AB; ABC; ABCA; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. This time we know that both B and C are dependent on A. This means we must set; up an error for C too. As the call stack reverses back we get to A and we must; set up an error to all nodes which depend on A (this includes C). But C is no; longer on the import path, it just had been previously. Such a situation can; happen only if during the visitation we had a cycle. If we didn't have any; cycle, then the normal way of passing an Error object through the call stack; could handle the situation. This is why we must track cycles during the import; process for each visited declaration. Lookup Problems; ^^^^^^^^^^^^^^^. When we import a declaration from the source context then we check whether we; already have a structurally equivalent node with the same name in the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:103533,Availability,error,error,103533," nodes are declarations). .. code-block:: text. A->B->C->D; `->E. We would like to import A.; The import behaves like a DFS, so we will visit the nodes in this order: ABCDE.; During the visitation we will have the following import paths:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for E, then as; the call stack shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. However, during the import we could import C and D without any error and they; are independent of A,B and E. We must not set up an error for C and D. So, at; the end of the import we have an entry in ``ImportDeclErrors`` for A,B,E but; not for C,D. Now, what happens if there is a cycle in the import path? Let's consider this; AST:. .. code-block:: text. A->B->C->A; `->E. During the visitation, we will have the below import paths and if during the; visit of E there is an error then we will set up an error for E,B,A. But what's; up with C?. .. code-block:: text. A; AB; ABC; ABCA; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. This time we know that both B and C are dependent on A. This means we must set; up an error for C too. As the call stack reverses back we get to A and we must; set up an error to all nodes which depend on A (this includes C). But C is no; longer on the import path, it just had been previously. Such a situation can; happen only if during the visitation we had a cycle. If we didn't have any; cycle, then the normal way of passing an Error object through the call stack; could handle the situation. This is why we must track cycles during the import; process for each visited declaration. Lookup Problems; ^^^^^^^^^^^^^^^. When we import a declaration from the source context then we check whether we; already have a structurally equivalent node with the same name in the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:103644,Availability,error,error,103644," During the visitation we will have the following import paths:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for E, then as; the call stack shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. However, during the import we could import C and D without any error and they; are independent of A,B and E. We must not set up an error for C and D. So, at; the end of the import we have an entry in ``ImportDeclErrors`` for A,B,E but; not for C,D. Now, what happens if there is a cycle in the import path? Let's consider this; AST:. .. code-block:: text. A->B->C->A; `->E. During the visitation, we will have the below import paths and if during the; visit of E there is an error then we will set up an error for E,B,A. But what's; up with C?. .. code-block:: text. A; AB; ABC; ABCA; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. This time we know that both B and C are dependent on A. This means we must set; up an error for C too. As the call stack reverses back we get to A and we must; set up an error to all nodes which depend on A (this includes C). But C is no; longer on the import path, it just had been previously. Such a situation can; happen only if during the visitation we had a cycle. If we didn't have any; cycle, then the normal way of passing an Error object through the call stack; could handle the situation. This is why we must track cycles during the import; process for each visited declaration. Lookup Problems; ^^^^^^^^^^^^^^^. When we import a declaration from the source context then we check whether we; already have a structurally equivalent node with the same name in the ""to""; context. If the ""from"" node is a definition and the found one is also a; definition, then we do not create a new node, instead, we mark the found node; as the imported",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:103669,Availability,error,error,103669," During the visitation we will have the following import paths:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for E, then as; the call stack shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. However, during the import we could import C and D without any error and they; are independent of A,B and E. We must not set up an error for C and D. So, at; the end of the import we have an entry in ``ImportDeclErrors`` for A,B,E but; not for C,D. Now, what happens if there is a cycle in the import path? Let's consider this; AST:. .. code-block:: text. A->B->C->A; `->E. During the visitation, we will have the below import paths and if during the; visit of E there is an error then we will set up an error for E,B,A. But what's; up with C?. .. code-block:: text. A; AB; ABC; ABCA; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. This time we know that both B and C are dependent on A. This means we must set; up an error for C too. As the call stack reverses back we get to A and we must; set up an error to all nodes which depend on A (this includes C). But C is no; longer on the import path, it just had been previously. Such a situation can; happen only if during the visitation we had a cycle. If we didn't have any; cycle, then the normal way of passing an Error object through the call stack; could handle the situation. This is why we must track cycles during the import; process for each visited declaration. Lookup Problems; ^^^^^^^^^^^^^^^. When we import a declaration from the source context then we check whether we; already have a structurally equivalent node with the same name in the ""to""; context. If the ""from"" node is a definition and the found one is also a; definition, then we do not create a new node, instead, we mark the found node; as the imported",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:103693,Availability,error,error,103693," During the visitation we will have the following import paths:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for E, then as; the call stack shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. However, during the import we could import C and D without any error and they; are independent of A,B and E. We must not set up an error for C and D. So, at; the end of the import we have an entry in ``ImportDeclErrors`` for A,B,E but; not for C,D. Now, what happens if there is a cycle in the import path? Let's consider this; AST:. .. code-block:: text. A->B->C->A; `->E. During the visitation, we will have the below import paths and if during the; visit of E there is an error then we will set up an error for E,B,A. But what's; up with C?. .. code-block:: text. A; AB; ABC; ABCA; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. This time we know that both B and C are dependent on A. This means we must set; up an error for C too. As the call stack reverses back we get to A and we must; set up an error to all nodes which depend on A (this includes C). But C is no; longer on the import path, it just had been previously. Such a situation can; happen only if during the visitation we had a cycle. If we didn't have any; cycle, then the normal way of passing an Error object through the call stack; could handle the situation. This is why we must track cycles during the import; process for each visited declaration. Lookup Problems; ^^^^^^^^^^^^^^^. When we import a declaration from the source context then we check whether we; already have a structurally equivalent node with the same name in the ""to""; context. If the ""from"" node is a definition and the found one is also a; definition, then we do not create a new node, instead, we mark the found node; as the imported",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:103791,Availability,error,error,103791,"g the visit of E there is an error then we set an error for E, then as; the call stack shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. However, during the import we could import C and D without any error and they; are independent of A,B and E. We must not set up an error for C and D. So, at; the end of the import we have an entry in ``ImportDeclErrors`` for A,B,E but; not for C,D. Now, what happens if there is a cycle in the import path? Let's consider this; AST:. .. code-block:: text. A->B->C->A; `->E. During the visitation, we will have the below import paths and if during the; visit of E there is an error then we will set up an error for E,B,A. But what's; up with C?. .. code-block:: text. A; AB; ABC; ABCA; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. This time we know that both B and C are dependent on A. This means we must set; up an error for C too. As the call stack reverses back we get to A and we must; set up an error to all nodes which depend on A (this includes C). But C is no; longer on the import path, it just had been previously. Such a situation can; happen only if during the visitation we had a cycle. If we didn't have any; cycle, then the normal way of passing an Error object through the call stack; could handle the situation. This is why we must track cycles during the import; process for each visited declaration. Lookup Problems; ^^^^^^^^^^^^^^^. When we import a declaration from the source context then we check whether we; already have a structurally equivalent node with the same name in the ""to""; context. If the ""from"" node is a definition and the found one is also a; definition, then we do not create a new node, instead, we mark the found node; as the imported node. If the found definition and the one we want to import; have the same name but they are structurally in-equivalent, then we have",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:103875,Availability,error,error,103875,"k shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. However, during the import we could import C and D without any error and they; are independent of A,B and E. We must not set up an error for C and D. So, at; the end of the import we have an entry in ``ImportDeclErrors`` for A,B,E but; not for C,D. Now, what happens if there is a cycle in the import path? Let's consider this; AST:. .. code-block:: text. A->B->C->A; `->E. During the visitation, we will have the below import paths and if during the; visit of E there is an error then we will set up an error for E,B,A. But what's; up with C?. .. code-block:: text. A; AB; ABC; ABCA; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. This time we know that both B and C are dependent on A. This means we must set; up an error for C too. As the call stack reverses back we get to A and we must; set up an error to all nodes which depend on A (this includes C). But C is no; longer on the import path, it just had been previously. Such a situation can; happen only if during the visitation we had a cycle. If we didn't have any; cycle, then the normal way of passing an Error object through the call stack; could handle the situation. This is why we must track cycles during the import; process for each visited declaration. Lookup Problems; ^^^^^^^^^^^^^^^. When we import a declaration from the source context then we check whether we; already have a structurally equivalent node with the same name in the ""to""; context. If the ""from"" node is a definition and the found one is also a; definition, then we do not create a new node, instead, we mark the found node; as the imported node. If the found definition and the one we want to import; have the same name but they are structurally in-equivalent, then we have an ODR; violation in case of C++. If the ""from"" node is not a definition then we add",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:105705,Availability,redundant,redundant,105705,"t, then we have an ODR; violation in case of C++. If the ""from"" node is not a definition then we add; that to the redeclaration chain of the found node. This behaviour is essential; when we merge ASTs from different translation units which include the same; header file(s). For example, we want to have only one definition for the class; template ``std::vector``, even if we included ``<vector>`` in several; translation units. To find a structurally equivalent node we can use the regular C/C++ lookup; functions: ``DeclContext::noload_lookup()`` and; ``DeclContext::localUncachedLookup()``. These functions do respect the C/C++; name hiding rules, thus you cannot find certain declarations in a given; declaration context. For instance, unnamed declarations (anonymous structs),; non-first ``friend`` declarations and template specializations are hidden. This; is a problem, because if we use the regular C/C++ lookup then we create; redundant AST nodes during the merge! Also, having two instances of the same; node could result in false :ref:`structural in-equivalencies <structural-eq>`; of other nodes which depend on the duplicated node. Because of these reasons,; we created a lookup class which has the sole purpose to register all; declarations, so later they can be looked up by subsequent import requests.; This is the ``ASTImporterLookupTable`` class. This lookup table should be; shared amongst the different ``ASTImporter`` instances if they happen to import; to the very same ""to"" context. This is why we can use the importer specific; lookup only via the ``ASTImporterSharedState`` class. ExternalASTSource; ~~~~~~~~~~~~~~~~~. The ``ExternalASTSource`` is an abstract interface associated with the; ``ASTContext`` class. It provides the ability to read the declarations stored; within a declaration context either for iteration or for name lookup. A; declaration context with an external AST source may load its declarations; on-demand. This means that the list of declarations (repr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:110986,Availability,error,error,110986,"ility of Declarations; ^^^^^^^^^^^^^^^^^^^^^^^^^^. During import of a global variable with external visibility, the lookup will; find variables (with the same name) but with static visibility (linkage).; Clearly, we cannot put them into the same redeclaration chain. The same is true; the in case of functions. Also, we have to take care of other kinds of; declarations like enums, classes, etc. if they are in anonymous namespaces.; Therefore, we filter the lookup results and consider only those which have the; same visibility as the declaration we currently import. We consider two declarations in two anonymous namespaces to have the same; visibility only if they are imported from the same AST context. Strategies to Handle Conflicting Names; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. During the import we lookup existing declarations with the same name. We filter; the lookup results based on their :ref:`visibility <visibility>`. If any of the; found declarations are not structurally equivalent then we bumped to a name; conflict error (ODR violation in C++). In this case, we return with an; ``Error`` and we set up the ``Error`` object for the declaration. However, some; clients of the ``ASTImporter`` may require a different, perhaps less; conservative and more liberal error handling strategy. E.g. static analysis clients may benefit if the node is created even if there; is a name conflict. During the CTU analysis of certain projects, we recognized; that there are global declarations which collide with declarations from other; translation units, but they are not referenced outside from their translation; unit. These declarations should be in an unnamed namespace ideally. If we treat; these collisions liberally then CTU analysis can find more results. Note, the; feature be able to choose between name conflict handling strategies is still an; ongoing work. .. _CFG:. The ``CFG`` class; -----------------. The ``CFG`` class is designed to represent a source-level control-flow grap",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:111230,Availability,error,error,111230,"o the same redeclaration chain. The same is true; the in case of functions. Also, we have to take care of other kinds of; declarations like enums, classes, etc. if they are in anonymous namespaces.; Therefore, we filter the lookup results and consider only those which have the; same visibility as the declaration we currently import. We consider two declarations in two anonymous namespaces to have the same; visibility only if they are imported from the same AST context. Strategies to Handle Conflicting Names; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. During the import we lookup existing declarations with the same name. We filter; the lookup results based on their :ref:`visibility <visibility>`. If any of the; found declarations are not structurally equivalent then we bumped to a name; conflict error (ODR violation in C++). In this case, we return with an; ``Error`` and we set up the ``Error`` object for the declaration. However, some; clients of the ``ASTImporter`` may require a different, perhaps less; conservative and more liberal error handling strategy. E.g. static analysis clients may benefit if the node is created even if there; is a name conflict. During the CTU analysis of certain projects, we recognized; that there are global declarations which collide with declarations from other; translation units, but they are not referenced outside from their translation; unit. These declarations should be in an unnamed namespace ideally. If we treat; these collisions liberally then CTU analysis can find more results. Note, the; feature be able to choose between name conflict handling strategies is still an; ongoing work. .. _CFG:. The ``CFG`` class; -----------------. The ``CFG`` class is designed to represent a source-level control-flow graph; for a single statement (``Stmt*``). Typically instances of ``CFG`` are; constructed for function bodies (usually an instance of ``CompoundStmt``), but; can also be instantiated to represent the control-flow of any class that; subcl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:115468,Availability,error,error,115468,"the control-flow, and is used to identify the; nature of the conditional control-flow between blocks. For example, in the; case of an if-statement, the terminator refers to the ``IfStmt`` object in the; AST that represented the given branch. To illustrate, consider the following code example:. .. code-block:: c++. int foo(int x) {; x = x + 1;; if (x > 2); x++;; else {; x += 2;; x *= 2;; }. return x;; }. After invoking the parser+semantic analyzer on this code fragment, the AST of; the body of ``foo`` is referenced by a single ``Stmt*``. We can then construct; an instance of ``CFG`` representing the control-flow graph of this function; body by single call to a static class method:. .. code-block:: c++. Stmt *FooBody = ...; std::unique_ptr<CFG> FooCFG = CFG::buildCFG(FooBody);. Along with providing an interface to iterate over its ``CFGBlocks``, the; ``CFG`` class also provides methods that are useful for debugging and; visualizing CFGs. For example, the method ``CFG::dump()`` dumps a; pretty-printed version of the CFG to standard error. This is especially useful; when one is using a debugger such as gdb. For example, here is the output of; ``FooCFG->dump()``:. .. code-block:: text. [ B5 (ENTRY) ]; Predecessors (0):; Successors (1): B4. [ B4 ]; 1: x = x + 1; 2: (x > 2); T: if [B4.2]; Predecessors (1): B5; Successors (2): B3 B2. [ B3 ]; 1: x++; Predecessors (1): B4; Successors (1): B1. [ B2 ]; 1: x += 2; 2: x *= 2; Predecessors (1): B4; Successors (1): B1. [ B1 ]; 1: return x;; Predecessors (2): B2 B3; Successors (1): B0. [ B0 (EXIT) ]; Predecessors (1): B1; Successors (0):. For each block, the pretty-printed output displays for each block the number of; *predecessor* blocks (blocks that have outgoing control-flow to the given; block) and *successor* blocks (blocks that have control-flow that have incoming; control-flow from the given block). We can also clearly see the special entry; and exit blocks at the beginning and end of the pretty-printed output. For the; entry",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:119383,Availability,error,errors,119383,"to; the Clang front-end. First, in general, we prefer the AST to retain the source; code as close to how the user wrote it as possible. This means that if they; wrote ""``5+4``"", we want to keep the addition and two constants in the AST, we; don't want to fold to ""``9``"". This means that constant folding in various; ways turns into a tree walk that needs to handle the various cases. However, there are places in both C and C++ that require constants to be; folded. For example, the C standard defines what an ""integer constant; expression"" (i-c-e) is with very precise and specific requirements. The; language then requires i-c-e's in a lot of places (for example, the size of a; bitfield, the value for a case statement, etc). For these, we have to be able; to constant fold the constants, to do semantic checks (e.g., verify bitfield; size is non-negative and that case statements aren't duplicated). We aim for; Clang to be very pedantic about this, diagnosing cases when the code does not; use an i-c-e where one is required, but accepting the code unless running with; ``-pedantic-errors``. Things get a little bit more tricky when it comes to compatibility with; real-world source code. Specifically, GCC has historically accepted a huge; superset of expressions as i-c-e's, and a lot of real world code depends on; this unfortunate accident of history (including, e.g., the glibc system; headers). GCC accepts anything its ""fold"" optimizer is capable of reducing to; an integer constant, which means that the definition of what it accepts changes; as its optimizer does. One example is that GCC accepts things like ""``case; X-X:``"" even when ``X`` is a variable, because it can fold this to 0. Another issue are how constants interact with the extensions we support, such; as ``__builtin_constant_p``, ``__builtin_inf``, ``__extension__`` and many; others. C99 obviously does not specify the semantics of any of these; extensions, and the definition of i-c-e does not include them. However, t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:122565,Availability,error,error,122565,"expression was computable in any way, this method returns the; ``APValue`` for the result of the expression.; * If the expression is not evaluatable at all, this method returns information; on one of the problems with the expression. This includes a; ``SourceLocation`` for where the problem is, and a diagnostic ID that explains; the problem. The diagnostic should have ``ERROR`` type.; * If the expression is not an integer constant expression, this method returns; information on one of the problems with the expression. This includes a; ``SourceLocation`` for where the problem is, and a diagnostic ID that; explains the problem. The diagnostic should have ``EXTENSION`` type. This information gives various clients the flexibility that they want, and we; will eventually have some helper methods for various extensions. For example,; ``Sema`` should have a ``Sema::VerifyIntegerConstantExpression`` method, which; calls ``Evaluate`` on the expression. If the expression is not foldable, the; error is emitted, and it would return ``true``. If the expression is not an; i-c-e, the ``EXTENSION`` diagnostic is emitted. Finally it would return; ``false`` to indicate that the AST is OK. Other clients can use the information in other ways, for example, codegen can; just use expressions that are foldable in any way. Extensions; ^^^^^^^^^^. This section describes how some of the various extensions Clang supports; interacts with constant evaluation:. * ``__extension__``: The expression form of this extension causes any; evaluatable subexpression to be accepted as an integer constant expression.; * ``__builtin_constant_p``: This returns true (as an integer constant; expression) if the operand evaluates to either a numeric value (that is, not; a pointer cast to integral type) of integral, enumeration, floating or; complex type, or if it evaluates to the address of the first character of a; string literal (possibly cast to some other type). As a special case, if; ``__builtin_constant_p`` i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:131937,Availability,error,error,131937,"t, a C-style spelling is provided.; ``Pragma`` The attribute is spelled as a ``#pragma``, and requires; custom processing within the preprocessor. If the; attribute is meant to be used by Clang, it should; set the namespace to ``""clang""``. Note that this; spelling is not used for declaration attributes.; ================== =========================================================. The C++ standard specifies that any [non-standard attribute] that is not; recognized by the implementation is ignored (``[dcl.attr.grammar]``).; The rule for C is similar. This makes ``CXX11`` and ``C23`` spellings; unsuitable for attributes that affect the type system, that change the; binary interface of the code, or that have other similar semantic meaning. ``RegularKeyword`` provides an alternative way of spelling such attributes.; It reuses the production rules for standard attributes, but it applies them; to plain keywords rather than to ``[[]]`` sequences. Compilers that don't; recognize the keyword are likely to report an error of some kind. For example, the ``ArmStreaming`` function type attribute affects; both the type system and the binary interface of the function.; It cannot therefore be spelled ``[[arm::streaming]]``, since compilers; that don't understand ``arm::streaming`` would ignore it and miscompile; the code. ``ArmStreaming`` is instead spelled ``__arm_streaming``, but it; can appear wherever a hypothetical ``[[arm::streaming]]`` could appear. Subjects; ~~~~~~~~; Attributes appertain to one or more subjects. If the attribute attempts to; attach to a subject that is not in the subject list, a diagnostic is issued; automatically. Whether the diagnostic is a warning or an error depends on how; the attribute's ``SubjectList`` is defined, but the default behavior is to warn.; The diagnostics displayed to the user are automatically determined based on the; subjects in the list, but a custom diagnostic parameter can also be specified in; the ``SubjectList``. The diagnostic",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:132610,Availability,error,error,132610,"lar semantic meaning. ``RegularKeyword`` provides an alternative way of spelling such attributes.; It reuses the production rules for standard attributes, but it applies them; to plain keywords rather than to ``[[]]`` sequences. Compilers that don't; recognize the keyword are likely to report an error of some kind. For example, the ``ArmStreaming`` function type attribute affects; both the type system and the binary interface of the function.; It cannot therefore be spelled ``[[arm::streaming]]``, since compilers; that don't understand ``arm::streaming`` would ignore it and miscompile; the code. ``ArmStreaming`` is instead spelled ``__arm_streaming``, but it; can appear wherever a hypothetical ``[[arm::streaming]]`` could appear. Subjects; ~~~~~~~~; Attributes appertain to one or more subjects. If the attribute attempts to; attach to a subject that is not in the subject list, a diagnostic is issued; automatically. Whether the diagnostic is a warning or an error depends on how; the attribute's ``SubjectList`` is defined, but the default behavior is to warn.; The diagnostics displayed to the user are automatically determined based on the; subjects in the list, but a custom diagnostic parameter can also be specified in; the ``SubjectList``. The diagnostics generated for subject list violations are; calculated automatically or specified by the subject list itself. If a; previously unused Decl node is added to the ``SubjectList``, the logic used to; automatically determine the diagnostic parameter in `utils/TableGen/ClangAttrEmitter.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/utils/TableGen/ClangAttrEmitter.cpp>`_; may need to be updated. By default, all subjects in the SubjectList must either be a Decl node defined; in ``DeclNodes.td``, or a statement node defined in ``StmtNodes.td``. However,; more complex subjects can be created by creating a ``SubsetSubject`` object.; Each such object has a base subject which it appertains to (which must be a; Decl or ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:145473,Availability,recover,recovery,145473,"ement; -------------------------------------. Expressions and statements are one of the most fundamental constructs within a; compiler, because they interact with many different parts of the AST, semantic; analysis, and IR generation. Therefore, adding a new expression or statement; kind into Clang requires some care. The following list details the various; places in Clang where an expression or statement needs to be introduced, along; with patterns to follow to ensure that the new expression or statement works; well across all of the C languages. We focus on expressions, but statements; are similar. #. Introduce parsing actions into the parser. Recursive-descent parsing is; mostly self-explanatory, but there are a few things that are worth keeping; in mind:. * Keep as much source location information as possible! You'll want it later; to produce great diagnostics and support Clang's various features that map; between source code and the AST.; * Write tests for all of the ""bad"" parsing cases, to make sure your recovery; is good. If you have matched delimiters (e.g., parentheses, square; brackets, etc.), use ``Parser::BalancedDelimiterTracker`` to give nice; diagnostics when things go wrong. #. Introduce semantic analysis actions into ``Sema``. Semantic analysis should; always involve two functions: an ``ActOnXXX`` function that will be called; directly from the parser, and a ``BuildXXX`` function that performs the; actual semantic analysis and will (eventually!) build the AST node. It's; fairly common for the ``ActOnCXX`` function to do very little (often just; some minor translation from the parser's representation to ``Sema``'s; representation of the same thing), but the separation is still important:; C++ template instantiation, for example, should always call the ``BuildXXX``; variant. Several notes on semantic analysis before we get into construction; of the AST:. * Your expression probably involves some types and some subexpressions.; Make sure to fully check ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:149162,Availability,failure,failures,149162,"lass for a similar expression to get ideas, and there are some; specific things to watch for:. * If you need to allocate memory, use the ``ASTContext`` allocator to; allocate memory. Never use raw ``malloc`` or ``new``, and never hold any; resources in an AST node, because the destructor of an AST node is never; called.; * Make sure that ``getSourceRange()`` covers the exact source range of your; expression. This is needed for diagnostics and for IDE support.; * Make sure that ``children()`` visits all of the subexpressions. This is; important for a number of features (e.g., IDE support, C++ variadic; templates). If you have sub-types, you'll also need to visit those; sub-types in ``RecursiveASTVisitor``.; * Add printing support (``StmtPrinter.cpp``) for your expression.; * Add profiling support (``StmtProfile.cpp``) for your AST node, noting the; distinguishing (non-source location) characteristics of an instance of; your expression. Omitting this step will lead to hard-to-diagnose; failures regarding matching of template declarations.; * Add serialization support (``ASTReaderStmt.cpp``, ``ASTWriterStmt.cpp``); for your AST node. #. Teach semantic analysis to build your AST node. At this point, you can wire; up your ``Sema::BuildXXX`` function to actually create your AST. A few; things to check at this point:. * If your expression can construct a new C++ class or return a new; Objective-C object, be sure to update and then call; ``Sema::MaybeBindToTemporary`` for your just-created AST node to be sure; that the object gets properly destructed. An easy way to test this is to; return a C++ class with a private destructor: semantic analysis should; flag an error here with the attempt to call the destructor.; * Inspect the generated AST by printing it using ``clang -cc1 -ast-print``,; to make sure you're capturing all of the important information about how; the AST was written.; * Inspect the generated AST under ``clang -cc1 -ast-dump`` to verify that; all of the types ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:149845,Availability,error,error,149845,"also need to visit those; sub-types in ``RecursiveASTVisitor``.; * Add printing support (``StmtPrinter.cpp``) for your expression.; * Add profiling support (``StmtProfile.cpp``) for your AST node, noting the; distinguishing (non-source location) characteristics of an instance of; your expression. Omitting this step will lead to hard-to-diagnose; failures regarding matching of template declarations.; * Add serialization support (``ASTReaderStmt.cpp``, ``ASTWriterStmt.cpp``); for your AST node. #. Teach semantic analysis to build your AST node. At this point, you can wire; up your ``Sema::BuildXXX`` function to actually create your AST. A few; things to check at this point:. * If your expression can construct a new C++ class or return a new; Objective-C object, be sure to update and then call; ``Sema::MaybeBindToTemporary`` for your just-created AST node to be sure; that the object gets properly destructed. An easy way to test this is to; return a C++ class with a private destructor: semantic analysis should; flag an error here with the attempt to call the destructor.; * Inspect the generated AST by printing it using ``clang -cc1 -ast-print``,; to make sure you're capturing all of the important information about how; the AST was written.; * Inspect the generated AST under ``clang -cc1 -ast-dump`` to verify that; all of the types in the generated AST line up the way you want them.; Remember that clients of the AST should never have to ""think"" to; understand what's going on. For example, all implicit conversions should; show up explicitly in the AST.; * Write tests that use your expression as a subexpression of other,; well-known expressions. Can you call a function using your expression as; an argument? Can you use the ternary operator?. #. Teach code generation to create IR to your AST node. This step is the first; (and only) that requires knowledge of LLVM IR. There are several things to; keep in mind:. * Code generation is separated into scalar/aggregate/complex and",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:153317,Availability,error,error,153317," instantiation how to cope with your AST node, which requires; some fairly simple code:. * Make sure that your expression's constructor properly computes the flags; for type dependence (i.e., the type your expression produces can change; from one instantiation to the next), value dependence (i.e., the constant; value your expression produces can change from one instantiation to the; next), instantiation dependence (i.e., a template parameter occurs; anywhere in your expression), and whether your expression contains a; parameter pack (for variadic templates). Often, computing these flags; just means combining the results from the various types and; subexpressions.; * Add ``TransformXXX`` and ``RebuildXXX`` functions to the ``TreeTransform``; class template in ``Sema``. ``TransformXXX`` should (recursively); transform all of the subexpressions and types within your expression,; using ``getDerived().TransformYYY``. If all of the subexpressions and; types transform without error, it will then call the ``RebuildXXX``; function, which will in turn call ``getSema().BuildXXX`` to perform; semantic analysis and build your expression.; * To test template instantiation, take those tests you wrote to make sure; that you were type checking with type-dependent expressions and dependent; types (from step #2) and instantiate those templates with various types,; some of which type-check and some that don't, and test the error messages; in each case. #. There are some ""extras"" that make other features work better. It's worth; handling these extras to give your expression complete integration into; Clang:. * Add code completion support for your expression in; ``SemaCodeComplete.cpp``.; * If your expression has types in it, or has any ""interesting"" features; other than subexpressions, extend libclang's ``CursorVisitor`` to provide; proper visitation for your expression, enabling various IDE features such; as syntax highlighting, cross-referencing, and so on. The; ``c-index-test`` helpe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:153760,Availability,error,error,153760,"the constant; value your expression produces can change from one instantiation to the; next), instantiation dependence (i.e., a template parameter occurs; anywhere in your expression), and whether your expression contains a; parameter pack (for variadic templates). Often, computing these flags; just means combining the results from the various types and; subexpressions.; * Add ``TransformXXX`` and ``RebuildXXX`` functions to the ``TreeTransform``; class template in ``Sema``. ``TransformXXX`` should (recursively); transform all of the subexpressions and types within your expression,; using ``getDerived().TransformYYY``. If all of the subexpressions and; types transform without error, it will then call the ``RebuildXXX``; function, which will in turn call ``getSema().BuildXXX`` to perform; semantic analysis and build your expression.; * To test template instantiation, take those tests you wrote to make sure; that you were type checking with type-dependent expressions and dependent; types (from step #2) and instantiate those templates with various types,; some of which type-check and some that don't, and test the error messages; in each case. #. There are some ""extras"" that make other features work better. It's worth; handling these extras to give your expression complete integration into; Clang:. * Add code completion support for your expression in; ``SemaCodeComplete.cpp``.; * If your expression has types in it, or has any ""interesting"" features; other than subexpressions, extend libclang's ``CursorVisitor`` to provide; proper visitation for your expression, enabling various IDE features such; as syntax highlighting, cross-referencing, and so on. The; ``c-index-test`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come with test coverage demonstrating; the change in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:155225,Availability,error,error,155225,"bling various IDE features such; as syntax highlighting, cross-referencing, and so on. The; ``c-index-test`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come with test coverage demonstrating; the change in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option as a way to; validate diagnostic behavior. This option will use special comments within the; test file to verify that expected diagnostics appear in the correct source; locations. If all of the expected diagnostics match the actual output of Clang,; then the invocation will return normally. If there are discrepancies between; the expected and actual output, Clang will emit detailed information about; which expected diagnostics were not seen or which unexpected diagnostics were; seen, etc. A complete example is:. .. code-block: c++. // RUN: %clang_cc1 -verify %s; int A = B; // expected-error {{use of undeclared identifier 'B'}}. If the test is run and the expected error is emitted on the expected line, the; diagnostic verifier will pass. However, if the expected error does not appear; or appears in a different location than expected, or if additional diagnostics; appear, the diagnostic verifier will fail and emit information as to why. The ``-verify`` command optionally accepts a comma-delimited list of one or; more verification prefixes that can be used to craft those special comments.; Each prefix must start with a letter and contain only alphanumeric characters,; hyphens, and underscores. ``-verify`` by itself is equivalent to; ``-verify=expected``, meaning that special comments will start with; ``expected``. Using different prefixes makes it easier to have separate; ``RUN:`` lines in the same test file which result in differing diagnostic; behavior. For example:. .. code-block:: c++. // RUN: %clang_cc1 -verify=foo,bar %s. int A = B; // foo-error {{use of un",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:155305,Availability,error,error,155305,"st`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come with test coverage demonstrating; the change in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option as a way to; validate diagnostic behavior. This option will use special comments within the; test file to verify that expected diagnostics appear in the correct source; locations. If all of the expected diagnostics match the actual output of Clang,; then the invocation will return normally. If there are discrepancies between; the expected and actual output, Clang will emit detailed information about; which expected diagnostics were not seen or which unexpected diagnostics were; seen, etc. A complete example is:. .. code-block: c++. // RUN: %clang_cc1 -verify %s; int A = B; // expected-error {{use of undeclared identifier 'B'}}. If the test is run and the expected error is emitted on the expected line, the; diagnostic verifier will pass. However, if the expected error does not appear; or appears in a different location than expected, or if additional diagnostics; appear, the diagnostic verifier will fail and emit information as to why. The ``-verify`` command optionally accepts a comma-delimited list of one or; more verification prefixes that can be used to craft those special comments.; Each prefix must start with a letter and contain only alphanumeric characters,; hyphens, and underscores. ``-verify`` by itself is equivalent to; ``-verify=expected``, meaning that special comments will start with; ``expected``. Using different prefixes makes it easier to have separate; ``RUN:`` lines in the same test file which result in differing diagnostic; behavior. For example:. .. code-block:: c++. // RUN: %clang_cc1 -verify=foo,bar %s. int A = B; // foo-error {{use of undeclared identifier 'B'}}; int C = D; // bar-error {{use of undeclared identifier 'D'}}; int E = F; // ex",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:155405,Availability,error,error,155405,"hange in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option as a way to; validate diagnostic behavior. This option will use special comments within the; test file to verify that expected diagnostics appear in the correct source; locations. If all of the expected diagnostics match the actual output of Clang,; then the invocation will return normally. If there are discrepancies between; the expected and actual output, Clang will emit detailed information about; which expected diagnostics were not seen or which unexpected diagnostics were; seen, etc. A complete example is:. .. code-block: c++. // RUN: %clang_cc1 -verify %s; int A = B; // expected-error {{use of undeclared identifier 'B'}}. If the test is run and the expected error is emitted on the expected line, the; diagnostic verifier will pass. However, if the expected error does not appear; or appears in a different location than expected, or if additional diagnostics; appear, the diagnostic verifier will fail and emit information as to why. The ``-verify`` command optionally accepts a comma-delimited list of one or; more verification prefixes that can be used to craft those special comments.; Each prefix must start with a letter and contain only alphanumeric characters,; hyphens, and underscores. ``-verify`` by itself is equivalent to; ``-verify=expected``, meaning that special comments will start with; ``expected``. Using different prefixes makes it easier to have separate; ``RUN:`` lines in the same test file which result in differing diagnostic; behavior. For example:. .. code-block:: c++. // RUN: %clang_cc1 -verify=foo,bar %s. int A = B; // foo-error {{use of undeclared identifier 'B'}}; int C = D; // bar-error {{use of undeclared identifier 'D'}}; int E = F; // expected-error {{use of undeclared identifier 'F'}}. The verifier will recognize ``foo-error`` and ``bar-error`` as special comments; but will not recognize `",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:156202,Availability,error,error,156202,"st is run and the expected error is emitted on the expected line, the; diagnostic verifier will pass. However, if the expected error does not appear; or appears in a different location than expected, or if additional diagnostics; appear, the diagnostic verifier will fail and emit information as to why. The ``-verify`` command optionally accepts a comma-delimited list of one or; more verification prefixes that can be used to craft those special comments.; Each prefix must start with a letter and contain only alphanumeric characters,; hyphens, and underscores. ``-verify`` by itself is equivalent to; ``-verify=expected``, meaning that special comments will start with; ``expected``. Using different prefixes makes it easier to have separate; ``RUN:`` lines in the same test file which result in differing diagnostic; behavior. For example:. .. code-block:: c++. // RUN: %clang_cc1 -verify=foo,bar %s. int A = B; // foo-error {{use of undeclared identifier 'B'}}; int C = D; // bar-error {{use of undeclared identifier 'D'}}; int E = F; // expected-error {{use of undeclared identifier 'F'}}. The verifier will recognize ``foo-error`` and ``bar-error`` as special comments; but will not recognize ``expected-error`` as one because the ``-verify`` line; does not contain that as a prefix. Thus, this test would fail verification; because an unexpected diagnostic would appear on the declaration of ``E``. Multiple occurrences accumulate prefixes. For example,; ``-verify -verify=foo,bar -verify=baz`` is equivalent to; ``-verify=expected,foo,bar,baz``. Specifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^; Indicating that a line expects an error or a warning is easy. Put a comment; on the line that has the diagnostic, use; ``expected-{error,warning,remark,note}`` to tag if it's an expected error,; warning, remark, or note (respectively), and place the expected text between; ``{{`` and ``}}`` markers. The full text doesn't have to be included, only; enough to ensure that the correct diagnostic was",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:156264,Availability,error,error,156264,"st is run and the expected error is emitted on the expected line, the; diagnostic verifier will pass. However, if the expected error does not appear; or appears in a different location than expected, or if additional diagnostics; appear, the diagnostic verifier will fail and emit information as to why. The ``-verify`` command optionally accepts a comma-delimited list of one or; more verification prefixes that can be used to craft those special comments.; Each prefix must start with a letter and contain only alphanumeric characters,; hyphens, and underscores. ``-verify`` by itself is equivalent to; ``-verify=expected``, meaning that special comments will start with; ``expected``. Using different prefixes makes it easier to have separate; ``RUN:`` lines in the same test file which result in differing diagnostic; behavior. For example:. .. code-block:: c++. // RUN: %clang_cc1 -verify=foo,bar %s. int A = B; // foo-error {{use of undeclared identifier 'B'}}; int C = D; // bar-error {{use of undeclared identifier 'D'}}; int E = F; // expected-error {{use of undeclared identifier 'F'}}. The verifier will recognize ``foo-error`` and ``bar-error`` as special comments; but will not recognize ``expected-error`` as one because the ``-verify`` line; does not contain that as a prefix. Thus, this test would fail verification; because an unexpected diagnostic would appear on the declaration of ``E``. Multiple occurrences accumulate prefixes. For example,; ``-verify -verify=foo,bar -verify=baz`` is equivalent to; ``-verify=expected,foo,bar,baz``. Specifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^; Indicating that a line expects an error or a warning is easy. Put a comment; on the line that has the diagnostic, use; ``expected-{error,warning,remark,note}`` to tag if it's an expected error,; warning, remark, or note (respectively), and place the expected text between; ``{{`` and ``}}`` markers. The full text doesn't have to be included, only; enough to ensure that the correct diagnostic was",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:156331,Availability,error,error,156331,"st is run and the expected error is emitted on the expected line, the; diagnostic verifier will pass. However, if the expected error does not appear; or appears in a different location than expected, or if additional diagnostics; appear, the diagnostic verifier will fail and emit information as to why. The ``-verify`` command optionally accepts a comma-delimited list of one or; more verification prefixes that can be used to craft those special comments.; Each prefix must start with a letter and contain only alphanumeric characters,; hyphens, and underscores. ``-verify`` by itself is equivalent to; ``-verify=expected``, meaning that special comments will start with; ``expected``. Using different prefixes makes it easier to have separate; ``RUN:`` lines in the same test file which result in differing diagnostic; behavior. For example:. .. code-block:: c++. // RUN: %clang_cc1 -verify=foo,bar %s. int A = B; // foo-error {{use of undeclared identifier 'B'}}; int C = D; // bar-error {{use of undeclared identifier 'D'}}; int E = F; // expected-error {{use of undeclared identifier 'F'}}. The verifier will recognize ``foo-error`` and ``bar-error`` as special comments; but will not recognize ``expected-error`` as one because the ``-verify`` line; does not contain that as a prefix. Thus, this test would fail verification; because an unexpected diagnostic would appear on the declaration of ``E``. Multiple occurrences accumulate prefixes. For example,; ``-verify -verify=foo,bar -verify=baz`` is equivalent to; ``-verify=expected,foo,bar,baz``. Specifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^; Indicating that a line expects an error or a warning is easy. Put a comment; on the line that has the diagnostic, use; ``expected-{error,warning,remark,note}`` to tag if it's an expected error,; warning, remark, or note (respectively), and place the expected text between; ``{{`` and ``}}`` markers. The full text doesn't have to be included, only; enough to ensure that the correct diagnostic was",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:156409,Availability,error,error,156409,"ected, or if additional diagnostics; appear, the diagnostic verifier will fail and emit information as to why. The ``-verify`` command optionally accepts a comma-delimited list of one or; more verification prefixes that can be used to craft those special comments.; Each prefix must start with a letter and contain only alphanumeric characters,; hyphens, and underscores. ``-verify`` by itself is equivalent to; ``-verify=expected``, meaning that special comments will start with; ``expected``. Using different prefixes makes it easier to have separate; ``RUN:`` lines in the same test file which result in differing diagnostic; behavior. For example:. .. code-block:: c++. // RUN: %clang_cc1 -verify=foo,bar %s. int A = B; // foo-error {{use of undeclared identifier 'B'}}; int C = D; // bar-error {{use of undeclared identifier 'D'}}; int E = F; // expected-error {{use of undeclared identifier 'F'}}. The verifier will recognize ``foo-error`` and ``bar-error`` as special comments; but will not recognize ``expected-error`` as one because the ``-verify`` line; does not contain that as a prefix. Thus, this test would fail verification; because an unexpected diagnostic would appear on the declaration of ``E``. Multiple occurrences accumulate prefixes. For example,; ``-verify -verify=foo,bar -verify=baz`` is equivalent to; ``-verify=expected,foo,bar,baz``. Specifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^; Indicating that a line expects an error or a warning is easy. Put a comment; on the line that has the diagnostic, use; ``expected-{error,warning,remark,note}`` to tag if it's an expected error,; warning, remark, or note (respectively), and place the expected text between; ``{{`` and ``}}`` markers. The full text doesn't have to be included, only; enough to ensure that the correct diagnostic was emitted. (Note: full text; should be included in test cases unless there is a compelling reason to use; truncated text instead.). For a full description of the matching behavior, including mor",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:156427,Availability,error,error,156427,"ected, or if additional diagnostics; appear, the diagnostic verifier will fail and emit information as to why. The ``-verify`` command optionally accepts a comma-delimited list of one or; more verification prefixes that can be used to craft those special comments.; Each prefix must start with a letter and contain only alphanumeric characters,; hyphens, and underscores. ``-verify`` by itself is equivalent to; ``-verify=expected``, meaning that special comments will start with; ``expected``. Using different prefixes makes it easier to have separate; ``RUN:`` lines in the same test file which result in differing diagnostic; behavior. For example:. .. code-block:: c++. // RUN: %clang_cc1 -verify=foo,bar %s. int A = B; // foo-error {{use of undeclared identifier 'B'}}; int C = D; // bar-error {{use of undeclared identifier 'D'}}; int E = F; // expected-error {{use of undeclared identifier 'F'}}. The verifier will recognize ``foo-error`` and ``bar-error`` as special comments; but will not recognize ``expected-error`` as one because the ``-verify`` line; does not contain that as a prefix. Thus, this test would fail verification; because an unexpected diagnostic would appear on the declaration of ``E``. Multiple occurrences accumulate prefixes. For example,; ``-verify -verify=foo,bar -verify=baz`` is equivalent to; ``-verify=expected,foo,bar,baz``. Specifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^; Indicating that a line expects an error or a warning is easy. Put a comment; on the line that has the diagnostic, use; ``expected-{error,warning,remark,note}`` to tag if it's an expected error,; warning, remark, or note (respectively), and place the expected text between; ``{{`` and ``}}`` markers. The full text doesn't have to be included, only; enough to ensure that the correct diagnostic was emitted. (Note: full text; should be included in test cases unless there is a compelling reason to use; truncated text instead.). For a full description of the matching behavior, including mor",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:156490,Availability,error,error,156490,"ected, or if additional diagnostics; appear, the diagnostic verifier will fail and emit information as to why. The ``-verify`` command optionally accepts a comma-delimited list of one or; more verification prefixes that can be used to craft those special comments.; Each prefix must start with a letter and contain only alphanumeric characters,; hyphens, and underscores. ``-verify`` by itself is equivalent to; ``-verify=expected``, meaning that special comments will start with; ``expected``. Using different prefixes makes it easier to have separate; ``RUN:`` lines in the same test file which result in differing diagnostic; behavior. For example:. .. code-block:: c++. // RUN: %clang_cc1 -verify=foo,bar %s. int A = B; // foo-error {{use of undeclared identifier 'B'}}; int C = D; // bar-error {{use of undeclared identifier 'D'}}; int E = F; // expected-error {{use of undeclared identifier 'F'}}. The verifier will recognize ``foo-error`` and ``bar-error`` as special comments; but will not recognize ``expected-error`` as one because the ``-verify`` line; does not contain that as a prefix. Thus, this test would fail verification; because an unexpected diagnostic would appear on the declaration of ``E``. Multiple occurrences accumulate prefixes. For example,; ``-verify -verify=foo,bar -verify=baz`` is equivalent to; ``-verify=expected,foo,bar,baz``. Specifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^; Indicating that a line expects an error or a warning is easy. Put a comment; on the line that has the diagnostic, use; ``expected-{error,warning,remark,note}`` to tag if it's an expected error,; warning, remark, or note (respectively), and place the expected text between; ``{{`` and ``}}`` markers. The full text doesn't have to be included, only; enough to ensure that the correct diagnostic was emitted. (Note: full text; should be included in test cases unless there is a compelling reason to use; truncated text instead.). For a full description of the matching behavior, including mor",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:156916,Availability,error,error,156916,"rify=expected``, meaning that special comments will start with; ``expected``. Using different prefixes makes it easier to have separate; ``RUN:`` lines in the same test file which result in differing diagnostic; behavior. For example:. .. code-block:: c++. // RUN: %clang_cc1 -verify=foo,bar %s. int A = B; // foo-error {{use of undeclared identifier 'B'}}; int C = D; // bar-error {{use of undeclared identifier 'D'}}; int E = F; // expected-error {{use of undeclared identifier 'F'}}. The verifier will recognize ``foo-error`` and ``bar-error`` as special comments; but will not recognize ``expected-error`` as one because the ``-verify`` line; does not contain that as a prefix. Thus, this test would fail verification; because an unexpected diagnostic would appear on the declaration of ``E``. Multiple occurrences accumulate prefixes. For example,; ``-verify -verify=foo,bar -verify=baz`` is equivalent to; ``-verify=expected,foo,bar,baz``. Specifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^; Indicating that a line expects an error or a warning is easy. Put a comment; on the line that has the diagnostic, use; ``expected-{error,warning,remark,note}`` to tag if it's an expected error,; warning, remark, or note (respectively), and place the expected text between; ``{{`` and ``}}`` markers. The full text doesn't have to be included, only; enough to ensure that the correct diagnostic was emitted. (Note: full text; should be included in test cases unless there is a compelling reason to use; truncated text instead.). For a full description of the matching behavior, including more complex; matching scenarios, see :ref:`matching <DiagnosticMatching>` below. Here's an example of the most commonly used way to specify expected; diagnostics:. .. code-block:: c++. int A = B; // expected-error {{use of undeclared identifier 'B'}}. You can place as many diagnostics on one line as you wish. To make the code; more readable, you can use slash-newline to separate out the diagnostics. Alternatively, ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:157013,Availability,error,error,157013,"which result in differing diagnostic; behavior. For example:. .. code-block:: c++. // RUN: %clang_cc1 -verify=foo,bar %s. int A = B; // foo-error {{use of undeclared identifier 'B'}}; int C = D; // bar-error {{use of undeclared identifier 'D'}}; int E = F; // expected-error {{use of undeclared identifier 'F'}}. The verifier will recognize ``foo-error`` and ``bar-error`` as special comments; but will not recognize ``expected-error`` as one because the ``-verify`` line; does not contain that as a prefix. Thus, this test would fail verification; because an unexpected diagnostic would appear on the declaration of ``E``. Multiple occurrences accumulate prefixes. For example,; ``-verify -verify=foo,bar -verify=baz`` is equivalent to; ``-verify=expected,foo,bar,baz``. Specifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^; Indicating that a line expects an error or a warning is easy. Put a comment; on the line that has the diagnostic, use; ``expected-{error,warning,remark,note}`` to tag if it's an expected error,; warning, remark, or note (respectively), and place the expected text between; ``{{`` and ``}}`` markers. The full text doesn't have to be included, only; enough to ensure that the correct diagnostic was emitted. (Note: full text; should be included in test cases unless there is a compelling reason to use; truncated text instead.). For a full description of the matching behavior, including more complex; matching scenarios, see :ref:`matching <DiagnosticMatching>` below. Here's an example of the most commonly used way to specify expected; diagnostics:. .. code-block:: c++. int A = B; // expected-error {{use of undeclared identifier 'B'}}. You can place as many diagnostics on one line as you wish. To make the code; more readable, you can use slash-newline to separate out the diagnostics. Alternatively, it is possible to specify the line on which the diagnostic; should appear by appending ``@<line>`` to ``expected-<type>``, for example:. .. code-block:: c++. #warning some te",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:157069,Availability,error,error,157069,"which result in differing diagnostic; behavior. For example:. .. code-block:: c++. // RUN: %clang_cc1 -verify=foo,bar %s. int A = B; // foo-error {{use of undeclared identifier 'B'}}; int C = D; // bar-error {{use of undeclared identifier 'D'}}; int E = F; // expected-error {{use of undeclared identifier 'F'}}. The verifier will recognize ``foo-error`` and ``bar-error`` as special comments; but will not recognize ``expected-error`` as one because the ``-verify`` line; does not contain that as a prefix. Thus, this test would fail verification; because an unexpected diagnostic would appear on the declaration of ``E``. Multiple occurrences accumulate prefixes. For example,; ``-verify -verify=foo,bar -verify=baz`` is equivalent to; ``-verify=expected,foo,bar,baz``. Specifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^; Indicating that a line expects an error or a warning is easy. Put a comment; on the line that has the diagnostic, use; ``expected-{error,warning,remark,note}`` to tag if it's an expected error,; warning, remark, or note (respectively), and place the expected text between; ``{{`` and ``}}`` markers. The full text doesn't have to be included, only; enough to ensure that the correct diagnostic was emitted. (Note: full text; should be included in test cases unless there is a compelling reason to use; truncated text instead.). For a full description of the matching behavior, including more complex; matching scenarios, see :ref:`matching <DiagnosticMatching>` below. Here's an example of the most commonly used way to specify expected; diagnostics:. .. code-block:: c++. int A = B; // expected-error {{use of undeclared identifier 'B'}}. You can place as many diagnostics on one line as you wish. To make the code; more readable, you can use slash-newline to separate out the diagnostics. Alternatively, it is possible to specify the line on which the diagnostic; should appear by appending ``@<line>`` to ``expected-<type>``, for example:. .. code-block:: c++. #warning some te",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:157678,Availability,error,error,157678,"ultiple occurrences accumulate prefixes. For example,; ``-verify -verify=foo,bar -verify=baz`` is equivalent to; ``-verify=expected,foo,bar,baz``. Specifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^; Indicating that a line expects an error or a warning is easy. Put a comment; on the line that has the diagnostic, use; ``expected-{error,warning,remark,note}`` to tag if it's an expected error,; warning, remark, or note (respectively), and place the expected text between; ``{{`` and ``}}`` markers. The full text doesn't have to be included, only; enough to ensure that the correct diagnostic was emitted. (Note: full text; should be included in test cases unless there is a compelling reason to use; truncated text instead.). For a full description of the matching behavior, including more complex; matching scenarios, see :ref:`matching <DiagnosticMatching>` below. Here's an example of the most commonly used way to specify expected; diagnostics:. .. code-block:: c++. int A = B; // expected-error {{use of undeclared identifier 'B'}}. You can place as many diagnostics on one line as you wish. To make the code; more readable, you can use slash-newline to separate out the diagnostics. Alternatively, it is possible to specify the line on which the diagnostic; should appear by appending ``@<line>`` to ``expected-<type>``, for example:. .. code-block:: c++. #warning some text; // expected-warning@10 {{some text}}. The line number may be absolute (as above), or relative to the current line by; prefixing the number with either ``+`` or ``-``. If the diagnostic is generated in a separate file, for example in a shared; header file, it may be beneficial to be able to declare the file in which the; diagnostic will appear, rather than placing the ``expected-*`` directive in the; actual file itself. This can be done using the following syntax:. .. code-block:: c++. // expected-error@path/include.h:15 {{error message}}. The path can be absolute or relative and the same search paths will be used a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:158568,Availability,error,error,158568," the most commonly used way to specify expected; diagnostics:. .. code-block:: c++. int A = B; // expected-error {{use of undeclared identifier 'B'}}. You can place as many diagnostics on one line as you wish. To make the code; more readable, you can use slash-newline to separate out the diagnostics. Alternatively, it is possible to specify the line on which the diagnostic; should appear by appending ``@<line>`` to ``expected-<type>``, for example:. .. code-block:: c++. #warning some text; // expected-warning@10 {{some text}}. The line number may be absolute (as above), or relative to the current line by; prefixing the number with either ``+`` or ``-``. If the diagnostic is generated in a separate file, for example in a shared; header file, it may be beneficial to be able to declare the file in which the; diagnostic will appear, rather than placing the ``expected-*`` directive in the; actual file itself. This can be done using the following syntax:. .. code-block:: c++. // expected-error@path/include.h:15 {{error message}}. The path can be absolute or relative and the same search paths will be used as; for ``#include`` directives. The line number in an external file may be; substituted with ``*`` meaning that any line number will match (useful where; the included file is, for example, a system header where the actual line number; may change and is not critical). As an alternative to specifying a fixed line number, the location of a; diagnostic can instead be indicated by a marker of the form ``#<marker>``.; Markers are specified by including them in a comment, and then referenced by; appending the marker to the diagnostic with ``@#<marker>``, as with:. .. code-block:: c++. #warning some text // #1; // ... other code ...; // expected-warning@#1 {{some text}}. The name of a marker used in a directive must be unique within the compilation. The simple syntax above allows each specification to match exactly one; diagnostic. You can use the extended syntax to customize th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:158594,Availability,error,error,158594," to specify expected; diagnostics:. .. code-block:: c++. int A = B; // expected-error {{use of undeclared identifier 'B'}}. You can place as many diagnostics on one line as you wish. To make the code; more readable, you can use slash-newline to separate out the diagnostics. Alternatively, it is possible to specify the line on which the diagnostic; should appear by appending ``@<line>`` to ``expected-<type>``, for example:. .. code-block:: c++. #warning some text; // expected-warning@10 {{some text}}. The line number may be absolute (as above), or relative to the current line by; prefixing the number with either ``+`` or ``-``. If the diagnostic is generated in a separate file, for example in a shared; header file, it may be beneficial to be able to declare the file in which the; diagnostic will appear, rather than placing the ``expected-*`` directive in the; actual file itself. This can be done using the following syntax:. .. code-block:: c++. // expected-error@path/include.h:15 {{error message}}. The path can be absolute or relative and the same search paths will be used as; for ``#include`` directives. The line number in an external file may be; substituted with ``*`` meaning that any line number will match (useful where; the included file is, for example, a system header where the actual line number; may change and is not critical). As an alternative to specifying a fixed line number, the location of a; diagnostic can instead be indicated by a marker of the form ``#<marker>``.; Markers are specified by including them in a comment, and then referenced by; appending the marker to the diagnostic with ``@#<marker>``, as with:. .. code-block:: c++. #warning some text // #1; // ... other code ...; // expected-warning@#1 {{some text}}. The name of a marker used in a directive must be unique within the compilation. The simple syntax above allows each specification to match exactly one; diagnostic. You can use the extended syntax to customize this. The extended; syntax is ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:159668,Availability,error,error,159668,"earch paths will be used as; for ``#include`` directives. The line number in an external file may be; substituted with ``*`` meaning that any line number will match (useful where; the included file is, for example, a system header where the actual line number; may change and is not critical). As an alternative to specifying a fixed line number, the location of a; diagnostic can instead be indicated by a marker of the form ``#<marker>``.; Markers are specified by including them in a comment, and then referenced by; appending the marker to the diagnostic with ``@#<marker>``, as with:. .. code-block:: c++. #warning some text // #1; // ... other code ...; // expected-warning@#1 {{some text}}. The name of a marker used in a directive must be unique within the compilation. The simple syntax above allows each specification to match exactly one; diagnostic. You can use the extended syntax to customize this. The extended; syntax is ``expected-<type> <n> {{diag text}}``, where ``<type>`` is one of; ``error``, ``warning``, ``remark``, or ``note``, and ``<n>`` is a positive; integer. This allows the diagnostic to appear as many times as specified. For; example:. .. code-block:: c++. void f(); // expected-note 2 {{previous declaration is here}}. Where the diagnostic is expected to occur a minimum number of times, this can; be specified by appending a ``+`` to the number. For example:. .. code-block:: c++. void f(); // expected-note 0+ {{previous declaration is here}}; void g(); // expected-note 1+ {{previous declaration is here}}. In the first example, the diagnostic becomes optional, i.e. it will be; swallowed if it occurs, but will not generate an error if it does not occur. In; the second example, the diagnostic must occur at least once. As a short-hand,; ""one or more"" can be specified simply by ``+``. For example:. .. code-block:: c++. void g(); // expected-note + {{previous declaration is here}}. A range can also be specified by ``<n>-<m>``. For example:. .. code-block:: c+",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:160327,Availability,error,error,160327,"er code ...; // expected-warning@#1 {{some text}}. The name of a marker used in a directive must be unique within the compilation. The simple syntax above allows each specification to match exactly one; diagnostic. You can use the extended syntax to customize this. The extended; syntax is ``expected-<type> <n> {{diag text}}``, where ``<type>`` is one of; ``error``, ``warning``, ``remark``, or ``note``, and ``<n>`` is a positive; integer. This allows the diagnostic to appear as many times as specified. For; example:. .. code-block:: c++. void f(); // expected-note 2 {{previous declaration is here}}. Where the diagnostic is expected to occur a minimum number of times, this can; be specified by appending a ``+`` to the number. For example:. .. code-block:: c++. void f(); // expected-note 0+ {{previous declaration is here}}; void g(); // expected-note 1+ {{previous declaration is here}}. In the first example, the diagnostic becomes optional, i.e. it will be; swallowed if it occurs, but will not generate an error if it does not occur. In; the second example, the diagnostic must occur at least once. As a short-hand,; ""one or more"" can be specified simply by ``+``. For example:. .. code-block:: c++. void g(); // expected-note + {{previous declaration is here}}. A range can also be specified by ``<n>-<m>``. For example:. .. code-block:: c++. void f(); // expected-note 0-1 {{previous declaration is here}}. In this example, the diagnostic may appear only once, if at all. .. _DiagnosticMatching:. Matching Modes; ~~~~~~~~~~~~~~. The default matching mode is simple string, which looks for the expected text; that appears between the first `{{` and `}}` pair of the comment. The string is; interpreted just as-is, with one exception: the sequence `\n` is converted to a; single newline character. This mode matches the emitted diagnostic when the; text appears as a substring at any position of the emitted message. To enable matching against desired strings that contain `}}` or `{{`, th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162009,Availability,error,error-re,162009,"-is, with one exception: the sequence `\n` is converted to a; single newline character. This mode matches the emitted diagnostic when the; text appears as a substring at any position of the emitted message. To enable matching against desired strings that contain `}}` or `{{`, the; string-mode parser accepts opening delimiters of more than two curly braces,; like `{{{`. It then looks for a closing delimiter of equal ""width"" (i.e `}}}`).; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a par",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162091,Availability,error,error,162091,"e character. This mode matches the emitted diagnostic when the; text appears as a substring at any position of the emitted message. To enable matching against desired strings that contain `}}` or `{{`, the; string-mode parser accepts opening delimiters of more than two curly braces,; like `{{{`. It then looks for a closing delimiter of equal ""width"" (i.e `}}}`).; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult propert",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162174,Availability,error,error,162174,"strings that contain `}}` or `{{`, the; string-mode parser accepts opening delimiters of more than two curly braces,; like `{{{`. It then looks for a closing delimiter of equal ""width"" (i.e `}}}`).; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a featur",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162237,Availability,error,error,162237,"strings that contain `}}` or `{{`, the; string-mode parser accepts opening delimiters of more than two curly braces,; like `{{{`. It then looks for a closing delimiter of equal ""width"" (i.e `}}}`).; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a featur",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162289,Availability,error,error,162289,"strings that contain `}}` or `{{`, the; string-mode parser accepts opening delimiters of more than two curly braces,; like `{{{`. It then looks for a closing delimiter of equal ""width"" (i.e `}}}`).; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a featur",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162343,Availability,error,error,162343,"strings that contain `}}` or `{{`, the; string-mode parser accepts opening delimiters of more than two curly braces,; like `{{{`. It then looks for a closing delimiter of equal ""width"" (i.e `}}}`).; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a featur",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162399,Availability,error,error-re,162399,"ooks for a closing delimiter of equal ""width"" (i.e `}}}`).; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accept",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162458,Availability,error,error-re,162458,").; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162518,Availability,error,error-re,162518,"valuates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, fail",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162580,Availability,error,error-re,162580,"he delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, failed assertions, or miscompilations?; * Are there known issues on a ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:5225,Deployability,configurat,configuration,5225," severity is used for; diagnostics indicating the program is never acceptable under any circumstances.; When an error is emitted, the AST for the input code may not be fully built.; The ``EXTENSION`` and ``EXTWARN`` severities are used for extensions to the; language that Clang accepts. This means that Clang fully understands and can; represent them in the AST, but we produce diagnostics to tell the user their; code is non-portable. The difference is that the former are ignored by; default, and the later warn by default. The ``WARNING`` severity is used for; constructs that are valid in the currently selected source language but that; are dubious in some way. The ``REMARK`` severity provides generic information; about the compilation that is not necessarily related to any dubious code. The; ``NOTE`` level is used to staple more information onto previous diagnostics. These *severities* are mapped into a smaller set (the ``Diagnostic::Level``; enum, {``Ignored``, ``Note``, ``Remark``, ``Warning``, ``Error``, ``Fatal``}) of; output; *levels* by the diagnostics subsystem based on various configuration options.; Clang internally supports a fully fine grained mapping mechanism that allows; you to map almost any diagnostic to the output level that you want. The only; diagnostics that cannot be mapped are ``NOTE``\ s, which always follow the; severity of the previously emitted diagnostic and ``ERROR``\ s, which can only; be mapped to ``Fatal`` (it is not possible to turn an error into a warning, for; example). Diagnostic mappings are used in many ways. For example, if the user specifies; ``-pedantic``, ``EXTENSION`` maps to ``Warning``, if they specify; ``-pedantic-errors``, it turns into ``Error``. This is used to implement; options like ``-Wunused_macros``, ``-Wundef`` etc. Mapping to ``Fatal`` should only be used for diagnostics that are considered so; severe that error recovery won't be able to recover sensibly from them (thus; spewing a ton of bogus errors). One example",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:52215,Deployability,upgrade,upgraded,52215,"presents a C++ scope; specifier, such as ""``A::B::``"". This corresponds to the grammar; productions ""*::*"" and ""*:: [opt] nested-name-specifier*"". The; ``AnnotationValue`` pointer is a ``NestedNameSpecifier *`` returned by the; ``Sema::ActOnCXXGlobalScopeSpecifier`` and; ``Sema::ActOnCXXNestedNameSpecifier`` callbacks.; #. **tok::annot_template_id**: This annotation token represents a C++; template-id such as ""``foo<int, 4>``"", where ""``foo``"" is the name of a; template. The ``AnnotationValue`` pointer is a pointer to a ``malloc``'d; ``TemplateIdAnnotation`` object. Depending on the context, a parsed; template-id that names a type might become a typename annotation token (if; all we care about is the named type, e.g., because it occurs in a type; specifier) or might remain a template-id token (if we want to retain more; source location information or produce a new type, e.g., in a declaration of; a class template specialization). template-id annotation tokens that refer; to a type can be ""upgraded"" to typename annotation tokens by the parser. As mentioned above, annotation tokens are not returned by the preprocessor,; they are formed on demand by the parser. This means that the parser has to be; aware of cases where an annotation could occur and form it where appropriate.; This is somewhat similar to how the parser handles Translation Phase 6 of C99:; String Concatenation (see C99 5.1.1.2). In the case of string concatenation,; the preprocessor just returns distinct ``tok::string_literal`` and; ``tok::wide_string_literal`` tokens and the parser eats a sequence of them; wherever the grammar indicates that a string literal can occur. In order to do this, whenever the parser expects a ``tok::identifier`` or; ``tok::coloncolon``, it should call the ``TryAnnotateTypeOrScopeToken`` or; ``TryAnnotateCXXScopeToken`` methods to form the annotation token. These; methods will maximally form the specified annotation tokens and replace the; current token with them, if applicable.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:58626,Deployability,update,update,58626,"-------. Immutability; ^^^^^^^^^^^^. Clang AST nodes (types, declarations, statements, expressions, and so on) are; generally designed to be immutable once created. This provides a number of key; benefits:. * Canonicalization of the ""meaning"" of nodes is possible as soon as the nodes; are created, and is not invalidated by later addition of more information.; For example, we :ref:`canonicalize types <CanonicalType>`, and use a; canonicalized representation of expressions when determining whether two; function template declarations involving dependent expressions declare the; same entity.; * AST nodes can be reused when they have the same meaning. For example, we; reuse ``Type`` nodes when representing the same type (but maintain separate; ``TypeLoc``\s for each instance where a type is written), and we reuse; non-dependent ``Stmt`` and ``Expr`` nodes across instantiations of a; template.; * Serialization and deserialization of the AST to/from AST files is simpler:; we do not need to track modifications made to AST nodes imported from AST; files and serialize separate ""update records"". There are unfortunately exceptions to this general approach, such as:. * The first declaration of a redeclarable entity maintains a pointer to the; most recent declaration of that entity, which naturally needs to change as; more declarations are parsed.; * Name lookup tables in declaration contexts change after the namespace; declaration is formed.; * We attempt to maintain only a single declaration for an instantiation of a; template, rather than having distinct declarations for an instantiation of; the declaration versus the definition, so template instantiation often; updates parts of existing declarations.; * Some parts of declarations are required to be instantiated separately (this; includes default arguments and exception specifications), and such; instantiations update the existing declaration. These cases tend to be fragile; mutable AST state should be avoided where; possible. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:59221,Deployability,update,updates,59221,"e entity.; * AST nodes can be reused when they have the same meaning. For example, we; reuse ``Type`` nodes when representing the same type (but maintain separate; ``TypeLoc``\s for each instance where a type is written), and we reuse; non-dependent ``Stmt`` and ``Expr`` nodes across instantiations of a; template.; * Serialization and deserialization of the AST to/from AST files is simpler:; we do not need to track modifications made to AST nodes imported from AST; files and serialize separate ""update records"". There are unfortunately exceptions to this general approach, such as:. * The first declaration of a redeclarable entity maintains a pointer to the; most recent declaration of that entity, which naturally needs to change as; more declarations are parsed.; * Name lookup tables in declaration contexts change after the namespace; declaration is formed.; * We attempt to maintain only a single declaration for an instantiation of a; template, rather than having distinct declarations for an instantiation of; the declaration versus the definition, so template instantiation often; updates parts of existing declarations.; * Some parts of declarations are required to be instantiated separately (this; includes default arguments and exception specifications), and such; instantiations update the existing declaration. These cases tend to be fragile; mutable AST state should be avoided where; possible. As a consequence of this design principle, we typically do not provide setters; for AST state. (Some are provided for short-term modifications intended to be; used immediately after an AST node is created and before it's ""published"" as; part of the complete AST, or where language semantics require after-the-fact; updates.). Faithfulness; ^^^^^^^^^^^^. The AST intends to provide a representation of the program that is faithful to; the original source. We intend for it to be possible to write refactoring tools; using only information stored in, or easily reconstructible from, the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:59424,Deployability,update,update,59424,"se; non-dependent ``Stmt`` and ``Expr`` nodes across instantiations of a; template.; * Serialization and deserialization of the AST to/from AST files is simpler:; we do not need to track modifications made to AST nodes imported from AST; files and serialize separate ""update records"". There are unfortunately exceptions to this general approach, such as:. * The first declaration of a redeclarable entity maintains a pointer to the; most recent declaration of that entity, which naturally needs to change as; more declarations are parsed.; * Name lookup tables in declaration contexts change after the namespace; declaration is formed.; * We attempt to maintain only a single declaration for an instantiation of a; template, rather than having distinct declarations for an instantiation of; the declaration versus the definition, so template instantiation often; updates parts of existing declarations.; * Some parts of declarations are required to be instantiated separately (this; includes default arguments and exception specifications), and such; instantiations update the existing declaration. These cases tend to be fragile; mutable AST state should be avoided where; possible. As a consequence of this design principle, we typically do not provide setters; for AST state. (Some are provided for short-term modifications intended to be; used immediately after an AST node is created and before it's ""published"" as; part of the complete AST, or where language semantics require after-the-fact; updates.). Faithfulness; ^^^^^^^^^^^^. The AST intends to provide a representation of the program that is faithful to; the original source. We intend for it to be possible to write refactoring tools; using only information stored in, or easily reconstructible from, the Clang AST.; This means that the AST representation should either not desugar source-level; constructs to simpler forms, or -- where made necessary by language semantics; or a clear engineering tradeoff -- should desugar minimally a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:59857,Deployability,update,updates,59857,"rable entity maintains a pointer to the; most recent declaration of that entity, which naturally needs to change as; more declarations are parsed.; * Name lookup tables in declaration contexts change after the namespace; declaration is formed.; * We attempt to maintain only a single declaration for an instantiation of a; template, rather than having distinct declarations for an instantiation of; the declaration versus the definition, so template instantiation often; updates parts of existing declarations.; * Some parts of declarations are required to be instantiated separately (this; includes default arguments and exception specifications), and such; instantiations update the existing declaration. These cases tend to be fragile; mutable AST state should be avoided where; possible. As a consequence of this design principle, we typically do not provide setters; for AST state. (Some are provided for short-term modifications intended to be; used immediately after an AST node is created and before it's ""published"" as; part of the complete AST, or where language semantics require after-the-fact; updates.). Faithfulness; ^^^^^^^^^^^^. The AST intends to provide a representation of the program that is faithful to; the original source. We intend for it to be possible to write refactoring tools; using only information stored in, or easily reconstructible from, the Clang AST.; This means that the AST representation should either not desugar source-level; constructs to simpler forms, or -- where made necessary by language semantics; or a clear engineering tradeoff -- should desugar minimally and wrap the result; in a construct representing the original source form. For example, ``CXXForRangeStmt`` directly represents the syntactic form of a; range-based for statement, but also holds a semantic representation of the; range declaration and iterator declarations. It does not contain a; fully-desugared ``ForStmt``, however. Some AST nodes (for example, ``ParenExpr``) represent only ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:133308,Deployability,update,updated,133308,"but it; can appear wherever a hypothetical ``[[arm::streaming]]`` could appear. Subjects; ~~~~~~~~; Attributes appertain to one or more subjects. If the attribute attempts to; attach to a subject that is not in the subject list, a diagnostic is issued; automatically. Whether the diagnostic is a warning or an error depends on how; the attribute's ``SubjectList`` is defined, but the default behavior is to warn.; The diagnostics displayed to the user are automatically determined based on the; subjects in the list, but a custom diagnostic parameter can also be specified in; the ``SubjectList``. The diagnostics generated for subject list violations are; calculated automatically or specified by the subject list itself. If a; previously unused Decl node is added to the ``SubjectList``, the logic used to; automatically determine the diagnostic parameter in `utils/TableGen/ClangAttrEmitter.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/utils/TableGen/ClangAttrEmitter.cpp>`_; may need to be updated. By default, all subjects in the SubjectList must either be a Decl node defined; in ``DeclNodes.td``, or a statement node defined in ``StmtNodes.td``. However,; more complex subjects can be created by creating a ``SubsetSubject`` object.; Each such object has a base subject which it appertains to (which must be a; Decl or Stmt node, and not a SubsetSubject node), and some custom code which is; called when determining whether an attribute appertains to the subject. For; instance, a ``NonBitField`` SubsetSubject appertains to a ``FieldDecl``, and; tests whether the given FieldDecl is a bit field. When a SubsetSubject is; specified in a SubjectList, a custom diagnostic parameter must also be provided. Diagnostic checking for attribute subject lists for declaration and statement; attributes is automated except when ``HasCustomParsing`` is set to ``1``. Documentation; ~~~~~~~~~~~~~; All attributes must have some form of documentation associated with them.; Documentation is ta",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:138034,Deployability,update,updated,138034,"ng and integer argument. All arguments have a name and a flag that specifies whether the argument is; optional. The associated C++ type of the argument is determined by the argument; definition type. If the existing argument types are insufficient, new types can; be created, but it requires modifying `utils/TableGen/ClangAttrEmitter.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/utils/TableGen/ClangAttrEmitter.cpp>`_; to properly support the type. Other Properties; ~~~~~~~~~~~~~~~~; The ``Attr`` definition has other members which control the behavior of the; attribute. Many of them are special-purpose and beyond the scope of this; document, however a few deserve mention. If the parsed form of the attribute is more complex, or differs from the; semantic form, the ``HasCustomParsing`` bit can be set to ``1`` for the class,; and the parsing code in `Parser::ParseGNUAttributeArgs(); <https://github.com/llvm/llvm-project/blob/main/clang/lib/Parse/ParseDecl.cpp>`_; can be updated for the special case. Note that this only applies to arguments; with a GNU spelling -- attributes with a __declspec spelling currently ignore; this flag and are handled by ``Parser::ParseMicrosoftDeclSpec``. Note that setting this member to 1 will opt out of common attribute semantic; handling, requiring extra implementation efforts to ensure the attribute; appertains to the appropriate subject, etc. If the attribute should not be propagated from a template declaration to an; instantiation of the template, set the ``Clone`` member to 0. By default, all; attributes will be cloned to template instantiations. Attributes that do not require an AST node should set the ``ASTNode`` field to; ``0`` to avoid polluting the AST. Note that anything inheriting from; ``TypeAttr`` or ``IgnoredAttr`` automatically do not generate an AST node. All; other attributes generate an AST node by default. The AST node is the semantic; representation of the attribute. The ``LangOpts`` field specifies a list of",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:149595,Deployability,update,update,149595," IDE support.; * Make sure that ``children()`` visits all of the subexpressions. This is; important for a number of features (e.g., IDE support, C++ variadic; templates). If you have sub-types, you'll also need to visit those; sub-types in ``RecursiveASTVisitor``.; * Add printing support (``StmtPrinter.cpp``) for your expression.; * Add profiling support (``StmtProfile.cpp``) for your AST node, noting the; distinguishing (non-source location) characteristics of an instance of; your expression. Omitting this step will lead to hard-to-diagnose; failures regarding matching of template declarations.; * Add serialization support (``ASTReaderStmt.cpp``, ``ASTWriterStmt.cpp``); for your AST node. #. Teach semantic analysis to build your AST node. At this point, you can wire; up your ``Sema::BuildXXX`` function to actually create your AST. A few; things to check at this point:. * If your expression can construct a new C++ class or return a new; Objective-C object, be sure to update and then call; ``Sema::MaybeBindToTemporary`` for your just-created AST node to be sure; that the object gets properly destructed. An easy way to test this is to; return a C++ class with a private destructor: semantic analysis should; flag an error here with the attempt to call the destructor.; * Inspect the generated AST by printing it using ``clang -cc1 -ast-print``,; to make sure you're capturing all of the important information about how; the AST was written.; * Inspect the generated AST under ``clang -cc1 -ast-dump`` to verify that; all of the types in the generated AST line up the way you want them.; Remember that clients of the AST should never have to ""think"" to; understand what's going on. For example, all implicit conversions should; show up explicitly in the AST.; * Write tests that use your expression as a subexpression of other,; well-known expressions. Can you call a function using your expression as; an argument? Can you use the ternary operator?. #. Teach code generation to create ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:153922,Deployability,integrat,integration,153922,"ten, computing these flags; just means combining the results from the various types and; subexpressions.; * Add ``TransformXXX`` and ``RebuildXXX`` functions to the ``TreeTransform``; class template in ``Sema``. ``TransformXXX`` should (recursively); transform all of the subexpressions and types within your expression,; using ``getDerived().TransformYYY``. If all of the subexpressions and; types transform without error, it will then call the ``RebuildXXX``; function, which will in turn call ``getSema().BuildXXX`` to perform; semantic analysis and build your expression.; * To test template instantiation, take those tests you wrote to make sure; that you were type checking with type-dependent expressions and dependent; types (from step #2) and instantiate those templates with various types,; some of which type-check and some that don't, and test the error messages; in each case. #. There are some ""extras"" that make other features work better. It's worth; handling these extras to give your expression complete integration into; Clang:. * Add code completion support for your expression in; ``SemaCodeComplete.cpp``.; * If your expression has types in it, or has any ""interesting"" features; other than subexpressions, extend libclang's ``CursorVisitor`` to provide; proper visitation for your expression, enabling various IDE features such; as syntax highlighting, cross-referencing, and so on. The; ``c-index-test`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come with test coverage demonstrating; the change in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option as a way to; validate diagnostic behavior. This option will use special comments within the; test file to verify that expected diagnostics appear in the correct source; locations. If all of the expected diagnostics match the actual output of Clang,; then the invocatio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:6293,Energy Efficiency,power,power,6293,"ally supports a fully fine grained mapping mechanism that allows; you to map almost any diagnostic to the output level that you want. The only; diagnostics that cannot be mapped are ``NOTE``\ s, which always follow the; severity of the previously emitted diagnostic and ``ERROR``\ s, which can only; be mapped to ``Fatal`` (it is not possible to turn an error into a warning, for; example). Diagnostic mappings are used in many ways. For example, if the user specifies; ``-pedantic``, ``EXTENSION`` maps to ``Warning``, if they specify; ``-pedantic-errors``, it turns into ``Error``. This is used to implement; options like ``-Wunused_macros``, ``-Wundef`` etc. Mapping to ``Fatal`` should only be used for diagnostics that are considered so; severe that error recovery won't be able to recover sensibly from them (thus; spewing a ton of bogus errors). One example of this class of error are failure; to ``#include`` a file. The Format String; ^^^^^^^^^^^^^^^^^. The format string for the diagnostic is very simple, but it has some power. It; takes the form of a string in English with markers that indicate where and how; arguments to the diagnostic are inserted and formatted. For example, here are; some simple format strings:. .. code-block:: c++. ""binary integer literals are an extension""; ""format string contains '\\0' within the string body""; ""more '%%' conversions than data arguments""; ""invalid operands to binary expression (%0 and %1)""; ""overloaded '%0' must be a %select{unary|binary|unary or binary}2 operator""; "" (has %1 parameter%s1)"". These examples show some important points of format strings. You can use any; plain ASCII character in the diagnostic string except ""``%``"" without a; problem, but these are C strings, so you have to use and be aware of all the C; escape sequences (as in the second example). If you want to produce a ""``%``""; in the output, use the ""``%%``"" escape sequence, like the third diagnostic.; Finally, Clang uses the ""``%...[digit]``"" sequences to specif",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:23538,Energy Efficiency,efficient,efficiently,23538,"I; might let you click on typedefs to expand them. This application would want to; pass significantly more information about types through to the GUI than a; simple flat string. The interface allows this to happen. .. _internals-diag-translation:. Adding Translations to Clang; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Not possible yet! Diagnostic strings should be written in UTF-8, the client can; translate to the relevant code page if needed. Each translation completely; replaces the format string for the diagnostic. .. _SourceLocation:; .. _SourceManager:. The ``SourceLocation`` and ``SourceManager`` classes; ----------------------------------------------------. Strangely enough, the ``SourceLocation`` class represents a location within the; source code of the program. Important design points include:. #. ``sizeof(SourceLocation)`` must be extremely small, as these are embedded; into many AST nodes and are passed around often. Currently it is 32 bits.; #. ``SourceLocation`` must be a simple value object that can be efficiently; copied.; #. We should be able to represent a source location for any byte of any input; file. This includes in the middle of tokens, in whitespace, in trigraphs,; etc.; #. A ``SourceLocation`` must encode the current ``#include`` stack that was; active when the location was processed. For example, if the location; corresponds to a token, it should contain the set of ``#include``\ s active; when the token was lexed. This allows us to print the ``#include`` stack; for a diagnostic.; #. ``SourceLocation`` must be able to describe macro expansions, capturing both; the ultimate instantiation point and the source of the original character; data. In practice, the ``SourceLocation`` works together with the ``SourceManager``; class to encode two pieces of information about a location: its spelling; location and its expansion location. For most tokens, these will be the; same. However, for a macro expansion (or tokens that came from a ``_Pragma``; directive) the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:32654,Energy Efficiency,reduce,reduces,32654,"(Twine(""-fpass-plugin="") + A->getValue()));; + A->claim();; + }; }. The last step is implementing the ``-cc1`` command line argument; parsing/generation that initializes/serializes the option class (in our case; ``CodeGenOptions``) stored within ``CompilerInvocation``. This can be done; automatically by using the marshalling annotations on the option definition:. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; Group<f_Group>, Flags<[CC1Option]>,; HelpText<""Load pass plugin from a dynamic shared object file."">,; + MarshallingInfoStringVector<CodeGenOpts<""PassPlugins"">>;. Inner workings of the system are introduced in the :ref:`marshalling; infrastructure <OptionMarshalling>` section and the available annotations are; listed :ref:`here <OptionMarshallingAnnotations>`. In case the marshalling infrastructure does not support the desired semantics,; consider simplifying it to fit the existing model. This makes the command line; more uniform and reduces the amount of custom, manually written code. Remember; that the ``-cc1`` command line interface is intended only for Clang developers,; meaning it does not need to mirror the driver interface, maintain backward; compatibility or be compatible with GCC. If the option semantics cannot be encoded via marshalling annotations, you can; resort to parsing/serializing the command line arguments manually:. .. code-block:: diff. // CompilerInvocation.cpp. static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args /*...*/) {; // ... + Opts.PassPlugins = Args.getAllArgValues(OPT_fpass_plugin_EQ);; }. static void GenerateCodeGenArgs(const CodeGenOptions &Opts,; SmallVectorImpl<const char *> &Args,; CompilerInvocation::StringAllocator SA /*...*/) {; // ... + for (const std::string &PassPlugin : Opts.PassPlugins); + GenerateArg(Args, OPT_fpass_plugin_EQ, PassPlugin, SA);; }. Finally, you can specify the argument on the command line:; ``clang -fpass-plugin=a -fpass-plugin=b`` and use the ne",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:44909,Energy Efficiency,efficient,efficient,44909,"essing C source code. The main; interface to this library for outside clients is the large ``Preprocessor``; class. It contains the various pieces of state that are required to coherently; read tokens out of a translation unit. The core interface to the ``Preprocessor`` object (once it is set up) is the; ``Preprocessor::Lex`` method, which returns the next :ref:`Token <Token>` from; the preprocessor stream. There are two types of token providers that the; preprocessor is capable of reading from: a buffer lexer (provided by the; :ref:`Lexer <Lexer>` class) and a buffered token stream (provided by the; :ref:`TokenLexer <TokenLexer>` class). .. _Token:. The Token class; ---------------. The ``Token`` class is used to represent a single lexed token. Tokens are; intended to be used by the lexer/preprocess and parser libraries, but are not; intended to live beyond them (for example, they should not live in the ASTs). Tokens most often live on the stack (or some other location that is efficient; to access) as the parser is running, but occasionally do get buffered up. For; example, macro definitions are stored as a series of tokens, and the C++; front-end periodically needs to buffer tokens up for tentative parsing and; various pieces of look-ahead. As such, the size of a ``Token`` matters. On a; 32-bit system, ``sizeof(Token)`` is currently 16 bytes. Tokens occur in two forms: :ref:`annotation tokens <AnnotationToken>` and; normal tokens. Normal tokens are those returned by the lexer, annotation; tokens represent semantic information and are produced by the parser, replacing; normal tokens in the token stream. Normal tokens contain the following; information:. * **A SourceLocation** --- This indicates the location of the start of the; token. * **A length** --- This stores the length of the token as stored in the; ``SourceBuffer``. For tokens that include them, this length includes; trigraphs and escaped newlines which are ignored by later phases of the; compiler. By pointi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:63396,Energy Efficiency,efficient,efficient,63396,". While this example is somewhat silly, it illustrates the point: we want to; retain typedef information where possible, so that we can emit errors about; ""``std::string``"" instead of ""``std::basic_string<char, std:...``"". Doing this; requires properly keeping typedef information (for example, the type of ``X``; is ""``foo``"", not ""``int``""), and requires properly propagating it through the; various operators (for example, the type of ``*Y`` is ""``foo``"", not; ""``int``""). In order to retain this information, the type of these expressions; is an instance of the ``TypedefType`` class, which indicates that the type of; these expressions is a typedef for ""``foo``"". Representing types like this is great for diagnostics, because the; user-specified type is always immediately available. There are two problems; with this: first, various semantic checks need to make judgements about the; *actual structure* of a type, ignoring typedefs. Second, we need an efficient; way to query whether two types are structurally identical to each other,; ignoring typedefs. The solution to both of these problems is the idea of; canonical types. .. _CanonicalType:. Canonical Types; ^^^^^^^^^^^^^^^. Every instance of the ``Type`` class contains a canonical type pointer. For; simple types with no typedefs involved (e.g., ""``int``"", ""``int*``"",; ""``int**``""), the type just points to itself. For types that have a typedef; somewhere in their structure (e.g., ""``foo``"", ""``foo*``"", ""``foo**``"",; ""``bar``""), the canonical type pointer points to their structurally equivalent; type without any typedefs (e.g., ""``int``"", ""``int*``"", ""``int**``"", and; ""``int*``"" respectively). This design provides a constant time operation (dereferencing the canonical type; pointer) that gives us access to the structure of types. For example, we can; trivially tell that ""``bar``"" and ""``foo*``"" are the same type by dereferencing; their canonical type pointers and doing a pointer comparison (they both point; to the single """,MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:66610,Energy Efficiency,efficient,efficient,66610,"indirection; operator is the pointee type of the subexpression. In order to determine the; type, we need to get the instance of ``PointerType`` that best captures the; typedef information in the program. If the type of the expression is literally; a ``PointerType``, we can return that, otherwise we have to dig through the; typedefs to find the pointer type. For example, if the subexpression had type; ""``foo*``"", we could return that type as the result. If the subexpression had; type ""``bar``"", we want to return ""``foo*``"" (note that we do *not* want; ""``int*``""). In order to provide all of this, ``Type`` has a; ``getAsPointerType()`` method that checks whether the type is structurally a; ``PointerType`` and, if so, returns the best one. If not, it returns a null; pointer. This structure is somewhat mystical, but after meditating on it, it will make; sense to you :). .. _QualType:. The ``QualType`` class; ----------------------. The ``QualType`` class is designed as a trivial value class that is small,; passed by-value and is efficient to query. The idea of ``QualType`` is that it; stores the type qualifiers (``const``, ``volatile``, ``restrict``, plus some; extended qualifiers required by language extensions) separately from the types; themselves. ``QualType`` is conceptually a pair of ""``Type*``"" and the bits; for these type qualifiers. By storing the type qualifiers as bits in the conceptual pair, it is extremely; efficient to get the set of qualifiers on a ``QualType`` (just return the field; of the pair), add a type qualifier (which is a trivial constant-time operation; that sets a bit), and remove one or more type qualifiers (just return a; ``QualType`` with the bitfield set to empty). Further, because the bits are stored outside of the type itself, we do not need; to create duplicates of types with different sets of qualifiers (i.e. there is; only a single heap allocated ""``int``"" type: ""``const int``"" and ""``volatile; const int``"" both point to the same heap a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:67009,Energy Efficiency,efficient,efficient,67009,"we do *not* want; ""``int*``""). In order to provide all of this, ``Type`` has a; ``getAsPointerType()`` method that checks whether the type is structurally a; ``PointerType`` and, if so, returns the best one. If not, it returns a null; pointer. This structure is somewhat mystical, but after meditating on it, it will make; sense to you :). .. _QualType:. The ``QualType`` class; ----------------------. The ``QualType`` class is designed as a trivial value class that is small,; passed by-value and is efficient to query. The idea of ``QualType`` is that it; stores the type qualifiers (``const``, ``volatile``, ``restrict``, plus some; extended qualifiers required by language extensions) separately from the types; themselves. ``QualType`` is conceptually a pair of ""``Type*``"" and the bits; for these type qualifiers. By storing the type qualifiers as bits in the conceptual pair, it is extremely; efficient to get the set of qualifiers on a ``QualType`` (just return the field; of the pair), add a type qualifier (which is a trivial constant-time operation; that sets a bit), and remove one or more type qualifiers (just return a; ``QualType`` with the bitfield set to empty). Further, because the bits are stored outside of the type itself, we do not need; to create duplicates of types with different sets of qualifiers (i.e. there is; only a single heap allocated ""``int``"" type: ""``const int``"" and ""``volatile; const int``"" both point to the same heap allocated ""``int``"" type). This; reduces the heap size used to represent bits and also means we do not have to; consider qualifiers when uniquing types (:ref:`Type <Type>` does not even; contain qualifiers). In practice, the two most common type qualifiers (``const`` and ``restrict``); are stored in the low bits of the pointer to the ``Type`` object, together with; a flag indicating whether extended qualifiers are present (which must be; heap-allocated). This means that ``QualType`` is exactly the same size as a; pointer. .. _Declara",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:67469,Energy Efficiency,allocate,allocated,67469,"QualType`` class is designed as a trivial value class that is small,; passed by-value and is efficient to query. The idea of ``QualType`` is that it; stores the type qualifiers (``const``, ``volatile``, ``restrict``, plus some; extended qualifiers required by language extensions) separately from the types; themselves. ``QualType`` is conceptually a pair of ""``Type*``"" and the bits; for these type qualifiers. By storing the type qualifiers as bits in the conceptual pair, it is extremely; efficient to get the set of qualifiers on a ``QualType`` (just return the field; of the pair), add a type qualifier (which is a trivial constant-time operation; that sets a bit), and remove one or more type qualifiers (just return a; ``QualType`` with the bitfield set to empty). Further, because the bits are stored outside of the type itself, we do not need; to create duplicates of types with different sets of qualifiers (i.e. there is; only a single heap allocated ""``int``"" type: ""``const int``"" and ""``volatile; const int``"" both point to the same heap allocated ""``int``"" type). This; reduces the heap size used to represent bits and also means we do not have to; consider qualifiers when uniquing types (:ref:`Type <Type>` does not even; contain qualifiers). In practice, the two most common type qualifiers (``const`` and ``restrict``); are stored in the low bits of the pointer to the ``Type`` object, together with; a flag indicating whether extended qualifiers are present (which must be; heap-allocated). This means that ``QualType`` is exactly the same size as a; pointer. .. _DeclarationName:. Declaration names; -----------------. The ``DeclarationName`` class represents the name of a declaration in Clang.; Declarations in the C family of languages can take several different forms.; Most declarations are named by simple identifiers, e.g., ""``f``"" and ""``x``"" in; the function declaration ``f(int x)``. In C++, declaration names can also name; class constructors (""``Class``"" in ``struct ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:67569,Energy Efficiency,allocate,allocated,67569,"QualType`` class is designed as a trivial value class that is small,; passed by-value and is efficient to query. The idea of ``QualType`` is that it; stores the type qualifiers (``const``, ``volatile``, ``restrict``, plus some; extended qualifiers required by language extensions) separately from the types; themselves. ``QualType`` is conceptually a pair of ""``Type*``"" and the bits; for these type qualifiers. By storing the type qualifiers as bits in the conceptual pair, it is extremely; efficient to get the set of qualifiers on a ``QualType`` (just return the field; of the pair), add a type qualifier (which is a trivial constant-time operation; that sets a bit), and remove one or more type qualifiers (just return a; ``QualType`` with the bitfield set to empty). Further, because the bits are stored outside of the type itself, we do not need; to create duplicates of types with different sets of qualifiers (i.e. there is; only a single heap allocated ""``int``"" type: ""``const int``"" and ""``volatile; const int``"" both point to the same heap allocated ""``int``"" type). This; reduces the heap size used to represent bits and also means we do not have to; consider qualifiers when uniquing types (:ref:`Type <Type>` does not even; contain qualifiers). In practice, the two most common type qualifiers (``const`` and ``restrict``); are stored in the low bits of the pointer to the ``Type`` object, together with; a flag indicating whether extended qualifiers are present (which must be; heap-allocated). This means that ``QualType`` is exactly the same size as a; pointer. .. _DeclarationName:. Declaration names; -----------------. The ``DeclarationName`` class represents the name of a declaration in Clang.; Declarations in the C family of languages can take several different forms.; Most declarations are named by simple identifiers, e.g., ""``f``"" and ""``x``"" in; the function declaration ``f(int x)``. In C++, declaration names can also name; class constructors (""``Class``"" in ``struct ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:67602,Energy Efficiency,reduce,reduces,67602,"alifiers (``const``, ``volatile``, ``restrict``, plus some; extended qualifiers required by language extensions) separately from the types; themselves. ``QualType`` is conceptually a pair of ""``Type*``"" and the bits; for these type qualifiers. By storing the type qualifiers as bits in the conceptual pair, it is extremely; efficient to get the set of qualifiers on a ``QualType`` (just return the field; of the pair), add a type qualifier (which is a trivial constant-time operation; that sets a bit), and remove one or more type qualifiers (just return a; ``QualType`` with the bitfield set to empty). Further, because the bits are stored outside of the type itself, we do not need; to create duplicates of types with different sets of qualifiers (i.e. there is; only a single heap allocated ""``int``"" type: ""``const int``"" and ""``volatile; const int``"" both point to the same heap allocated ""``int``"" type). This; reduces the heap size used to represent bits and also means we do not have to; consider qualifiers when uniquing types (:ref:`Type <Type>` does not even; contain qualifiers). In practice, the two most common type qualifiers (``const`` and ``restrict``); are stored in the low bits of the pointer to the ``Type`` object, together with; a flag indicating whether extended qualifiers are present (which must be; heap-allocated). This means that ``QualType`` is exactly the same size as a; pointer. .. _DeclarationName:. Declaration names; -----------------. The ``DeclarationName`` class represents the name of a declaration in Clang.; Declarations in the C family of languages can take several different forms.; Most declarations are named by simple identifiers, e.g., ""``f``"" and ""``x``"" in; the function declaration ``f(int x)``. In C++, declaration names can also name; class constructors (""``Class``"" in ``struct Class { Class(); }``), class; destructors (""``~Class``""), overloaded operator names (""``operator+``""), and; conversion functions (""``operator void const *``""). In Object",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:68016,Energy Efficiency,allocate,allocated,68016," for these type qualifiers. By storing the type qualifiers as bits in the conceptual pair, it is extremely; efficient to get the set of qualifiers on a ``QualType`` (just return the field; of the pair), add a type qualifier (which is a trivial constant-time operation; that sets a bit), and remove one or more type qualifiers (just return a; ``QualType`` with the bitfield set to empty). Further, because the bits are stored outside of the type itself, we do not need; to create duplicates of types with different sets of qualifiers (i.e. there is; only a single heap allocated ""``int``"" type: ""``const int``"" and ""``volatile; const int``"" both point to the same heap allocated ""``int``"" type). This; reduces the heap size used to represent bits and also means we do not have to; consider qualifiers when uniquing types (:ref:`Type <Type>` does not even; contain qualifiers). In practice, the two most common type qualifiers (``const`` and ``restrict``); are stored in the low bits of the pointer to the ``Type`` object, together with; a flag indicating whether extended qualifiers are present (which must be; heap-allocated). This means that ``QualType`` is exactly the same size as a; pointer. .. _DeclarationName:. Declaration names; -----------------. The ``DeclarationName`` class represents the name of a declaration in Clang.; Declarations in the C family of languages can take several different forms.; Most declarations are named by simple identifiers, e.g., ""``f``"" and ""``x``"" in; the function declaration ``f(int x)``. In C++, declaration names can also name; class constructors (""``Class``"" in ``struct Class { Class(); }``), class; destructors (""``~Class``""), overloaded operator names (""``operator+``""), and; conversion functions (""``operator void const *``""). In Objective-C,; declaration names can refer to the names of Objective-C methods, which involve; the method name and the parameters, collectively called a *selector*, e.g.,; ""``setWidth:height:``"". Since all of these kinds of",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:69115,Energy Efficiency,efficient,efficiently,69115,"p-allocated). This means that ``QualType`` is exactly the same size as a; pointer. .. _DeclarationName:. Declaration names; -----------------. The ``DeclarationName`` class represents the name of a declaration in Clang.; Declarations in the C family of languages can take several different forms.; Most declarations are named by simple identifiers, e.g., ""``f``"" and ""``x``"" in; the function declaration ``f(int x)``. In C++, declaration names can also name; class constructors (""``Class``"" in ``struct Class { Class(); }``), class; destructors (""``~Class``""), overloaded operator names (""``operator+``""), and; conversion functions (""``operator void const *``""). In Objective-C,; declaration names can refer to the names of Objective-C methods, which involve; the method name and the parameters, collectively called a *selector*, e.g.,; ""``setWidth:height:``"". Since all of these kinds of entities --- variables,; functions, Objective-C methods, C++ constructors, destructors, and operators; --- are represented as subclasses of Clang's common ``NamedDecl`` class,; ``DeclarationName`` is designed to efficiently represent any kind of name. Given a ``DeclarationName`` ``N``, ``N.getNameKind()`` will produce a value; that describes what kind of name ``N`` stores. There are 10 options (all of; the names are inside the ``DeclarationName`` class). ``Identifier``. The name is a simple identifier. Use ``N.getAsIdentifierInfo()`` to retrieve; the corresponding ``IdentifierInfo*`` pointing to the actual identifier. ``ObjCZeroArgSelector``, ``ObjCOneArgSelector``, ``ObjCMultiArgSelector``. The name is an Objective-C selector, which can be retrieved as a ``Selector``; instance via ``N.getObjCSelector()``. The three possible name kinds for; Objective-C reflect an optimization within the ``DeclarationName`` class:; both zero- and one-argument selectors are stored as a masked; ``IdentifierInfo`` pointer, and therefore require very little space, since; zero- and one-argument selectors are far more",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:74670,Energy Efficiency,efficient,efficient,74670,"a; declaration context. The source-centric view accurately represents the; program source code as written, including multiple declarations of entities; where present (see the section :ref:`Redeclarations and Overloads; <Redeclarations>`), while the semantics-centric view represents the program; semantics. The two views are kept synchronized by semantic analysis while; the ASTs are being constructed. Storage of declarations within that context. Every declaration context can contain some number of declarations. For; example, a C++ class (represented by ``RecordDecl``) contains various member; functions, fields, nested types, and so on. All of these declarations will; be stored within the ``DeclContext``, and one can iterate over the; declarations via [``DeclContext::decls_begin()``,; ``DeclContext::decls_end()``). This mechanism provides the source-centric; view of declarations in the context. Lookup of declarations within that context. The ``DeclContext`` structure provides efficient name lookup for names within; that declaration context. For example, if ``N`` is a namespace we can look; for the name ``N::f`` using ``DeclContext::lookup``. The lookup itself is; based on a lazily-constructed array (for declaration contexts with a small; number of declarations) or hash table (for declaration contexts with more; declarations). The lookup operation provides the semantics-centric view of; the declarations in the context. Ownership of declarations. The ``DeclContext`` owns all of the declarations that were declared within; its declaration context, and is responsible for the management of their; memory as well as their (de-)serialization. All declarations are stored within a declaration context, and one can query; information about the context in which each declaration lives. One can; retrieve the ``DeclContext`` that contains a particular ``Decl`` using; ``Decl::getDeclContext``. However, see the section; :ref:`LexicalAndSemanticContexts` for more information about how to i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:134672,Energy Efficiency,consumption,consumption,134672,"termining whether an attribute appertains to the subject. For; instance, a ``NonBitField`` SubsetSubject appertains to a ``FieldDecl``, and; tests whether the given FieldDecl is a bit field. When a SubsetSubject is; specified in a SubjectList, a custom diagnostic parameter must also be provided. Diagnostic checking for attribute subject lists for declaration and statement; attributes is automated except when ``HasCustomParsing`` is set to ``1``. Documentation; ~~~~~~~~~~~~~; All attributes must have some form of documentation associated with them.; Documentation is table generated on the public web server by a server-side; process that runs daily. Generally, the documentation for an attribute is a; stand-alone definition in `include/clang/Basic/AttrDocs.td; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/AttrDocs.td>`_; that is named after the attribute being documented. If the attribute is not for public consumption, or is an implicitly-created; attribute that has no visible spelling, the documentation list can specify the; ``InternalOnly`` object. Otherwise, the attribute should have its documentation; added to AttrDocs.td. Documentation derives from the ``Documentation`` tablegen type. All derived; types must specify a documentation category and the actual documentation itself.; Additionally, it can specify a custom heading for the attribute, though a; default heading will be chosen when possible. There are four predefined documentation categories: ``DocCatFunction`` for; attributes that appertain to function-like subjects, ``DocCatVariable`` for; attributes that appertain to variable-like subjects, ``DocCatType`` for type; attributes, and ``DocCatStmt`` for statement attributes. A custom documentation; category should be used for groups of attributes with similar functionality.; Custom categories are good for providing overview information for the attributes; grouped under it. For instance, the consumed annotation attributes define a; c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:148275,Energy Efficiency,allocate,allocate,148275,"ry to instantiate the; templates.; * For each subexpression, be sure to call ``Sema::CheckPlaceholderExpr()``; to deal with ""weird"" expressions that don't behave well as subexpressions.; Then, determine whether you need to perform lvalue-to-rvalue conversions; (``Sema::DefaultLvalueConversions``) or the usual unary conversions; (``Sema::UsualUnaryConversions``), for places where the subexpression is; producing a value you intend to use.; * Your ``BuildXXX`` function will probably just return ``ExprError()`` at; this point, since you don't have an AST. That's perfectly fine, and; shouldn't impact your testing. #. Introduce an AST node for your new expression. This starts with declaring; the node in ``include/Basic/StmtNodes.td`` and creating a new class for your; expression in the appropriate ``include/AST/Expr*.h`` header. It's best to; look at the class for a similar expression to get ideas, and there are some; specific things to watch for:. * If you need to allocate memory, use the ``ASTContext`` allocator to; allocate memory. Never use raw ``malloc`` or ``new``, and never hold any; resources in an AST node, because the destructor of an AST node is never; called.; * Make sure that ``getSourceRange()`` covers the exact source range of your; expression. This is needed for diagnostics and for IDE support.; * Make sure that ``children()`` visits all of the subexpressions. This is; important for a number of features (e.g., IDE support, C++ variadic; templates). If you have sub-types, you'll also need to visit those; sub-types in ``RecursiveASTVisitor``.; * Add printing support (``StmtPrinter.cpp``) for your expression.; * Add profiling support (``StmtProfile.cpp``) for your AST node, noting the; distinguishing (non-source location) characteristics of an instance of; your expression. Omitting this step will lead to hard-to-diagnose; failures regarding matching of template declarations.; * Add serialization support (``ASTReaderStmt.cpp``, ``ASTWriterStmt.cpp``); for your",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:148329,Energy Efficiency,allocate,allocate,148329,"ry to instantiate the; templates.; * For each subexpression, be sure to call ``Sema::CheckPlaceholderExpr()``; to deal with ""weird"" expressions that don't behave well as subexpressions.; Then, determine whether you need to perform lvalue-to-rvalue conversions; (``Sema::DefaultLvalueConversions``) or the usual unary conversions; (``Sema::UsualUnaryConversions``), for places where the subexpression is; producing a value you intend to use.; * Your ``BuildXXX`` function will probably just return ``ExprError()`` at; this point, since you don't have an AST. That's perfectly fine, and; shouldn't impact your testing. #. Introduce an AST node for your new expression. This starts with declaring; the node in ``include/Basic/StmtNodes.td`` and creating a new class for your; expression in the appropriate ``include/AST/Expr*.h`` header. It's best to; look at the class for a similar expression to get ideas, and there are some; specific things to watch for:. * If you need to allocate memory, use the ``ASTContext`` allocator to; allocate memory. Never use raw ``malloc`` or ``new``, and never hold any; resources in an AST node, because the destructor of an AST node is never; called.; * Make sure that ``getSourceRange()`` covers the exact source range of your; expression. This is needed for diagnostics and for IDE support.; * Make sure that ``children()`` visits all of the subexpressions. This is; important for a number of features (e.g., IDE support, C++ variadic; templates). If you have sub-types, you'll also need to visit those; sub-types in ``RecursiveASTVisitor``.; * Add printing support (``StmtPrinter.cpp``) for your expression.; * Add profiling support (``StmtProfile.cpp``) for your AST node, noting the; distinguishing (non-source location) characteristics of an instance of; your expression. Omitting this step will lead to hard-to-diagnose; failures regarding matching of template declarations.; * Add serialization support (``ASTReaderStmt.cpp``, ``ASTWriterStmt.cpp``); for your",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:1715,Integrability,depend,dependencies,1715," libraries and; `data-structures <https://llvm.org/docs/ProgrammersManual.html>`_, including; command line option processing, various containers and a system abstraction; layer, which is used for file system access. The Clang ""Basic"" Library; =========================. This library certainly needs a better name. The ""basic"" library contains a; number of low-level utilities for tracking and manipulating source buffers,; locations within the source buffers, diagnostics, tokens, target abstraction,; and information about the subset of the language being compiled for. Part of this infrastructure is specific to C (such as the ``TargetInfo``; class), other parts could be reused for other non-C-based languages; (``SourceLocation``, ``SourceManager``, ``Diagnostics``, ``FileManager``).; When and if there is future demand we can figure out if it makes sense to; introduce a new library, move the general classes somewhere else, or introduce; some other solution. We describe the roles of these classes in order of their dependencies. The Diagnostics Subsystem; -------------------------. The Clang Diagnostics subsystem is an important part of how the compiler; communicates with the human. Diagnostics are the warnings and errors produced; when the code is incorrect or dubious. In Clang, each diagnostic produced has; (at the minimum) a unique ID, an English translation associated with it, a; :ref:`SourceLocation <SourceLocation>` to ""put the caret"", and a severity; (e.g., ``WARNING`` or ``ERROR``). They can also optionally include a number of; arguments to the diagnostic (which fill in ""%0""'s in the string) as well as a; number of source ranges that related to the diagnostic. In this section, we'll be giving examples produced by the Clang command line; driver, but diagnostics can be :ref:`rendered in many different ways; <DiagnosticConsumer>` depending on how the ``DiagnosticConsumer`` interface is; implemented. A representative example of a diagnostic is:. .. code-block:: text. t.c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:2551,Integrability,depend,depending,2551,"is future demand we can figure out if it makes sense to; introduce a new library, move the general classes somewhere else, or introduce; some other solution. We describe the roles of these classes in order of their dependencies. The Diagnostics Subsystem; -------------------------. The Clang Diagnostics subsystem is an important part of how the compiler; communicates with the human. Diagnostics are the warnings and errors produced; when the code is incorrect or dubious. In Clang, each diagnostic produced has; (at the minimum) a unique ID, an English translation associated with it, a; :ref:`SourceLocation <SourceLocation>` to ""put the caret"", and a severity; (e.g., ``WARNING`` or ``ERROR``). They can also optionally include a number of; arguments to the diagnostic (which fill in ""%0""'s in the string) as well as a; number of source ranges that related to the diagnostic. In this section, we'll be giving examples produced by the Clang command line; driver, but diagnostics can be :ref:`rendered in many different ways; <DiagnosticConsumer>` depending on how the ``DiagnosticConsumer`` interface is; implemented. A representative example of a diagnostic is:. .. code-block:: text. t.c:38:15: error: invalid operands to binary expression ('int *' and '_Complex float'); P = (P-42) + Gamma*4;; ~~~~~~ ^ ~~~~~~~. In this example, you can see the English translation, the severity (error), you; can see the source location (the caret (""``^``"") and file/line/column info),; the source ranges ""``~~~~``"", arguments to the diagnostic (""``int*``"" and; ""``_Complex float``""). You'll have to believe me that there is a unique ID; backing the diagnostic :). Getting all of this to happen has several steps and involves many moving; pieces, this section describes them and talks about best practices when adding; a new diagnostic. The ``Diagnostic*Kinds.td`` files; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Diagnostics are created by adding an entry to one of the; ``clang/Basic/Diagnostic*Kinds.td`` files, de",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:2595,Integrability,interface,interface,2595,"is future demand we can figure out if it makes sense to; introduce a new library, move the general classes somewhere else, or introduce; some other solution. We describe the roles of these classes in order of their dependencies. The Diagnostics Subsystem; -------------------------. The Clang Diagnostics subsystem is an important part of how the compiler; communicates with the human. Diagnostics are the warnings and errors produced; when the code is incorrect or dubious. In Clang, each diagnostic produced has; (at the minimum) a unique ID, an English translation associated with it, a; :ref:`SourceLocation <SourceLocation>` to ""put the caret"", and a severity; (e.g., ``WARNING`` or ``ERROR``). They can also optionally include a number of; arguments to the diagnostic (which fill in ""%0""'s in the string) as well as a; number of source ranges that related to the diagnostic. In this section, we'll be giving examples produced by the Clang command line; driver, but diagnostics can be :ref:`rendered in many different ways; <DiagnosticConsumer>` depending on how the ``DiagnosticConsumer`` interface is; implemented. A representative example of a diagnostic is:. .. code-block:: text. t.c:38:15: error: invalid operands to binary expression ('int *' and '_Complex float'); P = (P-42) + Gamma*4;; ~~~~~~ ^ ~~~~~~~. In this example, you can see the English translation, the severity (error), you; can see the source location (the caret (""``^``"") and file/line/column info),; the source ranges ""``~~~~``"", arguments to the diagnostic (""``int*``"" and; ""``_Complex float``""). You'll have to believe me that there is a unique ID; backing the diagnostic :). Getting all of this to happen has several steps and involves many moving; pieces, this section describes them and talks about best practices when adding; a new diagnostic. The ``Diagnostic*Kinds.td`` files; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Diagnostics are created by adding an entry to one of the; ``clang/Basic/Diagnostic*Kinds.td`` files, de",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:3499,Integrability,depend,depending,3499,"fferent ways; <DiagnosticConsumer>` depending on how the ``DiagnosticConsumer`` interface is; implemented. A representative example of a diagnostic is:. .. code-block:: text. t.c:38:15: error: invalid operands to binary expression ('int *' and '_Complex float'); P = (P-42) + Gamma*4;; ~~~~~~ ^ ~~~~~~~. In this example, you can see the English translation, the severity (error), you; can see the source location (the caret (""``^``"") and file/line/column info),; the source ranges ""``~~~~``"", arguments to the diagnostic (""``int*``"" and; ""``_Complex float``""). You'll have to believe me that there is a unique ID; backing the diagnostic :). Getting all of this to happen has several steps and involves many moving; pieces, this section describes them and talks about best practices when adding; a new diagnostic. The ``Diagnostic*Kinds.td`` files; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Diagnostics are created by adding an entry to one of the; ``clang/Basic/Diagnostic*Kinds.td`` files, depending on what library will be; using it. From this file, :program:`tblgen` generates the unique ID of the; diagnostic, the severity of the diagnostic and the English translation + format; string. There is little sanity with the naming of the unique ID's right now. Some; start with ``err_``, ``warn_``, ``ext_`` to encode the severity into the name.; Since the enum is referenced in the C++ code that produces the diagnostic, it; is somewhat useful for it to be reasonably short. The severity of the diagnostic comes from the set {``NOTE``, ``REMARK``,; ``WARNING``,; ``EXTENSION``, ``EXTWARN``, ``ERROR``}. The ``ERROR`` severity is used for; diagnostics indicating the program is never acceptable under any circumstances.; When an error is emitted, the AST for the input code may not be fully built.; The ``EXTENSION`` and ``EXTWARN`` severities are used for extensions to the; language that Clang accepts. This means that Clang fully understands and can; represent them in the AST, but we produce diagnostics ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:8189,Integrability,wrap,wrapping,8189,"[digit]``"" sequences to specify where and how; arguments to the diagnostic are formatted. Arguments to the diagnostic are numbered according to how they are specified by; the C++ code that :ref:`produces them <internals-producing-diag>`, and are; referenced by ``%0`` .. ``%9``. If you have more than 10 arguments to your; diagnostic, you are doing something wrong :). Unlike ``printf``, there is no; requirement that arguments to the diagnostic end up in the output in the same; order as they are specified, you could have a format string with ""``%1 %0``""; that swaps them, for example. The text in between the percent and digit are; formatting instructions. If there are no instructions, the argument is just; turned into a string and substituted in. Here are some ""best practices"" for writing the English format string:. * Keep the string short. It should ideally fit in the 80 column limit of the; ``DiagnosticKinds.td`` file. This avoids the diagnostic wrapping when; printed, and forces you to think about the important point you are conveying; with the diagnostic.; * Take advantage of location information. The user will be able to see the; line and location of the caret, so you don't need to tell them that the; problem is with the 4th argument to the function: just point to it.; * Do not capitalize the diagnostic string, and do not end it with a period.; * If you need to quote something in the diagnostic string, use single quotes. Diagnostics should never take random English strings as arguments: you; shouldn't use ""``you have a problem with %0``"" and pass in things like ""``your; argument``"" or ""``your return value``"" as arguments. Doing this prevents; :ref:`translating <internals-diag-translation>` the Clang diagnostics to other; languages (because they'll get random English words in their otherwise; localized diagnostic). The exceptions to this are C/C++ language keywords; (e.g., ``auto``, ``const``, ``mutable``, etc) and C/C++ operators (``/=``).; Note that things like ""po",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:15036,Integrability,message,message,15036,"ing ""``+``"". **""objcinstance"" format**. Example:; ``""method %objcinstance0 not found""``; Class:; ``DeclarationName``; Description:; This is a simple formatter that indicates the ``DeclarationName`` corresponds; to an Objective-C instance method selector. As such, it prints the selector; with a leading ""``-``"". **""q"" format**. Example:; ``""candidate found by name lookup is %q0""``; Class:; ``NamedDecl *``; Description:; This formatter indicates that the fully-qualified name of the declaration; should be printed, e.g., ""``std::vector``"" rather than ""``vector``"". **""diff"" format**. Example:; ``""no known conversion %diff{from $ to $|from argument type to parameter type}1,2""``; Class:; ``QualType``; Description:; This formatter takes two ``QualType``\ s and attempts to print a template; difference between the two. If tree printing is off, the text inside the; braces before the pipe is printed, with the formatted text replacing the $.; If tree printing is on, the text after the pipe is printed and a type tree is; printed after the diagnostic message. **""sub"" format**. Example:; Given the following record definition of type ``TextSubstitution``:. .. code-block:: text. def select_ovl_candidate : TextSubstitution<; ""%select{function|constructor}0%select{| template| %2}1"">;. which can be used as. .. code-block:: text. def note_ovl_candidate : Note<; ""candidate %sub{select_ovl_candidate}3,2,1 not viable"">;. and will act as if it was written; ``""candidate %select{function|constructor}3%select{| template| %1}2 not viable""``.; Description:; This format specifier is used to avoid repeating strings verbatim in multiple; diagnostics. The argument to ``%sub`` must name a ``TextSubstitution`` tblgen; record. The substitution must specify all arguments used by the substitution,; and the modifier indexes in the substitution are re-numbered accordingly. The; substituted text must itself be a valid format string before substitution. .. _internals-producing-diag:. Producing the Diagnostic; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:17031,Integrability,interface,interface,17031,"ts the new; diagnostic. Various components of Clang (e.g., the preprocessor, ``Sema``,; etc.) provide a helper function named ""``Diag``"". It creates a diagnostic and; accepts the arguments, ranges, and other information that goes along with it. For example, the binary expression error comes from code like this:. .. code-block:: c++. if (various things that are bad); Diag(Loc, diag::err_typecheck_invalid_operands); << lex->getType() << rex->getType(); << lex->getSourceRange() << rex->getSourceRange();. This shows that use of the ``Diag`` method: it takes a location (a; :ref:`SourceLocation <SourceLocation>` object) and a diagnostic enum value; (which matches the name from ``Diagnostic*Kinds.td``). If the diagnostic takes; arguments, they are specified with the ``<<`` operator: the first argument; becomes ``%0``, the second becomes ``%1``, etc. The diagnostic interface; allows you to specify arguments of many different types, including ``int`` and; ``unsigned`` for integer arguments, ``const char*`` and ``std::string`` for; string arguments, ``DeclarationName`` and ``const IdentifierInfo *`` for names,; ``QualType`` for types, etc. ``SourceRange``\ s are also specified with the; ``<<`` operator, but do not have a specific ordering requirement. As you can see, adding and producing a diagnostic is pretty straightforward.; The hard part is deciding exactly what you need to say to help the user,; picking a suitable wording, and providing the information needed to format it; correctly. The good news is that the call site that issues a diagnostic should; be completely independent of how the diagnostic is formatted and in what; language it is rendered. Fix-It Hints; ^^^^^^^^^^^^. In some cases, the front end emits diagnostics when it is clear that some small; change to the source code would fix the problem. For example, a missing; semicolon at the end of a statement or a use of deprecated syntax that is; easily rewritten into a more modern form. Clang tries very hard to emit ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:21262,Integrability,interface,interface,21262,"diagnostic using the ``<<`` operator in the same way; that highlighted source ranges and arguments are passed to the diagnostic.; Fix-it hints can be created with one of three constructors:. * ``FixItHint::CreateInsertion(Loc, Code)``. Specifies that the given ``Code`` (a string) should be inserted before the; source location ``Loc``. * ``FixItHint::CreateRemoval(Range)``. Specifies that the code in the given source ``Range`` should be removed. * ``FixItHint::CreateReplacement(Range, Code)``. Specifies that the code in the given source ``Range`` should be removed,; and replaced with the given ``Code`` string. .. _DiagnosticConsumer:. The ``DiagnosticConsumer`` Interface; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Once code generates a diagnostic with all of the arguments and the rest of the; relevant information, Clang needs to know what to do with it. As previously; mentioned, the diagnostic machinery goes through some filtering to map a; severity onto a diagnostic level, then (assuming the diagnostic is not mapped; to ""``Ignore``"") it invokes an object that implements the ``DiagnosticConsumer``; interface with the information. It is possible to implement this interface in many different ways. For; example, the normal Clang ``DiagnosticConsumer`` (named; ``TextDiagnosticPrinter``) turns the arguments into strings (according to the; various formatting rules), prints out the file/line/column information and the; string, then prints out the line of code, the source ranges, and the caret.; However, this behavior isn't required. Another implementation of the ``DiagnosticConsumer`` interface is the; ``TextDiagnosticBuffer`` class, which is used when Clang is in ``-verify``; mode. Instead of formatting and printing out the diagnostics, this; implementation just captures and remembers the diagnostics as they fly by.; Then ``-verify`` compares the list of produced diagnostics to the list of; expected ones. If they disagree, it prints out its own output. Full; documentation for t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:21327,Integrability,interface,interface,21327,"e constructors:. * ``FixItHint::CreateInsertion(Loc, Code)``. Specifies that the given ``Code`` (a string) should be inserted before the; source location ``Loc``. * ``FixItHint::CreateRemoval(Range)``. Specifies that the code in the given source ``Range`` should be removed. * ``FixItHint::CreateReplacement(Range, Code)``. Specifies that the code in the given source ``Range`` should be removed,; and replaced with the given ``Code`` string. .. _DiagnosticConsumer:. The ``DiagnosticConsumer`` Interface; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Once code generates a diagnostic with all of the arguments and the rest of the; relevant information, Clang needs to know what to do with it. As previously; mentioned, the diagnostic machinery goes through some filtering to map a; severity onto a diagnostic level, then (assuming the diagnostic is not mapped; to ""``Ignore``"") it invokes an object that implements the ``DiagnosticConsumer``; interface with the information. It is possible to implement this interface in many different ways. For; example, the normal Clang ``DiagnosticConsumer`` (named; ``TextDiagnosticPrinter``) turns the arguments into strings (according to the; various formatting rules), prints out the file/line/column information and the; string, then prints out the line of code, the source ranges, and the caret.; However, this behavior isn't required. Another implementation of the ``DiagnosticConsumer`` interface is the; ``TextDiagnosticBuffer`` class, which is used when Clang is in ``-verify``; mode. Instead of formatting and printing out the diagnostics, this; implementation just captures and remembers the diagnostics as they fly by.; Then ``-verify`` compares the list of produced diagnostics to the list of; expected ones. If they disagree, it prints out its own output. Full; documentation for the ``-verify`` mode can be found at; :ref:`verifying-diagnostics`. There are many other possible implementations of this interface, and this is; why we prefer diagnostics to p",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:21751,Integrability,interface,interface,21751,"DiagnosticConsumer:. The ``DiagnosticConsumer`` Interface; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Once code generates a diagnostic with all of the arguments and the rest of the; relevant information, Clang needs to know what to do with it. As previously; mentioned, the diagnostic machinery goes through some filtering to map a; severity onto a diagnostic level, then (assuming the diagnostic is not mapped; to ""``Ignore``"") it invokes an object that implements the ``DiagnosticConsumer``; interface with the information. It is possible to implement this interface in many different ways. For; example, the normal Clang ``DiagnosticConsumer`` (named; ``TextDiagnosticPrinter``) turns the arguments into strings (according to the; various formatting rules), prints out the file/line/column information and the; string, then prints out the line of code, the source ranges, and the caret.; However, this behavior isn't required. Another implementation of the ``DiagnosticConsumer`` interface is the; ``TextDiagnosticBuffer`` class, which is used when Clang is in ``-verify``; mode. Instead of formatting and printing out the diagnostics, this; implementation just captures and remembers the diagnostics as they fly by.; Then ``-verify`` compares the list of produced diagnostics to the list of; expected ones. If they disagree, it prints out its own output. Full; documentation for the ``-verify`` mode can be found at; :ref:`verifying-diagnostics`. There are many other possible implementations of this interface, and this is; why we prefer diagnostics to pass down rich structured information in; arguments. For example, an HTML output might want declaration names be; linkified to where they come from in the source. Another example is that a GUI; might let you click on typedefs to expand them. This application would want to; pass significantly more information about types through to the GUI than a; simple flat string. The interface allows this to happen. .. _internals-diag-translation:. Adding Tr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:22273,Integrability,interface,interface,22273,"s possible to implement this interface in many different ways. For; example, the normal Clang ``DiagnosticConsumer`` (named; ``TextDiagnosticPrinter``) turns the arguments into strings (according to the; various formatting rules), prints out the file/line/column information and the; string, then prints out the line of code, the source ranges, and the caret.; However, this behavior isn't required. Another implementation of the ``DiagnosticConsumer`` interface is the; ``TextDiagnosticBuffer`` class, which is used when Clang is in ``-verify``; mode. Instead of formatting and printing out the diagnostics, this; implementation just captures and remembers the diagnostics as they fly by.; Then ``-verify`` compares the list of produced diagnostics to the list of; expected ones. If they disagree, it prints out its own output. Full; documentation for the ``-verify`` mode can be found at; :ref:`verifying-diagnostics`. There are many other possible implementations of this interface, and this is; why we prefer diagnostics to pass down rich structured information in; arguments. For example, an HTML output might want declaration names be; linkified to where they come from in the source. Another example is that a GUI; might let you click on typedefs to expand them. This application would want to; pass significantly more information about types through to the GUI than a; simple flat string. The interface allows this to happen. .. _internals-diag-translation:. Adding Translations to Clang; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Not possible yet! Diagnostic strings should be written in UTF-8, the client can; translate to the relevant code page if needed. Each translation completely; replaces the format string for the diagnostic. .. _SourceLocation:; .. _SourceManager:. The ``SourceLocation`` and ``SourceManager`` classes; ----------------------------------------------------. Strangely enough, the ``SourceLocation`` class represents a location within the; source code of the program. Important d",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:22699,Integrability,interface,interface,22699,"entation of the ``DiagnosticConsumer`` interface is the; ``TextDiagnosticBuffer`` class, which is used when Clang is in ``-verify``; mode. Instead of formatting and printing out the diagnostics, this; implementation just captures and remembers the diagnostics as they fly by.; Then ``-verify`` compares the list of produced diagnostics to the list of; expected ones. If they disagree, it prints out its own output. Full; documentation for the ``-verify`` mode can be found at; :ref:`verifying-diagnostics`. There are many other possible implementations of this interface, and this is; why we prefer diagnostics to pass down rich structured information in; arguments. For example, an HTML output might want declaration names be; linkified to where they come from in the source. Another example is that a GUI; might let you click on typedefs to expand them. This application would want to; pass significantly more information about types through to the GUI than a; simple flat string. The interface allows this to happen. .. _internals-diag-translation:. Adding Translations to Clang; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Not possible yet! Diagnostic strings should be written in UTF-8, the client can; translate to the relevant code page if needed. Each translation completely; replaces the format string for the diagnostic. .. _SourceLocation:; .. _SourceManager:. The ``SourceLocation`` and ``SourceManager`` classes; ----------------------------------------------------. Strangely enough, the ``SourceLocation`` class represents a location within the; source code of the program. Important design points include:. #. ``sizeof(SourceLocation)`` must be extremely small, as these are embedded; into many AST nodes and are passed around often. Currently it is 32 bits.; #. ``SourceLocation`` must be a simple value object that can be efficiently; copied.; #. We should be able to represent a source location for any byte of any input; file. This includes in the middle of tokens, in whitespace, in trigraphs,;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:24744,Integrability,depend,depends,24744,"e current ``#include`` stack that was; active when the location was processed. For example, if the location; corresponds to a token, it should contain the set of ``#include``\ s active; when the token was lexed. This allows us to print the ``#include`` stack; for a diagnostic.; #. ``SourceLocation`` must be able to describe macro expansions, capturing both; the ultimate instantiation point and the source of the original character; data. In practice, the ``SourceLocation`` works together with the ``SourceManager``; class to encode two pieces of information about a location: its spelling; location and its expansion location. For most tokens, these will be the; same. However, for a macro expansion (or tokens that came from a ``_Pragma``; directive) these will describe the location of the characters corresponding to; the token and the location where the token was used (i.e., the macro; expansion point or the location of the ``_Pragma`` itself). The Clang front-end inherently depends on the location of a token being tracked; correctly. If it is ever incorrect, the front-end may get confused and die.; The reason for this is that the notion of the ""spelling"" of a ``Token`` in; Clang depends on being able to find the original input characters for the; token. This concept maps directly to the ""spelling location"" for the token. ``SourceRange`` and ``CharSourceRange``; ---------------------------------------. .. mostly taken from https://discourse.llvm.org/t/code-ranges-of-tokens-ast-elements/16893/2. Clang represents most source ranges by [first, last], where ""first"" and ""last""; each point to the beginning of their respective tokens. For example consider; the ``SourceRange`` of the following statement:. .. code-block:: text. x = foo + bar;; ^first ^last. To map from this representation to a character-based representation, the ""last""; location needs to be adjusted to point to (or past) the end of that token with; either ``Lexer::MeasureTokenLength()`` or ``Lexer::getLocForEndO",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:24953,Integrability,depend,depends,24953," the token was lexed. This allows us to print the ``#include`` stack; for a diagnostic.; #. ``SourceLocation`` must be able to describe macro expansions, capturing both; the ultimate instantiation point and the source of the original character; data. In practice, the ``SourceLocation`` works together with the ``SourceManager``; class to encode two pieces of information about a location: its spelling; location and its expansion location. For most tokens, these will be the; same. However, for a macro expansion (or tokens that came from a ``_Pragma``; directive) these will describe the location of the characters corresponding to; the token and the location where the token was used (i.e., the macro; expansion point or the location of the ``_Pragma`` itself). The Clang front-end inherently depends on the location of a token being tracked; correctly. If it is ever incorrect, the front-end may get confused and die.; The reason for this is that the notion of the ""spelling"" of a ``Token`` in; Clang depends on being able to find the original input characters for the; token. This concept maps directly to the ""spelling location"" for the token. ``SourceRange`` and ``CharSourceRange``; ---------------------------------------. .. mostly taken from https://discourse.llvm.org/t/code-ranges-of-tokens-ast-elements/16893/2. Clang represents most source ranges by [first, last], where ""first"" and ""last""; each point to the beginning of their respective tokens. For example consider; the ``SourceRange`` of the following statement:. .. code-block:: text. x = foo + bar;; ^first ^last. To map from this representation to a character-based representation, the ""last""; location needs to be adjusted to point to (or past) the end of that token with; either ``Lexer::MeasureTokenLength()`` or ``Lexer::getLocForEndOfToken()``. For; the rare cases where character-level source ranges information is needed we use; the ``CharSourceRange`` class. The Driver Library; ==================. The clang Driver and l",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:27058,Integrability,interface,interface,27058,">`), which uses a; serialized representation of Clang's internal data structures, encoded with the; `LLVM bitstream format <https://llvm.org/docs/BitCodeFormat.html>`_. The Frontend Library; ====================. The Frontend library contains functionality useful for building tools on top of; the Clang libraries, for example several methods for outputting diagnostics. Compiler Invocation; -------------------. One of the classes provided by the Frontend library is ``CompilerInvocation``,; which holds information that describe current invocation of the Clang ``-cc1``; frontend. The information typically comes from the command line constructed by; the Clang driver or from clients performing custom initialization. The data; structure is split into logical units used by different parts of the compiler,; for example ``PreprocessorOptions``, ``LanguageOptions`` or ``CodeGenOptions``. Command Line Interface; ----------------------. The command line interface of the Clang ``-cc1`` frontend is defined alongside; the driver options in ``clang/Driver/Options.td``. The information making up an; option definition includes its prefix and name (for example ``-std=``), form and; position of the option value, help text, aliases and more. Each option may; belong to a certain group and can be marked with zero or more flags. Options; accepted by the ``-cc1`` frontend are marked with the ``CC1Option`` flag. Command Line Parsing; --------------------. Option definitions are processed by the ``-gen-opt-parser-defs`` tablegen; backend during early stages of the build. Options are then used for querying an; instance ``llvm::opt::ArgList``, a wrapper around the command line arguments.; This is done in the Clang driver to construct individual jobs based on the; driver arguments and also in the ``CompilerInvocation::CreateFromArgs`` function; that parses the ``-cc1`` frontend arguments. Command Line Generation; -----------------------. Any valid ``CompilerInvocation`` created from a ``-cc1`` co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:27747,Integrability,wrap,wrapper,27747,"mand line constructed by; the Clang driver or from clients performing custom initialization. The data; structure is split into logical units used by different parts of the compiler,; for example ``PreprocessorOptions``, ``LanguageOptions`` or ``CodeGenOptions``. Command Line Interface; ----------------------. The command line interface of the Clang ``-cc1`` frontend is defined alongside; the driver options in ``clang/Driver/Options.td``. The information making up an; option definition includes its prefix and name (for example ``-std=``), form and; position of the option value, help text, aliases and more. Each option may; belong to a certain group and can be marked with zero or more flags. Options; accepted by the ``-cc1`` frontend are marked with the ``CC1Option`` flag. Command Line Parsing; --------------------. Option definitions are processed by the ``-gen-opt-parser-defs`` tablegen; backend during early stages of the build. Options are then used for querying an; instance ``llvm::opt::ArgList``, a wrapper around the command line arguments.; This is done in the Clang driver to construct individual jobs based on the; driver arguments and also in the ``CompilerInvocation::CreateFromArgs`` function; that parses the ``-cc1`` frontend arguments. Command Line Generation; -----------------------. Any valid ``CompilerInvocation`` created from a ``-cc1`` command line can be; also serialized back into semantically equivalent command line in a; deterministic manner. This enables features such as implicitly discovered,; explicitly built modules. ..; TODO: Create and link corresponding section in Modules.rst. Adding new Command Line Option; ------------------------------. When adding a new command line option, the first place of interest is the header; file declaring the corresponding options class (e.g. ``CodeGenOptions.h`` for; command line option that affects the code generation). Create new member; variable for the option value:. .. code-block:: diff. class CodeGenOptions ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:28910,Integrability,interface,interface,28910,"s`` function; that parses the ``-cc1`` frontend arguments. Command Line Generation; -----------------------. Any valid ``CompilerInvocation`` created from a ``-cc1`` command line can be; also serialized back into semantically equivalent command line in a; deterministic manner. This enables features such as implicitly discovered,; explicitly built modules. ..; TODO: Create and link corresponding section in Modules.rst. Adding new Command Line Option; ------------------------------. When adding a new command line option, the first place of interest is the header; file declaring the corresponding options class (e.g. ``CodeGenOptions.h`` for; command line option that affects the code generation). Create new member; variable for the option value:. .. code-block:: diff. class CodeGenOptions : public CodeGenOptionsBase {. + /// List of dynamic shared object files to be loaded as pass plugins.; + std::vector<std::string> PassPlugins;. }. Next, declare the command line interface of the option in the tablegen file; ``clang/include/clang/Driver/Options.td``. This is done by instantiating the; ``Option`` class (defined in ``llvm/include/llvm/Option/OptParser.td``). The; instance is typically created through one of the helper classes that encode the; acceptable ways to specify the option value on the command line:. * ``Flag`` - the option does not accept any value,; * ``Joined`` - the value must immediately follow the option name within the same; argument,; * ``Separate`` - the value must follow the option name in the next command line; argument,; * ``JoinedOrSeparate`` - the value can be specified either as ``Joined`` or; ``Separate``,; * ``CommaJoined`` - the values are comma-separated and must immediately follow; the option name within the same argument (see ``Wl,`` for an example). The helper classes take a list of acceptable prefixes of the option (e.g.; ``""-""``, ``""--""`` or ``""/""``) and the option name:. .. code-block:: diff. // Options.td. + def fpass_plugin_EQ : Joined<[""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:32748,Integrability,interface,interface,32748,"hat initializes/serializes the option class (in our case; ``CodeGenOptions``) stored within ``CompilerInvocation``. This can be done; automatically by using the marshalling annotations on the option definition:. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; Group<f_Group>, Flags<[CC1Option]>,; HelpText<""Load pass plugin from a dynamic shared object file."">,; + MarshallingInfoStringVector<CodeGenOpts<""PassPlugins"">>;. Inner workings of the system are introduced in the :ref:`marshalling; infrastructure <OptionMarshalling>` section and the available annotations are; listed :ref:`here <OptionMarshallingAnnotations>`. In case the marshalling infrastructure does not support the desired semantics,; consider simplifying it to fit the existing model. This makes the command line; more uniform and reduces the amount of custom, manually written code. Remember; that the ``-cc1`` command line interface is intended only for Clang developers,; meaning it does not need to mirror the driver interface, maintain backward; compatibility or be compatible with GCC. If the option semantics cannot be encoded via marshalling annotations, you can; resort to parsing/serializing the command line arguments manually:. .. code-block:: diff. // CompilerInvocation.cpp. static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args /*...*/) {; // ... + Opts.PassPlugins = Args.getAllArgValues(OPT_fpass_plugin_EQ);; }. static void GenerateCodeGenArgs(const CodeGenOptions &Opts,; SmallVectorImpl<const char *> &Args,; CompilerInvocation::StringAllocator SA /*...*/) {; // ... + for (const std::string &PassPlugin : Opts.PassPlugins); + GenerateArg(Args, OPT_fpass_plugin_EQ, PassPlugin, SA);; }. Finally, you can specify the argument on the command line:; ``clang -fpass-plugin=a -fpass-plugin=b`` and use the new member variable as; desired. .. code-block:: diff. void EmitAssemblyHelper::EmitAssemblyWithNewPassManager(/*...*/) {; // ...; + for (auto &PluginFN : ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:32844,Integrability,interface,interface,32844,"hat initializes/serializes the option class (in our case; ``CodeGenOptions``) stored within ``CompilerInvocation``. This can be done; automatically by using the marshalling annotations on the option definition:. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; Group<f_Group>, Flags<[CC1Option]>,; HelpText<""Load pass plugin from a dynamic shared object file."">,; + MarshallingInfoStringVector<CodeGenOpts<""PassPlugins"">>;. Inner workings of the system are introduced in the :ref:`marshalling; infrastructure <OptionMarshalling>` section and the available annotations are; listed :ref:`here <OptionMarshallingAnnotations>`. In case the marshalling infrastructure does not support the desired semantics,; consider simplifying it to fit the existing model. This makes the command line; more uniform and reduces the amount of custom, manually written code. Remember; that the ``-cc1`` command line interface is intended only for Clang developers,; meaning it does not need to mirror the driver interface, maintain backward; compatibility or be compatible with GCC. If the option semantics cannot be encoded via marshalling annotations, you can; resort to parsing/serializing the command line arguments manually:. .. code-block:: diff. // CompilerInvocation.cpp. static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args /*...*/) {; // ... + Opts.PassPlugins = Args.getAllArgValues(OPT_fpass_plugin_EQ);; }. static void GenerateCodeGenArgs(const CodeGenOptions &Opts,; SmallVectorImpl<const char *> &Args,; CompilerInvocation::StringAllocator SA /*...*/) {; // ... + for (const std::string &PassPlugin : Opts.PassPlugins); + GenerateArg(Args, OPT_fpass_plugin_EQ, PassPlugin, SA);; }. Finally, you can specify the argument on the command line:; ``clang -fpass-plugin=a -fpass-plugin=b`` and use the new member variable as; desired. .. code-block:: diff. void EmitAssemblyHelper::EmitAssemblyWithNewPassManager(/*...*/) {; // ...; + for (auto &PluginFN : ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:34391,Integrability,interface,interface,34391,"ns &Opts,; SmallVectorImpl<const char *> &Args,; CompilerInvocation::StringAllocator SA /*...*/) {; // ... + for (const std::string &PassPlugin : Opts.PassPlugins); + GenerateArg(Args, OPT_fpass_plugin_EQ, PassPlugin, SA);; }. Finally, you can specify the argument on the command line:; ``clang -fpass-plugin=a -fpass-plugin=b`` and use the new member variable as; desired. .. code-block:: diff. void EmitAssemblyHelper::EmitAssemblyWithNewPassManager(/*...*/) {; // ...; + for (auto &PluginFN : CodeGenOpts.PassPlugins); + if (auto PassPlugin = PassPlugin::Load(PluginFN)); + PassPlugin->registerPassBuilderCallbacks(PB);; }. .. _OptionMarshalling:. Option Marshalling Infrastructure; ---------------------------------. The option marshalling infrastructure automates the parsing of the Clang; ``-cc1`` frontend command line arguments into ``CompilerInvocation`` and their; generation from ``CompilerInvocation``. The system replaces lots of repetitive; C++ code with simple, declarative tablegen annotations and it's being used for; the majority of the ``-cc1`` command line interface. This section provides an; overview of the system. **Note:** The marshalling infrastructure is not intended for driver-only; options. Only options of the ``-cc1`` frontend need to be marshalled to/from; ``CompilerInvocation`` instance. To read and modify contents of ``CompilerInvocation``, the marshalling system; uses key paths, which are declared in two steps. First, a tablegen definition; for the ``CompilerInvocation`` member is created by inheriting from; ``KeyPathAndMacro``:. .. code-block:: text. // Options.td. class LangOpts<string field> : KeyPathAndMacro<""LangOpts->"", field, ""LANG_""> {}; // CompilerInvocation member ^^^^^^^^^^; // OPTION_WITH_MARSHALLING prefix ^^^^^. The first argument to the parent class is the beginning of the key path that; references the ``CompilerInvocation`` member. This argument ends with ``->`` if; the member is a pointer type or with ``.`` if it's a value type. The c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:43948,Integrability,interface,interface,43948," elements of ``ImpliedByAnyOf`` evaluate to true,; the key path value is changed to the specified value or ``true`` if missing.; Finally, the command line is parsed according to the primary annotation. .. code-block:: text. def fms_extensions : Flag<[""-""], ""fms-extensions"">,; Visibility<[ClangOption, CC1Option]>,; MarshallingInfoFlag<LangOpts<""MicrosoftExt"">>,; ImpliedByAnyOf<[fms_compatibility.KeyPath], ""true"">;. **Condition**. The option is parsed only if the expression in ``ShouldParseIf`` evaluates to; true. .. code-block:: text. def fopenmp_enable_irbuilder : Flag<[""-""], ""fopenmp-enable-irbuilder"">,; Visibility<[ClangOption, CC1Option]>,; MarshallingInfoFlag<LangOpts<""OpenMPIRBuilder"">>,; ShouldParseIf<fopenmp.KeyPath>;. The Lexer and Preprocessor Library; ==================================. The Lexer library contains several tightly-connected classes that are involved; with the nasty process of lexing and preprocessing C source code. The main; interface to this library for outside clients is the large ``Preprocessor``; class. It contains the various pieces of state that are required to coherently; read tokens out of a translation unit. The core interface to the ``Preprocessor`` object (once it is set up) is the; ``Preprocessor::Lex`` method, which returns the next :ref:`Token <Token>` from; the preprocessor stream. There are two types of token providers that the; preprocessor is capable of reading from: a buffer lexer (provided by the; :ref:`Lexer <Lexer>` class) and a buffered token stream (provided by the; :ref:`TokenLexer <TokenLexer>` class). .. _Token:. The Token class; ---------------. The ``Token`` class is used to represent a single lexed token. Tokens are; intended to be used by the lexer/preprocess and parser libraries, but are not; intended to live beyond them (for example, they should not live in the ASTs). Tokens most often live on the stack (or some other location that is efficient; to access) as the parser is running, but occasionally do get buf",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:44153,Integrability,interface,interface,44153,"[""-""], ""fms-extensions"">,; Visibility<[ClangOption, CC1Option]>,; MarshallingInfoFlag<LangOpts<""MicrosoftExt"">>,; ImpliedByAnyOf<[fms_compatibility.KeyPath], ""true"">;. **Condition**. The option is parsed only if the expression in ``ShouldParseIf`` evaluates to; true. .. code-block:: text. def fopenmp_enable_irbuilder : Flag<[""-""], ""fopenmp-enable-irbuilder"">,; Visibility<[ClangOption, CC1Option]>,; MarshallingInfoFlag<LangOpts<""OpenMPIRBuilder"">>,; ShouldParseIf<fopenmp.KeyPath>;. The Lexer and Preprocessor Library; ==================================. The Lexer library contains several tightly-connected classes that are involved; with the nasty process of lexing and preprocessing C source code. The main; interface to this library for outside clients is the large ``Preprocessor``; class. It contains the various pieces of state that are required to coherently; read tokens out of a translation unit. The core interface to the ``Preprocessor`` object (once it is set up) is the; ``Preprocessor::Lex`` method, which returns the next :ref:`Token <Token>` from; the preprocessor stream. There are two types of token providers that the; preprocessor is capable of reading from: a buffer lexer (provided by the; :ref:`Lexer <Lexer>` class) and a buffered token stream (provided by the; :ref:`TokenLexer <TokenLexer>` class). .. _Token:. The Token class; ---------------. The ``Token`` class is used to represent a single lexed token. Tokens are; intended to be used by the lexer/preprocess and parser libraries, but are not; intended to live beyond them (for example, they should not live in the ASTs). Tokens most often live on the stack (or some other location that is efficient; to access) as the parser is running, but occasionally do get buffered up. For; example, macro definitions are stored as a series of tokens, and the C++; front-end periodically needs to buffer tokens up for tentative parsing and; various pieces of look-ahead. As such, the size of a ``Token`` matters. On a; 32-bit s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:48887,Integrability,inject,injected,48887,"lling for the; token includes a trigraph or escaped newline. Since this is uncommon,; many pieces of code can fast-path on tokens that did not need cleaning. One interesting (and somewhat unusual) aspect of normal tokens is that they; don't contain any semantic information about the lexed value. For example, if; the token was a pp-number token, we do not represent the value of the number; that was lexed (this is left for later pieces of code to decide).; Additionally, the lexer library has no notion of typedef names vs variable; names: both are returned as identifiers, and the parser is left to decide; whether a specific identifier is a typedef or a variable (tracking this; requires scope information among other things). The parser can do this; translation by replacing tokens returned by the preprocessor with ""Annotation; Tokens"". .. _AnnotationToken:. Annotation Tokens; -----------------. Annotation tokens are tokens that are synthesized by the parser and injected; into the preprocessor's token stream (replacing existing tokens) to record; semantic information found by the parser. For example, if ""``foo``"" is found; to be a typedef, the ""``foo``"" ``tok::identifier`` token is replaced with an; ``tok::annot_typename``. This is useful for a couple of reasons: 1) this makes; it easy to handle qualified type names (e.g., ""``foo::bar::baz<42>::t``"") in; C++ as a single ""token"" in the parser. 2) if the parser backtracks, the; reparse does not need to redo semantic analysis to determine whether a token; sequence is a variable, type, template, etc. Annotation tokens are created by the parser and reinjected into the parser's; token stream (when backtracking is enabled). Because they can only exist in; tokens that the preprocessor-proper is done with, it doesn't need to keep; around flags like ""start of line"" that the preprocessor uses to do its job.; Additionally, an annotation token may ""cover"" a sequence of preprocessor tokens; (e.g., ""``a::b::c``"" is five preprocessor tok",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:57028,Integrability,interface,interface,57028," expanded 2) returning; tokens from an arbitrary buffer of tokens. The later use is used by; ``_Pragma`` and will most likely be used to handle unbounded look-ahead for the; C++ parser. .. _MultipleIncludeOpt:. The ``MultipleIncludeOpt`` class; --------------------------------. The ``MultipleIncludeOpt`` class implements a really simple little state; machine that is used to detect the standard ""``#ifndef XX`` / ``#define XX``""; idiom that people typically use to prevent multiple inclusion of headers. If a; buffer uses this idiom and is subsequently ``#include``'d, the preprocessor can; simply check to see whether the guarding condition is defined or not. If so,; the preprocessor can completely ignore the include of the header. .. _Parser:. The Parser Library; ==================. This library contains a recursive-descent parser that polls tokens from the; preprocessor and notifies a client of the parsing progress. Historically, the parser used to talk to an abstract ``Action`` interface that; had virtual methods for parse events, for example ``ActOnBinOp()``. When Clang; grew C++ support, the parser stopped supporting general ``Action`` clients --; it now always talks to the :ref:`Sema library <Sema>`. However, the Parser; still accesses AST objects only through opaque types like ``ExprResult`` and; ``StmtResult``. Only :ref:`Sema <Sema>` looks at the AST node contents of these; wrappers. .. _AST:. The AST Library; ===============. .. _ASTPhilosophy:. Design philosophy; -----------------. Immutability; ^^^^^^^^^^^^. Clang AST nodes (types, declarations, statements, expressions, and so on) are; generally designed to be immutable once created. This provides a number of key; benefits:. * Canonicalization of the ""meaning"" of nodes is possible as soon as the nodes; are created, and is not invalidated by later addition of more information.; For example, we :ref:`canonicalize types <CanonicalType>`, and use a; canonicalized representation of expressions when determining whe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:57438,Integrability,wrap,wrappers,57438,"d to detect the standard ""``#ifndef XX`` / ``#define XX``""; idiom that people typically use to prevent multiple inclusion of headers. If a; buffer uses this idiom and is subsequently ``#include``'d, the preprocessor can; simply check to see whether the guarding condition is defined or not. If so,; the preprocessor can completely ignore the include of the header. .. _Parser:. The Parser Library; ==================. This library contains a recursive-descent parser that polls tokens from the; preprocessor and notifies a client of the parsing progress. Historically, the parser used to talk to an abstract ``Action`` interface that; had virtual methods for parse events, for example ``ActOnBinOp()``. When Clang; grew C++ support, the parser stopped supporting general ``Action`` clients --; it now always talks to the :ref:`Sema library <Sema>`. However, the Parser; still accesses AST objects only through opaque types like ``ExprResult`` and; ``StmtResult``. Only :ref:`Sema <Sema>` looks at the AST node contents of these; wrappers. .. _AST:. The AST Library; ===============. .. _ASTPhilosophy:. Design philosophy; -----------------. Immutability; ^^^^^^^^^^^^. Clang AST nodes (types, declarations, statements, expressions, and so on) are; generally designed to be immutable once created. This provides a number of key; benefits:. * Canonicalization of the ""meaning"" of nodes is possible as soon as the nodes; are created, and is not invalidated by later addition of more information.; For example, we :ref:`canonicalize types <CanonicalType>`, and use a; canonicalized representation of expressions when determining whether two; function template declarations involving dependent expressions declare the; same entity.; * AST nodes can be reused when they have the same meaning. For example, we; reuse ``Type`` nodes when representing the same type (but maintain separate; ``TypeLoc``\s for each instance where a type is written), and we reuse; non-dependent ``Stmt`` and ``Expr`` nodes across",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:58088,Integrability,depend,dependent,58088,"`Action`` interface that; had virtual methods for parse events, for example ``ActOnBinOp()``. When Clang; grew C++ support, the parser stopped supporting general ``Action`` clients --; it now always talks to the :ref:`Sema library <Sema>`. However, the Parser; still accesses AST objects only through opaque types like ``ExprResult`` and; ``StmtResult``. Only :ref:`Sema <Sema>` looks at the AST node contents of these; wrappers. .. _AST:. The AST Library; ===============. .. _ASTPhilosophy:. Design philosophy; -----------------. Immutability; ^^^^^^^^^^^^. Clang AST nodes (types, declarations, statements, expressions, and so on) are; generally designed to be immutable once created. This provides a number of key; benefits:. * Canonicalization of the ""meaning"" of nodes is possible as soon as the nodes; are created, and is not invalidated by later addition of more information.; For example, we :ref:`canonicalize types <CanonicalType>`, and use a; canonicalized representation of expressions when determining whether two; function template declarations involving dependent expressions declare the; same entity.; * AST nodes can be reused when they have the same meaning. For example, we; reuse ``Type`` nodes when representing the same type (but maintain separate; ``TypeLoc``\s for each instance where a type is written), and we reuse; non-dependent ``Stmt`` and ``Expr`` nodes across instantiations of a; template.; * Serialization and deserialization of the AST to/from AST files is simpler:; we do not need to track modifications made to AST nodes imported from AST; files and serialize separate ""update records"". There are unfortunately exceptions to this general approach, such as:. * The first declaration of a redeclarable entity maintains a pointer to the; most recent declaration of that entity, which naturally needs to change as; more declarations are parsed.; * Name lookup tables in declaration contexts change after the namespace; declaration is formed.; * We attempt to maintai",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:58366,Integrability,depend,dependent,58366," opaque types like ``ExprResult`` and; ``StmtResult``. Only :ref:`Sema <Sema>` looks at the AST node contents of these; wrappers. .. _AST:. The AST Library; ===============. .. _ASTPhilosophy:. Design philosophy; -----------------. Immutability; ^^^^^^^^^^^^. Clang AST nodes (types, declarations, statements, expressions, and so on) are; generally designed to be immutable once created. This provides a number of key; benefits:. * Canonicalization of the ""meaning"" of nodes is possible as soon as the nodes; are created, and is not invalidated by later addition of more information.; For example, we :ref:`canonicalize types <CanonicalType>`, and use a; canonicalized representation of expressions when determining whether two; function template declarations involving dependent expressions declare the; same entity.; * AST nodes can be reused when they have the same meaning. For example, we; reuse ``Type`` nodes when representing the same type (but maintain separate; ``TypeLoc``\s for each instance where a type is written), and we reuse; non-dependent ``Stmt`` and ``Expr`` nodes across instantiations of a; template.; * Serialization and deserialization of the AST to/from AST files is simpler:; we do not need to track modifications made to AST nodes imported from AST; files and serialize separate ""update records"". There are unfortunately exceptions to this general approach, such as:. * The first declaration of a redeclarable entity maintains a pointer to the; most recent declaration of that entity, which naturally needs to change as; more declarations are parsed.; * Name lookup tables in declaration contexts change after the namespace; declaration is formed.; * We attempt to maintain only a single declaration for an instantiation of a; template, rather than having distinct declarations for an instantiation of; the declaration versus the definition, so template instantiation often; updates parts of existing declarations.; * Some parts of declarations are required to be instanti",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:60361,Integrability,wrap,wrap,60361,"ations are required to be instantiated separately (this; includes default arguments and exception specifications), and such; instantiations update the existing declaration. These cases tend to be fragile; mutable AST state should be avoided where; possible. As a consequence of this design principle, we typically do not provide setters; for AST state. (Some are provided for short-term modifications intended to be; used immediately after an AST node is created and before it's ""published"" as; part of the complete AST, or where language semantics require after-the-fact; updates.). Faithfulness; ^^^^^^^^^^^^. The AST intends to provide a representation of the program that is faithful to; the original source. We intend for it to be possible to write refactoring tools; using only information stored in, or easily reconstructible from, the Clang AST.; This means that the AST representation should either not desugar source-level; constructs to simpler forms, or -- where made necessary by language semantics; or a clear engineering tradeoff -- should desugar minimally and wrap the result; in a construct representing the original source form. For example, ``CXXForRangeStmt`` directly represents the syntactic form of a; range-based for statement, but also holds a semantic representation of the; range declaration and iterator declarations. It does not contain a; fully-desugared ``ForStmt``, however. Some AST nodes (for example, ``ParenExpr``) represent only syntax, and others; (for example, ``ImplicitCastExpr``) represent only semantics, but most nodes; will represent a combination of syntax and associated semantics. Inheritance; is typically used when representing different (but related) syntaxes for nodes; with the same or similar semantics. .. _Type:. The ``Type`` class and its subclasses; -------------------------------------. The ``Type`` class (and its subclasses) are an important part of the AST.; Types are accessed through the ``ASTContext`` class, which implicitly creates",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:72380,Integrability,depend,depending,72380,"CXXLiteralIdentifier()`` to retrieve the corresponding; ``IdentifierInfo*`` pointing to the identifier. ``CXXUsingDirective``. The name is a C++ using directive. Using directives are not really; NamedDecls, in that they all have the same name, but they are; implemented as such in order to store them in DeclContext; effectively. ``DeclarationName``\ s are cheap to create, copy, and compare. They require; only a single pointer's worth of storage in the common cases (identifiers,; zero- and one-argument Objective-C selectors) and use dense, uniqued storage; for the other kinds of names. Two ``DeclarationName``\ s can be compared for; equality (``==``, ``!=``) using a simple bitwise comparison, can be ordered; with ``<``, ``>``, ``<=``, and ``>=`` (which provide a lexicographical ordering; for normal identifiers but an unspecified ordering for other kinds of names),; and can be placed into LLVM ``DenseMap``\ s and ``DenseSet``\ s. ``DeclarationName`` instances can be created in different ways depending on; what kind of name the instance will store. Normal identifiers; (``IdentifierInfo`` pointers) and Objective-C selectors (``Selector``) can be; implicitly converted to ``DeclarationNames``. Names for C++ constructors,; destructors, conversion functions, and overloaded operators can be retrieved; from the ``DeclarationNameTable``, an instance of which is available as; ``ASTContext::DeclarationNames``. The member functions; ``getCXXConstructorName``, ``getCXXDestructorName``,; ``getCXXConversionFunctionName``, and ``getCXXOperatorName``, respectively,; return ``DeclarationName`` instances for the four kinds of C++ special function; names. .. _DeclContext:. Declaration contexts; --------------------. Every declaration in a program exists within some *declaration context*, such; as a translation unit, namespace, class, or function. Declaration contexts in; Clang are represented by the ``DeclContext`` class, from which the various; declaration-context AST nodes (``Translatio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:74012,Integrability,synchroniz,synchronized,74012," .. _DeclContext:. Declaration contexts; --------------------. Every declaration in a program exists within some *declaration context*, such; as a translation unit, namespace, class, or function. Declaration contexts in; Clang are represented by the ``DeclContext`` class, from which the various; declaration-context AST nodes (``TranslationUnitDecl``, ``NamespaceDecl``,; ``RecordDecl``, ``FunctionDecl``, etc.) will derive. The ``DeclContext`` class; provides several facilities common to each declaration context:. Source-centric vs. Semantics-centric View of Declarations. ``DeclContext`` provides two views of the declarations stored within a; declaration context. The source-centric view accurately represents the; program source code as written, including multiple declarations of entities; where present (see the section :ref:`Redeclarations and Overloads; <Redeclarations>`), while the semantics-centric view represents the program; semantics. The two views are kept synchronized by semantic analysis while; the ASTs are being constructed. Storage of declarations within that context. Every declaration context can contain some number of declarations. For; example, a C++ class (represented by ``RecordDecl``) contains various member; functions, fields, nested types, and so on. All of these declarations will; be stored within the ``DeclContext``, and one can iterate over the; declarations via [``DeclContext::decls_begin()``,; ``DeclContext::decls_end()``). This mechanism provides the source-centric; view of declarations in the context. Lookup of declarations within that context. The ``DeclContext`` structure provides efficient name lookup for names within; that declaration context. For example, if ``N`` is a namespace we can look; for the name ``N::f`` using ``DeclContext::lookup``. The lookup itself is; based on a lazily-constructed array (for declaration contexts with a small; number of declarations) or hash table (for declaration contexts with more; declarations). The looku",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:84535,Integrability,depend,depend,84535,"ned multiple times in different modules,; it is also possible for there to be multiple definitions of (for instance); a ``CXXRecordDecl``, all of which describe a definition of the same class.; In such a case, only one of those ""definitions"" is considered by Clang to be; the definition of the class, and the others are treated as non-defining; declarations that happen to also contain member declarations. Corresponding; members in each definition of such multiply-defined classes are identified; either by redeclaration chains (if the members are ``Redeclarable``); or by simply a pointer to the canonical declaration (if the declarations; are not ``Redeclarable`` -- in that case, a ``Mergeable`` base class is used; instead). Error Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we dont have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr was created for semantic analysis. With these strategies, clang surfaces better diagnostics, and provides AST; consumers",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:87670,Integrability,depend,dependence,87670,"|-UnresolvedLookupExpr <col:3> '<overloaded function type>' lvalue (ADL) = 'NoArg'; `-DeclRefExpr <col:9> 'int' lvalue ParmVar 'abc' 'int'. An alternative is to use existing Exprs, e.g. CallExpr for the above example.; This would capture more call details (e.g. locations of parentheses) and allow; it to be treated uniformly with valid CallExprs. However, jamming the data we; have into CallExpr forces us to weaken its invariants, e.g. arg count may be; wrong. This would introduce a huge burden on consumers of the AST to handle such; ""impossible"" cases. So when we're representing (rather than correcting) errors,; we use a distinct recovery node type with extremely weak invariants instead. ``RecoveryExpr`` is the only recovery node so far. In practice, broken decls; need more detailed semantics preserved (the current ``Invalid`` flag works; fairly well), and completely broken statements with interesting internal; structure are rare (so dropping the statements is OK). Types and dependence; ^^^^^^^^^^^^^^^^^^^^. ``RecoveryExpr`` is an ``Expr``, so it must have a type. In many cases the true; type can't really be known until the code is corrected (e.g. a call to a; function that doesn't exist). And it means that we can't properly perform type; checks on some containing constructs, such as ``return 42 + unknownFunction()``. To model this, we generalize the concept of dependence from C++ templates to; mean dependence on a template parameter or how an error is repaired. The; ``RecoveryExpr`` ``unknownFunction()`` has the totally unknown type; ``DependentTy``, and this suppresses type-based analysis in the same way it; would inside a template. In cases where we are confident about the concrete type (e.g. the return type; for a broken non-overloaded function call), the ``RecoveryExpr`` will have this; type. This allows more code to be typechecked, and produces a better AST and; more diagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDep",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:88064,Integrability,depend,dependence,88064,"eaken its invariants, e.g. arg count may be; wrong. This would introduce a huge burden on consumers of the AST to handle such; ""impossible"" cases. So when we're representing (rather than correcting) errors,; we use a distinct recovery node type with extremely weak invariants instead. ``RecoveryExpr`` is the only recovery node so far. In practice, broken decls; need more detailed semantics preserved (the current ``Invalid`` flag works; fairly well), and completely broken statements with interesting internal; structure are rare (so dropping the statements is OK). Types and dependence; ^^^^^^^^^^^^^^^^^^^^. ``RecoveryExpr`` is an ``Expr``, so it must have a type. In many cases the true; type can't really be known until the code is corrected (e.g. a call to a; function that doesn't exist). And it means that we can't properly perform type; checks on some containing constructs, such as ``return 42 + unknownFunction()``. To model this, we generalize the concept of dependence from C++ templates to; mean dependence on a template parameter or how an error is repaired. The; ``RecoveryExpr`` ``unknownFunction()`` has the totally unknown type; ``DependentTy``, and this suppresses type-based analysis in the same way it; would inside a template. In cases where we are confident about the concrete type (e.g. the return type; for a broken non-overloaded function call), the ``RecoveryExpr`` will have this; type. This allows more code to be typechecked, and produces a better AST and; more diagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:88103,Integrability,depend,dependence,88103,"eaken its invariants, e.g. arg count may be; wrong. This would introduce a huge burden on consumers of the AST to handle such; ""impossible"" cases. So when we're representing (rather than correcting) errors,; we use a distinct recovery node type with extremely weak invariants instead. ``RecoveryExpr`` is the only recovery node so far. In practice, broken decls; need more detailed semantics preserved (the current ``Invalid`` flag works; fairly well), and completely broken statements with interesting internal; structure are rare (so dropping the statements is OK). Types and dependence; ^^^^^^^^^^^^^^^^^^^^. ``RecoveryExpr`` is an ``Expr``, so it must have a type. In many cases the true; type can't really be known until the code is corrected (e.g. a call to a; function that doesn't exist). And it means that we can't properly perform type; checks on some containing constructs, such as ``return 42 + unknownFunction()``. To model this, we generalize the concept of dependence from C++ templates to; mean dependence on a template parameter or how an error is repaired. The; ``RecoveryExpr`` ``unknownFunction()`` has the totally unknown type; ``DependentTy``, and this suppresses type-based analysis in the same way it; would inside a template. In cases where we are confident about the concrete type (e.g. the return type; for a broken non-overloaded function call), the ``RecoveryExpr`` will have this; type. This allows more code to be typechecked, and produces a better AST and; more diagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:88806,Integrability,depend,dependent,88806,"a call to a; function that doesn't exist). And it means that we can't properly perform type; checks on some containing constructs, such as ``return 42 + unknownFunction()``. To model this, we generalize the concept of dependence from C++ templates to; mean dependence on a template parameter or how an error is repaired. The; ``RecoveryExpr`` ``unknownFunction()`` has the totally unknown type; ``DependentTy``, and this suppresses type-based analysis in the same way it; would inside a template. In cases where we are confident about the concrete type (e.g. the return type; for a broken non-overloaded function call), the ``RecoveryExpr`` will have this; type. This allows more code to be typechecked, and produces a better AST and; more diagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new ContainsErrors bit to; express Does this expression or anything within it contain errors semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:88853,Integrability,depend,dependent,88853,"a call to a; function that doesn't exist). And it means that we can't properly perform type; checks on some containing constructs, such as ``return 42 + unknownFunction()``. To model this, we generalize the concept of dependence from C++ templates to; mean dependence on a template parameter or how an error is repaired. The; ``RecoveryExpr`` ``unknownFunction()`` has the totally unknown type; ``DependentTy``, and this suppresses type-based analysis in the same way it; would inside a template. In cases where we are confident about the concrete type (e.g. the return type; for a broken non-overloaded function call), the ``RecoveryExpr`` will have this; type. This allows more code to be typechecked, and produces a better AST and; more diagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new ContainsErrors bit to; express Does this expression or anything within it contain errors semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89157,Integrability,depend,dependence,89157,"y``, and this suppresses type-based analysis in the same way it; would inside a template. In cases where we are confident about the concrete type (e.g. the return type; for a broken non-overloaded function call), the ``RecoveryExpr`` will have this; type. This allows more code to be typechecked, and produces a better AST and; more diagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new ContainsErrors bit to; express Does this expression or anything within it contain errors semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89598,Integrability,depend,dependent,89598,"iagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new ContainsErrors bit to; express Does this expression or anything within it contain errors semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not a tree. It is a directed graph with; cycles. One example of a cycle is the connection between a; ``ClassTemplateDecl`` and its ""templated"" ``CXXRe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89615,Integrability,depend,dependent,89615,"iagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new ContainsErrors bit to; express Does this expression or anything within it contain errors semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not a tree. It is a directed graph with; cycles. One example of a cycle is the connection between a; ``ClassTemplateDecl`` and its ""templated"" ``CXXRe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89676,Integrability,depend,dependent,89676,"ing(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new ContainsErrors bit to; express Does this expression or anything within it contain errors semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not a tree. It is a directed graph with; cycles. One example of a cycle is the connection between a; ``ClassTemplateDecl`` and its ""templated"" ``CXXRecordDecl``. The *templated*; ``CXXRecordDecl`` represents all the fields and methods inside the class; template, while the ``C",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89717,Integrability,depend,dependent,89717,"ing(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new ContainsErrors bit to; express Does this expression or anything within it contain errors semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not a tree. It is a directed graph with; cycles. One example of a cycle is the connection between a; ``ClassTemplateDecl`` and its ""templated"" ``CXXRecordDecl``. The *templated*; ``CXXRecordDecl`` represents all the fields and methods inside the class; template, while the ``C",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89848,Integrability,depend,dependent,89848,"idered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new ContainsErrors bit to; express Does this expression or anything within it contain errors semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not a tree. It is a directed graph with; cycles. One example of a cycle is the connection between a; ``ClassTemplateDecl`` and its ""templated"" ``CXXRecordDecl``. The *templated*; ``CXXRecordDecl`` represents all the fields and methods inside the class; template, while the ``ClassTemplateDecl`` holds the information which is; related to being a template, i.e. template arguments, etc. We can get the; *",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89865,Integrability,depend,dependent,89865,"idered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new ContainsErrors bit to; express Does this expression or anything within it contain errors semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not a tree. It is a directed graph with; cycles. One example of a cycle is the connection between a; ``ClassTemplateDecl`` and its ""templated"" ``CXXRecordDecl``. The *templated*; ``CXXRecordDecl`` represents all the fields and methods inside the class; template, while the ``ClassTemplateDecl`` holds the information which is; related to being a template, i.e. template arguments, etc. We can get the; *",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:92956,Integrability,depend,depend,92956,"ly equivalent,; - function types and all their parameters have structurally equivalent types,; - record types and all their fields in order of their definition have the same; identifier names and structurally equivalent types,; - variable or function declarations and they have the same identifier name and; their types are structurally equivalent. In C, two types are structurally equivalent if they are *compatible types*. For; a formal definition of *compatible types*, please refer to 6.2.7/1 in the C11; standard. However, there is no definition for *compatible types* in the C++; standard. Still, we extend the definition of structural equivalency to; templates and their instantiations similarly: besides checking the previously; mentioned properties, we have to check for equivalent template; parameters/arguments, etc. The structural equivalent check can be and is used independently from the; ASTImporter, e.g. the ``clang::Sema`` class uses it also. The equivalence of nodes may depend on the equivalency of other pairs of nodes.; Thus, the check is implemented as a parallel graph traversal. We traverse; through the nodes of both graphs at the same time. The actual implementation is; similar to breadth-first-search. Let's say we start the traverse with the <A,B>; pair of nodes. Whenever the traversal reaches a pair <X,Y> then the following; statements are true:. - A and X are nodes from the same ASTContext.; - B and Y are nodes from the same ASTContext.; - A and B may or may not be from the same ASTContext.; - if A == X and B == Y (pointer equivalency) then (there is a cycle during the; traverse). - A and B are structurally equivalent if and only if. - All dependent nodes on the path from <A,B> to <X,Y> are structurally; equivalent. When we compare two classes or enums and one of them is incomplete or has; unloaded external lexical declarations then we cannot descend to compare their; contained declarations. So in these cases they are considered equal if they; have the s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:93646,Integrability,depend,dependent,93646,"cking the previously; mentioned properties, we have to check for equivalent template; parameters/arguments, etc. The structural equivalent check can be and is used independently from the; ASTImporter, e.g. the ``clang::Sema`` class uses it also. The equivalence of nodes may depend on the equivalency of other pairs of nodes.; Thus, the check is implemented as a parallel graph traversal. We traverse; through the nodes of both graphs at the same time. The actual implementation is; similar to breadth-first-search. Let's say we start the traverse with the <A,B>; pair of nodes. Whenever the traversal reaches a pair <X,Y> then the following; statements are true:. - A and X are nodes from the same ASTContext.; - B and Y are nodes from the same ASTContext.; - A and B may or may not be from the same ASTContext.; - if A == X and B == Y (pointer equivalency) then (there is a cycle during the; traverse). - A and B are structurally equivalent if and only if. - All dependent nodes on the path from <A,B> to <X,Y> are structurally; equivalent. When we compare two classes or enums and one of them is incomplete or has; unloaded external lexical declarations then we cannot descend to compare their; contained declarations. So in these cases they are considered equal if they; have the same names. This is the way how we compare forward declarations with; definitions. .. TODO Should we elaborate the actual implementation of the graph traversal,; .. which is a very weird BFS traversal?. Redeclaration Chains; ^^^^^^^^^^^^^^^^^^^^. The early version of the ``ASTImporter``'s merge mechanism squashed the; declarations, i.e. it aimed to have only one declaration instead of maintaining; a whole redeclaration chain. This early approach simply skipped importing a; function prototype, but it imported a definition. To demonstrate the problem; with this approach let's consider an empty ""to"" context and the following; ``virtual`` function declarations of ``f`` in the ""from"" context:. .. code-block:: c+",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:98448,Integrability,depend,dependencies,98448,"declaration to the existing redeclaration chain (if; there is structural equivalency). We do not import, however, the whole; redeclaration chain as we do in case of functions. Up till now, we haven't; found any essential property of forward declarations which is similar to the; case of the virtual flag in a member function prototype. In the future, this; may change, though. Traversal during the Import; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. The node specific import mechanisms are implemented in; ``ASTNodeImporter::VisitNode()`` functions, e.g. ``VisitFunctionDecl()``.; When we import a declaration then first we import everything which is needed to; call the constructor of that declaration node. Everything which can be set; later is set after the node is created. For example, in case of a; ``FunctionDecl`` we first import the declaration context in which the function; is declared, then we create the ``FunctionDecl`` and only then we import the; body of the function. This means there are implicit dependencies between AST; nodes. These dependencies determine the order in which we visit nodes in the; ""from"" context. As with the regular graph traversal algorithms like DFS, we; keep track which nodes we have already visited in; ``ASTImporter::ImportedDecls``. Whenever we create a node then we immediately; add that to the ``ImportedDecls``. We must not start the import of any other; declarations before we keep track of the newly created one. This is essential,; otherwise, we would not be able to handle circular dependencies. To enforce; this, we wrap all constructor calls of all AST nodes in; ``GetImportedOrCreateDecl()``. This wrapper ensures that all newly created; declarations are immediately marked as imported; also, if a declaration is; already marked as imported then we just return its counterpart in the ""to""; context. Consequently, calling a declaration's ``::Create()`` function directly; would lead to errors, please don't do that!. Even with the use of ``GetImportedOrCreateDe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:98487,Integrability,depend,dependencies,98487,"uivalency). We do not import, however, the whole; redeclaration chain as we do in case of functions. Up till now, we haven't; found any essential property of forward declarations which is similar to the; case of the virtual flag in a member function prototype. In the future, this; may change, though. Traversal during the Import; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. The node specific import mechanisms are implemented in; ``ASTNodeImporter::VisitNode()`` functions, e.g. ``VisitFunctionDecl()``.; When we import a declaration then first we import everything which is needed to; call the constructor of that declaration node. Everything which can be set; later is set after the node is created. For example, in case of a; ``FunctionDecl`` we first import the declaration context in which the function; is declared, then we create the ``FunctionDecl`` and only then we import the; body of the function. This means there are implicit dependencies between AST; nodes. These dependencies determine the order in which we visit nodes in the; ""from"" context. As with the regular graph traversal algorithms like DFS, we; keep track which nodes we have already visited in; ``ASTImporter::ImportedDecls``. Whenever we create a node then we immediately; add that to the ``ImportedDecls``. We must not start the import of any other; declarations before we keep track of the newly created one. This is essential,; otherwise, we would not be able to handle circular dependencies. To enforce; this, we wrap all constructor calls of all AST nodes in; ``GetImportedOrCreateDecl()``. This wrapper ensures that all newly created; declarations are immediately marked as imported; also, if a declaration is; already marked as imported then we just return its counterpart in the ""to""; context. Consequently, calling a declaration's ``::Create()`` function directly; would lead to errors, please don't do that!. Even with the use of ``GetImportedOrCreateDecl()`` there is still a; probability of having an infinite import recursion",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:98968,Integrability,depend,dependencies,98968," ``ASTNodeImporter::VisitNode()`` functions, e.g. ``VisitFunctionDecl()``.; When we import a declaration then first we import everything which is needed to; call the constructor of that declaration node. Everything which can be set; later is set after the node is created. For example, in case of a; ``FunctionDecl`` we first import the declaration context in which the function; is declared, then we create the ``FunctionDecl`` and only then we import the; body of the function. This means there are implicit dependencies between AST; nodes. These dependencies determine the order in which we visit nodes in the; ""from"" context. As with the regular graph traversal algorithms like DFS, we; keep track which nodes we have already visited in; ``ASTImporter::ImportedDecls``. Whenever we create a node then we immediately; add that to the ``ImportedDecls``. We must not start the import of any other; declarations before we keep track of the newly created one. This is essential,; otherwise, we would not be able to handle circular dependencies. To enforce; this, we wrap all constructor calls of all AST nodes in; ``GetImportedOrCreateDecl()``. This wrapper ensures that all newly created; declarations are immediately marked as imported; also, if a declaration is; already marked as imported then we just return its counterpart in the ""to""; context. Consequently, calling a declaration's ``::Create()`` function directly; would lead to errors, please don't do that!. Even with the use of ``GetImportedOrCreateDecl()`` there is still a; probability of having an infinite import recursion if things are imported from; each other in wrong way. Imagine that during the import of ``A``, the import of; ``B`` is requested before we could create the node for ``A`` (the constructor; needs a reference to ``B``). And the same could be true for the import of ``B``; (``A`` is requested to be imported before we could create the node for ``B``).; In case of the :ref:`templated-described swing <templated>` we t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:99003,Integrability,wrap,wrap,99003,"declaration then first we import everything which is needed to; call the constructor of that declaration node. Everything which can be set; later is set after the node is created. For example, in case of a; ``FunctionDecl`` we first import the declaration context in which the function; is declared, then we create the ``FunctionDecl`` and only then we import the; body of the function. This means there are implicit dependencies between AST; nodes. These dependencies determine the order in which we visit nodes in the; ""from"" context. As with the regular graph traversal algorithms like DFS, we; keep track which nodes we have already visited in; ``ASTImporter::ImportedDecls``. Whenever we create a node then we immediately; add that to the ``ImportedDecls``. We must not start the import of any other; declarations before we keep track of the newly created one. This is essential,; otherwise, we would not be able to handle circular dependencies. To enforce; this, we wrap all constructor calls of all AST nodes in; ``GetImportedOrCreateDecl()``. This wrapper ensures that all newly created; declarations are immediately marked as imported; also, if a declaration is; already marked as imported then we just return its counterpart in the ""to""; context. Consequently, calling a declaration's ``::Create()`` function directly; would lead to errors, please don't do that!. Even with the use of ``GetImportedOrCreateDecl()`` there is still a; probability of having an infinite import recursion if things are imported from; each other in wrong way. Imagine that during the import of ``A``, the import of; ``B`` is requested before we could create the node for ``A`` (the constructor; needs a reference to ``B``). And the same could be true for the import of ``B``; (``A`` is requested to be imported before we could create the node for ``B``).; In case of the :ref:`templated-described swing <templated>` we take; extra attention to break the cyclical dependency: we import and set the; described temp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:99087,Integrability,wrap,wrapper,99087,"after the node is created. For example, in case of a; ``FunctionDecl`` we first import the declaration context in which the function; is declared, then we create the ``FunctionDecl`` and only then we import the; body of the function. This means there are implicit dependencies between AST; nodes. These dependencies determine the order in which we visit nodes in the; ""from"" context. As with the regular graph traversal algorithms like DFS, we; keep track which nodes we have already visited in; ``ASTImporter::ImportedDecls``. Whenever we create a node then we immediately; add that to the ``ImportedDecls``. We must not start the import of any other; declarations before we keep track of the newly created one. This is essential,; otherwise, we would not be able to handle circular dependencies. To enforce; this, we wrap all constructor calls of all AST nodes in; ``GetImportedOrCreateDecl()``. This wrapper ensures that all newly created; declarations are immediately marked as imported; also, if a declaration is; already marked as imported then we just return its counterpart in the ""to""; context. Consequently, calling a declaration's ``::Create()`` function directly; would lead to errors, please don't do that!. Even with the use of ``GetImportedOrCreateDecl()`` there is still a; probability of having an infinite import recursion if things are imported from; each other in wrong way. Imagine that during the import of ``A``, the import of; ``B`` is requested before we could create the node for ``A`` (the constructor; needs a reference to ``B``). And the same could be true for the import of ``B``; (``A`` is requested to be imported before we could create the node for ``B``).; In case of the :ref:`templated-described swing <templated>` we take; extra attention to break the cyclical dependency: we import and set the; described template only after the ``CXXRecordDecl`` is created. As a best; practice, before creating the node in the ""to"" context, avoid importing of; other nodes whic",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:99982,Integrability,depend,dependency,99982,"cies. To enforce; this, we wrap all constructor calls of all AST nodes in; ``GetImportedOrCreateDecl()``. This wrapper ensures that all newly created; declarations are immediately marked as imported; also, if a declaration is; already marked as imported then we just return its counterpart in the ""to""; context. Consequently, calling a declaration's ``::Create()`` function directly; would lead to errors, please don't do that!. Even with the use of ``GetImportedOrCreateDecl()`` there is still a; probability of having an infinite import recursion if things are imported from; each other in wrong way. Imagine that during the import of ``A``, the import of; ``B`` is requested before we could create the node for ``A`` (the constructor; needs a reference to ``B``). And the same could be true for the import of ``B``; (``A`` is requested to be imported before we could create the node for ``B``).; In case of the :ref:`templated-described swing <templated>` we take; extra attention to break the cyclical dependency: we import and set the; described template only after the ``CXXRecordDecl`` is created. As a best; practice, before creating the node in the ""to"" context, avoid importing of; other nodes which are not needed for the constructor of node ``A``. Error Handling; ^^^^^^^^^^^^^^. Every import function returns with either an ``llvm::Error`` or an; ``llvm::Expected<T>`` object. This enforces to check the return value of the; import functions. If there was an error during one import then we return with; that error. (Exception: when we import the members of a class, we collect the; individual errors with each member and we concatenate them in one Error; object.) We cache these errors in cases of declarations. During the next import; call if there is an existing error we just return with that. So, clients of the; library receive an Error object, which they must check. During import of a specific declaration, it may happen that some AST nodes had; already been created before we rec",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:101875,Integrability,depend,dependant,101875,"ich they must check. During import of a specific declaration, it may happen that some AST nodes had; already been created before we recognize an error. In this case, we signal back; the error to the caller, but the ""to"" context remains polluted with those nodes; which had been created. Ideally, those nodes should not had been created, but; that time we did not know about the error, the error happened later. Since the; AST is immutable (most of the cases we can't remove existing nodes) we choose; to mark these nodes as erroneous. We cache the errors associated with declarations in the ""from"" context in; ``ASTImporter::ImportDeclErrors`` and the ones which are associated with the; ""to"" context in ``ASTImporterSharedState::ImportErrors``. Note that, there may; be several ASTImporter objects which import into the same ""to"" context but from; different ""from"" contexts; in this case, they have to share the associated; errors of the ""to"" context. When an error happens, that propagates through the call stack, through all the; dependant nodes. However, in case of dependency cycles, this is not enough,; because we strive to mark the erroneous nodes so clients can act upon. In those; cases, we have to keep track of the errors for those nodes which are; intermediate nodes of a cycle. An **import path** is the list of the AST nodes which we visit during an Import; call. If node ``A`` depends on node ``B`` then the path contains an ``A->B``; edge. From the call stack of the import functions, we can read the very same; path. Now imagine the following AST, where the ``->`` represents dependency in terms; of the import (all nodes are declarations). .. code-block:: text. A->B->C->D; `->E. We would like to import A.; The import behaves like a DFS, so we will visit the nodes in this order: ABCDE.; During the visitation we will have the following import paths:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:101912,Integrability,depend,dependency,101912,"created before we recognize an error. In this case, we signal back; the error to the caller, but the ""to"" context remains polluted with those nodes; which had been created. Ideally, those nodes should not had been created, but; that time we did not know about the error, the error happened later. Since the; AST is immutable (most of the cases we can't remove existing nodes) we choose; to mark these nodes as erroneous. We cache the errors associated with declarations in the ""from"" context in; ``ASTImporter::ImportDeclErrors`` and the ones which are associated with the; ""to"" context in ``ASTImporterSharedState::ImportErrors``. Note that, there may; be several ASTImporter objects which import into the same ""to"" context but from; different ""from"" contexts; in this case, they have to share the associated; errors of the ""to"" context. When an error happens, that propagates through the call stack, through all the; dependant nodes. However, in case of dependency cycles, this is not enough,; because we strive to mark the erroneous nodes so clients can act upon. In those; cases, we have to keep track of the errors for those nodes which are; intermediate nodes of a cycle. An **import path** is the list of the AST nodes which we visit during an Import; call. If node ``A`` depends on node ``B`` then the path contains an ``A->B``; edge. From the call stack of the import functions, we can read the very same; path. Now imagine the following AST, where the ``->`` represents dependency in terms; of the import (all nodes are declarations). .. code-block:: text. A->B->C->D; `->E. We would like to import A.; The import behaves like a DFS, so we will visit the nodes in this order: ABCDE.; During the visitation we will have the following import paths:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for E, then as; the call stack shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Err",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:102235,Integrability,depend,depends,102235,"the; AST is immutable (most of the cases we can't remove existing nodes) we choose; to mark these nodes as erroneous. We cache the errors associated with declarations in the ""from"" context in; ``ASTImporter::ImportDeclErrors`` and the ones which are associated with the; ""to"" context in ``ASTImporterSharedState::ImportErrors``. Note that, there may; be several ASTImporter objects which import into the same ""to"" context but from; different ""from"" contexts; in this case, they have to share the associated; errors of the ""to"" context. When an error happens, that propagates through the call stack, through all the; dependant nodes. However, in case of dependency cycles, this is not enough,; because we strive to mark the erroneous nodes so clients can act upon. In those; cases, we have to keep track of the errors for those nodes which are; intermediate nodes of a cycle. An **import path** is the list of the AST nodes which we visit during an Import; call. If node ``A`` depends on node ``B`` then the path contains an ``A->B``; edge. From the call stack of the import functions, we can read the very same; path. Now imagine the following AST, where the ``->`` represents dependency in terms; of the import (all nodes are declarations). .. code-block:: text. A->B->C->D; `->E. We would like to import A.; The import behaves like a DFS, so we will visit the nodes in this order: ABCDE.; During the visitation we will have the following import paths:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for E, then as; the call stack shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. However, during the import we could import C and D without any error and they; are independent of A,B and E. We must not set up an error for C and D. So, at; the end of the import we have an entry in ``ImportDeclErrors`` for A,B,E",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:102436,Integrability,depend,dependency,102436,""" context in; ``ASTImporter::ImportDeclErrors`` and the ones which are associated with the; ""to"" context in ``ASTImporterSharedState::ImportErrors``. Note that, there may; be several ASTImporter objects which import into the same ""to"" context but from; different ""from"" contexts; in this case, they have to share the associated; errors of the ""to"" context. When an error happens, that propagates through the call stack, through all the; dependant nodes. However, in case of dependency cycles, this is not enough,; because we strive to mark the erroneous nodes so clients can act upon. In those; cases, we have to keep track of the errors for those nodes which are; intermediate nodes of a cycle. An **import path** is the list of the AST nodes which we visit during an Import; call. If node ``A`` depends on node ``B`` then the path contains an ``A->B``; edge. From the call stack of the import functions, we can read the very same; path. Now imagine the following AST, where the ``->`` represents dependency in terms; of the import (all nodes are declarations). .. code-block:: text. A->B->C->D; `->E. We would like to import A.; The import behaves like a DFS, so we will visit the nodes in this order: ABCDE.; During the visitation we will have the following import paths:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for E, then as; the call stack shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. However, during the import we could import C and D without any error and they; are independent of A,B and E. We must not set up an error for C and D. So, at; the end of the import we have an entry in ``ImportDeclErrors`` for A,B,E but; not for C,D. Now, what happens if there is a cycle in the import path? Let's consider this; AST:. .. code-block:: text. A->B->C->A; `->E. During the visitation, we will have",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:103745,Integrability,depend,dependent,103745,"xt. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for E, then as; the call stack shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. However, during the import we could import C and D without any error and they; are independent of A,B and E. We must not set up an error for C and D. So, at; the end of the import we have an entry in ``ImportDeclErrors`` for A,B,E but; not for C,D. Now, what happens if there is a cycle in the import path? Let's consider this; AST:. .. code-block:: text. A->B->C->A; `->E. During the visitation, we will have the below import paths and if during the; visit of E there is an error then we will set up an error for E,B,A. But what's; up with C?. .. code-block:: text. A; AB; ABC; ABCA; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. This time we know that both B and C are dependent on A. This means we must set; up an error for C too. As the call stack reverses back we get to A and we must; set up an error to all nodes which depend on A (this includes C). But C is no; longer on the import path, it just had been previously. Such a situation can; happen only if during the visitation we had a cycle. If we didn't have any; cycle, then the normal way of passing an Error object through the call stack; could handle the situation. This is why we must track cycles during the import; process for each visited declaration. Lookup Problems; ^^^^^^^^^^^^^^^. When we import a declaration from the source context then we check whether we; already have a structurally equivalent node with the same name in the ""to""; context. If the ""from"" node is a definition and the found one is also a; definition, then we do not create a new node, instead, we mark the found node; as the imported node. If the found definition and the one we want to import; have the same name b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:103900,Integrability,depend,depend,103900,"k shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. However, during the import we could import C and D without any error and they; are independent of A,B and E. We must not set up an error for C and D. So, at; the end of the import we have an entry in ``ImportDeclErrors`` for A,B,E but; not for C,D. Now, what happens if there is a cycle in the import path? Let's consider this; AST:. .. code-block:: text. A->B->C->A; `->E. During the visitation, we will have the below import paths and if during the; visit of E there is an error then we will set up an error for E,B,A. But what's; up with C?. .. code-block:: text. A; AB; ABC; ABCA; ABC; AB; ABE // Error! Set an error to E; AB // Set an error to B; A // Set an error to A. This time we know that both B and C are dependent on A. This means we must set; up an error for C too. As the call stack reverses back we get to A and we must; set up an error to all nodes which depend on A (this includes C). But C is no; longer on the import path, it just had been previously. Such a situation can; happen only if during the visitation we had a cycle. If we didn't have any; cycle, then the normal way of passing an Error object through the call stack; could handle the situation. This is why we must track cycles during the import; process for each visited declaration. Lookup Problems; ^^^^^^^^^^^^^^^. When we import a declaration from the source context then we check whether we; already have a structurally equivalent node with the same name in the ""to""; context. If the ""from"" node is a definition and the found one is also a; definition, then we do not create a new node, instead, we mark the found node; as the imported node. If the found definition and the one we want to import; have the same name but they are structurally in-equivalent, then we have an ODR; violation in case of C++. If the ""from"" node is not a definition then we add",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:105883,Integrability,depend,depend,105883,"t, then we have an ODR; violation in case of C++. If the ""from"" node is not a definition then we add; that to the redeclaration chain of the found node. This behaviour is essential; when we merge ASTs from different translation units which include the same; header file(s). For example, we want to have only one definition for the class; template ``std::vector``, even if we included ``<vector>`` in several; translation units. To find a structurally equivalent node we can use the regular C/C++ lookup; functions: ``DeclContext::noload_lookup()`` and; ``DeclContext::localUncachedLookup()``. These functions do respect the C/C++; name hiding rules, thus you cannot find certain declarations in a given; declaration context. For instance, unnamed declarations (anonymous structs),; non-first ``friend`` declarations and template specializations are hidden. This; is a problem, because if we use the regular C/C++ lookup then we create; redundant AST nodes during the merge! Also, having two instances of the same; node could result in false :ref:`structural in-equivalencies <structural-eq>`; of other nodes which depend on the duplicated node. Because of these reasons,; we created a lookup class which has the sole purpose to register all; declarations, so later they can be looked up by subsequent import requests.; This is the ``ASTImporterLookupTable`` class. This lookup table should be; shared amongst the different ``ASTImporter`` instances if they happen to import; to the very same ""to"" context. This is why we can use the importer specific; lookup only via the ``ASTImporterSharedState`` class. ExternalASTSource; ~~~~~~~~~~~~~~~~~. The ``ExternalASTSource`` is an abstract interface associated with the; ``ASTContext`` class. It provides the ability to read the declarations stored; within a declaration context either for iteration or for name lookup. A; declaration context with an external AST source may load its declarations; on-demand. This means that the list of declarations (repr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:106454,Integrability,interface,interface,106454,"s in a given; declaration context. For instance, unnamed declarations (anonymous structs),; non-first ``friend`` declarations and template specializations are hidden. This; is a problem, because if we use the regular C/C++ lookup then we create; redundant AST nodes during the merge! Also, having two instances of the same; node could result in false :ref:`structural in-equivalencies <structural-eq>`; of other nodes which depend on the duplicated node. Because of these reasons,; we created a lookup class which has the sole purpose to register all; declarations, so later they can be looked up by subsequent import requests.; This is the ``ASTImporterLookupTable`` class. This lookup table should be; shared amongst the different ``ASTImporter`` instances if they happen to import; to the very same ""to"" context. This is why we can use the importer specific; lookup only via the ``ASTImporterSharedState`` class. ExternalASTSource; ~~~~~~~~~~~~~~~~~. The ``ExternalASTSource`` is an abstract interface associated with the; ``ASTContext`` class. It provides the ability to read the declarations stored; within a declaration context either for iteration or for name lookup. A; declaration context with an external AST source may load its declarations; on-demand. This means that the list of declarations (represented as a linked; list, the head is ``DeclContext::FirstDecl``) could be empty. However, member; functions like ``DeclContext::lookup()`` may initiate a load. Usually, external sources are associated with precompiled headers. For example,; when we load a class from a PCH then the members are loaded only if we do want; to look up something in the class' context. In case of LLDB, an implementation of the ``ExternalASTSource`` interface is; attached to the AST context which is related to the parsed expression. This; implementation of the ``ExternalASTSource`` interface is realized with the help; of the ``ASTImporter`` class. This way, LLDB can reuse Clang's parsing; machinery while",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:107200,Integrability,interface,interface,107200,"nstances if they happen to import; to the very same ""to"" context. This is why we can use the importer specific; lookup only via the ``ASTImporterSharedState`` class. ExternalASTSource; ~~~~~~~~~~~~~~~~~. The ``ExternalASTSource`` is an abstract interface associated with the; ``ASTContext`` class. It provides the ability to read the declarations stored; within a declaration context either for iteration or for name lookup. A; declaration context with an external AST source may load its declarations; on-demand. This means that the list of declarations (represented as a linked; list, the head is ``DeclContext::FirstDecl``) could be empty. However, member; functions like ``DeclContext::lookup()`` may initiate a load. Usually, external sources are associated with precompiled headers. For example,; when we load a class from a PCH then the members are loaded only if we do want; to look up something in the class' context. In case of LLDB, an implementation of the ``ExternalASTSource`` interface is; attached to the AST context which is related to the parsed expression. This; implementation of the ``ExternalASTSource`` interface is realized with the help; of the ``ASTImporter`` class. This way, LLDB can reuse Clang's parsing; machinery while synthesizing the underlying AST from the debug data (e.g. from; DWARF). From the view of the ``ASTImporter`` this means both the ""to"" and the; ""from"" context may have declaration contexts with external lexical storage. If; a ``DeclContext`` in the ""to"" AST context has external lexical storage then we; must take extra attention to work only with the already loaded declarations!; Otherwise, we would end up with an uncontrolled import process. For instance,; if we used the regular ``DeclContext::lookup()`` to find the existing; declarations in the ""to"" context then the ``lookup()`` call itself would; initiate a new import while we are in the middle of importing a declaration!; (By the time we initiate the lookup we haven't registered yet that ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:107335,Integrability,interface,interface,107335,"`ASTImporterSharedState`` class. ExternalASTSource; ~~~~~~~~~~~~~~~~~. The ``ExternalASTSource`` is an abstract interface associated with the; ``ASTContext`` class. It provides the ability to read the declarations stored; within a declaration context either for iteration or for name lookup. A; declaration context with an external AST source may load its declarations; on-demand. This means that the list of declarations (represented as a linked; list, the head is ``DeclContext::FirstDecl``) could be empty. However, member; functions like ``DeclContext::lookup()`` may initiate a load. Usually, external sources are associated with precompiled headers. For example,; when we load a class from a PCH then the members are loaded only if we do want; to look up something in the class' context. In case of LLDB, an implementation of the ``ExternalASTSource`` interface is; attached to the AST context which is related to the parsed expression. This; implementation of the ``ExternalASTSource`` interface is realized with the help; of the ``ASTImporter`` class. This way, LLDB can reuse Clang's parsing; machinery while synthesizing the underlying AST from the debug data (e.g. from; DWARF). From the view of the ``ASTImporter`` this means both the ""to"" and the; ""from"" context may have declaration contexts with external lexical storage. If; a ``DeclContext`` in the ""to"" AST context has external lexical storage then we; must take extra attention to work only with the already loaded declarations!; Otherwise, we would end up with an uncontrolled import process. For instance,; if we used the regular ``DeclContext::lookup()`` to find the existing; declarations in the ""to"" context then the ``lookup()`` call itself would; initiate a new import while we are in the middle of importing a declaration!; (By the time we initiate the lookup we haven't registered yet that we already; started to import the node of the ""from"" context.) This is why we use; ``DeclContext::noload_lookup()`` instead. Class Te",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:112989,Integrability,interface,interface,112989," graph; for a single statement (``Stmt*``). Typically instances of ``CFG`` are; constructed for function bodies (usually an instance of ``CompoundStmt``), but; can also be instantiated to represent the control-flow of any class that; subclasses ``Stmt``, which includes simple expressions. Control-flow graphs; are especially useful for performing `flow- or path-sensitive; <https://en.wikipedia.org/wiki/Data_flow_analysis#Sensitivities>`_ program; analyses on a given function. Basic Blocks; ^^^^^^^^^^^^. Concretely, an instance of ``CFG`` is a collection of basic blocks. Each basic; block is an instance of ``CFGBlock``, which simply contains an ordered sequence; of ``Stmt*`` (each referring to statements in the AST). The ordering of; statements within a block indicates unconditional flow of control from one; statement to the next. :ref:`Conditional control-flow; <ConditionalControlFlow>` is represented using edges between basic blocks. The; statements within a given ``CFGBlock`` can be traversed using the; ``CFGBlock::*iterator`` interface. A ``CFG`` object owns the instances of ``CFGBlock`` within the control-flow; graph it represents. Each ``CFGBlock`` within a CFG is also uniquely numbered; (accessible via ``CFGBlock::getBlockID()``). Currently the number is based on; the ordering the blocks were created, but no assumptions should be made on how; ``CFGBlocks`` are numbered other than their numbers are unique and that they; are numbered from 0..N-1 (where N is the number of basic blocks in the CFG). Entry and Exit Blocks; ^^^^^^^^^^^^^^^^^^^^^. Each instance of ``CFG`` contains two special blocks: an *entry* block; (accessible via ``CFG::getEntry()``), which has no incoming edges, and an; *exit* block (accessible via ``CFG::getExit()``), which has no outgoing edges.; Neither block contains any statements, and they serve the role of providing a; clear entrance and exit for a body of code such as a function body. The; presence of these empty blocks greatly simplifies t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:115234,Integrability,interface,interface,115234,"`` also records an extra; ``Stmt*`` that represents the *terminator* of the block. A terminator is; simply the statement that caused the control-flow, and is used to identify the; nature of the conditional control-flow between blocks. For example, in the; case of an if-statement, the terminator refers to the ``IfStmt`` object in the; AST that represented the given branch. To illustrate, consider the following code example:. .. code-block:: c++. int foo(int x) {; x = x + 1;; if (x > 2); x++;; else {; x += 2;; x *= 2;; }. return x;; }. After invoking the parser+semantic analyzer on this code fragment, the AST of; the body of ``foo`` is referenced by a single ``Stmt*``. We can then construct; an instance of ``CFG`` representing the control-flow graph of this function; body by single call to a static class method:. .. code-block:: c++. Stmt *FooBody = ...; std::unique_ptr<CFG> FooCFG = CFG::buildCFG(FooBody);. Along with providing an interface to iterate over its ``CFGBlocks``, the; ``CFG`` class also provides methods that are useful for debugging and; visualizing CFGs. For example, the method ``CFG::dump()`` dumps a; pretty-printed version of the CFG to standard error. This is especially useful; when one is using a debugger such as gdb. For example, here is the output of; ``FooCFG->dump()``:. .. code-block:: text. [ B5 (ENTRY) ]; Predecessors (0):; Successors (1): B4. [ B4 ]; 1: x = x + 1; 2: (x > 2); T: if [B4.2]; Predecessors (1): B5; Successors (2): B3 B2. [ B3 ]; 1: x++; Predecessors (1): B4; Successors (1): B1. [ B2 ]; 1: x += 2; 2: x *= 2; Predecessors (1): B4; Successors (1): B1. [ B1 ]; 1: return x;; Predecessors (2): B2 B3; Successors (1): B0. [ B0 (EXIT) ]; Predecessors (1): B1; Successors (0):. For each block, the pretty-printed output displays for each block the number of; *predecessor* blocks (blocks that have outgoing control-flow to the given; block) and *successor* blocks (blocks that have control-flow that have incoming; control-flow from the given bloc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:119607,Integrability,depend,depends,119607,"hat constant folding in various; ways turns into a tree walk that needs to handle the various cases. However, there are places in both C and C++ that require constants to be; folded. For example, the C standard defines what an ""integer constant; expression"" (i-c-e) is with very precise and specific requirements. The; language then requires i-c-e's in a lot of places (for example, the size of a; bitfield, the value for a case statement, etc). For these, we have to be able; to constant fold the constants, to do semantic checks (e.g., verify bitfield; size is non-negative and that case statements aren't duplicated). We aim for; Clang to be very pedantic about this, diagnosing cases when the code does not; use an i-c-e where one is required, but accepting the code unless running with; ``-pedantic-errors``. Things get a little bit more tricky when it comes to compatibility with; real-world source code. Specifically, GCC has historically accepted a huge; superset of expressions as i-c-e's, and a lot of real world code depends on; this unfortunate accident of history (including, e.g., the glibc system; headers). GCC accepts anything its ""fold"" optimizer is capable of reducing to; an integer constant, which means that the definition of what it accepts changes; as its optimizer does. One example is that GCC accepts things like ""``case; X-X:``"" even when ``X`` is a variable, because it can fold this to 0. Another issue are how constants interact with the extensions we support, such; as ``__builtin_constant_p``, ``__builtin_inf``, ``__extension__`` and many; others. C99 obviously does not specify the semantics of any of these; extensions, and the definition of i-c-e does not include them. However, these; extensions are often used in real code, and we have to have a way to reason; about them. Finally, this is not just a problem for semantic analysis. The code generator; and other clients have to be able to fold constants (e.g., to initialize global; variables) and have to handle",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:123964,Integrability,depend,depending,123964,"ang supports; interacts with constant evaluation:. * ``__extension__``: The expression form of this extension causes any; evaluatable subexpression to be accepted as an integer constant expression.; * ``__builtin_constant_p``: This returns true (as an integer constant; expression) if the operand evaluates to either a numeric value (that is, not; a pointer cast to integral type) of integral, enumeration, floating or; complex type, or if it evaluates to the address of the first character of a; string literal (possibly cast to some other type). As a special case, if; ``__builtin_constant_p`` is the (potentially parenthesized) condition of a; conditional operator expression (""``?:``""), only the true side of the; conditional operator is considered, and it is evaluated with full constant; folding.; * ``__builtin_choose_expr``: The condition is required to be an integer; constant expression, but we accept any constant as an ""extension of an; extension"". This only evaluates one operand depending on which way the; condition evaluates.; * ``__builtin_classify_type``: This always returns an integer constant; expression.; * ``__builtin_inf, nan, ...``: These are treated just like a floating-point; literal.; * ``__builtin_abs, copysign, ...``: These are constant folded as general; constant expressions.; * ``__builtin_strlen`` and ``strlen``: These are constant folded as integer; constant expressions if the argument is a string literal. .. _Sema:. The Sema Library; ================. This library is called by the :ref:`Parser library <Parser>` during parsing to; do semantic analysis of the input. For valid programs, Sema builds an AST for; parsed constructs. .. _CodeGen:. The CodeGen Library; ===================. CodeGen takes an :ref:`AST <AST>` as input and produces `LLVM IR code; <//llvm.org/docs/LangRef.html>`_ from it. How to change Clang; ===================. How to add an attribute; -----------------------; Attributes are a form of metadata that can be attached to a program ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:126613,Integrability,depend,depends,126613,"e semantic handling of the attribute. Parsing of the attribute is determined by the various syntactic forms attributes; can take, such as GNU, C++11, and Microsoft style attributes, as well as other; information provided by the table definition of the attribute. Ultimately, the; parsed representation of an attribute object is a ``ParsedAttr`` object.; These parsed attributes chain together as a list of parsed attributes attached; to a declarator or declaration specifier. The parsing of attributes is handled; automatically by Clang, except for attributes spelled as so-called custom; keywords. When implementing a custom keyword attribute, the parsing of the; keyword and creation of the ``ParsedAttr`` object must be done manually. Eventually, ``Sema::ProcessDeclAttributeList()`` is called with a ``Decl`` and; a ``ParsedAttr``, at which point the parsed attribute can be transformed; into a semantic attribute. The process by which a parsed attribute is converted; into a semantic attribute depends on the attribute definition and semantic; requirements of the attribute. The end result, however, is that the semantic; attribute object is attached to the ``Decl`` object, and can be obtained by a; call to ``Decl::getAttr<T>()``. Similarly, for statement attributes,; ``Sema::ProcessStmtAttributes()`` is called with a ``Stmt`` a list of; ``ParsedAttr`` objects to be converted into a semantic attribute. The structure of the semantic attribute is also governed by the attribute; definition given in Attr.td. This definition is used to automatically generate; functionality used for the implementation of the attribute, such as a class; derived from ``clang::Attr``, information for the parser to use, automated; semantic checking for some attributes, etc. ``include/clang/Basic/Attr.td``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; The first step to adding a new attribute to Clang is to add its definition to; `include/clang/Basic/Attr.td; <https://github.com/llvm/llvm-project/blob/main/clang/inclu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:131593,Integrability,interface,interface,131593,"lling with the ``gnu`` namespace. Attributes; should only specify this spelling for attributes; supported by GCC.; ``Clang`` Specifies two or three spellings: the first is a; GNU-style spelling, the second is a C++-style spelling; with the ``clang`` namespace, and the third is an; optional C-style spelling with the ``clang`` namespace.; By default, a C-style spelling is provided.; ``Pragma`` The attribute is spelled as a ``#pragma``, and requires; custom processing within the preprocessor. If the; attribute is meant to be used by Clang, it should; set the namespace to ``""clang""``. Note that this; spelling is not used for declaration attributes.; ================== =========================================================. The C++ standard specifies that any [non-standard attribute] that is not; recognized by the implementation is ignored (``[dcl.attr.grammar]``).; The rule for C is similar. This makes ``CXX11`` and ``C23`` spellings; unsuitable for attributes that affect the type system, that change the; binary interface of the code, or that have other similar semantic meaning. ``RegularKeyword`` provides an alternative way of spelling such attributes.; It reuses the production rules for standard attributes, but it applies them; to plain keywords rather than to ``[[]]`` sequences. Compilers that don't; recognize the keyword are likely to report an error of some kind. For example, the ``ArmStreaming`` function type attribute affects; both the type system and the binary interface of the function.; It cannot therefore be spelled ``[[arm::streaming]]``, since compilers; that don't understand ``arm::streaming`` would ignore it and miscompile; the code. ``ArmStreaming`` is instead spelled ``__arm_streaming``, but it; can appear wherever a hypothetical ``[[arm::streaming]]`` could appear. Subjects; ~~~~~~~~; Attributes appertain to one or more subjects. If the attribute attempts to; attach to a subject that is not in the subject list, a diagnostic is issued; automaticall",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:132060,Integrability,interface,interface,132060,"m processing within the preprocessor. If the; attribute is meant to be used by Clang, it should; set the namespace to ``""clang""``. Note that this; spelling is not used for declaration attributes.; ================== =========================================================. The C++ standard specifies that any [non-standard attribute] that is not; recognized by the implementation is ignored (``[dcl.attr.grammar]``).; The rule for C is similar. This makes ``CXX11`` and ``C23`` spellings; unsuitable for attributes that affect the type system, that change the; binary interface of the code, or that have other similar semantic meaning. ``RegularKeyword`` provides an alternative way of spelling such attributes.; It reuses the production rules for standard attributes, but it applies them; to plain keywords rather than to ``[[]]`` sequences. Compilers that don't; recognize the keyword are likely to report an error of some kind. For example, the ``ArmStreaming`` function type attribute affects; both the type system and the binary interface of the function.; It cannot therefore be spelled ``[[arm::streaming]]``, since compilers; that don't understand ``arm::streaming`` would ignore it and miscompile; the code. ``ArmStreaming`` is instead spelled ``__arm_streaming``, but it; can appear wherever a hypothetical ``[[arm::streaming]]`` could appear. Subjects; ~~~~~~~~; Attributes appertain to one or more subjects. If the attribute attempts to; attach to a subject that is not in the subject list, a diagnostic is issued; automatically. Whether the diagnostic is a warning or an error depends on how; the attribute's ``SubjectList`` is defined, but the default behavior is to warn.; The diagnostics displayed to the user are automatically determined based on the; subjects in the list, but a custom diagnostic parameter can also be specified in; the ``SubjectList``. The diagnostics generated for subject list violations are; calculated automatically or specified by the subject list itself",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:132616,Integrability,depend,depends,132616,"lar semantic meaning. ``RegularKeyword`` provides an alternative way of spelling such attributes.; It reuses the production rules for standard attributes, but it applies them; to plain keywords rather than to ``[[]]`` sequences. Compilers that don't; recognize the keyword are likely to report an error of some kind. For example, the ``ArmStreaming`` function type attribute affects; both the type system and the binary interface of the function.; It cannot therefore be spelled ``[[arm::streaming]]``, since compilers; that don't understand ``arm::streaming`` would ignore it and miscompile; the code. ``ArmStreaming`` is instead spelled ``__arm_streaming``, but it; can appear wherever a hypothetical ``[[arm::streaming]]`` could appear. Subjects; ~~~~~~~~; Attributes appertain to one or more subjects. If the attribute attempts to; attach to a subject that is not in the subject list, a diagnostic is issued; automatically. Whether the diagnostic is a warning or an error depends on how; the attribute's ``SubjectList`` is defined, but the default behavior is to warn.; The diagnostics displayed to the user are automatically determined based on the; subjects in the list, but a custom diagnostic parameter can also be specified in; the ``SubjectList``. The diagnostics generated for subject list violations are; calculated automatically or specified by the subject list itself. If a; previously unused Decl node is added to the ``SubjectList``, the logic used to; automatically determine the diagnostic parameter in `utils/TableGen/ClangAttrEmitter.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/utils/TableGen/ClangAttrEmitter.cpp>`_; may need to be updated. By default, all subjects in the SubjectList must either be a Decl node defined; in ``DeclNodes.td``, or a statement node defined in ``StmtNodes.td``. However,; more complex subjects can be created by creating a ``SubsetSubject`` object.; Each such object has a base subject which it appertains to (which must be a; Decl or ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:146898,Integrability,depend,dependent,146898,"s and will (eventually!) build the AST node. It's; fairly common for the ``ActOnCXX`` function to do very little (often just; some minor translation from the parser's representation to ``Sema``'s; representation of the same thing), but the separation is still important:; C++ template instantiation, for example, should always call the ``BuildXXX``; variant. Several notes on semantic analysis before we get into construction; of the AST:. * Your expression probably involves some types and some subexpressions.; Make sure to fully check that those types, and the types of those; subexpressions, meet your expectations. Add implicit conversions where; necessary to make sure that all of the types line up exactly the way you; want them. Write extensive tests to check that you're getting good; diagnostics for mistakes and that you can use various forms of; subexpressions with your expression.; * When type-checking a type or subexpression, make sure to first check; whether the type is ""dependent"" (``Type::isDependentType()``) or whether a; subexpression is type-dependent (``Expr::isTypeDependent()``). If any of; these return ``true``, then you're inside a template and you can't do much; type-checking now. That's normal, and your AST node (when you get there); will have to deal with this case. At this point, you can write tests that; use your expression within templates, but don't try to instantiate the; templates.; * For each subexpression, be sure to call ``Sema::CheckPlaceholderExpr()``; to deal with ""weird"" expressions that don't behave well as subexpressions.; Then, determine whether you need to perform lvalue-to-rvalue conversions; (``Sema::DefaultLvalueConversions``) or the usual unary conversions; (``Sema::UsualUnaryConversions``), for places where the subexpression is; producing a value you intend to use.; * Your ``BuildXXX`` function will probably just return ``ExprError()`` at; this point, since you don't have an AST. That's perfectly fine, and; shouldn't impact your ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:146975,Integrability,depend,dependent,146975,"s and will (eventually!) build the AST node. It's; fairly common for the ``ActOnCXX`` function to do very little (often just; some minor translation from the parser's representation to ``Sema``'s; representation of the same thing), but the separation is still important:; C++ template instantiation, for example, should always call the ``BuildXXX``; variant. Several notes on semantic analysis before we get into construction; of the AST:. * Your expression probably involves some types and some subexpressions.; Make sure to fully check that those types, and the types of those; subexpressions, meet your expectations. Add implicit conversions where; necessary to make sure that all of the types line up exactly the way you; want them. Write extensive tests to check that you're getting good; diagnostics for mistakes and that you can use various forms of; subexpressions with your expression.; * When type-checking a type or subexpression, make sure to first check; whether the type is ""dependent"" (``Type::isDependentType()``) or whether a; subexpression is type-dependent (``Expr::isTypeDependent()``). If any of; these return ``true``, then you're inside a template and you can't do much; type-checking now. That's normal, and your AST node (when you get there); will have to deal with this case. At this point, you can write tests that; use your expression within templates, but don't try to instantiate the; templates.; * For each subexpression, be sure to call ``Sema::CheckPlaceholderExpr()``; to deal with ""weird"" expressions that don't behave well as subexpressions.; Then, determine whether you need to perform lvalue-to-rvalue conversions; (``Sema::DefaultLvalueConversions``) or the usual unary conversions; (``Sema::UsualUnaryConversions``), for places where the subexpression is; producing a value you intend to use.; * Your ``BuildXXX`` function will probably just return ``ExprError()`` at; this point, since you don't have an AST. That's perfectly fine, and; shouldn't impact your ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:150837,Integrability,depend,depending,150837,"alysis should; flag an error here with the attempt to call the destructor.; * Inspect the generated AST by printing it using ``clang -cc1 -ast-print``,; to make sure you're capturing all of the important information about how; the AST was written.; * Inspect the generated AST under ``clang -cc1 -ast-dump`` to verify that; all of the types in the generated AST line up the way you want them.; Remember that clients of the AST should never have to ""think"" to; understand what's going on. For example, all implicit conversions should; show up explicitly in the AST.; * Write tests that use your expression as a subexpression of other,; well-known expressions. Can you call a function using your expression as; an argument? Can you use the ternary operator?. #. Teach code generation to create IR to your AST node. This step is the first; (and only) that requires knowledge of LLVM IR. There are several things to; keep in mind:. * Code generation is separated into scalar/aggregate/complex and; lvalue/rvalue paths, depending on what kind of result your expression; produces. On occasion, this requires some careful factoring of code to; avoid duplication.; * ``CodeGenFunction`` contains functions ``ConvertType`` and; ``ConvertTypeForMem`` that convert Clang's types (``clang::Type*`` or; ``clang::QualType``) to LLVM types. Use the former for values, and the; latter for memory locations: test with the C++ ""``bool``"" type to check; this. If you find that you are having to use LLVM bitcasts to make the; subexpressions of your expression have the type that your expression; expects, STOP! Go fix semantic analysis and the AST so that you don't; need these bitcasts.; * The ``CodeGenFunction`` class has a number of helper functions to make; certain operations easy, such as generating code to produce an lvalue or; an rvalue, or to initialize a memory location with a given value. Prefer; to use these functions rather than directly writing loads and stores,; because these functions take care of s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:152507,Integrability,depend,dependence,152507,"eed these bitcasts.; * The ``CodeGenFunction`` class has a number of helper functions to make; certain operations easy, such as generating code to produce an lvalue or; an rvalue, or to initialize a memory location with a given value. Prefer; to use these functions rather than directly writing loads and stores,; because these functions take care of some of the tricky details for you; (e.g., for exceptions).; * If your expression requires some special behavior in the event of an; exception, look at the ``push*Cleanup`` functions in ``CodeGenFunction``; to introduce a cleanup. You shouldn't have to deal with; exception-handling directly.; * Testing is extremely important in IR generation. Use ``clang -cc1; -emit-llvm`` and `FileCheck; <https://llvm.org/docs/CommandGuide/FileCheck.html>`_ to verify that you're; generating the right IR. #. Teach template instantiation how to cope with your AST node, which requires; some fairly simple code:. * Make sure that your expression's constructor properly computes the flags; for type dependence (i.e., the type your expression produces can change; from one instantiation to the next), value dependence (i.e., the constant; value your expression produces can change from one instantiation to the; next), instantiation dependence (i.e., a template parameter occurs; anywhere in your expression), and whether your expression contains a; parameter pack (for variadic templates). Often, computing these flags; just means combining the results from the various types and; subexpressions.; * Add ``TransformXXX`` and ``RebuildXXX`` functions to the ``TreeTransform``; class template in ``Sema``. ``TransformXXX`` should (recursively); transform all of the subexpressions and types within your expression,; using ``getDerived().TransformYYY``. If all of the subexpressions and; types transform without error, it will then call the ``RebuildXXX``; function, which will in turn call ``getSema().BuildXXX`` to perform; semantic analysis and build your express",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:152614,Integrability,depend,dependence,152614,"perations easy, such as generating code to produce an lvalue or; an rvalue, or to initialize a memory location with a given value. Prefer; to use these functions rather than directly writing loads and stores,; because these functions take care of some of the tricky details for you; (e.g., for exceptions).; * If your expression requires some special behavior in the event of an; exception, look at the ``push*Cleanup`` functions in ``CodeGenFunction``; to introduce a cleanup. You shouldn't have to deal with; exception-handling directly.; * Testing is extremely important in IR generation. Use ``clang -cc1; -emit-llvm`` and `FileCheck; <https://llvm.org/docs/CommandGuide/FileCheck.html>`_ to verify that you're; generating the right IR. #. Teach template instantiation how to cope with your AST node, which requires; some fairly simple code:. * Make sure that your expression's constructor properly computes the flags; for type dependence (i.e., the type your expression produces can change; from one instantiation to the next), value dependence (i.e., the constant; value your expression produces can change from one instantiation to the; next), instantiation dependence (i.e., a template parameter occurs; anywhere in your expression), and whether your expression contains a; parameter pack (for variadic templates). Often, computing these flags; just means combining the results from the various types and; subexpressions.; * Add ``TransformXXX`` and ``RebuildXXX`` functions to the ``TreeTransform``; class template in ``Sema``. ``TransformXXX`` should (recursively); transform all of the subexpressions and types within your expression,; using ``getDerived().TransformYYY``. If all of the subexpressions and; types transform without error, it will then call the ``RebuildXXX``; function, which will in turn call ``getSema().BuildXXX`` to perform; semantic analysis and build your expression.; * To test template instantiation, take those tests you wrote to make sure; that you were type check",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:152740,Integrability,depend,dependence,152740," given value. Prefer; to use these functions rather than directly writing loads and stores,; because these functions take care of some of the tricky details for you; (e.g., for exceptions).; * If your expression requires some special behavior in the event of an; exception, look at the ``push*Cleanup`` functions in ``CodeGenFunction``; to introduce a cleanup. You shouldn't have to deal with; exception-handling directly.; * Testing is extremely important in IR generation. Use ``clang -cc1; -emit-llvm`` and `FileCheck; <https://llvm.org/docs/CommandGuide/FileCheck.html>`_ to verify that you're; generating the right IR. #. Teach template instantiation how to cope with your AST node, which requires; some fairly simple code:. * Make sure that your expression's constructor properly computes the flags; for type dependence (i.e., the type your expression produces can change; from one instantiation to the next), value dependence (i.e., the constant; value your expression produces can change from one instantiation to the; next), instantiation dependence (i.e., a template parameter occurs; anywhere in your expression), and whether your expression contains a; parameter pack (for variadic templates). Often, computing these flags; just means combining the results from the various types and; subexpressions.; * Add ``TransformXXX`` and ``RebuildXXX`` functions to the ``TreeTransform``; class template in ``Sema``. ``TransformXXX`` should (recursively); transform all of the subexpressions and types within your expression,; using ``getDerived().TransformYYY``. If all of the subexpressions and; types transform without error, it will then call the ``RebuildXXX``; function, which will in turn call ``getSema().BuildXXX`` to perform; semantic analysis and build your expression.; * To test template instantiation, take those tests you wrote to make sure; that you were type checking with type-dependent expressions and dependent; types (from step #2) and instantiate those templates with various",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:153590,Integrability,depend,dependent,153590,"the constant; value your expression produces can change from one instantiation to the; next), instantiation dependence (i.e., a template parameter occurs; anywhere in your expression), and whether your expression contains a; parameter pack (for variadic templates). Often, computing these flags; just means combining the results from the various types and; subexpressions.; * Add ``TransformXXX`` and ``RebuildXXX`` functions to the ``TreeTransform``; class template in ``Sema``. ``TransformXXX`` should (recursively); transform all of the subexpressions and types within your expression,; using ``getDerived().TransformYYY``. If all of the subexpressions and; types transform without error, it will then call the ``RebuildXXX``; function, which will in turn call ``getSema().BuildXXX`` to perform; semantic analysis and build your expression.; * To test template instantiation, take those tests you wrote to make sure; that you were type checking with type-dependent expressions and dependent; types (from step #2) and instantiate those templates with various types,; some of which type-check and some that don't, and test the error messages; in each case. #. There are some ""extras"" that make other features work better. It's worth; handling these extras to give your expression complete integration into; Clang:. * Add code completion support for your expression in; ``SemaCodeComplete.cpp``.; * If your expression has types in it, or has any ""interesting"" features; other than subexpressions, extend libclang's ``CursorVisitor`` to provide; proper visitation for your expression, enabling various IDE features such; as syntax highlighting, cross-referencing, and so on. The; ``c-index-test`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come with test coverage demonstrating; the change in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:153616,Integrability,depend,dependent,153616,"the constant; value your expression produces can change from one instantiation to the; next), instantiation dependence (i.e., a template parameter occurs; anywhere in your expression), and whether your expression contains a; parameter pack (for variadic templates). Often, computing these flags; just means combining the results from the various types and; subexpressions.; * Add ``TransformXXX`` and ``RebuildXXX`` functions to the ``TreeTransform``; class template in ``Sema``. ``TransformXXX`` should (recursively); transform all of the subexpressions and types within your expression,; using ``getDerived().TransformYYY``. If all of the subexpressions and; types transform without error, it will then call the ``RebuildXXX``; function, which will in turn call ``getSema().BuildXXX`` to perform; semantic analysis and build your expression.; * To test template instantiation, take those tests you wrote to make sure; that you were type checking with type-dependent expressions and dependent; types (from step #2) and instantiate those templates with various types,; some of which type-check and some that don't, and test the error messages; in each case. #. There are some ""extras"" that make other features work better. It's worth; handling these extras to give your expression complete integration into; Clang:. * Add code completion support for your expression in; ``SemaCodeComplete.cpp``.; * If your expression has types in it, or has any ""interesting"" features; other than subexpressions, extend libclang's ``CursorVisitor`` to provide; proper visitation for your expression, enabling various IDE features such; as syntax highlighting, cross-referencing, and so on. The; ``c-index-test`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come with test coverage demonstrating; the change in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:153766,Integrability,message,messages,153766,"the constant; value your expression produces can change from one instantiation to the; next), instantiation dependence (i.e., a template parameter occurs; anywhere in your expression), and whether your expression contains a; parameter pack (for variadic templates). Often, computing these flags; just means combining the results from the various types and; subexpressions.; * Add ``TransformXXX`` and ``RebuildXXX`` functions to the ``TreeTransform``; class template in ``Sema``. ``TransformXXX`` should (recursively); transform all of the subexpressions and types within your expression,; using ``getDerived().TransformYYY``. If all of the subexpressions and; types transform without error, it will then call the ``RebuildXXX``; function, which will in turn call ``getSema().BuildXXX`` to perform; semantic analysis and build your expression.; * To test template instantiation, take those tests you wrote to make sure; that you were type checking with type-dependent expressions and dependent; types (from step #2) and instantiate those templates with various types,; some of which type-check and some that don't, and test the error messages; in each case. #. There are some ""extras"" that make other features work better. It's worth; handling these extras to give your expression complete integration into; Clang:. * Add code completion support for your expression in; ``SemaCodeComplete.cpp``.; * If your expression has types in it, or has any ""interesting"" features; other than subexpressions, extend libclang's ``CursorVisitor`` to provide; proper visitation for your expression, enabling various IDE features such; as syntax highlighting, cross-referencing, and so on. The; ``c-index-test`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come with test coverage demonstrating; the change in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:153922,Integrability,integrat,integration,153922,"ten, computing these flags; just means combining the results from the various types and; subexpressions.; * Add ``TransformXXX`` and ``RebuildXXX`` functions to the ``TreeTransform``; class template in ``Sema``. ``TransformXXX`` should (recursively); transform all of the subexpressions and types within your expression,; using ``getDerived().TransformYYY``. If all of the subexpressions and; types transform without error, it will then call the ``RebuildXXX``; function, which will in turn call ``getSema().BuildXXX`` to perform; semantic analysis and build your expression.; * To test template instantiation, take those tests you wrote to make sure; that you were type checking with type-dependent expressions and dependent; types (from step #2) and instantiate those templates with various types,; some of which type-check and some that don't, and test the error messages; in each case. #. There are some ""extras"" that make other features work better. It's worth; handling these extras to give your expression complete integration into; Clang:. * Add code completion support for your expression in; ``SemaCodeComplete.cpp``.; * If your expression has types in it, or has any ""interesting"" features; other than subexpressions, extend libclang's ``CursorVisitor`` to provide; proper visitation for your expression, enabling various IDE features such; as syntax highlighting, cross-referencing, and so on. The; ``c-index-test`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come with test coverage demonstrating; the change in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option as a way to; validate diagnostic behavior. This option will use special comments within the; test file to verify that expected diagnostics appear in the correct source; locations. If all of the expected diagnostics match the actual output of Clang,; then the invocatio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:158600,Integrability,message,message,158600," to specify expected; diagnostics:. .. code-block:: c++. int A = B; // expected-error {{use of undeclared identifier 'B'}}. You can place as many diagnostics on one line as you wish. To make the code; more readable, you can use slash-newline to separate out the diagnostics. Alternatively, it is possible to specify the line on which the diagnostic; should appear by appending ``@<line>`` to ``expected-<type>``, for example:. .. code-block:: c++. #warning some text; // expected-warning@10 {{some text}}. The line number may be absolute (as above), or relative to the current line by; prefixing the number with either ``+`` or ``-``. If the diagnostic is generated in a separate file, for example in a shared; header file, it may be beneficial to be able to declare the file in which the; diagnostic will appear, rather than placing the ``expected-*`` directive in the; actual file itself. This can be done using the following syntax:. .. code-block:: c++. // expected-error@path/include.h:15 {{error message}}. The path can be absolute or relative and the same search paths will be used as; for ``#include`` directives. The line number in an external file may be; substituted with ``*`` meaning that any line number will match (useful where; the included file is, for example, a system header where the actual line number; may change and is not critical). As an alternative to specifying a fixed line number, the location of a; diagnostic can instead be indicated by a marker of the form ``#<marker>``.; Markers are specified by including them in a comment, and then referenced by; appending the marker to the diagnostic with ``@#<marker>``, as with:. .. code-block:: c++. #warning some text // #1; // ... other code ...; // expected-warning@#1 {{some text}}. The name of a marker used in a directive must be unique within the compilation. The simple syntax above allows each specification to match exactly one; diagnostic. You can use the extended syntax to customize this. The extended; syntax is ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:161229,Integrability,message,message,161229,"vious declaration is here}}. In the first example, the diagnostic becomes optional, i.e. it will be; swallowed if it occurs, but will not generate an error if it does not occur. In; the second example, the diagnostic must occur at least once. As a short-hand,; ""one or more"" can be specified simply by ``+``. For example:. .. code-block:: c++. void g(); // expected-note + {{previous declaration is here}}. A range can also be specified by ``<n>-<m>``. For example:. .. code-block:: c++. void f(); // expected-note 0-1 {{previous declaration is here}}. In this example, the diagnostic may appear only once, if at all. .. _DiagnosticMatching:. Matching Modes; ~~~~~~~~~~~~~~. The default matching mode is simple string, which looks for the expected text; that appears between the first `{{` and `}}` pair of the comment. The string is; interpreted just as-is, with one exception: the sequence `\n` is converted to a; single newline character. This mode matches the emitted diagnostic when the; text appears as a substring at any position of the emitted message. To enable matching against desired strings that contain `}}` or `{{`, the; string-mode parser accepts opening delimiters of more than two curly braces,; like `{{{`. It then looks for a closing delimiter of equal ""width"" (i.e `}}}`).; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-erro",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:161902,Integrability,wrap,wrapped,161902," string, which looks for the expected text; that appears between the first `{{` and `}}` pair of the comment. The string is; interpreted just as-is, with one exception: the sequence `\n` is converted to a; single newline character. This mode matches the emitted diagnostic when the; text appears as a substring at any position of the emitted message. To enable matching against desired strings that contain `}}` or `{{`, the; string-mode parser accepts opening delimiters of more than two curly braces,; like `{{{`. It then looks for a closing delimiter of equal ""width"" (i.e `}}}`).; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:4551,Modifiability,portab,portable,4551,"s.td`` files, depending on what library will be; using it. From this file, :program:`tblgen` generates the unique ID of the; diagnostic, the severity of the diagnostic and the English translation + format; string. There is little sanity with the naming of the unique ID's right now. Some; start with ``err_``, ``warn_``, ``ext_`` to encode the severity into the name.; Since the enum is referenced in the C++ code that produces the diagnostic, it; is somewhat useful for it to be reasonably short. The severity of the diagnostic comes from the set {``NOTE``, ``REMARK``,; ``WARNING``,; ``EXTENSION``, ``EXTWARN``, ``ERROR``}. The ``ERROR`` severity is used for; diagnostics indicating the program is never acceptable under any circumstances.; When an error is emitted, the AST for the input code may not be fully built.; The ``EXTENSION`` and ``EXTWARN`` severities are used for extensions to the; language that Clang accepts. This means that Clang fully understands and can; represent them in the AST, but we produce diagnostics to tell the user their; code is non-portable. The difference is that the former are ignored by; default, and the later warn by default. The ``WARNING`` severity is used for; constructs that are valid in the currently selected source language but that; are dubious in some way. The ``REMARK`` severity provides generic information; about the compilation that is not necessarily related to any dubious code. The; ``NOTE`` level is used to staple more information onto previous diagnostics. These *severities* are mapped into a smaller set (the ``Diagnostic::Level``; enum, {``Ignored``, ``Note``, ``Remark``, ``Warning``, ``Error``, ``Fatal``}) of; output; *levels* by the diagnostics subsystem based on various configuration options.; Clang internally supports a fully fine grained mapping mechanism that allows; you to map almost any diagnostic to the output level that you want. The only; diagnostics that cannot be mapped are ``NOTE``\ s, which always follow the; sever",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:5225,Modifiability,config,configuration,5225," severity is used for; diagnostics indicating the program is never acceptable under any circumstances.; When an error is emitted, the AST for the input code may not be fully built.; The ``EXTENSION`` and ``EXTWARN`` severities are used for extensions to the; language that Clang accepts. This means that Clang fully understands and can; represent them in the AST, but we produce diagnostics to tell the user their; code is non-portable. The difference is that the former are ignored by; default, and the later warn by default. The ``WARNING`` severity is used for; constructs that are valid in the currently selected source language but that; are dubious in some way. The ``REMARK`` severity provides generic information; about the compilation that is not necessarily related to any dubious code. The; ``NOTE`` level is used to staple more information onto previous diagnostics. These *severities* are mapped into a smaller set (the ``Diagnostic::Level``; enum, {``Ignored``, ``Note``, ``Remark``, ``Warning``, ``Error``, ``Fatal``}) of; output; *levels* by the diagnostics subsystem based on various configuration options.; Clang internally supports a fully fine grained mapping mechanism that allows; you to map almost any diagnostic to the output level that you want. The only; diagnostics that cannot be mapped are ``NOTE``\ s, which always follow the; severity of the previously emitted diagnostic and ``ERROR``\ s, which can only; be mapped to ``Fatal`` (it is not possible to turn an error into a warning, for; example). Diagnostic mappings are used in many ways. For example, if the user specifies; ``-pedantic``, ``EXTENSION`` maps to ``Warning``, if they specify; ``-pedantic-errors``, it turns into ``Error``. This is used to implement; options like ``-Wunused_macros``, ``-Wundef`` etc. Mapping to ``Fatal`` should only be used for diagnostics that are considered so; severe that error recovery won't be able to recover sensibly from them (thus; spewing a ton of bogus errors). One example",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:9371,Modifiability,variab,variable,9371,"ation. The user will be able to see the; line and location of the caret, so you don't need to tell them that the; problem is with the 4th argument to the function: just point to it.; * Do not capitalize the diagnostic string, and do not end it with a period.; * If you need to quote something in the diagnostic string, use single quotes. Diagnostics should never take random English strings as arguments: you; shouldn't use ""``you have a problem with %0``"" and pass in things like ""``your; argument``"" or ""``your return value``"" as arguments. Doing this prevents; :ref:`translating <internals-diag-translation>` the Clang diagnostics to other; languages (because they'll get random English words in their otherwise; localized diagnostic). The exceptions to this are C/C++ language keywords; (e.g., ``auto``, ``const``, ``mutable``, etc) and C/C++ operators (``/=``).; Note that things like ""pointer"" and ""reference"" are not keywords. On the other; hand, you *can* include anything that comes from the user's source code,; including variable names, types, labels, etc. The ""``select``"" format can be; used to achieve this sort of thing in a localizable way, see below. Formatting a Diagnostic Argument; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Arguments to diagnostics are fully typed internally, and come from a couple; different classes: integers, types, names, and random strings. Depending on; the class of the argument, it can be optionally formatted in different ways.; This gives the ``DiagnosticConsumer`` information about what the argument means; without requiring it to use a specific presentation (consider this MVC for; Clang :). It is really easy to add format specifiers to the Clang diagnostics system, but; they should be discussed before they are added. If you are creating a lot of; repetitive diagnostics and/or have an idea for a useful formatter, please bring; it up on the cfe-dev mailing list. Here are the different diagnostic argument formats currently supported by; Clang:. **""s"" f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:18524,Modifiability,rewrite,rewrite,18524,"ciding exactly what you need to say to help the user,; picking a suitable wording, and providing the information needed to format it; correctly. The good news is that the call site that issues a diagnostic should; be completely independent of how the diagnostic is formatted and in what; language it is rendered. Fix-It Hints; ^^^^^^^^^^^^. In some cases, the front end emits diagnostics when it is clear that some small; change to the source code would fix the problem. For example, a missing; semicolon at the end of a statement or a use of deprecated syntax that is; easily rewritten into a more modern form. Clang tries very hard to emit the; diagnostic and recover gracefully in these and other cases. However, for these cases where the fix is obvious, the diagnostic can be; annotated with a hint (referred to as a ""fix-it hint"") that describes how to; change the code referenced by the diagnostic to fix the problem. For example,; it might add the missing semicolon at the end of the statement or rewrite the; use of a deprecated construct into something more palatable. Here is one such; example from the C++ front end, where we warn about the right-shift operator; changing meaning from C++98 to C++11:. .. code-block:: text. test.cpp:3:7: warning: use of right-shift operator ('>>') in template argument; will require parentheses in C++11; A<100 >> 2> *a;; ^; ( ). Here, the fix-it hint is suggesting that parentheses be added, and showing; exactly where those parentheses would be inserted into the source code. The; fix-it hints themselves describe what changes to make to the source code in an; abstract manner, which the text diagnostic printer renders as a line of; ""insertions"" below the caret line. :ref:`Other diagnostic clients; <DiagnosticConsumer>` might choose to render the code differently (e.g., as; markup inline) or even give the user the ability to automatically fix the; problem. Fix-it hints on errors and warnings need to obey these rules:. * Since they are automatical",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:28656,Modifiability,variab,variable,28656," the build. Options are then used for querying an; instance ``llvm::opt::ArgList``, a wrapper around the command line arguments.; This is done in the Clang driver to construct individual jobs based on the; driver arguments and also in the ``CompilerInvocation::CreateFromArgs`` function; that parses the ``-cc1`` frontend arguments. Command Line Generation; -----------------------. Any valid ``CompilerInvocation`` created from a ``-cc1`` command line can be; also serialized back into semantically equivalent command line in a; deterministic manner. This enables features such as implicitly discovered,; explicitly built modules. ..; TODO: Create and link corresponding section in Modules.rst. Adding new Command Line Option; ------------------------------. When adding a new command line option, the first place of interest is the header; file declaring the corresponding options class (e.g. ``CodeGenOptions.h`` for; command line option that affects the code generation). Create new member; variable for the option value:. .. code-block:: diff. class CodeGenOptions : public CodeGenOptionsBase {. + /// List of dynamic shared object files to be loaded as pass plugins.; + std::vector<std::string> PassPlugins;. }. Next, declare the command line interface of the option in the tablegen file; ``clang/include/clang/Driver/Options.td``. This is done by instantiating the; ``Option`` class (defined in ``llvm/include/llvm/Option/OptParser.td``). The; instance is typically created through one of the helper classes that encode the; acceptable ways to specify the option value on the command line:. * ``Flag`` - the option does not accept any value,; * ``Joined`` - the value must immediately follow the option name within the same; argument,; * ``Separate`` - the value must follow the option name in the next command line; argument,; * ``JoinedOrSeparate`` - the value can be specified either as ``Joined`` or; ``Separate``,; * ``CommaJoined`` - the values are comma-separated and must immediately fo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:28825,Modifiability,plugin,plugins,28825,"s done in the Clang driver to construct individual jobs based on the; driver arguments and also in the ``CompilerInvocation::CreateFromArgs`` function; that parses the ``-cc1`` frontend arguments. Command Line Generation; -----------------------. Any valid ``CompilerInvocation`` created from a ``-cc1`` command line can be; also serialized back into semantically equivalent command line in a; deterministic manner. This enables features such as implicitly discovered,; explicitly built modules. ..; TODO: Create and link corresponding section in Modules.rst. Adding new Command Line Option; ------------------------------. When adding a new command line option, the first place of interest is the header; file declaring the corresponding options class (e.g. ``CodeGenOptions.h`` for; command line option that affects the code generation). Create new member; variable for the option value:. .. code-block:: diff. class CodeGenOptions : public CodeGenOptionsBase {. + /// List of dynamic shared object files to be loaded as pass plugins.; + std::vector<std::string> PassPlugins;. }. Next, declare the command line interface of the option in the tablegen file; ``clang/include/clang/Driver/Options.td``. This is done by instantiating the; ``Option`` class (defined in ``llvm/include/llvm/Option/OptParser.td``). The; instance is typically created through one of the helper classes that encode the; acceptable ways to specify the option value on the command line:. * ``Flag`` - the option does not accept any value,; * ``Joined`` - the value must immediately follow the option name within the same; argument,; * ``Separate`` - the value must follow the option name in the next command line; argument,; * ``JoinedOrSeparate`` - the value can be specified either as ``Joined`` or; ``Separate``,; * ``CommaJoined`` - the values are comma-separated and must immediately follow; the option name within the same argument (see ``Wl,`` for an example). The helper classes take a list of acceptable prefixes of t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:29948,Modifiability,plugin,plugin,29948,"ion in the tablegen file; ``clang/include/clang/Driver/Options.td``. This is done by instantiating the; ``Option`` class (defined in ``llvm/include/llvm/Option/OptParser.td``). The; instance is typically created through one of the helper classes that encode the; acceptable ways to specify the option value on the command line:. * ``Flag`` - the option does not accept any value,; * ``Joined`` - the value must immediately follow the option name within the same; argument,; * ``Separate`` - the value must follow the option name in the next command line; argument,; * ``JoinedOrSeparate`` - the value can be specified either as ``Joined`` or; ``Separate``,; * ``CommaJoined`` - the values are comma-separated and must immediately follow; the option name within the same argument (see ``Wl,`` for an example). The helper classes take a list of acceptable prefixes of the option (e.g.; ``""-""``, ``""--""`` or ``""/""``) and the option name:. .. code-block:: diff. // Options.td. + def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">;. Then, specify additional attributes via mix-ins:. * ``HelpText`` holds the text that will be printed besides the option name when; the user requests help (e.g. via ``clang --help``).; * ``Group`` specifies the ""category"" of options this option belongs to. This is; used by various tools to categorize and sometimes filter options.; * ``Flags`` may contain ""tags"" associated with the option. These may affect how; the option is rendered, or if it's hidden in some contexts.; * ``Visibility`` should be used to specify the drivers in which a particular; option would be available. This attribute will impact tool --help; * ``Alias`` denotes that the option is an alias of another option. This may be; combined with ``AliasArgs`` that holds the implied value. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; + Group<f_Group>, Visibility<[ClangOption, CC1Option]>,; + HelpText<""Load pass plugin from a dynamic shared object file."">",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:30797,Modifiability,plugin,plugin,30797,"`) and the option name:. .. code-block:: diff. // Options.td. + def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">;. Then, specify additional attributes via mix-ins:. * ``HelpText`` holds the text that will be printed besides the option name when; the user requests help (e.g. via ``clang --help``).; * ``Group`` specifies the ""category"" of options this option belongs to. This is; used by various tools to categorize and sometimes filter options.; * ``Flags`` may contain ""tags"" associated with the option. These may affect how; the option is rendered, or if it's hidden in some contexts.; * ``Visibility`` should be used to specify the drivers in which a particular; option would be available. This attribute will impact tool --help; * ``Alias`` denotes that the option is an alias of another option. This may be; combined with ``AliasArgs`` that holds the implied value. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; + Group<f_Group>, Visibility<[ClangOption, CC1Option]>,; + HelpText<""Load pass plugin from a dynamic shared object file."">;. New options are recognized by the ``clang`` driver mode if ``Visibility`` is; not specified or contains ``ClangOption``. Options intended for ``clang -cc1``; must be explicitly marked with the ``CC1Option`` flag. Flags that specify; ``CC1Option`` but not ``ClangOption`` will only be accessible via ``-cc1``.; This is similar for other driver modes, such as ``clang-cl`` or ``flang``. Next, parse (or manufacture) the command line arguments in the Clang driver and; use them to construct the ``-cc1`` job:. .. code-block:: diff. void Clang::ConstructJob(const ArgList &Args /*...*/) const {; ArgStringList CmdArgs;; // ... + for (const Arg *A : Args.filtered(OPT_fpass_plugin_EQ)) {; + CmdArgs.push_back(Args.MakeArgString(Twine(""-fpass-plugin="") + A->getValue()));; + A->claim();; + }; }. The last step is implementing the ``-cc1`` command line argument; parsing/generation that initializes/serializes the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:30888,Modifiability,plugin,plugin,30888,"`) and the option name:. .. code-block:: diff. // Options.td. + def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">;. Then, specify additional attributes via mix-ins:. * ``HelpText`` holds the text that will be printed besides the option name when; the user requests help (e.g. via ``clang --help``).; * ``Group`` specifies the ""category"" of options this option belongs to. This is; used by various tools to categorize and sometimes filter options.; * ``Flags`` may contain ""tags"" associated with the option. These may affect how; the option is rendered, or if it's hidden in some contexts.; * ``Visibility`` should be used to specify the drivers in which a particular; option would be available. This attribute will impact tool --help; * ``Alias`` denotes that the option is an alias of another option. This may be; combined with ``AliasArgs`` that holds the implied value. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; + Group<f_Group>, Visibility<[ClangOption, CC1Option]>,; + HelpText<""Load pass plugin from a dynamic shared object file."">;. New options are recognized by the ``clang`` driver mode if ``Visibility`` is; not specified or contains ``ClangOption``. Options intended for ``clang -cc1``; must be explicitly marked with the ``CC1Option`` flag. Flags that specify; ``CC1Option`` but not ``ClangOption`` will only be accessible via ``-cc1``.; This is similar for other driver modes, such as ``clang-cl`` or ``flang``. Next, parse (or manufacture) the command line arguments in the Clang driver and; use them to construct the ``-cc1`` job:. .. code-block:: diff. void Clang::ConstructJob(const ArgList &Args /*...*/) const {; ArgStringList CmdArgs;; // ... + for (const Arg *A : Args.filtered(OPT_fpass_plugin_EQ)) {; + CmdArgs.push_back(Args.MakeArgString(Twine(""-fpass-plugin="") + A->getValue()));; + A->claim();; + }; }. The last step is implementing the ``-cc1`` command line argument; parsing/generation that initializes/serializes the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:31671,Modifiability,plugin,plugin,31671,"s`` that holds the implied value. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; + Group<f_Group>, Visibility<[ClangOption, CC1Option]>,; + HelpText<""Load pass plugin from a dynamic shared object file."">;. New options are recognized by the ``clang`` driver mode if ``Visibility`` is; not specified or contains ``ClangOption``. Options intended for ``clang -cc1``; must be explicitly marked with the ``CC1Option`` flag. Flags that specify; ``CC1Option`` but not ``ClangOption`` will only be accessible via ``-cc1``.; This is similar for other driver modes, such as ``clang-cl`` or ``flang``. Next, parse (or manufacture) the command line arguments in the Clang driver and; use them to construct the ``-cc1`` job:. .. code-block:: diff. void Clang::ConstructJob(const ArgList &Args /*...*/) const {; ArgStringList CmdArgs;; // ... + for (const Arg *A : Args.filtered(OPT_fpass_plugin_EQ)) {; + CmdArgs.push_back(Args.MakeArgString(Twine(""-fpass-plugin="") + A->getValue()));; + A->claim();; + }; }. The last step is implementing the ``-cc1`` command line argument; parsing/generation that initializes/serializes the option class (in our case; ``CodeGenOptions``) stored within ``CompilerInvocation``. This can be done; automatically by using the marshalling annotations on the option definition:. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; Group<f_Group>, Flags<[CC1Option]>,; HelpText<""Load pass plugin from a dynamic shared object file."">,; + MarshallingInfoStringVector<CodeGenOpts<""PassPlugins"">>;. Inner workings of the system are introduced in the :ref:`marshalling; infrastructure <OptionMarshalling>` section and the available annotations are; listed :ref:`here <OptionMarshallingAnnotations>`. In case the marshalling infrastructure does not support the desired semantics,; consider simplifying it to fit the existing model. This makes the command line; more uniform and reduces the amount of custom,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:32102,Modifiability,plugin,plugin,32102,"ion`` flag. Flags that specify; ``CC1Option`` but not ``ClangOption`` will only be accessible via ``-cc1``.; This is similar for other driver modes, such as ``clang-cl`` or ``flang``. Next, parse (or manufacture) the command line arguments in the Clang driver and; use them to construct the ``-cc1`` job:. .. code-block:: diff. void Clang::ConstructJob(const ArgList &Args /*...*/) const {; ArgStringList CmdArgs;; // ... + for (const Arg *A : Args.filtered(OPT_fpass_plugin_EQ)) {; + CmdArgs.push_back(Args.MakeArgString(Twine(""-fpass-plugin="") + A->getValue()));; + A->claim();; + }; }. The last step is implementing the ``-cc1`` command line argument; parsing/generation that initializes/serializes the option class (in our case; ``CodeGenOptions``) stored within ``CompilerInvocation``. This can be done; automatically by using the marshalling annotations on the option definition:. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; Group<f_Group>, Flags<[CC1Option]>,; HelpText<""Load pass plugin from a dynamic shared object file."">,; + MarshallingInfoStringVector<CodeGenOpts<""PassPlugins"">>;. Inner workings of the system are introduced in the :ref:`marshalling; infrastructure <OptionMarshalling>` section and the available annotations are; listed :ref:`here <OptionMarshallingAnnotations>`. In case the marshalling infrastructure does not support the desired semantics,; consider simplifying it to fit the existing model. This makes the command line; more uniform and reduces the amount of custom, manually written code. Remember; that the ``-cc1`` command line interface is intended only for Clang developers,; meaning it does not need to mirror the driver interface, maintain backward; compatibility or be compatible with GCC. If the option semantics cannot be encoded via marshalling annotations, you can; resort to parsing/serializing the command line arguments manually:. .. code-block:: diff. // CompilerInvocation.cpp. static bool ParseCodeGe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:32171,Modifiability,plugin,plugin,32171,"ion`` flag. Flags that specify; ``CC1Option`` but not ``ClangOption`` will only be accessible via ``-cc1``.; This is similar for other driver modes, such as ``clang-cl`` or ``flang``. Next, parse (or manufacture) the command line arguments in the Clang driver and; use them to construct the ``-cc1`` job:. .. code-block:: diff. void Clang::ConstructJob(const ArgList &Args /*...*/) const {; ArgStringList CmdArgs;; // ... + for (const Arg *A : Args.filtered(OPT_fpass_plugin_EQ)) {; + CmdArgs.push_back(Args.MakeArgString(Twine(""-fpass-plugin="") + A->getValue()));; + A->claim();; + }; }. The last step is implementing the ``-cc1`` command line argument; parsing/generation that initializes/serializes the option class (in our case; ``CodeGenOptions``) stored within ``CompilerInvocation``. This can be done; automatically by using the marshalling annotations on the option definition:. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; Group<f_Group>, Flags<[CC1Option]>,; HelpText<""Load pass plugin from a dynamic shared object file."">,; + MarshallingInfoStringVector<CodeGenOpts<""PassPlugins"">>;. Inner workings of the system are introduced in the :ref:`marshalling; infrastructure <OptionMarshalling>` section and the available annotations are; listed :ref:`here <OptionMarshallingAnnotations>`. In case the marshalling infrastructure does not support the desired semantics,; consider simplifying it to fit the existing model. This makes the command line; more uniform and reduces the amount of custom, manually written code. Remember; that the ``-cc1`` command line interface is intended only for Clang developers,; meaning it does not need to mirror the driver interface, maintain backward; compatibility or be compatible with GCC. If the option semantics cannot be encoded via marshalling annotations, you can; resort to parsing/serializing the command line arguments manually:. .. code-block:: diff. // CompilerInvocation.cpp. static bool ParseCodeGe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:33616,Modifiability,plugin,plugin,33616,"makes the command line; more uniform and reduces the amount of custom, manually written code. Remember; that the ``-cc1`` command line interface is intended only for Clang developers,; meaning it does not need to mirror the driver interface, maintain backward; compatibility or be compatible with GCC. If the option semantics cannot be encoded via marshalling annotations, you can; resort to parsing/serializing the command line arguments manually:. .. code-block:: diff. // CompilerInvocation.cpp. static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args /*...*/) {; // ... + Opts.PassPlugins = Args.getAllArgValues(OPT_fpass_plugin_EQ);; }. static void GenerateCodeGenArgs(const CodeGenOptions &Opts,; SmallVectorImpl<const char *> &Args,; CompilerInvocation::StringAllocator SA /*...*/) {; // ... + for (const std::string &PassPlugin : Opts.PassPlugins); + GenerateArg(Args, OPT_fpass_plugin_EQ, PassPlugin, SA);; }. Finally, you can specify the argument on the command line:; ``clang -fpass-plugin=a -fpass-plugin=b`` and use the new member variable as; desired. .. code-block:: diff. void EmitAssemblyHelper::EmitAssemblyWithNewPassManager(/*...*/) {; // ...; + for (auto &PluginFN : CodeGenOpts.PassPlugins); + if (auto PassPlugin = PassPlugin::Load(PluginFN)); + PassPlugin->registerPassBuilderCallbacks(PB);; }. .. _OptionMarshalling:. Option Marshalling Infrastructure; ---------------------------------. The option marshalling infrastructure automates the parsing of the Clang; ``-cc1`` frontend command line arguments into ``CompilerInvocation`` and their; generation from ``CompilerInvocation``. The system replaces lots of repetitive; C++ code with simple, declarative tablegen annotations and it's being used for; the majority of the ``-cc1`` command line interface. This section provides an; overview of the system. **Note:** The marshalling infrastructure is not intended for driver-only; options. Only options of the ``-cc1`` frontend need to be marshalled to/from; ``Compiler",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:33632,Modifiability,plugin,plugin,33632,"makes the command line; more uniform and reduces the amount of custom, manually written code. Remember; that the ``-cc1`` command line interface is intended only for Clang developers,; meaning it does not need to mirror the driver interface, maintain backward; compatibility or be compatible with GCC. If the option semantics cannot be encoded via marshalling annotations, you can; resort to parsing/serializing the command line arguments manually:. .. code-block:: diff. // CompilerInvocation.cpp. static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args /*...*/) {; // ... + Opts.PassPlugins = Args.getAllArgValues(OPT_fpass_plugin_EQ);; }. static void GenerateCodeGenArgs(const CodeGenOptions &Opts,; SmallVectorImpl<const char *> &Args,; CompilerInvocation::StringAllocator SA /*...*/) {; // ... + for (const std::string &PassPlugin : Opts.PassPlugins); + GenerateArg(Args, OPT_fpass_plugin_EQ, PassPlugin, SA);; }. Finally, you can specify the argument on the command line:; ``clang -fpass-plugin=a -fpass-plugin=b`` and use the new member variable as; desired. .. code-block:: diff. void EmitAssemblyHelper::EmitAssemblyWithNewPassManager(/*...*/) {; // ...; + for (auto &PluginFN : CodeGenOpts.PassPlugins); + if (auto PassPlugin = PassPlugin::Load(PluginFN)); + PassPlugin->registerPassBuilderCallbacks(PB);; }. .. _OptionMarshalling:. Option Marshalling Infrastructure; ---------------------------------. The option marshalling infrastructure automates the parsing of the Clang; ``-cc1`` frontend command line arguments into ``CompilerInvocation`` and their; generation from ``CompilerInvocation``. The system replaces lots of repetitive; C++ code with simple, declarative tablegen annotations and it's being used for; the majority of the ``-cc1`` command line interface. This section provides an; overview of the system. **Note:** The marshalling infrastructure is not intended for driver-only; options. Only options of the ``-cc1`` frontend need to be marshalled to/from; ``Compiler",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:33666,Modifiability,variab,variable,33666,"makes the command line; more uniform and reduces the amount of custom, manually written code. Remember; that the ``-cc1`` command line interface is intended only for Clang developers,; meaning it does not need to mirror the driver interface, maintain backward; compatibility or be compatible with GCC. If the option semantics cannot be encoded via marshalling annotations, you can; resort to parsing/serializing the command line arguments manually:. .. code-block:: diff. // CompilerInvocation.cpp. static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args /*...*/) {; // ... + Opts.PassPlugins = Args.getAllArgValues(OPT_fpass_plugin_EQ);; }. static void GenerateCodeGenArgs(const CodeGenOptions &Opts,; SmallVectorImpl<const char *> &Args,; CompilerInvocation::StringAllocator SA /*...*/) {; // ... + for (const std::string &PassPlugin : Opts.PassPlugins); + GenerateArg(Args, OPT_fpass_plugin_EQ, PassPlugin, SA);; }. Finally, you can specify the argument on the command line:; ``clang -fpass-plugin=a -fpass-plugin=b`` and use the new member variable as; desired. .. code-block:: diff. void EmitAssemblyHelper::EmitAssemblyWithNewPassManager(/*...*/) {; // ...; + for (auto &PluginFN : CodeGenOpts.PassPlugins); + if (auto PassPlugin = PassPlugin::Load(PluginFN)); + PassPlugin->registerPassBuilderCallbacks(PB);; }. .. _OptionMarshalling:. Option Marshalling Infrastructure; ---------------------------------. The option marshalling infrastructure automates the parsing of the Clang; ``-cc1`` frontend command line arguments into ``CompilerInvocation`` and their; generation from ``CompilerInvocation``. The system replaces lots of repetitive; C++ code with simple, declarative tablegen annotations and it's being used for; the majority of the ``-cc1`` command line interface. This section provides an; overview of the system. **Note:** The marshalling infrastructure is not intended for driver-only; options. Only options of the ``-cc1`` frontend need to be marshalled to/from; ``Compiler",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:34847,Modifiability,inherit,inheriting,34847,"ssPlugins); + if (auto PassPlugin = PassPlugin::Load(PluginFN)); + PassPlugin->registerPassBuilderCallbacks(PB);; }. .. _OptionMarshalling:. Option Marshalling Infrastructure; ---------------------------------. The option marshalling infrastructure automates the parsing of the Clang; ``-cc1`` frontend command line arguments into ``CompilerInvocation`` and their; generation from ``CompilerInvocation``. The system replaces lots of repetitive; C++ code with simple, declarative tablegen annotations and it's being used for; the majority of the ``-cc1`` command line interface. This section provides an; overview of the system. **Note:** The marshalling infrastructure is not intended for driver-only; options. Only options of the ``-cc1`` frontend need to be marshalled to/from; ``CompilerInvocation`` instance. To read and modify contents of ``CompilerInvocation``, the marshalling system; uses key paths, which are declared in two steps. First, a tablegen definition; for the ``CompilerInvocation`` member is created by inheriting from; ``KeyPathAndMacro``:. .. code-block:: text. // Options.td. class LangOpts<string field> : KeyPathAndMacro<""LangOpts->"", field, ""LANG_""> {}; // CompilerInvocation member ^^^^^^^^^^; // OPTION_WITH_MARSHALLING prefix ^^^^^. The first argument to the parent class is the beginning of the key path that; references the ``CompilerInvocation`` member. This argument ends with ``->`` if; the member is a pointer type or with ``.`` if it's a value type. The child class; takes a single parameter ``field`` that is forwarded as the second argument to; the base class. The child class can then be used like so:; ``LangOpts<""IgnoreExceptions"">``, constructing a key path to the field; ``LangOpts->IgnoreExceptions``. The third argument passed to the parent class is; a string that the tablegen backend uses as a prefix to the; ``OPTION_WITH_MARSHALLING`` macro. Using the key path as a mix-in on an; ``Option`` instance instructs the backend to generate the following code",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:48441,Modifiability,variab,variable,48441,"e definition of this flag is very closely defined by the; stringizing requirements of the preprocessor.; #. **DisableExpand** --- This flag is used internally to the preprocessor to; represent identifier tokens which have macro expansion disabled. This; prevents them from being considered as candidates for macro expansion ever; in the future.; #. **NeedsCleaning** --- This flag is set if the original spelling for the; token includes a trigraph or escaped newline. Since this is uncommon,; many pieces of code can fast-path on tokens that did not need cleaning. One interesting (and somewhat unusual) aspect of normal tokens is that they; don't contain any semantic information about the lexed value. For example, if; the token was a pp-number token, we do not represent the value of the number; that was lexed (this is left for later pieces of code to decide).; Additionally, the lexer library has no notion of typedef names vs variable; names: both are returned as identifiers, and the parser is left to decide; whether a specific identifier is a typedef or a variable (tracking this; requires scope information among other things). The parser can do this; translation by replacing tokens returned by the preprocessor with ""Annotation; Tokens"". .. _AnnotationToken:. Annotation Tokens; -----------------. Annotation tokens are tokens that are synthesized by the parser and injected; into the preprocessor's token stream (replacing existing tokens) to record; semantic information found by the parser. For example, if ""``foo``"" is found; to be a typedef, the ""``foo``"" ``tok::identifier`` token is replaced with an; ``tok::annot_typename``. This is useful for a couple of reasons: 1) this makes; it easy to handle qualified type names (e.g., ""``foo::bar::baz<42>::t``"") in; C++ as a single ""token"" in the parser. 2) if the parser backtracks, the; reparse does not need to redo semantic analysis to determine whether a token; sequence is a variable, type, template, etc. Annotation tokens are creat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:48574,Modifiability,variab,variable,48574,"e definition of this flag is very closely defined by the; stringizing requirements of the preprocessor.; #. **DisableExpand** --- This flag is used internally to the preprocessor to; represent identifier tokens which have macro expansion disabled. This; prevents them from being considered as candidates for macro expansion ever; in the future.; #. **NeedsCleaning** --- This flag is set if the original spelling for the; token includes a trigraph or escaped newline. Since this is uncommon,; many pieces of code can fast-path on tokens that did not need cleaning. One interesting (and somewhat unusual) aspect of normal tokens is that they; don't contain any semantic information about the lexed value. For example, if; the token was a pp-number token, we do not represent the value of the number; that was lexed (this is left for later pieces of code to decide).; Additionally, the lexer library has no notion of typedef names vs variable; names: both are returned as identifiers, and the parser is left to decide; whether a specific identifier is a typedef or a variable (tracking this; requires scope information among other things). The parser can do this; translation by replacing tokens returned by the preprocessor with ""Annotation; Tokens"". .. _AnnotationToken:. Annotation Tokens; -----------------. Annotation tokens are tokens that are synthesized by the parser and injected; into the preprocessor's token stream (replacing existing tokens) to record; semantic information found by the parser. For example, if ""``foo``"" is found; to be a typedef, the ""``foo``"" ``tok::identifier`` token is replaced with an; ``tok::annot_typename``. This is useful for a couple of reasons: 1) this makes; it easy to handle qualified type names (e.g., ""``foo::bar::baz<42>::t``"") in; C++ as a single ""token"" in the parser. 2) if the parser backtracks, the; reparse does not need to redo semantic analysis to determine whether a token; sequence is a variable, type, template, etc. Annotation tokens are creat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:49452,Modifiability,variab,variable,49452,"ary has no notion of typedef names vs variable; names: both are returned as identifiers, and the parser is left to decide; whether a specific identifier is a typedef or a variable (tracking this; requires scope information among other things). The parser can do this; translation by replacing tokens returned by the preprocessor with ""Annotation; Tokens"". .. _AnnotationToken:. Annotation Tokens; -----------------. Annotation tokens are tokens that are synthesized by the parser and injected; into the preprocessor's token stream (replacing existing tokens) to record; semantic information found by the parser. For example, if ""``foo``"" is found; to be a typedef, the ""``foo``"" ``tok::identifier`` token is replaced with an; ``tok::annot_typename``. This is useful for a couple of reasons: 1) this makes; it easy to handle qualified type names (e.g., ""``foo::bar::baz<42>::t``"") in; C++ as a single ""token"" in the parser. 2) if the parser backtracks, the; reparse does not need to redo semantic analysis to determine whether a token; sequence is a variable, type, template, etc. Annotation tokens are created by the parser and reinjected into the parser's; token stream (when backtracking is enabled). Because they can only exist in; tokens that the preprocessor-proper is done with, it doesn't need to keep; around flags like ""start of line"" that the preprocessor uses to do its job.; Additionally, an annotation token may ""cover"" a sequence of preprocessor tokens; (e.g., ""``a::b::c``"" is five preprocessor tokens). As such, the valid fields; of an annotation token are different than the fields for a normal token (but; they are multiplexed into the normal ``Token`` fields):. * **SourceLocation ""Location""** --- The ``SourceLocation`` for the annotation; token indicates the first token replaced by the annotation token. In the; example above, it would be the location of the ""``a``"" identifier.; * **SourceLocation ""AnnotationEndLoc""** --- This holds the location of the last; token replaced wit",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:60038,Modifiability,refactor,refactoring,60038," of a; template, rather than having distinct declarations for an instantiation of; the declaration versus the definition, so template instantiation often; updates parts of existing declarations.; * Some parts of declarations are required to be instantiated separately (this; includes default arguments and exception specifications), and such; instantiations update the existing declaration. These cases tend to be fragile; mutable AST state should be avoided where; possible. As a consequence of this design principle, we typically do not provide setters; for AST state. (Some are provided for short-term modifications intended to be; used immediately after an AST node is created and before it's ""published"" as; part of the complete AST, or where language semantics require after-the-fact; updates.). Faithfulness; ^^^^^^^^^^^^. The AST intends to provide a representation of the program that is faithful to; the original source. We intend for it to be possible to write refactoring tools; using only information stored in, or easily reconstructible from, the Clang AST.; This means that the AST representation should either not desugar source-level; constructs to simpler forms, or -- where made necessary by language semantics; or a clear engineering tradeoff -- should desugar minimally and wrap the result; in a construct representing the original source form. For example, ``CXXForRangeStmt`` directly represents the syntactic form of a; range-based for statement, but also holds a semantic representation of the; range declaration and iterator declarations. It does not contain a; fully-desugared ``ForStmt``, however. Some AST nodes (for example, ``ParenExpr``) represent only syntax, and others; (for example, ``ImplicitCastExpr``) represent only semantics, but most nodes; will represent a combination of syntax and associated semantics. Inheritance; is typically used when representing different (but related) syntaxes for nodes; with the same or similar semantics. .. _Type:. The ``Type`` ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:66745,Modifiability,extend,extended,66745,"the; typedef information in the program. If the type of the expression is literally; a ``PointerType``, we can return that, otherwise we have to dig through the; typedefs to find the pointer type. For example, if the subexpression had type; ""``foo*``"", we could return that type as the result. If the subexpression had; type ""``bar``"", we want to return ""``foo*``"" (note that we do *not* want; ""``int*``""). In order to provide all of this, ``Type`` has a; ``getAsPointerType()`` method that checks whether the type is structurally a; ``PointerType`` and, if so, returns the best one. If not, it returns a null; pointer. This structure is somewhat mystical, but after meditating on it, it will make; sense to you :). .. _QualType:. The ``QualType`` class; ----------------------. The ``QualType`` class is designed as a trivial value class that is small,; passed by-value and is efficient to query. The idea of ``QualType`` is that it; stores the type qualifiers (``const``, ``volatile``, ``restrict``, plus some; extended qualifiers required by language extensions) separately from the types; themselves. ``QualType`` is conceptually a pair of ""``Type*``"" and the bits; for these type qualifiers. By storing the type qualifiers as bits in the conceptual pair, it is extremely; efficient to get the set of qualifiers on a ``QualType`` (just return the field; of the pair), add a type qualifier (which is a trivial constant-time operation; that sets a bit), and remove one or more type qualifiers (just return a; ``QualType`` with the bitfield set to empty). Further, because the bits are stored outside of the type itself, we do not need; to create duplicates of types with different sets of qualifiers (i.e. there is; only a single heap allocated ""``int``"" type: ""``const int``"" and ""``volatile; const int``"" both point to the same heap allocated ""``int``"" type). This; reduces the heap size used to represent bits and also means we do not have to; consider qualifiers when uniquing types (:ref:`Type ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:67963,Modifiability,extend,extended,67963," for these type qualifiers. By storing the type qualifiers as bits in the conceptual pair, it is extremely; efficient to get the set of qualifiers on a ``QualType`` (just return the field; of the pair), add a type qualifier (which is a trivial constant-time operation; that sets a bit), and remove one or more type qualifiers (just return a; ``QualType`` with the bitfield set to empty). Further, because the bits are stored outside of the type itself, we do not need; to create duplicates of types with different sets of qualifiers (i.e. there is; only a single heap allocated ""``int``"" type: ""``const int``"" and ""``volatile; const int``"" both point to the same heap allocated ""``int``"" type). This; reduces the heap size used to represent bits and also means we do not have to; consider qualifiers when uniquing types (:ref:`Type <Type>` does not even; contain qualifiers). In practice, the two most common type qualifiers (``const`` and ``restrict``); are stored in the low bits of the pointer to the ``Type`` object, together with; a flag indicating whether extended qualifiers are present (which must be; heap-allocated). This means that ``QualType`` is exactly the same size as a; pointer. .. _DeclarationName:. Declaration names; -----------------. The ``DeclarationName`` class represents the name of a declaration in Clang.; Declarations in the C family of languages can take several different forms.; Most declarations are named by simple identifiers, e.g., ""``f``"" and ""``x``"" in; the function declaration ``f(int x)``. In C++, declaration names can also name; class constructors (""``Class``"" in ``struct Class { Class(); }``), class; destructors (""``~Class``""), overloaded operator names (""``operator+``""), and; conversion functions (""``operator void const *``""). In Objective-C,; declaration names can refer to the names of Objective-C methods, which involve; the method name and the parameters, collectively called a *selector*, e.g.,; ""``setWidth:height:``"". Since all of these kinds of",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:68916,Modifiability,variab,variables,68916,"p-allocated). This means that ``QualType`` is exactly the same size as a; pointer. .. _DeclarationName:. Declaration names; -----------------. The ``DeclarationName`` class represents the name of a declaration in Clang.; Declarations in the C family of languages can take several different forms.; Most declarations are named by simple identifiers, e.g., ""``f``"" and ""``x``"" in; the function declaration ``f(int x)``. In C++, declaration names can also name; class constructors (""``Class``"" in ``struct Class { Class(); }``), class; destructors (""``~Class``""), overloaded operator names (""``operator+``""), and; conversion functions (""``operator void const *``""). In Objective-C,; declaration names can refer to the names of Objective-C methods, which involve; the method name and the parameters, collectively called a *selector*, e.g.,; ""``setWidth:height:``"". Since all of these kinds of entities --- variables,; functions, Objective-C methods, C++ constructors, destructors, and operators; --- are represented as subclasses of Clang's common ``NamedDecl`` class,; ``DeclarationName`` is designed to efficiently represent any kind of name. Given a ``DeclarationName`` ``N``, ``N.getNameKind()`` will produce a value; that describes what kind of name ``N`` stores. There are 10 options (all of; the names are inside the ``DeclarationName`` class). ``Identifier``. The name is a simple identifier. Use ``N.getAsIdentifierInfo()`` to retrieve; the corresponding ``IdentifierInfo*`` pointing to the actual identifier. ``ObjCZeroArgSelector``, ``ObjCOneArgSelector``, ``ObjCMultiArgSelector``. The name is an Objective-C selector, which can be retrieved as a ``Selector``; instance via ``N.getObjCSelector()``. The three possible name kinds for; Objective-C reflect an optimization within the ``DeclarationName`` class:; both zero- and one-argument selectors are stored as a masked; ``IdentifierInfo`` pointer, and therefore require very little space, since; zero- and one-argument selectors are far more",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:92196,Modifiability,variab,variable,92196,"two; nodes: between the *templated* and the *described* node. There may be various; other kinds of cycles in the AST especially in case of declarations. .. _structural-eq:. Structural Equivalency; ^^^^^^^^^^^^^^^^^^^^^^. Importing one AST node copies that node into the destination ``ASTContext``. To; copy one node means that we create a new node in the ""to"" context then we set; its properties to be equal to the properties of the source node. Before the; copy, we make sure that the source node is not *structurally equivalent* to any; existing node in the destination context. If it happens to be equivalent then; we skip the copy. The informal definition of structural equivalency is the following:; Two nodes are **structurally equivalent** if they are. - builtin types and refer to the same type, e.g. ``int`` and ``int`` are; structurally equivalent,; - function types and all their parameters have structurally equivalent types,; - record types and all their fields in order of their definition have the same; identifier names and structurally equivalent types,; - variable or function declarations and they have the same identifier name and; their types are structurally equivalent. In C, two types are structurally equivalent if they are *compatible types*. For; a formal definition of *compatible types*, please refer to 6.2.7/1 in the C11; standard. However, there is no definition for *compatible types* in the C++; standard. Still, we extend the definition of structural equivalency to; templates and their instantiations similarly: besides checking the previously; mentioned properties, we have to check for equivalent template; parameters/arguments, etc. The structural equivalent check can be and is used independently from the; ASTImporter, e.g. the ``clang::Sema`` class uses it also. The equivalence of nodes may depend on the equivalency of other pairs of nodes.; Thus, the check is implemented as a parallel graph traversal. We traverse; through the nodes of both graphs at the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:92572,Modifiability,extend,extend,92572," the destination context. If it happens to be equivalent then; we skip the copy. The informal definition of structural equivalency is the following:; Two nodes are **structurally equivalent** if they are. - builtin types and refer to the same type, e.g. ``int`` and ``int`` are; structurally equivalent,; - function types and all their parameters have structurally equivalent types,; - record types and all their fields in order of their definition have the same; identifier names and structurally equivalent types,; - variable or function declarations and they have the same identifier name and; their types are structurally equivalent. In C, two types are structurally equivalent if they are *compatible types*. For; a formal definition of *compatible types*, please refer to 6.2.7/1 in the C11; standard. However, there is no definition for *compatible types* in the C++; standard. Still, we extend the definition of structural equivalency to; templates and their instantiations similarly: besides checking the previously; mentioned properties, we have to check for equivalent template; parameters/arguments, etc. The structural equivalent check can be and is used independently from the; ASTImporter, e.g. the ``clang::Sema`` class uses it also. The equivalence of nodes may depend on the equivalency of other pairs of nodes.; Thus, the check is implemented as a parallel graph traversal. We traverse; through the nodes of both graphs at the same time. The actual implementation is; similar to breadth-first-search. Let's say we start the traverse with the <A,B>; pair of nodes. Whenever the traversal reaches a pair <X,Y> then the following; statements are true:. - A and X are nodes from the same ASTContext.; - B and Y are nodes from the same ASTContext.; - A and B may or may not be from the same ASTContext.; - if A == X and B == Y (pointer equivalency) then (there is a cycle during the; traverse). - A and B are structurally equivalent if and only if. - All dependent nodes on the path fro",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:110026,Modifiability,variab,variable,110026," the member ``a`` to ``3``, thus the ``InitListExpr`` ``{0}`` is not; used here and the AST node is not instantiated. However, in the case of; ``bar.cpp`` we use the constructor with number ``(2)``, which does not; explicitly initialize the ``a`` member, so the default ``InitListExpr`` is; needed and thus instantiated. When we merge the AST of ``foo.cpp`` and; ``bar.cpp`` we must create an AST node for the class template instantiation of; ``X<char>`` which has all the required nodes. Therefore, when we find an; existing ``ClassTemplateSpecializationDecl`` then we merge the fields of the; ``ClassTemplateSpecializationDecl`` in the ""from"" context in a way that the; ``InitListExpr`` is copied if not existent yet. The same merge mechanism should; be done in the cases of instantiated default arguments and exception; specifications of functions. .. _visibility:. Visibility of Declarations; ^^^^^^^^^^^^^^^^^^^^^^^^^^. During import of a global variable with external visibility, the lookup will; find variables (with the same name) but with static visibility (linkage).; Clearly, we cannot put them into the same redeclaration chain. The same is true; the in case of functions. Also, we have to take care of other kinds of; declarations like enums, classes, etc. if they are in anonymous namespaces.; Therefore, we filter the lookup results and consider only those which have the; same visibility as the declaration we currently import. We consider two declarations in two anonymous namespaces to have the same; visibility only if they are imported from the same AST context. Strategies to Handle Conflicting Names; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. During the import we lookup existing declarations with the same name. We filter; the lookup results based on their :ref:`visibility <visibility>`. If any of the; found declarations are not structurally equivalent then we bumped to a name; conflict error (ODR violation in C++). In this case, we return with an; ``Error`` and we set up th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:110083,Modifiability,variab,variables,110083," the member ``a`` to ``3``, thus the ``InitListExpr`` ``{0}`` is not; used here and the AST node is not instantiated. However, in the case of; ``bar.cpp`` we use the constructor with number ``(2)``, which does not; explicitly initialize the ``a`` member, so the default ``InitListExpr`` is; needed and thus instantiated. When we merge the AST of ``foo.cpp`` and; ``bar.cpp`` we must create an AST node for the class template instantiation of; ``X<char>`` which has all the required nodes. Therefore, when we find an; existing ``ClassTemplateSpecializationDecl`` then we merge the fields of the; ``ClassTemplateSpecializationDecl`` in the ""from"" context in a way that the; ``InitListExpr`` is copied if not existent yet. The same merge mechanism should; be done in the cases of instantiated default arguments and exception; specifications of functions. .. _visibility:. Visibility of Declarations; ^^^^^^^^^^^^^^^^^^^^^^^^^^. During import of a global variable with external visibility, the lookup will; find variables (with the same name) but with static visibility (linkage).; Clearly, we cannot put them into the same redeclaration chain. The same is true; the in case of functions. Also, we have to take care of other kinds of; declarations like enums, classes, etc. if they are in anonymous namespaces.; Therefore, we filter the lookup results and consider only those which have the; same visibility as the declaration we currently import. We consider two declarations in two anonymous namespaces to have the same; visibility only if they are imported from the same AST context. Strategies to Handle Conflicting Names; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. During the import we lookup existing declarations with the same name. We filter; the lookup results based on their :ref:`visibility <visibility>`. If any of the; found declarations are not structurally equivalent then we bumped to a name; conflict error (ODR violation in C++). In this case, we return with an; ``Error`` and we set up th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:119957,Modifiability,variab,variable,119957,"ot of places (for example, the size of a; bitfield, the value for a case statement, etc). For these, we have to be able; to constant fold the constants, to do semantic checks (e.g., verify bitfield; size is non-negative and that case statements aren't duplicated). We aim for; Clang to be very pedantic about this, diagnosing cases when the code does not; use an i-c-e where one is required, but accepting the code unless running with; ``-pedantic-errors``. Things get a little bit more tricky when it comes to compatibility with; real-world source code. Specifically, GCC has historically accepted a huge; superset of expressions as i-c-e's, and a lot of real world code depends on; this unfortunate accident of history (including, e.g., the glibc system; headers). GCC accepts anything its ""fold"" optimizer is capable of reducing to; an integer constant, which means that the definition of what it accepts changes; as its optimizer does. One example is that GCC accepts things like ""``case; X-X:``"" even when ``X`` is a variable, because it can fold this to 0. Another issue are how constants interact with the extensions we support, such; as ``__builtin_constant_p``, ``__builtin_inf``, ``__extension__`` and many; others. C99 obviously does not specify the semantics of any of these; extensions, and the definition of i-c-e does not include them. However, these; extensions are often used in real code, and we have to have a way to reason; about them. Finally, this is not just a problem for semantic analysis. The code generator; and other clients have to be able to fold constants (e.g., to initialize global; variables) and have to handle a superset of what C99 allows. Further, these; clients can benefit from extended information. For example, we know that; ""``foo() || 1``"" always evaluates to ``true``, but we can't replace the; expression with ``true`` because it has side effects. Implementation Approach; ^^^^^^^^^^^^^^^^^^^^^^^. After trying several different approaches, we've finally ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:120551,Modifiability,variab,variables,120551,"i-c-e's, and a lot of real world code depends on; this unfortunate accident of history (including, e.g., the glibc system; headers). GCC accepts anything its ""fold"" optimizer is capable of reducing to; an integer constant, which means that the definition of what it accepts changes; as its optimizer does. One example is that GCC accepts things like ""``case; X-X:``"" even when ``X`` is a variable, because it can fold this to 0. Another issue are how constants interact with the extensions we support, such; as ``__builtin_constant_p``, ``__builtin_inf``, ``__extension__`` and many; others. C99 obviously does not specify the semantics of any of these; extensions, and the definition of i-c-e does not include them. However, these; extensions are often used in real code, and we have to have a way to reason; about them. Finally, this is not just a problem for semantic analysis. The code generator; and other clients have to be able to fold constants (e.g., to initialize global; variables) and have to handle a superset of what C99 allows. Further, these; clients can benefit from extended information. For example, we know that; ""``foo() || 1``"" always evaluates to ``true``, but we can't replace the; expression with ``true`` because it has side effects. Implementation Approach; ^^^^^^^^^^^^^^^^^^^^^^^. After trying several different approaches, we've finally converged on a design; (Note, at the time of this writing, not all of this has been implemented,; consider this a design goal!). Our basic approach is to define a single; recursive evaluation method (``Expr::Evaluate``), which is implemented; in ``AST/ExprConstant.cpp``. Given an expression with ""scalar"" type (integer,; fp, complex, or pointer) this method returns the following information:. * Whether the expression is an integer constant expression, a general constant; that was folded but has no side effects, a general constant that was folded; but that does have side effects, or an uncomputable/unfoldable value.; * If the e",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:120653,Modifiability,extend,extended,120653,"nt of history (including, e.g., the glibc system; headers). GCC accepts anything its ""fold"" optimizer is capable of reducing to; an integer constant, which means that the definition of what it accepts changes; as its optimizer does. One example is that GCC accepts things like ""``case; X-X:``"" even when ``X`` is a variable, because it can fold this to 0. Another issue are how constants interact with the extensions we support, such; as ``__builtin_constant_p``, ``__builtin_inf``, ``__extension__`` and many; others. C99 obviously does not specify the semantics of any of these; extensions, and the definition of i-c-e does not include them. However, these; extensions are often used in real code, and we have to have a way to reason; about them. Finally, this is not just a problem for semantic analysis. The code generator; and other clients have to be able to fold constants (e.g., to initialize global; variables) and have to handle a superset of what C99 allows. Further, these; clients can benefit from extended information. For example, we know that; ""``foo() || 1``"" always evaluates to ``true``, but we can't replace the; expression with ``true`` because it has side effects. Implementation Approach; ^^^^^^^^^^^^^^^^^^^^^^^. After trying several different approaches, we've finally converged on a design; (Note, at the time of this writing, not all of this has been implemented,; consider this a design goal!). Our basic approach is to define a single; recursive evaluation method (``Expr::Evaluate``), which is implemented; in ``AST/ExprConstant.cpp``. Given an expression with ""scalar"" type (integer,; fp, complex, or pointer) this method returns the following information:. * Whether the expression is an integer constant expression, a general constant; that was folded but has no side effects, a general constant that was folded; but that does have side effects, or an uncomputable/unfoldable value.; * If the expression was computable in any way, this method returns the; ``APValue`` ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:127861,Modifiability,inherit,inherited,127861,"T>()``. Similarly, for statement attributes,; ``Sema::ProcessStmtAttributes()`` is called with a ``Stmt`` a list of; ``ParsedAttr`` objects to be converted into a semantic attribute. The structure of the semantic attribute is also governed by the attribute; definition given in Attr.td. This definition is used to automatically generate; functionality used for the implementation of the attribute, such as a class; derived from ``clang::Attr``, information for the parser to use, automated; semantic checking for some attributes, etc. ``include/clang/Basic/Attr.td``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; The first step to adding a new attribute to Clang is to add its definition to; `include/clang/Basic/Attr.td; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/Attr.td>`_.; This tablegen definition must derive from the ``Attr`` (tablegen, not; semantic) type, or one of its derivatives. Most attributes will derive from the; ``InheritableAttr`` type, which specifies that the attribute can be inherited by; later redeclarations of the ``Decl`` it is associated with.; ``InheritableParamAttr`` is similar to ``InheritableAttr``, except that the; attribute is written on a parameter instead of a declaration. If the attribute; applies to statements, it should inherit from ``StmtAttr``. If the attribute is; intended to apply to a type instead of a declaration, such an attribute should; derive from ``TypeAttr``, and will generally not be given an AST representation.; (Note that this document does not cover the creation of type attributes.) An; attribute that inherits from ``IgnoredAttr`` is parsed, but will generate an; ignored attribute diagnostic when used, which may be useful when an attribute is; supported by another vendor but not supported by clang. The definition will specify several key pieces of information, such as the; semantic name of the attribute, the spellings the attribute supports, the; arguments the attribute expects, and more. Most members of the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:128126,Modifiability,inherit,inherit,128126,"given in Attr.td. This definition is used to automatically generate; functionality used for the implementation of the attribute, such as a class; derived from ``clang::Attr``, information for the parser to use, automated; semantic checking for some attributes, etc. ``include/clang/Basic/Attr.td``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; The first step to adding a new attribute to Clang is to add its definition to; `include/clang/Basic/Attr.td; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/Attr.td>`_.; This tablegen definition must derive from the ``Attr`` (tablegen, not; semantic) type, or one of its derivatives. Most attributes will derive from the; ``InheritableAttr`` type, which specifies that the attribute can be inherited by; later redeclarations of the ``Decl`` it is associated with.; ``InheritableParamAttr`` is similar to ``InheritableAttr``, except that the; attribute is written on a parameter instead of a declaration. If the attribute; applies to statements, it should inherit from ``StmtAttr``. If the attribute is; intended to apply to a type instead of a declaration, such an attribute should; derive from ``TypeAttr``, and will generally not be given an AST representation.; (Note that this document does not cover the creation of type attributes.) An; attribute that inherits from ``IgnoredAttr`` is parsed, but will generate an; ignored attribute diagnostic when used, which may be useful when an attribute is; supported by another vendor but not supported by clang. The definition will specify several key pieces of information, such as the; semantic name of the attribute, the spellings the attribute supports, the; arguments the attribute expects, and more. Most members of the ``Attr`` tablegen; type do not require definitions in the derived definition as the default; suffice. However, every attribute must specify at least a spelling list, a; subject list, and a documentation list. Spellings; ~~~~~~~~~; All attributes are required to specify",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:128429,Modifiability,inherit,inherits,128429,"n to; `include/clang/Basic/Attr.td; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/Attr.td>`_.; This tablegen definition must derive from the ``Attr`` (tablegen, not; semantic) type, or one of its derivatives. Most attributes will derive from the; ``InheritableAttr`` type, which specifies that the attribute can be inherited by; later redeclarations of the ``Decl`` it is associated with.; ``InheritableParamAttr`` is similar to ``InheritableAttr``, except that the; attribute is written on a parameter instead of a declaration. If the attribute; applies to statements, it should inherit from ``StmtAttr``. If the attribute is; intended to apply to a type instead of a declaration, such an attribute should; derive from ``TypeAttr``, and will generally not be given an AST representation.; (Note that this document does not cover the creation of type attributes.) An; attribute that inherits from ``IgnoredAttr`` is parsed, but will generate an; ignored attribute diagnostic when used, which may be useful when an attribute is; supported by another vendor but not supported by clang. The definition will specify several key pieces of information, such as the; semantic name of the attribute, the spellings the attribute supports, the; arguments the attribute expects, and more. Most members of the ``Attr`` tablegen; type do not require definitions in the derived definition as the default; suffice. However, every attribute must specify at least a spelling list, a; subject list, and a documentation list. Spellings; ~~~~~~~~~; All attributes are required to specify a spelling list that denotes the ways in; which the attribute can be spelled. For instance, a single semantic attribute; may have a keyword spelling, as well as a C++11 spelling and a GNU spelling. An; empty spelling list is also permissible and may be useful for attributes which; are created implicitly. The following spellings are accepted:. ================== =========================================",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:135359,Modifiability,variab,variable-like,135359,"e public web server by a server-side; process that runs daily. Generally, the documentation for an attribute is a; stand-alone definition in `include/clang/Basic/AttrDocs.td; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/AttrDocs.td>`_; that is named after the attribute being documented. If the attribute is not for public consumption, or is an implicitly-created; attribute that has no visible spelling, the documentation list can specify the; ``InternalOnly`` object. Otherwise, the attribute should have its documentation; added to AttrDocs.td. Documentation derives from the ``Documentation`` tablegen type. All derived; types must specify a documentation category and the actual documentation itself.; Additionally, it can specify a custom heading for the attribute, though a; default heading will be chosen when possible. There are four predefined documentation categories: ``DocCatFunction`` for; attributes that appertain to function-like subjects, ``DocCatVariable`` for; attributes that appertain to variable-like subjects, ``DocCatType`` for type; attributes, and ``DocCatStmt`` for statement attributes. A custom documentation; category should be used for groups of attributes with similar functionality.; Custom categories are good for providing overview information for the attributes; grouped under it. For instance, the consumed annotation attributes define a; custom category, ``DocCatConsumed``, that explains what consumed annotations are; at a high level. Documentation content (whether it is for an attribute or a category) is written; using reStructuredText (RST) syntax. After writing the documentation for the attribute, it should be locally tested; to ensure that there are no issues generating the documentation on the server.; Local testing requires a fresh build of clang-tblgen. To generate the attribute; documentation, execute the following command::. clang-tblgen -gen-attr-docs -I /path/to/clang/include /path/to/clang/include/clang/Basic",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:138789,Modifiability,inherit,inheriting,138789,"e ``HasCustomParsing`` bit can be set to ``1`` for the class,; and the parsing code in `Parser::ParseGNUAttributeArgs(); <https://github.com/llvm/llvm-project/blob/main/clang/lib/Parse/ParseDecl.cpp>`_; can be updated for the special case. Note that this only applies to arguments; with a GNU spelling -- attributes with a __declspec spelling currently ignore; this flag and are handled by ``Parser::ParseMicrosoftDeclSpec``. Note that setting this member to 1 will opt out of common attribute semantic; handling, requiring extra implementation efforts to ensure the attribute; appertains to the appropriate subject, etc. If the attribute should not be propagated from a template declaration to an; instantiation of the template, set the ``Clone`` member to 0. By default, all; attributes will be cloned to template instantiations. Attributes that do not require an AST node should set the ``ASTNode`` field to; ``0`` to avoid polluting the AST. Note that anything inheriting from; ``TypeAttr`` or ``IgnoredAttr`` automatically do not generate an AST node. All; other attributes generate an AST node by default. The AST node is the semantic; representation of the attribute. The ``LangOpts`` field specifies a list of language options required by the; attribute. For instance, all of the CUDA-specific attributes specify ``[CUDA]``; for the ``LangOpts`` field, and when the CUDA language option is not enabled, an; ""attribute ignored"" warning diagnostic is emitted. Since language options are; not table generated nodes, new language options must be created manually and; should specify the spelling used by ``LangOptions`` class. Custom accessors can be generated for an attribute based on the spelling list; for that attribute. For instance, if an attribute has two different spellings:; 'Foo' and 'Bar', accessors can be created:; ``[Accessor<""isFoo"", [GNU<""Foo"">]>, Accessor<""isBar"", [GNU<""Bar"">]>]``; These accessors will be generated on the semantic form of the attribute,; accepting no argument",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:139976,Modifiability,inherit,inheriting,139976,"`LangOpts`` field specifies a list of language options required by the; attribute. For instance, all of the CUDA-specific attributes specify ``[CUDA]``; for the ``LangOpts`` field, and when the CUDA language option is not enabled, an; ""attribute ignored"" warning diagnostic is emitted. Since language options are; not table generated nodes, new language options must be created manually and; should specify the spelling used by ``LangOptions`` class. Custom accessors can be generated for an attribute based on the spelling list; for that attribute. For instance, if an attribute has two different spellings:; 'Foo' and 'Bar', accessors can be created:; ``[Accessor<""isFoo"", [GNU<""Foo"">]>, Accessor<""isBar"", [GNU<""Bar"">]>]``; These accessors will be generated on the semantic form of the attribute,; accepting no arguments and returning a ``bool``. Attributes that do not require custom semantic handling should set the; ``SemaHandler`` field to ``0``. Note that anything inheriting from; ``IgnoredAttr`` automatically do not get a semantic handler. All other; attributes are assumed to use a semantic handler by default. Attributes; without a semantic handler are not given a parsed attribute ``Kind`` enumerator. ""Simple"" attributes, that require no custom semantic processing aside from what; is automatically provided, should set the ``SimpleHandler`` field to ``1``. Target-specific attributes may share a spelling with other attributes in; different targets. For instance, the ARM and MSP430 targets both have an; attribute spelled ``GNU<""interrupt"">``, but with different parsing and semantic; requirements. To support this feature, an attribute inheriting from; ``TargetSpecificAttribute`` may specify a ``ParseKind`` field. This field; should be the same value between all arguments sharing a spelling, and; corresponds to the parsed attribute's ``Kind`` enumerator. This allows; attributes to share a parsed attribute kind, but have distinct semantic; attribute classes. For instance, ``Pars",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:140657,Modifiability,inherit,inheriting,140657,", [GNU<""Foo"">]>, Accessor<""isBar"", [GNU<""Bar"">]>]``; These accessors will be generated on the semantic form of the attribute,; accepting no arguments and returning a ``bool``. Attributes that do not require custom semantic handling should set the; ``SemaHandler`` field to ``0``. Note that anything inheriting from; ``IgnoredAttr`` automatically do not get a semantic handler. All other; attributes are assumed to use a semantic handler by default. Attributes; without a semantic handler are not given a parsed attribute ``Kind`` enumerator. ""Simple"" attributes, that require no custom semantic processing aside from what; is automatically provided, should set the ``SimpleHandler`` field to ``1``. Target-specific attributes may share a spelling with other attributes in; different targets. For instance, the ARM and MSP430 targets both have an; attribute spelled ``GNU<""interrupt"">``, but with different parsing and semantic; requirements. To support this feature, an attribute inheriting from; ``TargetSpecificAttribute`` may specify a ``ParseKind`` field. This field; should be the same value between all arguments sharing a spelling, and; corresponds to the parsed attribute's ``Kind`` enumerator. This allows; attributes to share a parsed attribute kind, but have distinct semantic; attribute classes. For instance, ``ParsedAttr`` is the shared; parsed attribute kind, but ARMInterruptAttr and MSP430InterruptAttr are the; semantic attributes generated. By default, attribute arguments are parsed in an evaluated context. If the; arguments for an attribute should be parsed in an unevaluated context (akin to; the way the argument to a ``sizeof`` expression is parsed), set; ``ParseArgumentsAsUnevaluated`` to ``1``. If additional functionality is desired for the semantic form of the attribute,; the ``AdditionalMembers`` field specifies code to be copied verbatim into the; semantic attribute class object, with ``public`` access. If two or more attributes cannot be used in combination on th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:154129,Modifiability,extend,extend,154129,"f the subexpressions and types within your expression,; using ``getDerived().TransformYYY``. If all of the subexpressions and; types transform without error, it will then call the ``RebuildXXX``; function, which will in turn call ``getSema().BuildXXX`` to perform; semantic analysis and build your expression.; * To test template instantiation, take those tests you wrote to make sure; that you were type checking with type-dependent expressions and dependent; types (from step #2) and instantiate those templates with various types,; some of which type-check and some that don't, and test the error messages; in each case. #. There are some ""extras"" that make other features work better. It's worth; handling these extras to give your expression complete integration into; Clang:. * Add code completion support for your expression in; ``SemaCodeComplete.cpp``.; * If your expression has types in it, or has any ""interesting"" features; other than subexpressions, extend libclang's ``CursorVisitor`` to provide; proper visitation for your expression, enabling various IDE features such; as syntax highlighting, cross-referencing, and so on. The; ``c-index-test`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come with test coverage demonstrating; the change in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option as a way to; validate diagnostic behavior. This option will use special comments within the; test file to verify that expected diagnostics appear in the correct source; locations. If all of the expected diagnostics match the actual output of Clang,; then the invocation will return normally. If there are discrepancies between; the expected and actual output, Clang will emit detailed information about; which expected diagnostics were not seen or which unexpected diagnostics were; seen, etc. A complete example is:. .. code-block: ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:159540,Modifiability,extend,extended,159540,":: c++. // expected-error@path/include.h:15 {{error message}}. The path can be absolute or relative and the same search paths will be used as; for ``#include`` directives. The line number in an external file may be; substituted with ``*`` meaning that any line number will match (useful where; the included file is, for example, a system header where the actual line number; may change and is not critical). As an alternative to specifying a fixed line number, the location of a; diagnostic can instead be indicated by a marker of the form ``#<marker>``.; Markers are specified by including them in a comment, and then referenced by; appending the marker to the diagnostic with ``@#<marker>``, as with:. .. code-block:: c++. #warning some text // #1; // ... other code ...; // expected-warning@#1 {{some text}}. The name of a marker used in a directive must be unique within the compilation. The simple syntax above allows each specification to match exactly one; diagnostic. You can use the extended syntax to customize this. The extended; syntax is ``expected-<type> <n> {{diag text}}``, where ``<type>`` is one of; ``error``, ``warning``, ``remark``, or ``note``, and ``<n>`` is a positive; integer. This allows the diagnostic to appear as many times as specified. For; example:. .. code-block:: c++. void f(); // expected-note 2 {{previous declaration is here}}. Where the diagnostic is expected to occur a minimum number of times, this can; be specified by appending a ``+`` to the number. For example:. .. code-block:: c++. void f(); // expected-note 0+ {{previous declaration is here}}; void g(); // expected-note 1+ {{previous declaration is here}}. In the first example, the diagnostic becomes optional, i.e. it will be; swallowed if it occurs, but will not generate an error if it does not occur. In; the second example, the diagnostic must occur at least once. As a short-hand,; ""one or more"" can be specified simply by ``+``. For example:. .. code-block:: c++. void g(); // expected-note +",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:159579,Modifiability,extend,extended,159579,"earch paths will be used as; for ``#include`` directives. The line number in an external file may be; substituted with ``*`` meaning that any line number will match (useful where; the included file is, for example, a system header where the actual line number; may change and is not critical). As an alternative to specifying a fixed line number, the location of a; diagnostic can instead be indicated by a marker of the form ``#<marker>``.; Markers are specified by including them in a comment, and then referenced by; appending the marker to the diagnostic with ``@#<marker>``, as with:. .. code-block:: c++. #warning some text // #1; // ... other code ...; // expected-warning@#1 {{some text}}. The name of a marker used in a directive must be unique within the compilation. The simple syntax above allows each specification to match exactly one; diagnostic. You can use the extended syntax to customize this. The extended; syntax is ``expected-<type> <n> {{diag text}}``, where ``<type>`` is one of; ``error``, ``warning``, ``remark``, or ``note``, and ``<n>`` is a positive; integer. This allows the diagnostic to appear as many times as specified. For; example:. .. code-block:: c++. void f(); // expected-note 2 {{previous declaration is here}}. Where the diagnostic is expected to occur a minimum number of times, this can; be specified by appending a ``+`` to the number. For example:. .. code-block:: c++. void f(); // expected-note 0+ {{previous declaration is here}}; void g(); // expected-note 1+ {{previous declaration is here}}. In the first example, the diagnostic becomes optional, i.e. it will be; swallowed if it occurs, but will not generate an error if it does not occur. In; the second example, the diagnostic must occur at least once. As a short-hand,; ""one or more"" can be specified simply by ``+``. For example:. .. code-block:: c++. void g(); // expected-note + {{previous declaration is here}}. A range can also be specified by ``<n>-<m>``. For example:. .. code-block:: c+",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162099,Modifiability,variab,variable,162099,"e character. This mode matches the emitted diagnostic when the; text appears as a substring at any position of the emitted message. To enable matching against desired strings that contain `}}` or `{{`, the; string-mode parser accepts opening delimiters of more than two curly braces,; like `{{{`. It then looks for a closing delimiter of equal ""width"" (i.e `}}}`).; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult propert",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162182,Modifiability,variab,variable,162182,"strings that contain `}}` or `{{`, the; string-mode parser accepts opening delimiters of more than two curly braces,; like `{{{`. It then looks for a closing delimiter of equal ""width"" (i.e `}}}`).; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a featur",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162245,Modifiability,variab,variable,162245,"strings that contain `}}` or `{{`, the; string-mode parser accepts opening delimiters of more than two curly braces,; like `{{{`. It then looks for a closing delimiter of equal ""width"" (i.e `}}}`).; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a featur",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162298,Modifiability,variab,variable,162298,"strings that contain `}}` or `{{`, the; string-mode parser accepts opening delimiters of more than two curly braces,; like `{{{`. It then looks for a closing delimiter of equal ""width"" (i.e `}}}`).; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a featur",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162353,Modifiability,variab,variable,162353,"strings that contain `}}` or `{{`, the; string-mode parser accepts opening delimiters of more than two curly braces,; like `{{{`. It then looks for a closing delimiter of equal ""width"" (i.e `}}}`).; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a featur",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162410,Modifiability,variab,variable,162410,"ooks for a closing delimiter of equal ""width"" (i.e `}}}`).; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accept",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162469,Modifiability,variab,variable,162469,").; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162529,Modifiability,variab,variable,162529,"valuates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, fail",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162591,Modifiability,variab,variable,162591,"he delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, failed assertions, or miscompilations?; * Are there known issues on a ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:26789,Performance,perform,performing,26789,"rEndOfToken()``. For; the rare cases where character-level source ranges information is needed we use; the ``CharSourceRange`` class. The Driver Library; ==================. The clang Driver and library are documented :doc:`here <DriverInternals>`. Precompiled Headers; ===================. Clang supports precompiled headers (:doc:`PCH <PCHInternals>`), which uses a; serialized representation of Clang's internal data structures, encoded with the; `LLVM bitstream format <https://llvm.org/docs/BitCodeFormat.html>`_. The Frontend Library; ====================. The Frontend library contains functionality useful for building tools on top of; the Clang libraries, for example several methods for outputting diagnostics. Compiler Invocation; -------------------. One of the classes provided by the Frontend library is ``CompilerInvocation``,; which holds information that describe current invocation of the Clang ``-cc1``; frontend. The information typically comes from the command line constructed by; the Clang driver or from clients performing custom initialization. The data; structure is split into logical units used by different parts of the compiler,; for example ``PreprocessorOptions``, ``LanguageOptions`` or ``CodeGenOptions``. Command Line Interface; ----------------------. The command line interface of the Clang ``-cc1`` frontend is defined alongside; the driver options in ``clang/Driver/Options.td``. The information making up an; option definition includes its prefix and name (for example ``-std=``), form and; position of the option value, help text, aliases and more. Each option may; belong to a certain group and can be marked with zero or more flags. Options; accepted by the ``-cc1`` frontend are marked with the ``CC1Option`` flag. Command Line Parsing; --------------------. Option definitions are processed by the ``-gen-opt-parser-defs`` tablegen; backend during early stages of the build. Options are then used for querying an; instance ``llvm::opt::ArgList``, a wrapper",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:28810,Performance,load,loaded,28810,"s done in the Clang driver to construct individual jobs based on the; driver arguments and also in the ``CompilerInvocation::CreateFromArgs`` function; that parses the ``-cc1`` frontend arguments. Command Line Generation; -----------------------. Any valid ``CompilerInvocation`` created from a ``-cc1`` command line can be; also serialized back into semantically equivalent command line in a; deterministic manner. This enables features such as implicitly discovered,; explicitly built modules. ..; TODO: Create and link corresponding section in Modules.rst. Adding new Command Line Option; ------------------------------. When adding a new command line option, the first place of interest is the header; file declaring the corresponding options class (e.g. ``CodeGenOptions.h`` for; command line option that affects the code generation). Create new member; variable for the option value:. .. code-block:: diff. class CodeGenOptions : public CodeGenOptionsBase {. + /// List of dynamic shared object files to be loaded as pass plugins.; + std::vector<std::string> PassPlugins;. }. Next, declare the command line interface of the option in the tablegen file; ``clang/include/clang/Driver/Options.td``. This is done by instantiating the; ``Option`` class (defined in ``llvm/include/llvm/Option/OptParser.td``). The; instance is typically created through one of the helper classes that encode the; acceptable ways to specify the option value on the command line:. * ``Flag`` - the option does not accept any value,; * ``Joined`` - the value must immediately follow the option name within the same; argument,; * ``Separate`` - the value must follow the option name in the next command line; argument,; * ``JoinedOrSeparate`` - the value can be specified either as ``Joined`` or; ``Separate``,; * ``CommaJoined`` - the values are comma-separated and must immediately follow; the option name within the same argument (see ``Wl,`` for an example). The helper classes take a list of acceptable prefixes of t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:53637,Performance,perform,performance,53637,"enation,; the preprocessor just returns distinct ``tok::string_literal`` and; ``tok::wide_string_literal`` tokens and the parser eats a sequence of them; wherever the grammar indicates that a string literal can occur. In order to do this, whenever the parser expects a ``tok::identifier`` or; ``tok::coloncolon``, it should call the ``TryAnnotateTypeOrScopeToken`` or; ``TryAnnotateCXXScopeToken`` methods to form the annotation token. These; methods will maximally form the specified annotation tokens and replace the; current token with them, if applicable. If the current tokens is not valid for; an annotation token, it will remain an identifier or ""``::``"" token. .. _Lexer:. The ``Lexer`` class; -------------------. The ``Lexer`` class provides the mechanics of lexing tokens out of a source; buffer and deciding what they mean. The ``Lexer`` is complicated by the fact; that it operates on raw buffers that have not had spelling eliminated (this is; a necessity to get decent performance), but this is countered with careful; coding as well as standard performance techniques (for example, the comment; handling code is vectorized on X86 and PowerPC hosts). The lexer has a couple of interesting modal features:. * The lexer can operate in ""raw"" mode. This mode has several features that; make it possible to quickly lex the file (e.g., it stops identifier lookup,; doesn't specially handle preprocessor tokens, handles EOF differently, etc).; This mode is used for lexing within an ""``#if 0``"" block, for example.; * The lexer can capture and return comments as tokens. This is required to; support the ``-C`` preprocessor mode, which passes comments through, and is; used by the diagnostic checker to identifier expect-error annotations.; * The lexer can be in ``ParsingFilename`` mode, which happens when; preprocessing after reading a ``#include`` directive. This mode changes the; parsing of ""``<``"" to return an ""angled string"" instead of a bunch of tokens; for each thing within the fi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:53714,Performance,perform,performance,53714,"enation,; the preprocessor just returns distinct ``tok::string_literal`` and; ``tok::wide_string_literal`` tokens and the parser eats a sequence of them; wherever the grammar indicates that a string literal can occur. In order to do this, whenever the parser expects a ``tok::identifier`` or; ``tok::coloncolon``, it should call the ``TryAnnotateTypeOrScopeToken`` or; ``TryAnnotateCXXScopeToken`` methods to form the annotation token. These; methods will maximally form the specified annotation tokens and replace the; current token with them, if applicable. If the current tokens is not valid for; an annotation token, it will remain an identifier or ""``::``"" token. .. _Lexer:. The ``Lexer`` class; -------------------. The ``Lexer`` class provides the mechanics of lexing tokens out of a source; buffer and deciding what they mean. The ``Lexer`` is complicated by the fact; that it operates on raw buffers that have not had spelling eliminated (this is; a necessity to get decent performance), but this is countered with careful; coding as well as standard performance techniques (for example, the comment; handling code is vectorized on X86 and PowerPC hosts). The lexer has a couple of interesting modal features:. * The lexer can operate in ""raw"" mode. This mode has several features that; make it possible to quickly lex the file (e.g., it stops identifier lookup,; doesn't specially handle preprocessor tokens, handles EOF differently, etc).; This mode is used for lexing within an ""``#if 0``"" block, for example.; * The lexer can capture and return comments as tokens. This is required to; support the ``-C`` preprocessor mode, which passes comments through, and is; used by the diagnostic checker to identifier expect-error annotations.; * The lexer can be in ``ParsingFilename`` mode, which happens when; preprocessing after reading a ``#include`` directive. This mode changes the; parsing of ""``<``"" to return an ""angled string"" instead of a bunch of tokens; for each thing within the fi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:69779,Performance,optimiz,optimization,69779,"entities --- variables,; functions, Objective-C methods, C++ constructors, destructors, and operators; --- are represented as subclasses of Clang's common ``NamedDecl`` class,; ``DeclarationName`` is designed to efficiently represent any kind of name. Given a ``DeclarationName`` ``N``, ``N.getNameKind()`` will produce a value; that describes what kind of name ``N`` stores. There are 10 options (all of; the names are inside the ``DeclarationName`` class). ``Identifier``. The name is a simple identifier. Use ``N.getAsIdentifierInfo()`` to retrieve; the corresponding ``IdentifierInfo*`` pointing to the actual identifier. ``ObjCZeroArgSelector``, ``ObjCOneArgSelector``, ``ObjCMultiArgSelector``. The name is an Objective-C selector, which can be retrieved as a ``Selector``; instance via ``N.getObjCSelector()``. The three possible name kinds for; Objective-C reflect an optimization within the ``DeclarationName`` class:; both zero- and one-argument selectors are stored as a masked; ``IdentifierInfo`` pointer, and therefore require very little space, since; zero- and one-argument selectors are far more common than multi-argument; selectors (which use a different structure). ``CXXConstructorName``. The name is a C++ constructor name. Use ``N.getCXXNameType()`` to retrieve; the :ref:`type <QualType>` that this constructor is meant to construct. The; type is always the canonical type, since all constructors for a given type; have the same name. ``CXXDestructorName``. The name is a C++ destructor name. Use ``N.getCXXNameType()`` to retrieve; the :ref:`type <QualType>` whose destructor is being named. This type is; always a canonical type. ``CXXConversionFunctionName``. The name is a C++ conversion function. Conversion functions are named; according to the type they convert to, e.g., ""``operator void const *``"".; Use ``N.getCXXNameType()`` to retrieve the type that this conversion function; converts to. This type is always a canonical type. ``CXXOperatorName``. The name is a C++ ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:77152,Performance,perform,perform,77152,"ext. In the source-centric view,; all redeclarations will be present, in the order they occurred in the source; code, making this view suitable for clients that wish to see the structure of; the source code. In the semantics-centric view, only the most recent ""``f``""; will be found by the lookup, since it effectively replaces the first; declaration of ""``f``"". (Note that because ``f`` can be redeclared at block scope, or in a friend; declaration, etc. it is possible that the declaration of ``f`` found by name; lookup will not be the most recent one.). In the semantics-centric view, overloading of functions is represented; explicitly. For example, given two declarations of a function ""``g``"" that are; overloaded, e.g.,. .. code-block:: c++. void g();; void g(int);. the ``DeclContext::lookup`` operation will return a; ``DeclContext::lookup_result`` that contains a range of iterators over; declarations of ""``g``"". Clients that perform semantic analysis on a program; that is not concerned with the actual source code will primarily use this; semantics-centric view. .. _LexicalAndSemanticContexts:. Lexical and Semantic Contexts; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Each declaration has two potentially different declaration contexts: a; *lexical* context, which corresponds to the source-centric view of the; declaration context, and a *semantic* context, which corresponds to the; semantics-centric view. The lexical context is accessible via; ``Decl::getLexicalDeclContext`` while the semantic context is accessible via; ``Decl::getDeclContext``, both of which return ``DeclContext`` pointers. For; most declarations, the two contexts are identical. For example:. .. code-block:: c++. class X {; public:; void f(int x);; };. Here, the semantic and lexical contexts of ``X::f`` are the ``DeclContext``; associated with the class ``X`` (itself stored as a ``RecordDecl`` AST node).; However, we can now define ``X::f`` out-of-line:. .. code-block:: c++. void X::f(int x = 17) { /* ... */ }. Th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:84415,Performance,optimiz,optimize,84415,"on methods of the ``DeclContext``, so; the vast majority of clients can ignore them. Because the same entity can be defined multiple times in different modules,; it is also possible for there to be multiple definitions of (for instance); a ``CXXRecordDecl``, all of which describe a definition of the same class.; In such a case, only one of those ""definitions"" is considered by Clang to be; the definition of the class, and the others are treated as non-defining; declarations that happen to also contain member declarations. Corresponding; members in each definition of such multiply-defined classes are identified; either by redeclaration chains (if the members are ``Redeclarable``); or by simply a pointer to the canonical declaration (if the declarations; are not ``Redeclarable`` -- in that case, a ``Mergeable`` base class is used; instead). Error Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we dont have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:87925,Performance,perform,perform,87925,"of parentheses) and allow; it to be treated uniformly with valid CallExprs. However, jamming the data we; have into CallExpr forces us to weaken its invariants, e.g. arg count may be; wrong. This would introduce a huge burden on consumers of the AST to handle such; ""impossible"" cases. So when we're representing (rather than correcting) errors,; we use a distinct recovery node type with extremely weak invariants instead. ``RecoveryExpr`` is the only recovery node so far. In practice, broken decls; need more detailed semantics preserved (the current ``Invalid`` flag works; fairly well), and completely broken statements with interesting internal; structure are rare (so dropping the statements is OK). Types and dependence; ^^^^^^^^^^^^^^^^^^^^. ``RecoveryExpr`` is an ``Expr``, so it must have a type. In many cases the true; type can't really be known until the code is corrected (e.g. a call to a; function that doesn't exist). And it means that we can't properly perform type; checks on some containing constructs, such as ``return 42 + unknownFunction()``. To model this, we generalize the concept of dependence from C++ templates to; mean dependence on a template parameter or how an error is repaired. The; ``RecoveryExpr`` ``unknownFunction()`` has the totally unknown type; ``DependentTy``, and this suppresses type-based analysis in the same way it; would inside a template. In cases where we are confident about the concrete type (e.g. the return type; for a broken non-overloaded function call), the ``RecoveryExpr`` will have this; type. This allows more code to be typechecked, and produces a better AST and; more diagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, thi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:100657,Performance,cache,cache,100657," the node for ``A`` (the constructor; needs a reference to ``B``). And the same could be true for the import of ``B``; (``A`` is requested to be imported before we could create the node for ``B``).; In case of the :ref:`templated-described swing <templated>` we take; extra attention to break the cyclical dependency: we import and set the; described template only after the ``CXXRecordDecl`` is created. As a best; practice, before creating the node in the ""to"" context, avoid importing of; other nodes which are not needed for the constructor of node ``A``. Error Handling; ^^^^^^^^^^^^^^. Every import function returns with either an ``llvm::Error`` or an; ``llvm::Expected<T>`` object. This enforces to check the return value of the; import functions. If there was an error during one import then we return with; that error. (Exception: when we import the members of a class, we collect the; individual errors with each member and we concatenate them in one Error; object.) We cache these errors in cases of declarations. During the next import; call if there is an existing error we just return with that. So, clients of the; library receive an Error object, which they must check. During import of a specific declaration, it may happen that some AST nodes had; already been created before we recognize an error. In this case, we signal back; the error to the caller, but the ""to"" context remains polluted with those nodes; which had been created. Ideally, those nodes should not had been created, but; that time we did not know about the error, the error happened later. Since the; AST is immutable (most of the cases we can't remove existing nodes) we choose; to mark these nodes as erroneous. We cache the errors associated with declarations in the ""from"" context in; ``ASTImporter::ImportDeclErrors`` and the ones which are associated with the; ""to"" context in ``ASTImporterSharedState::ImportErrors``. Note that, there may; be several ASTImporter objects which import into the same ""to"" cont",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:101380,Performance,cache,cache,101380,"eturn with; that error. (Exception: when we import the members of a class, we collect the; individual errors with each member and we concatenate them in one Error; object.) We cache these errors in cases of declarations. During the next import; call if there is an existing error we just return with that. So, clients of the; library receive an Error object, which they must check. During import of a specific declaration, it may happen that some AST nodes had; already been created before we recognize an error. In this case, we signal back; the error to the caller, but the ""to"" context remains polluted with those nodes; which had been created. Ideally, those nodes should not had been created, but; that time we did not know about the error, the error happened later. Since the; AST is immutable (most of the cases we can't remove existing nodes) we choose; to mark these nodes as erroneous. We cache the errors associated with declarations in the ""from"" context in; ``ASTImporter::ImportDeclErrors`` and the ones which are associated with the; ""to"" context in ``ASTImporterSharedState::ImportErrors``. Note that, there may; be several ASTImporter objects which import into the same ""to"" context but from; different ""from"" contexts; in this case, they have to share the associated; errors of the ""to"" context. When an error happens, that propagates through the call stack, through all the; dependant nodes. However, in case of dependency cycles, this is not enough,; because we strive to mark the erroneous nodes so clients can act upon. In those; cases, we have to keep track of the errors for those nodes which are; intermediate nodes of a cycle. An **import path** is the list of the AST nodes which we visit during an Import; call. If node ``A`` depends on node ``B`` then the path contains an ``A->B``; edge. From the call stack of the import functions, we can read the very same; path. Now imagine the following AST, where the ``->`` represents dependency in terms; of the import (all nodes ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:106689,Performance,load,load,106689,"/C++ lookup then we create; redundant AST nodes during the merge! Also, having two instances of the same; node could result in false :ref:`structural in-equivalencies <structural-eq>`; of other nodes which depend on the duplicated node. Because of these reasons,; we created a lookup class which has the sole purpose to register all; declarations, so later they can be looked up by subsequent import requests.; This is the ``ASTImporterLookupTable`` class. This lookup table should be; shared amongst the different ``ASTImporter`` instances if they happen to import; to the very same ""to"" context. This is why we can use the importer specific; lookup only via the ``ASTImporterSharedState`` class. ExternalASTSource; ~~~~~~~~~~~~~~~~~. The ``ExternalASTSource`` is an abstract interface associated with the; ``ASTContext`` class. It provides the ability to read the declarations stored; within a declaration context either for iteration or for name lookup. A; declaration context with an external AST source may load its declarations; on-demand. This means that the list of declarations (represented as a linked; list, the head is ``DeclContext::FirstDecl``) could be empty. However, member; functions like ``DeclContext::lookup()`` may initiate a load. Usually, external sources are associated with precompiled headers. For example,; when we load a class from a PCH then the members are loaded only if we do want; to look up something in the class' context. In case of LLDB, an implementation of the ``ExternalASTSource`` interface is; attached to the AST context which is related to the parsed expression. This; implementation of the ``ExternalASTSource`` interface is realized with the help; of the ``ASTImporter`` class. This way, LLDB can reuse Clang's parsing; machinery while synthesizing the underlying AST from the debug data (e.g. from; DWARF). From the view of the ``ASTImporter`` this means both the ""to"" and the; ""from"" context may have declaration contexts with external lexical storage.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:106925,Performance,load,load,106925,"on the duplicated node. Because of these reasons,; we created a lookup class which has the sole purpose to register all; declarations, so later they can be looked up by subsequent import requests.; This is the ``ASTImporterLookupTable`` class. This lookup table should be; shared amongst the different ``ASTImporter`` instances if they happen to import; to the very same ""to"" context. This is why we can use the importer specific; lookup only via the ``ASTImporterSharedState`` class. ExternalASTSource; ~~~~~~~~~~~~~~~~~. The ``ExternalASTSource`` is an abstract interface associated with the; ``ASTContext`` class. It provides the ability to read the declarations stored; within a declaration context either for iteration or for name lookup. A; declaration context with an external AST source may load its declarations; on-demand. This means that the list of declarations (represented as a linked; list, the head is ``DeclContext::FirstDecl``) could be empty. However, member; functions like ``DeclContext::lookup()`` may initiate a load. Usually, external sources are associated with precompiled headers. For example,; when we load a class from a PCH then the members are loaded only if we do want; to look up something in the class' context. In case of LLDB, an implementation of the ``ExternalASTSource`` interface is; attached to the AST context which is related to the parsed expression. This; implementation of the ``ExternalASTSource`` interface is realized with the help; of the ``ASTImporter`` class. This way, LLDB can reuse Clang's parsing; machinery while synthesizing the underlying AST from the debug data (e.g. from; DWARF). From the view of the ``ASTImporter`` this means both the ""to"" and the; ""from"" context may have declaration contexts with external lexical storage. If; a ``DeclContext`` in the ""to"" AST context has external lexical storage then we; must take extra attention to work only with the already loaded declarations!; Otherwise, we would end up with an uncontrolled im",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:107020,Performance,load,load,107020,"ent import requests.; This is the ``ASTImporterLookupTable`` class. This lookup table should be; shared amongst the different ``ASTImporter`` instances if they happen to import; to the very same ""to"" context. This is why we can use the importer specific; lookup only via the ``ASTImporterSharedState`` class. ExternalASTSource; ~~~~~~~~~~~~~~~~~. The ``ExternalASTSource`` is an abstract interface associated with the; ``ASTContext`` class. It provides the ability to read the declarations stored; within a declaration context either for iteration or for name lookup. A; declaration context with an external AST source may load its declarations; on-demand. This means that the list of declarations (represented as a linked; list, the head is ``DeclContext::FirstDecl``) could be empty. However, member; functions like ``DeclContext::lookup()`` may initiate a load. Usually, external sources are associated with precompiled headers. For example,; when we load a class from a PCH then the members are loaded only if we do want; to look up something in the class' context. In case of LLDB, an implementation of the ``ExternalASTSource`` interface is; attached to the AST context which is related to the parsed expression. This; implementation of the ``ExternalASTSource`` interface is realized with the help; of the ``ASTImporter`` class. This way, LLDB can reuse Clang's parsing; machinery while synthesizing the underlying AST from the debug data (e.g. from; DWARF). From the view of the ``ASTImporter`` this means both the ""to"" and the; ""from"" context may have declaration contexts with external lexical storage. If; a ``DeclContext`` in the ""to"" AST context has external lexical storage then we; must take extra attention to work only with the already loaded declarations!; Otherwise, we would end up with an uncontrolled import process. For instance,; if we used the regular ``DeclContext::lookup()`` to find the existing; declarations in the ""to"" context then the ``lookup()`` call itself would; i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:107065,Performance,load,loaded,107065,"ent import requests.; This is the ``ASTImporterLookupTable`` class. This lookup table should be; shared amongst the different ``ASTImporter`` instances if they happen to import; to the very same ""to"" context. This is why we can use the importer specific; lookup only via the ``ASTImporterSharedState`` class. ExternalASTSource; ~~~~~~~~~~~~~~~~~. The ``ExternalASTSource`` is an abstract interface associated with the; ``ASTContext`` class. It provides the ability to read the declarations stored; within a declaration context either for iteration or for name lookup. A; declaration context with an external AST source may load its declarations; on-demand. This means that the list of declarations (represented as a linked; list, the head is ``DeclContext::FirstDecl``) could be empty. However, member; functions like ``DeclContext::lookup()`` may initiate a load. Usually, external sources are associated with precompiled headers. For example,; when we load a class from a PCH then the members are loaded only if we do want; to look up something in the class' context. In case of LLDB, an implementation of the ``ExternalASTSource`` interface is; attached to the AST context which is related to the parsed expression. This; implementation of the ``ExternalASTSource`` interface is realized with the help; of the ``ASTImporter`` class. This way, LLDB can reuse Clang's parsing; machinery while synthesizing the underlying AST from the debug data (e.g. from; DWARF). From the view of the ``ASTImporter`` this means both the ""to"" and the; ""from"" context may have declaration contexts with external lexical storage. If; a ``DeclContext`` in the ""to"" AST context has external lexical storage then we; must take extra attention to work only with the already loaded declarations!; Otherwise, we would end up with an uncontrolled import process. For instance,; if we used the regular ``DeclContext::lookup()`` to find the existing; declarations in the ""to"" context then the ``lookup()`` call itself would; i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:107819,Performance,load,loaded,107819,"ist, the head is ``DeclContext::FirstDecl``) could be empty. However, member; functions like ``DeclContext::lookup()`` may initiate a load. Usually, external sources are associated with precompiled headers. For example,; when we load a class from a PCH then the members are loaded only if we do want; to look up something in the class' context. In case of LLDB, an implementation of the ``ExternalASTSource`` interface is; attached to the AST context which is related to the parsed expression. This; implementation of the ``ExternalASTSource`` interface is realized with the help; of the ``ASTImporter`` class. This way, LLDB can reuse Clang's parsing; machinery while synthesizing the underlying AST from the debug data (e.g. from; DWARF). From the view of the ``ASTImporter`` this means both the ""to"" and the; ""from"" context may have declaration contexts with external lexical storage. If; a ``DeclContext`` in the ""to"" AST context has external lexical storage then we; must take extra attention to work only with the already loaded declarations!; Otherwise, we would end up with an uncontrolled import process. For instance,; if we used the regular ``DeclContext::lookup()`` to find the existing; declarations in the ""to"" context then the ``lookup()`` call itself would; initiate a new import while we are in the middle of importing a declaration!; (By the time we initiate the lookup we haven't registered yet that we already; started to import the node of the ""from"" context.) This is why we use; ``DeclContext::noload_lookup()`` instead. Class Template Instantiations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Different translation units may have class template instantiations with the; same template arguments, but with a different set of instantiated; ``MethodDecls`` and ``FieldDecls``. Consider the following files:. .. code-block:: c++. // x.h; template <typename T>; struct X {; int a{0}; // FieldDecl with InitListExpr; X(char) : a(3) {} // (1); X(int) {} // (2); };. // foo.cpp; void foo() {; // ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:112282,Performance,perform,performing,112282,"s may benefit if the node is created even if there; is a name conflict. During the CTU analysis of certain projects, we recognized; that there are global declarations which collide with declarations from other; translation units, but they are not referenced outside from their translation; unit. These declarations should be in an unnamed namespace ideally. If we treat; these collisions liberally then CTU analysis can find more results. Note, the; feature be able to choose between name conflict handling strategies is still an; ongoing work. .. _CFG:. The ``CFG`` class; -----------------. The ``CFG`` class is designed to represent a source-level control-flow graph; for a single statement (``Stmt*``). Typically instances of ``CFG`` are; constructed for function bodies (usually an instance of ``CompoundStmt``), but; can also be instantiated to represent the control-flow of any class that; subclasses ``Stmt``, which includes simple expressions. Control-flow graphs; are especially useful for performing `flow- or path-sensitive; <https://en.wikipedia.org/wiki/Data_flow_analysis#Sensitivities>`_ program; analyses on a given function. Basic Blocks; ^^^^^^^^^^^^. Concretely, an instance of ``CFG`` is a collection of basic blocks. Each basic; block is an instance of ``CFGBlock``, which simply contains an ordered sequence; of ``Stmt*`` (each referring to statements in the AST). The ordering of; statements within a block indicates unconditional flow of control from one; statement to the next. :ref:`Conditional control-flow; <ConditionalControlFlow>` is represented using edges between basic blocks. The; statements within a given ``CFGBlock`` can be traversed using the; ``CFGBlock::*iterator`` interface. A ``CFG`` object owns the instances of ``CFGBlock`` within the control-flow; graph it represents. Each ``CFGBlock`` within a CFG is also uniquely numbered; (accessible via ``CFGBlock::getBlockID()``). Currently the number is based on; the ordering the blocks were created, but no ass",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:117963,Performance,perform,perform,117963,"or B4, the ``Stmt*`` for the second; statement refers to the actual expression in the AST for ``(x > 2)``. Thus; pointers to subclasses of ``Expr`` can appear in the list of statements in a; block, and not just subclasses of ``Stmt`` that refer to proper C statements. The terminator of block B4 is a pointer to the ``IfStmt`` object in the AST.; The pretty-printer outputs ``if [B4.2]`` because the condition expression of; the if-statement has an actual place in the basic block, and thus the; terminator is essentially *referring* to the expression that is the second; statement of block B4 (i.e., B4.2). In this manner, conditions for; control-flow (which also includes conditions for loops and switch statements); are hoisted into the actual basic block. .. Implicit Control-Flow; .. ^^^^^^^^^^^^^^^^^^^^^. .. A key design principle of the ``CFG`` class was to not require any; .. transformations to the AST in order to represent control-flow. Thus the; .. ``CFG`` does not perform any ""lowering"" of the statements in an AST: loops; .. are not transformed into guarded gotos, short-circuit operations are not; .. converted to a set of if-statements, and so on. Constant Folding in the Clang AST; ---------------------------------. There are several places where constants and constant folding matter a lot to; the Clang front-end. First, in general, we prefer the AST to retain the source; code as close to how the user wrote it as possible. This means that if they; wrote ""``5+4``"", we want to keep the addition and two constants in the AST, we; don't want to fold to ""``9``"". This means that constant folding in various; ways turns into a tree walk that needs to handle the various cases. However, there are places in both C and C++ that require constants to be; folded. For example, the C standard defines what an ""integer constant; expression"" (i-c-e) is with very precise and specific requirements. The; language then requires i-c-e's in a lot of places (for example, the size of a; bitfiel",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:119734,Performance,optimiz,optimizer,119734,"rd defines what an ""integer constant; expression"" (i-c-e) is with very precise and specific requirements. The; language then requires i-c-e's in a lot of places (for example, the size of a; bitfield, the value for a case statement, etc). For these, we have to be able; to constant fold the constants, to do semantic checks (e.g., verify bitfield; size is non-negative and that case statements aren't duplicated). We aim for; Clang to be very pedantic about this, diagnosing cases when the code does not; use an i-c-e where one is required, but accepting the code unless running with; ``-pedantic-errors``. Things get a little bit more tricky when it comes to compatibility with; real-world source code. Specifically, GCC has historically accepted a huge; superset of expressions as i-c-e's, and a lot of real world code depends on; this unfortunate accident of history (including, e.g., the glibc system; headers). GCC accepts anything its ""fold"" optimizer is capable of reducing to; an integer constant, which means that the definition of what it accepts changes; as its optimizer does. One example is that GCC accepts things like ""``case; X-X:``"" even when ``X`` is a variable, because it can fold this to 0. Another issue are how constants interact with the extensions we support, such; as ``__builtin_constant_p``, ``__builtin_inf``, ``__extension__`` and many; others. C99 obviously does not specify the semantics of any of these; extensions, and the definition of i-c-e does not include them. However, these; extensions are often used in real code, and we have to have a way to reason; about them. Finally, this is not just a problem for semantic analysis. The code generator; and other clients have to be able to fold constants (e.g., to initialize global; variables) and have to handle a superset of what C99 allows. Further, these; clients can benefit from extended information. For example, we know that; ""``foo() || 1``"" always evaluates to ``true``, but we can't replace the; expression wi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:119859,Performance,optimiz,optimizer,119859,"rd defines what an ""integer constant; expression"" (i-c-e) is with very precise and specific requirements. The; language then requires i-c-e's in a lot of places (for example, the size of a; bitfield, the value for a case statement, etc). For these, we have to be able; to constant fold the constants, to do semantic checks (e.g., verify bitfield; size is non-negative and that case statements aren't duplicated). We aim for; Clang to be very pedantic about this, diagnosing cases when the code does not; use an i-c-e where one is required, but accepting the code unless running with; ``-pedantic-errors``. Things get a little bit more tricky when it comes to compatibility with; real-world source code. Specifically, GCC has historically accepted a huge; superset of expressions as i-c-e's, and a lot of real world code depends on; this unfortunate accident of history (including, e.g., the glibc system; headers). GCC accepts anything its ""fold"" optimizer is capable of reducing to; an integer constant, which means that the definition of what it accepts changes; as its optimizer does. One example is that GCC accepts things like ""``case; X-X:``"" even when ``X`` is a variable, because it can fold this to 0. Another issue are how constants interact with the extensions we support, such; as ``__builtin_constant_p``, ``__builtin_inf``, ``__extension__`` and many; others. C99 obviously does not specify the semantics of any of these; extensions, and the definition of i-c-e does not include them. However, these; extensions are often used in real code, and we have to have a way to reason; about them. Finally, this is not just a problem for semantic analysis. The code generator; and other clients have to be able to fold constants (e.g., to initialize global; variables) and have to handle a superset of what C99 allows. Further, these; clients can benefit from extended information. For example, we know that; ""``foo() || 1``"" always evaluates to ``true``, but we can't replace the; expression wi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:145872,Performance,perform,performs,145872," expression or statement needs to be introduced, along; with patterns to follow to ensure that the new expression or statement works; well across all of the C languages. We focus on expressions, but statements; are similar. #. Introduce parsing actions into the parser. Recursive-descent parsing is; mostly self-explanatory, but there are a few things that are worth keeping; in mind:. * Keep as much source location information as possible! You'll want it later; to produce great diagnostics and support Clang's various features that map; between source code and the AST.; * Write tests for all of the ""bad"" parsing cases, to make sure your recovery; is good. If you have matched delimiters (e.g., parentheses, square; brackets, etc.), use ``Parser::BalancedDelimiterTracker`` to give nice; diagnostics when things go wrong. #. Introduce semantic analysis actions into ``Sema``. Semantic analysis should; always involve two functions: an ``ActOnXXX`` function that will be called; directly from the parser, and a ``BuildXXX`` function that performs the; actual semantic analysis and will (eventually!) build the AST node. It's; fairly common for the ``ActOnCXX`` function to do very little (often just; some minor translation from the parser's representation to ``Sema``'s; representation of the same thing), but the separation is still important:; C++ template instantiation, for example, should always call the ``BuildXXX``; variant. Several notes on semantic analysis before we get into construction; of the AST:. * Your expression probably involves some types and some subexpressions.; Make sure to fully check that those types, and the types of those; subexpressions, meet your expectations. Add implicit conversions where; necessary to make sure that all of the types line up exactly the way you; want them. Write extensive tests to check that you're getting good; diagnostics for mistakes and that you can use various forms of; subexpressions with your expression.; * When type-checking a type",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:147524,Performance,perform,perform,147524," exactly the way you; want them. Write extensive tests to check that you're getting good; diagnostics for mistakes and that you can use various forms of; subexpressions with your expression.; * When type-checking a type or subexpression, make sure to first check; whether the type is ""dependent"" (``Type::isDependentType()``) or whether a; subexpression is type-dependent (``Expr::isTypeDependent()``). If any of; these return ``true``, then you're inside a template and you can't do much; type-checking now. That's normal, and your AST node (when you get there); will have to deal with this case. At this point, you can write tests that; use your expression within templates, but don't try to instantiate the; templates.; * For each subexpression, be sure to call ``Sema::CheckPlaceholderExpr()``; to deal with ""weird"" expressions that don't behave well as subexpressions.; Then, determine whether you need to perform lvalue-to-rvalue conversions; (``Sema::DefaultLvalueConversions``) or the usual unary conversions; (``Sema::UsualUnaryConversions``), for places where the subexpression is; producing a value you intend to use.; * Your ``BuildXXX`` function will probably just return ``ExprError()`` at; this point, since you don't have an AST. That's perfectly fine, and; shouldn't impact your testing. #. Introduce an AST node for your new expression. This starts with declaring; the node in ``include/Basic/StmtNodes.td`` and creating a new class for your; expression in the appropriate ``include/AST/Expr*.h`` header. It's best to; look at the class for a similar expression to get ideas, and there are some; specific things to watch for:. * If you need to allocate memory, use the ``ASTContext`` allocator to; allocate memory. Never use raw ``malloc`` or ``new``, and never hold any; resources in an AST node, because the destructor of an AST node is never; called.; * Make sure that ``getSourceRange()`` covers the exact source range of your; expression. This is needed for diagnostics and for ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:151766,Performance,load,loads,151766,"to scalar/aggregate/complex and; lvalue/rvalue paths, depending on what kind of result your expression; produces. On occasion, this requires some careful factoring of code to; avoid duplication.; * ``CodeGenFunction`` contains functions ``ConvertType`` and; ``ConvertTypeForMem`` that convert Clang's types (``clang::Type*`` or; ``clang::QualType``) to LLVM types. Use the former for values, and the; latter for memory locations: test with the C++ ""``bool``"" type to check; this. If you find that you are having to use LLVM bitcasts to make the; subexpressions of your expression have the type that your expression; expects, STOP! Go fix semantic analysis and the AST so that you don't; need these bitcasts.; * The ``CodeGenFunction`` class has a number of helper functions to make; certain operations easy, such as generating code to produce an lvalue or; an rvalue, or to initialize a memory location with a given value. Prefer; to use these functions rather than directly writing loads and stores,; because these functions take care of some of the tricky details for you; (e.g., for exceptions).; * If your expression requires some special behavior in the event of an; exception, look at the ``push*Cleanup`` functions in ``CodeGenFunction``; to introduce a cleanup. You shouldn't have to deal with; exception-handling directly.; * Testing is extremely important in IR generation. Use ``clang -cc1; -emit-llvm`` and `FileCheck; <https://llvm.org/docs/CommandGuide/FileCheck.html>`_ to verify that you're; generating the right IR. #. Teach template instantiation how to cope with your AST node, which requires; some fairly simple code:. * Make sure that your expression's constructor properly computes the flags; for type dependence (i.e., the type your expression produces can change; from one instantiation to the next), value dependence (i.e., the constant; value your expression produces can change from one instantiation to the; next), instantiation dependence (i.e., a template parameter occu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:153422,Performance,perform,perform,153422,"ur expression's constructor properly computes the flags; for type dependence (i.e., the type your expression produces can change; from one instantiation to the next), value dependence (i.e., the constant; value your expression produces can change from one instantiation to the; next), instantiation dependence (i.e., a template parameter occurs; anywhere in your expression), and whether your expression contains a; parameter pack (for variadic templates). Often, computing these flags; just means combining the results from the various types and; subexpressions.; * Add ``TransformXXX`` and ``RebuildXXX`` functions to the ``TreeTransform``; class template in ``Sema``. ``TransformXXX`` should (recursively); transform all of the subexpressions and types within your expression,; using ``getDerived().TransformYYY``. If all of the subexpressions and; types transform without error, it will then call the ``RebuildXXX``; function, which will in turn call ``getSema().BuildXXX`` to perform; semantic analysis and build your expression.; * To test template instantiation, take those tests you wrote to make sure; that you were type checking with type-dependent expressions and dependent; types (from step #2) and instantiate those templates with various types,; some of which type-check and some that don't, and test the error messages; in each case. #. There are some ""extras"" that make other features work better. It's worth; handling these extras to give your expression complete integration into; Clang:. * Add code completion support for your expression in; ``SemaCodeComplete.cpp``.; * If your expression has types in it, or has any ""interesting"" features; other than subexpressions, extend libclang's ``CursorVisitor`` to provide; proper visitation for your expression, enabling various IDE features such; as syntax highlighting, cross-referencing, and so on. The; ``c-index-test`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come w",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:6022,Safety,recover,recovery,6022,"ies* are mapped into a smaller set (the ``Diagnostic::Level``; enum, {``Ignored``, ``Note``, ``Remark``, ``Warning``, ``Error``, ``Fatal``}) of; output; *levels* by the diagnostics subsystem based on various configuration options.; Clang internally supports a fully fine grained mapping mechanism that allows; you to map almost any diagnostic to the output level that you want. The only; diagnostics that cannot be mapped are ``NOTE``\ s, which always follow the; severity of the previously emitted diagnostic and ``ERROR``\ s, which can only; be mapped to ``Fatal`` (it is not possible to turn an error into a warning, for; example). Diagnostic mappings are used in many ways. For example, if the user specifies; ``-pedantic``, ``EXTENSION`` maps to ``Warning``, if they specify; ``-pedantic-errors``, it turns into ``Error``. This is used to implement; options like ``-Wunused_macros``, ``-Wundef`` etc. Mapping to ``Fatal`` should only be used for diagnostics that are considered so; severe that error recovery won't be able to recover sensibly from them (thus; spewing a ton of bogus errors). One example of this class of error are failure; to ``#include`` a file. The Format String; ^^^^^^^^^^^^^^^^^. The format string for the diagnostic is very simple, but it has some power. It; takes the form of a string in English with markers that indicate where and how; arguments to the diagnostic are inserted and formatted. For example, here are; some simple format strings:. .. code-block:: c++. ""binary integer literals are an extension""; ""format string contains '\\0' within the string body""; ""more '%%' conversions than data arguments""; ""invalid operands to binary expression (%0 and %1)""; ""overloaded '%0' must be a %select{unary|binary|unary or binary}2 operator""; "" (has %1 parameter%s1)"". These examples show some important points of format strings. You can use any; plain ASCII character in the diagnostic string except ""``%``"" without a; problem, but these are C strings, so you have to use a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:6048,Safety,recover,recover,6048,"ies* are mapped into a smaller set (the ``Diagnostic::Level``; enum, {``Ignored``, ``Note``, ``Remark``, ``Warning``, ``Error``, ``Fatal``}) of; output; *levels* by the diagnostics subsystem based on various configuration options.; Clang internally supports a fully fine grained mapping mechanism that allows; you to map almost any diagnostic to the output level that you want. The only; diagnostics that cannot be mapped are ``NOTE``\ s, which always follow the; severity of the previously emitted diagnostic and ``ERROR``\ s, which can only; be mapped to ``Fatal`` (it is not possible to turn an error into a warning, for; example). Diagnostic mappings are used in many ways. For example, if the user specifies; ``-pedantic``, ``EXTENSION`` maps to ``Warning``, if they specify; ``-pedantic-errors``, it turns into ``Error``. This is used to implement; options like ``-Wunused_macros``, ``-Wundef`` etc. Mapping to ``Fatal`` should only be used for diagnostics that are considered so; severe that error recovery won't be able to recover sensibly from them (thus; spewing a ton of bogus errors). One example of this class of error are failure; to ``#include`` a file. The Format String; ^^^^^^^^^^^^^^^^^. The format string for the diagnostic is very simple, but it has some power. It; takes the form of a string in English with markers that indicate where and how; arguments to the diagnostic are inserted and formatted. For example, here are; some simple format strings:. .. code-block:: c++. ""binary integer literals are an extension""; ""format string contains '\\0' within the string body""; ""more '%%' conversions than data arguments""; ""invalid operands to binary expression (%0 and %1)""; ""overloaded '%0' must be a %select{unary|binary|unary or binary}2 operator""; "" (has %1 parameter%s1)"". These examples show some important points of format strings. You can use any; plain ASCII character in the diagnostic string except ""``%``"" without a; problem, but these are C strings, so you have to use a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:8167,Safety,avoid,avoids,8167,"[digit]``"" sequences to specify where and how; arguments to the diagnostic are formatted. Arguments to the diagnostic are numbered according to how they are specified by; the C++ code that :ref:`produces them <internals-producing-diag>`, and are; referenced by ``%0`` .. ``%9``. If you have more than 10 arguments to your; diagnostic, you are doing something wrong :). Unlike ``printf``, there is no; requirement that arguments to the diagnostic end up in the output in the same; order as they are specified, you could have a format string with ""``%1 %0``""; that swaps them, for example. The text in between the percent and digit are; formatting instructions. If there are no instructions, the argument is just; turned into a string and substituted in. Here are some ""best practices"" for writing the English format string:. * Keep the string short. It should ideally fit in the 80 column limit of the; ``DiagnosticKinds.td`` file. This avoids the diagnostic wrapping when; printed, and forces you to think about the important point you are conveying; with the diagnostic.; * Take advantage of location information. The user will be able to see the; line and location of the caret, so you don't need to tell them that the; problem is with the 4th argument to the function: just point to it.; * Do not capitalize the diagnostic string, and do not end it with a period.; * If you need to quote something in the diagnostic string, use single quotes. Diagnostics should never take random English strings as arguments: you; shouldn't use ""``you have a problem with %0``"" and pass in things like ""``your; argument``"" or ""``your return value``"" as arguments. Doing this prevents; :ref:`translating <internals-diag-translation>` the Clang diagnostics to other; languages (because they'll get random English words in their otherwise; localized diagnostic). The exceptions to this are C/C++ language keywords; (e.g., ``auto``, ``const``, ``mutable``, etc) and C/C++ operators (``/=``).; Note that things like ""po",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:13285,Safety,abort,abort,13285," to true is; the result of the modifier. An expression can be empty, in which case it is always true. See the example; at the top. Otherwise, it is a series of one or more numeric conditions,; separated by "","". If any condition matches, the expression matches. Each; numeric condition can take one of three forms. * number: A simple decimal number matches if the argument is the same as the; number. Example: ``""%plural{1:mouse|:mice}0""``; * range: A range in square brackets matches if the argument is within the; range. Then range is inclusive on both ends. Example:; ``""%plural{0:none|1:one|[2,5]:some|:many}0""``; * modulo: A modulo operator is followed by a number, and equals sign and; either a number or a range. The tests are the same as for plain numbers; and ranges, but the argument is taken modulo the number first. Example:; ``""%plural{%100=0:even hundred|%100=[1,50]:lower half|:everything else}1""``. The parser is very unforgiving. A syntax error, even whitespace, will abort,; as will a failure to match the argument against any expression. **""ordinal"" format**. Example:; ``""ambiguity in %ordinal0 argument""``; Class:; Integers; Description:; This is a formatter which represents the argument number as an ordinal: the; value ``1`` becomes ``1st``, ``3`` becomes ``3rd``, and so on. Values less; than ``1`` are not supported. This formatter is currently hard-coded to use; English ordinals. **""objcclass"" format**. Example:; ``""method %objcclass0 not found""``; Class:; ``DeclarationName``; Description:; This is a simple formatter that indicates the ``DeclarationName`` corresponds; to an Objective-C class method selector. As such, it prints the selector; with a leading ""``+``"". **""objcinstance"" format**. Example:; ``""method %objcinstance0 not found""``; Class:; ``DeclarationName``; Description:; This is a simple formatter that indicates the ``DeclarationName`` corresponds; to an Objective-C instance method selector. As such, it prints the selector; with a leading ""``-``"". **""q",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:15570,Safety,avoid,avoid,15570,"ple:; ``""no known conversion %diff{from $ to $|from argument type to parameter type}1,2""``; Class:; ``QualType``; Description:; This formatter takes two ``QualType``\ s and attempts to print a template; difference between the two. If tree printing is off, the text inside the; braces before the pipe is printed, with the formatted text replacing the $.; If tree printing is on, the text after the pipe is printed and a type tree is; printed after the diagnostic message. **""sub"" format**. Example:; Given the following record definition of type ``TextSubstitution``:. .. code-block:: text. def select_ovl_candidate : TextSubstitution<; ""%select{function|constructor}0%select{| template| %2}1"">;. which can be used as. .. code-block:: text. def note_ovl_candidate : Note<; ""candidate %sub{select_ovl_candidate}3,2,1 not viable"">;. and will act as if it was written; ``""candidate %select{function|constructor}3%select{| template| %1}2 not viable""``.; Description:; This format specifier is used to avoid repeating strings verbatim in multiple; diagnostics. The argument to ``%sub`` must name a ``TextSubstitution`` tblgen; record. The substitution must specify all arguments used by the substitution,; and the modifier indexes in the substitution are re-numbered accordingly. The; substituted text must itself be a valid format string before substitution. .. _internals-producing-diag:. Producing the Diagnostic; ^^^^^^^^^^^^^^^^^^^^^^^^. Now that you've created the diagnostic in the ``Diagnostic*Kinds.td`` file, you; need to write the code that detects the condition in question and emits the new; diagnostic. Various components of Clang (e.g., the preprocessor, ``Sema``,; etc.) provide a helper function named ""``Diag``"". It creates a diagnostic and; accepts the arguments, ranges, and other information that goes along with it. For example, the binary expression error comes from code like this:. .. code-block:: c++. if (various things that are bad); Diag(Loc, diag::err_typecheck_invalid_operand",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:16120,Safety,detect,detects,16120,"itution``:. .. code-block:: text. def select_ovl_candidate : TextSubstitution<; ""%select{function|constructor}0%select{| template| %2}1"">;. which can be used as. .. code-block:: text. def note_ovl_candidate : Note<; ""candidate %sub{select_ovl_candidate}3,2,1 not viable"">;. and will act as if it was written; ``""candidate %select{function|constructor}3%select{| template| %1}2 not viable""``.; Description:; This format specifier is used to avoid repeating strings verbatim in multiple; diagnostics. The argument to ``%sub`` must name a ``TextSubstitution`` tblgen; record. The substitution must specify all arguments used by the substitution,; and the modifier indexes in the substitution are re-numbered accordingly. The; substituted text must itself be a valid format string before substitution. .. _internals-producing-diag:. Producing the Diagnostic; ^^^^^^^^^^^^^^^^^^^^^^^^. Now that you've created the diagnostic in the ``Diagnostic*Kinds.td`` file, you; need to write the code that detects the condition in question and emits the new; diagnostic. Various components of Clang (e.g., the preprocessor, ``Sema``,; etc.) provide a helper function named ""``Diag``"". It creates a diagnostic and; accepts the arguments, ranges, and other information that goes along with it. For example, the binary expression error comes from code like this:. .. code-block:: c++. if (various things that are bad); Diag(Loc, diag::err_typecheck_invalid_operands); << lex->getType() << rex->getType(); << lex->getSourceRange() << rex->getSourceRange();. This shows that use of the ``Diag`` method: it takes a location (a; :ref:`SourceLocation <SourceLocation>` object) and a diagnostic enum value; (which matches the name from ``Diagnostic*Kinds.td``). If the diagnostic takes; arguments, they are specified with the ``<<`` operator: the first argument; becomes ``%0``, the second becomes ``%1``, etc. The diagnostic interface; allows you to specify arguments of many different types, including ``int`` and; ``unsign",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:18182,Safety,recover,recover,18182,"``std::string`` for; string arguments, ``DeclarationName`` and ``const IdentifierInfo *`` for names,; ``QualType`` for types, etc. ``SourceRange``\ s are also specified with the; ``<<`` operator, but do not have a specific ordering requirement. As you can see, adding and producing a diagnostic is pretty straightforward.; The hard part is deciding exactly what you need to say to help the user,; picking a suitable wording, and providing the information needed to format it; correctly. The good news is that the call site that issues a diagnostic should; be completely independent of how the diagnostic is formatted and in what; language it is rendered. Fix-It Hints; ^^^^^^^^^^^^. In some cases, the front end emits diagnostics when it is clear that some small; change to the source code would fix the problem. For example, a missing; semicolon at the end of a statement or a use of deprecated syntax that is; easily rewritten into a more modern form. Clang tries very hard to emit the; diagnostic and recover gracefully in these and other cases. However, for these cases where the fix is obvious, the diagnostic can be; annotated with a hint (referred to as a ""fix-it hint"") that describes how to; change the code referenced by the diagnostic to fix the problem. For example,; it might add the missing semicolon at the end of the statement or rewrite the; use of a deprecated construct into something more palatable. Here is one such; example from the C++ front end, where we warn about the right-shift operator; changing meaning from C++98 to C++11:. .. code-block:: text. test.cpp:3:7: warning: use of right-shift operator ('>>') in template argument; will require parentheses in C++11; A<100 >> 2> *a;; ^; ( ). Here, the fix-it hint is suggesting that parentheses be added, and showing; exactly where those parentheses would be inserted into the source code. The; fix-it hints themselves describe what changes to make to the source code in an; abstract manner, which the text diagnostic printer ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:19671,Safety,recover,recover,19671,"or; changing meaning from C++98 to C++11:. .. code-block:: text. test.cpp:3:7: warning: use of right-shift operator ('>>') in template argument; will require parentheses in C++11; A<100 >> 2> *a;; ^; ( ). Here, the fix-it hint is suggesting that parentheses be added, and showing; exactly where those parentheses would be inserted into the source code. The; fix-it hints themselves describe what changes to make to the source code in an; abstract manner, which the text diagnostic printer renders as a line of; ""insertions"" below the caret line. :ref:`Other diagnostic clients; <DiagnosticConsumer>` might choose to render the code differently (e.g., as; markup inline) or even give the user the ability to automatically fix the; problem. Fix-it hints on errors and warnings need to obey these rules:. * Since they are automatically applied if ``-Xclang -fixit`` is passed to the; driver, they should only be used when it's very likely they match the user's; intent.; * Clang must recover from errors as if the fix-it had been applied.; * Fix-it hints on a warning must not change the meaning of the code.; However, a hint may clarify the meaning as intentional, for example by adding; parentheses when the precedence of operators isn't obvious. If a fix-it can't obey these rules, put the fix-it on a note. Fix-its on notes; are not applied automatically. All fix-it hints are described by the ``FixItHint`` class, instances of which; should be attached to the diagnostic using the ``<<`` operator in the same way; that highlighted source ranges and arguments are passed to the diagnostic.; Fix-it hints can be created with one of three constructors:. * ``FixItHint::CreateInsertion(Loc, Code)``. Specifies that the given ``Code`` (a string) should be inserted before the; source location ``Loc``. * ``FixItHint::CreateRemoval(Range)``. Specifies that the code in the given source ``Range`` should be removed. * ``FixItHint::CreateReplacement(Range, Code)``. Specifies that the code in the given sour",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:55551,Safety,detect,detect,55551," of ""``<``"" to return an ""angled string"" instead of a bunch of tokens; for each thing within the filename.; * When parsing a preprocessor directive (after ""``#``"") the; ``ParsingPreprocessorDirective`` mode is entered. This changes the parser to; return EOD at a newline.; * The ``Lexer`` uses a ``LangOptions`` object to know whether trigraphs are; enabled, whether C++ or ObjC keywords are recognized, etc. In addition to these modes, the lexer keeps track of a couple of other features; that are local to a lexed buffer, which change as the buffer is lexed:. * The ``Lexer`` uses ``BufferPtr`` to keep track of the current character being; lexed.; * The ``Lexer`` uses ``IsAtStartOfLine`` to keep track of whether the next; lexed token will start with its ""start of line"" bit set.; * The ``Lexer`` keeps track of the current ""``#if``"" directives that are active; (which can be nested).; * The ``Lexer`` keeps track of an :ref:`MultipleIncludeOpt; <MultipleIncludeOpt>` object, which is used to detect whether the buffer uses; the standard ""``#ifndef XX`` / ``#define XX``"" idiom to prevent multiple; inclusion. If a buffer does, subsequent includes can be ignored if the; ""``XX``"" macro is defined. .. _TokenLexer:. The ``TokenLexer`` class; ------------------------. The ``TokenLexer`` class is a token provider that returns tokens from a list of; tokens that came from somewhere else. It typically used for two things: 1); returning tokens from a macro definition as it is being expanded 2) returning; tokens from an arbitrary buffer of tokens. The later use is used by; ``_Pragma`` and will most likely be used to handle unbounded look-ahead for the; C++ parser. .. _MultipleIncludeOpt:. The ``MultipleIncludeOpt`` class; --------------------------------. The ``MultipleIncludeOpt`` class implements a really simple little state; machine that is used to detect the standard ""``#ifndef XX`` / ``#define XX``""; idiom that people typically use to prevent multiple inclusion of headers. If a; buffer",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:56414,Safety,detect,detect,56414,"an be nested).; * The ``Lexer`` keeps track of an :ref:`MultipleIncludeOpt; <MultipleIncludeOpt>` object, which is used to detect whether the buffer uses; the standard ""``#ifndef XX`` / ``#define XX``"" idiom to prevent multiple; inclusion. If a buffer does, subsequent includes can be ignored if the; ""``XX``"" macro is defined. .. _TokenLexer:. The ``TokenLexer`` class; ------------------------. The ``TokenLexer`` class is a token provider that returns tokens from a list of; tokens that came from somewhere else. It typically used for two things: 1); returning tokens from a macro definition as it is being expanded 2) returning; tokens from an arbitrary buffer of tokens. The later use is used by; ``_Pragma`` and will most likely be used to handle unbounded look-ahead for the; C++ parser. .. _MultipleIncludeOpt:. The ``MultipleIncludeOpt`` class; --------------------------------. The ``MultipleIncludeOpt`` class implements a really simple little state; machine that is used to detect the standard ""``#ifndef XX`` / ``#define XX``""; idiom that people typically use to prevent multiple inclusion of headers. If a; buffer uses this idiom and is subsequently ``#include``'d, the preprocessor can; simply check to see whether the guarding condition is defined or not. If so,; the preprocessor can completely ignore the include of the header. .. _Parser:. The Parser Library; ==================. This library contains a recursive-descent parser that polls tokens from the; preprocessor and notifies a client of the parsing progress. Historically, the parser used to talk to an abstract ``Action`` interface that; had virtual methods for parse events, for example ``ActOnBinOp()``. When Clang; grew C++ support, the parser stopped supporting general ``Action`` clients --; it now always talks to the :ref:`Sema library <Sema>`. However, the Parser; still accesses AST objects only through opaque types like ``ExprResult`` and; ``StmtResult``. Only :ref:`Sema <Sema>` looks at the AST node contents o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:59517,Safety,avoid,avoided,59517,"AST files is simpler:; we do not need to track modifications made to AST nodes imported from AST; files and serialize separate ""update records"". There are unfortunately exceptions to this general approach, such as:. * The first declaration of a redeclarable entity maintains a pointer to the; most recent declaration of that entity, which naturally needs to change as; more declarations are parsed.; * Name lookup tables in declaration contexts change after the namespace; declaration is formed.; * We attempt to maintain only a single declaration for an instantiation of a; template, rather than having distinct declarations for an instantiation of; the declaration versus the definition, so template instantiation often; updates parts of existing declarations.; * Some parts of declarations are required to be instantiated separately (this; includes default arguments and exception specifications), and such; instantiations update the existing declaration. These cases tend to be fragile; mutable AST state should be avoided where; possible. As a consequence of this design principle, we typically do not provide setters; for AST state. (Some are provided for short-term modifications intended to be; used immediately after an AST node is created and before it's ""published"" as; part of the complete AST, or where language semantics require after-the-fact; updates.). Faithfulness; ^^^^^^^^^^^^. The AST intends to provide a representation of the program that is faithful to; the original source. We intend for it to be possible to write refactoring tools; using only information stored in, or easily reconstructible from, the Clang AST.; This means that the AST representation should either not desugar source-level; constructs to simpler forms, or -- where made necessary by language semantics; or a clear engineering tradeoff -- should desugar minimally and wrap the result; in a construct representing the original source form. For example, ``CXXForRangeStmt`` directly represents the syntactic ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:84475,Safety,detect,detect,84475,"on methods of the ``DeclContext``, so; the vast majority of clients can ignore them. Because the same entity can be defined multiple times in different modules,; it is also possible for there to be multiple definitions of (for instance); a ``CXXRecordDecl``, all of which describe a definition of the same class.; In such a case, only one of those ""definitions"" is considered by Clang to be; the definition of the class, and the others are treated as non-defining; declarations that happen to also contain member declarations. Corresponding; members in each definition of such multiply-defined classes are identified; either by redeclaration chains (if the members are ``Redeclarable``); or by simply a pointer to the canonical declaration (if the declarations; are not ``Redeclarable`` -- in that case, a ``Mergeable`` base class is used; instead). Error Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we dont have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:84675,Safety,recover,recovery,84675,"nce); a ``CXXRecordDecl``, all of which describe a definition of the same class.; In such a case, only one of those ""definitions"" is considered by Clang to be; the definition of the class, and the others are treated as non-defining; declarations that happen to also contain member declarations. Corresponding; members in each definition of such multiply-defined classes are identified; either by redeclaration chains (if the members are ``Redeclarable``); or by simply a pointer to the canonical declaration (if the declarations; are not ``Redeclarable`` -- in that case, a ``Mergeable`` base class is used; instead). Error Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we dont have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr was created for semantic analysis. With these strategies, clang surfaces better diagnostics, and provides AST; consumers a rich AST reflecting the written source code as much as possible even; for broken code. Recovery AST; ^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:85339,Safety,recover,recovery,85339,"rror Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we dont have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr was created for semantic analysis. With these strategies, clang surfaces better diagnostics, and provides AST; consumers a rich AST reflecting the written source code as much as possible even; for broken code. Recovery AST; ^^^^^^^^^^^^. The idea of Recovery AST is to use recovery nodes which act as a placeholder to; maintain the rough structure of the parsing tree, preserve locations and; children but have no language semantics attached to them. For example, consider the following mismatched function call:. .. code-block:: c++. int NoArg();; void test(int abc) {; NoArg(abc); // oops, mismatched function arguments.; }. Without Recovery AST, the invalid function call expression (and its child; expressions) would be dropped in the AST:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:85723,Safety,recover,recovery,85723,"out the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we dont have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr was created for semantic analysis. With these strategies, clang surfaces better diagnostics, and provides AST; consumers a rich AST reflecting the written source code as much as possible even; for broken code. Recovery AST; ^^^^^^^^^^^^. The idea of Recovery AST is to use recovery nodes which act as a placeholder to; maintain the rough structure of the parsing tree, preserve locations and; children but have no language semantics attached to them. For example, consider the following mismatched function call:. .. code-block:: c++. int NoArg();; void test(int abc) {; NoArg(abc); // oops, mismatched function arguments.; }. Without Recovery AST, the invalid function call expression (and its child; expressions) would be dropped in the AST:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> col:15 used abc 'int'; `-CompoundStmt <col:20, line:4:1>. With Recovery AST, the AST looks like:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> used abc 'int'; `-CompoundStmt <col:20, line:4:1>; `-RecoveryExpr <line:3:3, col:12> 'int' contains-errors; |-UnresolvedLookupExpr <col:3> '<overloaded function type>' lvalue (ADL) = 'NoArg'; `-DeclRefExpr <col:9> 'int' l",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:87318,Safety,recover,recovery,87318,"armVarDecl <col:11, col:15> col:15 used abc 'int'; `-CompoundStmt <col:20, line:4:1>. With Recovery AST, the AST looks like:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> used abc 'int'; `-CompoundStmt <col:20, line:4:1>; `-RecoveryExpr <line:3:3, col:12> 'int' contains-errors; |-UnresolvedLookupExpr <col:3> '<overloaded function type>' lvalue (ADL) = 'NoArg'; `-DeclRefExpr <col:9> 'int' lvalue ParmVar 'abc' 'int'. An alternative is to use existing Exprs, e.g. CallExpr for the above example.; This would capture more call details (e.g. locations of parentheses) and allow; it to be treated uniformly with valid CallExprs. However, jamming the data we; have into CallExpr forces us to weaken its invariants, e.g. arg count may be; wrong. This would introduce a huge burden on consumers of the AST to handle such; ""impossible"" cases. So when we're representing (rather than correcting) errors,; we use a distinct recovery node type with extremely weak invariants instead. ``RecoveryExpr`` is the only recovery node so far. In practice, broken decls; need more detailed semantics preserved (the current ``Invalid`` flag works; fairly well), and completely broken statements with interesting internal; structure are rare (so dropping the statements is OK). Types and dependence; ^^^^^^^^^^^^^^^^^^^^. ``RecoveryExpr`` is an ``Expr``, so it must have a type. In many cases the true; type can't really be known until the code is corrected (e.g. a call to a; function that doesn't exist). And it means that we can't properly perform type; checks on some containing constructs, such as ``return 42 + unknownFunction()``. To model this, we generalize the concept of dependence from C++ templates to; mean dependence on a template parameter or how an error is repaired. The; ``RecoveryExpr`` ``unknownFunction()`` has the totally unknown type; ``DependentTy``, and this suppresses type-based analysis in the sa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:87406,Safety,recover,recovery,87406,"overy AST, the AST looks like:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> used abc 'int'; `-CompoundStmt <col:20, line:4:1>; `-RecoveryExpr <line:3:3, col:12> 'int' contains-errors; |-UnresolvedLookupExpr <col:3> '<overloaded function type>' lvalue (ADL) = 'NoArg'; `-DeclRefExpr <col:9> 'int' lvalue ParmVar 'abc' 'int'. An alternative is to use existing Exprs, e.g. CallExpr for the above example.; This would capture more call details (e.g. locations of parentheses) and allow; it to be treated uniformly with valid CallExprs. However, jamming the data we; have into CallExpr forces us to weaken its invariants, e.g. arg count may be; wrong. This would introduce a huge burden on consumers of the AST to handle such; ""impossible"" cases. So when we're representing (rather than correcting) errors,; we use a distinct recovery node type with extremely weak invariants instead. ``RecoveryExpr`` is the only recovery node so far. In practice, broken decls; need more detailed semantics preserved (the current ``Invalid`` flag works; fairly well), and completely broken statements with interesting internal; structure are rare (so dropping the statements is OK). Types and dependence; ^^^^^^^^^^^^^^^^^^^^. ``RecoveryExpr`` is an ``Expr``, so it must have a type. In many cases the true; type can't really be known until the code is corrected (e.g. a call to a; function that doesn't exist). And it means that we can't properly perform type; checks on some containing constructs, such as ``return 42 + unknownFunction()``. To model this, we generalize the concept of dependence from C++ templates to; mean dependence on a template parameter or how an error is repaired. The; ``RecoveryExpr`` ``unknownFunction()`` has the totally unknown type; ``DependentTy``, and this suppresses type-based analysis in the same way it; would inside a template. In cases where we are confident about the concrete type (e.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89546,Safety,recover,recoveryExpr,89546,"iagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new ContainsErrors bit to; express Does this expression or anything within it contain errors semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not a tree. It is a directed graph with; cycles. One example of a cycle is the connection between a; ``ClassTemplateDecl`` and its ""templated"" ``CXXRe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89797,Safety,recover,recoveryExpr,89797,"idered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new ContainsErrors bit to; express Does this expression or anything within it contain errors semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not a tree. It is a directed graph with; cycles. One example of a cycle is the connection between a; ``ClassTemplateDecl`` and its ""templated"" ``CXXRecordDecl``. The *templated*; ``CXXRecordDecl`` represents all the fields and methods inside the class; template, while the ``ClassTemplateDecl`` holds the information which is; related to being a template, i.e. template arguments, etc. We can get the; *",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:100148,Safety,avoid,avoid,100148,"arked as imported; also, if a declaration is; already marked as imported then we just return its counterpart in the ""to""; context. Consequently, calling a declaration's ``::Create()`` function directly; would lead to errors, please don't do that!. Even with the use of ``GetImportedOrCreateDecl()`` there is still a; probability of having an infinite import recursion if things are imported from; each other in wrong way. Imagine that during the import of ``A``, the import of; ``B`` is requested before we could create the node for ``A`` (the constructor; needs a reference to ``B``). And the same could be true for the import of ``B``; (``A`` is requested to be imported before we could create the node for ``B``).; In case of the :ref:`templated-described swing <templated>` we take; extra attention to break the cyclical dependency: we import and set the; described template only after the ``CXXRecordDecl`` is created. As a best; practice, before creating the node in the ""to"" context, avoid importing of; other nodes which are not needed for the constructor of node ``A``. Error Handling; ^^^^^^^^^^^^^^. Every import function returns with either an ``llvm::Error`` or an; ``llvm::Expected<T>`` object. This enforces to check the return value of the; import functions. If there was an error during one import then we return with; that error. (Exception: when we import the members of a class, we collect the; individual errors with each member and we concatenate them in one Error; object.) We cache these errors in cases of declarations. During the next import; call if there is an existing error we just return with that. So, clients of the; library receive an Error object, which they must check. During import of a specific declaration, it may happen that some AST nodes had; already been created before we recognize an error. In this case, we signal back; the error to the caller, but the ""to"" context remains polluted with those nodes; which had been created. Ideally, those nodes should n",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:105705,Safety,redund,redundant,105705,"t, then we have an ODR; violation in case of C++. If the ""from"" node is not a definition then we add; that to the redeclaration chain of the found node. This behaviour is essential; when we merge ASTs from different translation units which include the same; header file(s). For example, we want to have only one definition for the class; template ``std::vector``, even if we included ``<vector>`` in several; translation units. To find a structurally equivalent node we can use the regular C/C++ lookup; functions: ``DeclContext::noload_lookup()`` and; ``DeclContext::localUncachedLookup()``. These functions do respect the C/C++; name hiding rules, thus you cannot find certain declarations in a given; declaration context. For instance, unnamed declarations (anonymous structs),; non-first ``friend`` declarations and template specializations are hidden. This; is a problem, because if we use the regular C/C++ lookup then we create; redundant AST nodes during the merge! Also, having two instances of the same; node could result in false :ref:`structural in-equivalencies <structural-eq>`; of other nodes which depend on the duplicated node. Because of these reasons,; we created a lookup class which has the sole purpose to register all; declarations, so later they can be looked up by subsequent import requests.; This is the ``ASTImporterLookupTable`` class. This lookup table should be; shared amongst the different ``ASTImporter`` instances if they happen to import; to the very same ""to"" context. This is why we can use the importer specific; lookup only via the ``ASTImporterSharedState`` class. ExternalASTSource; ~~~~~~~~~~~~~~~~~. The ``ExternalASTSource`` is an abstract interface associated with the; ``ASTContext`` class. It provides the ability to read the declarations stored; within a declaration context either for iteration or for name lookup. A; declaration context with an external AST source may load its declarations; on-demand. This means that the list of declarations (repr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:138745,Safety,avoid,avoid,138745,"few deserve mention. If the parsed form of the attribute is more complex, or differs from the; semantic form, the ``HasCustomParsing`` bit can be set to ``1`` for the class,; and the parsing code in `Parser::ParseGNUAttributeArgs(); <https://github.com/llvm/llvm-project/blob/main/clang/lib/Parse/ParseDecl.cpp>`_; can be updated for the special case. Note that this only applies to arguments; with a GNU spelling -- attributes with a __declspec spelling currently ignore; this flag and are handled by ``Parser::ParseMicrosoftDeclSpec``. Note that setting this member to 1 will opt out of common attribute semantic; handling, requiring extra implementation efforts to ensure the attribute; appertains to the appropriate subject, etc. If the attribute should not be propagated from a template declaration to an; instantiation of the template, set the ``Clone`` member to 0. By default, all; attributes will be cloned to template instantiations. Attributes that do not require an AST node should set the ``ASTNode`` field to; ``0`` to avoid polluting the AST. Note that anything inheriting from; ``TypeAttr`` or ``IgnoredAttr`` automatically do not generate an AST node. All; other attributes generate an AST node by default. The AST node is the semantic; representation of the attribute. The ``LangOpts`` field specifies a list of language options required by the; attribute. For instance, all of the CUDA-specific attributes specify ``[CUDA]``; for the ``LangOpts`` field, and when the CUDA language option is not enabled, an; ""attribute ignored"" warning diagnostic is emitted. Since language options are; not table generated nodes, new language options must be created manually and; should specify the spelling used by ``LangOptions`` class. Custom accessors can be generated for an attribute based on the spelling list; for that attribute. For instance, if an attribute has two different spellings:; 'Foo' and 'Bar', accessors can be created:; ``[Accessor<""isFoo"", [GNU<""Foo"">]>, Accessor<""isBar"", ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:145473,Safety,recover,recovery,145473,"ement; -------------------------------------. Expressions and statements are one of the most fundamental constructs within a; compiler, because they interact with many different parts of the AST, semantic; analysis, and IR generation. Therefore, adding a new expression or statement; kind into Clang requires some care. The following list details the various; places in Clang where an expression or statement needs to be introduced, along; with patterns to follow to ensure that the new expression or statement works; well across all of the C languages. We focus on expressions, but statements; are similar. #. Introduce parsing actions into the parser. Recursive-descent parsing is; mostly self-explanatory, but there are a few things that are worth keeping; in mind:. * Keep as much source location information as possible! You'll want it later; to produce great diagnostics and support Clang's various features that map; between source code and the AST.; * Write tests for all of the ""bad"" parsing cases, to make sure your recovery; is good. If you have matched delimiters (e.g., parentheses, square; brackets, etc.), use ``Parser::BalancedDelimiterTracker`` to give nice; diagnostics when things go wrong. #. Introduce semantic analysis actions into ``Sema``. Semantic analysis should; always involve two functions: an ``ActOnXXX`` function that will be called; directly from the parser, and a ``BuildXXX`` function that performs the; actual semantic analysis and will (eventually!) build the AST node. It's; fairly common for the ``ActOnCXX`` function to do very little (often just; some minor translation from the parser's representation to ``Sema``'s; representation of the same thing), but the separation is still important:; C++ template instantiation, for example, should always call the ``BuildXXX``; variant. Several notes on semantic analysis before we get into construction; of the AST:. * Your expression probably involves some types and some subexpressions.; Make sure to fully check ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:150959,Safety,avoid,avoid,150959,"g it using ``clang -cc1 -ast-print``,; to make sure you're capturing all of the important information about how; the AST was written.; * Inspect the generated AST under ``clang -cc1 -ast-dump`` to verify that; all of the types in the generated AST line up the way you want them.; Remember that clients of the AST should never have to ""think"" to; understand what's going on. For example, all implicit conversions should; show up explicitly in the AST.; * Write tests that use your expression as a subexpression of other,; well-known expressions. Can you call a function using your expression as; an argument? Can you use the ternary operator?. #. Teach code generation to create IR to your AST node. This step is the first; (and only) that requires knowledge of LLVM IR. There are several things to; keep in mind:. * Code generation is separated into scalar/aggregate/complex and; lvalue/rvalue paths, depending on what kind of result your expression; produces. On occasion, this requires some careful factoring of code to; avoid duplication.; * ``CodeGenFunction`` contains functions ``ConvertType`` and; ``ConvertTypeForMem`` that convert Clang's types (``clang::Type*`` or; ``clang::QualType``) to LLVM types. Use the former for values, and the; latter for memory locations: test with the C++ ""``bool``"" type to check; this. If you find that you are having to use LLVM bitcasts to make the; subexpressions of your expression have the type that your expression; expects, STOP! Go fix semantic analysis and the AST so that you don't; need these bitcasts.; * The ``CodeGenFunction`` class has a number of helper functions to make; certain operations easy, such as generating code to produce an lvalue or; an rvalue, or to initialize a memory location with a given value. Prefer; to use these functions rather than directly writing loads and stores,; because these functions take care of some of the tricky details for you; (e.g., for exceptions).; * If your expression requires some special behavior in",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:900,Security,access,access,900,"============================; ""Clang"" CFE Internals Manual; ============================. .. contents::; :local:. Introduction; ============. This document describes some of the more important APIs and internal design; decisions made in the Clang C front-end. The purpose of this document is to; both capture some of this high level information and also describe some of the; design decisions behind it. This is meant for people interested in hacking on; Clang, not for end-users. The description below is categorized by libraries,; and does not describe any of the clients of the libraries. LLVM Support Library; ====================. The LLVM ``libSupport`` library provides many underlying libraries and; `data-structures <https://llvm.org/docs/ProgrammersManual.html>`_, including; command line option processing, various containers and a system abstraction; layer, which is used for file system access. The Clang ""Basic"" Library; =========================. This library certainly needs a better name. The ""basic"" library contains a; number of low-level utilities for tracking and manipulating source buffers,; locations within the source buffers, diagnostics, tokens, target abstraction,; and information about the subset of the language being compiled for. Part of this infrastructure is specific to C (such as the ``TargetInfo``; class), other parts could be reused for other non-C-based languages; (``SourceLocation``, ``SourceManager``, ``Diagnostics``, ``FileManager``).; When and if there is future demand we can figure out if it makes sense to; introduce a new library, move the general classes somewhere else, or introduce; some other solution. We describe the roles of these classes in order of their dependencies. The Diagnostics Subsystem; -------------------------. The Clang Diagnostics subsystem is an important part of how the compiler; communicates with the human. Diagnostics are the warnings and errors produced; when the code is incorrect or dubious. In Clang, each diagnostic ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:31218,Security,access,accessible,31218,"is option belongs to. This is; used by various tools to categorize and sometimes filter options.; * ``Flags`` may contain ""tags"" associated with the option. These may affect how; the option is rendered, or if it's hidden in some contexts.; * ``Visibility`` should be used to specify the drivers in which a particular; option would be available. This attribute will impact tool --help; * ``Alias`` denotes that the option is an alias of another option. This may be; combined with ``AliasArgs`` that holds the implied value. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; + Group<f_Group>, Visibility<[ClangOption, CC1Option]>,; + HelpText<""Load pass plugin from a dynamic shared object file."">;. New options are recognized by the ``clang`` driver mode if ``Visibility`` is; not specified or contains ``ClangOption``. Options intended for ``clang -cc1``; must be explicitly marked with the ``CC1Option`` flag. Flags that specify; ``CC1Option`` but not ``ClangOption`` will only be accessible via ``-cc1``.; This is similar for other driver modes, such as ``clang-cl`` or ``flang``. Next, parse (or manufacture) the command line arguments in the Clang driver and; use them to construct the ``-cc1`` job:. .. code-block:: diff. void Clang::ConstructJob(const ArgList &Args /*...*/) const {; ArgStringList CmdArgs;; // ... + for (const Arg *A : Args.filtered(OPT_fpass_plugin_EQ)) {; + CmdArgs.push_back(Args.MakeArgString(Twine(""-fpass-plugin="") + A->getValue()));; + A->claim();; + }; }. The last step is implementing the ``-cc1`` command line argument; parsing/generation that initializes/serializes the option class (in our case; ``CodeGenOptions``) stored within ``CompilerInvocation``. This can be done; automatically by using the marshalling annotations on the option definition:. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; Group<f_Group>, Flags<[CC1Option]>,; HelpText<""Load pass plugin from a dynamic s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:44923,Security,access,access,44923,"essing C source code. The main; interface to this library for outside clients is the large ``Preprocessor``; class. It contains the various pieces of state that are required to coherently; read tokens out of a translation unit. The core interface to the ``Preprocessor`` object (once it is set up) is the; ``Preprocessor::Lex`` method, which returns the next :ref:`Token <Token>` from; the preprocessor stream. There are two types of token providers that the; preprocessor is capable of reading from: a buffer lexer (provided by the; :ref:`Lexer <Lexer>` class) and a buffered token stream (provided by the; :ref:`TokenLexer <TokenLexer>` class). .. _Token:. The Token class; ---------------. The ``Token`` class is used to represent a single lexed token. Tokens are; intended to be used by the lexer/preprocess and parser libraries, but are not; intended to live beyond them (for example, they should not live in the ASTs). Tokens most often live on the stack (or some other location that is efficient; to access) as the parser is running, but occasionally do get buffered up. For; example, macro definitions are stored as a series of tokens, and the C++; front-end periodically needs to buffer tokens up for tentative parsing and; various pieces of look-ahead. As such, the size of a ``Token`` matters. On a; 32-bit system, ``sizeof(Token)`` is currently 16 bytes. Tokens occur in two forms: :ref:`annotation tokens <AnnotationToken>` and; normal tokens. Normal tokens are those returned by the lexer, annotation; tokens represent semantic information and are produced by the parser, replacing; normal tokens in the token stream. Normal tokens contain the following; information:. * **A SourceLocation** --- This indicates the location of the start of the; token. * **A length** --- This stores the length of the token as stored in the; ``SourceBuffer``. For tokens that include them, this length includes; trigraphs and escaped newlines which are ignored by later phases of the; compiler. By pointi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:46258,Security,hash,hash,46258,"t system, ``sizeof(Token)`` is currently 16 bytes. Tokens occur in two forms: :ref:`annotation tokens <AnnotationToken>` and; normal tokens. Normal tokens are those returned by the lexer, annotation; tokens represent semantic information and are produced by the parser, replacing; normal tokens in the token stream. Normal tokens contain the following; information:. * **A SourceLocation** --- This indicates the location of the start of the; token. * **A length** --- This stores the length of the token as stored in the; ``SourceBuffer``. For tokens that include them, this length includes; trigraphs and escaped newlines which are ignored by later phases of the; compiler. By pointing into the original source buffer, it is always possible; to get the original spelling of a token completely accurately. * **IdentifierInfo** --- If a token takes the form of an identifier, and if; identifier lookup was enabled when the token was lexed (e.g., the lexer was; not reading in ""raw"" mode) this contains a pointer to the unique hash value; for the identifier. Because the lookup happens before keyword; identification, this field is set even for language keywords like ""``for``"". * **TokenKind** --- This indicates the kind of token as classified by the; lexer. This includes things like ``tok::starequal`` (for the ""``*=``""; operator), ``tok::ampamp`` for the ""``&&``"" token, and keyword values (e.g.,; ``tok::kw_for``) for identifiers that correspond to keywords. Note that; some tokens can be spelled multiple ways. For example, C++ supports; ""operator keywords"", where things like ""``and``"" are treated exactly like the; ""``&&``"" operator. In these cases, the kind value is set to ``tok::ampamp``,; which is good for the parser, which doesn't have to consider both forms. For; something that cares about which form is used (e.g., the preprocessor; ""stringize"" operator) the spelling indicates the original form. * **Flags** --- There are currently four flags tracked by the; lexer/preprocessor syste",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:48887,Security,inject,injected,48887,"lling for the; token includes a trigraph or escaped newline. Since this is uncommon,; many pieces of code can fast-path on tokens that did not need cleaning. One interesting (and somewhat unusual) aspect of normal tokens is that they; don't contain any semantic information about the lexed value. For example, if; the token was a pp-number token, we do not represent the value of the number; that was lexed (this is left for later pieces of code to decide).; Additionally, the lexer library has no notion of typedef names vs variable; names: both are returned as identifiers, and the parser is left to decide; whether a specific identifier is a typedef or a variable (tracking this; requires scope information among other things). The parser can do this; translation by replacing tokens returned by the preprocessor with ""Annotation; Tokens"". .. _AnnotationToken:. Annotation Tokens; -----------------. Annotation tokens are tokens that are synthesized by the parser and injected; into the preprocessor's token stream (replacing existing tokens) to record; semantic information found by the parser. For example, if ""``foo``"" is found; to be a typedef, the ""``foo``"" ``tok::identifier`` token is replaced with an; ``tok::annot_typename``. This is useful for a couple of reasons: 1) this makes; it easy to handle qualified type names (e.g., ""``foo::bar::baz<42>::t``"") in; C++ as a single ""token"" in the parser. 2) if the parser backtracks, the; reparse does not need to redo semantic analysis to determine whether a token; sequence is a variable, type, template, etc. Annotation tokens are created by the parser and reinjected into the parser's; token stream (when backtracking is enabled). Because they can only exist in; tokens that the preprocessor-proper is done with, it doesn't need to keep; around flags like ""start of line"" that the preprocessor uses to do its job.; Additionally, an annotation token may ""cover"" a sequence of preprocessor tokens; (e.g., ""``a::b::c``"" is five preprocessor tok",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:57285,Security,access,accesses,57285,". The ``MultipleIncludeOpt`` class implements a really simple little state; machine that is used to detect the standard ""``#ifndef XX`` / ``#define XX``""; idiom that people typically use to prevent multiple inclusion of headers. If a; buffer uses this idiom and is subsequently ``#include``'d, the preprocessor can; simply check to see whether the guarding condition is defined or not. If so,; the preprocessor can completely ignore the include of the header. .. _Parser:. The Parser Library; ==================. This library contains a recursive-descent parser that polls tokens from the; preprocessor and notifies a client of the parsing progress. Historically, the parser used to talk to an abstract ``Action`` interface that; had virtual methods for parse events, for example ``ActOnBinOp()``. When Clang; grew C++ support, the parser stopped supporting general ``Action`` clients --; it now always talks to the :ref:`Sema library <Sema>`. However, the Parser; still accesses AST objects only through opaque types like ``ExprResult`` and; ``StmtResult``. Only :ref:`Sema <Sema>` looks at the AST node contents of these; wrappers. .. _AST:. The AST Library; ===============. .. _ASTPhilosophy:. Design philosophy; -----------------. Immutability; ^^^^^^^^^^^^. Clang AST nodes (types, declarations, statements, expressions, and so on) are; generally designed to be immutable once created. This provides a number of key; benefits:. * Canonicalization of the ""meaning"" of nodes is possible as soon as the nodes; are created, and is not invalidated by later addition of more information.; For example, we :ref:`canonicalize types <CanonicalType>`, and use a; canonicalized representation of expressions when determining whether two; function template declarations involving dependent expressions declare the; same entity.; * AST nodes can be reused when they have the same meaning. For example, we; reuse ``Type`` nodes when representing the same type (but maintain separate; ``TypeLoc``\s for each in",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:61217,Security,access,accessed,61217," necessary by language semantics; or a clear engineering tradeoff -- should desugar minimally and wrap the result; in a construct representing the original source form. For example, ``CXXForRangeStmt`` directly represents the syntactic form of a; range-based for statement, but also holds a semantic representation of the; range declaration and iterator declarations. It does not contain a; fully-desugared ``ForStmt``, however. Some AST nodes (for example, ``ParenExpr``) represent only syntax, and others; (for example, ``ImplicitCastExpr``) represent only semantics, but most nodes; will represent a combination of syntax and associated semantics. Inheritance; is typically used when representing different (but related) syntaxes for nodes; with the same or similar semantics. .. _Type:. The ``Type`` class and its subclasses; -------------------------------------. The ``Type`` class (and its subclasses) are an important part of the AST.; Types are accessed through the ``ASTContext`` class, which implicitly creates; and uniques them as they are needed. Types have a couple of non-obvious; features: 1) they do not capture type qualifiers like ``const`` or ``volatile``; (see :ref:`QualType <QualType>`), and 2) they implicitly capture typedef; information. Once created, types are immutable (unlike decls). Typedefs in C make semantic analysis a bit more complex than it would be without; them. The issue is that we want to capture typedef information and represent it; in the AST perfectly, but the semantics of operations need to ""see through""; typedefs. For example, consider this code:. .. code-block:: c++. void func() {; typedef int foo;; foo X, *Y;; typedef foo *bar;; bar Z;; *X; // error; **Y; // error; **Z; // error; }. The code above is illegal, and thus we expect there to be diagnostics emitted; on the annotated lines. In this example, we expect to get:. .. code-block:: text. test.c:6:1: error: indirection requires pointer operand ('foo' invalid); *X; // error; ^~; test.c:7:1:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:64208,Security,access,access,64208,"e; user-specified type is always immediately available. There are two problems; with this: first, various semantic checks need to make judgements about the; *actual structure* of a type, ignoring typedefs. Second, we need an efficient; way to query whether two types are structurally identical to each other,; ignoring typedefs. The solution to both of these problems is the idea of; canonical types. .. _CanonicalType:. Canonical Types; ^^^^^^^^^^^^^^^. Every instance of the ``Type`` class contains a canonical type pointer. For; simple types with no typedefs involved (e.g., ""``int``"", ""``int*``"",; ""``int**``""), the type just points to itself. For types that have a typedef; somewhere in their structure (e.g., ""``foo``"", ""``foo*``"", ""``foo**``"",; ""``bar``""), the canonical type pointer points to their structurally equivalent; type without any typedefs (e.g., ""``int``"", ""``int*``"", ""``int**``"", and; ""``int*``"" respectively). This design provides a constant time operation (dereferencing the canonical type; pointer) that gives us access to the structure of types. For example, we can; trivially tell that ""``bar``"" and ""``foo*``"" are the same type by dereferencing; their canonical type pointers and doing a pointer comparison (they both point; to the single ""``int*``"" type). Canonical types and typedef types bring up some complexities that must be; carefully managed. Specifically, the ``isa``/``cast``/``dyn_cast`` operators; generally shouldn't be used in code that is inspecting the AST. For example,; when type checking the indirection operator (unary ""``*``"" on a pointer), the; type checker must verify that the operand has a pointer type. It would not be; correct to check that with ""``isa<PointerType>(SubExpr->getType())``"", because; this predicate would fail if the subexpression had a typedef type. The solution to this problem are a set of helper methods on ``Type``, used to; check their properties. In this case, it would be correct to use; ""``SubExpr->getType()->isPointerType",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:65469,Security,access,access,65469,"d typedef types bring up some complexities that must be; carefully managed. Specifically, the ``isa``/``cast``/``dyn_cast`` operators; generally shouldn't be used in code that is inspecting the AST. For example,; when type checking the indirection operator (unary ""``*``"" on a pointer), the; type checker must verify that the operand has a pointer type. It would not be; correct to check that with ""``isa<PointerType>(SubExpr->getType())``"", because; this predicate would fail if the subexpression had a typedef type. The solution to this problem are a set of helper methods on ``Type``, used to; check their properties. In this case, it would be correct to use; ""``SubExpr->getType()->isPointerType()``"" to do the check. This predicate will; return true if the *canonical type is a pointer*, which is true any time the; type is structurally a pointer type. The only hard part here is remembering; not to use the ``isa``/``cast``/``dyn_cast`` operations. The second problem we face is how to get access to the pointer type once we; know it exists. To continue the example, the result type of the indirection; operator is the pointee type of the subexpression. In order to determine the; type, we need to get the instance of ``PointerType`` that best captures the; typedef information in the program. If the type of the expression is literally; a ``PointerType``, we can return that, otherwise we have to dig through the; typedefs to find the pointer type. For example, if the subexpression had type; ""``foo*``"", we could return that type as the result. If the subexpression had; type ""``bar``"", we want to return ""``foo*``"" (note that we do *not* want; ""``int*``""). In order to provide all of this, ``Type`` has a; ``getAsPointerType()`` method that checks whether the type is structurally a; ``PointerType`` and, if so, returns the best one. If not, it returns a null; pointer. This structure is somewhat mystical, but after meditating on it, it will make; sense to you :). .. _QualType:. The ``QualT",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:74964,Security,hash,hash,74964,"emantics-centric view represents the program; semantics. The two views are kept synchronized by semantic analysis while; the ASTs are being constructed. Storage of declarations within that context. Every declaration context can contain some number of declarations. For; example, a C++ class (represented by ``RecordDecl``) contains various member; functions, fields, nested types, and so on. All of these declarations will; be stored within the ``DeclContext``, and one can iterate over the; declarations via [``DeclContext::decls_begin()``,; ``DeclContext::decls_end()``). This mechanism provides the source-centric; view of declarations in the context. Lookup of declarations within that context. The ``DeclContext`` structure provides efficient name lookup for names within; that declaration context. For example, if ``N`` is a namespace we can look; for the name ``N::f`` using ``DeclContext::lookup``. The lookup itself is; based on a lazily-constructed array (for declaration contexts with a small; number of declarations) or hash table (for declaration contexts with more; declarations). The lookup operation provides the semantics-centric view of; the declarations in the context. Ownership of declarations. The ``DeclContext`` owns all of the declarations that were declared within; its declaration context, and is responsible for the management of their; memory as well as their (de-)serialization. All declarations are stored within a declaration context, and one can query; information about the context in which each declaration lives. One can; retrieve the ``DeclContext`` that contains a particular ``Decl`` using; ``Decl::getDeclContext``. However, see the section; :ref:`LexicalAndSemanticContexts` for more information about how to interpret; this context information. .. _Redeclarations:. Redeclarations and Overloads; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Within a translation unit, it is common for an entity to be declared several; times. For example, we might declare a function ""``f``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:77650,Security,access,accessible,77650,"by name; lookup will not be the most recent one.). In the semantics-centric view, overloading of functions is represented; explicitly. For example, given two declarations of a function ""``g``"" that are; overloaded, e.g.,. .. code-block:: c++. void g();; void g(int);. the ``DeclContext::lookup`` operation will return a; ``DeclContext::lookup_result`` that contains a range of iterators over; declarations of ""``g``"". Clients that perform semantic analysis on a program; that is not concerned with the actual source code will primarily use this; semantics-centric view. .. _LexicalAndSemanticContexts:. Lexical and Semantic Contexts; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Each declaration has two potentially different declaration contexts: a; *lexical* context, which corresponds to the source-centric view of the; declaration context, and a *semantic* context, which corresponds to the; semantics-centric view. The lexical context is accessible via; ``Decl::getLexicalDeclContext`` while the semantic context is accessible via; ``Decl::getDeclContext``, both of which return ``DeclContext`` pointers. For; most declarations, the two contexts are identical. For example:. .. code-block:: c++. class X {; public:; void f(int x);; };. Here, the semantic and lexical contexts of ``X::f`` are the ``DeclContext``; associated with the class ``X`` (itself stored as a ``RecordDecl`` AST node).; However, we can now define ``X::f`` out-of-line:. .. code-block:: c++. void X::f(int x = 17) { /* ... */ }. This definition of ""``f``"" has different lexical and semantic contexts. The; lexical context corresponds to the declaration context in which the actual; declaration occurred in the source code, e.g., the translation unit containing; ``X``. Thus, this declaration of ``X::f`` can be found by traversing the; declarations provided by [``decls_begin()``, ``decls_end()``) in the; translation unit. The semantic context of ``X::f`` corresponds to the class ``X``, since this; member function is (semantically) a m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:77728,Security,access,accessible,77728,"by name; lookup will not be the most recent one.). In the semantics-centric view, overloading of functions is represented; explicitly. For example, given two declarations of a function ""``g``"" that are; overloaded, e.g.,. .. code-block:: c++. void g();; void g(int);. the ``DeclContext::lookup`` operation will return a; ``DeclContext::lookup_result`` that contains a range of iterators over; declarations of ""``g``"". Clients that perform semantic analysis on a program; that is not concerned with the actual source code will primarily use this; semantics-centric view. .. _LexicalAndSemanticContexts:. Lexical and Semantic Contexts; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Each declaration has two potentially different declaration contexts: a; *lexical* context, which corresponds to the source-centric view of the; declaration context, and a *semantic* context, which corresponds to the; semantics-centric view. The lexical context is accessible via; ``Decl::getLexicalDeclContext`` while the semantic context is accessible via; ``Decl::getDeclContext``, both of which return ``DeclContext`` pointers. For; most declarations, the two contexts are identical. For example:. .. code-block:: c++. class X {; public:; void f(int x);; };. Here, the semantic and lexical contexts of ``X::f`` are the ``DeclContext``; associated with the class ``X`` (itself stored as a ``RecordDecl`` AST node).; However, we can now define ``X::f`` out-of-line:. .. code-block:: c++. void X::f(int x = 17) { /* ... */ }. This definition of ""``f``"" has different lexical and semantic contexts. The; lexical context corresponds to the declaration context in which the actual; declaration occurred in the source code, e.g., the translation unit containing; ``X``. Thus, this declaration of ``X::f`` can be found by traversing the; declarations provided by [``decls_begin()``, ``decls_end()``) in the; translation unit. The semantic context of ``X::f`` corresponds to the class ``X``, since this; member function is (semantically) a m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:113157,Security,access,accessible,113157,"ontrol-flow of any class that; subclasses ``Stmt``, which includes simple expressions. Control-flow graphs; are especially useful for performing `flow- or path-sensitive; <https://en.wikipedia.org/wiki/Data_flow_analysis#Sensitivities>`_ program; analyses on a given function. Basic Blocks; ^^^^^^^^^^^^. Concretely, an instance of ``CFG`` is a collection of basic blocks. Each basic; block is an instance of ``CFGBlock``, which simply contains an ordered sequence; of ``Stmt*`` (each referring to statements in the AST). The ordering of; statements within a block indicates unconditional flow of control from one; statement to the next. :ref:`Conditional control-flow; <ConditionalControlFlow>` is represented using edges between basic blocks. The; statements within a given ``CFGBlock`` can be traversed using the; ``CFGBlock::*iterator`` interface. A ``CFG`` object owns the instances of ``CFGBlock`` within the control-flow; graph it represents. Each ``CFGBlock`` within a CFG is also uniquely numbered; (accessible via ``CFGBlock::getBlockID()``). Currently the number is based on; the ordering the blocks were created, but no assumptions should be made on how; ``CFGBlocks`` are numbered other than their numbers are unique and that they; are numbered from 0..N-1 (where N is the number of basic blocks in the CFG). Entry and Exit Blocks; ^^^^^^^^^^^^^^^^^^^^^. Each instance of ``CFG`` contains two special blocks: an *entry* block; (accessible via ``CFG::getEntry()``), which has no incoming edges, and an; *exit* block (accessible via ``CFG::getExit()``), which has no outgoing edges.; Neither block contains any statements, and they serve the role of providing a; clear entrance and exit for a body of code such as a function body. The; presence of these empty blocks greatly simplifies the implementation of many; analyses built on top of CFGs. .. _ConditionalControlFlow:. Conditional Control-Flow; ^^^^^^^^^^^^^^^^^^^^^^^^. Conditional control-flow (such as those induced by if-statements",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:113589,Security,access,accessible,113589,"each referring to statements in the AST). The ordering of; statements within a block indicates unconditional flow of control from one; statement to the next. :ref:`Conditional control-flow; <ConditionalControlFlow>` is represented using edges between basic blocks. The; statements within a given ``CFGBlock`` can be traversed using the; ``CFGBlock::*iterator`` interface. A ``CFG`` object owns the instances of ``CFGBlock`` within the control-flow; graph it represents. Each ``CFGBlock`` within a CFG is also uniquely numbered; (accessible via ``CFGBlock::getBlockID()``). Currently the number is based on; the ordering the blocks were created, but no assumptions should be made on how; ``CFGBlocks`` are numbered other than their numbers are unique and that they; are numbered from 0..N-1 (where N is the number of basic blocks in the CFG). Entry and Exit Blocks; ^^^^^^^^^^^^^^^^^^^^^. Each instance of ``CFG`` contains two special blocks: an *entry* block; (accessible via ``CFG::getEntry()``), which has no incoming edges, and an; *exit* block (accessible via ``CFG::getExit()``), which has no outgoing edges.; Neither block contains any statements, and they serve the role of providing a; clear entrance and exit for a body of code such as a function body. The; presence of these empty blocks greatly simplifies the implementation of many; analyses built on top of CFGs. .. _ConditionalControlFlow:. Conditional Control-Flow; ^^^^^^^^^^^^^^^^^^^^^^^^. Conditional control-flow (such as those induced by if-statements and loops) is; represented as edges between ``CFGBlocks``. Because different C language; constructs can induce control-flow, each ``CFGBlock`` also records an extra; ``Stmt*`` that represents the *terminator* of the block. A terminator is; simply the statement that caused the control-flow, and is used to identify the; nature of the conditional control-flow between blocks. For example, in the; case of an if-statement, the terminator refers to the ``IfStmt`` object in the; AS",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:113677,Security,access,accessible,113677,"each referring to statements in the AST). The ordering of; statements within a block indicates unconditional flow of control from one; statement to the next. :ref:`Conditional control-flow; <ConditionalControlFlow>` is represented using edges between basic blocks. The; statements within a given ``CFGBlock`` can be traversed using the; ``CFGBlock::*iterator`` interface. A ``CFG`` object owns the instances of ``CFGBlock`` within the control-flow; graph it represents. Each ``CFGBlock`` within a CFG is also uniquely numbered; (accessible via ``CFGBlock::getBlockID()``). Currently the number is based on; the ordering the blocks were created, but no assumptions should be made on how; ``CFGBlocks`` are numbered other than their numbers are unique and that they; are numbered from 0..N-1 (where N is the number of basic blocks in the CFG). Entry and Exit Blocks; ^^^^^^^^^^^^^^^^^^^^^. Each instance of ``CFG`` contains two special blocks: an *entry* block; (accessible via ``CFG::getEntry()``), which has no incoming edges, and an; *exit* block (accessible via ``CFG::getExit()``), which has no outgoing edges.; Neither block contains any statements, and they serve the role of providing a; clear entrance and exit for a body of code such as a function body. The; presence of these empty blocks greatly simplifies the implementation of many; analyses built on top of CFGs. .. _ConditionalControlFlow:. Conditional Control-Flow; ^^^^^^^^^^^^^^^^^^^^^^^^. Conditional control-flow (such as those induced by if-statements and loops) is; represented as edges between ``CFGBlocks``. Because different C language; constructs can induce control-flow, each ``CFGBlock`` also records an extra; ``Stmt*`` that represents the *terminator* of the block. A terminator is; simply the statement that caused the control-flow, and is used to identify the; nature of the conditional control-flow between blocks. For example, in the; case of an if-statement, the terminator refers to the ``IfStmt`` object in the; AS",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:139462,Security,access,accessors,139462," declaration to an; instantiation of the template, set the ``Clone`` member to 0. By default, all; attributes will be cloned to template instantiations. Attributes that do not require an AST node should set the ``ASTNode`` field to; ``0`` to avoid polluting the AST. Note that anything inheriting from; ``TypeAttr`` or ``IgnoredAttr`` automatically do not generate an AST node. All; other attributes generate an AST node by default. The AST node is the semantic; representation of the attribute. The ``LangOpts`` field specifies a list of language options required by the; attribute. For instance, all of the CUDA-specific attributes specify ``[CUDA]``; for the ``LangOpts`` field, and when the CUDA language option is not enabled, an; ""attribute ignored"" warning diagnostic is emitted. Since language options are; not table generated nodes, new language options must be created manually and; should specify the spelling used by ``LangOptions`` class. Custom accessors can be generated for an attribute based on the spelling list; for that attribute. For instance, if an attribute has two different spellings:; 'Foo' and 'Bar', accessors can be created:; ``[Accessor<""isFoo"", [GNU<""Foo"">]>, Accessor<""isBar"", [GNU<""Bar"">]>]``; These accessors will be generated on the semantic form of the attribute,; accepting no arguments and returning a ``bool``. Attributes that do not require custom semantic handling should set the; ``SemaHandler`` field to ``0``. Note that anything inheriting from; ``IgnoredAttr`` automatically do not get a semantic handler. All other; attributes are assumed to use a semantic handler by default. Attributes; without a semantic handler are not given a parsed attribute ``Kind`` enumerator. ""Simple"" attributes, that require no custom semantic processing aside from what; is automatically provided, should set the ``SimpleHandler`` field to ``1``. Target-specific attributes may share a spelling with other attributes in; different targets. For instance, the ARM and MSP430 ta",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:139631,Security,access,accessors,139631,"uld set the ``ASTNode`` field to; ``0`` to avoid polluting the AST. Note that anything inheriting from; ``TypeAttr`` or ``IgnoredAttr`` automatically do not generate an AST node. All; other attributes generate an AST node by default. The AST node is the semantic; representation of the attribute. The ``LangOpts`` field specifies a list of language options required by the; attribute. For instance, all of the CUDA-specific attributes specify ``[CUDA]``; for the ``LangOpts`` field, and when the CUDA language option is not enabled, an; ""attribute ignored"" warning diagnostic is emitted. Since language options are; not table generated nodes, new language options must be created manually and; should specify the spelling used by ``LangOptions`` class. Custom accessors can be generated for an attribute based on the spelling list; for that attribute. For instance, if an attribute has two different spellings:; 'Foo' and 'Bar', accessors can be created:; ``[Accessor<""isFoo"", [GNU<""Foo"">]>, Accessor<""isBar"", [GNU<""Bar"">]>]``; These accessors will be generated on the semantic form of the attribute,; accepting no arguments and returning a ``bool``. Attributes that do not require custom semantic handling should set the; ``SemaHandler`` field to ``0``. Note that anything inheriting from; ``IgnoredAttr`` automatically do not get a semantic handler. All other; attributes are assumed to use a semantic handler by default. Attributes; without a semantic handler are not given a parsed attribute ``Kind`` enumerator. ""Simple"" attributes, that require no custom semantic processing aside from what; is automatically provided, should set the ``SimpleHandler`` field to ``1``. Target-specific attributes may share a spelling with other attributes in; different targets. For instance, the ARM and MSP430 targets both have an; attribute spelled ``GNU<""interrupt"">``, but with different parsing and semantic; requirements. To support this feature, an attribute inheriting from; ``TargetSpecificAttribute`` m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:139736,Security,access,accessors,139736,"uld set the ``ASTNode`` field to; ``0`` to avoid polluting the AST. Note that anything inheriting from; ``TypeAttr`` or ``IgnoredAttr`` automatically do not generate an AST node. All; other attributes generate an AST node by default. The AST node is the semantic; representation of the attribute. The ``LangOpts`` field specifies a list of language options required by the; attribute. For instance, all of the CUDA-specific attributes specify ``[CUDA]``; for the ``LangOpts`` field, and when the CUDA language option is not enabled, an; ""attribute ignored"" warning diagnostic is emitted. Since language options are; not table generated nodes, new language options must be created manually and; should specify the spelling used by ``LangOptions`` class. Custom accessors can be generated for an attribute based on the spelling list; for that attribute. For instance, if an attribute has two different spellings:; 'Foo' and 'Bar', accessors can be created:; ``[Accessor<""isFoo"", [GNU<""Foo"">]>, Accessor<""isBar"", [GNU<""Bar"">]>]``; These accessors will be generated on the semantic form of the attribute,; accepting no arguments and returning a ``bool``. Attributes that do not require custom semantic handling should set the; ``SemaHandler`` field to ``0``. Note that anything inheriting from; ``IgnoredAttr`` automatically do not get a semantic handler. All other; attributes are assumed to use a semantic handler by default. Attributes; without a semantic handler are not given a parsed attribute ``Kind`` enumerator. ""Simple"" attributes, that require no custom semantic processing aside from what; is automatically provided, should set the ``SimpleHandler`` field to ``1``. Target-specific attributes may share a spelling with other attributes in; different targets. For instance, the ARM and MSP430 targets both have an; attribute spelled ``GNU<""interrupt"">``, but with different parsing and semantic; requirements. To support this feature, an attribute inheriting from; ``TargetSpecificAttribute`` m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:141608,Security,access,access,141608,"ts both have an; attribute spelled ``GNU<""interrupt"">``, but with different parsing and semantic; requirements. To support this feature, an attribute inheriting from; ``TargetSpecificAttribute`` may specify a ``ParseKind`` field. This field; should be the same value between all arguments sharing a spelling, and; corresponds to the parsed attribute's ``Kind`` enumerator. This allows; attributes to share a parsed attribute kind, but have distinct semantic; attribute classes. For instance, ``ParsedAttr`` is the shared; parsed attribute kind, but ARMInterruptAttr and MSP430InterruptAttr are the; semantic attributes generated. By default, attribute arguments are parsed in an evaluated context. If the; arguments for an attribute should be parsed in an unevaluated context (akin to; the way the argument to a ``sizeof`` expression is parsed), set; ``ParseArgumentsAsUnevaluated`` to ``1``. If additional functionality is desired for the semantic form of the attribute,; the ``AdditionalMembers`` field specifies code to be copied verbatim into the; semantic attribute class object, with ``public`` access. If two or more attributes cannot be used in combination on the same declaration; or statement, a ``MutualExclusions`` definition can be supplied to automatically; generate diagnostic code. This will disallow the attribute combinations; regardless of spellings used. Additionally, it will diagnose combinations within; the same attribute list, different attribute list, and redeclarations, as; appropriate. Boilerplate; ^^^^^^^^^^^; All semantic processing of declaration attributes happens in `lib/Sema/SemaDeclAttr.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/lib/Sema/SemaDeclAttr.cpp>`_,; and generally starts in the ``ProcessDeclAttribute()`` function. If the; attribute has the ``SimpleHandler`` field set to ``1`` then the function to; process the attribute will be automatically generated, and nothing needs to be; done here. Otherwise, write a new ``handleYourAttr()`` ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:154646,Security,validat,validate,154646,"expressions and dependent; types (from step #2) and instantiate those templates with various types,; some of which type-check and some that don't, and test the error messages; in each case. #. There are some ""extras"" that make other features work better. It's worth; handling these extras to give your expression complete integration into; Clang:. * Add code completion support for your expression in; ``SemaCodeComplete.cpp``.; * If your expression has types in it, or has any ""interesting"" features; other than subexpressions, extend libclang's ``CursorVisitor`` to provide; proper visitation for your expression, enabling various IDE features such; as syntax highlighting, cross-referencing, and so on. The; ``c-index-test`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come with test coverage demonstrating; the change in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option as a way to; validate diagnostic behavior. This option will use special comments within the; test file to verify that expected diagnostics appear in the correct source; locations. If all of the expected diagnostics match the actual output of Clang,; then the invocation will return normally. If there are discrepancies between; the expected and actual output, Clang will emit detailed information about; which expected diagnostics were not seen or which unexpected diagnostics were; seen, etc. A complete example is:. .. code-block: c++. // RUN: %clang_cc1 -verify %s; int A = B; // expected-error {{use of undeclared identifier 'B'}}. If the test is run and the expected error is emitted on the expected line, the; diagnostic verifier will pass. However, if the expected error does not appear; or appears in a different location than expected, or if additional diagnostics; appear, the diagnostic verifier will fail and emit information as to why. The ``-verify`` com",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:163259,Security,expose,expose,163259,"ype}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, failed assertions, or miscompilations?; * Are there known issues on a particular relevant target?. If the answer to any of these is ""yes"", the feature test macro should either; not be defined or there should be very strong rationale for why the issues; should not prevent defining it. Note, it is acceptable to define the feature; test macro on a per-target basis if needed. When in doubt, being conservative is better than being aggressive. If we don't; claim support for the feature but it does useful things, users can still use it; and provide us with useful feedback on what is missing. But if we claim support; for a feature that has significant bugs, we've eliminated most of the utility; of having a feature testing macro at all because u",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:13024,Testability,test,tests,13024,"e even; the requirements of languages with very complex plural forms, as many Baltic; languages have. The argument consists of a series of expression/form pairs,; separated by "":"", where the first form whose expression evaluates to true is; the result of the modifier. An expression can be empty, in which case it is always true. See the example; at the top. Otherwise, it is a series of one or more numeric conditions,; separated by "","". If any condition matches, the expression matches. Each; numeric condition can take one of three forms. * number: A simple decimal number matches if the argument is the same as the; number. Example: ``""%plural{1:mouse|:mice}0""``; * range: A range in square brackets matches if the argument is within the; range. Then range is inclusive on both ends. Example:; ``""%plural{0:none|1:one|[2,5]:some|:many}0""``; * modulo: A modulo operator is followed by a number, and equals sign and; either a number or a range. The tests are the same as for plain numbers; and ranges, but the argument is taken modulo the number first. Example:; ``""%plural{%100=0:even hundred|%100=[1,50]:lower half|:everything else}1""``. The parser is very unforgiving. A syntax error, even whitespace, will abort,; as will a failure to match the argument against any expression. **""ordinal"" format**. Example:; ``""ambiguity in %ordinal0 argument""``; Class:; Integers; Description:; This is a formatter which represents the argument number as an ordinal: the; value ``1`` becomes ``1st``, ``3`` becomes ``3rd``, and so on. Values less; than ``1`` are not supported. This formatter is currently hard-coded to use; English ordinals. **""objcclass"" format**. Example:; ``""method %objcclass0 not found""``; Class:; ``DeclarationName``; Description:; This is a simple formatter that indicates the ``DeclarationName`` corresponds; to an Objective-C class method selector. As such, it prints the selector; with a leading ""``+``"". **""objcinstance"" format**. Example:; ``""method %objcinstance0 not found""``;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:18755,Testability,test,test,18755,"nt of how the diagnostic is formatted and in what; language it is rendered. Fix-It Hints; ^^^^^^^^^^^^. In some cases, the front end emits diagnostics when it is clear that some small; change to the source code would fix the problem. For example, a missing; semicolon at the end of a statement or a use of deprecated syntax that is; easily rewritten into a more modern form. Clang tries very hard to emit the; diagnostic and recover gracefully in these and other cases. However, for these cases where the fix is obvious, the diagnostic can be; annotated with a hint (referred to as a ""fix-it hint"") that describes how to; change the code referenced by the diagnostic to fix the problem. For example,; it might add the missing semicolon at the end of the statement or rewrite the; use of a deprecated construct into something more palatable. Here is one such; example from the C++ front end, where we warn about the right-shift operator; changing meaning from C++98 to C++11:. .. code-block:: text. test.cpp:3:7: warning: use of right-shift operator ('>>') in template argument; will require parentheses in C++11; A<100 >> 2> *a;; ^; ( ). Here, the fix-it hint is suggesting that parentheses be added, and showing; exactly where those parentheses would be inserted into the source code. The; fix-it hints themselves describe what changes to make to the source code in an; abstract manner, which the text diagnostic printer renders as a line of; ""insertions"" below the caret line. :ref:`Other diagnostic clients; <DiagnosticConsumer>` might choose to render the code differently (e.g., as; markup inline) or even give the user the ability to automatically fix the; problem. Fix-it hints on errors and warnings need to obey these rules:. * Since they are automatically applied if ``-Xclang -fixit`` is passed to the; driver, they should only be used when it's very likely they match the user's; intent.; * Clang must recover from errors as if the fix-it had been applied.; * Fix-it hints on a warning mu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:26857,Testability,log,logical,26857,"==================. The clang Driver and library are documented :doc:`here <DriverInternals>`. Precompiled Headers; ===================. Clang supports precompiled headers (:doc:`PCH <PCHInternals>`), which uses a; serialized representation of Clang's internal data structures, encoded with the; `LLVM bitstream format <https://llvm.org/docs/BitCodeFormat.html>`_. The Frontend Library; ====================. The Frontend library contains functionality useful for building tools on top of; the Clang libraries, for example several methods for outputting diagnostics. Compiler Invocation; -------------------. One of the classes provided by the Frontend library is ``CompilerInvocation``,; which holds information that describe current invocation of the Clang ``-cc1``; frontend. The information typically comes from the command line constructed by; the Clang driver or from clients performing custom initialization. The data; structure is split into logical units used by different parts of the compiler,; for example ``PreprocessorOptions``, ``LanguageOptions`` or ``CodeGenOptions``. Command Line Interface; ----------------------. The command line interface of the Clang ``-cc1`` frontend is defined alongside; the driver options in ``clang/Driver/Options.td``. The information making up an; option definition includes its prefix and name (for example ``-std=``), form and; position of the option value, help text, aliases and more. Each option may; belong to a certain group and can be marked with zero or more flags. Options; accepted by the ``-cc1`` frontend are marked with the ``CC1Option`` flag. Command Line Parsing; --------------------. Option definitions are processed by the ``-gen-opt-parser-defs`` tablegen; backend during early stages of the build. Options are then used for querying an; instance ``llvm::opt::ArgList``, a wrapper around the command line arguments.; This is done in the Clang driver to construct individual jobs based on the; driver arguments and also in the ``Compi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:62162,Testability,test,test,62162,"lasses) are an important part of the AST.; Types are accessed through the ``ASTContext`` class, which implicitly creates; and uniques them as they are needed. Types have a couple of non-obvious; features: 1) they do not capture type qualifiers like ``const`` or ``volatile``; (see :ref:`QualType <QualType>`), and 2) they implicitly capture typedef; information. Once created, types are immutable (unlike decls). Typedefs in C make semantic analysis a bit more complex than it would be without; them. The issue is that we want to capture typedef information and represent it; in the AST perfectly, but the semantics of operations need to ""see through""; typedefs. For example, consider this code:. .. code-block:: c++. void func() {; typedef int foo;; foo X, *Y;; typedef foo *bar;; bar Z;; *X; // error; **Y; // error; **Z; // error; }. The code above is illegal, and thus we expect there to be diagnostics emitted; on the annotated lines. In this example, we expect to get:. .. code-block:: text. test.c:6:1: error: indirection requires pointer operand ('foo' invalid); *X; // error; ^~; test.c:7:1: error: indirection requires pointer operand ('foo' invalid); **Y; // error; ^~~; test.c:8:1: error: indirection requires pointer operand ('foo' invalid); **Z; // error; ^~~. While this example is somewhat silly, it illustrates the point: we want to; retain typedef information where possible, so that we can emit errors about; ""``std::string``"" instead of ""``std::basic_string<char, std:...``"". Doing this; requires properly keeping typedef information (for example, the type of ``X``; is ""``foo``"", not ""``int``""), and requires properly propagating it through the; various operators (for example, the type of ``*Y`` is ""``foo``"", not; ""``int``""). In order to retain this information, the type of these expressions; is an instance of the ``TypedefType`` class, which indicates that the type of; these expressions is a typedef for ""``foo``"". Representing types like this is great for diagnostics, bec",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:62253,Testability,test,test,62253," are accessed through the ``ASTContext`` class, which implicitly creates; and uniques them as they are needed. Types have a couple of non-obvious; features: 1) they do not capture type qualifiers like ``const`` or ``volatile``; (see :ref:`QualType <QualType>`), and 2) they implicitly capture typedef; information. Once created, types are immutable (unlike decls). Typedefs in C make semantic analysis a bit more complex than it would be without; them. The issue is that we want to capture typedef information and represent it; in the AST perfectly, but the semantics of operations need to ""see through""; typedefs. For example, consider this code:. .. code-block:: c++. void func() {; typedef int foo;; foo X, *Y;; typedef foo *bar;; bar Z;; *X; // error; **Y; // error; **Z; // error; }. The code above is illegal, and thus we expect there to be diagnostics emitted; on the annotated lines. In this example, we expect to get:. .. code-block:: text. test.c:6:1: error: indirection requires pointer operand ('foo' invalid); *X; // error; ^~; test.c:7:1: error: indirection requires pointer operand ('foo' invalid); **Y; // error; ^~~; test.c:8:1: error: indirection requires pointer operand ('foo' invalid); **Z; // error; ^~~. While this example is somewhat silly, it illustrates the point: we want to; retain typedef information where possible, so that we can emit errors about; ""``std::string``"" instead of ""``std::basic_string<char, std:...``"". Doing this; requires properly keeping typedef information (for example, the type of ``X``; is ""``foo``"", not ""``int``""), and requires properly propagating it through the; various operators (for example, the type of ``*Y`` is ""``foo``"", not; ""``int``""). In order to retain this information, the type of these expressions; is an instance of the ``TypedefType`` class, which indicates that the type of; these expressions is a typedef for ""``foo``"". Representing types like this is great for diagnostics, because the; user-specified type is always immediate",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:62346,Testability,test,test,62346,"s they are needed. Types have a couple of non-obvious; features: 1) they do not capture type qualifiers like ``const`` or ``volatile``; (see :ref:`QualType <QualType>`), and 2) they implicitly capture typedef; information. Once created, types are immutable (unlike decls). Typedefs in C make semantic analysis a bit more complex than it would be without; them. The issue is that we want to capture typedef information and represent it; in the AST perfectly, but the semantics of operations need to ""see through""; typedefs. For example, consider this code:. .. code-block:: c++. void func() {; typedef int foo;; foo X, *Y;; typedef foo *bar;; bar Z;; *X; // error; **Y; // error; **Z; // error; }. The code above is illegal, and thus we expect there to be diagnostics emitted; on the annotated lines. In this example, we expect to get:. .. code-block:: text. test.c:6:1: error: indirection requires pointer operand ('foo' invalid); *X; // error; ^~; test.c:7:1: error: indirection requires pointer operand ('foo' invalid); **Y; // error; ^~~; test.c:8:1: error: indirection requires pointer operand ('foo' invalid); **Z; // error; ^~~. While this example is somewhat silly, it illustrates the point: we want to; retain typedef information where possible, so that we can emit errors about; ""``std::string``"" instead of ""``std::basic_string<char, std:...``"". Doing this; requires properly keeping typedef information (for example, the type of ``X``; is ""``foo``"", not ""``int``""), and requires properly propagating it through the; various operators (for example, the type of ``*Y`` is ""``foo``"", not; ""``int``""). In order to retain this information, the type of these expressions; is an instance of the ``TypedefType`` class, which indicates that the type of; these expressions is a typedef for ""``foo``"". Representing types like this is great for diagnostics, because the; user-specified type is always immediately available. There are two problems; with this: first, various semantic checks need to make",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:79040,Testability,log,logically,79040," a ``RecordDecl`` AST node).; However, we can now define ``X::f`` out-of-line:. .. code-block:: c++. void X::f(int x = 17) { /* ... */ }. This definition of ""``f``"" has different lexical and semantic contexts. The; lexical context corresponds to the declaration context in which the actual; declaration occurred in the source code, e.g., the translation unit containing; ``X``. Thus, this declaration of ``X::f`` can be found by traversing the; declarations provided by [``decls_begin()``, ``decls_end()``) in the; translation unit. The semantic context of ``X::f`` corresponds to the class ``X``, since this; member function is (semantically) a member of ``X``. Lookup of the name ``f``; into the ``DeclContext`` associated with ``X`` will then return the definition; of ``X::f`` (including information about the default argument). Transparent Declaration Contexts; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In C and C++, there are several contexts in which names that are logically; declared inside another declaration will actually ""leak"" out into the enclosing; scope from the perspective of name lookup. The most obvious instance of this; behavior is in enumeration types, e.g.,. .. code-block:: c++. enum Color {; Red,; Green,; Blue; };. Here, ``Color`` is an enumeration, which is a declaration context that contains; the enumerators ``Red``, ``Green``, and ``Blue``. Thus, traversing the list of; declarations contained in the enumeration ``Color`` will yield ``Red``,; ``Green``, and ``Blue``. However, outside of the scope of ``Color`` one can; name the enumerator ``Red`` without qualifying the name, e.g.,. .. code-block:: c++. Color c = Red;. There are other entities in C++ that provide similar behavior. For example,; linkage specifications that use curly braces:. .. code-block:: c++. extern ""C"" {; void f(int);; void g(int);; }; // f and g are visible here. For source-level accuracy, we treat the linkage specification and enumeration; type as a declaration context in which its enclosed de",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:86004,Testability,test,test,86004,"n is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form, e.g. when the ""declaration"" part of the declaration contains semantic; errors, the Decl node is marked as invalid.; - dropping invalid node: this often happens for errors that we dont have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr was created for semantic analysis. With these strategies, clang surfaces better diagnostics, and provides AST; consumers a rich AST reflecting the written source code as much as possible even; for broken code. Recovery AST; ^^^^^^^^^^^^. The idea of Recovery AST is to use recovery nodes which act as a placeholder to; maintain the rough structure of the parsing tree, preserve locations and; children but have no language semantics attached to them. For example, consider the following mismatched function call:. .. code-block:: c++. int NoArg();; void test(int abc) {; NoArg(abc); // oops, mismatched function arguments.; }. Without Recovery AST, the invalid function call expression (and its child; expressions) would be dropped in the AST:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> col:15 used abc 'int'; `-CompoundStmt <col:20, line:4:1>. With Recovery AST, the AST looks like:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> used abc 'int'; `-CompoundStmt <col:20, line:4:1>; `-RecoveryExpr <line:3:3, col:12> 'int' contains-errors; |-UnresolvedLookupExpr <col:3> '<overloaded function type>' lvalue (ADL) = 'NoArg'; `-DeclRefExpr <col:9> 'int' lvalue ParmVar 'abc' 'int'. An alternative is to use existing Exprs, e.g. CallExpr for the above example.; This would capture more call details (e.g. locations of parentheses) and allow; it to be treated uniformly with valid CallExprs.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:86285,Testability,test,test,86285,"ens for errors that we dont have; graceful recovery. Prior to Recovery AST, a mismatched-argument function call; expression was dropped though a CallExpr was created for semantic analysis. With these strategies, clang surfaces better diagnostics, and provides AST; consumers a rich AST reflecting the written source code as much as possible even; for broken code. Recovery AST; ^^^^^^^^^^^^. The idea of Recovery AST is to use recovery nodes which act as a placeholder to; maintain the rough structure of the parsing tree, preserve locations and; children but have no language semantics attached to them. For example, consider the following mismatched function call:. .. code-block:: c++. int NoArg();; void test(int abc) {; NoArg(abc); // oops, mismatched function arguments.; }. Without Recovery AST, the invalid function call expression (and its child; expressions) would be dropped in the AST:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> col:15 used abc 'int'; `-CompoundStmt <col:20, line:4:1>. With Recovery AST, the AST looks like:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> used abc 'int'; `-CompoundStmt <col:20, line:4:1>; `-RecoveryExpr <line:3:3, col:12> 'int' contains-errors; |-UnresolvedLookupExpr <col:3> '<overloaded function type>' lvalue (ADL) = 'NoArg'; `-DeclRefExpr <col:9> 'int' lvalue ParmVar 'abc' 'int'. An alternative is to use existing Exprs, e.g. CallExpr for the above example.; This would capture more call details (e.g. locations of parentheses) and allow; it to be treated uniformly with valid CallExprs. However, jamming the data we; have into CallExpr forces us to weaken its invariants, e.g. arg count may be; wrong. This would introduce a huge burden on consumers of the AST to handle such; ""impossible"" cases. So when we're representing (rather than correcting) erro",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:86523,Testability,test,test,86523,"possible even; for broken code. Recovery AST; ^^^^^^^^^^^^. The idea of Recovery AST is to use recovery nodes which act as a placeholder to; maintain the rough structure of the parsing tree, preserve locations and; children but have no language semantics attached to them. For example, consider the following mismatched function call:. .. code-block:: c++. int NoArg();; void test(int abc) {; NoArg(abc); // oops, mismatched function arguments.; }. Without Recovery AST, the invalid function call expression (and its child; expressions) would be dropped in the AST:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> col:15 used abc 'int'; `-CompoundStmt <col:20, line:4:1>. With Recovery AST, the AST looks like:. ::. |-FunctionDecl <line:1:1, col:11> NoArg 'int ()'; `-FunctionDecl <line:2:1, line:4:1> test 'void (int)'; |-ParmVarDecl <col:11, col:15> used abc 'int'; `-CompoundStmt <col:20, line:4:1>; `-RecoveryExpr <line:3:3, col:12> 'int' contains-errors; |-UnresolvedLookupExpr <col:3> '<overloaded function type>' lvalue (ADL) = 'NoArg'; `-DeclRefExpr <col:9> 'int' lvalue ParmVar 'abc' 'int'. An alternative is to use existing Exprs, e.g. CallExpr for the above example.; This would capture more call details (e.g. locations of parentheses) and allow; it to be treated uniformly with valid CallExprs. However, jamming the data we; have into CallExpr forces us to weaken its invariants, e.g. arg count may be; wrong. This would introduce a huge burden on consumers of the AST to handle such; ""impossible"" cases. So when we're representing (rather than correcting) errors,; we use a distinct recovery node type with extremely weak invariants instead. ``RecoveryExpr`` is the only recovery node so far. In practice, broken decls; need more detailed semantics preserved (the current ``Invalid`` flag works; fairly well), and completely broken statements with interesting internal; structure are rare (so ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:133094,Testability,log,logic,133094,"be spelled ``[[arm::streaming]]``, since compilers; that don't understand ``arm::streaming`` would ignore it and miscompile; the code. ``ArmStreaming`` is instead spelled ``__arm_streaming``, but it; can appear wherever a hypothetical ``[[arm::streaming]]`` could appear. Subjects; ~~~~~~~~; Attributes appertain to one or more subjects. If the attribute attempts to; attach to a subject that is not in the subject list, a diagnostic is issued; automatically. Whether the diagnostic is a warning or an error depends on how; the attribute's ``SubjectList`` is defined, but the default behavior is to warn.; The diagnostics displayed to the user are automatically determined based on the; subjects in the list, but a custom diagnostic parameter can also be specified in; the ``SubjectList``. The diagnostics generated for subject list violations are; calculated automatically or specified by the subject list itself. If a; previously unused Decl node is added to the ``SubjectList``, the logic used to; automatically determine the diagnostic parameter in `utils/TableGen/ClangAttrEmitter.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/utils/TableGen/ClangAttrEmitter.cpp>`_; may need to be updated. By default, all subjects in the SubjectList must either be a Decl node defined; in ``DeclNodes.td``, or a statement node defined in ``StmtNodes.td``. However,; more complex subjects can be created by creating a ``SubsetSubject`` object.; Each such object has a base subject which it appertains to (which must be a; Decl or Stmt node, and not a SubsetSubject node), and some custom code which is; called when determining whether an attribute appertains to the subject. For; instance, a ``NonBitField`` SubsetSubject appertains to a ``FieldDecl``, and; tests whether the given FieldDecl is a bit field. When a SubsetSubject is; specified in a SubjectList, a custom diagnostic parameter must also be provided. Diagnostic checking for attribute subject lists for declaration and statement; attri",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:133868,Testability,test,tests,133868," can also be specified in; the ``SubjectList``. The diagnostics generated for subject list violations are; calculated automatically or specified by the subject list itself. If a; previously unused Decl node is added to the ``SubjectList``, the logic used to; automatically determine the diagnostic parameter in `utils/TableGen/ClangAttrEmitter.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/utils/TableGen/ClangAttrEmitter.cpp>`_; may need to be updated. By default, all subjects in the SubjectList must either be a Decl node defined; in ``DeclNodes.td``, or a statement node defined in ``StmtNodes.td``. However,; more complex subjects can be created by creating a ``SubsetSubject`` object.; Each such object has a base subject which it appertains to (which must be a; Decl or Stmt node, and not a SubsetSubject node), and some custom code which is; called when determining whether an attribute appertains to the subject. For; instance, a ``NonBitField`` SubsetSubject appertains to a ``FieldDecl``, and; tests whether the given FieldDecl is a bit field. When a SubsetSubject is; specified in a SubjectList, a custom diagnostic parameter must also be provided. Diagnostic checking for attribute subject lists for declaration and statement; attributes is automated except when ``HasCustomParsing`` is set to ``1``. Documentation; ~~~~~~~~~~~~~; All attributes must have some form of documentation associated with them.; Documentation is table generated on the public web server by a server-side; process that runs daily. Generally, the documentation for an attribute is a; stand-alone definition in `include/clang/Basic/AttrDocs.td; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/AttrDocs.td>`_; that is named after the attribute being documented. If the attribute is not for public consumption, or is an implicitly-created; attribute that has no visible spelling, the documentation list can specify the; ``InternalOnly`` object. Otherwise, the attribute should ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:136015,Testability,test,tested,136015," the actual documentation itself.; Additionally, it can specify a custom heading for the attribute, though a; default heading will be chosen when possible. There are four predefined documentation categories: ``DocCatFunction`` for; attributes that appertain to function-like subjects, ``DocCatVariable`` for; attributes that appertain to variable-like subjects, ``DocCatType`` for type; attributes, and ``DocCatStmt`` for statement attributes. A custom documentation; category should be used for groups of attributes with similar functionality.; Custom categories are good for providing overview information for the attributes; grouped under it. For instance, the consumed annotation attributes define a; custom category, ``DocCatConsumed``, that explains what consumed annotations are; at a high level. Documentation content (whether it is for an attribute or a category) is written; using reStructuredText (RST) syntax. After writing the documentation for the attribute, it should be locally tested; to ensure that there are no issues generating the documentation on the server.; Local testing requires a fresh build of clang-tblgen. To generate the attribute; documentation, execute the following command::. clang-tblgen -gen-attr-docs -I /path/to/clang/include /path/to/clang/include/clang/Basic/Attr.td -o /path/to/clang/docs/AttributeReference.rst. When testing locally, *do not* commit changes to ``AttributeReference.rst``.; This file is generated by the server automatically, and any changes made to this; file will be overwritten. Arguments; ~~~~~~~~~; Attributes may optionally specify a list of arguments that can be passed to the; attribute. Attribute arguments specify both the parsed form and the semantic; form of the attribute. For example, if ``Args`` is; ``[StringArgument<""Arg1"">, IntArgument<""Arg2"">]`` then; ``__attribute__((myattribute(""Hello"", 3)))`` will be a valid use; it requires; two arguments while parsing, and the Attr subclass' constructor for the; semantic attribute ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:136109,Testability,test,testing,136109,"a; default heading will be chosen when possible. There are four predefined documentation categories: ``DocCatFunction`` for; attributes that appertain to function-like subjects, ``DocCatVariable`` for; attributes that appertain to variable-like subjects, ``DocCatType`` for type; attributes, and ``DocCatStmt`` for statement attributes. A custom documentation; category should be used for groups of attributes with similar functionality.; Custom categories are good for providing overview information for the attributes; grouped under it. For instance, the consumed annotation attributes define a; custom category, ``DocCatConsumed``, that explains what consumed annotations are; at a high level. Documentation content (whether it is for an attribute or a category) is written; using reStructuredText (RST) syntax. After writing the documentation for the attribute, it should be locally tested; to ensure that there are no issues generating the documentation on the server.; Local testing requires a fresh build of clang-tblgen. To generate the attribute; documentation, execute the following command::. clang-tblgen -gen-attr-docs -I /path/to/clang/include /path/to/clang/include/clang/Basic/Attr.td -o /path/to/clang/docs/AttributeReference.rst. When testing locally, *do not* commit changes to ``AttributeReference.rst``.; This file is generated by the server automatically, and any changes made to this; file will be overwritten. Arguments; ~~~~~~~~~; Attributes may optionally specify a list of arguments that can be passed to the; attribute. Attribute arguments specify both the parsed form and the semantic; form of the attribute. For example, if ``Args`` is; ``[StringArgument<""Arg1"">, IntArgument<""Arg2"">]`` then; ``__attribute__((myattribute(""Hello"", 3)))`` will be a valid use; it requires; two arguments while parsing, and the Attr subclass' constructor for the; semantic attribute will require a string and integer argument. All arguments have a name and a flag that specifies whether the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:136381,Testability,test,testing,136381,"tributes, and ``DocCatStmt`` for statement attributes. A custom documentation; category should be used for groups of attributes with similar functionality.; Custom categories are good for providing overview information for the attributes; grouped under it. For instance, the consumed annotation attributes define a; custom category, ``DocCatConsumed``, that explains what consumed annotations are; at a high level. Documentation content (whether it is for an attribute or a category) is written; using reStructuredText (RST) syntax. After writing the documentation for the attribute, it should be locally tested; to ensure that there are no issues generating the documentation on the server.; Local testing requires a fresh build of clang-tblgen. To generate the attribute; documentation, execute the following command::. clang-tblgen -gen-attr-docs -I /path/to/clang/include /path/to/clang/include/clang/Basic/Attr.td -o /path/to/clang/docs/AttributeReference.rst. When testing locally, *do not* commit changes to ``AttributeReference.rst``.; This file is generated by the server automatically, and any changes made to this; file will be overwritten. Arguments; ~~~~~~~~~; Attributes may optionally specify a list of arguments that can be passed to the; attribute. Attribute arguments specify both the parsed form and the semantic; form of the attribute. For example, if ``Args`` is; ``[StringArgument<""Arg1"">, IntArgument<""Arg2"">]`` then; ``__attribute__((myattribute(""Hello"", 3)))`` will be a valid use; it requires; two arguments while parsing, and the Attr subclass' constructor for the; semantic attribute will require a string and integer argument. All arguments have a name and a flag that specifies whether the argument is; optional. The associated C++ type of the argument is determined by the argument; definition type. If the existing argument types are insufficient, new types can; be created, but it requires modifying `utils/TableGen/ClangAttrEmitter.cpp; <https://github.com/llvm/llvm-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:142589,Testability,log,logic,142589,"``public`` access. If two or more attributes cannot be used in combination on the same declaration; or statement, a ``MutualExclusions`` definition can be supplied to automatically; generate diagnostic code. This will disallow the attribute combinations; regardless of spellings used. Additionally, it will diagnose combinations within; the same attribute list, different attribute list, and redeclarations, as; appropriate. Boilerplate; ^^^^^^^^^^^; All semantic processing of declaration attributes happens in `lib/Sema/SemaDeclAttr.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/lib/Sema/SemaDeclAttr.cpp>`_,; and generally starts in the ``ProcessDeclAttribute()`` function. If the; attribute has the ``SimpleHandler`` field set to ``1`` then the function to; process the attribute will be automatically generated, and nothing needs to be; done here. Otherwise, write a new ``handleYourAttr()`` function, and add that to; the switch statement. Please do not implement handling logic directly in the; ``case`` for the attribute. Unless otherwise specified by the attribute definition, common semantic checking; of the parsed attribute is handled automatically. This includes diagnosing; parsed attributes that do not appertain to the given ``Decl`` or ``Stmt``,; ensuring the correct minimum number of arguments are passed, etc. If the attribute adds additional warnings, define a ``DiagGroup`` in; `include/clang/Basic/DiagnosticGroups.td; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/DiagnosticGroups.td>`_; named after the attribute's ``Spelling`` with ""_""s replaced by ""-""s. If there; is only a single diagnostic, it is permissible to use ``InGroup<DiagGroup<""your-attribute"">>``; directly in `DiagnosticSemaKinds.td; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/DiagnosticSemaKinds.td>`_. All semantic diagnostics generated for your attribute, including automatically-; generated ones (such as subjects and argument counts)",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:143628,Testability,test,test,143628,"ment. Please do not implement handling logic directly in the; ``case`` for the attribute. Unless otherwise specified by the attribute definition, common semantic checking; of the parsed attribute is handled automatically. This includes diagnosing; parsed attributes that do not appertain to the given ``Decl`` or ``Stmt``,; ensuring the correct minimum number of arguments are passed, etc. If the attribute adds additional warnings, define a ``DiagGroup`` in; `include/clang/Basic/DiagnosticGroups.td; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/DiagnosticGroups.td>`_; named after the attribute's ``Spelling`` with ""_""s replaced by ""-""s. If there; is only a single diagnostic, it is permissible to use ``InGroup<DiagGroup<""your-attribute"">>``; directly in `DiagnosticSemaKinds.td; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/DiagnosticSemaKinds.td>`_. All semantic diagnostics generated for your attribute, including automatically-; generated ones (such as subjects and argument counts), should have a; corresponding test case. Semantic handling; ^^^^^^^^^^^^^^^^^; Most attributes are implemented to have some effect on the compiler. For; instance, to modify the way code is generated, or to add extra semantic checks; for an analysis pass, etc. Having added the attribute definition and conversion; to the semantic representation for the attribute, what remains is to implement; the custom logic requiring use of the attribute. The ``clang::Decl`` object can be queried for the presence or absence of an; attribute using ``hasAttr<T>()``. To obtain a pointer to the semantic; representation of the attribute, ``getAttr<T>`` may be used. The ``clang::AttributedStmt`` object can be queried for the presence or absence; of an attribute by calling ``getAttrs()`` and looping over the list of; attributes. How to add an expression or statement; -------------------------------------. Expressions and statements are one of the most fundamenta",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:144003,Testability,log,logic,144003,"ttribute adds additional warnings, define a ``DiagGroup`` in; `include/clang/Basic/DiagnosticGroups.td; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/DiagnosticGroups.td>`_; named after the attribute's ``Spelling`` with ""_""s replaced by ""-""s. If there; is only a single diagnostic, it is permissible to use ``InGroup<DiagGroup<""your-attribute"">>``; directly in `DiagnosticSemaKinds.td; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/DiagnosticSemaKinds.td>`_. All semantic diagnostics generated for your attribute, including automatically-; generated ones (such as subjects and argument counts), should have a; corresponding test case. Semantic handling; ^^^^^^^^^^^^^^^^^; Most attributes are implemented to have some effect on the compiler. For; instance, to modify the way code is generated, or to add extra semantic checks; for an analysis pass, etc. Having added the attribute definition and conversion; to the semantic representation for the attribute, what remains is to implement; the custom logic requiring use of the attribute. The ``clang::Decl`` object can be queried for the presence or absence of an; attribute using ``hasAttr<T>()``. To obtain a pointer to the semantic; representation of the attribute, ``getAttr<T>`` may be used. The ``clang::AttributedStmt`` object can be queried for the presence or absence; of an attribute by calling ``getAttrs()`` and looping over the list of; attributes. How to add an expression or statement; -------------------------------------. Expressions and statements are one of the most fundamental constructs within a; compiler, because they interact with many different parts of the AST, semantic; analysis, and IR generation. Therefore, adding a new expression or statement; kind into Clang requires some care. The following list details the various; places in Clang where an expression or statement needs to be introduced, along; with patterns to follow to ensure that the new expression or s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:145413,Testability,test,tests,145413,"ement; -------------------------------------. Expressions and statements are one of the most fundamental constructs within a; compiler, because they interact with many different parts of the AST, semantic; analysis, and IR generation. Therefore, adding a new expression or statement; kind into Clang requires some care. The following list details the various; places in Clang where an expression or statement needs to be introduced, along; with patterns to follow to ensure that the new expression or statement works; well across all of the C languages. We focus on expressions, but statements; are similar. #. Introduce parsing actions into the parser. Recursive-descent parsing is; mostly self-explanatory, but there are a few things that are worth keeping; in mind:. * Keep as much source location information as possible! You'll want it later; to produce great diagnostics and support Clang's various features that map; between source code and the AST.; * Write tests for all of the ""bad"" parsing cases, to make sure your recovery; is good. If you have matched delimiters (e.g., parentheses, square; brackets, etc.), use ``Parser::BalancedDelimiterTracker`` to give nice; diagnostics when things go wrong. #. Introduce semantic analysis actions into ``Sema``. Semantic analysis should; always involve two functions: an ``ActOnXXX`` function that will be called; directly from the parser, and a ``BuildXXX`` function that performs the; actual semantic analysis and will (eventually!) build the AST node. It's; fairly common for the ``ActOnCXX`` function to do very little (often just; some minor translation from the parser's representation to ``Sema``'s; representation of the same thing), but the separation is still important:; C++ template instantiation, for example, should always call the ``BuildXXX``; variant. Several notes on semantic analysis before we get into construction; of the AST:. * Your expression probably involves some types and some subexpressions.; Make sure to fully check ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:146662,Testability,test,tests,146662,"ysis should; always involve two functions: an ``ActOnXXX`` function that will be called; directly from the parser, and a ``BuildXXX`` function that performs the; actual semantic analysis and will (eventually!) build the AST node. It's; fairly common for the ``ActOnCXX`` function to do very little (often just; some minor translation from the parser's representation to ``Sema``'s; representation of the same thing), but the separation is still important:; C++ template instantiation, for example, should always call the ``BuildXXX``; variant. Several notes on semantic analysis before we get into construction; of the AST:. * Your expression probably involves some types and some subexpressions.; Make sure to fully check that those types, and the types of those; subexpressions, meet your expectations. Add implicit conversions where; necessary to make sure that all of the types line up exactly the way you; want them. Write extensive tests to check that you're getting good; diagnostics for mistakes and that you can use various forms of; subexpressions with your expression.; * When type-checking a type or subexpression, make sure to first check; whether the type is ""dependent"" (``Type::isDependentType()``) or whether a; subexpression is type-dependent (``Expr::isTypeDependent()``). If any of; these return ``true``, then you're inside a template and you can't do much; type-checking now. That's normal, and your AST node (when you get there); will have to deal with this case. At this point, you can write tests that; use your expression within templates, but don't try to instantiate the; templates.; * For each subexpression, be sure to call ``Sema::CheckPlaceholderExpr()``; to deal with ""weird"" expressions that don't behave well as subexpressions.; Then, determine whether you need to perform lvalue-to-rvalue conversions; (``Sema::DefaultLvalueConversions``) or the usual unary conversions; (``Sema::UsualUnaryConversions``), for places where the subexpression is; producing a value y",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:147240,Testability,test,tests,147240,"ral notes on semantic analysis before we get into construction; of the AST:. * Your expression probably involves some types and some subexpressions.; Make sure to fully check that those types, and the types of those; subexpressions, meet your expectations. Add implicit conversions where; necessary to make sure that all of the types line up exactly the way you; want them. Write extensive tests to check that you're getting good; diagnostics for mistakes and that you can use various forms of; subexpressions with your expression.; * When type-checking a type or subexpression, make sure to first check; whether the type is ""dependent"" (``Type::isDependentType()``) or whether a; subexpression is type-dependent (``Expr::isTypeDependent()``). If any of; these return ``true``, then you're inside a template and you can't do much; type-checking now. That's normal, and your AST node (when you get there); will have to deal with this case. At this point, you can write tests that; use your expression within templates, but don't try to instantiate the; templates.; * For each subexpression, be sure to call ``Sema::CheckPlaceholderExpr()``; to deal with ""weird"" expressions that don't behave well as subexpressions.; Then, determine whether you need to perform lvalue-to-rvalue conversions; (``Sema::DefaultLvalueConversions``) or the usual unary conversions; (``Sema::UsualUnaryConversions``), for places where the subexpression is; producing a value you intend to use.; * Your ``BuildXXX`` function will probably just return ``ExprError()`` at; this point, since you don't have an AST. That's perfectly fine, and; shouldn't impact your testing. #. Introduce an AST node for your new expression. This starts with declaring; the node in ``include/Basic/StmtNodes.td`` and creating a new class for your; expression in the appropriate ``include/AST/Expr*.h`` header. It's best to; look at the class for a similar expression to get ideas, and there are some; specific things to watch for:. * If you need ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:147909,Testability,test,testing,147909,"e type is ""dependent"" (``Type::isDependentType()``) or whether a; subexpression is type-dependent (``Expr::isTypeDependent()``). If any of; these return ``true``, then you're inside a template and you can't do much; type-checking now. That's normal, and your AST node (when you get there); will have to deal with this case. At this point, you can write tests that; use your expression within templates, but don't try to instantiate the; templates.; * For each subexpression, be sure to call ``Sema::CheckPlaceholderExpr()``; to deal with ""weird"" expressions that don't behave well as subexpressions.; Then, determine whether you need to perform lvalue-to-rvalue conversions; (``Sema::DefaultLvalueConversions``) or the usual unary conversions; (``Sema::UsualUnaryConversions``), for places where the subexpression is; producing a value you intend to use.; * Your ``BuildXXX`` function will probably just return ``ExprError()`` at; this point, since you don't have an AST. That's perfectly fine, and; shouldn't impact your testing. #. Introduce an AST node for your new expression. This starts with declaring; the node in ``include/Basic/StmtNodes.td`` and creating a new class for your; expression in the appropriate ``include/AST/Expr*.h`` header. It's best to; look at the class for a similar expression to get ideas, and there are some; specific things to watch for:. * If you need to allocate memory, use the ``ASTContext`` allocator to; allocate memory. Never use raw ``malloc`` or ``new``, and never hold any; resources in an AST node, because the destructor of an AST node is never; called.; * Make sure that ``getSourceRange()`` covers the exact source range of your; expression. This is needed for diagnostics and for IDE support.; * Make sure that ``children()`` visits all of the subexpressions. This is; important for a number of features (e.g., IDE support, C++ variadic; templates). If you have sub-types, you'll also need to visit those; sub-types in ``RecursiveASTVisitor``.; * Add pri",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:149748,Testability,test,test,149748,"also need to visit those; sub-types in ``RecursiveASTVisitor``.; * Add printing support (``StmtPrinter.cpp``) for your expression.; * Add profiling support (``StmtProfile.cpp``) for your AST node, noting the; distinguishing (non-source location) characteristics of an instance of; your expression. Omitting this step will lead to hard-to-diagnose; failures regarding matching of template declarations.; * Add serialization support (``ASTReaderStmt.cpp``, ``ASTWriterStmt.cpp``); for your AST node. #. Teach semantic analysis to build your AST node. At this point, you can wire; up your ``Sema::BuildXXX`` function to actually create your AST. A few; things to check at this point:. * If your expression can construct a new C++ class or return a new; Objective-C object, be sure to update and then call; ``Sema::MaybeBindToTemporary`` for your just-created AST node to be sure; that the object gets properly destructed. An easy way to test this is to; return a C++ class with a private destructor: semantic analysis should; flag an error here with the attempt to call the destructor.; * Inspect the generated AST by printing it using ``clang -cc1 -ast-print``,; to make sure you're capturing all of the important information about how; the AST was written.; * Inspect the generated AST under ``clang -cc1 -ast-dump`` to verify that; all of the types in the generated AST line up the way you want them.; Remember that clients of the AST should never have to ""think"" to; understand what's going on. For example, all implicit conversions should; show up explicitly in the AST.; * Write tests that use your expression as a subexpression of other,; well-known expressions. Can you call a function using your expression as; an argument? Can you use the ternary operator?. #. Teach code generation to create IR to your AST node. This step is the first; (and only) that requires knowledge of LLVM IR. There are several things to; keep in mind:. * Code generation is separated into scalar/aggregate/complex and",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:150396,Testability,test,tests,150396,"tually create your AST. A few; things to check at this point:. * If your expression can construct a new C++ class or return a new; Objective-C object, be sure to update and then call; ``Sema::MaybeBindToTemporary`` for your just-created AST node to be sure; that the object gets properly destructed. An easy way to test this is to; return a C++ class with a private destructor: semantic analysis should; flag an error here with the attempt to call the destructor.; * Inspect the generated AST by printing it using ``clang -cc1 -ast-print``,; to make sure you're capturing all of the important information about how; the AST was written.; * Inspect the generated AST under ``clang -cc1 -ast-dump`` to verify that; all of the types in the generated AST line up the way you want them.; Remember that clients of the AST should never have to ""think"" to; understand what's going on. For example, all implicit conversions should; show up explicitly in the AST.; * Write tests that use your expression as a subexpression of other,; well-known expressions. Can you call a function using your expression as; an argument? Can you use the ternary operator?. #. Teach code generation to create IR to your AST node. This step is the first; (and only) that requires knowledge of LLVM IR. There are several things to; keep in mind:. * Code generation is separated into scalar/aggregate/complex and; lvalue/rvalue paths, depending on what kind of result your expression; produces. On occasion, this requires some careful factoring of code to; avoid duplication.; * ``CodeGenFunction`` contains functions ``ConvertType`` and; ``ConvertTypeForMem`` that convert Clang's types (``clang::Type*`` or; ``clang::QualType``) to LLVM types. Use the former for values, and the; latter for memory locations: test with the C++ ""``bool``"" type to check; this. If you find that you are having to use LLVM bitcasts to make the; subexpressions of your expression have the type that your expression; expects, STOP! Go fix semantic ana",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:151213,Testability,test,test,151213,"want them.; Remember that clients of the AST should never have to ""think"" to; understand what's going on. For example, all implicit conversions should; show up explicitly in the AST.; * Write tests that use your expression as a subexpression of other,; well-known expressions. Can you call a function using your expression as; an argument? Can you use the ternary operator?. #. Teach code generation to create IR to your AST node. This step is the first; (and only) that requires knowledge of LLVM IR. There are several things to; keep in mind:. * Code generation is separated into scalar/aggregate/complex and; lvalue/rvalue paths, depending on what kind of result your expression; produces. On occasion, this requires some careful factoring of code to; avoid duplication.; * ``CodeGenFunction`` contains functions ``ConvertType`` and; ``ConvertTypeForMem`` that convert Clang's types (``clang::Type*`` or; ``clang::QualType``) to LLVM types. Use the former for values, and the; latter for memory locations: test with the C++ ""``bool``"" type to check; this. If you find that you are having to use LLVM bitcasts to make the; subexpressions of your expression have the type that your expression; expects, STOP! Go fix semantic analysis and the AST so that you don't; need these bitcasts.; * The ``CodeGenFunction`` class has a number of helper functions to make; certain operations easy, such as generating code to produce an lvalue or; an rvalue, or to initialize a memory location with a given value. Prefer; to use these functions rather than directly writing loads and stores,; because these functions take care of some of the tricky details for you; (e.g., for exceptions).; * If your expression requires some special behavior in the event of an; exception, look at the ``push*Cleanup`` functions in ``CodeGenFunction``; to introduce a cleanup. You shouldn't have to deal with; exception-handling directly.; * Testing is extremely important in IR generation. Use ``clang -cc1; -emit-llvm`` and `Fi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:153482,Testability,test,test,153482,"the constant; value your expression produces can change from one instantiation to the; next), instantiation dependence (i.e., a template parameter occurs; anywhere in your expression), and whether your expression contains a; parameter pack (for variadic templates). Often, computing these flags; just means combining the results from the various types and; subexpressions.; * Add ``TransformXXX`` and ``RebuildXXX`` functions to the ``TreeTransform``; class template in ``Sema``. ``TransformXXX`` should (recursively); transform all of the subexpressions and types within your expression,; using ``getDerived().TransformYYY``. If all of the subexpressions and; types transform without error, it will then call the ``RebuildXXX``; function, which will in turn call ``getSema().BuildXXX`` to perform; semantic analysis and build your expression.; * To test template instantiation, take those tests you wrote to make sure; that you were type checking with type-dependent expressions and dependent; types (from step #2) and instantiate those templates with various types,; some of which type-check and some that don't, and test the error messages; in each case. #. There are some ""extras"" that make other features work better. It's worth; handling these extras to give your expression complete integration into; Clang:. * Add code completion support for your expression in; ``SemaCodeComplete.cpp``.; * If your expression has types in it, or has any ""interesting"" features; other than subexpressions, extend libclang's ``CursorVisitor`` to provide; proper visitation for your expression, enabling various IDE features such; as syntax highlighting, cross-referencing, and so on. The; ``c-index-test`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come with test coverage demonstrating; the change in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:153522,Testability,test,tests,153522,"the constant; value your expression produces can change from one instantiation to the; next), instantiation dependence (i.e., a template parameter occurs; anywhere in your expression), and whether your expression contains a; parameter pack (for variadic templates). Often, computing these flags; just means combining the results from the various types and; subexpressions.; * Add ``TransformXXX`` and ``RebuildXXX`` functions to the ``TreeTransform``; class template in ``Sema``. ``TransformXXX`` should (recursively); transform all of the subexpressions and types within your expression,; using ``getDerived().TransformYYY``. If all of the subexpressions and; types transform without error, it will then call the ``RebuildXXX``; function, which will in turn call ``getSema().BuildXXX`` to perform; semantic analysis and build your expression.; * To test template instantiation, take those tests you wrote to make sure; that you were type checking with type-dependent expressions and dependent; types (from step #2) and instantiate those templates with various types,; some of which type-check and some that don't, and test the error messages; in each case. #. There are some ""extras"" that make other features work better. It's worth; handling these extras to give your expression complete integration into; Clang:. * Add code completion support for your expression in; ``SemaCodeComplete.cpp``.; * If your expression has types in it, or has any ""interesting"" features; other than subexpressions, extend libclang's ``CursorVisitor`` to provide; proper visitation for your expression, enabling various IDE features such; as syntax highlighting, cross-referencing, and so on. The; ``c-index-test`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come with test coverage demonstrating; the change in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:153751,Testability,test,test,153751,"the constant; value your expression produces can change from one instantiation to the; next), instantiation dependence (i.e., a template parameter occurs; anywhere in your expression), and whether your expression contains a; parameter pack (for variadic templates). Often, computing these flags; just means combining the results from the various types and; subexpressions.; * Add ``TransformXXX`` and ``RebuildXXX`` functions to the ``TreeTransform``; class template in ``Sema``. ``TransformXXX`` should (recursively); transform all of the subexpressions and types within your expression,; using ``getDerived().TransformYYY``. If all of the subexpressions and; types transform without error, it will then call the ``RebuildXXX``; function, which will in turn call ``getSema().BuildXXX`` to perform; semantic analysis and build your expression.; * To test template instantiation, take those tests you wrote to make sure; that you were type checking with type-dependent expressions and dependent; types (from step #2) and instantiate those templates with various types,; some of which type-check and some that don't, and test the error messages; in each case. #. There are some ""extras"" that make other features work better. It's worth; handling these extras to give your expression complete integration into; Clang:. * Add code completion support for your expression in; ``SemaCodeComplete.cpp``.; * If your expression has types in it, or has any ""interesting"" features; other than subexpressions, extend libclang's ``CursorVisitor`` to provide; proper visitation for your expression, enabling various IDE features such; as syntax highlighting, cross-referencing, and so on. The; ``c-index-test`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come with test coverage demonstrating; the change in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:154321,Testability,test,test,154321," the ``RebuildXXX``; function, which will in turn call ``getSema().BuildXXX`` to perform; semantic analysis and build your expression.; * To test template instantiation, take those tests you wrote to make sure; that you were type checking with type-dependent expressions and dependent; types (from step #2) and instantiate those templates with various types,; some of which type-check and some that don't, and test the error messages; in each case. #. There are some ""extras"" that make other features work better. It's worth; handling these extras to give your expression complete integration into; Clang:. * Add code completion support for your expression in; ``SemaCodeComplete.cpp``.; * If your expression has types in it, or has any ""interesting"" features; other than subexpressions, extend libclang's ``CursorVisitor`` to provide; proper visitation for your expression, enabling various IDE features such; as syntax highlighting, cross-referencing, and so on. The; ``c-index-test`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come with test coverage demonstrating; the change in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option as a way to; validate diagnostic behavior. This option will use special comments within the; test file to verify that expected diagnostics appear in the correct source; locations. If all of the expected diagnostics match the actual output of Clang,; then the invocation will return normally. If there are discrepancies between; the expected and actual output, Clang will emit detailed information about; which expected diagnostics were not seen or which unexpected diagnostics were; seen, etc. A complete example is:. .. code-block: c++. // RUN: %clang_cc1 -verify %s; int A = B; // expected-error {{use of undeclared identifier 'B'}}. If the test is run and the expected error is emitted on the expected line",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:154358,Testability,test,test,154358," the ``RebuildXXX``; function, which will in turn call ``getSema().BuildXXX`` to perform; semantic analysis and build your expression.; * To test template instantiation, take those tests you wrote to make sure; that you were type checking with type-dependent expressions and dependent; types (from step #2) and instantiate those templates with various types,; some of which type-check and some that don't, and test the error messages; in each case. #. There are some ""extras"" that make other features work better. It's worth; handling these extras to give your expression complete integration into; Clang:. * Add code completion support for your expression in; ``SemaCodeComplete.cpp``.; * If your expression has types in it, or has any ""interesting"" features; other than subexpressions, extend libclang's ``CursorVisitor`` to provide; proper visitation for your expression, enabling various IDE features such; as syntax highlighting, cross-referencing, and so on. The; ``c-index-test`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come with test coverage demonstrating; the change in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option as a way to; validate diagnostic behavior. This option will use special comments within the; test file to verify that expected diagnostics appear in the correct source; locations. If all of the expected diagnostics match the actual output of Clang,; then the invocation will return normally. If there are discrepancies between; the expected and actual output, Clang will emit detailed information about; which expected diagnostics were not seen or which unexpected diagnostics were; seen, etc. A complete example is:. .. code-block: c++. // RUN: %clang_cc1 -verify %s; int A = B; // expected-error {{use of undeclared identifier 'B'}}. If the test is run and the expected error is emitted on the expected line",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:154446,Testability,test,test,154446,"c analysis and build your expression.; * To test template instantiation, take those tests you wrote to make sure; that you were type checking with type-dependent expressions and dependent; types (from step #2) and instantiate those templates with various types,; some of which type-check and some that don't, and test the error messages; in each case. #. There are some ""extras"" that make other features work better. It's worth; handling these extras to give your expression complete integration into; Clang:. * Add code completion support for your expression in; ``SemaCodeComplete.cpp``.; * If your expression has types in it, or has any ""interesting"" features; other than subexpressions, extend libclang's ``CursorVisitor`` to provide; proper visitation for your expression, enabling various IDE features such; as syntax highlighting, cross-referencing, and so on. The; ``c-index-test`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come with test coverage demonstrating; the change in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option as a way to; validate diagnostic behavior. This option will use special comments within the; test file to verify that expected diagnostics appear in the correct source; locations. If all of the expected diagnostics match the actual output of Clang,; then the invocation will return normally. If there are discrepancies between; the expected and actual output, Clang will emit detailed information about; which expected diagnostics were not seen or which unexpected diagnostics were; seen, etc. A complete example is:. .. code-block: c++. // RUN: %clang_cc1 -verify %s; int A = B; // expected-error {{use of undeclared identifier 'B'}}. If the test is run and the expected error is emitted on the expected line, the; diagnostic verifier will pass. However, if the expected error does not appear; or appears",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:154726,Testability,test,test,154726,"'t, and test the error messages; in each case. #. There are some ""extras"" that make other features work better. It's worth; handling these extras to give your expression complete integration into; Clang:. * Add code completion support for your expression in; ``SemaCodeComplete.cpp``.; * If your expression has types in it, or has any ""interesting"" features; other than subexpressions, extend libclang's ``CursorVisitor`` to provide; proper visitation for your expression, enabling various IDE features such; as syntax highlighting, cross-referencing, and so on. The; ``c-index-test`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come with test coverage demonstrating; the change in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option as a way to; validate diagnostic behavior. This option will use special comments within the; test file to verify that expected diagnostics appear in the correct source; locations. If all of the expected diagnostics match the actual output of Clang,; then the invocation will return normally. If there are discrepancies between; the expected and actual output, Clang will emit detailed information about; which expected diagnostics were not seen or which unexpected diagnostics were; seen, etc. A complete example is:. .. code-block: c++. // RUN: %clang_cc1 -verify %s; int A = B; // expected-error {{use of undeclared identifier 'B'}}. If the test is run and the expected error is emitted on the expected line, the; diagnostic verifier will pass. However, if the expected error does not appear; or appears in a different location than expected, or if additional diagnostics; appear, the diagnostic verifier will fail and emit information as to why. The ``-verify`` command optionally accepts a comma-delimited list of one or; more verification prefixes that can be used to craft those special comments.; Each pr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:155276,Testability,test,test,155276,"st`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come with test coverage demonstrating; the change in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option as a way to; validate diagnostic behavior. This option will use special comments within the; test file to verify that expected diagnostics appear in the correct source; locations. If all of the expected diagnostics match the actual output of Clang,; then the invocation will return normally. If there are discrepancies between; the expected and actual output, Clang will emit detailed information about; which expected diagnostics were not seen or which unexpected diagnostics were; seen, etc. A complete example is:. .. code-block: c++. // RUN: %clang_cc1 -verify %s; int A = B; // expected-error {{use of undeclared identifier 'B'}}. If the test is run and the expected error is emitted on the expected line, the; diagnostic verifier will pass. However, if the expected error does not appear; or appears in a different location than expected, or if additional diagnostics; appear, the diagnostic verifier will fail and emit information as to why. The ``-verify`` command optionally accepts a comma-delimited list of one or; more verification prefixes that can be used to craft those special comments.; Each prefix must start with a letter and contain only alphanumeric characters,; hyphens, and underscores. ``-verify`` by itself is equivalent to; ``-verify=expected``, meaning that special comments will start with; ``expected``. Using different prefixes makes it easier to have separate; ``RUN:`` lines in the same test file which result in differing diagnostic; behavior. For example:. .. code-block:: c++. // RUN: %clang_cc1 -verify=foo,bar %s. int A = B; // foo-error {{use of undeclared identifier 'B'}}; int C = D; // bar-error {{use of undeclared identifier 'D'}}; int E = F; // ex",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:156052,Testability,test,test,156052,"which expected diagnostics were not seen or which unexpected diagnostics were; seen, etc. A complete example is:. .. code-block: c++. // RUN: %clang_cc1 -verify %s; int A = B; // expected-error {{use of undeclared identifier 'B'}}. If the test is run and the expected error is emitted on the expected line, the; diagnostic verifier will pass. However, if the expected error does not appear; or appears in a different location than expected, or if additional diagnostics; appear, the diagnostic verifier will fail and emit information as to why. The ``-verify`` command optionally accepts a comma-delimited list of one or; more verification prefixes that can be used to craft those special comments.; Each prefix must start with a letter and contain only alphanumeric characters,; hyphens, and underscores. ``-verify`` by itself is equivalent to; ``-verify=expected``, meaning that special comments will start with; ``expected``. Using different prefixes makes it easier to have separate; ``RUN:`` lines in the same test file which result in differing diagnostic; behavior. For example:. .. code-block:: c++. // RUN: %clang_cc1 -verify=foo,bar %s. int A = B; // foo-error {{use of undeclared identifier 'B'}}; int C = D; // bar-error {{use of undeclared identifier 'D'}}; int E = F; // expected-error {{use of undeclared identifier 'F'}}. The verifier will recognize ``foo-error`` and ``bar-error`` as special comments; but will not recognize ``expected-error`` as one because the ``-verify`` line; does not contain that as a prefix. Thus, this test would fail verification; because an unexpected diagnostic would appear on the declaration of ``E``. Multiple occurrences accumulate prefixes. For example,; ``-verify -verify=foo,bar -verify=baz`` is equivalent to; ``-verify=expected,foo,bar,baz``. Specifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^; Indicating that a line expects an error or a warning is easy. Put a comment; on the line that has the diagnostic, use; ``expected-{error,warning,remark,not",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:156581,Testability,test,test,156581,"comma-delimited list of one or; more verification prefixes that can be used to craft those special comments.; Each prefix must start with a letter and contain only alphanumeric characters,; hyphens, and underscores. ``-verify`` by itself is equivalent to; ``-verify=expected``, meaning that special comments will start with; ``expected``. Using different prefixes makes it easier to have separate; ``RUN:`` lines in the same test file which result in differing diagnostic; behavior. For example:. .. code-block:: c++. // RUN: %clang_cc1 -verify=foo,bar %s. int A = B; // foo-error {{use of undeclared identifier 'B'}}; int C = D; // bar-error {{use of undeclared identifier 'D'}}; int E = F; // expected-error {{use of undeclared identifier 'F'}}. The verifier will recognize ``foo-error`` and ``bar-error`` as special comments; but will not recognize ``expected-error`` as one because the ``-verify`` line; does not contain that as a prefix. Thus, this test would fail verification; because an unexpected diagnostic would appear on the declaration of ``E``. Multiple occurrences accumulate prefixes. For example,; ``-verify -verify=foo,bar -verify=baz`` is equivalent to; ``-verify=expected,foo,bar,baz``. Specifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^; Indicating that a line expects an error or a warning is easy. Put a comment; on the line that has the diagnostic, use; ``expected-{error,warning,remark,note}`` to tag if it's an expected error,; warning, remark, or note (respectively), and place the expected text between; ``{{`` and ``}}`` markers. The full text doesn't have to be included, only; enough to ensure that the correct diagnostic was emitted. (Note: full text; should be included in test cases unless there is a compelling reason to use; truncated text instead.). For a full description of the matching behavior, including more complex; matching scenarios, see :ref:`matching <DiagnosticMatching>` below. Here's an example of the most commonly used way to specify expected; diagnos",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:157329,Testability,test,test,157329,"ndeclared identifier 'F'}}. The verifier will recognize ``foo-error`` and ``bar-error`` as special comments; but will not recognize ``expected-error`` as one because the ``-verify`` line; does not contain that as a prefix. Thus, this test would fail verification; because an unexpected diagnostic would appear on the declaration of ``E``. Multiple occurrences accumulate prefixes. For example,; ``-verify -verify=foo,bar -verify=baz`` is equivalent to; ``-verify=expected,foo,bar,baz``. Specifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^; Indicating that a line expects an error or a warning is easy. Put a comment; on the line that has the diagnostic, use; ``expected-{error,warning,remark,note}`` to tag if it's an expected error,; warning, remark, or note (respectively), and place the expected text between; ``{{`` and ``}}`` markers. The full text doesn't have to be included, only; enough to ensure that the correct diagnostic was emitted. (Note: full text; should be included in test cases unless there is a compelling reason to use; truncated text instead.). For a full description of the matching behavior, including more complex; matching scenarios, see :ref:`matching <DiagnosticMatching>` below. Here's an example of the most commonly used way to specify expected; diagnostics:. .. code-block:: c++. int A = B; // expected-error {{use of undeclared identifier 'B'}}. You can place as many diagnostics on one line as you wish. To make the code; more readable, you can use slash-newline to separate out the diagnostics. Alternatively, it is possible to specify the line on which the diagnostic; should appear by appending ``@<line>`` to ``expected-<type>``, for example:. .. code-block:: c++. #warning some text; // expected-warning@10 {{some text}}. The line number may be absolute (as above), or relative to the current line by; prefixing the number with either ``+`` or ``-``. If the diagnostic is generated in a separate file, for example in a shared; header file, it may be beneficial to be",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162715,Testability,test,test,162715,"pected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, failed assertions, or miscompilations?; * Are there known issues on a particular relevant target?. If the answer to any of these is ""yes"", the feature test macro should eithe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162782,Testability,test,tests,162782," appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, failed assertions, or miscompilations?; * Are there known issues on a particular relevant target?. If the answer to any of these is ""yes"", the feature test macro should either; not be defined or there should be very strong rationale for why the issues; should not prevent defining it. Note, it is acceptable to d",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162965,Testability,test,tests,162965,"ock:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, failed assertions, or miscompilations?; * Are there known issues on a particular relevant target?. If the answer to any of these is ""yes"", the feature test macro should either; not be defined or there should be very strong rationale for why the issues; should not prevent defining it. Note, it is acceptable to define the feature; test macro on a per-target basis if needed. When in doubt, being conservative is better than being aggressive. If we don't; claim su",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:163276,Testability,test,test,163276,"ype}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, failed assertions, or miscompilations?; * Are there known issues on a particular relevant target?. If the answer to any of these is ""yes"", the feature test macro should either; not be defined or there should be very strong rationale for why the issues; should not prevent defining it. Note, it is acceptable to define the feature; test macro on a per-target basis if needed. When in doubt, being conservative is better than being aggressive. If we don't; claim support for the feature but it does useful things, users can still use it; and provide us with useful feedback on what is missing. But if we claim support; for a feature that has significant bugs, we've eliminated most of the utility; of having a feature testing macro at all because u",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:163332,Testability,test,test,163332,"ype}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, failed assertions, or miscompilations?; * Are there known issues on a particular relevant target?. If the answer to any of these is ""yes"", the feature test macro should either; not be defined or there should be very strong rationale for why the issues; should not prevent defining it. Note, it is acceptable to define the feature; test macro on a per-target basis if needed. When in doubt, being conservative is better than being aggressive. If we don't; claim support for the feature but it does useful things, users can still use it; and provide us with useful feedback on what is missing. But if we claim support; for a feature that has significant bugs, we've eliminated most of the utility; of having a feature testing macro at all because u",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:163532,Testability,assert,assertions,163532," type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, failed assertions, or miscompilations?; * Are there known issues on a particular relevant target?. If the answer to any of these is ""yes"", the feature test macro should either; not be defined or there should be very strong rationale for why the issues; should not prevent defining it. Note, it is acceptable to define the feature; test macro on a per-target basis if needed. When in doubt, being conservative is better than being aggressive. If we don't; claim support for the feature but it does useful things, users can still use it; and provide us with useful feedback on what is missing. But if we claim support; for a feature that has significant bugs, we've eliminated most of the utility; of having a feature testing macro at all because users are then forced to test; what compiler version is in use to get a more accurate answer. The status reported by the feature test macro should always be reflected in the; language support page for the corres",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:163676,Testability,test,test,163676,"est whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, failed assertions, or miscompilations?; * Are there known issues on a particular relevant target?. If the answer to any of these is ""yes"", the feature test macro should either; not be defined or there should be very strong rationale for why the issues; should not prevent defining it. Note, it is acceptable to define the feature; test macro on a per-target basis if needed. When in doubt, being conservative is better than being aggressive. If we don't; claim support for the feature but it does useful things, users can still use it; and provide us with useful feedback on what is missing. But if we claim support; for a feature that has significant bugs, we've eliminated most of the utility; of having a feature testing macro at all because users are then forced to test; what compiler version is in use to get a more accurate answer. The status reported by the feature test macro should always be reflected in the; language support page for the corresponding feature (`C++; <https://clang.llvm.org/cxx_status.html>`_, `C; <https://clang.llvm.org/c_status.html>`_) if applicable. This page can give; more nuanced information to the user as well, such as claiming partial support; for a f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:163856,Testability,test,test,163856,"ure tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, failed assertions, or miscompilations?; * Are there known issues on a particular relevant target?. If the answer to any of these is ""yes"", the feature test macro should either; not be defined or there should be very strong rationale for why the issues; should not prevent defining it. Note, it is acceptable to define the feature; test macro on a per-target basis if needed. When in doubt, being conservative is better than being aggressive. If we don't; claim support for the feature but it does useful things, users can still use it; and provide us with useful feedback on what is missing. But if we claim support; for a feature that has significant bugs, we've eliminated most of the utility; of having a feature testing macro at all because users are then forced to test; what compiler version is in use to get a more accurate answer. The status reported by the feature test macro should always be reflected in the; language support page for the corresponding feature (`C++; <https://clang.llvm.org/cxx_status.html>`_, `C; <https://clang.llvm.org/c_status.html>`_) if applicable. This page can give; more nuanced information to the user as well, such as claiming partial support; for a feature and specifying details as to what remains to be done.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:164241,Testability,test,testing,164241,"ure tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, failed assertions, or miscompilations?; * Are there known issues on a particular relevant target?. If the answer to any of these is ""yes"", the feature test macro should either; not be defined or there should be very strong rationale for why the issues; should not prevent defining it. Note, it is acceptable to define the feature; test macro on a per-target basis if needed. When in doubt, being conservative is better than being aggressive. If we don't; claim support for the feature but it does useful things, users can still use it; and provide us with useful feedback on what is missing. But if we claim support; for a feature that has significant bugs, we've eliminated most of the utility; of having a feature testing macro at all because users are then forced to test; what compiler version is in use to get a more accurate answer. The status reported by the feature test macro should always be reflected in the; language support page for the corresponding feature (`C++; <https://clang.llvm.org/cxx_status.html>`_, `C; <https://clang.llvm.org/c_status.html>`_) if applicable. This page can give; more nuanced information to the user as well, such as claiming partial support; for a feature and specifying details as to what remains to be done.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:164295,Testability,test,test,164295,"ure tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, failed assertions, or miscompilations?; * Are there known issues on a particular relevant target?. If the answer to any of these is ""yes"", the feature test macro should either; not be defined or there should be very strong rationale for why the issues; should not prevent defining it. Note, it is acceptable to define the feature; test macro on a per-target basis if needed. When in doubt, being conservative is better than being aggressive. If we don't; claim support for the feature but it does useful things, users can still use it; and provide us with useful feedback on what is missing. But if we claim support; for a feature that has significant bugs, we've eliminated most of the utility; of having a feature testing macro at all because users are then forced to test; what compiler version is in use to get a more accurate answer. The status reported by the feature test macro should always be reflected in the; language support page for the corresponding feature (`C++; <https://clang.llvm.org/cxx_status.html>`_, `C; <https://clang.llvm.org/c_status.html>`_) if applicable. This page can give; more nuanced information to the user as well, such as claiming partial support; for a feature and specifying details as to what remains to be done.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:164399,Testability,test,test,164399,"ure tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, failed assertions, or miscompilations?; * Are there known issues on a particular relevant target?. If the answer to any of these is ""yes"", the feature test macro should either; not be defined or there should be very strong rationale for why the issues; should not prevent defining it. Note, it is acceptable to define the feature; test macro on a per-target basis if needed. When in doubt, being conservative is better than being aggressive. If we don't; claim support for the feature but it does useful things, users can still use it; and provide us with useful feedback on what is missing. But if we claim support; for a feature that has significant bugs, we've eliminated most of the utility; of having a feature testing macro at all because users are then forced to test; what compiler version is in use to get a more accurate answer. The status reported by the feature test macro should always be reflected in the; language support page for the corresponding feature (`C++; <https://clang.llvm.org/cxx_status.html>`_, `C; <https://clang.llvm.org/c_status.html>`_) if applicable. This page can give; more nuanced information to the user as well, such as claiming partial support; for a feature and specifying details as to what remains to be done.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:6269,Usability,simpl,simple,6269,"ally supports a fully fine grained mapping mechanism that allows; you to map almost any diagnostic to the output level that you want. The only; diagnostics that cannot be mapped are ``NOTE``\ s, which always follow the; severity of the previously emitted diagnostic and ``ERROR``\ s, which can only; be mapped to ``Fatal`` (it is not possible to turn an error into a warning, for; example). Diagnostic mappings are used in many ways. For example, if the user specifies; ``-pedantic``, ``EXTENSION`` maps to ``Warning``, if they specify; ``-pedantic-errors``, it turns into ``Error``. This is used to implement; options like ``-Wunused_macros``, ``-Wundef`` etc. Mapping to ``Fatal`` should only be used for diagnostics that are considered so; severe that error recovery won't be able to recover sensibly from them (thus; spewing a ton of bogus errors). One example of this class of error are failure; to ``#include`` a file. The Format String; ^^^^^^^^^^^^^^^^^. The format string for the diagnostic is very simple, but it has some power. It; takes the form of a string in English with markers that indicate where and how; arguments to the diagnostic are inserted and formatted. For example, here are; some simple format strings:. .. code-block:: c++. ""binary integer literals are an extension""; ""format string contains '\\0' within the string body""; ""more '%%' conversions than data arguments""; ""invalid operands to binary expression (%0 and %1)""; ""overloaded '%0' must be a %select{unary|binary|unary or binary}2 operator""; "" (has %1 parameter%s1)"". These examples show some important points of format strings. You can use any; plain ASCII character in the diagnostic string except ""``%``"" without a; problem, but these are C strings, so you have to use and be aware of all the C; escape sequences (as in the second example). If you want to produce a ""``%``""; in the output, use the ""``%%``"" escape sequence, like the third diagnostic.; Finally, Clang uses the ""``%...[digit]``"" sequences to specif",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:6468,Usability,simpl,simple,6468,"ays follow the; severity of the previously emitted diagnostic and ``ERROR``\ s, which can only; be mapped to ``Fatal`` (it is not possible to turn an error into a warning, for; example). Diagnostic mappings are used in many ways. For example, if the user specifies; ``-pedantic``, ``EXTENSION`` maps to ``Warning``, if they specify; ``-pedantic-errors``, it turns into ``Error``. This is used to implement; options like ``-Wunused_macros``, ``-Wundef`` etc. Mapping to ``Fatal`` should only be used for diagnostics that are considered so; severe that error recovery won't be able to recover sensibly from them (thus; spewing a ton of bogus errors). One example of this class of error are failure; to ``#include`` a file. The Format String; ^^^^^^^^^^^^^^^^^. The format string for the diagnostic is very simple, but it has some power. It; takes the form of a string in English with markers that indicate where and how; arguments to the diagnostic are inserted and formatted. For example, here are; some simple format strings:. .. code-block:: c++. ""binary integer literals are an extension""; ""format string contains '\\0' within the string body""; ""more '%%' conversions than data arguments""; ""invalid operands to binary expression (%0 and %1)""; ""overloaded '%0' must be a %select{unary|binary|unary or binary}2 operator""; "" (has %1 parameter%s1)"". These examples show some important points of format strings. You can use any; plain ASCII character in the diagnostic string except ""``%``"" without a; problem, but these are C strings, so you have to use and be aware of all the C; escape sequences (as in the second example). If you want to produce a ""``%``""; in the output, use the ""``%%``"" escape sequence, like the third diagnostic.; Finally, Clang uses the ""``%...[digit]``"" sequences to specify where and how; arguments to the diagnostic are formatted. Arguments to the diagnostic are numbered according to how they are specified by; the C++ code that :ref:`produces them <internals-producing-diag",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:10432,Usability,simpl,simple,10432," can be; used to achieve this sort of thing in a localizable way, see below. Formatting a Diagnostic Argument; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Arguments to diagnostics are fully typed internally, and come from a couple; different classes: integers, types, names, and random strings. Depending on; the class of the argument, it can be optionally formatted in different ways.; This gives the ``DiagnosticConsumer`` information about what the argument means; without requiring it to use a specific presentation (consider this MVC for; Clang :). It is really easy to add format specifiers to the Clang diagnostics system, but; they should be discussed before they are added. If you are creating a lot of; repetitive diagnostics and/or have an idea for a useful formatter, please bring; it up on the cfe-dev mailing list. Here are the different diagnostic argument formats currently supported by; Clang:. **""s"" format**. Example:; ``""requires %0 parameter%s0""``; Class:; Integers; Description:; This is a simple formatter for integers that is useful when producing English; diagnostics. When the integer is 1, it prints as nothing. When the integer; is not 1, it prints as ""``s``"". This allows some simple grammatical forms to; be to be handled correctly, and eliminates the need to use gross things like; ``""requires %1 parameter(s)""``. Note, this only handles adding a simple; ""``s``"" character, it will not handle situations where pluralization is more; complicated such as turning ``fancy`` into ``fancies`` or ``mouse`` into; ``mice``. You can use the ""plural"" format specifier to handle such situations. **""select"" format**. Example:; ``""must be a %select{unary|binary|unary or binary}0 operator""``; Class:; Integers; Description:; This format specifier is used to merge multiple related diagnostics together; into one common one, without requiring the difference to be specified as an; English string argument. Instead of specifying the string, the diagnostic; gets an integer argument and the fo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:10626,Usability,simpl,simple,10626,", names, and random strings. Depending on; the class of the argument, it can be optionally formatted in different ways.; This gives the ``DiagnosticConsumer`` information about what the argument means; without requiring it to use a specific presentation (consider this MVC for; Clang :). It is really easy to add format specifiers to the Clang diagnostics system, but; they should be discussed before they are added. If you are creating a lot of; repetitive diagnostics and/or have an idea for a useful formatter, please bring; it up on the cfe-dev mailing list. Here are the different diagnostic argument formats currently supported by; Clang:. **""s"" format**. Example:; ``""requires %0 parameter%s0""``; Class:; Integers; Description:; This is a simple formatter for integers that is useful when producing English; diagnostics. When the integer is 1, it prints as nothing. When the integer; is not 1, it prints as ""``s``"". This allows some simple grammatical forms to; be to be handled correctly, and eliminates the need to use gross things like; ``""requires %1 parameter(s)""``. Note, this only handles adding a simple; ""``s``"" character, it will not handle situations where pluralization is more; complicated such as turning ``fancy`` into ``fancies`` or ``mouse`` into; ``mice``. You can use the ""plural"" format specifier to handle such situations. **""select"" format**. Example:; ``""must be a %select{unary|binary|unary or binary}0 operator""``; Class:; Integers; Description:; This format specifier is used to merge multiple related diagnostics together; into one common one, without requiring the difference to be specified as an; English string argument. Instead of specifying the string, the diagnostic; gets an integer argument and the format string selects the numbered option.; In this case, the ""``%0``"" value must be an integer in the range [0..2]. If; it is 0, it prints ""unary"", if it is 1 it prints ""binary"" if it is 2, it; prints ""unary or binary"". This allows other language translatio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:10798,Usability,simpl,simple,10798,"at the argument means; without requiring it to use a specific presentation (consider this MVC for; Clang :). It is really easy to add format specifiers to the Clang diagnostics system, but; they should be discussed before they are added. If you are creating a lot of; repetitive diagnostics and/or have an idea for a useful formatter, please bring; it up on the cfe-dev mailing list. Here are the different diagnostic argument formats currently supported by; Clang:. **""s"" format**. Example:; ``""requires %0 parameter%s0""``; Class:; Integers; Description:; This is a simple formatter for integers that is useful when producing English; diagnostics. When the integer is 1, it prints as nothing. When the integer; is not 1, it prints as ""``s``"". This allows some simple grammatical forms to; be to be handled correctly, and eliminates the need to use gross things like; ``""requires %1 parameter(s)""``. Note, this only handles adding a simple; ""``s``"" character, it will not handle situations where pluralization is more; complicated such as turning ``fancy`` into ``fancies`` or ``mouse`` into; ``mice``. You can use the ""plural"" format specifier to handle such situations. **""select"" format**. Example:; ``""must be a %select{unary|binary|unary or binary}0 operator""``; Class:; Integers; Description:; This format specifier is used to merge multiple related diagnostics together; into one common one, without requiring the difference to be specified as an; English string argument. Instead of specifying the string, the diagnostic; gets an integer argument and the format string selects the numbered option.; In this case, the ""``%0``"" value must be an integer in the range [0..2]. If; it is 0, it prints ""unary"", if it is 1 it prints ""binary"" if it is 2, it; prints ""unary or binary"". This allows other language translations to; substitute reasonable words (or entire phrases) based on the semantics of the; diagnostic instead of having to do things textually. The selected string; does undergo formatt",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:12627,Usability,simpl,simple,12627,"ows other language translations to; substitute reasonable words (or entire phrases) based on the semantics of the; diagnostic instead of having to do things textually. The selected string; does undergo formatting. **""plural"" format**. Example:; ``""you have %0 %plural{1:mouse|:mice}0 connected to your computer""``; Class:; Integers; Description:; This is a formatter for complex plural forms. It is designed to handle even; the requirements of languages with very complex plural forms, as many Baltic; languages have. The argument consists of a series of expression/form pairs,; separated by "":"", where the first form whose expression evaluates to true is; the result of the modifier. An expression can be empty, in which case it is always true. See the example; at the top. Otherwise, it is a series of one or more numeric conditions,; separated by "","". If any condition matches, the expression matches. Each; numeric condition can take one of three forms. * number: A simple decimal number matches if the argument is the same as the; number. Example: ``""%plural{1:mouse|:mice}0""``; * range: A range in square brackets matches if the argument is within the; range. Then range is inclusive on both ends. Example:; ``""%plural{0:none|1:one|[2,5]:some|:many}0""``; * modulo: A modulo operator is followed by a number, and equals sign and; either a number or a range. The tests are the same as for plain numbers; and ranges, but the argument is taken modulo the number first. Example:; ``""%plural{%100=0:even hundred|%100=[1,50]:lower half|:everything else}1""``. The parser is very unforgiving. A syntax error, even whitespace, will abort,; as will a failure to match the argument against any expression. **""ordinal"" format**. Example:; ``""ambiguity in %ordinal0 argument""``; Class:; Integers; Description:; This is a formatter which represents the argument number as an ordinal: the; value ``1`` becomes ``1st``, ``3`` becomes ``3rd``, and so on. Values less; than ``1`` are not supported. This formatter",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:13831,Usability,simpl,simple,13831,"s inclusive on both ends. Example:; ``""%plural{0:none|1:one|[2,5]:some|:many}0""``; * modulo: A modulo operator is followed by a number, and equals sign and; either a number or a range. The tests are the same as for plain numbers; and ranges, but the argument is taken modulo the number first. Example:; ``""%plural{%100=0:even hundred|%100=[1,50]:lower half|:everything else}1""``. The parser is very unforgiving. A syntax error, even whitespace, will abort,; as will a failure to match the argument against any expression. **""ordinal"" format**. Example:; ``""ambiguity in %ordinal0 argument""``; Class:; Integers; Description:; This is a formatter which represents the argument number as an ordinal: the; value ``1`` becomes ``1st``, ``3`` becomes ``3rd``, and so on. Values less; than ``1`` are not supported. This formatter is currently hard-coded to use; English ordinals. **""objcclass"" format**. Example:; ``""method %objcclass0 not found""``; Class:; ``DeclarationName``; Description:; This is a simple formatter that indicates the ``DeclarationName`` corresponds; to an Objective-C class method selector. As such, it prints the selector; with a leading ""``+``"". **""objcinstance"" format**. Example:; ``""method %objcinstance0 not found""``; Class:; ``DeclarationName``; Description:; This is a simple formatter that indicates the ``DeclarationName`` corresponds; to an Objective-C instance method selector. As such, it prints the selector; with a leading ""``-``"". **""q"" format**. Example:; ``""candidate found by name lookup is %q0""``; Class:; ``NamedDecl *``; Description:; This formatter indicates that the fully-qualified name of the declaration; should be printed, e.g., ""``std::vector``"" rather than ""``vector``"". **""diff"" format**. Example:; ``""no known conversion %diff{from $ to $|from argument type to parameter type}1,2""``; Class:; ``QualType``; Description:; This formatter takes two ``QualType``\ s and attempts to print a template; difference between the two. If tree printing is off, the te",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:14127,Usability,simpl,simple,14127,"mple:; ``""%plural{%100=0:even hundred|%100=[1,50]:lower half|:everything else}1""``. The parser is very unforgiving. A syntax error, even whitespace, will abort,; as will a failure to match the argument against any expression. **""ordinal"" format**. Example:; ``""ambiguity in %ordinal0 argument""``; Class:; Integers; Description:; This is a formatter which represents the argument number as an ordinal: the; value ``1`` becomes ``1st``, ``3`` becomes ``3rd``, and so on. Values less; than ``1`` are not supported. This formatter is currently hard-coded to use; English ordinals. **""objcclass"" format**. Example:; ``""method %objcclass0 not found""``; Class:; ``DeclarationName``; Description:; This is a simple formatter that indicates the ``DeclarationName`` corresponds; to an Objective-C class method selector. As such, it prints the selector; with a leading ""``+``"". **""objcinstance"" format**. Example:; ``""method %objcinstance0 not found""``; Class:; ``DeclarationName``; Description:; This is a simple formatter that indicates the ``DeclarationName`` corresponds; to an Objective-C instance method selector. As such, it prints the selector; with a leading ""``-``"". **""q"" format**. Example:; ``""candidate found by name lookup is %q0""``; Class:; ``NamedDecl *``; Description:; This formatter indicates that the fully-qualified name of the declaration; should be printed, e.g., ""``std::vector``"" rather than ""``vector``"". **""diff"" format**. Example:; ``""no known conversion %diff{from $ to $|from argument type to parameter type}1,2""``; Class:; ``QualType``; Description:; This formatter takes two ``QualType``\ s and attempts to print a template; difference between the two. If tree printing is off, the text inside the; braces before the pipe is printed, with the formatted text replacing the $.; If tree printing is on, the text after the pipe is printed and a type tree is; printed after the diagnostic message. **""sub"" format**. Example:; Given the following record definition of type ``TextSubstit",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:17919,Usability,clear,clear,17919,"h the ``<<`` operator: the first argument; becomes ``%0``, the second becomes ``%1``, etc. The diagnostic interface; allows you to specify arguments of many different types, including ``int`` and; ``unsigned`` for integer arguments, ``const char*`` and ``std::string`` for; string arguments, ``DeclarationName`` and ``const IdentifierInfo *`` for names,; ``QualType`` for types, etc. ``SourceRange``\ s are also specified with the; ``<<`` operator, but do not have a specific ordering requirement. As you can see, adding and producing a diagnostic is pretty straightforward.; The hard part is deciding exactly what you need to say to help the user,; picking a suitable wording, and providing the information needed to format it; correctly. The good news is that the call site that issues a diagnostic should; be completely independent of how the diagnostic is formatted and in what; language it is rendered. Fix-It Hints; ^^^^^^^^^^^^. In some cases, the front end emits diagnostics when it is clear that some small; change to the source code would fix the problem. For example, a missing; semicolon at the end of a statement or a use of deprecated syntax that is; easily rewritten into a more modern form. Clang tries very hard to emit the; diagnostic and recover gracefully in these and other cases. However, for these cases where the fix is obvious, the diagnostic can be; annotated with a hint (referred to as a ""fix-it hint"") that describes how to; change the code referenced by the diagnostic to fix the problem. For example,; it might add the missing semicolon at the end of the statement or rewrite the; use of a deprecated construct into something more palatable. Here is one such; example from the C++ front end, where we warn about the right-shift operator; changing meaning from C++98 to C++11:. .. code-block:: text. test.cpp:3:7: warning: use of right-shift operator ('>>') in template argument; will require parentheses in C++11; A<100 >> 2> *a;; ^; ( ). Here, the fix-it hint is sugge",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:22675,Usability,simpl,simple,22675,"urce ranges, and the caret.; However, this behavior isn't required. Another implementation of the ``DiagnosticConsumer`` interface is the; ``TextDiagnosticBuffer`` class, which is used when Clang is in ``-verify``; mode. Instead of formatting and printing out the diagnostics, this; implementation just captures and remembers the diagnostics as they fly by.; Then ``-verify`` compares the list of produced diagnostics to the list of; expected ones. If they disagree, it prints out its own output. Full; documentation for the ``-verify`` mode can be found at; :ref:`verifying-diagnostics`. There are many other possible implementations of this interface, and this is; why we prefer diagnostics to pass down rich structured information in; arguments. For example, an HTML output might want declaration names be; linkified to where they come from in the source. Another example is that a GUI; might let you click on typedefs to expand them. This application would want to; pass significantly more information about types through to the GUI than a; simple flat string. The interface allows this to happen. .. _internals-diag-translation:. Adding Translations to Clang; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Not possible yet! Diagnostic strings should be written in UTF-8, the client can; translate to the relevant code page if needed. Each translation completely; replaces the format string for the diagnostic. .. _SourceLocation:; .. _SourceManager:. The ``SourceLocation`` and ``SourceManager`` classes; ----------------------------------------------------. Strangely enough, the ``SourceLocation`` class represents a location within the; source code of the program. Important design points include:. #. ``sizeof(SourceLocation)`` must be extremely small, as these are embedded; into many AST nodes and are passed around often. Currently it is 32 bits.; #. ``SourceLocation`` must be a simple value object that can be efficiently; copied.; #. We should be able to represent a source location for any byte of any",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:23506,Usability,simpl,simple,23506,"I; might let you click on typedefs to expand them. This application would want to; pass significantly more information about types through to the GUI than a; simple flat string. The interface allows this to happen. .. _internals-diag-translation:. Adding Translations to Clang; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Not possible yet! Diagnostic strings should be written in UTF-8, the client can; translate to the relevant code page if needed. Each translation completely; replaces the format string for the diagnostic. .. _SourceLocation:; .. _SourceManager:. The ``SourceLocation`` and ``SourceManager`` classes; ----------------------------------------------------. Strangely enough, the ``SourceLocation`` class represents a location within the; source code of the program. Important design points include:. #. ``sizeof(SourceLocation)`` must be extremely small, as these are embedded; into many AST nodes and are passed around often. Currently it is 32 bits.; #. ``SourceLocation`` must be a simple value object that can be efficiently; copied.; #. We should be able to represent a source location for any byte of any input; file. This includes in the middle of tokens, in whitespace, in trigraphs,; etc.; #. A ``SourceLocation`` must encode the current ``#include`` stack that was; active when the location was processed. For example, if the location; corresponds to a token, it should contain the set of ``#include``\ s active; when the token was lexed. This allows us to print the ``#include`` stack; for a diagnostic.; #. ``SourceLocation`` must be able to describe macro expansions, capturing both; the ultimate instantiation point and the source of the original character; data. In practice, the ``SourceLocation`` works together with the ``SourceManager``; class to encode two pieces of information about a location: its spelling; location and its expansion location. For most tokens, these will be the; same. However, for a macro expansion (or tokens that came from a ``_Pragma``; directive) the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:32566,Usability,simpl,simplifying,32566,"mdArgs;; // ... + for (const Arg *A : Args.filtered(OPT_fpass_plugin_EQ)) {; + CmdArgs.push_back(Args.MakeArgString(Twine(""-fpass-plugin="") + A->getValue()));; + A->claim();; + }; }. The last step is implementing the ``-cc1`` command line argument; parsing/generation that initializes/serializes the option class (in our case; ``CodeGenOptions``) stored within ``CompilerInvocation``. This can be done; automatically by using the marshalling annotations on the option definition:. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; Group<f_Group>, Flags<[CC1Option]>,; HelpText<""Load pass plugin from a dynamic shared object file."">,; + MarshallingInfoStringVector<CodeGenOpts<""PassPlugins"">>;. Inner workings of the system are introduced in the :ref:`marshalling; infrastructure <OptionMarshalling>` section and the available annotations are; listed :ref:`here <OptionMarshallingAnnotations>`. In case the marshalling infrastructure does not support the desired semantics,; consider simplifying it to fit the existing model. This makes the command line; more uniform and reduces the amount of custom, manually written code. Remember; that the ``-cc1`` command line interface is intended only for Clang developers,; meaning it does not need to mirror the driver interface, maintain backward; compatibility or be compatible with GCC. If the option semantics cannot be encoded via marshalling annotations, you can; resort to parsing/serializing the command line arguments manually:. .. code-block:: diff. // CompilerInvocation.cpp. static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args /*...*/) {; // ... + Opts.PassPlugins = Args.getAllArgValues(OPT_fpass_plugin_EQ);; }. static void GenerateCodeGenArgs(const CodeGenOptions &Opts,; SmallVectorImpl<const char *> &Args,; CompilerInvocation::StringAllocator SA /*...*/) {; // ... + for (const std::string &PassPlugin : Opts.PassPlugins); + GenerateArg(Args, OPT_fpass_plugin_EQ, PassPlugin, SA);; }. F",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:34283,Usability,simpl,simple,34283,"ns &Opts,; SmallVectorImpl<const char *> &Args,; CompilerInvocation::StringAllocator SA /*...*/) {; // ... + for (const std::string &PassPlugin : Opts.PassPlugins); + GenerateArg(Args, OPT_fpass_plugin_EQ, PassPlugin, SA);; }. Finally, you can specify the argument on the command line:; ``clang -fpass-plugin=a -fpass-plugin=b`` and use the new member variable as; desired. .. code-block:: diff. void EmitAssemblyHelper::EmitAssemblyWithNewPassManager(/*...*/) {; // ...; + for (auto &PluginFN : CodeGenOpts.PassPlugins); + if (auto PassPlugin = PassPlugin::Load(PluginFN)); + PassPlugin->registerPassBuilderCallbacks(PB);; }. .. _OptionMarshalling:. Option Marshalling Infrastructure; ---------------------------------. The option marshalling infrastructure automates the parsing of the Clang; ``-cc1`` frontend command line arguments into ``CompilerInvocation`` and their; generation from ``CompilerInvocation``. The system replaces lots of repetitive; C++ code with simple, declarative tablegen annotations and it's being used for; the majority of the ``-cc1`` command line interface. This section provides an; overview of the system. **Note:** The marshalling infrastructure is not intended for driver-only; options. Only options of the ``-cc1`` frontend need to be marshalled to/from; ``CompilerInvocation`` instance. To read and modify contents of ``CompilerInvocation``, the marshalling system; uses key paths, which are declared in two steps. First, a tablegen definition; for the ``CompilerInvocation`` member is created by inheriting from; ``KeyPathAndMacro``:. .. code-block:: text. // Options.td. class LangOpts<string field> : KeyPathAndMacro<""LangOpts->"", field, ""LANG_""> {}; // CompilerInvocation member ^^^^^^^^^^; // OPTION_WITH_MARSHALLING prefix ^^^^^. The first argument to the parent class is the beginning of the key path that; references the ``CompilerInvocation`` member. This argument ends with ``->`` if; the member is a pointer type or with ``.`` if it's a value type. The c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:40706,Usability,simpl,simply,40706,"r is responsible for; accepting both and either forwarding the changing flag or discarding the flag; that would just set the key path to its default. The first argument to ``BoolOption`` is a prefix that is used to construct the; full names of both flags. The positive flag would then be named; ``flegacy-pass-manager`` and the negative ``fno-legacy-pass-manager``.; ``BoolOption`` also implies the ``-`` prefix for both flags. It's also possible; to use ``BoolFOption`` that implies the ``""f""`` prefix and ``Group<f_Group>``.; The ``PosFlag`` and ``NegFlag`` classes hold the associated boolean value,; arrays of elements passed to the ``Flag`` and ``Visibility`` classes and the; help text. The optional ``BothFlags`` class holds arrays of ``Flag`` and; ``Visibility`` elements that are common for both the positive and negative flag; and their common help text suffix. **String**. The key path defaults to the specified string, or an empty one, if omitted. When; the option appears on the command line, the argument value is simply copied. .. code-block:: text. def isysroot : JoinedOrSeparate<[""-""], ""isysroot"">,; Visibility<[ClangOption, CC1Option, FlangOption]>,; MarshallingInfoString<HeaderSearchOpts<""Sysroot"">, [{""/""}]>;. **List of Strings**. The key path defaults to an empty ``std::vector<std::string>``. Values specified; with each appearance of the option on the command line are appended to the; vector. .. code-block:: text. def frewrite_map_file : Separate<[""-""], ""frewrite-map-file"">,; Visibility<[ClangOption, CC1Option]>,; MarshallingInfoStringVector<CodeGenOpts<""RewriteMapFiles"">>;. **Integer**. The key path defaults to the specified integer value, or ``0`` if omitted. When; the option appears on the command line, its value gets parsed by ``llvm::APInt``; and the result is assigned to the key path on success. .. code-block:: text. def mstack_probe_size : Joined<[""-""], ""mstack-probe-size="">,; Visibility<[ClangOption, CC1Option]>,; MarshallingInfoInt<CodeGenOpts<""StackProbe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:56369,Usability,simpl,simple,56369,"an be nested).; * The ``Lexer`` keeps track of an :ref:`MultipleIncludeOpt; <MultipleIncludeOpt>` object, which is used to detect whether the buffer uses; the standard ""``#ifndef XX`` / ``#define XX``"" idiom to prevent multiple; inclusion. If a buffer does, subsequent includes can be ignored if the; ""``XX``"" macro is defined. .. _TokenLexer:. The ``TokenLexer`` class; ------------------------. The ``TokenLexer`` class is a token provider that returns tokens from a list of; tokens that came from somewhere else. It typically used for two things: 1); returning tokens from a macro definition as it is being expanded 2) returning; tokens from an arbitrary buffer of tokens. The later use is used by; ``_Pragma`` and will most likely be used to handle unbounded look-ahead for the; C++ parser. .. _MultipleIncludeOpt:. The ``MultipleIncludeOpt`` class; --------------------------------. The ``MultipleIncludeOpt`` class implements a really simple little state; machine that is used to detect the standard ""``#ifndef XX`` / ``#define XX``""; idiom that people typically use to prevent multiple inclusion of headers. If a; buffer uses this idiom and is subsequently ``#include``'d, the preprocessor can; simply check to see whether the guarding condition is defined or not. If so,; the preprocessor can completely ignore the include of the header. .. _Parser:. The Parser Library; ==================. This library contains a recursive-descent parser that polls tokens from the; preprocessor and notifies a client of the parsing progress. Historically, the parser used to talk to an abstract ``Action`` interface that; had virtual methods for parse events, for example ``ActOnBinOp()``. When Clang; grew C++ support, the parser stopped supporting general ``Action`` clients --; it now always talks to the :ref:`Sema library <Sema>`. However, the Parser; still accesses AST objects only through opaque types like ``ExprResult`` and; ``StmtResult``. Only :ref:`Sema <Sema>` looks at the AST node contents o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:56630,Usability,simpl,simply,56630,"ine XX``"" idiom to prevent multiple; inclusion. If a buffer does, subsequent includes can be ignored if the; ""``XX``"" macro is defined. .. _TokenLexer:. The ``TokenLexer`` class; ------------------------. The ``TokenLexer`` class is a token provider that returns tokens from a list of; tokens that came from somewhere else. It typically used for two things: 1); returning tokens from a macro definition as it is being expanded 2) returning; tokens from an arbitrary buffer of tokens. The later use is used by; ``_Pragma`` and will most likely be used to handle unbounded look-ahead for the; C++ parser. .. _MultipleIncludeOpt:. The ``MultipleIncludeOpt`` class; --------------------------------. The ``MultipleIncludeOpt`` class implements a really simple little state; machine that is used to detect the standard ""``#ifndef XX`` / ``#define XX``""; idiom that people typically use to prevent multiple inclusion of headers. If a; buffer uses this idiom and is subsequently ``#include``'d, the preprocessor can; simply check to see whether the guarding condition is defined or not. If so,; the preprocessor can completely ignore the include of the header. .. _Parser:. The Parser Library; ==================. This library contains a recursive-descent parser that polls tokens from the; preprocessor and notifies a client of the parsing progress. Historically, the parser used to talk to an abstract ``Action`` interface that; had virtual methods for parse events, for example ``ActOnBinOp()``. When Clang; grew C++ support, the parser stopped supporting general ``Action`` clients --; it now always talks to the :ref:`Sema library <Sema>`. However, the Parser; still accesses AST objects only through opaque types like ``ExprResult`` and; ``StmtResult``. Only :ref:`Sema <Sema>` looks at the AST node contents of these; wrappers. .. _AST:. The AST Library; ===============. .. _ASTPhilosophy:. Design philosophy; -----------------. Immutability; ^^^^^^^^^^^^. Clang AST nodes (types, declarations, state",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:58511,Usability,simpl,simpler,58511,"-------. Immutability; ^^^^^^^^^^^^. Clang AST nodes (types, declarations, statements, expressions, and so on) are; generally designed to be immutable once created. This provides a number of key; benefits:. * Canonicalization of the ""meaning"" of nodes is possible as soon as the nodes; are created, and is not invalidated by later addition of more information.; For example, we :ref:`canonicalize types <CanonicalType>`, and use a; canonicalized representation of expressions when determining whether two; function template declarations involving dependent expressions declare the; same entity.; * AST nodes can be reused when they have the same meaning. For example, we; reuse ``Type`` nodes when representing the same type (but maintain separate; ``TypeLoc``\s for each instance where a type is written), and we reuse; non-dependent ``Stmt`` and ``Expr`` nodes across instantiations of a; template.; * Serialization and deserialization of the AST to/from AST files is simpler:; we do not need to track modifications made to AST nodes imported from AST; files and serialize separate ""update records"". There are unfortunately exceptions to this general approach, such as:. * The first declaration of a redeclarable entity maintains a pointer to the; most recent declaration of that entity, which naturally needs to change as; more declarations are parsed.; * Name lookup tables in declaration contexts change after the namespace; declaration is formed.; * We attempt to maintain only a single declaration for an instantiation of a; template, rather than having distinct declarations for an instantiation of; the declaration versus the definition, so template instantiation often; updates parts of existing declarations.; * Some parts of declarations are required to be instantiated separately (this; includes default arguments and exception specifications), and such; instantiations update the existing declaration. These cases tend to be fragile; mutable AST state should be avoided where; possible. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:60232,Usability,simpl,simpler,60232,"ations are required to be instantiated separately (this; includes default arguments and exception specifications), and such; instantiations update the existing declaration. These cases tend to be fragile; mutable AST state should be avoided where; possible. As a consequence of this design principle, we typically do not provide setters; for AST state. (Some are provided for short-term modifications intended to be; used immediately after an AST node is created and before it's ""published"" as; part of the complete AST, or where language semantics require after-the-fact; updates.). Faithfulness; ^^^^^^^^^^^^. The AST intends to provide a representation of the program that is faithful to; the original source. We intend for it to be possible to write refactoring tools; using only information stored in, or easily reconstructible from, the Clang AST.; This means that the AST representation should either not desugar source-level; constructs to simpler forms, or -- where made necessary by language semantics; or a clear engineering tradeoff -- should desugar minimally and wrap the result; in a construct representing the original source form. For example, ``CXXForRangeStmt`` directly represents the syntactic form of a; range-based for statement, but also holds a semantic representation of the; range declaration and iterator declarations. It does not contain a; fully-desugared ``ForStmt``, however. Some AST nodes (for example, ``ParenExpr``) represent only syntax, and others; (for example, ``ImplicitCastExpr``) represent only semantics, but most nodes; will represent a combination of syntax and associated semantics. Inheritance; is typically used when representing different (but related) syntaxes for nodes; with the same or similar semantics. .. _Type:. The ``Type`` class and its subclasses; -------------------------------------. The ``Type`` class (and its subclasses) are an important part of the AST.; Types are accessed through the ``ASTContext`` class, which implicitly creates",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:60302,Usability,clear,clear,60302,"ations are required to be instantiated separately (this; includes default arguments and exception specifications), and such; instantiations update the existing declaration. These cases tend to be fragile; mutable AST state should be avoided where; possible. As a consequence of this design principle, we typically do not provide setters; for AST state. (Some are provided for short-term modifications intended to be; used immediately after an AST node is created and before it's ""published"" as; part of the complete AST, or where language semantics require after-the-fact; updates.). Faithfulness; ^^^^^^^^^^^^. The AST intends to provide a representation of the program that is faithful to; the original source. We intend for it to be possible to write refactoring tools; using only information stored in, or easily reconstructible from, the Clang AST.; This means that the AST representation should either not desugar source-level; constructs to simpler forms, or -- where made necessary by language semantics; or a clear engineering tradeoff -- should desugar minimally and wrap the result; in a construct representing the original source form. For example, ``CXXForRangeStmt`` directly represents the syntactic form of a; range-based for statement, but also holds a semantic representation of the; range declaration and iterator declarations. It does not contain a; fully-desugared ``ForStmt``, however. Some AST nodes (for example, ``ParenExpr``) represent only syntax, and others; (for example, ``ImplicitCastExpr``) represent only semantics, but most nodes; will represent a combination of syntax and associated semantics. Inheritance; is typically used when representing different (but related) syntaxes for nodes; with the same or similar semantics. .. _Type:. The ``Type`` class and its subclasses; -------------------------------------. The ``Type`` class (and its subclasses) are an important part of the AST.; Types are accessed through the ``ASTContext`` class, which implicitly creates",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:63703,Usability,simpl,simple,63703,"r example, the type of ``X``; is ""``foo``"", not ""``int``""), and requires properly propagating it through the; various operators (for example, the type of ``*Y`` is ""``foo``"", not; ""``int``""). In order to retain this information, the type of these expressions; is an instance of the ``TypedefType`` class, which indicates that the type of; these expressions is a typedef for ""``foo``"". Representing types like this is great for diagnostics, because the; user-specified type is always immediately available. There are two problems; with this: first, various semantic checks need to make judgements about the; *actual structure* of a type, ignoring typedefs. Second, we need an efficient; way to query whether two types are structurally identical to each other,; ignoring typedefs. The solution to both of these problems is the idea of; canonical types. .. _CanonicalType:. Canonical Types; ^^^^^^^^^^^^^^^. Every instance of the ``Type`` class contains a canonical type pointer. For; simple types with no typedefs involved (e.g., ""``int``"", ""``int*``"",; ""``int**``""), the type just points to itself. For types that have a typedef; somewhere in their structure (e.g., ""``foo``"", ""``foo*``"", ""``foo**``"",; ""``bar``""), the canonical type pointer points to their structurally equivalent; type without any typedefs (e.g., ""``int``"", ""``int*``"", ""``int**``"", and; ""``int*``"" respectively). This design provides a constant time operation (dereferencing the canonical type; pointer) that gives us access to the structure of types. For example, we can; trivially tell that ""``bar``"" and ""``foo*``"" are the same type by dereferencing; their canonical type pointers and doing a pointer comparison (they both point; to the single ""``int*``"" type). Canonical types and typedef types bring up some complexities that must be; carefully managed. Specifically, the ``isa``/``cast``/``dyn_cast`` operators; generally shouldn't be used in code that is inspecting the AST. For example,; when type checking the indirection ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:68343,Usability,simpl,simple,68343,"the type itself, we do not need; to create duplicates of types with different sets of qualifiers (i.e. there is; only a single heap allocated ""``int``"" type: ""``const int``"" and ""``volatile; const int``"" both point to the same heap allocated ""``int``"" type). This; reduces the heap size used to represent bits and also means we do not have to; consider qualifiers when uniquing types (:ref:`Type <Type>` does not even; contain qualifiers). In practice, the two most common type qualifiers (``const`` and ``restrict``); are stored in the low bits of the pointer to the ``Type`` object, together with; a flag indicating whether extended qualifiers are present (which must be; heap-allocated). This means that ``QualType`` is exactly the same size as a; pointer. .. _DeclarationName:. Declaration names; -----------------. The ``DeclarationName`` class represents the name of a declaration in Clang.; Declarations in the C family of languages can take several different forms.; Most declarations are named by simple identifiers, e.g., ""``f``"" and ""``x``"" in; the function declaration ``f(int x)``. In C++, declaration names can also name; class constructors (""``Class``"" in ``struct Class { Class(); }``), class; destructors (""``~Class``""), overloaded operator names (""``operator+``""), and; conversion functions (""``operator void const *``""). In Objective-C,; declaration names can refer to the names of Objective-C methods, which involve; the method name and the parameters, collectively called a *selector*, e.g.,; ""``setWidth:height:``"". Since all of these kinds of entities --- variables,; functions, Objective-C methods, C++ constructors, destructors, and operators; --- are represented as subclasses of Clang's common ``NamedDecl`` class,; ``DeclarationName`` is designed to efficiently represent any kind of name. Given a ``DeclarationName`` ``N``, ``N.getNameKind()`` will produce a value; that describes what kind of name ``N`` stores. There are 10 options (all of; the names are inside the ``De",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:69392,Usability,simpl,simple,69392,"the function declaration ``f(int x)``. In C++, declaration names can also name; class constructors (""``Class``"" in ``struct Class { Class(); }``), class; destructors (""``~Class``""), overloaded operator names (""``operator+``""), and; conversion functions (""``operator void const *``""). In Objective-C,; declaration names can refer to the names of Objective-C methods, which involve; the method name and the parameters, collectively called a *selector*, e.g.,; ""``setWidth:height:``"". Since all of these kinds of entities --- variables,; functions, Objective-C methods, C++ constructors, destructors, and operators; --- are represented as subclasses of Clang's common ``NamedDecl`` class,; ``DeclarationName`` is designed to efficiently represent any kind of name. Given a ``DeclarationName`` ``N``, ``N.getNameKind()`` will produce a value; that describes what kind of name ``N`` stores. There are 10 options (all of; the names are inside the ``DeclarationName`` class). ``Identifier``. The name is a simple identifier. Use ``N.getAsIdentifierInfo()`` to retrieve; the corresponding ``IdentifierInfo*`` pointing to the actual identifier. ``ObjCZeroArgSelector``, ``ObjCOneArgSelector``, ``ObjCMultiArgSelector``. The name is an Objective-C selector, which can be retrieved as a ``Selector``; instance via ``N.getObjCSelector()``. The three possible name kinds for; Objective-C reflect an optimization within the ``DeclarationName`` class:; both zero- and one-argument selectors are stored as a masked; ``IdentifierInfo`` pointer, and therefore require very little space, since; zero- and one-argument selectors are far more common than multi-argument; selectors (which use a different structure). ``CXXConstructorName``. The name is a C++ constructor name. Use ``N.getCXXNameType()`` to retrieve; the :ref:`type <QualType>` that this constructor is meant to construct. The; type is always the canonical type, since all constructors for a given type; have the same name. ``CXXDestructorName``. The name i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:72049,Usability,simpl,simple,72049,"edOperatorKind``). ``CXXLiteralOperatorName``. The name is a C++11 user defined literal operator. User defined; Literal operators are named according to the suffix they define,; e.g., ""``_foo``"" for ""``operator """" _foo``"". Use; ``N.getCXXLiteralIdentifier()`` to retrieve the corresponding; ``IdentifierInfo*`` pointing to the identifier. ``CXXUsingDirective``. The name is a C++ using directive. Using directives are not really; NamedDecls, in that they all have the same name, but they are; implemented as such in order to store them in DeclContext; effectively. ``DeclarationName``\ s are cheap to create, copy, and compare. They require; only a single pointer's worth of storage in the common cases (identifiers,; zero- and one-argument Objective-C selectors) and use dense, uniqued storage; for the other kinds of names. Two ``DeclarationName``\ s can be compared for; equality (``==``, ``!=``) using a simple bitwise comparison, can be ordered; with ``<``, ``>``, ``<=``, and ``>=`` (which provide a lexicographical ordering; for normal identifiers but an unspecified ordering for other kinds of names),; and can be placed into LLVM ``DenseMap``\ s and ``DenseSet``\ s. ``DeclarationName`` instances can be created in different ways depending on; what kind of name the instance will store. Normal identifiers; (``IdentifierInfo`` pointers) and Objective-C selectors (``Selector``) can be; implicitly converted to ``DeclarationNames``. Names for C++ constructors,; destructors, conversion functions, and overloaded operators can be retrieved; from the ``DeclarationNameTable``, an instance of which is available as; ``ASTContext::DeclarationNames``. The member functions; ``getCXXConstructorName``, ``getCXXDestructorName``,; ``getCXXConversionFunctionName``, and ``getCXXOperatorName``, respectively,; return ``DeclarationName`` instances for the four kinds of C++ special function; names. .. _DeclContext:. Declaration contexts; --------------------. Every declaration in a program exists with",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:84143,Usability,simpl,simply,84143,"the set of declaration contexts that are; semantically connected to this declaration context, in source order, including; this context (which will be the only result, for non-namespace contexts) via; ``DeclContext::collectAllContexts``. Note that these functions are used; internally within the lookup and insertion methods of the ``DeclContext``, so; the vast majority of clients can ignore them. Because the same entity can be defined multiple times in different modules,; it is also possible for there to be multiple definitions of (for instance); a ``CXXRecordDecl``, all of which describe a definition of the same class.; In such a case, only one of those ""definitions"" is considered by Clang to be; the definition of the class, and the others are treated as non-defining; declarations that happen to also contain member declarations. Corresponding; members in each definition of such multiply-defined classes are identified; either by redeclaration chains (if the members are ``Redeclarable``); or by simply a pointer to the canonical declaration (if the declarations; are not ``Redeclarable`` -- in that case, a ``Mergeable`` base class is used; instead). Error Handling; --------------. Clang produces an AST even when the code contains errors. Clang won't generate; and optimize code for it, but it's used as parsing continues to detect further; errors in the input. Clang-based tools also depend on such ASTs, and IDEs in; particular benefit from a high-quality AST for broken code. In presence of errors, clang uses a few error-recovery strategies to present the; broken code in the AST:. - correcting errors: in cases where clang is confident about the fix, it; provides a FixIt attaching to the error diagnostic and emits a corrected AST; (reflecting the written code with FixIts applied). The advantage of that is to; provide more accurate subsequent diagnostics. Typo correction is a typical; example.; - representing invalid node: the invalid node is preserved in the AST in some; form",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:94415,Usability,simpl,simply,94415," and B may or may not be from the same ASTContext.; - if A == X and B == Y (pointer equivalency) then (there is a cycle during the; traverse). - A and B are structurally equivalent if and only if. - All dependent nodes on the path from <A,B> to <X,Y> are structurally; equivalent. When we compare two classes or enums and one of them is incomplete or has; unloaded external lexical declarations then we cannot descend to compare their; contained declarations. So in these cases they are considered equal if they; have the same names. This is the way how we compare forward declarations with; definitions. .. TODO Should we elaborate the actual implementation of the graph traversal,; .. which is a very weird BFS traversal?. Redeclaration Chains; ^^^^^^^^^^^^^^^^^^^^. The early version of the ``ASTImporter``'s merge mechanism squashed the; declarations, i.e. it aimed to have only one declaration instead of maintaining; a whole redeclaration chain. This early approach simply skipped importing a; function prototype, but it imported a definition. To demonstrate the problem; with this approach let's consider an empty ""to"" context and the following; ``virtual`` function declarations of ``f`` in the ""from"" context:. .. code-block:: c++. struct B { virtual void f(); };; void B::f() {} // <-- let's import this definition. If we imported the definition with the ""squashing"" approach then we would; end-up having one declaration which is indeed a definition, but ``isVirtual()``; returns ``false`` for it. The reason is that the definition is indeed not; virtual, it is the property of the prototype!. Consequently, we must either set the virtual flag for the definition (but then; we create a malformed AST which the parser would never create), or we import; the whole redeclaration chain of the function. The most recent version of the; ``ASTImporter`` uses the latter mechanism. We do import all function; declarations - regardless if they are definitions or prototypes - in the order; as they a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:96826,Usability,simpl,simply,96826,"f the redeclaration chain. This may result in long; redeclaration chains in certain cases, e.g. if we import from several; translation units which include the same header with the prototype. .. Squashing prototypes. To mitigate the problem of long redeclaration chains of free functions, we; could compare prototypes to see if they have the same properties and if yes; then we could merge these prototypes. The implementation of squashing of; prototypes for free functions is future work. .. Exception: Cannot have more than 1 prototype in-class. Chaining functions this way ensures that we do copy all information from the; source AST. Nonetheless, there is a problem with member functions: While we can; have many prototypes for free functions, we must have only one prototype for a; member function. .. code-block:: c++. void f(); // OK; void f(); // OK. struct X {; void f(); // OK; void f(); // ERROR; };; void X::f() {} // OK. Thus, prototypes of member functions must be squashed, we cannot just simply; attach a new prototype to the existing in-class prototype. Consider the; following contexts:. .. code-block:: c++. // ""to"" context; struct X {; void f(); // D0; };. .. code-block:: c++. // ""from"" context; struct X {; void f(); // D1; };; void X::f() {} // D2. When we import the prototype and the definition of ``f`` from the ""from""; context, then the resulting redecl chain will look like this ``D0 -> D2'``,; where ``D2'`` is the copy of ``D2`` in the ""to"" context. .. Redecl chains of other declarations. Generally speaking, when we import declarations (like enums and classes) we do; attach the newly imported declaration to the existing redeclaration chain (if; there is structural equivalency). We do not import, however, the whole; redeclaration chain as we do in case of functions. Up till now, we haven't; found any essential property of forward declarations which is similar to the; case of the virtual flag in a member function prototype. In the future, this; may change, though.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:112215,Usability,simpl,simple,112215,"on. However, some; clients of the ``ASTImporter`` may require a different, perhaps less; conservative and more liberal error handling strategy. E.g. static analysis clients may benefit if the node is created even if there; is a name conflict. During the CTU analysis of certain projects, we recognized; that there are global declarations which collide with declarations from other; translation units, but they are not referenced outside from their translation; unit. These declarations should be in an unnamed namespace ideally. If we treat; these collisions liberally then CTU analysis can find more results. Note, the; feature be able to choose between name conflict handling strategies is still an; ongoing work. .. _CFG:. The ``CFG`` class; -----------------. The ``CFG`` class is designed to represent a source-level control-flow graph; for a single statement (``Stmt*``). Typically instances of ``CFG`` are; constructed for function bodies (usually an instance of ``CompoundStmt``), but; can also be instantiated to represent the control-flow of any class that; subclasses ``Stmt``, which includes simple expressions. Control-flow graphs; are especially useful for performing `flow- or path-sensitive; <https://en.wikipedia.org/wiki/Data_flow_analysis#Sensitivities>`_ program; analyses on a given function. Basic Blocks; ^^^^^^^^^^^^. Concretely, an instance of ``CFG`` is a collection of basic blocks. Each basic; block is an instance of ``CFGBlock``, which simply contains an ordered sequence; of ``Stmt*`` (each referring to statements in the AST). The ordering of; statements within a block indicates unconditional flow of control from one; statement to the next. :ref:`Conditional control-flow; <ConditionalControlFlow>` is represented using edges between basic blocks. The; statements within a given ``CFGBlock`` can be traversed using the; ``CFGBlock::*iterator`` interface. A ``CFG`` object owns the instances of ``CFGBlock`` within the control-flow; graph it represents. Each ``CFGBlo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:112577,Usability,simpl,simply,112577,"ns should be in an unnamed namespace ideally. If we treat; these collisions liberally then CTU analysis can find more results. Note, the; feature be able to choose between name conflict handling strategies is still an; ongoing work. .. _CFG:. The ``CFG`` class; -----------------. The ``CFG`` class is designed to represent a source-level control-flow graph; for a single statement (``Stmt*``). Typically instances of ``CFG`` are; constructed for function bodies (usually an instance of ``CompoundStmt``), but; can also be instantiated to represent the control-flow of any class that; subclasses ``Stmt``, which includes simple expressions. Control-flow graphs; are especially useful for performing `flow- or path-sensitive; <https://en.wikipedia.org/wiki/Data_flow_analysis#Sensitivities>`_ program; analyses on a given function. Basic Blocks; ^^^^^^^^^^^^. Concretely, an instance of ``CFG`` is a collection of basic blocks. Each basic; block is an instance of ``CFGBlock``, which simply contains an ordered sequence; of ``Stmt*`` (each referring to statements in the AST). The ordering of; statements within a block indicates unconditional flow of control from one; statement to the next. :ref:`Conditional control-flow; <ConditionalControlFlow>` is represented using edges between basic blocks. The; statements within a given ``CFGBlock`` can be traversed using the; ``CFGBlock::*iterator`` interface. A ``CFG`` object owns the instances of ``CFGBlock`` within the control-flow; graph it represents. Each ``CFGBlock`` within a CFG is also uniquely numbered; (accessible via ``CFGBlock::getBlockID()``). Currently the number is based on; the ordering the blocks were created, but no assumptions should be made on how; ``CFGBlocks`` are numbered other than their numbers are unique and that they; are numbered from 0..N-1 (where N is the number of basic blocks in the CFG). Entry and Exit Blocks; ^^^^^^^^^^^^^^^^^^^^^. Each instance of ``CFG`` contains two special blocks: an *entry* block; (access",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:113822,Usability,clear,clear,113822,"w; <ConditionalControlFlow>` is represented using edges between basic blocks. The; statements within a given ``CFGBlock`` can be traversed using the; ``CFGBlock::*iterator`` interface. A ``CFG`` object owns the instances of ``CFGBlock`` within the control-flow; graph it represents. Each ``CFGBlock`` within a CFG is also uniquely numbered; (accessible via ``CFGBlock::getBlockID()``). Currently the number is based on; the ordering the blocks were created, but no assumptions should be made on how; ``CFGBlocks`` are numbered other than their numbers are unique and that they; are numbered from 0..N-1 (where N is the number of basic blocks in the CFG). Entry and Exit Blocks; ^^^^^^^^^^^^^^^^^^^^^. Each instance of ``CFG`` contains two special blocks: an *entry* block; (accessible via ``CFG::getEntry()``), which has no incoming edges, and an; *exit* block (accessible via ``CFG::getExit()``), which has no outgoing edges.; Neither block contains any statements, and they serve the role of providing a; clear entrance and exit for a body of code such as a function body. The; presence of these empty blocks greatly simplifies the implementation of many; analyses built on top of CFGs. .. _ConditionalControlFlow:. Conditional Control-Flow; ^^^^^^^^^^^^^^^^^^^^^^^^. Conditional control-flow (such as those induced by if-statements and loops) is; represented as edges between ``CFGBlocks``. Because different C language; constructs can induce control-flow, each ``CFGBlock`` also records an extra; ``Stmt*`` that represents the *terminator* of the block. A terminator is; simply the statement that caused the control-flow, and is used to identify the; nature of the conditional control-flow between blocks. For example, in the; case of an if-statement, the terminator refers to the ``IfStmt`` object in the; AST that represented the given branch. To illustrate, consider the following code example:. .. code-block:: c++. int foo(int x) {; x = x + 1;; if (x > 2); x++;; else {; x += 2;; x *= 2;; }.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:113934,Usability,simpl,simplifies,113934,"aversed using the; ``CFGBlock::*iterator`` interface. A ``CFG`` object owns the instances of ``CFGBlock`` within the control-flow; graph it represents. Each ``CFGBlock`` within a CFG is also uniquely numbered; (accessible via ``CFGBlock::getBlockID()``). Currently the number is based on; the ordering the blocks were created, but no assumptions should be made on how; ``CFGBlocks`` are numbered other than their numbers are unique and that they; are numbered from 0..N-1 (where N is the number of basic blocks in the CFG). Entry and Exit Blocks; ^^^^^^^^^^^^^^^^^^^^^. Each instance of ``CFG`` contains two special blocks: an *entry* block; (accessible via ``CFG::getEntry()``), which has no incoming edges, and an; *exit* block (accessible via ``CFG::getExit()``), which has no outgoing edges.; Neither block contains any statements, and they serve the role of providing a; clear entrance and exit for a body of code such as a function body. The; presence of these empty blocks greatly simplifies the implementation of many; analyses built on top of CFGs. .. _ConditionalControlFlow:. Conditional Control-Flow; ^^^^^^^^^^^^^^^^^^^^^^^^. Conditional control-flow (such as those induced by if-statements and loops) is; represented as edges between ``CFGBlocks``. Because different C language; constructs can induce control-flow, each ``CFGBlock`` also records an extra; ``Stmt*`` that represents the *terminator* of the block. A terminator is; simply the statement that caused the control-flow, and is used to identify the; nature of the conditional control-flow between blocks. For example, in the; case of an if-statement, the terminator refers to the ``IfStmt`` object in the; AST that represented the given branch. To illustrate, consider the following code example:. .. code-block:: c++. int foo(int x) {; x = x + 1;; if (x > 2); x++;; else {; x += 2;; x *= 2;; }. return x;; }. After invoking the parser+semantic analyzer on this code fragment, the AST of; the body of ``foo`` is referenced by ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:114390,Usability,simpl,simply,114390,"c blocks in the CFG). Entry and Exit Blocks; ^^^^^^^^^^^^^^^^^^^^^. Each instance of ``CFG`` contains two special blocks: an *entry* block; (accessible via ``CFG::getEntry()``), which has no incoming edges, and an; *exit* block (accessible via ``CFG::getExit()``), which has no outgoing edges.; Neither block contains any statements, and they serve the role of providing a; clear entrance and exit for a body of code such as a function body. The; presence of these empty blocks greatly simplifies the implementation of many; analyses built on top of CFGs. .. _ConditionalControlFlow:. Conditional Control-Flow; ^^^^^^^^^^^^^^^^^^^^^^^^. Conditional control-flow (such as those induced by if-statements and loops) is; represented as edges between ``CFGBlocks``. Because different C language; constructs can induce control-flow, each ``CFGBlock`` also records an extra; ``Stmt*`` that represents the *terminator* of the block. A terminator is; simply the statement that caused the control-flow, and is used to identify the; nature of the conditional control-flow between blocks. For example, in the; case of an if-statement, the terminator refers to the ``IfStmt`` object in the; AST that represented the given branch. To illustrate, consider the following code example:. .. code-block:: c++. int foo(int x) {; x = x + 1;; if (x > 2); x++;; else {; x += 2;; x *= 2;; }. return x;; }. After invoking the parser+semantic analyzer on this code fragment, the AST of; the body of ``foo`` is referenced by a single ``Stmt*``. We can then construct; an instance of ``CFG`` representing the control-flow graph of this function; body by single call to a static class method:. .. code-block:: c++. Stmt *FooBody = ...; std::unique_ptr<CFG> FooCFG = CFG::buildCFG(FooBody);. Along with providing an interface to iterate over its ``CFGBlocks``, the; ``CFG`` class also provides methods that are useful for debugging and; visualizing CFGs. For example, the method ``CFG::dump()`` dumps a; pretty-printed version of ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:116307,Usability,clear,clearly,116307,"nd; visualizing CFGs. For example, the method ``CFG::dump()`` dumps a; pretty-printed version of the CFG to standard error. This is especially useful; when one is using a debugger such as gdb. For example, here is the output of; ``FooCFG->dump()``:. .. code-block:: text. [ B5 (ENTRY) ]; Predecessors (0):; Successors (1): B4. [ B4 ]; 1: x = x + 1; 2: (x > 2); T: if [B4.2]; Predecessors (1): B5; Successors (2): B3 B2. [ B3 ]; 1: x++; Predecessors (1): B4; Successors (1): B1. [ B2 ]; 1: x += 2; 2: x *= 2; Predecessors (1): B4; Successors (1): B1. [ B1 ]; 1: return x;; Predecessors (2): B2 B3; Successors (1): B0. [ B0 (EXIT) ]; Predecessors (1): B1; Successors (0):. For each block, the pretty-printed output displays for each block the number of; *predecessor* blocks (blocks that have outgoing control-flow to the given; block) and *successor* blocks (blocks that have control-flow that have incoming; control-flow from the given block). We can also clearly see the special entry; and exit blocks at the beginning and end of the pretty-printed output. For the; entry block (block B5), the number of predecessor blocks is 0, while for the; exit block (block B0) the number of successor blocks is 0. The most interesting block here is B4, whose outgoing control-flow represents; the branching caused by the sole if-statement in ``foo``. Of particular; interest is the second statement in the block, ``(x > 2)``, and the terminator,; printed as ``if [B4.2]``. The second statement represents the evaluation of; the condition of the if-statement, which occurs before the actual branching of; control-flow. Within the ``CFGBlock`` for B4, the ``Stmt*`` for the second; statement refers to the actual expression in the AST for ``(x > 2)``. Thus; pointers to subclasses of ``Expr`` can appear in the list of statements in a; block, and not just subclasses of ``Stmt`` that refer to proper C statements. The terminator of block B4 is a pointer to the ``IfStmt`` object in the AST.; The pretty-printer o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:152408,Usability,simpl,simple,152408,"he type that your expression; expects, STOP! Go fix semantic analysis and the AST so that you don't; need these bitcasts.; * The ``CodeGenFunction`` class has a number of helper functions to make; certain operations easy, such as generating code to produce an lvalue or; an rvalue, or to initialize a memory location with a given value. Prefer; to use these functions rather than directly writing loads and stores,; because these functions take care of some of the tricky details for you; (e.g., for exceptions).; * If your expression requires some special behavior in the event of an; exception, look at the ``push*Cleanup`` functions in ``CodeGenFunction``; to introduce a cleanup. You shouldn't have to deal with; exception-handling directly.; * Testing is extremely important in IR generation. Use ``clang -cc1; -emit-llvm`` and `FileCheck; <https://llvm.org/docs/CommandGuide/FileCheck.html>`_ to verify that you're; generating the right IR. #. Teach template instantiation how to cope with your AST node, which requires; some fairly simple code:. * Make sure that your expression's constructor properly computes the flags; for type dependence (i.e., the type your expression produces can change; from one instantiation to the next), value dependence (i.e., the constant; value your expression produces can change from one instantiation to the; next), instantiation dependence (i.e., a template parameter occurs; anywhere in your expression), and whether your expression contains a; parameter pack (for variadic templates). Often, computing these flags; just means combining the results from the various types and; subexpressions.; * Add ``TransformXXX`` and ``RebuildXXX`` functions to the ``TreeTransform``; class template in ``Sema``. ``TransformXXX`` should (recursively); transform all of the subexpressions and types within your expression,; using ``getDerived().TransformYYY``. If all of the subexpressions and; types transform without error, it will then call the ``RebuildXXX``; function",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:159444,Usability,simpl,simple,159444,"itself. This can be done using the following syntax:. .. code-block:: c++. // expected-error@path/include.h:15 {{error message}}. The path can be absolute or relative and the same search paths will be used as; for ``#include`` directives. The line number in an external file may be; substituted with ``*`` meaning that any line number will match (useful where; the included file is, for example, a system header where the actual line number; may change and is not critical). As an alternative to specifying a fixed line number, the location of a; diagnostic can instead be indicated by a marker of the form ``#<marker>``.; Markers are specified by including them in a comment, and then referenced by; appending the marker to the diagnostic with ``@#<marker>``, as with:. .. code-block:: c++. #warning some text // #1; // ... other code ...; // expected-warning@#1 {{some text}}. The name of a marker used in a directive must be unique within the compilation. The simple syntax above allows each specification to match exactly one; diagnostic. You can use the extended syntax to customize this. The extended; syntax is ``expected-<type> <n> {{diag text}}``, where ``<type>`` is one of; ``error``, ``warning``, ``remark``, or ``note``, and ``<n>`` is a positive; integer. This allows the diagnostic to appear as many times as specified. For; example:. .. code-block:: c++. void f(); // expected-note 2 {{previous declaration is here}}. Where the diagnostic is expected to occur a minimum number of times, this can; be specified by appending a ``+`` to the number. For example:. .. code-block:: c++. void f(); // expected-note 0+ {{previous declaration is here}}; void g(); // expected-note 1+ {{previous declaration is here}}. In the first example, the diagnostic becomes optional, i.e. it will be; swallowed if it occurs, but will not generate an error if it does not occur. In; the second example, the diagnostic must occur at least once. As a short-hand,; ""one or more"" can be specified simply by ``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:160469,Usability,simpl,simply,160469,"yntax above allows each specification to match exactly one; diagnostic. You can use the extended syntax to customize this. The extended; syntax is ``expected-<type> <n> {{diag text}}``, where ``<type>`` is one of; ``error``, ``warning``, ``remark``, or ``note``, and ``<n>`` is a positive; integer. This allows the diagnostic to appear as many times as specified. For; example:. .. code-block:: c++. void f(); // expected-note 2 {{previous declaration is here}}. Where the diagnostic is expected to occur a minimum number of times, this can; be specified by appending a ``+`` to the number. For example:. .. code-block:: c++. void f(); // expected-note 0+ {{previous declaration is here}}; void g(); // expected-note 1+ {{previous declaration is here}}. In the first example, the diagnostic becomes optional, i.e. it will be; swallowed if it occurs, but will not generate an error if it does not occur. In; the second example, the diagnostic must occur at least once. As a short-hand,; ""one or more"" can be specified simply by ``+``. For example:. .. code-block:: c++. void g(); // expected-note + {{previous declaration is here}}. A range can also be specified by ``<n>-<m>``. For example:. .. code-block:: c++. void f(); // expected-note 0-1 {{previous declaration is here}}. In this example, the diagnostic may appear only once, if at all. .. _DiagnosticMatching:. Matching Modes; ~~~~~~~~~~~~~~. The default matching mode is simple string, which looks for the expected text; that appears between the first `{{` and `}}` pair of the comment. The string is; interpreted just as-is, with one exception: the sequence `\n` is converted to a; single newline character. This mode matches the emitted diagnostic when the; text appears as a substring at any position of the emitted message. To enable matching against desired strings that contain `}}` or `{{`, the; string-mode parser accepts opening delimiters of more than two curly braces,; like `{{{`. It then looks for a closing delimiter of equal ""w",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:160881,Usability,simpl,simple,160881,"e diagnostic is expected to occur a minimum number of times, this can; be specified by appending a ``+`` to the number. For example:. .. code-block:: c++. void f(); // expected-note 0+ {{previous declaration is here}}; void g(); // expected-note 1+ {{previous declaration is here}}. In the first example, the diagnostic becomes optional, i.e. it will be; swallowed if it occurs, but will not generate an error if it does not occur. In; the second example, the diagnostic must occur at least once. As a short-hand,; ""one or more"" can be specified simply by ``+``. For example:. .. code-block:: c++. void g(); // expected-note + {{previous declaration is here}}. A range can also be specified by ``<n>-<m>``. For example:. .. code-block:: c++. void f(); // expected-note 0-1 {{previous declaration is here}}. In this example, the diagnostic may appear only once, if at all. .. _DiagnosticMatching:. Matching Modes; ~~~~~~~~~~~~~~. The default matching mode is simple string, which looks for the expected text; that appears between the first `{{` and `}}` pair of the comment. The string is; interpreted just as-is, with one exception: the sequence `\n` is converted to a; single newline character. This mode matches the emitted diagnostic when the; text appears as a substring at any position of the emitted message. To enable matching against desired strings that contain `}}` or `{{`, the; string-mode parser accepts opening delimiters of more than two curly braces,; like `{{{`. It then looks for a closing delimiter of equal ""width"" (i.e `}}}`).; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:164088,Usability,feedback,feedback,164088,"ure tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, failed assertions, or miscompilations?; * Are there known issues on a particular relevant target?. If the answer to any of these is ""yes"", the feature test macro should either; not be defined or there should be very strong rationale for why the issues; should not prevent defining it. Note, it is acceptable to define the feature; test macro on a per-target basis if needed. When in doubt, being conservative is better than being aggressive. If we don't; claim support for the feature but it does useful things, users can still use it; and provide us with useful feedback on what is missing. But if we claim support; for a feature that has significant bugs, we've eliminated most of the utility; of having a feature testing macro at all because users are then forced to test; what compiler version is in use to get a more accurate answer. The status reported by the feature test macro should always be reflected in the; language support page for the corresponding feature (`C++; <https://clang.llvm.org/cxx_status.html>`_, `C; <https://clang.llvm.org/c_status.html>`_) if applicable. This page can give; more nuanced information to the user as well, such as claiming partial support; for a feature and specifying details as to what remains to be done.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/InternalsManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst:782,Availability,avail,available,782,"=============================; Introduction to the Clang AST; =============================. This document gives a gentle introduction to the mysteries of the Clang; AST. It is targeted at developers who either want to contribute to; Clang, or use tools that work based on Clang's AST, like the AST; matchers. .. raw:: html. <center><iframe width=""560"" height=""315"" src=""https://www.youtube.com/embed/VqCkCDFLSsc?vq=hd720"" frameborder=""0"" allowfullscreen></iframe></center>. `Slides <https://llvm.org/devmtg/2013-04/klimek-slides.pdf>`_. Introduction; ============. Clang's AST is different from ASTs produced by some other compilers in; that it closely resembles both the written C++ code and the C++; standard. For example, parenthesis expressions and compile time; constants are available in an unreduced form in the AST. This makes; Clang's AST a good fit for refactoring tools. Documentation for all Clang AST nodes is available via the generated; `Doxygen <https://clang.llvm.org/doxygen>`_. The doxygen online; documentation is also indexed by your favorite search engine, which will; make a search for clang and the AST node's class name usually turn up; the doxygen of the class you're looking for (for example, search for:; clang ParenExpr). Examining the AST; =================. A good way to familiarize yourself with the Clang AST is to actually look; at it on some simple example code. Clang has a builtin AST-dump mode,; which can be enabled with the flag ``-ast-dump``. Let's look at a simple example AST:. ::. $ cat test.cc; int f(int x) {; int result = (x / 42);; return result;; }. # Clang by default is a frontend for many tools; -Xclang is used to pass; # options directly to the C++ frontend.; $ clang -Xclang -ast-dump -fsyntax-only test.cc; TranslationUnitDecl 0x5aea0d0 <<invalid sloc>>; ... cutting out internal declarations of clang ...; `-FunctionDecl 0x5aeab50 <test.cc:1:1, line:4:1> f 'int (int)'; |-ParmVarDecl 0x5aeaa90 <line:1:7, col:11> x 'int'; `-CompoundStmt 0x5ae",MatchSource.DOCS,interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst:924,Availability,avail,available,924,"=============================; Introduction to the Clang AST; =============================. This document gives a gentle introduction to the mysteries of the Clang; AST. It is targeted at developers who either want to contribute to; Clang, or use tools that work based on Clang's AST, like the AST; matchers. .. raw:: html. <center><iframe width=""560"" height=""315"" src=""https://www.youtube.com/embed/VqCkCDFLSsc?vq=hd720"" frameborder=""0"" allowfullscreen></iframe></center>. `Slides <https://llvm.org/devmtg/2013-04/klimek-slides.pdf>`_. Introduction; ============. Clang's AST is different from ASTs produced by some other compilers in; that it closely resembles both the written C++ code and the C++; standard. For example, parenthesis expressions and compile time; constants are available in an unreduced form in the AST. This makes; Clang's AST a good fit for refactoring tools. Documentation for all Clang AST nodes is available via the generated; `Doxygen <https://clang.llvm.org/doxygen>`_. The doxygen online; documentation is also indexed by your favorite search engine, which will; make a search for clang and the AST node's class name usually turn up; the doxygen of the class you're looking for (for example, search for:; clang ParenExpr). Examining the AST; =================. A good way to familiarize yourself with the Clang AST is to actually look; at it on some simple example code. Clang has a builtin AST-dump mode,; which can be enabled with the flag ``-ast-dump``. Let's look at a simple example AST:. ::. $ cat test.cc; int f(int x) {; int result = (x / 42);; return result;; }. # Clang by default is a frontend for many tools; -Xclang is used to pass; # options directly to the C++ frontend.; $ clang -Xclang -ast-dump -fsyntax-only test.cc; TranslationUnitDecl 0x5aea0d0 <<invalid sloc>>; ... cutting out internal declarations of clang ...; `-FunctionDecl 0x5aeab50 <test.cc:1:1, line:4:1> f 'int (int)'; |-ParmVarDecl 0x5aeaa90 <line:1:7, col:11> x 'int'; `-CompoundStmt 0x5ae",MatchSource.DOCS,interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst:864,Modifiability,refactor,refactoring,864,"=============================; Introduction to the Clang AST; =============================. This document gives a gentle introduction to the mysteries of the Clang; AST. It is targeted at developers who either want to contribute to; Clang, or use tools that work based on Clang's AST, like the AST; matchers. .. raw:: html. <center><iframe width=""560"" height=""315"" src=""https://www.youtube.com/embed/VqCkCDFLSsc?vq=hd720"" frameborder=""0"" allowfullscreen></iframe></center>. `Slides <https://llvm.org/devmtg/2013-04/klimek-slides.pdf>`_. Introduction; ============. Clang's AST is different from ASTs produced by some other compilers in; that it closely resembles both the written C++ code and the C++; standard. For example, parenthesis expressions and compile time; constants are available in an unreduced form in the AST. This makes; Clang's AST a good fit for refactoring tools. Documentation for all Clang AST nodes is available via the generated; `Doxygen <https://clang.llvm.org/doxygen>`_. The doxygen online; documentation is also indexed by your favorite search engine, which will; make a search for clang and the AST node's class name usually turn up; the doxygen of the class you're looking for (for example, search for:; clang ParenExpr). Examining the AST; =================. A good way to familiarize yourself with the Clang AST is to actually look; at it on some simple example code. Clang has a builtin AST-dump mode,; which can be enabled with the flag ``-ast-dump``. Let's look at a simple example AST:. ::. $ cat test.cc; int f(int x) {; int result = (x / 42);; return result;; }. # Clang by default is a frontend for many tools; -Xclang is used to pass; # options directly to the C++ frontend.; $ clang -Xclang -ast-dump -fsyntax-only test.cc; TranslationUnitDecl 0x5aea0d0 <<invalid sloc>>; ... cutting out internal declarations of clang ...; `-FunctionDecl 0x5aeab50 <test.cc:1:1, line:4:1> f 'int (int)'; |-ParmVarDecl 0x5aeaa90 <line:1:7, col:11> x 'int'; `-CompoundStmt 0x5ae",MatchSource.DOCS,interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst:3179,Modifiability,variab,variable,3179,"5aeacc8 <col:17, col:21> 'int' '/'; | |-ImplicitCastExpr 0x5aeacb0 <col:17> 'int' <LValueToRValue>; | | `-DeclRefExpr 0x5aeac68 <col:17> 'int' lvalue ParmVar 0x5aeaa90 'x' 'int'; | `-IntegerLiteral 0x5aeac90 <col:21> 'int' 42; `-ReturnStmt 0x5aead68 <line:3:3, col:10>; `-ImplicitCastExpr 0x5aead50 <col:10> 'int' <LValueToRValue>; `-DeclRefExpr 0x5aead28 <col:10> 'int' lvalue Var 0x5aeac10 'result' 'int'. The toplevel declaration in; a translation unit is always the `translation unit; declaration <https://clang.llvm.org/doxygen/classclang_1_1TranslationUnitDecl.html>`_.; In this example, our first user written declaration is the `function; declaration <https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html>`_; of ""``f``"". The body of ""``f``"" is a `compound; statement <https://clang.llvm.org/doxygen/classclang_1_1CompoundStmt.html>`_,; whose child nodes are a `declaration; statement <https://clang.llvm.org/doxygen/classclang_1_1DeclStmt.html>`_; that declares our result variable, and the `return; statement <https://clang.llvm.org/doxygen/classclang_1_1ReturnStmt.html>`_. AST Context; ===========. All information about the AST for a translation unit is bundled up in; the class; `ASTContext <https://clang.llvm.org/doxygen/classclang_1_1ASTContext.html>`_.; It allows traversal of the whole translation unit starting from; `getTranslationUnitDecl <https://clang.llvm.org/doxygen/classclang_1_1ASTContext.html#abd909fb01ef10cfd0244832a67b1dd64>`_,; or to access Clang's `table of; identifiers <https://clang.llvm.org/doxygen/classclang_1_1ASTContext.html#a4f95adb9958e22fbe55212ae6482feb4>`_; for the parsed translation unit. AST Nodes; =========. Clang's AST nodes are modeled on a class hierarchy that does not have a; common ancestor. Instead, there are multiple larger hierarchies for; basic node types like; `Decl <https://clang.llvm.org/doxygen/classclang_1_1Decl.html>`_ and; `Stmt <https://clang.llvm.org/doxygen/classclang_1_1Stmt.html>`_. Many; important AST nodes der",MatchSource.DOCS,interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst:3665,Security,access,access,3665,"tion unit; declaration <https://clang.llvm.org/doxygen/classclang_1_1TranslationUnitDecl.html>`_.; In this example, our first user written declaration is the `function; declaration <https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html>`_; of ""``f``"". The body of ""``f``"" is a `compound; statement <https://clang.llvm.org/doxygen/classclang_1_1CompoundStmt.html>`_,; whose child nodes are a `declaration; statement <https://clang.llvm.org/doxygen/classclang_1_1DeclStmt.html>`_; that declares our result variable, and the `return; statement <https://clang.llvm.org/doxygen/classclang_1_1ReturnStmt.html>`_. AST Context; ===========. All information about the AST for a translation unit is bundled up in; the class; `ASTContext <https://clang.llvm.org/doxygen/classclang_1_1ASTContext.html>`_.; It allows traversal of the whole translation unit starting from; `getTranslationUnitDecl <https://clang.llvm.org/doxygen/classclang_1_1ASTContext.html#abd909fb01ef10cfd0244832a67b1dd64>`_,; or to access Clang's `table of; identifiers <https://clang.llvm.org/doxygen/classclang_1_1ASTContext.html#a4f95adb9958e22fbe55212ae6482feb4>`_; for the parsed translation unit. AST Nodes; =========. Clang's AST nodes are modeled on a class hierarchy that does not have a; common ancestor. Instead, there are multiple larger hierarchies for; basic node types like; `Decl <https://clang.llvm.org/doxygen/classclang_1_1Decl.html>`_ and; `Stmt <https://clang.llvm.org/doxygen/classclang_1_1Stmt.html>`_. Many; important AST nodes derive from; `Type <https://clang.llvm.org/doxygen/classclang_1_1Type.html>`_,; `Decl <https://clang.llvm.org/doxygen/classclang_1_1Decl.html>`_,; `DeclContext <https://clang.llvm.org/doxygen/classclang_1_1DeclContext.html>`_; or `Stmt <https://clang.llvm.org/doxygen/classclang_1_1Stmt.html>`_, with; some classes deriving from both Decl and DeclContext. There are also a multitude of nodes in the AST that are not part of a; larger hierarchy, and are only reachable from specific ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst:1533,Testability,test,test,1533,"f>`_. Introduction; ============. Clang's AST is different from ASTs produced by some other compilers in; that it closely resembles both the written C++ code and the C++; standard. For example, parenthesis expressions and compile time; constants are available in an unreduced form in the AST. This makes; Clang's AST a good fit for refactoring tools. Documentation for all Clang AST nodes is available via the generated; `Doxygen <https://clang.llvm.org/doxygen>`_. The doxygen online; documentation is also indexed by your favorite search engine, which will; make a search for clang and the AST node's class name usually turn up; the doxygen of the class you're looking for (for example, search for:; clang ParenExpr). Examining the AST; =================. A good way to familiarize yourself with the Clang AST is to actually look; at it on some simple example code. Clang has a builtin AST-dump mode,; which can be enabled with the flag ``-ast-dump``. Let's look at a simple example AST:. ::. $ cat test.cc; int f(int x) {; int result = (x / 42);; return result;; }. # Clang by default is a frontend for many tools; -Xclang is used to pass; # options directly to the C++ frontend.; $ clang -Xclang -ast-dump -fsyntax-only test.cc; TranslationUnitDecl 0x5aea0d0 <<invalid sloc>>; ... cutting out internal declarations of clang ...; `-FunctionDecl 0x5aeab50 <test.cc:1:1, line:4:1> f 'int (int)'; |-ParmVarDecl 0x5aeaa90 <line:1:7, col:11> x 'int'; `-CompoundStmt 0x5aead88 <col:14, line:4:1>; |-DeclStmt 0x5aead10 <line:2:3, col:24>; | `-VarDecl 0x5aeac10 <col:3, col:23> result 'int'; | `-ParenExpr 0x5aeacf0 <col:16, col:23> 'int'; | `-BinaryOperator 0x5aeacc8 <col:17, col:21> 'int' '/'; | |-ImplicitCastExpr 0x5aeacb0 <col:17> 'int' <LValueToRValue>; | | `-DeclRefExpr 0x5aeac68 <col:17> 'int' lvalue ParmVar 0x5aeaa90 'x' 'int'; | `-IntegerLiteral 0x5aeac90 <col:21> 'int' 42; `-ReturnStmt 0x5aead68 <line:3:3, col:10>; `-ImplicitCastExpr 0x5aead50 <col:10> 'int' <LValueToRValue>; `-DeclRefExp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst:1756,Testability,test,test,1756," expressions and compile time; constants are available in an unreduced form in the AST. This makes; Clang's AST a good fit for refactoring tools. Documentation for all Clang AST nodes is available via the generated; `Doxygen <https://clang.llvm.org/doxygen>`_. The doxygen online; documentation is also indexed by your favorite search engine, which will; make a search for clang and the AST node's class name usually turn up; the doxygen of the class you're looking for (for example, search for:; clang ParenExpr). Examining the AST; =================. A good way to familiarize yourself with the Clang AST is to actually look; at it on some simple example code. Clang has a builtin AST-dump mode,; which can be enabled with the flag ``-ast-dump``. Let's look at a simple example AST:. ::. $ cat test.cc; int f(int x) {; int result = (x / 42);; return result;; }. # Clang by default is a frontend for many tools; -Xclang is used to pass; # options directly to the C++ frontend.; $ clang -Xclang -ast-dump -fsyntax-only test.cc; TranslationUnitDecl 0x5aea0d0 <<invalid sloc>>; ... cutting out internal declarations of clang ...; `-FunctionDecl 0x5aeab50 <test.cc:1:1, line:4:1> f 'int (int)'; |-ParmVarDecl 0x5aeaa90 <line:1:7, col:11> x 'int'; `-CompoundStmt 0x5aead88 <col:14, line:4:1>; |-DeclStmt 0x5aead10 <line:2:3, col:24>; | `-VarDecl 0x5aeac10 <col:3, col:23> result 'int'; | `-ParenExpr 0x5aeacf0 <col:16, col:23> 'int'; | `-BinaryOperator 0x5aeacc8 <col:17, col:21> 'int' '/'; | |-ImplicitCastExpr 0x5aeacb0 <col:17> 'int' <LValueToRValue>; | | `-DeclRefExpr 0x5aeac68 <col:17> 'int' lvalue ParmVar 0x5aeaa90 'x' 'int'; | `-IntegerLiteral 0x5aeac90 <col:21> 'int' 42; `-ReturnStmt 0x5aead68 <line:3:3, col:10>; `-ImplicitCastExpr 0x5aead50 <col:10> 'int' <LValueToRValue>; `-DeclRefExpr 0x5aead28 <col:10> 'int' lvalue Var 0x5aeac10 'result' 'int'. The toplevel declaration in; a translation unit is always the `translation unit; declaration <https://clang.llvm.org/doxygen/classclang_1_1Tra",MatchSource.DOCS,interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst:1891,Testability,test,test,1891,"ls. Documentation for all Clang AST nodes is available via the generated; `Doxygen <https://clang.llvm.org/doxygen>`_. The doxygen online; documentation is also indexed by your favorite search engine, which will; make a search for clang and the AST node's class name usually turn up; the doxygen of the class you're looking for (for example, search for:; clang ParenExpr). Examining the AST; =================. A good way to familiarize yourself with the Clang AST is to actually look; at it on some simple example code. Clang has a builtin AST-dump mode,; which can be enabled with the flag ``-ast-dump``. Let's look at a simple example AST:. ::. $ cat test.cc; int f(int x) {; int result = (x / 42);; return result;; }. # Clang by default is a frontend for many tools; -Xclang is used to pass; # options directly to the C++ frontend.; $ clang -Xclang -ast-dump -fsyntax-only test.cc; TranslationUnitDecl 0x5aea0d0 <<invalid sloc>>; ... cutting out internal declarations of clang ...; `-FunctionDecl 0x5aeab50 <test.cc:1:1, line:4:1> f 'int (int)'; |-ParmVarDecl 0x5aeaa90 <line:1:7, col:11> x 'int'; `-CompoundStmt 0x5aead88 <col:14, line:4:1>; |-DeclStmt 0x5aead10 <line:2:3, col:24>; | `-VarDecl 0x5aeac10 <col:3, col:23> result 'int'; | `-ParenExpr 0x5aeacf0 <col:16, col:23> 'int'; | `-BinaryOperator 0x5aeacc8 <col:17, col:21> 'int' '/'; | |-ImplicitCastExpr 0x5aeacb0 <col:17> 'int' <LValueToRValue>; | | `-DeclRefExpr 0x5aeac68 <col:17> 'int' lvalue ParmVar 0x5aeaa90 'x' 'int'; | `-IntegerLiteral 0x5aeac90 <col:21> 'int' 42; `-ReturnStmt 0x5aead68 <line:3:3, col:10>; `-ImplicitCastExpr 0x5aead50 <col:10> 'int' <LValueToRValue>; `-DeclRefExpr 0x5aead28 <col:10> 'int' lvalue Var 0x5aeac10 'result' 'int'. The toplevel declaration in; a translation unit is always the `translation unit; declaration <https://clang.llvm.org/doxygen/classclang_1_1TranslationUnitDecl.html>`_.; In this example, our first user written declaration is the `function; declaration <https://clang.llvm.org/doxygen/c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst:1379,Usability,simpl,simple,1379,"th=""560"" height=""315"" src=""https://www.youtube.com/embed/VqCkCDFLSsc?vq=hd720"" frameborder=""0"" allowfullscreen></iframe></center>. `Slides <https://llvm.org/devmtg/2013-04/klimek-slides.pdf>`_. Introduction; ============. Clang's AST is different from ASTs produced by some other compilers in; that it closely resembles both the written C++ code and the C++; standard. For example, parenthesis expressions and compile time; constants are available in an unreduced form in the AST. This makes; Clang's AST a good fit for refactoring tools. Documentation for all Clang AST nodes is available via the generated; `Doxygen <https://clang.llvm.org/doxygen>`_. The doxygen online; documentation is also indexed by your favorite search engine, which will; make a search for clang and the AST node's class name usually turn up; the doxygen of the class you're looking for (for example, search for:; clang ParenExpr). Examining the AST; =================. A good way to familiarize yourself with the Clang AST is to actually look; at it on some simple example code. Clang has a builtin AST-dump mode,; which can be enabled with the flag ``-ast-dump``. Let's look at a simple example AST:. ::. $ cat test.cc; int f(int x) {; int result = (x / 42);; return result;; }. # Clang by default is a frontend for many tools; -Xclang is used to pass; # options directly to the C++ frontend.; $ clang -Xclang -ast-dump -fsyntax-only test.cc; TranslationUnitDecl 0x5aea0d0 <<invalid sloc>>; ... cutting out internal declarations of clang ...; `-FunctionDecl 0x5aeab50 <test.cc:1:1, line:4:1> f 'int (int)'; |-ParmVarDecl 0x5aeaa90 <line:1:7, col:11> x 'int'; `-CompoundStmt 0x5aead88 <col:14, line:4:1>; |-DeclStmt 0x5aead10 <line:2:3, col:24>; | `-VarDecl 0x5aeac10 <col:3, col:23> result 'int'; | `-ParenExpr 0x5aeacf0 <col:16, col:23> 'int'; | `-BinaryOperator 0x5aeacc8 <col:17, col:21> 'int' '/'; | |-ImplicitCastExpr 0x5aeacb0 <col:17> 'int' <LValueToRValue>; | | `-DeclRefExpr 0x5aeac68 <col:17> 'int' lvalue ParmVa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst:1502,Usability,simpl,simple,1502,"vmtg/2013-04/klimek-slides.pdf>`_. Introduction; ============. Clang's AST is different from ASTs produced by some other compilers in; that it closely resembles both the written C++ code and the C++; standard. For example, parenthesis expressions and compile time; constants are available in an unreduced form in the AST. This makes; Clang's AST a good fit for refactoring tools. Documentation for all Clang AST nodes is available via the generated; `Doxygen <https://clang.llvm.org/doxygen>`_. The doxygen online; documentation is also indexed by your favorite search engine, which will; make a search for clang and the AST node's class name usually turn up; the doxygen of the class you're looking for (for example, search for:; clang ParenExpr). Examining the AST; =================. A good way to familiarize yourself with the Clang AST is to actually look; at it on some simple example code. Clang has a builtin AST-dump mode,; which can be enabled with the flag ``-ast-dump``. Let's look at a simple example AST:. ::. $ cat test.cc; int f(int x) {; int result = (x / 42);; return result;; }. # Clang by default is a frontend for many tools; -Xclang is used to pass; # options directly to the C++ frontend.; $ clang -Xclang -ast-dump -fsyntax-only test.cc; TranslationUnitDecl 0x5aea0d0 <<invalid sloc>>; ... cutting out internal declarations of clang ...; `-FunctionDecl 0x5aeab50 <test.cc:1:1, line:4:1> f 'int (int)'; |-ParmVarDecl 0x5aeaa90 <line:1:7, col:11> x 'int'; `-CompoundStmt 0x5aead88 <col:14, line:4:1>; |-DeclStmt 0x5aead10 <line:2:3, col:24>; | `-VarDecl 0x5aeac10 <col:3, col:23> result 'int'; | `-ParenExpr 0x5aeacf0 <col:16, col:23> 'int'; | `-BinaryOperator 0x5aeacc8 <col:17, col:21> 'int' '/'; | |-ImplicitCastExpr 0x5aeacb0 <col:17> 'int' <LValueToRValue>; | | `-DeclRefExpr 0x5aeac68 <col:17> 'int' lvalue ParmVar 0x5aeaa90 'x' 'int'; | `-IntegerLiteral 0x5aeac90 <col:21> 'int' 42; `-ReturnStmt 0x5aead68 <line:3:3, col:10>; `-ImplicitCastExpr 0x5aead50 <col:10> 'int' <L",MatchSource.DOCS,interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst:1540,Availability,avail,available,1540,"ine namespace declaration. The attribute takes; one or more strings (called tags); the order does not matter. See https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Attributes.html for; details. Tags on an inline namespace are called ""implicit tags"", all other tags are; ""explicit tags"". Mangling; ========. All tags that are ""active"" on an <unqualified-name> are emitted after the; <unqualified-name>, before <template-args> or <discriminator>, and are part of; the same <substitution> the <unqualified-name> is. They are mangled as:. .. code-block:: none. <abi-tags> ::= <abi-tag>* # sort by name; <abi-tag> ::= B <tag source-name>. Example:. .. code-block:: c++. __attribute__((abi_tag(""test""))); void Func();; // gets mangled as: _Z4FuncB4testv (prettified as `Func[abi:test]()`). Active tags; ===========. A namespace does not have any active tags. For types (class / struct / union /; enum), the explicit tags are the active tags. For variables and functions, the active tags are the explicit tags plus any; ""required tags"" which are not in the ""available tags"" set:. .. code-block:: none. derived-tags := (required-tags - available-tags); active-tags := explicit-tags + derived-tags. Required tags for a function; ============================. If a function is used as a local scope for another name, and is part of; another function as local scope, it doesn't have any required tags. If a function is used as a local scope for a guard variable name, it doesn't; have any required tags. Otherwise the function requires any implicit or explicit tag used in the name; for the return type. Example:. .. code-block:: c++. namespace A {; inline namespace B __attribute__((abi_tag)) {; struct C { int x; };; }; }. A::C foo(); // gets mangled as: _Z3fooB1Bv (prettified as `foo[abi:B]()`). Required tags for a variable; ============================. A variable requires any implicit or explicit tag used in its type. Available tags; ==============. All tags used in the prefix and in the template argument",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst:1617,Availability,avail,available-tags,1617,"nedocs/gcc/C_002b_002b-Attributes.html for; details. Tags on an inline namespace are called ""implicit tags"", all other tags are; ""explicit tags"". Mangling; ========. All tags that are ""active"" on an <unqualified-name> are emitted after the; <unqualified-name>, before <template-args> or <discriminator>, and are part of; the same <substitution> the <unqualified-name> is. They are mangled as:. .. code-block:: none. <abi-tags> ::= <abi-tag>* # sort by name; <abi-tag> ::= B <tag source-name>. Example:. .. code-block:: c++. __attribute__((abi_tag(""test""))); void Func();; // gets mangled as: _Z4FuncB4testv (prettified as `Func[abi:test]()`). Active tags; ===========. A namespace does not have any active tags. For types (class / struct / union /; enum), the explicit tags are the active tags. For variables and functions, the active tags are the explicit tags plus any; ""required tags"" which are not in the ""available tags"" set:. .. code-block:: none. derived-tags := (required-tags - available-tags); active-tags := explicit-tags + derived-tags. Required tags for a function; ============================. If a function is used as a local scope for another name, and is part of; another function as local scope, it doesn't have any required tags. If a function is used as a local scope for a guard variable name, it doesn't; have any required tags. Otherwise the function requires any implicit or explicit tag used in the name; for the return type. Example:. .. code-block:: c++. namespace A {; inline namespace B __attribute__((abi_tag)) {; struct C { int x; };; }; }. A::C foo(); // gets mangled as: _Z3fooB1Bv (prettified as `foo[abi:B]()`). Required tags for a variable; ============================. A variable requires any implicit or explicit tag used in its type. Available tags; ==============. All tags used in the prefix and in the template arguments for a name are; available. Also, for functions, all tags from the <bare-function-type>; (which might include the return type for templat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst:2511,Availability,avail,available,2511," Example:. .. code-block:: c++. __attribute__((abi_tag(""test""))); void Func();; // gets mangled as: _Z4FuncB4testv (prettified as `Func[abi:test]()`). Active tags; ===========. A namespace does not have any active tags. For types (class / struct / union /; enum), the explicit tags are the active tags. For variables and functions, the active tags are the explicit tags plus any; ""required tags"" which are not in the ""available tags"" set:. .. code-block:: none. derived-tags := (required-tags - available-tags); active-tags := explicit-tags + derived-tags. Required tags for a function; ============================. If a function is used as a local scope for another name, and is part of; another function as local scope, it doesn't have any required tags. If a function is used as a local scope for a guard variable name, it doesn't; have any required tags. Otherwise the function requires any implicit or explicit tag used in the name; for the return type. Example:. .. code-block:: c++. namespace A {; inline namespace B __attribute__((abi_tag)) {; struct C { int x; };; }; }. A::C foo(); // gets mangled as: _Z3fooB1Bv (prettified as `foo[abi:B]()`). Required tags for a variable; ============================. A variable requires any implicit or explicit tag used in its type. Available tags; ==============. All tags used in the prefix and in the template arguments for a name are; available. Also, for functions, all tags from the <bare-function-type>; (which might include the return type for template functions) are available. For <local-name>s all active tags used in the local part (<function-; encoding>) are available, but not implicit tags which were not active. Implicit and explicit tags used in the <unqualified-name> for a function (as; in the type of a cast operator) are NOT available. Example: a cast operator to std::string (which is; std::__cxx11::basic_string<...>) will use 'cxx11' as an active tag, as it is; required from the return type `std::string` but not available.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst:2648,Availability,avail,available,2648," Example:. .. code-block:: c++. __attribute__((abi_tag(""test""))); void Func();; // gets mangled as: _Z4FuncB4testv (prettified as `Func[abi:test]()`). Active tags; ===========. A namespace does not have any active tags. For types (class / struct / union /; enum), the explicit tags are the active tags. For variables and functions, the active tags are the explicit tags plus any; ""required tags"" which are not in the ""available tags"" set:. .. code-block:: none. derived-tags := (required-tags - available-tags); active-tags := explicit-tags + derived-tags. Required tags for a function; ============================. If a function is used as a local scope for another name, and is part of; another function as local scope, it doesn't have any required tags. If a function is used as a local scope for a guard variable name, it doesn't; have any required tags. Otherwise the function requires any implicit or explicit tag used in the name; for the return type. Example:. .. code-block:: c++. namespace A {; inline namespace B __attribute__((abi_tag)) {; struct C { int x; };; }; }. A::C foo(); // gets mangled as: _Z3fooB1Bv (prettified as `foo[abi:B]()`). Required tags for a variable; ============================. A variable requires any implicit or explicit tag used in its type. Available tags; ==============. All tags used in the prefix and in the template arguments for a name are; available. Also, for functions, all tags from the <bare-function-type>; (which might include the return type for template functions) are available. For <local-name>s all active tags used in the local part (<function-; encoding>) are available, but not implicit tags which were not active. Implicit and explicit tags used in the <unqualified-name> for a function (as; in the type of a cast operator) are NOT available. Example: a cast operator to std::string (which is; std::__cxx11::basic_string<...>) will use 'cxx11' as an active tag, as it is; required from the return type `std::string` but not available.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst:2744,Availability,avail,available,2744," Example:. .. code-block:: c++. __attribute__((abi_tag(""test""))); void Func();; // gets mangled as: _Z4FuncB4testv (prettified as `Func[abi:test]()`). Active tags; ===========. A namespace does not have any active tags. For types (class / struct / union /; enum), the explicit tags are the active tags. For variables and functions, the active tags are the explicit tags plus any; ""required tags"" which are not in the ""available tags"" set:. .. code-block:: none. derived-tags := (required-tags - available-tags); active-tags := explicit-tags + derived-tags. Required tags for a function; ============================. If a function is used as a local scope for another name, and is part of; another function as local scope, it doesn't have any required tags. If a function is used as a local scope for a guard variable name, it doesn't; have any required tags. Otherwise the function requires any implicit or explicit tag used in the name; for the return type. Example:. .. code-block:: c++. namespace A {; inline namespace B __attribute__((abi_tag)) {; struct C { int x; };; }; }. A::C foo(); // gets mangled as: _Z3fooB1Bv (prettified as `foo[abi:B]()`). Required tags for a variable; ============================. A variable requires any implicit or explicit tag used in its type. Available tags; ==============. All tags used in the prefix and in the template arguments for a name are; available. Also, for functions, all tags from the <bare-function-type>; (which might include the return type for template functions) are available. For <local-name>s all active tags used in the local part (<function-; encoding>) are available, but not implicit tags which were not active. Implicit and explicit tags used in the <unqualified-name> for a function (as; in the type of a cast operator) are NOT available. Example: a cast operator to std::string (which is; std::__cxx11::basic_string<...>) will use 'cxx11' as an active tag, as it is; required from the return type `std::string` but not available.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst:2918,Availability,avail,available,2918," Example:. .. code-block:: c++. __attribute__((abi_tag(""test""))); void Func();; // gets mangled as: _Z4FuncB4testv (prettified as `Func[abi:test]()`). Active tags; ===========. A namespace does not have any active tags. For types (class / struct / union /; enum), the explicit tags are the active tags. For variables and functions, the active tags are the explicit tags plus any; ""required tags"" which are not in the ""available tags"" set:. .. code-block:: none. derived-tags := (required-tags - available-tags); active-tags := explicit-tags + derived-tags. Required tags for a function; ============================. If a function is used as a local scope for another name, and is part of; another function as local scope, it doesn't have any required tags. If a function is used as a local scope for a guard variable name, it doesn't; have any required tags. Otherwise the function requires any implicit or explicit tag used in the name; for the return type. Example:. .. code-block:: c++. namespace A {; inline namespace B __attribute__((abi_tag)) {; struct C { int x; };; }; }. A::C foo(); // gets mangled as: _Z3fooB1Bv (prettified as `foo[abi:B]()`). Required tags for a variable; ============================. A variable requires any implicit or explicit tag used in its type. Available tags; ==============. All tags used in the prefix and in the template arguments for a name are; available. Also, for functions, all tags from the <bare-function-type>; (which might include the return type for template functions) are available. For <local-name>s all active tags used in the local part (<function-; encoding>) are available, but not implicit tags which were not active. Implicit and explicit tags used in the <unqualified-name> for a function (as; in the type of a cast operator) are NOT available. Example: a cast operator to std::string (which is; std::__cxx11::basic_string<...>) will use 'cxx11' as an active tag, as it is; required from the return type `std::string` but not available.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst:3110,Availability,avail,available,3110," Example:. .. code-block:: c++. __attribute__((abi_tag(""test""))); void Func();; // gets mangled as: _Z4FuncB4testv (prettified as `Func[abi:test]()`). Active tags; ===========. A namespace does not have any active tags. For types (class / struct / union /; enum), the explicit tags are the active tags. For variables and functions, the active tags are the explicit tags plus any; ""required tags"" which are not in the ""available tags"" set:. .. code-block:: none. derived-tags := (required-tags - available-tags); active-tags := explicit-tags + derived-tags. Required tags for a function; ============================. If a function is used as a local scope for another name, and is part of; another function as local scope, it doesn't have any required tags. If a function is used as a local scope for a guard variable name, it doesn't; have any required tags. Otherwise the function requires any implicit or explicit tag used in the name; for the return type. Example:. .. code-block:: c++. namespace A {; inline namespace B __attribute__((abi_tag)) {; struct C { int x; };; }; }. A::C foo(); // gets mangled as: _Z3fooB1Bv (prettified as `foo[abi:B]()`). Required tags for a variable; ============================. A variable requires any implicit or explicit tag used in its type. Available tags; ==============. All tags used in the prefix and in the template arguments for a name are; available. Also, for functions, all tags from the <bare-function-type>; (which might include the return type for template functions) are available. For <local-name>s all active tags used in the local part (<function-; encoding>) are available, but not implicit tags which were not active. Implicit and explicit tags used in the <unqualified-name> for a function (as; in the type of a cast operator) are NOT available. Example: a cast operator to std::string (which is; std::__cxx11::basic_string<...>) will use 'cxx11' as an active tag, as it is; required from the return type `std::string` but not available.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst:470,Modifiability,variab,variable,470,"========; ABI tags; ========. Introduction; ============. This text tries to describe gcc semantic for mangling ""abi_tag"" attributes; described in https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Attributes.html. There is no guarantee the following rules are correct, complete or make sense; in any way as they were determined empirically by experiments with gcc5. Declaration; ===========. ABI tags are declared in an abi_tag attribute and can be applied to a; function, variable, class or inline namespace declaration. The attribute takes; one or more strings (called tags); the order does not matter. See https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Attributes.html for; details. Tags on an inline namespace are called ""implicit tags"", all other tags are; ""explicit tags"". Mangling; ========. All tags that are ""active"" on an <unqualified-name> are emitted after the; <unqualified-name>, before <template-args> or <discriminator>, and are part of; the same <substitution> the <unqualified-name> is. They are mangled as:. .. code-block:: none. <abi-tags> ::= <abi-tag>* # sort by name; <abi-tag> ::= B <tag source-name>. Example:. .. code-block:: c++. __attribute__((abi_tag(""test""))); void Func();; // gets mangled as: _Z4FuncB4testv (prettified as `Func[abi:test]()`). Active tags; ===========. A namespace does not have any active tags. For types (class / struct / union /; enum), the explicit tags are the active tags. For variables and functions, the active tags are the explicit tags plus any; ""required tags"" which are not in the ""available tags"" set:. .. code-block:: none. derived-tags := (required-tags - available-tags); active-tags := explicit-tags + derived-tags. Required tags for a function; ============================. If a function is used as a local scope for another name, and is part of; another function as local scope, it doesn't have any required tags. If a function is used as a local scope for a guard variable name, it doesn't; have any required tags. Otherwise the funct",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst:1429,Modifiability,variab,variables,1429,"ine namespace declaration. The attribute takes; one or more strings (called tags); the order does not matter. See https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Attributes.html for; details. Tags on an inline namespace are called ""implicit tags"", all other tags are; ""explicit tags"". Mangling; ========. All tags that are ""active"" on an <unqualified-name> are emitted after the; <unqualified-name>, before <template-args> or <discriminator>, and are part of; the same <substitution> the <unqualified-name> is. They are mangled as:. .. code-block:: none. <abi-tags> ::= <abi-tag>* # sort by name; <abi-tag> ::= B <tag source-name>. Example:. .. code-block:: c++. __attribute__((abi_tag(""test""))); void Func();; // gets mangled as: _Z4FuncB4testv (prettified as `Func[abi:test]()`). Active tags; ===========. A namespace does not have any active tags. For types (class / struct / union /; enum), the explicit tags are the active tags. For variables and functions, the active tags are the explicit tags plus any; ""required tags"" which are not in the ""available tags"" set:. .. code-block:: none. derived-tags := (required-tags - available-tags); active-tags := explicit-tags + derived-tags. Required tags for a function; ============================. If a function is used as a local scope for another name, and is part of; another function as local scope, it doesn't have any required tags. If a function is used as a local scope for a guard variable name, it doesn't; have any required tags. Otherwise the function requires any implicit or explicit tag used in the name; for the return type. Example:. .. code-block:: c++. namespace A {; inline namespace B __attribute__((abi_tag)) {; struct C { int x; };; }; }. A::C foo(); // gets mangled as: _Z3fooB1Bv (prettified as `foo[abi:B]()`). Required tags for a variable; ============================. A variable requires any implicit or explicit tag used in its type. Available tags; ==============. All tags used in the prefix and in the template argument",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst:1931,Modifiability,variab,variable,1931,"r>, and are part of; the same <substitution> the <unqualified-name> is. They are mangled as:. .. code-block:: none. <abi-tags> ::= <abi-tag>* # sort by name; <abi-tag> ::= B <tag source-name>. Example:. .. code-block:: c++. __attribute__((abi_tag(""test""))); void Func();; // gets mangled as: _Z4FuncB4testv (prettified as `Func[abi:test]()`). Active tags; ===========. A namespace does not have any active tags. For types (class / struct / union /; enum), the explicit tags are the active tags. For variables and functions, the active tags are the explicit tags plus any; ""required tags"" which are not in the ""available tags"" set:. .. code-block:: none. derived-tags := (required-tags - available-tags); active-tags := explicit-tags + derived-tags. Required tags for a function; ============================. If a function is used as a local scope for another name, and is part of; another function as local scope, it doesn't have any required tags. If a function is used as a local scope for a guard variable name, it doesn't; have any required tags. Otherwise the function requires any implicit or explicit tag used in the name; for the return type. Example:. .. code-block:: c++. namespace A {; inline namespace B __attribute__((abi_tag)) {; struct C { int x; };; }; }. A::C foo(); // gets mangled as: _Z3fooB1Bv (prettified as `foo[abi:B]()`). Required tags for a variable; ============================. A variable requires any implicit or explicit tag used in its type. Available tags; ==============. All tags used in the prefix and in the template arguments for a name are; available. Also, for functions, all tags from the <bare-function-type>; (which might include the return type for template functions) are available. For <local-name>s all active tags used in the local part (<function-; encoding>) are available, but not implicit tags which were not active. Implicit and explicit tags used in the <unqualified-name> for a function (as; in the type of a cast operator) are NOT available. E",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst:2298,Modifiability,variab,variable,2298," Example:. .. code-block:: c++. __attribute__((abi_tag(""test""))); void Func();; // gets mangled as: _Z4FuncB4testv (prettified as `Func[abi:test]()`). Active tags; ===========. A namespace does not have any active tags. For types (class / struct / union /; enum), the explicit tags are the active tags. For variables and functions, the active tags are the explicit tags plus any; ""required tags"" which are not in the ""available tags"" set:. .. code-block:: none. derived-tags := (required-tags - available-tags); active-tags := explicit-tags + derived-tags. Required tags for a function; ============================. If a function is used as a local scope for another name, and is part of; another function as local scope, it doesn't have any required tags. If a function is used as a local scope for a guard variable name, it doesn't; have any required tags. Otherwise the function requires any implicit or explicit tag used in the name; for the return type. Example:. .. code-block:: c++. namespace A {; inline namespace B __attribute__((abi_tag)) {; struct C { int x; };; }; }. A::C foo(); // gets mangled as: _Z3fooB1Bv (prettified as `foo[abi:B]()`). Required tags for a variable; ============================. A variable requires any implicit or explicit tag used in its type. Available tags; ==============. All tags used in the prefix and in the template arguments for a name are; available. Also, for functions, all tags from the <bare-function-type>; (which might include the return type for template functions) are available. For <local-name>s all active tags used in the local part (<function-; encoding>) are available, but not implicit tags which were not active. Implicit and explicit tags used in the <unqualified-name> for a function (as; in the type of a cast operator) are NOT available. Example: a cast operator to std::string (which is; std::__cxx11::basic_string<...>) will use 'cxx11' as an active tag, as it is; required from the return type `std::string` but not available.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst:2340,Modifiability,variab,variable,2340," Example:. .. code-block:: c++. __attribute__((abi_tag(""test""))); void Func();; // gets mangled as: _Z4FuncB4testv (prettified as `Func[abi:test]()`). Active tags; ===========. A namespace does not have any active tags. For types (class / struct / union /; enum), the explicit tags are the active tags. For variables and functions, the active tags are the explicit tags plus any; ""required tags"" which are not in the ""available tags"" set:. .. code-block:: none. derived-tags := (required-tags - available-tags); active-tags := explicit-tags + derived-tags. Required tags for a function; ============================. If a function is used as a local scope for another name, and is part of; another function as local scope, it doesn't have any required tags. If a function is used as a local scope for a guard variable name, it doesn't; have any required tags. Otherwise the function requires any implicit or explicit tag used in the name; for the return type. Example:. .. code-block:: c++. namespace A {; inline namespace B __attribute__((abi_tag)) {; struct C { int x; };; }; }. A::C foo(); // gets mangled as: _Z3fooB1Bv (prettified as `foo[abi:B]()`). Required tags for a variable; ============================. A variable requires any implicit or explicit tag used in its type. Available tags; ==============. All tags used in the prefix and in the template arguments for a name are; available. Also, for functions, all tags from the <bare-function-type>; (which might include the return type for template functions) are available. For <local-name>s all active tags used in the local part (<function-; encoding>) are available, but not implicit tags which were not active. Implicit and explicit tags used in the <unqualified-name> for a function (as; in the type of a cast operator) are NOT available. Example: a cast operator to std::string (which is; std::__cxx11::basic_string<...>) will use 'cxx11' as an active tag, as it is; required from the return type `std::string` but not available.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst:1178,Testability,test,test,1178,"here is no guarantee the following rules are correct, complete or make sense; in any way as they were determined empirically by experiments with gcc5. Declaration; ===========. ABI tags are declared in an abi_tag attribute and can be applied to a; function, variable, class or inline namespace declaration. The attribute takes; one or more strings (called tags); the order does not matter. See https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Attributes.html for; details. Tags on an inline namespace are called ""implicit tags"", all other tags are; ""explicit tags"". Mangling; ========. All tags that are ""active"" on an <unqualified-name> are emitted after the; <unqualified-name>, before <template-args> or <discriminator>, and are part of; the same <substitution> the <unqualified-name> is. They are mangled as:. .. code-block:: none. <abi-tags> ::= <abi-tag>* # sort by name; <abi-tag> ::= B <tag source-name>. Example:. .. code-block:: c++. __attribute__((abi_tag(""test""))); void Func();; // gets mangled as: _Z4FuncB4testv (prettified as `Func[abi:test]()`). Active tags; ===========. A namespace does not have any active tags. For types (class / struct / union /; enum), the explicit tags are the active tags. For variables and functions, the active tags are the explicit tags plus any; ""required tags"" which are not in the ""available tags"" set:. .. code-block:: none. derived-tags := (required-tags - available-tags); active-tags := explicit-tags + derived-tags. Required tags for a function; ============================. If a function is used as a local scope for another name, and is part of; another function as local scope, it doesn't have any required tags. If a function is used as a local scope for a guard variable name, it doesn't; have any required tags. Otherwise the function requires any implicit or explicit tag used in the name; for the return type. Example:. .. code-block:: c++. namespace A {; inline namespace B __attribute__((abi_tag)) {; struct C { int x; };; }; }. A::C foo()",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst:1262,Testability,test,test,1262,"here is no guarantee the following rules are correct, complete or make sense; in any way as they were determined empirically by experiments with gcc5. Declaration; ===========. ABI tags are declared in an abi_tag attribute and can be applied to a; function, variable, class or inline namespace declaration. The attribute takes; one or more strings (called tags); the order does not matter. See https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Attributes.html for; details. Tags on an inline namespace are called ""implicit tags"", all other tags are; ""explicit tags"". Mangling; ========. All tags that are ""active"" on an <unqualified-name> are emitted after the; <unqualified-name>, before <template-args> or <discriminator>, and are part of; the same <substitution> the <unqualified-name> is. They are mangled as:. .. code-block:: none. <abi-tags> ::= <abi-tag>* # sort by name; <abi-tag> ::= B <tag source-name>. Example:. .. code-block:: c++. __attribute__((abi_tag(""test""))); void Func();; // gets mangled as: _Z4FuncB4testv (prettified as `Func[abi:test]()`). Active tags; ===========. A namespace does not have any active tags. For types (class / struct / union /; enum), the explicit tags are the active tags. For variables and functions, the active tags are the explicit tags plus any; ""required tags"" which are not in the ""available tags"" set:. .. code-block:: none. derived-tags := (required-tags - available-tags); active-tags := explicit-tags + derived-tags. Required tags for a function; ============================. If a function is used as a local scope for another name, and is part of; another function as local scope, it doesn't have any required tags. If a function is used as a local scope for a guard variable name, it doesn't; have any required tags. Otherwise the function requires any implicit or explicit tag used in the name; for the return type. Example:. .. code-block:: c++. namespace A {; inline namespace B __attribute__((abi_tag)) {; struct C { int x; };; }; }. A::C foo()",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst:426,Availability,avail,available,426,"==============================================; JSON Compilation Database Format Specification; ==============================================. This document describes a format for specifying how to replay single; compilations independently of the build system. Background; ==========. Tools based on the C++ Abstract Syntax Tree need full information how to; parse a translation unit. Usually this information is implicitly; available in the build system, but running tools as part of the build; system is not necessarily the best solution:. - Build systems are inherently change driven, so running multiple tools; over the same code base without changing the code does not fit into; the architecture of many build systems.; - Figuring out whether things have changed is often an IO bound; process; this makes it hard to build low latency end user tools based; on the build system.; - Build systems are inherently sequential in the build graph, for; example due to generated source code. While tools that run; independently of the build still need the generated source code to; exist, running tools multiple times over unchanging source does not; require serialization of the runs according to the build dependency; graph. Supported Systems; =================. Clang has the ability to generate compilation database fragments via; ``-MJ argument <clang -MJ\<arg>>``. You can concatenate those; fragments together between ``[`` and ``]`` to create a compilation database. Currently `CMake <https://cmake.org>`_ (since 2.8.5) supports generation; of compilation databases for Unix Makefile builds (Ninja builds in the; works) with the option ``CMAKE_EXPORT_COMPILE_COMMANDS``. For projects on Linux, there is an alternative to intercept compiler; calls with a tool called `Bear <https://github.com/rizsotto/Bear>`_. `Bazel <https://bazel.build>`_ can export a compilation database via; `this extractor extension; <https://github.com/hedronvision/bazel-compile-commands-extractor>`_.; Bazel is otherwise",MatchSource.DOCS,interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst:4202,Availability,error,errors,4202,"d object are:. - **directory:** The working directory of the compilation. All paths; specified in the **command** or **file** fields must be either; absolute or relative to this directory.; - **file:** The main translation unit source processed by this; compilation step. This is used by tools as the key into the; compilation database. There can be multiple command objects for the; same file, for example if the same source file is compiled with; different configurations.; - **arguments:** The compile command argv as list of strings.; This should run the compilation step for the translation unit ``file``.; ``arguments[0]`` should be the executable name, such as ``clang++``.; Arguments should not be escaped, but ready to pass to ``execvp()``.; - **command:** The compile command as a single shell-escaped string.; Arguments may be shell quoted and escaped following platform conventions,; with '``""``' and '``\``' being the only special characters. Shell expansion; is not supported. Either **arguments** or **command** is required. **arguments** is preferred,; as shell (un)escaping is a possible source of errors.; - **output:** The name of the output created by this compilation step.; This field is optional. It can be used to distinguish different processing; modes of the same input file. Build System Integration; ========================. The convention is to name the file compile\_commands.json and put it at; the top of the build directory. Clang tools are pointed to the top of; the build directory to detect the file and use the compilation database; to parse C++ code in the source tree. Alternatives; ============; For simple projects, Clang tools also recognize a ``compile_flags.txt`` file.; This should contain one argument per line. The same flags will be used to; compile any file. Example:. ::. -xc++; -I; libwidget/include/. Here ``-I libwidget/include`` is two arguments, and so becomes two lines.; Paths are relative to the directory containing ``compile_flags.txt``.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst:3546,Deployability,configurat,configurations,3546,"is compiled in the project. Each command object contains the translation unit's main file, the; working directory of the compile run and the actual compile command. Example:. ::. [; { ""directory"": ""/home/user/llvm/build"",; ""arguments"": [""/usr/bin/clang++"", ""-Irelative"", ""-DSOMEDEF=With spaces, quotes and \\-es."", ""-c"", ""-o"", ""file.o"", ""file.cc""],; ""file"": ""file.cc"" },. { ""directory"": ""/home/user/llvm/build"",; ""command"": ""/usr/bin/clang++ -Irelative -DSOMEDEF=\""With spaces, quotes and \\-es.\"" -c -o file.o file.cc"",; ""file"": ""file2.cc"" },. ...; ]. The contracts for each field in the command object are:. - **directory:** The working directory of the compilation. All paths; specified in the **command** or **file** fields must be either; absolute or relative to this directory.; - **file:** The main translation unit source processed by this; compilation step. This is used by tools as the key into the; compilation database. There can be multiple command objects for the; same file, for example if the same source file is compiled with; different configurations.; - **arguments:** The compile command argv as list of strings.; This should run the compilation step for the translation unit ``file``.; ``arguments[0]`` should be the executable name, such as ``clang++``.; Arguments should not be escaped, but ready to pass to ``execvp()``.; - **command:** The compile command as a single shell-escaped string.; Arguments may be shell quoted and escaped following platform conventions,; with '``""``' and '``\``' being the only special characters. Shell expansion; is not supported. Either **arguments** or **command** is required. **arguments** is preferred,; as shell (un)escaping is a possible source of errors.; - **output:** The name of the output created by this compilation step.; This field is optional. It can be used to distinguish different processing; modes of the same input file. Build System Integration; ========================. The convention is to name the file compile\_command",MatchSource.DOCS,interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst:1205,Integrability,depend,dependency,1205,"=====================================. This document describes a format for specifying how to replay single; compilations independently of the build system. Background; ==========. Tools based on the C++ Abstract Syntax Tree need full information how to; parse a translation unit. Usually this information is implicitly; available in the build system, but running tools as part of the build; system is not necessarily the best solution:. - Build systems are inherently change driven, so running multiple tools; over the same code base without changing the code does not fit into; the architecture of many build systems.; - Figuring out whether things have changed is often an IO bound; process; this makes it hard to build low latency end user tools based; on the build system.; - Build systems are inherently sequential in the build graph, for; example due to generated source code. While tools that run; independently of the build still need the generated source code to; exist, running tools multiple times over unchanging source does not; require serialization of the runs according to the build dependency; graph. Supported Systems; =================. Clang has the ability to generate compilation database fragments via; ``-MJ argument <clang -MJ\<arg>>``. You can concatenate those; fragments together between ``[`` and ``]`` to create a compilation database. Currently `CMake <https://cmake.org>`_ (since 2.8.5) supports generation; of compilation databases for Unix Makefile builds (Ninja builds in the; works) with the option ``CMAKE_EXPORT_COMPILE_COMMANDS``. For projects on Linux, there is an alternative to intercept compiler; calls with a tool called `Bear <https://github.com/rizsotto/Bear>`_. `Bazel <https://bazel.build>`_ can export a compilation database via; `this extractor extension; <https://github.com/hedronvision/bazel-compile-commands-extractor>`_.; Bazel is otherwise resistant to Bear and other compiler-intercept; techniques. Clang's tooling interface supports reading c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst:2078,Integrability,interface,interface,2078,"nchanging source does not; require serialization of the runs according to the build dependency; graph. Supported Systems; =================. Clang has the ability to generate compilation database fragments via; ``-MJ argument <clang -MJ\<arg>>``. You can concatenate those; fragments together between ``[`` and ``]`` to create a compilation database. Currently `CMake <https://cmake.org>`_ (since 2.8.5) supports generation; of compilation databases for Unix Makefile builds (Ninja builds in the; works) with the option ``CMAKE_EXPORT_COMPILE_COMMANDS``. For projects on Linux, there is an alternative to intercept compiler; calls with a tool called `Bear <https://github.com/rizsotto/Bear>`_. `Bazel <https://bazel.build>`_ can export a compilation database via; `this extractor extension; <https://github.com/hedronvision/bazel-compile-commands-extractor>`_.; Bazel is otherwise resistant to Bear and other compiler-intercept; techniques. Clang's tooling interface supports reading compilation databases; see; the :doc:`LibTooling documentation <LibTooling>`. libclang and its; python bindings also support this (since clang 3.2); see; `CXCompilationDatabase.h </doxygen/group__COMPILATIONDB.html>`_. Format; ======. A compilation database is a JSON file, which consist of an array of; ""command objects"", where each command object specifies one way a; translation unit is compiled in the project. Each command object contains the translation unit's main file, the; working directory of the compile run and the actual compile command. Example:. ::. [; { ""directory"": ""/home/user/llvm/build"",; ""arguments"": [""/usr/bin/clang++"", ""-Irelative"", ""-DSOMEDEF=With spaces, quotes and \\-es."", ""-c"", ""-o"", ""file.o"", ""file.cc""],; ""file"": ""file.cc"" },. { ""directory"": ""/home/user/llvm/build"",; ""command"": ""/usr/bin/clang++ -Irelative -DSOMEDEF=\""With spaces, quotes and \\-es.\"" -c -o file.o file.cc"",; ""file"": ""file2.cc"" },. ...; ]. The contracts for each field in the command object are:. - **directory:** The",MatchSource.DOCS,interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst:3049,Integrability,contract,contracts,3049,"oling interface supports reading compilation databases; see; the :doc:`LibTooling documentation <LibTooling>`. libclang and its; python bindings also support this (since clang 3.2); see; `CXCompilationDatabase.h </doxygen/group__COMPILATIONDB.html>`_. Format; ======. A compilation database is a JSON file, which consist of an array of; ""command objects"", where each command object specifies one way a; translation unit is compiled in the project. Each command object contains the translation unit's main file, the; working directory of the compile run and the actual compile command. Example:. ::. [; { ""directory"": ""/home/user/llvm/build"",; ""arguments"": [""/usr/bin/clang++"", ""-Irelative"", ""-DSOMEDEF=With spaces, quotes and \\-es."", ""-c"", ""-o"", ""file.o"", ""file.cc""],; ""file"": ""file.cc"" },. { ""directory"": ""/home/user/llvm/build"",; ""command"": ""/usr/bin/clang++ -Irelative -DSOMEDEF=\""With spaces, quotes and \\-es.\"" -c -o file.o file.cc"",; ""file"": ""file2.cc"" },. ...; ]. The contracts for each field in the command object are:. - **directory:** The working directory of the compilation. All paths; specified in the **command** or **file** fields must be either; absolute or relative to this directory.; - **file:** The main translation unit source processed by this; compilation step. This is used by tools as the key into the; compilation database. There can be multiple command objects for the; same file, for example if the same source file is compiled with; different configurations.; - **arguments:** The compile command argv as list of strings.; This should run the compilation step for the translation unit ``file``.; ``arguments[0]`` should be the executable name, such as ``clang++``.; Arguments should not be escaped, but ready to pass to ``execvp()``.; - **command:** The compile command as a single shell-escaped string.; Arguments may be shell quoted and escaped following platform conventions,; with '``""``' and '``\``' being the only special characters. Shell expansion; is not suppor",MatchSource.DOCS,interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst:3546,Modifiability,config,configurations,3546,"is compiled in the project. Each command object contains the translation unit's main file, the; working directory of the compile run and the actual compile command. Example:. ::. [; { ""directory"": ""/home/user/llvm/build"",; ""arguments"": [""/usr/bin/clang++"", ""-Irelative"", ""-DSOMEDEF=With spaces, quotes and \\-es."", ""-c"", ""-o"", ""file.o"", ""file.cc""],; ""file"": ""file.cc"" },. { ""directory"": ""/home/user/llvm/build"",; ""command"": ""/usr/bin/clang++ -Irelative -DSOMEDEF=\""With spaces, quotes and \\-es.\"" -c -o file.o file.cc"",; ""file"": ""file2.cc"" },. ...; ]. The contracts for each field in the command object are:. - **directory:** The working directory of the compilation. All paths; specified in the **command** or **file** fields must be either; absolute or relative to this directory.; - **file:** The main translation unit source processed by this; compilation step. This is used by tools as the key into the; compilation database. There can be multiple command objects for the; same file, for example if the same source file is compiled with; different configurations.; - **arguments:** The compile command argv as list of strings.; This should run the compilation step for the translation unit ``file``.; ``arguments[0]`` should be the executable name, such as ``clang++``.; Arguments should not be escaped, but ready to pass to ``execvp()``.; - **command:** The compile command as a single shell-escaped string.; Arguments may be shell quoted and escaped following platform conventions,; with '``""``' and '``\``' being the only special characters. Shell expansion; is not supported. Either **arguments** or **command** is required. **arguments** is preferred,; as shell (un)escaping is a possible source of errors.; - **output:** The name of the output created by this compilation step.; This field is optional. It can be used to distinguish different processing; modes of the same input file. Build System Integration; ========================. The convention is to name the file compile\_command",MatchSource.DOCS,interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst:832,Performance,latency,latency,832,"==============================================; JSON Compilation Database Format Specification; ==============================================. This document describes a format for specifying how to replay single; compilations independently of the build system. Background; ==========. Tools based on the C++ Abstract Syntax Tree need full information how to; parse a translation unit. Usually this information is implicitly; available in the build system, but running tools as part of the build; system is not necessarily the best solution:. - Build systems are inherently change driven, so running multiple tools; over the same code base without changing the code does not fit into; the architecture of many build systems.; - Figuring out whether things have changed is often an IO bound; process; this makes it hard to build low latency end user tools based; on the build system.; - Build systems are inherently sequential in the build graph, for; example due to generated source code. While tools that run; independently of the build still need the generated source code to; exist, running tools multiple times over unchanging source does not; require serialization of the runs according to the build dependency; graph. Supported Systems; =================. Clang has the ability to generate compilation database fragments via; ``-MJ argument <clang -MJ\<arg>>``. You can concatenate those; fragments together between ``[`` and ``]`` to create a compilation database. Currently `CMake <https://cmake.org>`_ (since 2.8.5) supports generation; of compilation databases for Unix Makefile builds (Ninja builds in the; works) with the option ``CMAKE_EXPORT_COMPILE_COMMANDS``. For projects on Linux, there is an alternative to intercept compiler; calls with a tool called `Bear <https://github.com/rizsotto/Bear>`_. `Bazel <https://bazel.build>`_ can export a compilation database via; `this extractor extension; <https://github.com/hedronvision/bazel-compile-commands-extractor>`_.; Bazel is otherwise",MatchSource.DOCS,interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst:4608,Safety,detect,detect,4608,"d object are:. - **directory:** The working directory of the compilation. All paths; specified in the **command** or **file** fields must be either; absolute or relative to this directory.; - **file:** The main translation unit source processed by this; compilation step. This is used by tools as the key into the; compilation database. There can be multiple command objects for the; same file, for example if the same source file is compiled with; different configurations.; - **arguments:** The compile command argv as list of strings.; This should run the compilation step for the translation unit ``file``.; ``arguments[0]`` should be the executable name, such as ``clang++``.; Arguments should not be escaped, but ready to pass to ``execvp()``.; - **command:** The compile command as a single shell-escaped string.; Arguments may be shell quoted and escaped following platform conventions,; with '``""``' and '``\``' being the only special characters. Shell expansion; is not supported. Either **arguments** or **command** is required. **arguments** is preferred,; as shell (un)escaping is a possible source of errors.; - **output:** The name of the output created by this compilation step.; This field is optional. It can be used to distinguish different processing; modes of the same input file. Build System Integration; ========================. The convention is to name the file compile\_commands.json and put it at; the top of the build directory. Clang tools are pointed to the top of; the build directory to detect the file and use the compilation database; to parse C++ code in the source tree. Alternatives; ============; For simple projects, Clang tools also recognize a ``compile_flags.txt`` file.; This should contain one argument per line. The same flags will be used to; compile any file. Example:. ::. -xc++; -I; libwidget/include/. Here ``-I libwidget/include`` is two arguments, and so becomes two lines.; Paths are relative to the directory containing ``compile_flags.txt``.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst:4728,Usability,simpl,simple,4728,"d object are:. - **directory:** The working directory of the compilation. All paths; specified in the **command** or **file** fields must be either; absolute or relative to this directory.; - **file:** The main translation unit source processed by this; compilation step. This is used by tools as the key into the; compilation database. There can be multiple command objects for the; same file, for example if the same source file is compiled with; different configurations.; - **arguments:** The compile command argv as list of strings.; This should run the compilation step for the translation unit ``file``.; ``arguments[0]`` should be the executable name, such as ``clang++``.; Arguments should not be escaped, but ready to pass to ``execvp()``.; - **command:** The compile command as a single shell-escaped string.; Arguments may be shell quoted and escaped following platform conventions,; with '``""``' and '``\``' being the only special characters. Shell expansion; is not supported. Either **arguments** or **command** is required. **arguments** is preferred,; as shell (un)escaping is a possible source of errors.; - **output:** The name of the output created by this compilation step.; This field is optional. It can be used to distinguish different processing; modes of the same input file. Build System Integration; ========================. The convention is to name the file compile\_commands.json and put it at; the top of the build directory. Clang tools are pointed to the top of; the build directory to detect the file and use the compilation database; to parse C++ code in the source tree. Alternatives; ============; For simple projects, Clang tools also recognize a ``compile_flags.txt`` file.; This should contain one argument per line. The same flags will be used to; compile any file. Example:. ::. -xc++; -I; libwidget/include/. Here ``-I libwidget/include`` is two arguments, and so becomes two lines.; Paths are relative to the directory containing ``compile_flags.txt``.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:4476,Availability,error,errors,4476,"lang compilers.; #endif; #ifndef __has_extension; #define __has_extension __has_feature // Compatibility with pre-3.0 compilers.; #endif. ...; #if __has_feature(cxx_rvalue_references); // This code will only be compiled with the -std=c++11 and -std=gnu++11; // options, because rvalue references are only standardized in C++11.; #endif. #if __has_extension(cxx_rvalue_references); // This code will be compiled with the -std=c++11, -std=gnu++11, -std=c++98; // and -std=gnu++98 options, because rvalue references are supported as a; // language extension in C++98.; #endif. .. _langext-has-feature-back-compat:. For backward compatibility, ``__has_feature`` can also be used to test; for support for non-standardized features, i.e. features not prefixed ``c_``,; ``cxx_`` or ``objc_``. Another use of ``__has_feature`` is to check for compiler features not related; to the language standard, such as e.g. :doc:`AddressSanitizer; <AddressSanitizer>`. If the ``-pedantic-errors`` option is given, ``__has_extension`` is equivalent; to ``__has_feature``. The feature tag is described along with the language feature below. The feature name or extension name can also be specified with a preceding and; following ``__`` (double underscore) to avoid interference from a macro with; the same name. For instance, ``__cxx_rvalue_references__`` can be used instead; of ``cxx_rvalue_references``. ``__has_cpp_attribute``; -----------------------. This function-like macro is available in C++20 by default, and is provided as an; extension in earlier language standards. It takes a single argument that is the; name of a double-square-bracket-style attribute. The argument can either be a; single identifier or a scoped identifier. If the attribute is supported, a; nonzero value is returned. If the attribute is a standards-based attribute, this; macro returns a nonzero value based on the year and month in which the attribute; was voted into the working draft. See `WG21 SD-6; <https://isocpp.org/std/standin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:4972,Availability,avail,available,4972,"alue references are supported as a; // language extension in C++98.; #endif. .. _langext-has-feature-back-compat:. For backward compatibility, ``__has_feature`` can also be used to test; for support for non-standardized features, i.e. features not prefixed ``c_``,; ``cxx_`` or ``objc_``. Another use of ``__has_feature`` is to check for compiler features not related; to the language standard, such as e.g. :doc:`AddressSanitizer; <AddressSanitizer>`. If the ``-pedantic-errors`` option is given, ``__has_extension`` is equivalent; to ``__has_feature``. The feature tag is described along with the language feature below. The feature name or extension name can also be specified with a preceding and; following ``__`` (double underscore) to avoid interference from a macro with; the same name. For instance, ``__cxx_rvalue_references__`` can be used instead; of ``cxx_rvalue_references``. ``__has_cpp_attribute``; -----------------------. This function-like macro is available in C++20 by default, and is provided as an; extension in earlier language standards. It takes a single argument that is the; name of a double-square-bracket-style attribute. The argument can either be a; single identifier or a scoped identifier. If the attribute is supported, a; nonzero value is returned. If the attribute is a standards-based attribute, this; macro returns a nonzero value based on the year and month in which the attribute; was voted into the working draft. See `WG21 SD-6; <https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations>`_; for the list of values returned for standards-based attributes. If the attribute; is not supported by the current compilation target, this macro evaluates to 0.; It can be used like this:. .. code-block:: c++. #ifndef __has_cpp_attribute // For backwards compatibility; #define __has_cpp_attribute(x) 0; #endif. ...; #if __has_cpp_attribute(clang::fallthrough); #define FALLTHROUGH [[clang::fallthrough]]; #else; #define FALLTHROUGH; #endif; .",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:16577,Availability,error,error,16577,"c++. typedef __attribute__((neon_vector_type(8))) int8_t int8x8_t;; typedef __attribute__((neon_polyvector_type(16))) poly8_t poly8x16_t;. int8x8_t foo(int8x8_t a) {; int8x8_t v;; v = a;; return v;; }. GCC vector types are created using the ``vector_size(N)`` attribute. The; argument ``N`` specifies the number of bytes that will be allocated for an; object of this type. The size has to be multiple of the size of the vector; element type. For example:. .. code-block:: c++. // OK: This declares a vector type with four 'int' elements; typedef int int4 __attribute__((vector_size(4 * sizeof(int))));. // ERROR: '11' is not a multiple of sizeof(int); typedef int int_impossible __attribute__((vector_size(11)));. int4 foo(int4 a) {; int4 v;; v = a;; return v;; }. Boolean Vectors; ---------------. Clang also supports the ext_vector_type attribute with boolean element types in; C and C++. For example:. .. code-block:: c++. // legal for Clang, error for GCC:; typedef bool bool4 __attribute__((ext_vector_type(4)));; // Objects of bool4 type hold 8 bits, sizeof(bool4) == 1. bool4 foo(bool4 a) {; bool4 v;; v = a;; return v;; }. Boolean vectors are a Clang extension of the ext vector type. Boolean vectors; are intended, though not guaranteed, to map to vector mask registers. The size; parameter of a boolean vector type is the number of bits in the vector. The; boolean vector is dense and each bit in the boolean vector is one vector; element. The semantics of boolean vectors borrows from C bit-fields with the following; differences:. * Distinct boolean vectors are always distinct memory objects (there is no; packing).; * Only the operators `?:`, `!`, `~`, `|`, `&`, `^` and comparison are allowed on; boolean vectors.; * Casting a scalar bool value to a boolean vector type means broadcasting the; scalar value onto all lanes (same as general ext_vector_type).; * It is not possible to access or swizzle elements of a boolean vector; (different than general ext_vector_type). The size and a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:16895,Availability,mask,mask,16895,"g the ``vector_size(N)`` attribute. The; argument ``N`` specifies the number of bytes that will be allocated for an; object of this type. The size has to be multiple of the size of the vector; element type. For example:. .. code-block:: c++. // OK: This declares a vector type with four 'int' elements; typedef int int4 __attribute__((vector_size(4 * sizeof(int))));. // ERROR: '11' is not a multiple of sizeof(int); typedef int int_impossible __attribute__((vector_size(11)));. int4 foo(int4 a) {; int4 v;; v = a;; return v;; }. Boolean Vectors; ---------------. Clang also supports the ext_vector_type attribute with boolean element types in; C and C++. For example:. .. code-block:: c++. // legal for Clang, error for GCC:; typedef bool bool4 __attribute__((ext_vector_type(4)));; // Objects of bool4 type hold 8 bits, sizeof(bool4) == 1. bool4 foo(bool4 a) {; bool4 v;; v = a;; return v;; }. Boolean vectors are a Clang extension of the ext vector type. Boolean vectors; are intended, though not guaranteed, to map to vector mask registers. The size; parameter of a boolean vector type is the number of bits in the vector. The; boolean vector is dense and each bit in the boolean vector is one vector; element. The semantics of boolean vectors borrows from C bit-fields with the following; differences:. * Distinct boolean vectors are always distinct memory objects (there is no; packing).; * Only the operators `?:`, `!`, `~`, `|`, `&`, `^` and comparison are allowed on; boolean vectors.; * Casting a scalar bool value to a boolean vector type means broadcasting the; scalar value onto all lanes (same as general ext_vector_type).; * It is not possible to access or swizzle elements of a boolean vector; (different than general ext_vector_type). The size and alignment are both the number of bits rounded up to the next power; of two, but the alignment is at most the maximum vector alignment of the; target. Vector Literals; ---------------. Vector literals can be used to create vectors from a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:18767,Availability,error,error,18767,"ector Literals; ---------------. Vector literals can be used to create vectors from a set of scalars, or; vectors. Either parentheses or braces form can be used. In the parentheses; form the number of literal values specified must be one, i.e. referring to a; scalar value, or must match the size of the vector type being created. If a; single scalar literal value is specified, the scalar literal value will be; replicated to all the components of the vector type. In the brackets form any; number of literals can be specified. For example:. .. code-block:: c++. typedef int v4si __attribute__((__vector_size__(16)));; typedef float float4 __attribute__((ext_vector_type(4)));; typedef float float2 __attribute__((ext_vector_type(2)));. v4si vsi = (v4si){1, 2, 3, 4};; float4 vf = (float4)(1.0f, 2.0f, 3.0f, 4.0f);; vector int vi1 = (vector int)(1); // vi1 will be (1, 1, 1, 1).; vector int vi2 = (vector int){1}; // vi2 will be (1, 0, 0, 0).; vector int vi3 = (vector int)(1, 2); // error; vector int vi4 = (vector int){1, 2}; // vi4 will be (1, 2, 0, 0).; vector int vi5 = (vector int)(1, 2, 3, 4);; float4 vf = (float4)((float2)(1.0f, 2.0f), (float2)(3.0f, 4.0f));. Vector Operations; -----------------. The table below shows the support for each operation by vector extension. A; dash indicates that an operation is not accepted according to a corresponding; specification. ============================== ======= ======= ============= ======= =====; Operator OpenCL AltiVec GCC NEON SVE; ============================== ======= ======= ============= ======= =====; [] yes yes yes yes yes; unary operators +, -- yes yes yes yes yes; ++, -- -- yes yes yes no no; +,--,*,/,% yes yes yes yes yes; bitwise operators &,|,^,~ yes yes yes yes yes; >>,<< yes yes yes yes yes; !, &&, || yes -- yes yes yes; ==, !=, >, <, >=, <= yes yes yes yes yes; = yes yes yes yes yes; ?: [#]_ yes -- yes yes yes; sizeof yes yes yes yes yes [#]_; C-style cast yes yes yes no no; reinterpret_cast yes no yes no no; static",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:20232,Availability,avail,available,20232,"=; Operator OpenCL AltiVec GCC NEON SVE; ============================== ======= ======= ============= ======= =====; [] yes yes yes yes yes; unary operators +, -- yes yes yes yes yes; ++, -- -- yes yes yes no no; +,--,*,/,% yes yes yes yes yes; bitwise operators &,|,^,~ yes yes yes yes yes; >>,<< yes yes yes yes yes; !, &&, || yes -- yes yes yes; ==, !=, >, <, >=, <= yes yes yes yes yes; = yes yes yes yes yes; ?: [#]_ yes -- yes yes yes; sizeof yes yes yes yes yes [#]_; C-style cast yes yes yes no no; reinterpret_cast yes no yes no no; static_cast yes no yes no no; const_cast no no no no no; address &v[i] no no no [#]_ no no; ============================== ======= ======= ============= ======= =====. See also :ref:`langext-__builtin_shufflevector`, :ref:`langext-__builtin_convertvector`. .. [#] ternary operator(?:) has different behaviors depending on condition; operand's vector type. If the condition is a GNU vector (i.e. __vector_size__),; a NEON vector or an SVE vector, it's only available in C++ and uses normal bool; conversions (that is, != 0).; If it's an extension (OpenCL) vector, it's only available in C and OpenCL C.; And it selects base on signedness of the condition operands (OpenCL v1.1 s6.3.9).; .. [#] sizeof can only be used on vector length specific SVE types.; .. [#] Clang does not allow the address of an element to be taken while GCC; allows this. This is intentional for vectors with a boolean element type and; not implemented otherwise. Vector Builtins; ---------------. **Note: The implementation of vector builtins is work-in-progress and incomplete.**. In addition to the operators mentioned above, Clang provides a set of builtins; to perform additional operations on certain scalar and vector types. Let ``T`` be one of the following types:. * an integer type (as in C23 6.2.5p22), but excluding enumerated types and ``bool``; * the standard floating types float or double; * a half-precision floating point type, if one is supported on the target; * a v",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:20349,Availability,avail,available,20349,"===== =====; [] yes yes yes yes yes; unary operators +, -- yes yes yes yes yes; ++, -- -- yes yes yes no no; +,--,*,/,% yes yes yes yes yes; bitwise operators &,|,^,~ yes yes yes yes yes; >>,<< yes yes yes yes yes; !, &&, || yes -- yes yes yes; ==, !=, >, <, >=, <= yes yes yes yes yes; = yes yes yes yes yes; ?: [#]_ yes -- yes yes yes; sizeof yes yes yes yes yes [#]_; C-style cast yes yes yes no no; reinterpret_cast yes no yes no no; static_cast yes no yes no no; const_cast no no no no no; address &v[i] no no no [#]_ no no; ============================== ======= ======= ============= ======= =====. See also :ref:`langext-__builtin_shufflevector`, :ref:`langext-__builtin_convertvector`. .. [#] ternary operator(?:) has different behaviors depending on condition; operand's vector type. If the condition is a GNU vector (i.e. __vector_size__),; a NEON vector or an SVE vector, it's only available in C++ and uses normal bool; conversions (that is, != 0).; If it's an extension (OpenCL) vector, it's only available in C and OpenCL C.; And it selects base on signedness of the condition operands (OpenCL v1.1 s6.3.9).; .. [#] sizeof can only be used on vector length specific SVE types.; .. [#] Clang does not allow the address of an element to be taken while GCC; allows this. This is intentional for vectors with a boolean element type and; not implemented otherwise. Vector Builtins; ---------------. **Note: The implementation of vector builtins is work-in-progress and incomplete.**. In addition to the operators mentioned above, Clang provides a set of builtins; to perform additional operations on certain scalar and vector types. Let ``T`` be one of the following types:. * an integer type (as in C23 6.2.5p22), but excluding enumerated types and ``bool``; * the standard floating types float or double; * a half-precision floating point type, if one is supported on the target; * a vector type. For scalar types, consider the operation applied to a vector with a single element. *Vector",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:30850,Availability,avail,available,30850,"loating Point; =============================. Clang supports three half-precision (16-bit) floating point types:; ``__fp16``, ``_Float16`` and ``__bf16``. These types are supported; in all language modes, but their support differs between targets.; A target is said to have ""native support"" for a type if the target; processor offers instructions for directly performing basic arithmetic; on that type. In the absence of native support, a type can still be; supported if the compiler can emulate arithmetic on the type by promoting; to ``float``; see below for more information on this emulation. * ``__fp16`` is supported on all targets. The special semantics of this; type mean that no arithmetic is ever performed directly on ``__fp16`` values;; see below. * ``_Float16`` is supported on the following targets:. * 32-bit ARM (natively on some architecture versions); * 64-bit ARM (AArch64) (natively on ARMv8.2a and above); * AMDGPU (natively); * SPIR (natively); * X86 (if SSE2 is available; natively if AVX512-FP16 is also available); * RISC-V (natively if Zfh or Zhinx is available). * ``__bf16`` is supported on the following targets (currently never natively):. * 32-bit ARM; * 64-bit ARM (AArch64); * RISC-V; * X86 (when SSE2 is available). (For X86, SSE2 is available on 64-bit and all recent 32-bit processors.). ``__fp16`` and ``_Float16`` both use the binary16 format from IEEE; 754-2008, which provides a 5-bit exponent and an 11-bit significand; (counting the implicit leading 1). ``__bf16`` uses the `bfloat16; <https://en.wikipedia.org/wiki/Bfloat16_floating-point_format>`_ format,; which provides an 8-bit exponent and an 8-bit significand; this is the same; exponent range as `float`, just with greatly reduced precision. ``_Float16`` and ``__bf16`` follow the usual rules for arithmetic; floating-point types. Most importantly, this means that arithmetic operations; on operands of these types are formally performed in the type and produce; values of the type. ``__fp16`` does no",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:30893,Availability,avail,available,30893,"loating Point; =============================. Clang supports three half-precision (16-bit) floating point types:; ``__fp16``, ``_Float16`` and ``__bf16``. These types are supported; in all language modes, but their support differs between targets.; A target is said to have ""native support"" for a type if the target; processor offers instructions for directly performing basic arithmetic; on that type. In the absence of native support, a type can still be; supported if the compiler can emulate arithmetic on the type by promoting; to ``float``; see below for more information on this emulation. * ``__fp16`` is supported on all targets. The special semantics of this; type mean that no arithmetic is ever performed directly on ``__fp16`` values;; see below. * ``_Float16`` is supported on the following targets:. * 32-bit ARM (natively on some architecture versions); * 64-bit ARM (AArch64) (natively on ARMv8.2a and above); * AMDGPU (natively); * SPIR (natively); * X86 (if SSE2 is available; natively if AVX512-FP16 is also available); * RISC-V (natively if Zfh or Zhinx is available). * ``__bf16`` is supported on the following targets (currently never natively):. * 32-bit ARM; * 64-bit ARM (AArch64); * RISC-V; * X86 (when SSE2 is available). (For X86, SSE2 is available on 64-bit and all recent 32-bit processors.). ``__fp16`` and ``_Float16`` both use the binary16 format from IEEE; 754-2008, which provides a 5-bit exponent and an 11-bit significand; (counting the implicit leading 1). ``__bf16`` uses the `bfloat16; <https://en.wikipedia.org/wiki/Bfloat16_floating-point_format>`_ format,; which provides an 8-bit exponent and an 8-bit significand; this is the same; exponent range as `float`, just with greatly reduced precision. ``_Float16`` and ``__bf16`` follow the usual rules for arithmetic; floating-point types. Most importantly, this means that arithmetic operations; on operands of these types are formally performed in the type and produce; values of the type. ``__fp16`` does no",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:30943,Availability,avail,available,30943,"loating Point; =============================. Clang supports three half-precision (16-bit) floating point types:; ``__fp16``, ``_Float16`` and ``__bf16``. These types are supported; in all language modes, but their support differs between targets.; A target is said to have ""native support"" for a type if the target; processor offers instructions for directly performing basic arithmetic; on that type. In the absence of native support, a type can still be; supported if the compiler can emulate arithmetic on the type by promoting; to ``float``; see below for more information on this emulation. * ``__fp16`` is supported on all targets. The special semantics of this; type mean that no arithmetic is ever performed directly on ``__fp16`` values;; see below. * ``_Float16`` is supported on the following targets:. * 32-bit ARM (natively on some architecture versions); * 64-bit ARM (AArch64) (natively on ARMv8.2a and above); * AMDGPU (natively); * SPIR (natively); * X86 (if SSE2 is available; natively if AVX512-FP16 is also available); * RISC-V (natively if Zfh or Zhinx is available). * ``__bf16`` is supported on the following targets (currently never natively):. * 32-bit ARM; * 64-bit ARM (AArch64); * RISC-V; * X86 (when SSE2 is available). (For X86, SSE2 is available on 64-bit and all recent 32-bit processors.). ``__fp16`` and ``_Float16`` both use the binary16 format from IEEE; 754-2008, which provides a 5-bit exponent and an 11-bit significand; (counting the implicit leading 1). ``__bf16`` uses the `bfloat16; <https://en.wikipedia.org/wiki/Bfloat16_floating-point_format>`_ format,; which provides an 8-bit exponent and an 8-bit significand; this is the same; exponent range as `float`, just with greatly reduced precision. ``_Float16`` and ``__bf16`` follow the usual rules for arithmetic; floating-point types. Most importantly, this means that arithmetic operations; on operands of these types are formally performed in the type and produce; values of the type. ``__fp16`` does no",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:31103,Availability,avail,available,31103,"their support differs between targets.; A target is said to have ""native support"" for a type if the target; processor offers instructions for directly performing basic arithmetic; on that type. In the absence of native support, a type can still be; supported if the compiler can emulate arithmetic on the type by promoting; to ``float``; see below for more information on this emulation. * ``__fp16`` is supported on all targets. The special semantics of this; type mean that no arithmetic is ever performed directly on ``__fp16`` values;; see below. * ``_Float16`` is supported on the following targets:. * 32-bit ARM (natively on some architecture versions); * 64-bit ARM (AArch64) (natively on ARMv8.2a and above); * AMDGPU (natively); * SPIR (natively); * X86 (if SSE2 is available; natively if AVX512-FP16 is also available); * RISC-V (natively if Zfh or Zhinx is available). * ``__bf16`` is supported on the following targets (currently never natively):. * 32-bit ARM; * 64-bit ARM (AArch64); * RISC-V; * X86 (when SSE2 is available). (For X86, SSE2 is available on 64-bit and all recent 32-bit processors.). ``__fp16`` and ``_Float16`` both use the binary16 format from IEEE; 754-2008, which provides a 5-bit exponent and an 11-bit significand; (counting the implicit leading 1). ``__bf16`` uses the `bfloat16; <https://en.wikipedia.org/wiki/Bfloat16_floating-point_format>`_ format,; which provides an 8-bit exponent and an 8-bit significand; this is the same; exponent range as `float`, just with greatly reduced precision. ``_Float16`` and ``__bf16`` follow the usual rules for arithmetic; floating-point types. Most importantly, this means that arithmetic operations; on operands of these types are formally performed in the type and produce; values of the type. ``__fp16`` does not follow those rules: most operations; immediately promote operands of type ``__fp16`` to ``float``, and so; arithmetic operations are defined to be performed in ``float`` and so result in; a value of type ``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:31133,Availability,avail,available,31133,"port"" for a type if the target; processor offers instructions for directly performing basic arithmetic; on that type. In the absence of native support, a type can still be; supported if the compiler can emulate arithmetic on the type by promoting; to ``float``; see below for more information on this emulation. * ``__fp16`` is supported on all targets. The special semantics of this; type mean that no arithmetic is ever performed directly on ``__fp16`` values;; see below. * ``_Float16`` is supported on the following targets:. * 32-bit ARM (natively on some architecture versions); * 64-bit ARM (AArch64) (natively on ARMv8.2a and above); * AMDGPU (natively); * SPIR (natively); * X86 (if SSE2 is available; natively if AVX512-FP16 is also available); * RISC-V (natively if Zfh or Zhinx is available). * ``__bf16`` is supported on the following targets (currently never natively):. * 32-bit ARM; * 64-bit ARM (AArch64); * RISC-V; * X86 (when SSE2 is available). (For X86, SSE2 is available on 64-bit and all recent 32-bit processors.). ``__fp16`` and ``_Float16`` both use the binary16 format from IEEE; 754-2008, which provides a 5-bit exponent and an 11-bit significand; (counting the implicit leading 1). ``__bf16`` uses the `bfloat16; <https://en.wikipedia.org/wiki/Bfloat16_floating-point_format>`_ format,; which provides an 8-bit exponent and an 8-bit significand; this is the same; exponent range as `float`, just with greatly reduced precision. ``_Float16`` and ``__bf16`` follow the usual rules for arithmetic; floating-point types. Most importantly, this means that arithmetic operations; on operands of these types are formally performed in the type and produce; values of the type. ``__fp16`` does not follow those rules: most operations; immediately promote operands of type ``__fp16`` to ``float``, and so; arithmetic operations are defined to be performed in ``float`` and so result in; a value of type ``float`` (unless further promoted because of other operands).; See below for ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:38846,Availability,avail,available,38846,"the manner in which the; compiler changes warning behavior for system headers. Framework developers can opt-in to this mechanism by creating a; ""``.system_framework``"" file at the top-level of their framework. That is, the; framework should have contents like:. .. code-block:: none. .../TestFramework.framework; .../TestFramework.framework/.system_framework; .../TestFramework.framework/Headers; .../TestFramework.framework/Headers/TestFramework.h; ... Clang will treat the presence of this file as an indicator that the framework; should be treated as a system framework, regardless of how it was found in the; framework search path. For consistency, we recommend that such files never be; included in installed versions of the framework. Checks for Standard Language Features; =====================================. The ``__has_feature`` macro can be used to query if certain standard language; features are enabled. The ``__has_extension`` macro can be used to query if; language features are available as an extension when compiling for a standard; which does not provide them. The features which can be tested are listed here. Since Clang 3.4, the C++ SD-6 feature test macros are also supported.; These are macros with names of the form ``__cpp_<feature_name>``, and are; intended to be a portable way to query the supported features of the compiler.; See `the C++ status page <https://clang.llvm.org/cxx_status.html#ts>`_ for; information on the version of SD-6 supported by each Clang release, and the; macros provided by that revision of the recommendations. C++98; -----. The features listed below are part of the C++98 standard. These features are; enabled by default when compiling C++ code. C++ exceptions; ^^^^^^^^^^^^^^. Use ``__has_feature(cxx_exceptions)`` to determine if C++ exceptions have been; enabled. For example, compiling code with ``-fno-exceptions`` disables C++; exceptions. C++ RTTI; ^^^^^^^^. Use ``__has_feature(cxx_rtti)`` to determine if C++ RTTI has been enabled. F",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:40330,Availability,error,errors,40330,"s.html#ts>`_ for; information on the version of SD-6 supported by each Clang release, and the; macros provided by that revision of the recommendations. C++98; -----. The features listed below are part of the C++98 standard. These features are; enabled by default when compiling C++ code. C++ exceptions; ^^^^^^^^^^^^^^. Use ``__has_feature(cxx_exceptions)`` to determine if C++ exceptions have been; enabled. For example, compiling code with ``-fno-exceptions`` disables C++; exceptions. C++ RTTI; ^^^^^^^^. Use ``__has_feature(cxx_rtti)`` to determine if C++ RTTI has been enabled. For; example, compiling code with ``-fno-rtti`` disables the use of RTTI. C++11; -----. The features listed below are part of the C++11 standard. As a result, all; these features are enabled with the ``-std=c++11`` or ``-std=gnu++11`` option; when compiling C++ code. C++11 SFINAE includes access control; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_access_control_sfinae)`` or; ``__has_extension(cxx_access_control_sfinae)`` to determine whether; access-control errors (e.g., calling a private constructor) are considered to; be template argument deduction errors (aka SFINAE errors), per `C++ DR1170; <http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1170>`_. C++11 alias templates; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_alias_templates)`` or; ``__has_extension(cxx_alias_templates)`` to determine if support for C++11's; alias declarations and alias templates is enabled. C++11 alignment specifiers; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_alignas)`` or ``__has_extension(cxx_alignas)`` to; determine if support for alignment specifiers using ``alignas`` is enabled. Use ``__has_feature(cxx_alignof)`` or ``__has_extension(cxx_alignof)`` to; determine if support for the ``alignof`` keyword is enabled. C++11 attributes; ^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_attributes)`` or ``__has_extension(cxx_attributes)`` to; determine if support for attribute parsing ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:40425,Availability,error,errors,40425,"ions. C++98; -----. The features listed below are part of the C++98 standard. These features are; enabled by default when compiling C++ code. C++ exceptions; ^^^^^^^^^^^^^^. Use ``__has_feature(cxx_exceptions)`` to determine if C++ exceptions have been; enabled. For example, compiling code with ``-fno-exceptions`` disables C++; exceptions. C++ RTTI; ^^^^^^^^. Use ``__has_feature(cxx_rtti)`` to determine if C++ RTTI has been enabled. For; example, compiling code with ``-fno-rtti`` disables the use of RTTI. C++11; -----. The features listed below are part of the C++11 standard. As a result, all; these features are enabled with the ``-std=c++11`` or ``-std=gnu++11`` option; when compiling C++ code. C++11 SFINAE includes access control; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_access_control_sfinae)`` or; ``__has_extension(cxx_access_control_sfinae)`` to determine whether; access-control errors (e.g., calling a private constructor) are considered to; be template argument deduction errors (aka SFINAE errors), per `C++ DR1170; <http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1170>`_. C++11 alias templates; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_alias_templates)`` or; ``__has_extension(cxx_alias_templates)`` to determine if support for C++11's; alias declarations and alias templates is enabled. C++11 alignment specifiers; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_alignas)`` or ``__has_extension(cxx_alignas)`` to; determine if support for alignment specifiers using ``alignas`` is enabled. Use ``__has_feature(cxx_alignof)`` or ``__has_extension(cxx_alignof)`` to; determine if support for the ``alignof`` keyword is enabled. C++11 attributes; ^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_attributes)`` or ``__has_extension(cxx_attributes)`` to; determine if support for attribute parsing with C++11's square bracket notation; is enabled. C++11 generalized constant expressions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:40444,Availability,error,errors,40444,"ions. C++98; -----. The features listed below are part of the C++98 standard. These features are; enabled by default when compiling C++ code. C++ exceptions; ^^^^^^^^^^^^^^. Use ``__has_feature(cxx_exceptions)`` to determine if C++ exceptions have been; enabled. For example, compiling code with ``-fno-exceptions`` disables C++; exceptions. C++ RTTI; ^^^^^^^^. Use ``__has_feature(cxx_rtti)`` to determine if C++ RTTI has been enabled. For; example, compiling code with ``-fno-rtti`` disables the use of RTTI. C++11; -----. The features listed below are part of the C++11 standard. As a result, all; these features are enabled with the ``-std=c++11`` or ``-std=gnu++11`` option; when compiling C++ code. C++11 SFINAE includes access control; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_access_control_sfinae)`` or; ``__has_extension(cxx_access_control_sfinae)`` to determine whether; access-control errors (e.g., calling a private constructor) are considered to; be template argument deduction errors (aka SFINAE errors), per `C++ DR1170; <http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1170>`_. C++11 alias templates; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_alias_templates)`` or; ``__has_extension(cxx_alias_templates)`` to determine if support for C++11's; alias declarations and alias templates is enabled. C++11 alignment specifiers; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_alignas)`` or ``__has_extension(cxx_alignas)`` to; determine if support for alignment specifiers using ``alignas`` is enabled. Use ``__has_feature(cxx_alignof)`` or ``__has_extension(cxx_alignof)`` to; determine if support for the ``alignof`` keyword is enabled. C++11 attributes; ^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_attributes)`` or ``__has_extension(cxx_attributes)`` to; determine if support for attribute parsing with C++11's square bracket notation; is enabled. C++11 generalized constant expressions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:51541,Availability,avail,available,51541,"^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_return_type_deduction)`` or; ``__has_extension(cxx_return_type_deduction)`` to determine if support; for return type deduction for functions (using ``auto`` as a return type); is enabled. C++14 runtime-sized arrays; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_runtime_array)`` or; ``__has_extension(cxx_runtime_array)`` to determine if support; for arrays of runtime bound (a restricted form of variable-length arrays); is enabled.; Clang's implementation of this feature is incomplete. C++14 variable templates; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_variable_templates)`` or; ``__has_extension(cxx_variable_templates)`` to determine if support for; templated variable declarations is enabled. C11; ---. The features listed below are part of the C11 standard. As a result, all these; features are enabled with the ``-std=c11`` or ``-std=gnu11`` option when; compiling C code. Additionally, because these features are all; backward-compatible, they are available as extensions in all language modes. C11 alignment specifiers; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_alignas)`` or ``__has_extension(c_alignas)`` to determine; if support for alignment specifiers using ``_Alignas`` is enabled. Use ``__has_feature(c_alignof)`` or ``__has_extension(c_alignof)`` to determine; if support for the ``_Alignof`` keyword is enabled. C11 atomic operations; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_atomic)`` or ``__has_extension(c_atomic)`` to determine; if support for atomic types using ``_Atomic`` is enabled. Clang also provides; :ref:`a set of builtins <langext-__c11_atomic>` which can be used to implement; the ``<stdatomic.h>`` operations on ``_Atomic`` types. Use; ``__has_include(<stdatomic.h>)`` to determine if C11's ``<stdatomic.h>`` header; is available. Clang will use the system's ``<stdatomic.h>`` header when one is available, and; will otherwise use its own. When using its own, implementations of the atomic; operat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:52349,Availability,avail,available,52349,"d. As a result, all these; features are enabled with the ``-std=c11`` or ``-std=gnu11`` option when; compiling C code. Additionally, because these features are all; backward-compatible, they are available as extensions in all language modes. C11 alignment specifiers; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_alignas)`` or ``__has_extension(c_alignas)`` to determine; if support for alignment specifiers using ``_Alignas`` is enabled. Use ``__has_feature(c_alignof)`` or ``__has_extension(c_alignof)`` to determine; if support for the ``_Alignof`` keyword is enabled. C11 atomic operations; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_atomic)`` or ``__has_extension(c_atomic)`` to determine; if support for atomic types using ``_Atomic`` is enabled. Clang also provides; :ref:`a set of builtins <langext-__c11_atomic>` which can be used to implement; the ``<stdatomic.h>`` operations on ``_Atomic`` types. Use; ``__has_include(<stdatomic.h>)`` to determine if C11's ``<stdatomic.h>`` header; is available. Clang will use the system's ``<stdatomic.h>`` header when one is available, and; will otherwise use its own. When using its own, implementations of the atomic; operations are provided as macros. In the cases where C11 also requires a real; function, this header provides only the declaration of that function (along; with a shadowing macro implementation), and you must link to a library which; provides a definition of the function if you use it instead of the macro. C11 generic selections; ^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_generic_selections)`` or; ``__has_extension(c_generic_selections)`` to determine if support for generic; selections is enabled. As an extension, the C11 generic selection expression is available in all; languages supported by Clang. The syntax is the same as that given in the C11; standard. In C, type compatibility is decided according to the rules given in the; appropriate standard, but in C++, which lacks the type compatibility rules used; i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:52425,Availability,avail,available,52425,"option when; compiling C code. Additionally, because these features are all; backward-compatible, they are available as extensions in all language modes. C11 alignment specifiers; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_alignas)`` or ``__has_extension(c_alignas)`` to determine; if support for alignment specifiers using ``_Alignas`` is enabled. Use ``__has_feature(c_alignof)`` or ``__has_extension(c_alignof)`` to determine; if support for the ``_Alignof`` keyword is enabled. C11 atomic operations; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_atomic)`` or ``__has_extension(c_atomic)`` to determine; if support for atomic types using ``_Atomic`` is enabled. Clang also provides; :ref:`a set of builtins <langext-__c11_atomic>` which can be used to implement; the ``<stdatomic.h>`` operations on ``_Atomic`` types. Use; ``__has_include(<stdatomic.h>)`` to determine if C11's ``<stdatomic.h>`` header; is available. Clang will use the system's ``<stdatomic.h>`` header when one is available, and; will otherwise use its own. When using its own, implementations of the atomic; operations are provided as macros. In the cases where C11 also requires a real; function, this header provides only the declaration of that function (along; with a shadowing macro implementation), and you must link to a library which; provides a definition of the function if you use it instead of the macro. C11 generic selections; ^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_generic_selections)`` or; ``__has_extension(c_generic_selections)`` to determine if support for generic; selections is enabled. As an extension, the C11 generic selection expression is available in all; languages supported by Clang. The syntax is the same as that given in the C11; standard. In C, type compatibility is decided according to the rules given in the; appropriate standard, but in C++, which lacks the type compatibility rules used; in C, types are considered compatible only if they are equivalent. Clang also supports an ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:53084,Availability,avail,available,53084,"g ``_Atomic`` is enabled. Clang also provides; :ref:`a set of builtins <langext-__c11_atomic>` which can be used to implement; the ``<stdatomic.h>`` operations on ``_Atomic`` types. Use; ``__has_include(<stdatomic.h>)`` to determine if C11's ``<stdatomic.h>`` header; is available. Clang will use the system's ``<stdatomic.h>`` header when one is available, and; will otherwise use its own. When using its own, implementations of the atomic; operations are provided as macros. In the cases where C11 also requires a real; function, this header provides only the declaration of that function (along; with a shadowing macro implementation), and you must link to a library which; provides a definition of the function if you use it instead of the macro. C11 generic selections; ^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_generic_selections)`` or; ``__has_extension(c_generic_selections)`` to determine if support for generic; selections is enabled. As an extension, the C11 generic selection expression is available in all; languages supported by Clang. The syntax is the same as that given in the C11; standard. In C, type compatibility is decided according to the rules given in the; appropriate standard, but in C++, which lacks the type compatibility rules used; in C, types are considered compatible only if they are equivalent. Clang also supports an extended form of ``_Generic`` with a controlling type; rather than a controlling expression. Unlike with a controlling expression, a; controlling type argument does not undergo any conversions and thus is suitable; for use when trying to match qualified types, incomplete types, or function; types. Variable-length array types lack the necessary compile-time information; to resolve which association they match with and thus are not allowed as a; controlling type argument. Use ``__has_extension(c_generic_selection_with_controlling_type)`` to determine; if support for this extension is enabled. C11 ``_Static_assert()``; ^^^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:70717,Availability,avail,available,70717,"lector (e.g., ""``init``"" in ""``initWithObjects``"") is considered,; and the method will have a related result type if its return type is compatible; with the type of its class and if:. * the first word is ""``alloc``"" or ""``new``"", and the method is a class method,; or. * the first word is ""``autorelease``"", ""``init``"", ""``retain``"", or ""``self``"",; and the method is an instance method. If a method with a related result type is overridden by a subclass method, the; subclass method must also return a type that is compatible with the subclass; type. For example:. .. code-block:: objc. @interface NSString : NSObject; - (NSUnrelated *)init; // incorrect usage: NSUnrelated is not NSString or a superclass of NSString; @end. Related result types only affect the type of a message send or property access; via the given method. In all other respects, a method with a related result; type is treated the same way as method that returns ``id``. Use ``__has_feature(objc_instancetype)`` to determine whether the; ``instancetype`` contextual keyword is available. Automatic reference counting; ----------------------------. Clang provides support for :doc:`automated reference counting; <AutomaticReferenceCounting>` in Objective-C, which eliminates the need; for manual ``retain``/``release``/``autorelease`` message sends. There are three; feature macros associated with automatic reference counting:; ``__has_feature(objc_arc)`` indicates the availability of automated reference; counting in general, while ``__has_feature(objc_arc_weak)`` indicates that; automated reference counting also includes support for ``__weak`` pointers to; Objective-C objects. ``__has_feature(objc_arc_fields)`` indicates that C structs; are allowed to have fields that are pointers to Objective-C objects managed by; automatic reference counting. .. _objc-weak:. Weak references; ---------------. Clang supports ARC-style weak and unsafe references in Objective-C even; outside of ARC mode. Weak references must be explici",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:71110,Availability,avail,availability,71110,"t also return a type that is compatible with the subclass; type. For example:. .. code-block:: objc. @interface NSString : NSObject; - (NSUnrelated *)init; // incorrect usage: NSUnrelated is not NSString or a superclass of NSString; @end. Related result types only affect the type of a message send or property access; via the given method. In all other respects, a method with a related result; type is treated the same way as method that returns ``id``. Use ``__has_feature(objc_instancetype)`` to determine whether the; ``instancetype`` contextual keyword is available. Automatic reference counting; ----------------------------. Clang provides support for :doc:`automated reference counting; <AutomaticReferenceCounting>` in Objective-C, which eliminates the need; for manual ``retain``/``release``/``autorelease`` message sends. There are three; feature macros associated with automatic reference counting:; ``__has_feature(objc_arc)`` indicates the availability of automated reference; counting in general, while ``__has_feature(objc_arc_weak)`` indicates that; automated reference counting also includes support for ``__weak`` pointers to; Objective-C objects. ``__has_feature(objc_arc_fields)`` indicates that C structs; are allowed to have fields that are pointers to Objective-C objects managed by; automatic reference counting. .. _objc-weak:. Weak references; ---------------. Clang supports ARC-style weak and unsafe references in Objective-C even; outside of ARC mode. Weak references must be explicitly enabled with; the ``-fobjc-weak`` option; use ``__has_feature((objc_arc_weak))``; to test whether they are enabled. Unsafe references are enabled; unconditionally. ARC-style weak and unsafe references cannot be used; when Objective-C garbage collection is enabled. Except as noted below, the language rules for the ``__weak`` and; ``__unsafe_unretained`` qualifiers (and the ``weak`` and; ``unsafe_unretained`` property attributes) are just as laid out; in the :doc:`ARC specificati",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:74307,Availability,avail,available,74307,",; but that behavior is suppressed when the captured variable is qualified; with ``__unsafe_unretained``. Note that the ``__weak`` qualifier formerly meant the GC qualifier in; all non-ARC modes and was silently ignored outside of GC modes. It now; means the ARC-style qualifier in all non-GC modes and is no longer; allowed if not enabled by either ``-fobjc-arc`` or ``-fobjc-weak``.; It is expected that ``-fobjc-weak`` will eventually be enabled by default; in all non-GC Objective-C modes. .. _objc-fixed-enum:. Enumerations with a fixed underlying type; -----------------------------------------. Clang provides support for C++11 enumerations with a fixed underlying type; within Objective-C. For example, one can write an enumeration type as:. .. code-block:: c++. typedef enum : unsigned char { Red, Green, Blue } Color;. This specifies that the underlying type, which is used to store the enumeration; value, is ``unsigned char``. Use ``__has_feature(objc_fixed_enum)`` to determine whether support for fixed; underlying types is available in Objective-C. Interoperability with C++11 lambdas; -----------------------------------. Clang provides interoperability between C++11 lambdas and blocks-based APIs, by; permitting a lambda to be implicitly converted to a block pointer with the; corresponding signature. For example, consider an API such as ``NSArray``'s; array-sorting method:. .. code-block:: objc. - (NSArray *)sortedArrayUsingComparator:(NSComparator)cmptr;. ``NSComparator`` is simply a typedef for the block pointer ``NSComparisonResult; (^)(id, id)``, and parameters of this type are generally provided with block; literals as arguments. However, one can also use a C++11 lambda so long as it; provides the same signature (in this case, accepting two parameters of type; ``id`` and returning an ``NSComparisonResult``):. .. code-block:: objc. NSArray *array = @[@""string 1"", @""string 21"", @""string 12"", @""String 11"",; @""String 02""];; const NSStringCompareOptions comparisonOptio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:76766,Availability,avail,available,76766,", local class type called the *closure type*) to the; corresponding block pointer type. The conversion itself is expressed by a; conversion operator in that closure type that produces a block pointer with the; same signature as the lambda itself, e.g.,. .. code-block:: objc. operator NSComparisonResult (^)(id, id)() const;. This conversion function returns a new block that simply forwards the two; parameters to the lambda object (which it captures by copy), then returns the; result. The returned block is first copied (with ``Block_copy``) and then; autoreleased. As an optimization, if a lambda expression is immediately; converted to a block pointer (as in the first example, above), then the block; is not copied and autoreleased: rather, it is given the same lifetime as a; block literal written at that point in the program, which avoids the overhead; of copying a block to the heap in the common case. The conversion from a lambda to a block pointer is only available in; Objective-C++, and not in C++ with blocks, due to its use of Objective-C memory; management (autorelease). Object Literals and Subscripting; --------------------------------. Clang provides support for :doc:`Object Literals and Subscripting; <ObjectiveCLiterals>` in Objective-C, which simplifies common Objective-C; programming patterns, makes programs more concise, and improves the safety of; container creation. There are several feature macros associated with object; literals and subscripting: ``__has_feature(objc_array_literals)`` tests the; availability of array literals; ``__has_feature(objc_dictionary_literals)``; tests the availability of dictionary literals;; ``__has_feature(objc_subscripting)`` tests the availability of object; subscripting. Objective-C Autosynthesis of Properties; ---------------------------------------. Clang provides support for autosynthesis of declared properties. Using this; feature, clang provides default synthesis of those properties not declared; @dynamic and not having",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:77330,Availability,avail,availability,77330,"s an optimization, if a lambda expression is immediately; converted to a block pointer (as in the first example, above), then the block; is not copied and autoreleased: rather, it is given the same lifetime as a; block literal written at that point in the program, which avoids the overhead; of copying a block to the heap in the common case. The conversion from a lambda to a block pointer is only available in; Objective-C++, and not in C++ with blocks, due to its use of Objective-C memory; management (autorelease). Object Literals and Subscripting; --------------------------------. Clang provides support for :doc:`Object Literals and Subscripting; <ObjectiveCLiterals>` in Objective-C, which simplifies common Objective-C; programming patterns, makes programs more concise, and improves the safety of; container creation. There are several feature macros associated with object; literals and subscripting: ``__has_feature(objc_array_literals)`` tests the; availability of array literals; ``__has_feature(objc_dictionary_literals)``; tests the availability of dictionary literals;; ``__has_feature(objc_subscripting)`` tests the availability of object; subscripting. Objective-C Autosynthesis of Properties; ---------------------------------------. Clang provides support for autosynthesis of declared properties. Using this; feature, clang provides default synthesis of those properties not declared; @dynamic and not having user provided backing getter and setter methods.; ``__has_feature(objc_default_synthesize_properties)`` checks for availability; of this feature in version of clang being used. .. _langext-objc-retain-release:. Objective-C retaining behavior attributes; -----------------------------------------. In Objective-C, functions and methods are generally assumed to follow the; `Cocoa Memory Management; <https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html>`_; conventions for ownership of object arguments and; return va",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:77417,Availability,avail,availability,77417,"s an optimization, if a lambda expression is immediately; converted to a block pointer (as in the first example, above), then the block; is not copied and autoreleased: rather, it is given the same lifetime as a; block literal written at that point in the program, which avoids the overhead; of copying a block to the heap in the common case. The conversion from a lambda to a block pointer is only available in; Objective-C++, and not in C++ with blocks, due to its use of Objective-C memory; management (autorelease). Object Literals and Subscripting; --------------------------------. Clang provides support for :doc:`Object Literals and Subscripting; <ObjectiveCLiterals>` in Objective-C, which simplifies common Objective-C; programming patterns, makes programs more concise, and improves the safety of; container creation. There are several feature macros associated with object; literals and subscripting: ``__has_feature(objc_array_literals)`` tests the; availability of array literals; ``__has_feature(objc_dictionary_literals)``; tests the availability of dictionary literals;; ``__has_feature(objc_subscripting)`` tests the availability of object; subscripting. Objective-C Autosynthesis of Properties; ---------------------------------------. Clang provides support for autosynthesis of declared properties. Using this; feature, clang provides default synthesis of those properties not declared; @dynamic and not having user provided backing getter and setter methods.; ``__has_feature(objc_default_synthesize_properties)`` checks for availability; of this feature in version of clang being used. .. _langext-objc-retain-release:. Objective-C retaining behavior attributes; -----------------------------------------. In Objective-C, functions and methods are generally assumed to follow the; `Cocoa Memory Management; <https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html>`_; conventions for ownership of object arguments and; return va",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:77502,Availability,avail,availability,77502,"s an optimization, if a lambda expression is immediately; converted to a block pointer (as in the first example, above), then the block; is not copied and autoreleased: rather, it is given the same lifetime as a; block literal written at that point in the program, which avoids the overhead; of copying a block to the heap in the common case. The conversion from a lambda to a block pointer is only available in; Objective-C++, and not in C++ with blocks, due to its use of Objective-C memory; management (autorelease). Object Literals and Subscripting; --------------------------------. Clang provides support for :doc:`Object Literals and Subscripting; <ObjectiveCLiterals>` in Objective-C, which simplifies common Objective-C; programming patterns, makes programs more concise, and improves the safety of; container creation. There are several feature macros associated with object; literals and subscripting: ``__has_feature(objc_array_literals)`` tests the; availability of array literals; ``__has_feature(objc_dictionary_literals)``; tests the availability of dictionary literals;; ``__has_feature(objc_subscripting)`` tests the availability of object; subscripting. Objective-C Autosynthesis of Properties; ---------------------------------------. Clang provides support for autosynthesis of declared properties. Using this; feature, clang provides default synthesis of those properties not declared; @dynamic and not having user provided backing getter and setter methods.; ``__has_feature(objc_default_synthesize_properties)`` checks for availability; of this feature in version of clang being used. .. _langext-objc-retain-release:. Objective-C retaining behavior attributes; -----------------------------------------. In Objective-C, functions and methods are generally assumed to follow the; `Cocoa Memory Management; <https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html>`_; conventions for ownership of object arguments and; return va",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:77914,Availability,avail,availability,77914,"cripting; --------------------------------. Clang provides support for :doc:`Object Literals and Subscripting; <ObjectiveCLiterals>` in Objective-C, which simplifies common Objective-C; programming patterns, makes programs more concise, and improves the safety of; container creation. There are several feature macros associated with object; literals and subscripting: ``__has_feature(objc_array_literals)`` tests the; availability of array literals; ``__has_feature(objc_dictionary_literals)``; tests the availability of dictionary literals;; ``__has_feature(objc_subscripting)`` tests the availability of object; subscripting. Objective-C Autosynthesis of Properties; ---------------------------------------. Clang provides support for autosynthesis of declared properties. Using this; feature, clang provides default synthesis of those properties not declared; @dynamic and not having user provided backing getter and setter methods.; ``__has_feature(objc_default_synthesize_properties)`` checks for availability; of this feature in version of clang being used. .. _langext-objc-retain-release:. Objective-C retaining behavior attributes; -----------------------------------------. In Objective-C, functions and methods are generally assumed to follow the; `Cocoa Memory Management; <https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html>`_; conventions for ownership of object arguments and; return values. However, there are exceptions, and so Clang provides attributes; to allow these exceptions to be documented. This are used by ARC and the; `static analyzer <https://clang-analyzer.llvm.org>`_ Some exceptions may be; better described using the ``objc_method_family`` attribute instead. **Usage**: The ``ns_returns_retained``, ``ns_returns_not_retained``,; ``ns_returns_autoreleased``, ``cf_returns_retained``, and; ``cf_returns_not_retained`` attributes can be placed on methods and functions; that return Objective-C or CoreFoundation obj",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:80210,Availability,avail,available,80210,"`*_returns_not_retained`` attributes specify that the return; object has a +0 retain count, even if the normal convention for its selector; would be +1. ``ns_returns_autoreleased`` specifies that the returned object is; +0, but is guaranteed to live at least as long as the next flush of an; autorelease pool. **Usage**: The ``ns_consumed`` and ``cf_consumed`` attributes can be placed on; a parameter declaration; they specify that the argument is expected to have a; +1 retain count, which will be balanced in some way by the function or method.; The ``ns_consumes_self`` attribute can only be placed on an Objective-C; method; it specifies that the method expects its ``self`` parameter to have a; +1 retain count, which it will balance in some way. .. code-block:: objc. void foo(__attribute__((ns_consumed)) NSString *string);. - (void) bar __attribute__((ns_consumes_self));; - (void) baz:(id) __attribute__((ns_consumed)) x;. Further examples of these attributes are available in the static analyzer's `list of annotations for analysis; <https://clang-analyzer.llvm.org/annotations.html#cocoa_mem>`_. Query for these features with ``__has_attribute(ns_consumed)``,; ``__has_attribute(ns_returns_retained)``, etc. Objective-C @available; ----------------------. It is possible to use the newest SDK but still build a program that can run on; older versions of macOS and iOS by passing ``-mmacosx-version-min=`` /; ``-miphoneos-version-min=``. Before LLVM 5.0, when calling a function that exists only in the OS that's; newer than the target OS (as determined by the minimum deployment version),; programmers had to carefully check if the function exists at runtime, using; null checks for weakly-linked C functions, ``+class`` for Objective-C classes,; and ``-respondsToSelector:`` or ``+instancesRespondToSelector:`` for; Objective-C methods. If such a check was missed, the program would compile; fine, run fine on newer systems, but crash on older systems. As of LLVM 5.0, ``-Wunguarded-avai",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:80469,Availability,avail,available,80469,"o live at least as long as the next flush of an; autorelease pool. **Usage**: The ``ns_consumed`` and ``cf_consumed`` attributes can be placed on; a parameter declaration; they specify that the argument is expected to have a; +1 retain count, which will be balanced in some way by the function or method.; The ``ns_consumes_self`` attribute can only be placed on an Objective-C; method; it specifies that the method expects its ``self`` parameter to have a; +1 retain count, which it will balance in some way. .. code-block:: objc. void foo(__attribute__((ns_consumed)) NSString *string);. - (void) bar __attribute__((ns_consumes_self));; - (void) baz:(id) __attribute__((ns_consumed)) x;. Further examples of these attributes are available in the static analyzer's `list of annotations for analysis; <https://clang-analyzer.llvm.org/annotations.html#cocoa_mem>`_. Query for these features with ``__has_attribute(ns_consumed)``,; ``__has_attribute(ns_returns_retained)``, etc. Objective-C @available; ----------------------. It is possible to use the newest SDK but still build a program that can run on; older versions of macOS and iOS by passing ``-mmacosx-version-min=`` /; ``-miphoneos-version-min=``. Before LLVM 5.0, when calling a function that exists only in the OS that's; newer than the target OS (as determined by the minimum deployment version),; programmers had to carefully check if the function exists at runtime, using; null checks for weakly-linked C functions, ``+class`` for Objective-C classes,; and ``-respondsToSelector:`` or ``+instancesRespondToSelector:`` for; Objective-C methods. If such a check was missed, the program would compile; fine, run fine on newer systems, but crash on older systems. As of LLVM 5.0, ``-Wunguarded-availability`` uses the `availability attributes; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ together; with the new ``@available()`` keyword to assist with this issue.; When a method that's introduced in the OS newer than",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:81232,Availability,avail,availability,81232,"notations for analysis; <https://clang-analyzer.llvm.org/annotations.html#cocoa_mem>`_. Query for these features with ``__has_attribute(ns_consumed)``,; ``__has_attribute(ns_returns_retained)``, etc. Objective-C @available; ----------------------. It is possible to use the newest SDK but still build a program that can run on; older versions of macOS and iOS by passing ``-mmacosx-version-min=`` /; ``-miphoneos-version-min=``. Before LLVM 5.0, when calling a function that exists only in the OS that's; newer than the target OS (as determined by the minimum deployment version),; programmers had to carefully check if the function exists at runtime, using; null checks for weakly-linked C functions, ``+class`` for Objective-C classes,; and ``-respondsToSelector:`` or ``+instancesRespondToSelector:`` for; Objective-C methods. If such a check was missed, the program would compile; fine, run fine on newer systems, but crash on older systems. As of LLVM 5.0, ``-Wunguarded-availability`` uses the `availability attributes; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ together; with the new ``@available()`` keyword to assist with this issue.; When a method that's introduced in the OS newer than the target OS is called, a; -Wunguarded-availability warning is emitted if that call is not guarded:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; // If fancyNewMethod was added in e.g. macOS 10.12, but the code is; // built with -mmacosx-version-min=10.11, then this unconditional call; // will emit a -Wunguarded-availability warning:; [var fancyNewMethod];; }. To fix the warning and to avoid the crash on macOS 10.11, wrap it in; ``if(@available())``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, *)) {; [var fancyNewMethod];; } else {; // Put fallback behavior for old macOS versions (and for non-mac; // platforms) here.; }; }. The ``*`` is required and means that platforms not explicitly listed will take; the true bran",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:81257,Availability,avail,availability,81257,"notations for analysis; <https://clang-analyzer.llvm.org/annotations.html#cocoa_mem>`_. Query for these features with ``__has_attribute(ns_consumed)``,; ``__has_attribute(ns_returns_retained)``, etc. Objective-C @available; ----------------------. It is possible to use the newest SDK but still build a program that can run on; older versions of macOS and iOS by passing ``-mmacosx-version-min=`` /; ``-miphoneos-version-min=``. Before LLVM 5.0, when calling a function that exists only in the OS that's; newer than the target OS (as determined by the minimum deployment version),; programmers had to carefully check if the function exists at runtime, using; null checks for weakly-linked C functions, ``+class`` for Objective-C classes,; and ``-respondsToSelector:`` or ``+instancesRespondToSelector:`` for; Objective-C methods. If such a check was missed, the program would compile; fine, run fine on newer systems, but crash on older systems. As of LLVM 5.0, ``-Wunguarded-availability`` uses the `availability attributes; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ together; with the new ``@available()`` keyword to assist with this issue.; When a method that's introduced in the OS newer than the target OS is called, a; -Wunguarded-availability warning is emitted if that call is not guarded:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; // If fancyNewMethod was added in e.g. macOS 10.12, but the code is; // built with -mmacosx-version-min=10.11, then this unconditional call; // will emit a -Wunguarded-availability warning:; [var fancyNewMethod];; }. To fix the warning and to avoid the crash on macOS 10.11, wrap it in; ``if(@available())``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, *)) {; [var fancyNewMethod];; } else {; // Put fallback behavior for old macOS versions (and for non-mac; // platforms) here.; }; }. The ``*`` is required and means that platforms not explicitly listed will take; the true bran",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:81335,Availability,avail,availability,81335,"_has_attribute(ns_consumed)``,; ``__has_attribute(ns_returns_retained)``, etc. Objective-C @available; ----------------------. It is possible to use the newest SDK but still build a program that can run on; older versions of macOS and iOS by passing ``-mmacosx-version-min=`` /; ``-miphoneos-version-min=``. Before LLVM 5.0, when calling a function that exists only in the OS that's; newer than the target OS (as determined by the minimum deployment version),; programmers had to carefully check if the function exists at runtime, using; null checks for weakly-linked C functions, ``+class`` for Objective-C classes,; and ``-respondsToSelector:`` or ``+instancesRespondToSelector:`` for; Objective-C methods. If such a check was missed, the program would compile; fine, run fine on newer systems, but crash on older systems. As of LLVM 5.0, ``-Wunguarded-availability`` uses the `availability attributes; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ together; with the new ``@available()`` keyword to assist with this issue.; When a method that's introduced in the OS newer than the target OS is called, a; -Wunguarded-availability warning is emitted if that call is not guarded:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; // If fancyNewMethod was added in e.g. macOS 10.12, but the code is; // built with -mmacosx-version-min=10.11, then this unconditional call; // will emit a -Wunguarded-availability warning:; [var fancyNewMethod];; }. To fix the warning and to avoid the crash on macOS 10.11, wrap it in; ``if(@available())``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, *)) {; [var fancyNewMethod];; } else {; // Put fallback behavior for old macOS versions (and for non-mac; // platforms) here.; }; }. The ``*`` is required and means that platforms not explicitly listed will take; the true branch, and the compiler will emit ``-Wunguarded-availability``; warnings for unlisted platforms based on those platform's dep",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:81377,Availability,avail,available,81377,"_has_attribute(ns_consumed)``,; ``__has_attribute(ns_returns_retained)``, etc. Objective-C @available; ----------------------. It is possible to use the newest SDK but still build a program that can run on; older versions of macOS and iOS by passing ``-mmacosx-version-min=`` /; ``-miphoneos-version-min=``. Before LLVM 5.0, when calling a function that exists only in the OS that's; newer than the target OS (as determined by the minimum deployment version),; programmers had to carefully check if the function exists at runtime, using; null checks for weakly-linked C functions, ``+class`` for Objective-C classes,; and ``-respondsToSelector:`` or ``+instancesRespondToSelector:`` for; Objective-C methods. If such a check was missed, the program would compile; fine, run fine on newer systems, but crash on older systems. As of LLVM 5.0, ``-Wunguarded-availability`` uses the `availability attributes; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ together; with the new ``@available()`` keyword to assist with this issue.; When a method that's introduced in the OS newer than the target OS is called, a; -Wunguarded-availability warning is emitted if that call is not guarded:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; // If fancyNewMethod was added in e.g. macOS 10.12, but the code is; // built with -mmacosx-version-min=10.11, then this unconditional call; // will emit a -Wunguarded-availability warning:; [var fancyNewMethod];; }. To fix the warning and to avoid the crash on macOS 10.11, wrap it in; ``if(@available())``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, *)) {; [var fancyNewMethod];; } else {; // Put fallback behavior for old macOS versions (and for non-mac; // platforms) here.; }; }. The ``*`` is required and means that platforms not explicitly listed will take; the true branch, and the compiler will emit ``-Wunguarded-availability``; warnings for unlisted platforms based on those platform's dep",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:81520,Availability,avail,availability,81520," It is possible to use the newest SDK but still build a program that can run on; older versions of macOS and iOS by passing ``-mmacosx-version-min=`` /; ``-miphoneos-version-min=``. Before LLVM 5.0, when calling a function that exists only in the OS that's; newer than the target OS (as determined by the minimum deployment version),; programmers had to carefully check if the function exists at runtime, using; null checks for weakly-linked C functions, ``+class`` for Objective-C classes,; and ``-respondsToSelector:`` or ``+instancesRespondToSelector:`` for; Objective-C methods. If such a check was missed, the program would compile; fine, run fine on newer systems, but crash on older systems. As of LLVM 5.0, ``-Wunguarded-availability`` uses the `availability attributes; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ together; with the new ``@available()`` keyword to assist with this issue.; When a method that's introduced in the OS newer than the target OS is called, a; -Wunguarded-availability warning is emitted if that call is not guarded:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; // If fancyNewMethod was added in e.g. macOS 10.12, but the code is; // built with -mmacosx-version-min=10.11, then this unconditional call; // will emit a -Wunguarded-availability warning:; [var fancyNewMethod];; }. To fix the warning and to avoid the crash on macOS 10.11, wrap it in; ``if(@available())``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, *)) {; [var fancyNewMethod];; } else {; // Put fallback behavior for old macOS versions (and for non-mac; // platforms) here.; }; }. The ``*`` is required and means that platforms not explicitly listed will take; the true branch, and the compiler will emit ``-Wunguarded-availability``; warnings for unlisted platforms based on those platform's deployment target.; More than one platform can be listed in ``@available()``:. .. code-block:: objc. void my_fun(NSSomeClass* va",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:81805,Availability,avail,availability,81805,"ed by the minimum deployment version),; programmers had to carefully check if the function exists at runtime, using; null checks for weakly-linked C functions, ``+class`` for Objective-C classes,; and ``-respondsToSelector:`` or ``+instancesRespondToSelector:`` for; Objective-C methods. If such a check was missed, the program would compile; fine, run fine on newer systems, but crash on older systems. As of LLVM 5.0, ``-Wunguarded-availability`` uses the `availability attributes; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ together; with the new ``@available()`` keyword to assist with this issue.; When a method that's introduced in the OS newer than the target OS is called, a; -Wunguarded-availability warning is emitted if that call is not guarded:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; // If fancyNewMethod was added in e.g. macOS 10.12, but the code is; // built with -mmacosx-version-min=10.11, then this unconditional call; // will emit a -Wunguarded-availability warning:; [var fancyNewMethod];; }. To fix the warning and to avoid the crash on macOS 10.11, wrap it in; ``if(@available())``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, *)) {; [var fancyNewMethod];; } else {; // Put fallback behavior for old macOS versions (and for non-mac; // platforms) here.; }; }. The ``*`` is required and means that platforms not explicitly listed will take; the true branch, and the compiler will emit ``-Wunguarded-availability``; warnings for unlisted platforms based on those platform's deployment target.; More than one platform can be listed in ``@available()``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, iOS 10, *)) {; [var fancyNewMethod];; }; }. If the caller of ``my_fun()`` already checks that ``my_fun()`` is only called; on 10.12, then add an `availability attribute; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ to it,; which will also",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:81930,Availability,avail,available,81930,"for weakly-linked C functions, ``+class`` for Objective-C classes,; and ``-respondsToSelector:`` or ``+instancesRespondToSelector:`` for; Objective-C methods. If such a check was missed, the program would compile; fine, run fine on newer systems, but crash on older systems. As of LLVM 5.0, ``-Wunguarded-availability`` uses the `availability attributes; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ together; with the new ``@available()`` keyword to assist with this issue.; When a method that's introduced in the OS newer than the target OS is called, a; -Wunguarded-availability warning is emitted if that call is not guarded:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; // If fancyNewMethod was added in e.g. macOS 10.12, but the code is; // built with -mmacosx-version-min=10.11, then this unconditional call; // will emit a -Wunguarded-availability warning:; [var fancyNewMethod];; }. To fix the warning and to avoid the crash on macOS 10.11, wrap it in; ``if(@available())``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, *)) {; [var fancyNewMethod];; } else {; // Put fallback behavior for old macOS versions (and for non-mac; // platforms) here.; }; }. The ``*`` is required and means that platforms not explicitly listed will take; the true branch, and the compiler will emit ``-Wunguarded-availability``; warnings for unlisted platforms based on those platform's deployment target.; More than one platform can be listed in ``@available()``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, iOS 10, *)) {; [var fancyNewMethod];; }; }. If the caller of ``my_fun()`` already checks that ``my_fun()`` is only called; on 10.12, then add an `availability attribute; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ to it,; which will also suppress the warning and require that calls to my_fun() are; checked:. .. code-block:: objc. API_AVAILABLE(macos(10.12)) void m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:82007,Availability,avail,available,82007,"d ``-respondsToSelector:`` or ``+instancesRespondToSelector:`` for; Objective-C methods. If such a check was missed, the program would compile; fine, run fine on newer systems, but crash on older systems. As of LLVM 5.0, ``-Wunguarded-availability`` uses the `availability attributes; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ together; with the new ``@available()`` keyword to assist with this issue.; When a method that's introduced in the OS newer than the target OS is called, a; -Wunguarded-availability warning is emitted if that call is not guarded:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; // If fancyNewMethod was added in e.g. macOS 10.12, but the code is; // built with -mmacosx-version-min=10.11, then this unconditional call; // will emit a -Wunguarded-availability warning:; [var fancyNewMethod];; }. To fix the warning and to avoid the crash on macOS 10.11, wrap it in; ``if(@available())``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, *)) {; [var fancyNewMethod];; } else {; // Put fallback behavior for old macOS versions (and for non-mac; // platforms) here.; }; }. The ``*`` is required and means that platforms not explicitly listed will take; the true branch, and the compiler will emit ``-Wunguarded-availability``; warnings for unlisted platforms based on those platform's deployment target.; More than one platform can be listed in ``@available()``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, iOS 10, *)) {; [var fancyNewMethod];; }; }. If the caller of ``my_fun()`` already checks that ``my_fun()`` is only called; on 10.12, then add an `availability attribute; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ to it,; which will also suppress the warning and require that calls to my_fun() are; checked:. .. code-block:: objc. API_AVAILABLE(macos(10.12)) void my_fun(NSSomeClass* var) {; [var fancyNewMethod]; // Now ok.; }. ``@ava",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:82301,Availability,avail,availability,82301,"tes; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ together; with the new ``@available()`` keyword to assist with this issue.; When a method that's introduced in the OS newer than the target OS is called, a; -Wunguarded-availability warning is emitted if that call is not guarded:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; // If fancyNewMethod was added in e.g. macOS 10.12, but the code is; // built with -mmacosx-version-min=10.11, then this unconditional call; // will emit a -Wunguarded-availability warning:; [var fancyNewMethod];; }. To fix the warning and to avoid the crash on macOS 10.11, wrap it in; ``if(@available())``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, *)) {; [var fancyNewMethod];; } else {; // Put fallback behavior for old macOS versions (and for non-mac; // platforms) here.; }; }. The ``*`` is required and means that platforms not explicitly listed will take; the true branch, and the compiler will emit ``-Wunguarded-availability``; warnings for unlisted platforms based on those platform's deployment target.; More than one platform can be listed in ``@available()``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, iOS 10, *)) {; [var fancyNewMethod];; }; }. If the caller of ``my_fun()`` already checks that ``my_fun()`` is only called; on 10.12, then add an `availability attribute; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ to it,; which will also suppress the warning and require that calls to my_fun() are; checked:. .. code-block:: objc. API_AVAILABLE(macos(10.12)) void my_fun(NSSomeClass* var) {; [var fancyNewMethod]; // Now ok.; }. ``@available()`` is only available in Objective-C code. To use the feature; in C and C++ code, use the ``__builtin_available()`` spelling instead. If existing code uses null checks or ``-respondsToSelector:``, it should; be changed to use ``@available()`` (or ``__builtin_available``) in",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:82438,Availability,avail,available,82438,"e.; When a method that's introduced in the OS newer than the target OS is called, a; -Wunguarded-availability warning is emitted if that call is not guarded:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; // If fancyNewMethod was added in e.g. macOS 10.12, but the code is; // built with -mmacosx-version-min=10.11, then this unconditional call; // will emit a -Wunguarded-availability warning:; [var fancyNewMethod];; }. To fix the warning and to avoid the crash on macOS 10.11, wrap it in; ``if(@available())``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, *)) {; [var fancyNewMethod];; } else {; // Put fallback behavior for old macOS versions (and for non-mac; // platforms) here.; }; }. The ``*`` is required and means that platforms not explicitly listed will take; the true branch, and the compiler will emit ``-Wunguarded-availability``; warnings for unlisted platforms based on those platform's deployment target.; More than one platform can be listed in ``@available()``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, iOS 10, *)) {; [var fancyNewMethod];; }; }. If the caller of ``my_fun()`` already checks that ``my_fun()`` is only called; on 10.12, then add an `availability attribute; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ to it,; which will also suppress the warning and require that calls to my_fun() are; checked:. .. code-block:: objc. API_AVAILABLE(macos(10.12)) void my_fun(NSSomeClass* var) {; [var fancyNewMethod]; // Now ok.; }. ``@available()`` is only available in Objective-C code. To use the feature; in C and C++ code, use the ``__builtin_available()`` spelling instead. If existing code uses null checks or ``-respondsToSelector:``, it should; be changed to use ``@available()`` (or ``__builtin_available``) instead. ``-Wunguarded-availability`` is disabled by default, but; ``-Wunguarded-availability-new``, which only emits this warning for APIs; that h",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:82514,Availability,avail,available,82514," a; -Wunguarded-availability warning is emitted if that call is not guarded:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; // If fancyNewMethod was added in e.g. macOS 10.12, but the code is; // built with -mmacosx-version-min=10.11, then this unconditional call; // will emit a -Wunguarded-availability warning:; [var fancyNewMethod];; }. To fix the warning and to avoid the crash on macOS 10.11, wrap it in; ``if(@available())``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, *)) {; [var fancyNewMethod];; } else {; // Put fallback behavior for old macOS versions (and for non-mac; // platforms) here.; }; }. The ``*`` is required and means that platforms not explicitly listed will take; the true branch, and the compiler will emit ``-Wunguarded-availability``; warnings for unlisted platforms based on those platform's deployment target.; More than one platform can be listed in ``@available()``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, iOS 10, *)) {; [var fancyNewMethod];; }; }. If the caller of ``my_fun()`` already checks that ``my_fun()`` is only called; on 10.12, then add an `availability attribute; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ to it,; which will also suppress the warning and require that calls to my_fun() are; checked:. .. code-block:: objc. API_AVAILABLE(macos(10.12)) void my_fun(NSSomeClass* var) {; [var fancyNewMethod]; // Now ok.; }. ``@available()`` is only available in Objective-C code. To use the feature; in C and C++ code, use the ``__builtin_available()`` spelling instead. If existing code uses null checks or ``-respondsToSelector:``, it should; be changed to use ``@available()`` (or ``__builtin_available``) instead. ``-Wunguarded-availability`` is disabled by default, but; ``-Wunguarded-availability-new``, which only emits this warning for APIs; that have been introduced in macOS >= 10.13, iOS >= 11, watchOS >= 4 and; tvOS >= 11, i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:82683,Availability,avail,availability,82683,"he code is; // built with -mmacosx-version-min=10.11, then this unconditional call; // will emit a -Wunguarded-availability warning:; [var fancyNewMethod];; }. To fix the warning and to avoid the crash on macOS 10.11, wrap it in; ``if(@available())``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, *)) {; [var fancyNewMethod];; } else {; // Put fallback behavior for old macOS versions (and for non-mac; // platforms) here.; }; }. The ``*`` is required and means that platforms not explicitly listed will take; the true branch, and the compiler will emit ``-Wunguarded-availability``; warnings for unlisted platforms based on those platform's deployment target.; More than one platform can be listed in ``@available()``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, iOS 10, *)) {; [var fancyNewMethod];; }; }. If the caller of ``my_fun()`` already checks that ``my_fun()`` is only called; on 10.12, then add an `availability attribute; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ to it,; which will also suppress the warning and require that calls to my_fun() are; checked:. .. code-block:: objc. API_AVAILABLE(macos(10.12)) void my_fun(NSSomeClass* var) {; [var fancyNewMethod]; // Now ok.; }. ``@available()`` is only available in Objective-C code. To use the feature; in C and C++ code, use the ``__builtin_available()`` spelling instead. If existing code uses null checks or ``-respondsToSelector:``, it should; be changed to use ``@available()`` (or ``__builtin_available``) instead. ``-Wunguarded-availability`` is disabled by default, but; ``-Wunguarded-availability-new``, which only emits this warning for APIs; that have been introduced in macOS >= 10.13, iOS >= 11, watchOS >= 4 and; tvOS >= 11, is enabled by default. .. _langext-overloading:. Objective-C++ ABI: protocol-qualifier mangling of parameters; ------------------------------------------------------------. Starting with LLVM",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:82760,Availability,avail,availability,82760,"ility warning:; [var fancyNewMethod];; }. To fix the warning and to avoid the crash on macOS 10.11, wrap it in; ``if(@available())``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, *)) {; [var fancyNewMethod];; } else {; // Put fallback behavior for old macOS versions (and for non-mac; // platforms) here.; }; }. The ``*`` is required and means that platforms not explicitly listed will take; the true branch, and the compiler will emit ``-Wunguarded-availability``; warnings for unlisted platforms based on those platform's deployment target.; More than one platform can be listed in ``@available()``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, iOS 10, *)) {; [var fancyNewMethod];; }; }. If the caller of ``my_fun()`` already checks that ``my_fun()`` is only called; on 10.12, then add an `availability attribute; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ to it,; which will also suppress the warning and require that calls to my_fun() are; checked:. .. code-block:: objc. API_AVAILABLE(macos(10.12)) void my_fun(NSSomeClass* var) {; [var fancyNewMethod]; // Now ok.; }. ``@available()`` is only available in Objective-C code. To use the feature; in C and C++ code, use the ``__builtin_available()`` spelling instead. If existing code uses null checks or ``-respondsToSelector:``, it should; be changed to use ``@available()`` (or ``__builtin_available``) instead. ``-Wunguarded-availability`` is disabled by default, but; ``-Wunguarded-availability-new``, which only emits this warning for APIs; that have been introduced in macOS >= 10.13, iOS >= 11, watchOS >= 4 and; tvOS >= 11, is enabled by default. .. _langext-overloading:. Objective-C++ ABI: protocol-qualifier mangling of parameters; ------------------------------------------------------------. Starting with LLVM 3.4, Clang produces a new mangling for parameters whose; type is a qualified-``id`` (e.g., ``id<Foo>``). This mangling",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:82994,Availability,avail,available,82994,"acOS 10.12, *)) {; [var fancyNewMethod];; } else {; // Put fallback behavior for old macOS versions (and for non-mac; // platforms) here.; }; }. The ``*`` is required and means that platforms not explicitly listed will take; the true branch, and the compiler will emit ``-Wunguarded-availability``; warnings for unlisted platforms based on those platform's deployment target.; More than one platform can be listed in ``@available()``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, iOS 10, *)) {; [var fancyNewMethod];; }; }. If the caller of ``my_fun()`` already checks that ``my_fun()`` is only called; on 10.12, then add an `availability attribute; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ to it,; which will also suppress the warning and require that calls to my_fun() are; checked:. .. code-block:: objc. API_AVAILABLE(macos(10.12)) void my_fun(NSSomeClass* var) {; [var fancyNewMethod]; // Now ok.; }. ``@available()`` is only available in Objective-C code. To use the feature; in C and C++ code, use the ``__builtin_available()`` spelling instead. If existing code uses null checks or ``-respondsToSelector:``, it should; be changed to use ``@available()`` (or ``__builtin_available``) instead. ``-Wunguarded-availability`` is disabled by default, but; ``-Wunguarded-availability-new``, which only emits this warning for APIs; that have been introduced in macOS >= 10.13, iOS >= 11, watchOS >= 4 and; tvOS >= 11, is enabled by default. .. _langext-overloading:. Objective-C++ ABI: protocol-qualifier mangling of parameters; ------------------------------------------------------------. Starting with LLVM 3.4, Clang produces a new mangling for parameters whose; type is a qualified-``id`` (e.g., ``id<Foo>``). This mangling allows such; parameters to be differentiated from those with the regular unqualified ``id``; type. This was a non-backward compatible mangling change to the ABI. This change; allows proper overloading, an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:83016,Availability,avail,available,83016,"acOS 10.12, *)) {; [var fancyNewMethod];; } else {; // Put fallback behavior for old macOS versions (and for non-mac; // platforms) here.; }; }. The ``*`` is required and means that platforms not explicitly listed will take; the true branch, and the compiler will emit ``-Wunguarded-availability``; warnings for unlisted platforms based on those platform's deployment target.; More than one platform can be listed in ``@available()``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, iOS 10, *)) {; [var fancyNewMethod];; }; }. If the caller of ``my_fun()`` already checks that ``my_fun()`` is only called; on 10.12, then add an `availability attribute; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ to it,; which will also suppress the warning and require that calls to my_fun() are; checked:. .. code-block:: objc. API_AVAILABLE(macos(10.12)) void my_fun(NSSomeClass* var) {; [var fancyNewMethod]; // Now ok.; }. ``@available()`` is only available in Objective-C code. To use the feature; in C and C++ code, use the ``__builtin_available()`` spelling instead. If existing code uses null checks or ``-respondsToSelector:``, it should; be changed to use ``@available()`` (or ``__builtin_available``) instead. ``-Wunguarded-availability`` is disabled by default, but; ``-Wunguarded-availability-new``, which only emits this warning for APIs; that have been introduced in macOS >= 10.13, iOS >= 11, watchOS >= 4 and; tvOS >= 11, is enabled by default. .. _langext-overloading:. Objective-C++ ABI: protocol-qualifier mangling of parameters; ------------------------------------------------------------. Starting with LLVM 3.4, Clang produces a new mangling for parameters whose; type is a qualified-``id`` (e.g., ``id<Foo>``). This mangling allows such; parameters to be differentiated from those with the regular unqualified ``id``; type. This was a non-backward compatible mangling change to the ABI. This change; allows proper overloading, an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:83233,Availability,avail,available,83233,"not explicitly listed will take; the true branch, and the compiler will emit ``-Wunguarded-availability``; warnings for unlisted platforms based on those platform's deployment target.; More than one platform can be listed in ``@available()``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, iOS 10, *)) {; [var fancyNewMethod];; }; }. If the caller of ``my_fun()`` already checks that ``my_fun()`` is only called; on 10.12, then add an `availability attribute; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ to it,; which will also suppress the warning and require that calls to my_fun() are; checked:. .. code-block:: objc. API_AVAILABLE(macos(10.12)) void my_fun(NSSomeClass* var) {; [var fancyNewMethod]; // Now ok.; }. ``@available()`` is only available in Objective-C code. To use the feature; in C and C++ code, use the ``__builtin_available()`` spelling instead. If existing code uses null checks or ``-respondsToSelector:``, it should; be changed to use ``@available()`` (or ``__builtin_available``) instead. ``-Wunguarded-availability`` is disabled by default, but; ``-Wunguarded-availability-new``, which only emits this warning for APIs; that have been introduced in macOS >= 10.13, iOS >= 11, watchOS >= 4 and; tvOS >= 11, is enabled by default. .. _langext-overloading:. Objective-C++ ABI: protocol-qualifier mangling of parameters; ------------------------------------------------------------. Starting with LLVM 3.4, Clang produces a new mangling for parameters whose; type is a qualified-``id`` (e.g., ``id<Foo>``). This mangling allows such; parameters to be differentiated from those with the regular unqualified ``id``; type. This was a non-backward compatible mangling change to the ABI. This change; allows proper overloading, and also prevents mangling conflicts with template; parameters of protocol-qualified type. Query the presence of this new mangling with; ``__has_feature(objc_protocol_qualifier_mangling)``. Initi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:83299,Availability,avail,availability,83299,"m's deployment target.; More than one platform can be listed in ``@available()``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, iOS 10, *)) {; [var fancyNewMethod];; }; }. If the caller of ``my_fun()`` already checks that ``my_fun()`` is only called; on 10.12, then add an `availability attribute; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ to it,; which will also suppress the warning and require that calls to my_fun() are; checked:. .. code-block:: objc. API_AVAILABLE(macos(10.12)) void my_fun(NSSomeClass* var) {; [var fancyNewMethod]; // Now ok.; }. ``@available()`` is only available in Objective-C code. To use the feature; in C and C++ code, use the ``__builtin_available()`` spelling instead. If existing code uses null checks or ``-respondsToSelector:``, it should; be changed to use ``@available()`` (or ``__builtin_available``) instead. ``-Wunguarded-availability`` is disabled by default, but; ``-Wunguarded-availability-new``, which only emits this warning for APIs; that have been introduced in macOS >= 10.13, iOS >= 11, watchOS >= 4 and; tvOS >= 11, is enabled by default. .. _langext-overloading:. Objective-C++ ABI: protocol-qualifier mangling of parameters; ------------------------------------------------------------. Starting with LLVM 3.4, Clang produces a new mangling for parameters whose; type is a qualified-``id`` (e.g., ``id<Foo>``). This mangling allows such; parameters to be differentiated from those with the regular unqualified ``id``; type. This was a non-backward compatible mangling change to the ABI. This change; allows proper overloading, and also prevents mangling conflicts with template; parameters of protocol-qualified type. Query the presence of this new mangling with; ``__has_feature(objc_protocol_qualifier_mangling)``. Initializer lists for complex numbers in C; ==========================================. clang supports an extension which allows the following in C:. .. code-block::",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:83357,Availability,avail,availability-new,83357,"m's deployment target.; More than one platform can be listed in ``@available()``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, iOS 10, *)) {; [var fancyNewMethod];; }; }. If the caller of ``my_fun()`` already checks that ``my_fun()`` is only called; on 10.12, then add an `availability attribute; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ to it,; which will also suppress the warning and require that calls to my_fun() are; checked:. .. code-block:: objc. API_AVAILABLE(macos(10.12)) void my_fun(NSSomeClass* var) {; [var fancyNewMethod]; // Now ok.; }. ``@available()`` is only available in Objective-C code. To use the feature; in C and C++ code, use the ``__builtin_available()`` spelling instead. If existing code uses null checks or ``-respondsToSelector:``, it should; be changed to use ``@available()`` (or ``__builtin_available``) instead. ``-Wunguarded-availability`` is disabled by default, but; ``-Wunguarded-availability-new``, which only emits this warning for APIs; that have been introduced in macOS >= 10.13, iOS >= 11, watchOS >= 4 and; tvOS >= 11, is enabled by default. .. _langext-overloading:. Objective-C++ ABI: protocol-qualifier mangling of parameters; ------------------------------------------------------------. Starting with LLVM 3.4, Clang produces a new mangling for parameters whose; type is a qualified-``id`` (e.g., ``id<Foo>``). This mangling allows such; parameters to be differentiated from those with the regular unqualified ``id``; type. This was a non-backward compatible mangling change to the ABI. This change; allows proper overloading, and also prevents mangling conflicts with template; parameters of protocol-qualified type. Query the presence of this new mangling with; ``__has_feature(objc_protocol_qualifier_mangling)``. Initializer lists for complex numbers in C; ==========================================. clang supports an extension which allows the following in C:. .. code-block::",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:86514,Availability,error,error,86514," Clang supports internal OpenCL extensions documented below. ``__cl_clang_bitfields``; --------------------------------. With this extension it is possible to enable bitfields in structs; or unions using the OpenCL extension pragma mechanism detailed in; `the OpenCL Extension Specification, section 1.2; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview>`_. Use of bitfields in OpenCL kernels can result in reduced portability as struct; layout is not guaranteed to be consistent when compiled by different compilers.; If structs with bitfields are used as kernel function parameters, it can result; in incorrect functionality when the layout is different between the host and; device code. **Example of Use**:. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_bitfields : enable; struct with_bitfield {; unsigned int i : 5; // compiled - no diagnostic generated; };. #pragma OPENCL EXTENSION __cl_clang_bitfields : disable; struct without_bitfield {; unsigned int i : 5; // error - bitfields are not supported; };. ``__cl_clang_function_pointers``; --------------------------------. With this extension it is possible to enable various language features that; are relying on function pointers using regular OpenCL extension pragma; mechanism detailed in `the OpenCL Extension Specification,; section 1.2; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview>`_. In C++ for OpenCL this also enables:. - Use of member function pointers;. - Unrestricted use of references to functions;. - Virtual member functions. Such functionality is not conformant and does not guarantee to compile; correctly in any circumstances. It can be used if:. - the kernel source does not contain call expressions to (member-) function; pointers, or virtual functions. For example this extension can be used in; metaprogramming algorithms to be able to specify/detect types generically. - the generated kernel binary ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:87962,Availability,error,error,87962,"verview>`_. In C++ for OpenCL this also enables:. - Use of member function pointers;. - Unrestricted use of references to functions;. - Virtual member functions. Such functionality is not conformant and does not guarantee to compile; correctly in any circumstances. It can be used if:. - the kernel source does not contain call expressions to (member-) function; pointers, or virtual functions. For example this extension can be used in; metaprogramming algorithms to be able to specify/detect types generically. - the generated kernel binary does not contain indirect calls because they; are eliminated using compiler optimizations e.g. devirtualization. - the selected target supports the function pointer like functionality e.g.; most CPU targets. **Example of Use**:. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_function_pointers : enable; void foo(); {; void (*fp)(); // compiled - no diagnostic generated; }. #pragma OPENCL EXTENSION __cl_clang_function_pointers : disable; void bar(); {; void (*fp)(); // error - pointers to function are not allowed; }. ``__cl_clang_variadic_functions``; ---------------------------------. With this extension it is possible to enable variadic arguments in functions; using regular OpenCL extension pragma mechanism detailed in `the OpenCL; Extension Specification, section 1.2; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview>`_. This is not conformant behavior and it can only be used portably when the; functions with variadic prototypes do not get generated in binary e.g. the; variadic prototype is used to specify a function type with any number of; arguments in metaprogramming algorithms in C++ for OpenCL. This extensions can also be used when the kernel code is intended for targets; supporting the variadic arguments e.g. majority of CPU targets. **Example of Use**:. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_variadic_functions : enable; void foo(int a, ...); // comp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:89060,Availability,error,error,89060,"-. With this extension it is possible to enable variadic arguments in functions; using regular OpenCL extension pragma mechanism detailed in `the OpenCL; Extension Specification, section 1.2; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview>`_. This is not conformant behavior and it can only be used portably when the; functions with variadic prototypes do not get generated in binary e.g. the; variadic prototype is used to specify a function type with any number of; arguments in metaprogramming algorithms in C++ for OpenCL. This extensions can also be used when the kernel code is intended for targets; supporting the variadic arguments e.g. majority of CPU targets. **Example of Use**:. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_variadic_functions : enable; void foo(int a, ...); // compiled - no diagnostic generated. #pragma OPENCL EXTENSION __cl_clang_variadic_functions : disable; void bar(int a, ...); // error - variadic prototype is not allowed. ``__cl_clang_non_portable_kernel_param_types``; ----------------------------------------------. With this extension it is possible to enable the use of some restricted types; in kernel parameters specified in `C++ for OpenCL v1.0 s2.4; <https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html#kernel_function>`_.; The restrictions can be relaxed using regular OpenCL extension pragma mechanism; detailed in `the OpenCL Extension Specification, section 1.2; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview>`_. This is not a conformant behavior and it can only be used when the; kernel arguments are not accessed on the host side or the data layout/size; between the host and device is known to be compatible. **Example of Use**:. .. code-block:: c++. // Plain Old Data type.; struct Pod {; int a;; int b;; };. // Not POD type because of the constructor.; // Standard layout type because there is only one access control.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:90924,Availability,error,error,90924,"onstructor.; // Standard layout type because there is only one access control.; struct OnlySL {; int a;; int b;; OnlySL() : a(0), b(0) {}; };. // Not standard layout type because of two different access controls.; struct NotSL {; int a;; private:; int b;; };. #pragma OPENCL EXTENSION __cl_clang_non_portable_kernel_param_types : enable; kernel void kernel_main(; Pod a,. OnlySL b,; global NotSL *c,; global OnlySL *d; );; #pragma OPENCL EXTENSION __cl_clang_non_portable_kernel_param_types : disable. Remove address space builtin function; -------------------------------------. ``__remove_address_space`` allows to derive types in C++ for OpenCL; that have address space qualifiers removed. This utility only affects; address space qualifiers, therefore, other type qualifiers such as; ``const`` or ``volatile`` remain unchanged. **Example of Use**:. .. code-block:: c++. template<typename T>; void foo(T *par){; T var1; // error - local function variable with global address space; __private T var2; // error - conflicting address space qualifiers; __private __remove_address_space<T>::type var3; // var3 is __private int; }. void bar(){; __global int* ptr;; foo(ptr);; }. Legacy 1.x atomics with generic address space; ---------------------------------------------. Clang allows use of atomic functions from the OpenCL 1.x standards; with the generic address space pointer in C++ for OpenCL mode. This is a non-portable feature and might not be supported by all; targets. **Example of Use**:. .. code-block:: c++. void foo(__generic volatile unsigned int* a) {; atomic_add(a, 1);; }. WebAssembly Features; ====================. Clang supports the WebAssembly features documented below. For further; information related to the semantics of the builtins, please refer to the `WebAssembly Specification <https://webassembly.github.io/spec/core/>`_.; In this section, when we refer to reference types, we are referring to; WebAssembly reference types, not C++ reference types unless stated; otherwise.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:91004,Availability,error,error,91004,"onstructor.; // Standard layout type because there is only one access control.; struct OnlySL {; int a;; int b;; OnlySL() : a(0), b(0) {}; };. // Not standard layout type because of two different access controls.; struct NotSL {; int a;; private:; int b;; };. #pragma OPENCL EXTENSION __cl_clang_non_portable_kernel_param_types : enable; kernel void kernel_main(; Pod a,. OnlySL b,; global NotSL *c,; global OnlySL *d; );; #pragma OPENCL EXTENSION __cl_clang_non_portable_kernel_param_types : disable. Remove address space builtin function; -------------------------------------. ``__remove_address_space`` allows to derive types in C++ for OpenCL; that have address space qualifiers removed. This utility only affects; address space qualifiers, therefore, other type qualifiers such as; ``const`` or ``volatile`` remain unchanged. **Example of Use**:. .. code-block:: c++. template<typename T>; void foo(T *par){; T var1; // error - local function variable with global address space; __private T var2; // error - conflicting address space qualifiers; __private __remove_address_space<T>::type var3; // var3 is __private int; }. void bar(){; __global int* ptr;; foo(ptr);; }. Legacy 1.x atomics with generic address space; ---------------------------------------------. Clang allows use of atomic functions from the OpenCL 1.x standards; with the generic address space pointer in C++ for OpenCL mode. This is a non-portable feature and might not be supported by all; targets. **Example of Use**:. .. code-block:: c++. void foo(__generic volatile unsigned int* a) {; atomic_add(a, 1);; }. WebAssembly Features; ====================. Clang supports the WebAssembly features documented below. For further; information related to the semantics of the builtins, please refer to the `WebAssembly Specification <https://webassembly.github.io/spec/core/>`_.; In this section, when we refer to reference types, we are referring to; WebAssembly reference types, not C++ reference types unless stated; otherwise.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:94216,Availability,error,error,94216,"ebAssembly table.; Takes the table as an argument and returns an unsigned integer (``size_t``); with the current table size. .. code-block:: c++. typedef void (*__funcref funcref_t)();; static __funcref table[0];. size_t getSize() {; return __builtin_wasm_table_size(table);; }. ``__builtin_wasm_table_grow``; -----------------------------. This builtin function grows the WebAssembly table by a certain amount.; Currently, as all WebAssembly tables created in C/C++ are zero-sized,; this always needs to be called to grow the table. It takes three arguments. The first argument is the WebAssembly table; to grow. The second argument is the reference typed value to store in; the new table entries (the initialization value), and the third argument; is the amount to grow the table by. It returns the previous table size; or -1. It will return -1 if not enough space could be allocated. .. code-block:: c++. typedef void (*__funcref funcref_t)();; static __funcref table[0];. // grow returns the new table size or -1 on error.; int grow(__funcref fn, int delta) {; int prevSize = __builtin_wasm_table_grow(table, fn, delta);; if (prevSize == -1); return -1;; return prevSize + delta;; }. ``__builtin_wasm_table_fill``; -----------------------------. This builtin function sets all the entries of a WebAssembly table to a given; reference typed value. It takes four arguments. The first argument is; the WebAssembly table, the second argument is the index that starts the; range, the third argument is the value to set in the new entries, and; the fourth and the last argument is the size of the range. It returns; nothing. .. code-block:: c++. static __externref_t table[0];. // resets a table by setting all of its entries to a given value.; void reset(__externref_t Obj) {; int Size = __builtin_wasm_table_size(table);; __builtin_wasm_table_fill(table, 0, Obj, Size);; }. ``__builtin_wasm_table_copy``; -----------------------------. This builtin function copies elements from a source WebAssembly t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:119964,Availability,avail,available,119964,"-icall<ControlFlowIntegrity>` checks. ``__builtin_operator_new`` and ``__builtin_operator_delete``; ------------------------------------------------------------. A call to ``__builtin_operator_new(args)`` is exactly the same as a call to; ``::operator new(args)``, except that it allows certain optimizations; that the C++ standard does not permit for a direct function call to; ``::operator new`` (in particular, removing ``new`` / ``delete`` pairs and; merging allocations), and that the call is required to resolve to a; `replaceable global allocation function; <https://en.cppreference.com/w/cpp/memory/new/operator_new>`_. Likewise, ``__builtin_operator_delete`` is exactly the same as a call to; ``::operator delete(args)``, except that it permits optimizations; and that the call is required to resolve to a; `replaceable global deallocation function; <https://en.cppreference.com/w/cpp/memory/new/operator_delete>`_. These builtins are intended for use in the implementation of ``std::allocator``; and other similar allocation libraries, and are only available in C++. Query for this feature with ``__has_builtin(__builtin_operator_new)`` or; ``__has_builtin(__builtin_operator_delete)``:. * If the value is at least ``201802L``, the builtins behave as described above. * If the value is non-zero, the builtins may not support calling arbitrary; replaceable global (de)allocation functions, but do support calling at least; ``::operator new(size_t)`` and ``::operator delete(void*)``. ``__builtin_preserve_access_index``; -----------------------------------. ``__builtin_preserve_access_index`` specifies a code section where; array subscript access and structure/union member access are relocatable; under bpf compile-once run-everywhere framework. Debuginfo (typically; with ``-g``) is needed, otherwise, the compiler will exit with an error.; The return type for the intrinsic is the same as the type of the; argument. **Syntax**:. .. code-block:: c. type __builtin_preserve_access_index(t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:120751,Availability,error,error,120751,"solve to a; `replaceable global deallocation function; <https://en.cppreference.com/w/cpp/memory/new/operator_delete>`_. These builtins are intended for use in the implementation of ``std::allocator``; and other similar allocation libraries, and are only available in C++. Query for this feature with ``__has_builtin(__builtin_operator_new)`` or; ``__has_builtin(__builtin_operator_delete)``:. * If the value is at least ``201802L``, the builtins behave as described above. * If the value is non-zero, the builtins may not support calling arbitrary; replaceable global (de)allocation functions, but do support calling at least; ``::operator new(size_t)`` and ``::operator delete(void*)``. ``__builtin_preserve_access_index``; -----------------------------------. ``__builtin_preserve_access_index`` specifies a code section where; array subscript access and structure/union member access are relocatable; under bpf compile-once run-everywhere framework. Debuginfo (typically; with ``-g``) is needed, otherwise, the compiler will exit with an error.; The return type for the intrinsic is the same as the type of the; argument. **Syntax**:. .. code-block:: c. type __builtin_preserve_access_index(type arg). **Example of Use**:. .. code-block:: c. struct t {; int i;; int j;; union {; int a;; int b;; } c[4];; };; struct t *v = ...;; int *pb =__builtin_preserve_access_index(&v->c[3].b);; __builtin_preserve_access_index(v->j);. ``__builtin_debugtrap``; -----------------------. ``__builtin_debugtrap`` causes the program to stop its execution in such a way that a debugger can catch it. **Syntax**:. .. code-block:: c++. __builtin_debugtrap(). **Description**. ``__builtin_debugtrap`` is lowered to the ` ``llvm.debugtrap`` <https://llvm.org/docs/LangRef.html#llvm-debugtrap-intrinsic>`_ builtin. It should have the same effect as setting a breakpoint on the line where the builtin is called. Query for this feature with ``__has_builtin(__builtin_debugtrap)``. ``__builtin_trap``; ------------------. `",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:129583,Availability,mask,mask,129583,". Otherwise, the builtin will return; 1 and the result will be equal to the unique value that is equivalent; to the mathematically-correct result modulo two raised to the *k*; power, where *k* is the number of bits in the result type. The; behavior of these builtins is well-defined for all argument values. The first three builtins work generically for operands of any integer type,; including boolean types. The operands need not have the same type as each; other, or as the result. The other builtins may implicitly promote or; convert their operands before performing the operation. Query for this feature with ``__has_builtin(__builtin_add_overflow)``, etc. Floating point builtins; ---------------------------------------. ``__builtin_isfpclass``; -----------------------. ``__builtin_isfpclass`` is used to test if the specified floating-point values; fall into one of the specified floating-point classes. **Syntax**:. .. code-block:: c++. int __builtin_isfpclass(fp_type expr, int mask); int_vector __builtin_isfpclass(fp_vector expr, int mask). **Example of use**:. .. code-block:: c++. if (__builtin_isfpclass(x, 448)) {; // `x` is positive finite value; 	 ...; }. **Description**:. The ``__builtin_isfpclass()`` builtin is a generalization of functions ``isnan``,; ``isinf``, ``isfinite`` and some others defined by the C standard. It tests if; the floating-point value, specified by the first argument, falls into any of data; classes, specified by the second argument. The latter is an integer constant; bitmask expression, in which each data class is represented by a bit; using the encoding:. ========== =================== ======================; Mask value Data class Macro; ========== =================== ======================; 0x0001 Signaling NaN __FPCLASS_SNAN; 0x0002 Quiet NaN __FPCLASS_QNAN; 0x0004 Negative infinity __FPCLASS_NEGINF; 0x0008 Negative normal __FPCLASS_NEGNORMAL; 0x0010 Negative subnormal __FPCLASS_NEGSUBNORMAL; 0x0020 Negative zero __FPCLASS_NEGZERO; 0x0040",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:129641,Availability,mask,mask,129641,". Otherwise, the builtin will return; 1 and the result will be equal to the unique value that is equivalent; to the mathematically-correct result modulo two raised to the *k*; power, where *k* is the number of bits in the result type. The; behavior of these builtins is well-defined for all argument values. The first three builtins work generically for operands of any integer type,; including boolean types. The operands need not have the same type as each; other, or as the result. The other builtins may implicitly promote or; convert their operands before performing the operation. Query for this feature with ``__has_builtin(__builtin_add_overflow)``, etc. Floating point builtins; ---------------------------------------. ``__builtin_isfpclass``; -----------------------. ``__builtin_isfpclass`` is used to test if the specified floating-point values; fall into one of the specified floating-point classes. **Syntax**:. .. code-block:: c++. int __builtin_isfpclass(fp_type expr, int mask); int_vector __builtin_isfpclass(fp_vector expr, int mask). **Example of use**:. .. code-block:: c++. if (__builtin_isfpclass(x, 448)) {; // `x` is positive finite value; 	 ...; }. **Description**:. The ``__builtin_isfpclass()`` builtin is a generalization of functions ``isnan``,; ``isinf``, ``isfinite`` and some others defined by the C standard. It tests if; the floating-point value, specified by the first argument, falls into any of data; classes, specified by the second argument. The latter is an integer constant; bitmask expression, in which each data class is represented by a bit; using the encoding:. ========== =================== ======================; Mask value Data class Macro; ========== =================== ======================; 0x0001 Signaling NaN __FPCLASS_SNAN; 0x0002 Quiet NaN __FPCLASS_QNAN; 0x0004 Negative infinity __FPCLASS_NEGINF; 0x0008 Negative normal __FPCLASS_NEGNORMAL; 0x0010 Negative subnormal __FPCLASS_NEGSUBNORMAL; 0x0020 Negative zero __FPCLASS_NEGZERO; 0x0040",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:131002,Availability,mask,mask,131002,"ified by the second argument. The latter is an integer constant; bitmask expression, in which each data class is represented by a bit; using the encoding:. ========== =================== ======================; Mask value Data class Macro; ========== =================== ======================; 0x0001 Signaling NaN __FPCLASS_SNAN; 0x0002 Quiet NaN __FPCLASS_QNAN; 0x0004 Negative infinity __FPCLASS_NEGINF; 0x0008 Negative normal __FPCLASS_NEGNORMAL; 0x0010 Negative subnormal __FPCLASS_NEGSUBNORMAL; 0x0020 Negative zero __FPCLASS_NEGZERO; 0x0040 Positive zero __FPCLASS_POSZERO; 0x0080 Positive subnormal __FPCLASS_POSSUBNORMAL; 0x0100 Positive normal __FPCLASS_POSNORMAL; 0x0200 Positive infinity __FPCLASS_POSINF; ========== =================== ======================. For convenience preprocessor defines macros for these values. The function; returns 1 if ``expr`` falls into one of the specified data classes, 0 otherwise. In the example above the mask value 448 (0x1C0) contains the bits selecting; positive zero, positive subnormal and positive normal classes.; ``__builtin_isfpclass(x, 448)`` would return true only if ``x`` if of any of; these data classes. Using suitable mask value, the function can implement any of; the standard classification functions, for example, ``__builtin_isfpclass(x, 3)``; is identical to ``isnan``,``__builtin_isfpclass(x, 504)`` - to ``isfinite``; and so on. If the first argument is a vector, the function is equivalent to the set of; scalar calls of ``__builtin_isfpclass`` applied to the input elementwise. The result of ``__builtin_isfpclass`` is a boolean value, if the first argument; is a scalar, or an integer vector with the same element count as the first; argument. The element type in this vector has the same bit length as the; element of the first argument type. This function never raises floating-point exceptions and does not canonicalize; its input. The floating-point argument is not promoted, its data class is; determined based on its ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:131231,Availability,mask,mask,131231,"========; 0x0001 Signaling NaN __FPCLASS_SNAN; 0x0002 Quiet NaN __FPCLASS_QNAN; 0x0004 Negative infinity __FPCLASS_NEGINF; 0x0008 Negative normal __FPCLASS_NEGNORMAL; 0x0010 Negative subnormal __FPCLASS_NEGSUBNORMAL; 0x0020 Negative zero __FPCLASS_NEGZERO; 0x0040 Positive zero __FPCLASS_POSZERO; 0x0080 Positive subnormal __FPCLASS_POSSUBNORMAL; 0x0100 Positive normal __FPCLASS_POSNORMAL; 0x0200 Positive infinity __FPCLASS_POSINF; ========== =================== ======================. For convenience preprocessor defines macros for these values. The function; returns 1 if ``expr`` falls into one of the specified data classes, 0 otherwise. In the example above the mask value 448 (0x1C0) contains the bits selecting; positive zero, positive subnormal and positive normal classes.; ``__builtin_isfpclass(x, 448)`` would return true only if ``x`` if of any of; these data classes. Using suitable mask value, the function can implement any of; the standard classification functions, for example, ``__builtin_isfpclass(x, 3)``; is identical to ``isnan``,``__builtin_isfpclass(x, 504)`` - to ``isfinite``; and so on. If the first argument is a vector, the function is equivalent to the set of; scalar calls of ``__builtin_isfpclass`` applied to the input elementwise. The result of ``__builtin_isfpclass`` is a boolean value, if the first argument; is a scalar, or an integer vector with the same element count as the first; argument. The element type in this vector has the same bit length as the; element of the first argument type. This function never raises floating-point exceptions and does not canonicalize; its input. The floating-point argument is not promoted, its data class is; determined based on its representation in its actual semantic type. ``__builtin_canonicalize``; --------------------------. .. code-block:: c. double __builtin_canonicalize(double);; float __builtin_canonicalizef(float);; long double __builtin_canonicalizel(long double);. Returns the platform specific canonic",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:152047,Availability,down,down,152047,";. **Example of use**:. .. code-block:: c++. char* global_alloc_buffer;; void* my_aligned_allocator(size_t alloc_size, size_t alignment) {; char* result = __builtin_align_up(global_alloc_buffer, alignment);; // result now contains the value of global_alloc_buffer rounded up to the; // next multiple of alignment.; global_alloc_buffer = result + alloc_size;; return result;; }. void* get_start_of_page(void* ptr) {; return __builtin_align_down(ptr, PAGE_SIZE);; }. void example(char* buffer) {; if (__builtin_is_aligned(buffer, 64)) {; do_fast_aligned_copy(buffer);; } else {; do_unaligned_copy(buffer);; }; }. // In addition to pointers, the builtins can also be used on integer types; // and are evaluatable inside constant expressions.; static_assert(__builtin_align_up(123, 64) == 128, """");; static_assert(__builtin_align_down(123u, 64) == 64u, """");; static_assert(!__builtin_is_aligned(123, 64), """");. **Description**:. The builtins ``__builtin_align_up``, ``__builtin_align_down``, return their; first argument aligned up/down to the next multiple of the second argument.; If the value is already sufficiently aligned, it is returned unchanged.; The builtin ``__builtin_is_aligned`` returns whether the first argument is; aligned to a multiple of the second argument.; All of these builtins expect the alignment to be expressed as a number of bytes. These builtins can be used for all integer types as well as (non-function); pointer types. For pointer types, these builtins operate in terms of the integer; address of the pointer and return a new pointer of the same type (including; qualifiers such as ``const``) with an adjusted address.; When aligning pointers up or down, the resulting value must be within the same; underlying allocation or one past the end (see C17 6.5.6p8, C++ [expr.add]).; This means that arbitrary integer values stored in pointer-type variables must; not be passed to these builtins. For those use cases, the builtins can still be; used, but the operation must be pe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:152696,Availability,down,down,152696,"ide constant expressions.; static_assert(__builtin_align_up(123, 64) == 128, """");; static_assert(__builtin_align_down(123u, 64) == 64u, """");; static_assert(!__builtin_is_aligned(123, 64), """");. **Description**:. The builtins ``__builtin_align_up``, ``__builtin_align_down``, return their; first argument aligned up/down to the next multiple of the second argument.; If the value is already sufficiently aligned, it is returned unchanged.; The builtin ``__builtin_is_aligned`` returns whether the first argument is; aligned to a multiple of the second argument.; All of these builtins expect the alignment to be expressed as a number of bytes. These builtins can be used for all integer types as well as (non-function); pointer types. For pointer types, these builtins operate in terms of the integer; address of the pointer and return a new pointer of the same type (including; qualifiers such as ``const``) with an adjusted address.; When aligning pointers up or down, the resulting value must be within the same; underlying allocation or one past the end (see C17 6.5.6p8, C++ [expr.add]).; This means that arbitrary integer values stored in pointer-type variables must; not be passed to these builtins. For those use cases, the builtins can still be; used, but the operation must be performed on the pointer cast to ``uintptr_t``. If Clang can determine that the alignment is not a power of two at compile time,; it will result in a compilation failure. If the alignment argument is not a; power of two at run time, the behavior of these builtins is undefined. Non-standard C++11 Attributes; =============================. Clang's non-standard C++11 attributes live in the ``clang`` attribute; namespace. Clang supports GCC's ``gnu`` attribute namespace. All GCC attributes which; are accepted with the ``__attribute__((foo))`` syntax are also accepted as; ``[[gnu::foo]]``. This only extends to attributes which are specified by GCC; (see the list of `GCC function attributes; <https://gcc.gnu.org",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:153180,Availability,failure,failure,153180,"iciently aligned, it is returned unchanged.; The builtin ``__builtin_is_aligned`` returns whether the first argument is; aligned to a multiple of the second argument.; All of these builtins expect the alignment to be expressed as a number of bytes. These builtins can be used for all integer types as well as (non-function); pointer types. For pointer types, these builtins operate in terms of the integer; address of the pointer and return a new pointer of the same type (including; qualifiers such as ``const``) with an adjusted address.; When aligning pointers up or down, the resulting value must be within the same; underlying allocation or one past the end (see C17 6.5.6p8, C++ [expr.add]).; This means that arbitrary integer values stored in pointer-type variables must; not be passed to these builtins. For those use cases, the builtins can still be; used, but the operation must be performed on the pointer cast to ``uintptr_t``. If Clang can determine that the alignment is not a power of two at compile time,; it will result in a compilation failure. If the alignment argument is not a; power of two at run time, the behavior of these builtins is undefined. Non-standard C++11 Attributes; =============================. Clang's non-standard C++11 attributes live in the ``clang`` attribute; namespace. Clang supports GCC's ``gnu`` attribute namespace. All GCC attributes which; are accepted with the ``__attribute__((foo))`` syntax are also accepted as; ``[[gnu::foo]]``. This only extends to attributes which are specified by GCC; (see the list of `GCC function attributes; <https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html>`_, `GCC variable; attributes <https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html>`_, and; `GCC type attributes; <https://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html>`_). As with the GCC; implementation, these attributes must appertain to the *declarator-id* in a; declaration, which means they must go either at the start of the declaratio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:163460,Availability,avail,available,163460,"loop. The directive; provides options for vectorization, interleaving, predication, unrolling and; distribution. Loop hints can be specified before any loop and will be ignored if; the optimization is not safe to apply. There are loop hints that control transformations (e.g. vectorization, loop; unrolling) and there are loop hints that set transformation options (e.g.; ``vectorize_width``, ``unroll_count``). Pragmas setting transformation options; imply the transformation is enabled, as if it was enabled via the corresponding; transformation pragma (e.g. ``vectorize(enable)``). If the transformation is; disabled (e.g. ``vectorize(disable)``), that takes precedence over; transformations option pragmas implying that transformation. Vectorization, Interleaving, and Predication; --------------------------------------------. A vectorized loop performs multiple iterations of the original loop; in parallel using vector instructions. The instruction set of the target; processor determines which vector instructions are available and their vector; widths. This restricts the types of loops that can be vectorized. The vectorizer; automatically determines if the loop is safe and profitable to vectorize. A; vector instruction cost model is used to select the vector width. Interleaving multiple loop iterations allows modern processors to further; improve instruction-level parallelism (ILP) using advanced hardware features,; such as multiple execution units and out-of-order execution. The vectorizer uses; a cost model that depends on the register pressure and generated code size to; select the interleaving count. Vectorization is enabled by ``vectorize(enable)`` and interleaving is enabled; by ``interleave(enable)``. This is useful when compiling with ``-Os`` to; manually enable vectorization or interleaving. .. code-block:: c++. #pragma clang loop vectorize(enable); #pragma clang loop interleave(enable); for(...) {; ...; }. The vector width is specified by; ``vectorize_width(_valu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:165768,Availability,mask,masks,165768,"e the user can hint at the type; of vectorization to use without specifying the exact width. In both variants; of the pragma the vectorizer may decide to fall back on fixed width; vectorization if the target does not support scalable vectors. The interleave count is specified by ``interleave_count(_value_)``, where; _value_ is a positive integer. This is useful for specifying the optimal; width/count of the set of target architectures supported by your application. .. code-block:: c++. #pragma clang loop vectorize_width(2); #pragma clang loop interleave_count(2); for(...) {; ...; }. Specifying a width/count of 1 disables the optimization, and is equivalent to; ``vectorize(disable)`` or ``interleave(disable)``. Vector predication is enabled by ``vectorize_predicate(enable)``, for example:. .. code-block:: c++. #pragma clang loop vectorize(enable); #pragma clang loop vectorize_predicate(enable); for(...) {; ...; }. This predicates (masks) all instructions in the loop, which allows the scalar; remainder loop (the tail) to be folded into the main vectorized loop. This; might be more efficient when vector predication is efficiently supported by the; target platform. Loop Unrolling; --------------. Unrolling a loop reduces the loop control overhead and exposes more; opportunities for ILP. Loops can be fully or partially unrolled. Full unrolling; eliminates the loop and replaces it with an enumerated sequence of loop; iterations. Full unrolling is only possible if the loop trip count is known at; compile time. Partial unrolling replicates the loop body within the loop and; reduces the trip count. If ``unroll(enable)`` is specified the unroller will attempt to fully unroll the; loop if the trip count is known at compile time. If the fully unrolled code size; is greater than an internal limit the loop will be partially unrolled up to this; limit. If the trip count is not known at compile time the loop will be partially; unrolled with a heuristically chosen unroll factor. .. c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:174703,Availability,error,error,174703,"od(extended)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=extended`` is enabled. Rounds intermediate results to; target-dependent ``long double`` precision. In Win32 programming, for instance,; the long double data type maps to the double, 64-bit precision data type. The full syntax this pragma supports is; ``#pragma clang fp eval_method(source|double|extended)``. .. code-block:: c++. for(...) {; // The compiler will use long double as the floating-point evaluation; // method.; #pragma clang fp eval_method(extended); a = b[i] * c[i] + e;; }. Note: ``math.h`` defines the typedefs ``float_t`` and ``double_t`` based on the active; evaluation method at the point where the header is included, not where the; typedefs are used. Because of this, it is unwise to combine these typedefs with; ``#pragma clang fp eval_method``. To catch obvious bugs, Clang will emit an; error for any references to these typedefs within the scope of this pragma;; however, this is not a fool-proof protection, and programmers must take care. The ``#pragma float_control`` pragma allows precise floating-point; semantics and floating-point exception behavior to be specified; for a section of the source code. This pragma can only appear at file or; namespace scope, within a language linkage specification or at the start of a; compound statement (excluding comments). When used within a compound statement,; the pragma is active within the scope of the compound statement. This pragma; is modeled after a Microsoft pragma with the same spelling and syntax. For; pragmas specified at file or namespace scope, or within a language linkage; specification, a stack is supported so that the ``pragma float_control``; settings can be pushed or popped. When ``pragma float_control(precise, on)`` is enabled, the section of code; governed by the pragma uses precise floating point semantics, effectively; ``-ffast-math`` is disabled and ``-ffp-contr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:182025,Availability,error,error,182025," ``apply_to``; specifier is currently the only supported subject set specifier. It allows you; to specify match rules that form a subset of the attribute's allowed subject; set, i.e. the compiler doesn't require all of the attribute's subjects. For; example, an attribute like ``[[nodiscard]]`` whose subject set includes; ``enum``, ``record`` and ``hasType(functionType)``, requires the presence of at; least one of these rules after ``apply_to``:. .. code-block:: c++. #pragma clang attribute push([[nodiscard]], apply_to = enum). enum Enum1 { A1, B1 }; // The enum will receive [[nodiscard]]. struct Record1 { }; // The struct will *not* receive [[nodiscard]]. #pragma clang attribute pop. #pragma clang attribute push([[nodiscard]], apply_to = any(record, enum)). enum Enum2 { A2, B2 }; // The enum will receive [[nodiscard]]. struct Record2 { }; // The struct *will* receive [[nodiscard]]. #pragma clang attribute pop. // This is an error, since [[nodiscard]] can't be applied to namespaces:; #pragma clang attribute push([[nodiscard]], apply_to = any(record, namespace)). #pragma clang attribute pop. Multiple match rules can be specified using the ``any`` match rule, as shown; in the example above. The ``any`` rule applies attributes to all declarations; that are matched by at least one of the rules in the ``any``. It doesn't nest; and can't be used inside the other match rules. Redundant match rules or rules; that conflict with one another should not be used inside of ``any``. Failing to; specify a rule within the ``any`` rule results in an error. Clang supports the following match rules:. - ``function``: Can be used to apply attributes to functions. This includes C++; member functions, static functions, operators, and constructors/destructors. - ``function(is_member)``: Can be used to apply attributes to C++ member; functions. This includes members like static functions, operators, and; constructors/destructors. - ``hasType(functionType)``: Can be used to apply attributes to",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:182644,Availability,error,error,182644,"num). enum Enum1 { A1, B1 }; // The enum will receive [[nodiscard]]. struct Record1 { }; // The struct will *not* receive [[nodiscard]]. #pragma clang attribute pop. #pragma clang attribute push([[nodiscard]], apply_to = any(record, enum)). enum Enum2 { A2, B2 }; // The enum will receive [[nodiscard]]. struct Record2 { }; // The struct *will* receive [[nodiscard]]. #pragma clang attribute pop. // This is an error, since [[nodiscard]] can't be applied to namespaces:; #pragma clang attribute push([[nodiscard]], apply_to = any(record, namespace)). #pragma clang attribute pop. Multiple match rules can be specified using the ``any`` match rule, as shown; in the example above. The ``any`` rule applies attributes to all declarations; that are matched by at least one of the rules in the ``any``. It doesn't nest; and can't be used inside the other match rules. Redundant match rules or rules; that conflict with one another should not be used inside of ``any``. Failing to; specify a rule within the ``any`` rule results in an error. Clang supports the following match rules:. - ``function``: Can be used to apply attributes to functions. This includes C++; member functions, static functions, operators, and constructors/destructors. - ``function(is_member)``: Can be used to apply attributes to C++ member; functions. This includes members like static functions, operators, and; constructors/destructors. - ``hasType(functionType)``: Can be used to apply attributes to functions, C++; member functions, and variables/fields whose type is a function pointer. It; does not apply attributes to Objective-C methods or blocks. - ``type_alias``: Can be used to apply attributes to ``typedef`` declarations; and C++11 type aliases. - ``record``: Can be used to apply attributes to ``struct``, ``class``, and; ``union`` declarations. - ``record(unless(is_union))``: Can be used to apply attributes only to; ``struct`` and ``class`` declarations. - ``enum``: Can be used to apply attributes to enumeratio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:13599,Deployability,patch,patch,13599,"rts at zero and is incremented each time; the ``__COUNTER__`` macro is expanded. ``__INCLUDE_LEVEL__``; Defined to an integral value that is the include depth of the file currently; being translated. For the main file, this value is zero. ``__TIMESTAMP__``; Defined to the date and time of the last modification of the current source; file. ``__clang__``; Defined when compiling with Clang. ``__clang_major__``; Defined to the major marketing version number of Clang (e.g., the 2 in; 2.0.1). Note that marketing version numbers should not be used to check for; language features, as different vendors use different numbering schemes.; Instead, use the :ref:`langext-feature_check`. ``__clang_minor__``; Defined to the minor version number of Clang (e.g., the 0 in 2.0.1). Note; that marketing version numbers should not be used to check for language; features, as different vendors use different numbering schemes. Instead, use; the :ref:`langext-feature_check`. ``__clang_patchlevel__``; Defined to the marketing patch level of Clang (e.g., the 1 in 2.0.1). ``__clang_version__``; Defined to a string that captures the Clang marketing version, including the; Subversion tag or revision number, e.g., ""``1.5 (trunk 102332)``"". ``__clang_literal_encoding__``; Defined to a narrow string literal that represents the current encoding of; narrow string literals, e.g., ``""hello""``. This macro typically expands to; ""UTF-8"" (but may change in the future if the; ``-fexec-charset=""Encoding-Name""`` option is implemented.). ``__clang_wide_literal_encoding__``; Defined to a narrow string literal that represents the current encoding of; wide string literals, e.g., ``L""hello""``. This macro typically expands to; ""UTF-16"" or ""UTF-32"" (but may change in the future if the; ``-fwide-exec-charset=""Encoding-Name""`` option is implemented.). Implementation-defined keywords; ===============================. __datasizeof; ------------. ``__datasizeof`` behaves like ``sizeof``, except that it returns the size of ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:34394,Deployability,release,releases,34394,"n-by-operation emulation; * ``standard``: meaning that excess precision is permitted under the rules; described in the standard, i.e. never across explicit casts or statements; * ``fast``: meaning that excess precision is permitted whenever the; optimizer sees an opportunity to avoid truncations; currently this has no; effect beyond ``standard``. The ``_Float16`` type is an interchange floating type specified in; ISO/IEC TS 18661-3:2015 (""Floating-point extensions for C""). It will; be supported on more targets as they define ABIs for it. The ``__bf16`` type is a non-standard extension, but it generally follows; the rules for arithmetic interchange floating types from ISO/IEC TS; 18661-3:2015. In previous versions of Clang, it was a storage-only type; that forbade arithmetic operations. It will be supported on more targets; as they define ABIs for it. The ``__fp16`` type was originally an ARM extension and is specified; by the `ARM C Language Extensions <https://github.com/ARM-software/acle/releases>`_.; Clang uses the ``binary16`` format from IEEE 754-2008 for ``__fp16``,; not the ARM alternative format. Operators that expect arithmetic operands; immediately promote ``__fp16`` operands to ``float``. It is recommended that portable code use ``_Float16`` instead of ``__fp16``,; as it has been defined by the C standards committee and has behavior that is; more familiar to most programmers. Because ``__fp16`` operands are always immediately promoted to ``float``, the; common real type of ``__fp16`` and ``_Float16`` for the purposes of the usual; arithmetic conversions is ``float``. A literal can be given ``_Float16`` type using the suffix ``f16``. For example,; ``3.14f16``. Because default argument promotion only applies to the standard floating-point; types, ``_Float16`` values are not promoted to ``double`` when passed as variadic; or untyped arguments. As a consequence, some caution must be taken when using; certain library facilities with ``_Float16``; for example, ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:38553,Deployability,install,installed,38553," be built in such a way that; they will always be treated as being ""system frameworks"", even if they are not; present in a system framework directory. This can be useful to system; framework developers who want to be able to test building other applications; with development builds of their framework, including the manner in which the; compiler changes warning behavior for system headers. Framework developers can opt-in to this mechanism by creating a; ""``.system_framework``"" file at the top-level of their framework. That is, the; framework should have contents like:. .. code-block:: none. .../TestFramework.framework; .../TestFramework.framework/.system_framework; .../TestFramework.framework/Headers; .../TestFramework.framework/Headers/TestFramework.h; ... Clang will treat the presence of this file as an indicator that the framework; should be treated as a system framework, regardless of how it was found in the; framework search path. For consistency, we recommend that such files never be; included in installed versions of the framework. Checks for Standard Language Features; =====================================. The ``__has_feature`` macro can be used to query if certain standard language; features are enabled. The ``__has_extension`` macro can be used to query if; language features are available as an extension when compiling for a standard; which does not provide them. The features which can be tested are listed here. Since Clang 3.4, the C++ SD-6 feature test macros are also supported.; These are macros with names of the form ``__cpp_<feature_name>``, and are; intended to be a portable way to query the supported features of the compiler.; See `the C++ status page <https://clang.llvm.org/cxx_status.html#ts>`_ for; information on the version of SD-6 supported by each Clang release, and the; macros provided by that revision of the recommendations. C++98; -----. The features listed below are part of the C++98 standard. These features are; enabled by default when com",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:39343,Deployability,release,release,39343,"ile as an indicator that the framework; should be treated as a system framework, regardless of how it was found in the; framework search path. For consistency, we recommend that such files never be; included in installed versions of the framework. Checks for Standard Language Features; =====================================. The ``__has_feature`` macro can be used to query if certain standard language; features are enabled. The ``__has_extension`` macro can be used to query if; language features are available as an extension when compiling for a standard; which does not provide them. The features which can be tested are listed here. Since Clang 3.4, the C++ SD-6 feature test macros are also supported.; These are macros with names of the form ``__cpp_<feature_name>``, and are; intended to be a portable way to query the supported features of the compiler.; See `the C++ status page <https://clang.llvm.org/cxx_status.html#ts>`_ for; information on the version of SD-6 supported by each Clang release, and the; macros provided by that revision of the recommendations. C++98; -----. The features listed below are part of the C++98 standard. These features are; enabled by default when compiling C++ code. C++ exceptions; ^^^^^^^^^^^^^^. Use ``__has_feature(cxx_exceptions)`` to determine if C++ exceptions have been; enabled. For example, compiling code with ``-fno-exceptions`` disables C++; exceptions. C++ RTTI; ^^^^^^^^. Use ``__has_feature(cxx_rtti)`` to determine if C++ RTTI has been enabled. For; example, compiling code with ``-fno-rtti`` disables the use of RTTI. C++11; -----. The features listed below are part of the C++11 standard. As a result, all; these features are enabled with the ``-std=c++11`` or ``-std=gnu++11`` option; when compiling C++ code. C++11 SFINAE includes access control; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_access_control_sfinae)`` or; ``__has_extension(cxx_access_control_sfinae)`` to determine whether; access-control errors (e.g.,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:70948,Deployability,release,release,70948,"""``new``"", and the method is a class method,; or. * the first word is ""``autorelease``"", ""``init``"", ""``retain``"", or ""``self``"",; and the method is an instance method. If a method with a related result type is overridden by a subclass method, the; subclass method must also return a type that is compatible with the subclass; type. For example:. .. code-block:: objc. @interface NSString : NSObject; - (NSUnrelated *)init; // incorrect usage: NSUnrelated is not NSString or a superclass of NSString; @end. Related result types only affect the type of a message send or property access; via the given method. In all other respects, a method with a related result; type is treated the same way as method that returns ``id``. Use ``__has_feature(objc_instancetype)`` to determine whether the; ``instancetype`` contextual keyword is available. Automatic reference counting; ----------------------------. Clang provides support for :doc:`automated reference counting; <AutomaticReferenceCounting>` in Objective-C, which eliminates the need; for manual ``retain``/``release``/``autorelease`` message sends. There are three; feature macros associated with automatic reference counting:; ``__has_feature(objc_arc)`` indicates the availability of automated reference; counting in general, while ``__has_feature(objc_arc_weak)`` indicates that; automated reference counting also includes support for ``__weak`` pointers to; Objective-C objects. ``__has_feature(objc_arc_fields)`` indicates that C structs; are allowed to have fields that are pointers to Objective-C objects managed by; automatic reference counting. .. _objc-weak:. Weak references; ---------------. Clang supports ARC-style weak and unsafe references in Objective-C even; outside of ARC mode. Weak references must be explicitly enabled with; the ``-fobjc-weak`` option; use ``__has_feature((objc_arc_weak))``; to test whether they are enabled. Unsafe references are enabled; unconditionally. ARC-style weak and unsafe references cannot be used",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:78000,Deployability,release,release,78000,"t Literals and Subscripting; <ObjectiveCLiterals>` in Objective-C, which simplifies common Objective-C; programming patterns, makes programs more concise, and improves the safety of; container creation. There are several feature macros associated with object; literals and subscripting: ``__has_feature(objc_array_literals)`` tests the; availability of array literals; ``__has_feature(objc_dictionary_literals)``; tests the availability of dictionary literals;; ``__has_feature(objc_subscripting)`` tests the availability of object; subscripting. Objective-C Autosynthesis of Properties; ---------------------------------------. Clang provides support for autosynthesis of declared properties. Using this; feature, clang provides default synthesis of those properties not declared; @dynamic and not having user provided backing getter and setter methods.; ``__has_feature(objc_default_synthesize_properties)`` checks for availability; of this feature in version of clang being used. .. _langext-objc-retain-release:. Objective-C retaining behavior attributes; -----------------------------------------. In Objective-C, functions and methods are generally assumed to follow the; `Cocoa Memory Management; <https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html>`_; conventions for ownership of object arguments and; return values. However, there are exceptions, and so Clang provides attributes; to allow these exceptions to be documented. This are used by ARC and the; `static analyzer <https://clang-analyzer.llvm.org>`_ Some exceptions may be; better described using the ``objc_method_family`` attribute instead. **Usage**: The ``ns_returns_retained``, ``ns_returns_not_retained``,; ``ns_returns_autoreleased``, ``cf_returns_retained``, and; ``cf_returns_not_retained`` attributes can be placed on methods and functions; that return Objective-C or CoreFoundation objects. They are commonly placed at; the end of a function prototype or method declar",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:80816,Deployability,deploy,deployment,80816,"od expects its ``self`` parameter to have a; +1 retain count, which it will balance in some way. .. code-block:: objc. void foo(__attribute__((ns_consumed)) NSString *string);. - (void) bar __attribute__((ns_consumes_self));; - (void) baz:(id) __attribute__((ns_consumed)) x;. Further examples of these attributes are available in the static analyzer's `list of annotations for analysis; <https://clang-analyzer.llvm.org/annotations.html#cocoa_mem>`_. Query for these features with ``__has_attribute(ns_consumed)``,; ``__has_attribute(ns_returns_retained)``, etc. Objective-C @available; ----------------------. It is possible to use the newest SDK but still build a program that can run on; older versions of macOS and iOS by passing ``-mmacosx-version-min=`` /; ``-miphoneos-version-min=``. Before LLVM 5.0, when calling a function that exists only in the OS that's; newer than the target OS (as determined by the minimum deployment version),; programmers had to carefully check if the function exists at runtime, using; null checks for weakly-linked C functions, ``+class`` for Objective-C classes,; and ``-respondsToSelector:`` or ``+instancesRespondToSelector:`` for; Objective-C methods. If such a check was missed, the program would compile; fine, run fine on newer systems, but crash on older systems. As of LLVM 5.0, ``-Wunguarded-availability`` uses the `availability attributes; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ together; with the new ``@available()`` keyword to assist with this issue.; When a method that's introduced in the OS newer than the target OS is called, a; -Wunguarded-availability warning is emitted if that call is not guarded:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; // If fancyNewMethod was added in e.g. macOS 10.12, but the code is; // built with -mmacosx-version-min=10.11, then this unconditional call; // will emit a -Wunguarded-availability warning:; [var fancyNewMethod];; }. To fix the warning and to avoid the cr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:82375,Deployability,deploy,deployment,82375,"tes; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ together; with the new ``@available()`` keyword to assist with this issue.; When a method that's introduced in the OS newer than the target OS is called, a; -Wunguarded-availability warning is emitted if that call is not guarded:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; // If fancyNewMethod was added in e.g. macOS 10.12, but the code is; // built with -mmacosx-version-min=10.11, then this unconditional call; // will emit a -Wunguarded-availability warning:; [var fancyNewMethod];; }. To fix the warning and to avoid the crash on macOS 10.11, wrap it in; ``if(@available())``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, *)) {; [var fancyNewMethod];; } else {; // Put fallback behavior for old macOS versions (and for non-mac; // platforms) here.; }; }. The ``*`` is required and means that platforms not explicitly listed will take; the true branch, and the compiler will emit ``-Wunguarded-availability``; warnings for unlisted platforms based on those platform's deployment target.; More than one platform can be listed in ``@available()``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, iOS 10, *)) {; [var fancyNewMethod];; }; }. If the caller of ``my_fun()`` already checks that ``my_fun()`` is only called; on 10.12, then add an `availability attribute; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ to it,; which will also suppress the warning and require that calls to my_fun() are; checked:. .. code-block:: objc. API_AVAILABLE(macos(10.12)) void my_fun(NSSomeClass* var) {; [var fancyNewMethod]; // Now ok.; }. ``@available()`` is only available in Objective-C code. To use the feature; in C and C++ code, use the ``__builtin_available()`` spelling instead. If existing code uses null checks or ``-respondsToSelector:``, it should; be changed to use ``@available()`` (or ``__builtin_available``) in",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:140317,Deployability,release,release,140317,"hat this intrinsic cannot yet be called in a ``constexpr`` context. Atomic Min/Max builtins with memory ordering; --------------------------------------------. There are two atomic builtins with min/max in-memory comparison and swap.; The syntax and semantics are similar to GCC-compatible __atomic_* builtins. * ``__atomic_fetch_min``; * ``__atomic_fetch_max``. The builtins work with signed and unsigned integers and require to specify memory ordering.; The return value is the original value that was stored in memory before comparison. Example:. .. code-block:: c. unsigned int val = __atomic_fetch_min(unsigned int *pi, unsigned int ui, __ATOMIC_RELAXED);. The third argument is one of the memory ordering specifiers ``__ATOMIC_RELAXED``,; ``__ATOMIC_CONSUME``, ``__ATOMIC_ACQUIRE``, ``__ATOMIC_RELEASE``,; ``__ATOMIC_ACQ_REL``, or ``__ATOMIC_SEQ_CST`` following C++11 memory model semantics. In terms of acquire-release ordering barriers these two operations are always; considered as operations with *load-store* semantics, even when the original value; is not actually modified after comparison. .. _langext-__c11_atomic:. __c11_atomic builtins; ---------------------. Clang provides a set of builtins which are intended to be used to implement; C11's ``<stdatomic.h>`` header. These builtins provide the semantics of the; ``_explicit`` form of the corresponding C11 operation, and are named with a; ``__c11_`` prefix. The supported operations, and the differences from; the corresponding C11 operations, are:. * ``__c11_atomic_init``; * ``__c11_atomic_thread_fence``; * ``__c11_atomic_signal_fence``; * ``__c11_atomic_is_lock_free`` (The argument is the size of the; ``_Atomic(...)`` object, instead of its address); * ``__c11_atomic_store``; * ``__c11_atomic_load``; * ``__c11_atomic_exchange``; * ``__c11_atomic_compare_exchange_strong``; * ``__c11_atomic_compare_exchange_weak``; * ``__c11_atomic_fetch_add``; * ``__c11_atomic_fetch_sub``; * ``__c11_atomic_fetch_and``; * ``__c11_atomic_f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:145333,Deployability,release,releases,145333," insert; stack stores on its own, so it is best not to use these operations on variables; with automatic storage duration. Also, loads and stores may be implicit in code written between the ``ldrex`` and; ``strex``. Clang will not necessarily mitigate the effects of these either, so; care should be exercised. For these reasons the higher level atomic primitives should be preferred where; possible. Non-temporal load/store builtins; --------------------------------. Clang provides overloaded builtins allowing generation of non-temporal memory; accesses. .. code-block:: c. T __builtin_nontemporal_load(T *addr);; void __builtin_nontemporal_store(T value, T *addr);. The types ``T`` currently supported are:. * Integer types.; * Floating-point types.; * Vector types. Note that the compiler does not guarantee that non-temporal loads or stores; will be used. C++ Coroutines support builtins; --------------------------------. .. warning::; This is a work in progress. Compatibility across Clang/LLVM releases is not; guaranteed. Clang provides experimental builtins to support C++ Coroutines as defined by; https://wg21.link/P0057. The following four are intended to be used by the; standard library to implement the ``std::coroutine_handle`` type. **Syntax**:. .. code-block:: c. void __builtin_coro_resume(void *addr);; void __builtin_coro_destroy(void *addr);; bool __builtin_coro_done(void *addr);; void *__builtin_coro_promise(void *addr, int alignment, bool from_promise). **Example of use**:. .. code-block:: c++. template <> struct coroutine_handle<void> {; void resume() const { __builtin_coro_resume(ptr); }; void destroy() const { __builtin_coro_destroy(ptr); }; bool done() const { return __builtin_coro_done(ptr); }; // ...; protected:; void *ptr;; };. template <typename Promise> struct coroutine_handle : coroutine_handle<> {; // ...; Promise &promise() const {; return *reinterpret_cast<Promise *>(; __builtin_coro_promise(ptr, alignof(Promise), /*from-promise=*/false));; }; static",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:154776,Deployability,release,releases,154776,"ml>`_, `GCC variable; attributes <https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html>`_, and; `GCC type attributes; <https://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html>`_). As with the GCC; implementation, these attributes must appertain to the *declarator-id* in a; declaration, which means they must go either at the start of the declaration or; immediately after the name being declared. For example, this applies the GNU ``unused`` attribute to ``a`` and ``f``, and; also applies the GNU ``noreturn`` attribute to ``f``. .. code-block:: c++. [[gnu::unused]] int a, f [[gnu::noreturn]] ();. Target-Specific Extensions; ==========================. Clang supports some language features conditionally on some targets. ARM/AArch64 Language Extensions; -------------------------------. Memory Barrier Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^; Clang implements the ``__dmb``, ``__dsb`` and ``__isb`` intrinsics as defined; in the `Arm C Language Extensions; <https://github.com/ARM-software/acle/releases>`_.; Note that these intrinsics are implemented as motion barriers that block; reordering of memory accesses and side effect instructions. Other instructions; like simple arithmetic may be reordered around the intrinsic. If you expect to; have no reordering at all, use inline assembly instead. X86/X86-64 Language Extensions; ------------------------------. The X86 backend has these language extensions:. Memory references to specified segments; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Annotating a pointer with address space #256 causes it to be code generated; relative to the X86 GS segment register, address space #257 causes it to be; relative to the X86 FS segment, and address space #258 causes it to be; relative to the X86 SS segment. Note that this is a very very low-level; feature that should only be used if you know what you're doing (for example in; an OS kernel). Here is an example:. .. code-block:: c++. #define GS_RELATIVE __attribute__((address_space(256))); int ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:15965,Energy Efficiency,allocate,allocated,15965,"seen in OpenCL. An example; is:. .. code-block:: c++. typedef float float4 __attribute__((ext_vector_type(4)));; typedef float float2 __attribute__((ext_vector_type(2)));. float4 foo(float2 a, float2 b) {; float4 c;; c.xz = a;; c.yw = b;; return c;; }. Query for this feature with ``__has_attribute(ext_vector_type)``. Giving ``-maltivec`` option to clang enables support for AltiVec vector syntax; and functions. For example:. .. code-block:: c++. vector float foo(vector int a) {; vector int b;; b = vec_add(a, a) + a;; return (vector float)b;; }. NEON vector types are created using ``neon_vector_type`` and; ``neon_polyvector_type`` attributes. For example:. .. code-block:: c++. typedef __attribute__((neon_vector_type(8))) int8_t int8x8_t;; typedef __attribute__((neon_polyvector_type(16))) poly8_t poly8x16_t;. int8x8_t foo(int8x8_t a) {; int8x8_t v;; v = a;; return v;; }. GCC vector types are created using the ``vector_size(N)`` attribute. The; argument ``N`` specifies the number of bytes that will be allocated for an; object of this type. The size has to be multiple of the size of the vector; element type. For example:. .. code-block:: c++. // OK: This declares a vector type with four 'int' elements; typedef int int4 __attribute__((vector_size(4 * sizeof(int))));. // ERROR: '11' is not a multiple of sizeof(int); typedef int int_impossible __attribute__((vector_size(11)));. int4 foo(int4 a) {; int4 v;; v = a;; return v;; }. Boolean Vectors; ---------------. Clang also supports the ext_vector_type attribute with boolean element types in; C and C++. For example:. .. code-block:: c++. // legal for Clang, error for GCC:; typedef bool bool4 __attribute__((ext_vector_type(4)));; // Objects of bool4 type hold 8 bits, sizeof(bool4) == 1. bool4 foo(bool4 a) {; bool4 v;; v = a;; return v;; }. Boolean vectors are a Clang extension of the ext vector type. Boolean vectors; are intended, though not guaranteed, to map to vector mask registers. The size; parameter of a boolean vector t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:17692,Energy Efficiency,power,power,17692,"l4) == 1. bool4 foo(bool4 a) {; bool4 v;; v = a;; return v;; }. Boolean vectors are a Clang extension of the ext vector type. Boolean vectors; are intended, though not guaranteed, to map to vector mask registers. The size; parameter of a boolean vector type is the number of bits in the vector. The; boolean vector is dense and each bit in the boolean vector is one vector; element. The semantics of boolean vectors borrows from C bit-fields with the following; differences:. * Distinct boolean vectors are always distinct memory objects (there is no; packing).; * Only the operators `?:`, `!`, `~`, `|`, `&`, `^` and comparison are allowed on; boolean vectors.; * Casting a scalar bool value to a boolean vector type means broadcasting the; scalar value onto all lanes (same as general ext_vector_type).; * It is not possible to access or swizzle elements of a boolean vector; (different than general ext_vector_type). The size and alignment are both the number of bits rounded up to the next power; of two, but the alignment is at most the maximum vector alignment of the; target. Vector Literals; ---------------. Vector literals can be used to create vectors from a set of scalars, or; vectors. Either parentheses or braces form can be used. In the parentheses; form the number of literal values specified must be one, i.e. referring to a; scalar value, or must match the size of the vector type being created. If a; single scalar literal value is specified, the scalar literal value will be; replicated to all the components of the vector type. In the brackets form any; number of literals can be specified. For example:. .. code-block:: c++. typedef int v4si __attribute__((__vector_size__(16)));; typedef float float4 __attribute__((ext_vector_type(4)));; typedef float float2 __attribute__((ext_vector_type(2)));. v4si vsi = (v4si){1, 2, 3, 4};; float4 vf = (float4)(1.0f, 2.0f, 3.0f, 4.0f);; vector int vi1 = (vector int)(1); // vi1 will be (1, 1, 1, 1).; vector int vi2 = (vector int){1}; //",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:23487,Energy Efficiency,power,power,23487,"======================== ================================================================ =========================================; T __builtin_elementwise_abs(T x) return the absolute value of a number x; the absolute value of signed integer and floating point types; the most negative integer remains the most negative integer; T __builtin_elementwise_fma(T x, T y, T z) fused multiply add, (x * y) + z. floating point types; T __builtin_elementwise_ceil(T x) return the smallest integral value greater than or equal to x floating point types; T __builtin_elementwise_sin(T x) return the sine of x interpreted as an angle in radians floating point types; T __builtin_elementwise_cos(T x) return the cosine of x interpreted as an angle in radians floating point types; T __builtin_elementwise_floor(T x) return the largest integral value less than or equal to x floating point types; T __builtin_elementwise_log(T x) return the natural logarithm of x floating point types; T __builtin_elementwise_log2(T x) return the base 2 logarithm of x floating point types; T __builtin_elementwise_log10(T x) return the base 10 logarithm of x floating point types; T __builtin_elementwise_pow(T x, T y) return x raised to the power of y floating point types; T __builtin_elementwise_bitreverse(T x) return the integer represented after reversing the bits of x integer types; T __builtin_elementwise_exp(T x) returns the base-e exponential, e^x, of the specified value floating point types; T __builtin_elementwise_exp2(T x) returns the base-2 exponential, 2^x, of the specified value floating point types. T __builtin_elementwise_sqrt(T x) return the square root of a floating-point number floating point types; T __builtin_elementwise_roundeven(T x) round x to the nearest integer value in floating point format, floating point types; rounding halfway cases to even (that is, to the nearest value; that is an even integer), regardless of the current rounding; direction.; T __builtin_elementwise_round(T x) rou",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:26655,Energy Efficiency,power,power,26655,"se_min(T x, T y) return x or y, whichever is smaller integer and floating point types; T __builtin_elementwise_add_sat(T x, T y) return the sum of x and y, clamped to the range of integer types; representable values for the signed/unsigned integer type.; T __builtin_elementwise_sub_sat(T x, T y) return the difference of x and y, clamped to the range of integer types; representable values for the signed/unsigned integer type.; =========================================== ================================================================ =========================================. *Reduction Builtins*. Each builtin returns a scalar equivalent to applying the specified; operation(x, y) as recursive even-odd pairwise reduction to all vector; elements. ``operation(x, y)`` is repeatedly applied to each non-overlapping; even-odd element pair with indices ``i * 2`` and ``i * 2 + 1`` with; ``i in [0, Number of elements / 2)``. If the numbers of elements is not a; power of 2, the vector is widened with neutral elements for the reduction; at the end to the next power of 2. Example:. .. code-block:: c++. __builtin_reduce_add([e3, e2, e1, e0]) = __builtin_reduced_add([e3 + e2, e1 + e0]); = (e3 + e2) + (e1 + e0). Let ``VT`` be a vector type and ``ET`` the element type of ``VT``. ======================================= ================================================================ ==================================; Name Operation Supported element types; ======================================= ================================================================ ==================================; ET __builtin_reduce_max(VT a) return x or y, whichever is larger; If exactly one argument is integer and floating point types; a NaN, return the other argument. If both arguments are NaNs,; fmax() return a NaN.; ET __builtin_reduce_min(VT a) return x or y, whichever is smaller; If exactly one argument integer and floating point types; is a NaN, return the other argument. If both arguments are; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:26753,Energy Efficiency,power,power,26753,"se_min(T x, T y) return x or y, whichever is smaller integer and floating point types; T __builtin_elementwise_add_sat(T x, T y) return the sum of x and y, clamped to the range of integer types; representable values for the signed/unsigned integer type.; T __builtin_elementwise_sub_sat(T x, T y) return the difference of x and y, clamped to the range of integer types; representable values for the signed/unsigned integer type.; =========================================== ================================================================ =========================================. *Reduction Builtins*. Each builtin returns a scalar equivalent to applying the specified; operation(x, y) as recursive even-odd pairwise reduction to all vector; elements. ``operation(x, y)`` is repeatedly applied to each non-overlapping; even-odd element pair with indices ``i * 2`` and ``i * 2 + 1`` with; ``i in [0, Number of elements / 2)``. If the numbers of elements is not a; power of 2, the vector is widened with neutral elements for the reduction; at the end to the next power of 2. Example:. .. code-block:: c++. __builtin_reduce_add([e3, e2, e1, e0]) = __builtin_reduced_add([e3 + e2, e1 + e0]); = (e3 + e2) + (e1 + e0). Let ``VT`` be a vector type and ``ET`` the element type of ``VT``. ======================================= ================================================================ ==================================; Name Operation Supported element types; ======================================= ================================================================ ==================================; ET __builtin_reduce_max(VT a) return x or y, whichever is larger; If exactly one argument is integer and floating point types; a NaN, return the other argument. If both arguments are NaNs,; fmax() return a NaN.; ET __builtin_reduce_min(VT a) return x or y, whichever is smaller; If exactly one argument integer and floating point types; is a NaN, return the other argument. If both arguments are; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:31588,Energy Efficiency,reduce,reduced,31588,"ecial semantics of this; type mean that no arithmetic is ever performed directly on ``__fp16`` values;; see below. * ``_Float16`` is supported on the following targets:. * 32-bit ARM (natively on some architecture versions); * 64-bit ARM (AArch64) (natively on ARMv8.2a and above); * AMDGPU (natively); * SPIR (natively); * X86 (if SSE2 is available; natively if AVX512-FP16 is also available); * RISC-V (natively if Zfh or Zhinx is available). * ``__bf16`` is supported on the following targets (currently never natively):. * 32-bit ARM; * 64-bit ARM (AArch64); * RISC-V; * X86 (when SSE2 is available). (For X86, SSE2 is available on 64-bit and all recent 32-bit processors.). ``__fp16`` and ``_Float16`` both use the binary16 format from IEEE; 754-2008, which provides a 5-bit exponent and an 11-bit significand; (counting the implicit leading 1). ``__bf16`` uses the `bfloat16; <https://en.wikipedia.org/wiki/Bfloat16_floating-point_format>`_ format,; which provides an 8-bit exponent and an 8-bit significand; this is the same; exponent range as `float`, just with greatly reduced precision. ``_Float16`` and ``__bf16`` follow the usual rules for arithmetic; floating-point types. Most importantly, this means that arithmetic operations; on operands of these types are formally performed in the type and produce; values of the type. ``__fp16`` does not follow those rules: most operations; immediately promote operands of type ``__fp16`` to ``float``, and so; arithmetic operations are defined to be performed in ``float`` and so result in; a value of type ``float`` (unless further promoted because of other operands).; See below for more information on the exact specifications of these types. When compiling arithmetic on ``_Float16`` and ``__bf16`` for a target without; native support, Clang will perform the arithmetic in ``float``, inserting; extensions and truncations as necessary. This can be done in a way that; exactly matches the operation-by-operation behavior of native support,; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:85938,Energy Efficiency,reduce,reduced,85938,"x[] = { { 1.0f, 1.0f } }; // [0] = (1, 1); complex float x[] = { 1.0f, 1.0f }; // [0] = (1, 0), [1] = (1, 0). This extension also works in C++ mode, as far as that goes, but does not apply; to the C++ ``std::complex``. (In C++11, list initialization allows the same; syntax to be used with ``std::complex`` with the same meaning.). For GCC compatibility, ``__builtin_complex(re, im)`` can also be used to; construct a complex number from the given real and imaginary components. OpenCL Features; ===============. Clang supports internal OpenCL extensions documented below. ``__cl_clang_bitfields``; --------------------------------. With this extension it is possible to enable bitfields in structs; or unions using the OpenCL extension pragma mechanism detailed in; `the OpenCL Extension Specification, section 1.2; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview>`_. Use of bitfields in OpenCL kernels can result in reduced portability as struct; layout is not guaranteed to be consistent when compiled by different compilers.; If structs with bitfields are used as kernel function parameters, it can result; in incorrect functionality when the layout is different between the host and; device code. **Example of Use**:. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_bitfields : enable; struct with_bitfield {; unsigned int i : 5; // compiled - no diagnostic generated; };. #pragma OPENCL EXTENSION __cl_clang_bitfields : disable; struct without_bitfield {; unsigned int i : 5; // error - bitfields are not supported; };. ``__cl_clang_function_pointers``; --------------------------------. With this extension it is possible to enable various language features that; are relying on function pointers using regular OpenCL extension pragma; mechanism detailed in `the OpenCL Extension Specification,; section 1.2; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview>`_. In C++ for OpenCL t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:94072,Energy Efficiency,allocate,allocated,94072,"t(table, index);; return Obj;; }. ``__builtin_wasm_table_size``; -----------------------------. This builtin function returns the size of the WebAssembly table.; Takes the table as an argument and returns an unsigned integer (``size_t``); with the current table size. .. code-block:: c++. typedef void (*__funcref funcref_t)();; static __funcref table[0];. size_t getSize() {; return __builtin_wasm_table_size(table);; }. ``__builtin_wasm_table_grow``; -----------------------------. This builtin function grows the WebAssembly table by a certain amount.; Currently, as all WebAssembly tables created in C/C++ are zero-sized,; this always needs to be called to grow the table. It takes three arguments. The first argument is the WebAssembly table; to grow. The second argument is the reference typed value to store in; the new table entries (the initialization value), and the third argument; is the amount to grow the table by. It returns the previous table size; or -1. It will return -1 if not enough space could be allocated. .. code-block:: c++. typedef void (*__funcref funcref_t)();; static __funcref table[0];. // grow returns the new table size or -1 on error.; int grow(__funcref fn, int delta) {; int prevSize = __builtin_wasm_table_grow(table, fn, delta);; if (prevSize == -1); return -1;; return prevSize + delta;; }. ``__builtin_wasm_table_fill``; -----------------------------. This builtin function sets all the entries of a WebAssembly table to a given; reference typed value. It takes four arguments. The first argument is; the WebAssembly table, the second argument is the index that starts the; range, the third argument is the value to set in the new entries, and; the fourth and the last argument is the size of the range. It returns; nothing. .. code-block:: c++. static __externref_t table[0];. // resets a table by setting all of its entries to a given value.; void reset(__externref_t Obj) {; int Size = __builtin_wasm_table_size(table);; __builtin_wasm_table_fill(table, 0,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:96784,Energy Efficiency,reduce,reduce,96784,"ments from [src, src + nelem - 1] in tableSrc to; // [dst, dst + nelem - 1] in tableDst; void copy(int dst, int src, int nelem) {; __builtin_wasm_table_copy(tableDst, tableSrc, dst, src, nelem);; }. Builtin Functions; =================. Clang supports a number of builtin library functions with the same syntax as; GCC, including things like ``__builtin_nan``, ``__builtin_constant_p``,; ``__builtin_choose_expr``, ``__builtin_types_compatible_p``,; ``__builtin_assume_aligned``, ``__sync_fetch_and_add``, etc. In addition to; the GCC builtins, Clang supports a number of builtins that GCC does not, which; are listed here. Please note that Clang does not and will not support all of the GCC builtins; for vector operations. Instead of using builtins, you should use the functions; defined in target-specific header files like ``<xmmintrin.h>``, which define; portable wrappers for these. Many of the Clang versions of these functions are; implemented directly in terms of :ref:`extended vector support; <langext-vectors>` instead of builtins, in order to reduce the number of; builtins that we need to implement. ``__builtin_alloca``; --------------------. ``__builtin_alloca`` is used to dynamically allocate memory on the stack. Memory; is automatically freed upon function termination. **Syntax**:. .. code-block:: c++. __builtin_alloca(size_t n). **Example of Use**:. .. code-block:: c++. void init(float* data, size_t nbelems);; void process(float* data, size_t nbelems);; int foo(size_t n) {; auto mem = (float*)__builtin_alloca(n * sizeof(float));; init(mem, n);; process(mem, n);; /* mem is automatically freed at this point */; }. **Description**:. ``__builtin_alloca`` is meant to be used to allocate a dynamic amount of memory; on the stack. This amount is subject to stack allocation limits. Query for this feature with ``__has_builtin(__builtin_alloca)``. ``__builtin_alloca_with_align``; -------------------------------. ``__builtin_alloca_with_align`` is used to dynamically allocate m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:96930,Energy Efficiency,allocate,allocate,96930,"; }. Builtin Functions; =================. Clang supports a number of builtin library functions with the same syntax as; GCC, including things like ``__builtin_nan``, ``__builtin_constant_p``,; ``__builtin_choose_expr``, ``__builtin_types_compatible_p``,; ``__builtin_assume_aligned``, ``__sync_fetch_and_add``, etc. In addition to; the GCC builtins, Clang supports a number of builtins that GCC does not, which; are listed here. Please note that Clang does not and will not support all of the GCC builtins; for vector operations. Instead of using builtins, you should use the functions; defined in target-specific header files like ``<xmmintrin.h>``, which define; portable wrappers for these. Many of the Clang versions of these functions are; implemented directly in terms of :ref:`extended vector support; <langext-vectors>` instead of builtins, in order to reduce the number of; builtins that we need to implement. ``__builtin_alloca``; --------------------. ``__builtin_alloca`` is used to dynamically allocate memory on the stack. Memory; is automatically freed upon function termination. **Syntax**:. .. code-block:: c++. __builtin_alloca(size_t n). **Example of Use**:. .. code-block:: c++. void init(float* data, size_t nbelems);; void process(float* data, size_t nbelems);; int foo(size_t n) {; auto mem = (float*)__builtin_alloca(n * sizeof(float));; init(mem, n);; process(mem, n);; /* mem is automatically freed at this point */; }. **Description**:. ``__builtin_alloca`` is meant to be used to allocate a dynamic amount of memory; on the stack. This amount is subject to stack allocation limits. Query for this feature with ``__has_builtin(__builtin_alloca)``. ``__builtin_alloca_with_align``; -------------------------------. ``__builtin_alloca_with_align`` is used to dynamically allocate memory on the; stack while controlling its alignment. Memory is automatically freed upon; function termination. **Syntax**:. .. code-block:: c++. __builtin_alloca_with_align(size_t n, size_t ali",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:97431,Energy Efficiency,allocate,allocate,97431," vector operations. Instead of using builtins, you should use the functions; defined in target-specific header files like ``<xmmintrin.h>``, which define; portable wrappers for these. Many of the Clang versions of these functions are; implemented directly in terms of :ref:`extended vector support; <langext-vectors>` instead of builtins, in order to reduce the number of; builtins that we need to implement. ``__builtin_alloca``; --------------------. ``__builtin_alloca`` is used to dynamically allocate memory on the stack. Memory; is automatically freed upon function termination. **Syntax**:. .. code-block:: c++. __builtin_alloca(size_t n). **Example of Use**:. .. code-block:: c++. void init(float* data, size_t nbelems);; void process(float* data, size_t nbelems);; int foo(size_t n) {; auto mem = (float*)__builtin_alloca(n * sizeof(float));; init(mem, n);; process(mem, n);; /* mem is automatically freed at this point */; }. **Description**:. ``__builtin_alloca`` is meant to be used to allocate a dynamic amount of memory; on the stack. This amount is subject to stack allocation limits. Query for this feature with ``__has_builtin(__builtin_alloca)``. ``__builtin_alloca_with_align``; -------------------------------. ``__builtin_alloca_with_align`` is used to dynamically allocate memory on the; stack while controlling its alignment. Memory is automatically freed upon; function termination. **Syntax**:. .. code-block:: c++. __builtin_alloca_with_align(size_t n, size_t align). **Example of Use**:. .. code-block:: c++. void init(float* data, size_t nbelems);; void process(float* data, size_t nbelems);; int foo(size_t n) {; auto mem = (float*)__builtin_alloca_with_align(; n * sizeof(float),; CHAR_BIT * alignof(float));; init(mem, n);; process(mem, n);; /* mem is automatically freed at this point */; }. **Description**:. ``__builtin_alloca_with_align`` is meant to be used to allocate a dynamic amount of memory; on the stack. It is similar to ``__builtin_alloca`` but accepts a s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:97719,Energy Efficiency,allocate,allocate,97719," support; <langext-vectors>` instead of builtins, in order to reduce the number of; builtins that we need to implement. ``__builtin_alloca``; --------------------. ``__builtin_alloca`` is used to dynamically allocate memory on the stack. Memory; is automatically freed upon function termination. **Syntax**:. .. code-block:: c++. __builtin_alloca(size_t n). **Example of Use**:. .. code-block:: c++. void init(float* data, size_t nbelems);; void process(float* data, size_t nbelems);; int foo(size_t n) {; auto mem = (float*)__builtin_alloca(n * sizeof(float));; init(mem, n);; process(mem, n);; /* mem is automatically freed at this point */; }. **Description**:. ``__builtin_alloca`` is meant to be used to allocate a dynamic amount of memory; on the stack. This amount is subject to stack allocation limits. Query for this feature with ``__has_builtin(__builtin_alloca)``. ``__builtin_alloca_with_align``; -------------------------------. ``__builtin_alloca_with_align`` is used to dynamically allocate memory on the; stack while controlling its alignment. Memory is automatically freed upon; function termination. **Syntax**:. .. code-block:: c++. __builtin_alloca_with_align(size_t n, size_t align). **Example of Use**:. .. code-block:: c++. void init(float* data, size_t nbelems);; void process(float* data, size_t nbelems);; int foo(size_t n) {; auto mem = (float*)__builtin_alloca_with_align(; n * sizeof(float),; CHAR_BIT * alignof(float));; init(mem, n);; process(mem, n);; /* mem is automatically freed at this point */; }. **Description**:. ``__builtin_alloca_with_align`` is meant to be used to allocate a dynamic amount of memory; on the stack. It is similar to ``__builtin_alloca`` but accepts a second; argument whose value is the alignment constraint, as a power of 2 in *bits*. Query for this feature with ``__has_builtin(__builtin_alloca_with_align)``. .. _langext-__builtin_assume:. ``__builtin_assume``; --------------------. ``__builtin_assume`` is used to provide the optimizer",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:98330,Energy Efficiency,allocate,allocate,98330," automatically freed at this point */; }. **Description**:. ``__builtin_alloca`` is meant to be used to allocate a dynamic amount of memory; on the stack. This amount is subject to stack allocation limits. Query for this feature with ``__has_builtin(__builtin_alloca)``. ``__builtin_alloca_with_align``; -------------------------------. ``__builtin_alloca_with_align`` is used to dynamically allocate memory on the; stack while controlling its alignment. Memory is automatically freed upon; function termination. **Syntax**:. .. code-block:: c++. __builtin_alloca_with_align(size_t n, size_t align). **Example of Use**:. .. code-block:: c++. void init(float* data, size_t nbelems);; void process(float* data, size_t nbelems);; int foo(size_t n) {; auto mem = (float*)__builtin_alloca_with_align(; n * sizeof(float),; CHAR_BIT * alignof(float));; init(mem, n);; process(mem, n);; /* mem is automatically freed at this point */; }. **Description**:. ``__builtin_alloca_with_align`` is meant to be used to allocate a dynamic amount of memory; on the stack. It is similar to ``__builtin_alloca`` but accepts a second; argument whose value is the alignment constraint, as a power of 2 in *bits*. Query for this feature with ``__has_builtin(__builtin_alloca_with_align)``. .. _langext-__builtin_assume:. ``__builtin_assume``; --------------------. ``__builtin_assume`` is used to provide the optimizer with a boolean; invariant that is defined to be true. **Syntax**:. .. code-block:: c++. __builtin_assume(bool). **Example of Use**:. .. code-block:: c++. int foo(int x) {; __builtin_assume(x != 0);; // The optimizer may short-circuit this check using the invariant.; if (x == 0); return do_something();; return do_something_else();; }. **Description**:. The boolean argument to this function is defined to be true. The optimizer may; analyze the form of the expression provided as the argument and deduce from; that information used to optimize the program. If the condition is violated; during execution",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:98496,Energy Efficiency,power,power,98496,"c amount of memory; on the stack. This amount is subject to stack allocation limits. Query for this feature with ``__has_builtin(__builtin_alloca)``. ``__builtin_alloca_with_align``; -------------------------------. ``__builtin_alloca_with_align`` is used to dynamically allocate memory on the; stack while controlling its alignment. Memory is automatically freed upon; function termination. **Syntax**:. .. code-block:: c++. __builtin_alloca_with_align(size_t n, size_t align). **Example of Use**:. .. code-block:: c++. void init(float* data, size_t nbelems);; void process(float* data, size_t nbelems);; int foo(size_t n) {; auto mem = (float*)__builtin_alloca_with_align(; n * sizeof(float),; CHAR_BIT * alignof(float));; init(mem, n);; process(mem, n);; /* mem is automatically freed at this point */; }. **Description**:. ``__builtin_alloca_with_align`` is meant to be used to allocate a dynamic amount of memory; on the stack. It is similar to ``__builtin_alloca`` but accepts a second; argument whose value is the alignment constraint, as a power of 2 in *bits*. Query for this feature with ``__has_builtin(__builtin_alloca_with_align)``. .. _langext-__builtin_assume:. ``__builtin_assume``; --------------------. ``__builtin_assume`` is used to provide the optimizer with a boolean; invariant that is defined to be true. **Syntax**:. .. code-block:: c++. __builtin_assume(bool). **Example of Use**:. .. code-block:: c++. int foo(int x) {; __builtin_assume(x != 0);; // The optimizer may short-circuit this check using the invariant.; if (x == 0); return do_something();; return do_something_else();; }. **Description**:. The boolean argument to this function is defined to be true. The optimizer may; analyze the form of the expression provided as the argument and deduce from; that information used to optimize the program. If the condition is violated; during execution, the behavior is undefined. The argument itself is never; evaluated, so any side effects of the expression will be discar",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:99779,Energy Efficiency,allocate,allocated,99779,"er with a boolean; invariant that is defined to be true. **Syntax**:. .. code-block:: c++. __builtin_assume(bool). **Example of Use**:. .. code-block:: c++. int foo(int x) {; __builtin_assume(x != 0);; // The optimizer may short-circuit this check using the invariant.; if (x == 0); return do_something();; return do_something_else();; }. **Description**:. The boolean argument to this function is defined to be true. The optimizer may; analyze the form of the expression provided as the argument and deduce from; that information used to optimize the program. If the condition is violated; during execution, the behavior is undefined. The argument itself is never; evaluated, so any side effects of the expression will be discarded. Query for this feature with ``__has_builtin(__builtin_assume)``. .. _langext-__builtin_assume_separate_storage:. ``__builtin_assume_separate_storage``; -------------------------------------. ``__builtin_assume_separate_storage`` is used to provide the optimizer with the; knowledge that its two arguments point to separately allocated objects. **Syntax**:. .. code-block:: c++. __builtin_assume_separate_storage(const volatile void *, const volatile void *). **Example of Use**:. .. code-block:: c++. int foo(int *x, int *y) {; __builtin_assume_separate_storage(x, y);; *x = 0;; *y = 1;; // The optimizer may optimize this to return 0 without reloading from *x.; return *x;; }. **Description**:. The arguments to this function are assumed to point into separately allocated; storage (either different variable definitions or different dynamic storage; allocations). The optimizer may use this fact to aid in alias analysis. If the; arguments point into the same storage, the behavior is undefined. Note that the; definition of ""storage"" here refers to the outermost enclosing allocation of any; particular object (so for example, it's never correct to call this function; passing the addresses of fields in the same struct, elements of the same array,; etc.). Query f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:100218,Energy Efficiency,allocate,allocated,100218,"that information used to optimize the program. If the condition is violated; during execution, the behavior is undefined. The argument itself is never; evaluated, so any side effects of the expression will be discarded. Query for this feature with ``__has_builtin(__builtin_assume)``. .. _langext-__builtin_assume_separate_storage:. ``__builtin_assume_separate_storage``; -------------------------------------. ``__builtin_assume_separate_storage`` is used to provide the optimizer with the; knowledge that its two arguments point to separately allocated objects. **Syntax**:. .. code-block:: c++. __builtin_assume_separate_storage(const volatile void *, const volatile void *). **Example of Use**:. .. code-block:: c++. int foo(int *x, int *y) {; __builtin_assume_separate_storage(x, y);; *x = 0;; *y = 1;; // The optimizer may optimize this to return 0 without reloading from *x.; return *x;; }. **Description**:. The arguments to this function are assumed to point into separately allocated; storage (either different variable definitions or different dynamic storage; allocations). The optimizer may use this fact to aid in alias analysis. If the; arguments point into the same storage, the behavior is undefined. Note that the; definition of ""storage"" here refers to the outermost enclosing allocation of any; particular object (so for example, it's never correct to call this function; passing the addresses of fields in the same struct, elements of the same array,; etc.). Query for this feature with ``__has_builtin(__builtin_assume_separate_storage)``. ``__builtin_offsetof``; ----------------------. ``__builtin_offsetof`` is used to implement the ``offsetof`` macro, which; calculates the offset (in bytes) to a given member of the given type. **Syntax**:. .. code-block:: c++. __builtin_offsetof(type-name, member-designator). **Example of Use**:. .. code-block:: c++. struct S {; char c;; int i;; struct T {; float f[2];; } t;; };. const int offset_to_i = __builtin_offsetof(struct S, i)",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:117088,Energy Efficiency,efficient,efficient,117088,"case of *read write* access, ``1`` is to be used. ``locality``; indicates the expected persistence of data in cache, from ``0`` which means that; data can be discarded from cache after its next use to ``3`` which means that; data is going to be reused a lot once in cache. ``1`` and ``2`` provide; intermediate behavior between these two extremes. Query for this feature with ``__has_builtin(__builtin_prefetch)``. ``__sync_swap``; ---------------. ``__sync_swap`` is used to atomically swap integers or pointers in memory. **Syntax**:. .. code-block:: c++. type __sync_swap(type *ptr, type value, ...). **Example of Use**:. .. code-block:: c++. int old_value = __sync_swap(&value, new_value);. **Description**:. The ``__sync_swap()`` builtin extends the existing ``__sync_*()`` family of; atomic intrinsics to allow code to atomically swap the current value with the; new value. More importantly, it helps developers write more efficient and; correct code by avoiding expensive loops around; ``__sync_bool_compare_and_swap()`` or relying on the platform specific; implementation details of ``__sync_lock_test_and_set()``. The; ``__sync_swap()`` builtin is a full barrier. ``__builtin_addressof``; -----------------------. ``__builtin_addressof`` performs the functionality of the built-in ``&``; operator, ignoring any ``operator&`` overload. This is useful in constant; expressions in C++11, where there is no other way to take the address of an; object that overloads ``operator&``. Clang automatically adds; ``[[clang::lifetimebound]]`` to the parameter of ``__builtin_addressof``. **Example of use**:. .. code-block:: c++. template<typename T> constexpr T *addressof(T &value) {; return __builtin_addressof(value);; }. ``__builtin_function_start``; -----------------------------. ``__builtin_function_start`` returns the address of a function body. **Syntax**:. .. code-block:: c++. void *__builtin_function_start(function). **Example of use**:. .. code-block:: c++. void a() {}; void *p = __buil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:128769,Energy Efficiency,power,power,128769,"signed long long x, unsigned long long y, unsigned long long *prod);; bool __builtin_sadd_overflow (int x, int y, int *sum);; bool __builtin_saddl_overflow (long x, long y, long *sum);; bool __builtin_saddll_overflow(long long x, long long y, long long *sum);; bool __builtin_ssub_overflow (int x, int y, int *diff);; bool __builtin_ssubl_overflow (long x, long y, long *diff);; bool __builtin_ssubll_overflow(long long x, long long y, long long *diff);; bool __builtin_smul_overflow (int x, int y, int *prod);; bool __builtin_smull_overflow (long x, long y, long *prod);; bool __builtin_smulll_overflow(long long x, long long y, long long *prod);. Each builtin performs the specified mathematical operation on the; first two arguments and stores the result in the third argument. If; possible, the result will be equal to mathematically-correct result; and the builtin will return 0. Otherwise, the builtin will return; 1 and the result will be equal to the unique value that is equivalent; to the mathematically-correct result modulo two raised to the *k*; power, where *k* is the number of bits in the result type. The; behavior of these builtins is well-defined for all argument values. The first three builtins work generically for operands of any integer type,; including boolean types. The operands need not have the same type as each; other, or as the result. The other builtins may implicitly promote or; convert their operands before performing the operation. Query for this feature with ``__has_builtin(__builtin_add_overflow)``, etc. Floating point builtins; ---------------------------------------. ``__builtin_isfpclass``; -----------------------. ``__builtin_isfpclass`` is used to test if the specified floating-point values; fall into one of the specified floating-point classes. **Syntax**:. .. code-block:: c++. int __builtin_isfpclass(fp_type expr, int mask); int_vector __builtin_isfpclass(fp_vector expr, int mask). **Example of use**:. .. code-block:: c++. if (__builtin_isfpcla",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:138182,Energy Efficiency,efficient,efficient,138182,"s ``dest`` as a copy of ``src``. It is undefined; behavior to call this function with an already initialized ``dest`` argument. Memory builtins; ---------------. Clang provides constant expression evaluation support for builtin forms of the; following functions from the C standard library headers; ``<string.h>`` and ``<wchar.h>``:. * ``memcpy``; * ``memmove``; * ``wmemcpy``; * ``wmemmove``. In each case, the builtin form has the name of the C library function prefixed; by ``__builtin_``. Constant evaluation support is only provided when the source and destination; are pointers to arrays with the same trivially copyable element type, and the; given size is an exact multiple of the element size that is no greater than; the number of elements accessible through the source and destination operands. Guaranteed inlined copy; ^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c. void __builtin_memcpy_inline(void *dst, const void *src, size_t size);. ``__builtin_memcpy_inline`` has been designed as a building block for efficient; ``memcpy`` implementations. It is identical to ``__builtin_memcpy`` but also; guarantees not to call any external functions. See LLVM IR `llvm.memcpy.inline; <https://llvm.org/docs/LangRef.html#llvm-memcpy-inline-intrinsic>`_ intrinsic; for more information. This is useful to implement a custom version of ``memcpy``, implement a; ``libc`` memcpy or work around the absence of a ``libc``. Note that the `size` argument must be a compile time constant. Note that this intrinsic cannot yet be called in a ``constexpr`` context. Guaranteed inlined memset; ^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c. void __builtin_memset_inline(void *dst, int value, size_t size);. ``__builtin_memset_inline`` has been designed as a building block for efficient; ``memset`` implementations. It is identical to ``__builtin_memset`` but also; guarantees not to call any external functions. See LLVM IR `llvm.memset.inline; <https://llvm.org/docs/LangRef.html#llvm-memset-inline-intrinsic>`_ ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:138929,Energy Efficiency,efficient,efficient,138929,"ts accessible through the source and destination operands. Guaranteed inlined copy; ^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c. void __builtin_memcpy_inline(void *dst, const void *src, size_t size);. ``__builtin_memcpy_inline`` has been designed as a building block for efficient; ``memcpy`` implementations. It is identical to ``__builtin_memcpy`` but also; guarantees not to call any external functions. See LLVM IR `llvm.memcpy.inline; <https://llvm.org/docs/LangRef.html#llvm-memcpy-inline-intrinsic>`_ intrinsic; for more information. This is useful to implement a custom version of ``memcpy``, implement a; ``libc`` memcpy or work around the absence of a ``libc``. Note that the `size` argument must be a compile time constant. Note that this intrinsic cannot yet be called in a ``constexpr`` context. Guaranteed inlined memset; ^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c. void __builtin_memset_inline(void *dst, int value, size_t size);. ``__builtin_memset_inline`` has been designed as a building block for efficient; ``memset`` implementations. It is identical to ``__builtin_memset`` but also; guarantees not to call any external functions. See LLVM IR `llvm.memset.inline; <https://llvm.org/docs/LangRef.html#llvm-memset-inline-intrinsic>`_ intrinsic; for more information. This is useful to implement a custom version of ``memset``, implement a; ``libc`` memset or work around the absence of a ``libc``. Note that the `size` argument must be a compile time constant. Note that this intrinsic cannot yet be called in a ``constexpr`` context. Atomic Min/Max builtins with memory ordering; --------------------------------------------. There are two atomic builtins with min/max in-memory comparison and swap.; The syntax and semantics are similar to GCC-compatible __atomic_* builtins. * ``__atomic_fetch_min``; * ``__atomic_fetch_max``. The builtins work with signed and unsigned integers and require to specify memory ordering.; The return value is the original value that was stored in ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:144118,Energy Efficiency,monitor,monitor,144118," controls whether or not the atomic operation is ordered with respect to the; whole system, the current device, an OpenCL workgroup, wavefront, or just a; single thread. If these are used on a target that does not support atomic; scopes, then they will behave exactly as the standard GNU atomic builtins. Low-level ARM exclusive memory builtins; ---------------------------------------. Clang provides overloaded builtins giving direct access to the three key ARM; instructions for implementing atomic operations. .. code-block:: c. T __builtin_arm_ldrex(const volatile T *addr);; T __builtin_arm_ldaex(const volatile T *addr);; int __builtin_arm_strex(T val, volatile T *addr);; int __builtin_arm_stlex(T val, volatile T *addr);; void __builtin_arm_clrex(void);. The types ``T`` currently supported are:. * Integer types with width at most 64 bits (or 128 bits on AArch64).; * Floating-point types; * Pointer types. Note that the compiler does not guarantee it will not insert stores which clear; the exclusive monitor in between an ``ldrex`` type operation and its paired; ``strex``. In practice this is only usually a risk when the extra store is on; the same cache line as the variable being modified and Clang will only insert; stack stores on its own, so it is best not to use these operations on variables; with automatic storage duration. Also, loads and stores may be implicit in code written between the ``ldrex`` and; ``strex``. Clang will not necessarily mitigate the effects of these either, so; care should be exercised. For these reasons the higher level atomic primitives should be preferred where; possible. Non-temporal load/store builtins; --------------------------------. Clang provides overloaded builtins allowing generation of non-temporal memory; accesses. .. code-block:: c. T __builtin_nontemporal_load(T *addr);; void __builtin_nontemporal_store(T value, T *addr);. The types ``T`` currently supported are:. * Integer types.; * Floating-point types.; * Vector types. Note t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:153117,Energy Efficiency,power,power,153117,"iciently aligned, it is returned unchanged.; The builtin ``__builtin_is_aligned`` returns whether the first argument is; aligned to a multiple of the second argument.; All of these builtins expect the alignment to be expressed as a number of bytes. These builtins can be used for all integer types as well as (non-function); pointer types. For pointer types, these builtins operate in terms of the integer; address of the pointer and return a new pointer of the same type (including; qualifiers such as ``const``) with an adjusted address.; When aligning pointers up or down, the resulting value must be within the same; underlying allocation or one past the end (see C17 6.5.6p8, C++ [expr.add]).; This means that arbitrary integer values stored in pointer-type variables must; not be passed to these builtins. For those use cases, the builtins can still be; used, but the operation must be performed on the pointer cast to ``uintptr_t``. If Clang can determine that the alignment is not a power of two at compile time,; it will result in a compilation failure. If the alignment argument is not a; power of two at run time, the behavior of these builtins is undefined. Non-standard C++11 Attributes; =============================. Clang's non-standard C++11 attributes live in the ``clang`` attribute; namespace. Clang supports GCC's ``gnu`` attribute namespace. All GCC attributes which; are accepted with the ``__attribute__((foo))`` syntax are also accepted as; ``[[gnu::foo]]``. This only extends to attributes which are specified by GCC; (see the list of `GCC function attributes; <https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html>`_, `GCC variable; attributes <https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html>`_, and; `GCC type attributes; <https://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html>`_). As with the GCC; implementation, these attributes must appertain to the *declarator-id* in a; declaration, which means they must go either at the start of the declaratio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:153225,Energy Efficiency,power,power,153225,"t is; aligned to a multiple of the second argument.; All of these builtins expect the alignment to be expressed as a number of bytes. These builtins can be used for all integer types as well as (non-function); pointer types. For pointer types, these builtins operate in terms of the integer; address of the pointer and return a new pointer of the same type (including; qualifiers such as ``const``) with an adjusted address.; When aligning pointers up or down, the resulting value must be within the same; underlying allocation or one past the end (see C17 6.5.6p8, C++ [expr.add]).; This means that arbitrary integer values stored in pointer-type variables must; not be passed to these builtins. For those use cases, the builtins can still be; used, but the operation must be performed on the pointer cast to ``uintptr_t``. If Clang can determine that the alignment is not a power of two at compile time,; it will result in a compilation failure. If the alignment argument is not a; power of two at run time, the behavior of these builtins is undefined. Non-standard C++11 Attributes; =============================. Clang's non-standard C++11 attributes live in the ``clang`` attribute; namespace. Clang supports GCC's ``gnu`` attribute namespace. All GCC attributes which; are accepted with the ``__attribute__((foo))`` syntax are also accepted as; ``[[gnu::foo]]``. This only extends to attributes which are specified by GCC; (see the list of `GCC function attributes; <https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html>`_, `GCC variable; attributes <https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html>`_, and; `GCC type attributes; <https://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html>`_). As with the GCC; implementation, these attributes must appertain to the *declarator-id* in a; declaration, which means they must go either at the start of the declaration or; immediately after the name being declared. For example, this applies the GNU ``unused`` attribute to ``a`` an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:165920,Energy Efficiency,efficient,efficient,165920,"e vectorizer may decide to fall back on fixed width; vectorization if the target does not support scalable vectors. The interleave count is specified by ``interleave_count(_value_)``, where; _value_ is a positive integer. This is useful for specifying the optimal; width/count of the set of target architectures supported by your application. .. code-block:: c++. #pragma clang loop vectorize_width(2); #pragma clang loop interleave_count(2); for(...) {; ...; }. Specifying a width/count of 1 disables the optimization, and is equivalent to; ``vectorize(disable)`` or ``interleave(disable)``. Vector predication is enabled by ``vectorize_predicate(enable)``, for example:. .. code-block:: c++. #pragma clang loop vectorize(enable); #pragma clang loop vectorize_predicate(enable); for(...) {; ...; }. This predicates (masks) all instructions in the loop, which allows the scalar; remainder loop (the tail) to be folded into the main vectorized loop. This; might be more efficient when vector predication is efficiently supported by the; target platform. Loop Unrolling; --------------. Unrolling a loop reduces the loop control overhead and exposes more; opportunities for ILP. Loops can be fully or partially unrolled. Full unrolling; eliminates the loop and replaces it with an enumerated sequence of loop; iterations. Full unrolling is only possible if the loop trip count is known at; compile time. Partial unrolling replicates the loop body within the loop and; reduces the trip count. If ``unroll(enable)`` is specified the unroller will attempt to fully unroll the; loop if the trip count is known at compile time. If the fully unrolled code size; is greater than an internal limit the loop will be partially unrolled up to this; limit. If the trip count is not known at compile time the loop will be partially; unrolled with a heuristically chosen unroll factor. .. code-block:: c++. #pragma clang loop unroll(enable); for(...) {; ...; }. If ``unroll(full)`` is specified the unroller will att",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:165957,Energy Efficiency,efficient,efficiently,165957,"e vectorizer may decide to fall back on fixed width; vectorization if the target does not support scalable vectors. The interleave count is specified by ``interleave_count(_value_)``, where; _value_ is a positive integer. This is useful for specifying the optimal; width/count of the set of target architectures supported by your application. .. code-block:: c++. #pragma clang loop vectorize_width(2); #pragma clang loop interleave_count(2); for(...) {; ...; }. Specifying a width/count of 1 disables the optimization, and is equivalent to; ``vectorize(disable)`` or ``interleave(disable)``. Vector predication is enabled by ``vectorize_predicate(enable)``, for example:. .. code-block:: c++. #pragma clang loop vectorize(enable); #pragma clang loop vectorize_predicate(enable); for(...) {; ...; }. This predicates (masks) all instructions in the loop, which allows the scalar; remainder loop (the tail) to be folded into the main vectorized loop. This; might be more efficient when vector predication is efficiently supported by the; target platform. Loop Unrolling; --------------. Unrolling a loop reduces the loop control overhead and exposes more; opportunities for ILP. Loops can be fully or partially unrolled. Full unrolling; eliminates the loop and replaces it with an enumerated sequence of loop; iterations. Full unrolling is only possible if the loop trip count is known at; compile time. Partial unrolling replicates the loop body within the loop and; reduces the trip count. If ``unroll(enable)`` is specified the unroller will attempt to fully unroll the; loop if the trip count is known at compile time. If the fully unrolled code size; is greater than an internal limit the loop will be partially unrolled up to this; limit. If the trip count is not known at compile time the loop will be partially; unrolled with a heuristically chosen unroll factor. .. code-block:: c++. #pragma clang loop unroll(enable); for(...) {; ...; }. If ``unroll(full)`` is specified the unroller will att",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:166053,Energy Efficiency,reduce,reduces,166053," count is specified by ``interleave_count(_value_)``, where; _value_ is a positive integer. This is useful for specifying the optimal; width/count of the set of target architectures supported by your application. .. code-block:: c++. #pragma clang loop vectorize_width(2); #pragma clang loop interleave_count(2); for(...) {; ...; }. Specifying a width/count of 1 disables the optimization, and is equivalent to; ``vectorize(disable)`` or ``interleave(disable)``. Vector predication is enabled by ``vectorize_predicate(enable)``, for example:. .. code-block:: c++. #pragma clang loop vectorize(enable); #pragma clang loop vectorize_predicate(enable); for(...) {; ...; }. This predicates (masks) all instructions in the loop, which allows the scalar; remainder loop (the tail) to be folded into the main vectorized loop. This; might be more efficient when vector predication is efficiently supported by the; target platform. Loop Unrolling; --------------. Unrolling a loop reduces the loop control overhead and exposes more; opportunities for ILP. Loops can be fully or partially unrolled. Full unrolling; eliminates the loop and replaces it with an enumerated sequence of loop; iterations. Full unrolling is only possible if the loop trip count is known at; compile time. Partial unrolling replicates the loop body within the loop and; reduces the trip count. If ``unroll(enable)`` is specified the unroller will attempt to fully unroll the; loop if the trip count is known at compile time. If the fully unrolled code size; is greater than an internal limit the loop will be partially unrolled up to this; limit. If the trip count is not known at compile time the loop will be partially; unrolled with a heuristically chosen unroll factor. .. code-block:: c++. #pragma clang loop unroll(enable); for(...) {; ...; }. If ``unroll(full)`` is specified the unroller will attempt to fully unroll the; loop if the trip count is known at compile time identically to; ``unroll(enable)``. However, with ``unro",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:166417,Energy Efficiency,reduce,reduces,166417,"r(...) {; ...; }. Specifying a width/count of 1 disables the optimization, and is equivalent to; ``vectorize(disable)`` or ``interleave(disable)``. Vector predication is enabled by ``vectorize_predicate(enable)``, for example:. .. code-block:: c++. #pragma clang loop vectorize(enable); #pragma clang loop vectorize_predicate(enable); for(...) {; ...; }. This predicates (masks) all instructions in the loop, which allows the scalar; remainder loop (the tail) to be folded into the main vectorized loop. This; might be more efficient when vector predication is efficiently supported by the; target platform. Loop Unrolling; --------------. Unrolling a loop reduces the loop control overhead and exposes more; opportunities for ILP. Loops can be fully or partially unrolled. Full unrolling; eliminates the loop and replaces it with an enumerated sequence of loop; iterations. Full unrolling is only possible if the loop trip count is known at; compile time. Partial unrolling replicates the loop body within the loop and; reduces the trip count. If ``unroll(enable)`` is specified the unroller will attempt to fully unroll the; loop if the trip count is known at compile time. If the fully unrolled code size; is greater than an internal limit the loop will be partially unrolled up to this; limit. If the trip count is not known at compile time the loop will be partially; unrolled with a heuristically chosen unroll factor. .. code-block:: c++. #pragma clang loop unroll(enable); for(...) {; ...; }. If ``unroll(full)`` is specified the unroller will attempt to fully unroll the; loop if the trip count is known at compile time identically to; ``unroll(enable)``. However, with ``unroll(full)`` the loop will not be unrolled; if the loop count is not known at compile time. .. code-block:: c++. #pragma clang loop unroll(full); for(...) {; ...; }. The unroll count can be specified explicitly with ``unroll_count(_value_)`` where; _value_ is a positive integer. If this value is greater than the tri",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:168743,Energy Efficiency,reduce,reduced,168743,"-unroll-count=n` and `-mllvm -pragma-unroll-threshold=n`. Loop Distribution; -----------------. Loop Distribution allows splitting a loop into multiple loops. This is; beneficial for example when the entire loop cannot be vectorized but some of the; resulting loops can. If ``distribute(enable))`` is specified and the loop has memory dependencies; that inhibit vectorization, the compiler will attempt to isolate the offending; operations into a new loop. This optimization is not enabled by default, only; loops marked with the pragma are considered. .. code-block:: c++. #pragma clang loop distribute(enable); for (i = 0; i < N; ++i) {; S1: A[i + 1] = A[i] + B[i];; S2: C[i] = D[i] * E[i];; }. This loop will be split into two loops between statements S1 and S2. The; second loop containing S2 will be vectorized. Loop Distribution is currently not enabled by default in the optimizer because; it can hurt performance in some cases. For example, instruction-level; parallelism could be reduced by sequentializing the execution of the; statements S1 and S2 above. If Loop Distribution is turned on globally with; ``-mllvm -enable-loop-distribution``, specifying ``distribute(disable)`` can; be used the disable it on a per-loop basis. Additional Information; ----------------------. For convenience multiple loop hints can be specified on a single line. .. code-block:: c++. #pragma clang loop vectorize_width(4) interleave_count(8); for(...) {; ...; }. If an optimization cannot be applied any hints that apply to it will be ignored.; For example, the hint ``vectorize_width(4)`` is ignored if the loop is not; proven safe to vectorize. To identify and diagnose optimization issues use; `-Rpass`, `-Rpass-missed`, and `-Rpass-analysis` command line options. See the; user guide for details. Extensions to specify floating-point flags; ====================================================. The ``#pragma clang fp`` pragma allows floating-point options to be specified; for a section of the source c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:716,Integrability,depend,depend,716,"=========================; Clang Language Extensions; =========================. .. contents::; :local:; :depth: 1. .. toctree::; :hidden:. ObjectiveCLiterals; BlockLanguageSpec; Block-ABI-Apple; AutomaticReferenceCounting; MatrixTypes. Introduction; ============. This document describes the language extensions provided by Clang. In addition; to the language extensions listed here, Clang aims to support a broad range of; GCC extensions. Please see the `GCC manual; <https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html>`_ for more information on; these extensions. .. _langext-feature_check:. Feature Checking Macros; =======================. Language extensions can be very useful, but only if you know you can depend on; them. In order to allow fine-grain features checks, we support three builtin; function-like macros. This allows you to directly test for a feature in your; code without having to resort to something like autoconf or fragile ""compiler; version checks"". ``__has_builtin``; -----------------. This function-like macro takes a single identifier argument that is the name of; a builtin function, a builtin pseudo-function (taking one or more type; arguments), or a builtin template.; It evaluates to 1 if the builtin is supported or 0 if not.; It can be used like this:. .. code-block:: c++. #ifndef __has_builtin // Optional of course.; #define __has_builtin(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_builtin(__builtin_trap); __builtin_trap();; #else; abort();; #endif; ... .. note::. Prior to Clang 10, ``__has_builtin`` could not be used to detect most builtin; pseudo-functions. ``__has_builtin`` should not be used to detect support for a builtin macro;; use ``#ifdef`` instead. ``__has_constexpr_builtin``; ---------------------------. This function-like macro takes a single identifier argument that is the name of; a builtin function, a builtin pseudo-function (taking one or more type; arguments), or a builtin template.; It evaluates to 1 ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:12498,Integrability,depend,dependent,12498," #endif. // To avoid problem with non-clang compilers not having this macro.; #if defined(__has_include_next); #if __has_include_next(""myinclude.h""); # include_next ""myinclude.h""; #endif; #endif. Note that ``__has_include_next``, like the GNU extension ``#include_next``; directive, is intended for use in headers only, and will issue a warning if; used in the top-level compilation file. A warning will also be issued if an; absolute path is used in the file argument. ``__has_warning``; -----------------. This function-like macro takes a string literal that represents a command line; option for a warning and returns true if that is a valid warning option. .. code-block:: c++. #if __has_warning(""-Wformat""); ...; #endif. .. _languageextensions-builtin-macros:. Builtin Macros; ==============. ``__BASE_FILE__``; Defined to a string that contains the name of the main input file passed to; Clang. ``__FILE_NAME__``; Clang-specific extension that functions similar to ``__FILE__`` but only; renders the last path component (the filename) instead of an invocation; dependent full path to that file. ``__COUNTER__``; Defined to an integer value that starts at zero and is incremented each time; the ``__COUNTER__`` macro is expanded. ``__INCLUDE_LEVEL__``; Defined to an integral value that is the include depth of the file currently; being translated. For the main file, this value is zero. ``__TIMESTAMP__``; Defined to the date and time of the last modification of the current source; file. ``__clang__``; Defined when compiling with Clang. ``__clang_major__``; Defined to the major marketing version number of Clang (e.g., the 2 in; 2.0.1). Note that marketing version numbers should not be used to check for; language features, as different vendors use different numbering schemes.; Instead, use the :ref:`langext-feature_check`. ``__clang_minor__``; Defined to the minor version number of Clang (e.g., the 0 in 2.0.1). Note; that marketing version numbers should not be used to check for langu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:20085,Integrability,depend,depending,20085,"hat an operation is not accepted according to a corresponding; specification. ============================== ======= ======= ============= ======= =====; Operator OpenCL AltiVec GCC NEON SVE; ============================== ======= ======= ============= ======= =====; [] yes yes yes yes yes; unary operators +, -- yes yes yes yes yes; ++, -- -- yes yes yes no no; +,--,*,/,% yes yes yes yes yes; bitwise operators &,|,^,~ yes yes yes yes yes; >>,<< yes yes yes yes yes; !, &&, || yes -- yes yes yes; ==, !=, >, <, >=, <= yes yes yes yes yes; = yes yes yes yes yes; ?: [#]_ yes -- yes yes yes; sizeof yes yes yes yes yes [#]_; C-style cast yes yes yes no no; reinterpret_cast yes no yes no no; static_cast yes no yes no no; const_cast no no no no no; address &v[i] no no no [#]_ no no; ============================== ======= ======= ============= ======= =====. See also :ref:`langext-__builtin_shufflevector`, :ref:`langext-__builtin_convertvector`. .. [#] ternary operator(?:) has different behaviors depending on condition; operand's vector type. If the condition is a GNU vector (i.e. __vector_size__),; a NEON vector or an SVE vector, it's only available in C++ and uses normal bool; conversions (that is, != 0).; If it's an extension (OpenCL) vector, it's only available in C and OpenCL C.; And it selects base on signedness of the condition operands (OpenCL v1.1 s6.3.9).; .. [#] sizeof can only be used on vector length specific SVE types.; .. [#] Clang does not allow the address of an element to be taken while GCC; allows this. This is intentional for vectors with a boolean element type and; not implemented otherwise. Vector Builtins; ---------------. **Note: The implementation of vector builtins is work-in-progress and incomplete.**. In addition to the operators mentioned above, Clang provides a set of builtins; to perform additional operations on certain scalar and vector types. Let ``T`` be one of the following types:. * an integer type (as in C23 6.2.5p22), but excluding enumer",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:35795,Integrability,message,message,35795,"ands are always immediately promoted to ``float``, the; common real type of ``__fp16`` and ``_Float16`` for the purposes of the usual; arithmetic conversions is ``float``. A literal can be given ``_Float16`` type using the suffix ``f16``. For example,; ``3.14f16``. Because default argument promotion only applies to the standard floating-point; types, ``_Float16`` values are not promoted to ``double`` when passed as variadic; or untyped arguments. As a consequence, some caution must be taken when using; certain library facilities with ``_Float16``; for example, there is no ``printf`` format; specifier for ``_Float16``, and (unlike ``float``) it will not be implicitly promoted to; ``double`` when passed to ``printf``, so the programmer must explicitly cast it to; ``double`` before using it with an ``%f`` or similar specifier. Messages on ``deprecated`` and ``unavailable`` Attributes; =========================================================. An optional string message can be added to the ``deprecated`` and; ``unavailable`` attributes. For example:. .. code-block:: c++. void explode(void) __attribute__((deprecated(""extremely unsafe, use 'combust' instead!!!"")));. If the deprecated or unavailable declaration is used, the message will be; incorporated into the appropriate diagnostic:. .. code-block:: none. harmless.c:4:3: warning: 'explode' is deprecated: extremely unsafe, use 'combust' instead!!!; [-Wdeprecated-declarations]; explode();; ^. Query for this feature with; ``__has_extension(attribute_deprecated_with_message)`` and; ``__has_extension(attribute_unavailable_with_message)``. Attributes on Enumerators; =========================. Clang allows attributes to be written on individual enumerators. This allows; enumerators to be deprecated, made unavailable, etc. The attribute must appear; after the enumerator name and before any initializer, like so:. .. code-block:: c++. enum OperationMode {; OM_Invalid,; OM_Normal,; OM_Terrified __attribute__((deprecated)),; OM_Abor",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:36059,Integrability,message,message,36059,"For example,; ``3.14f16``. Because default argument promotion only applies to the standard floating-point; types, ``_Float16`` values are not promoted to ``double`` when passed as variadic; or untyped arguments. As a consequence, some caution must be taken when using; certain library facilities with ``_Float16``; for example, there is no ``printf`` format; specifier for ``_Float16``, and (unlike ``float``) it will not be implicitly promoted to; ``double`` when passed to ``printf``, so the programmer must explicitly cast it to; ``double`` before using it with an ``%f`` or similar specifier. Messages on ``deprecated`` and ``unavailable`` Attributes; =========================================================. An optional string message can be added to the ``deprecated`` and; ``unavailable`` attributes. For example:. .. code-block:: c++. void explode(void) __attribute__((deprecated(""extremely unsafe, use 'combust' instead!!!"")));. If the deprecated or unavailable declaration is used, the message will be; incorporated into the appropriate diagnostic:. .. code-block:: none. harmless.c:4:3: warning: 'explode' is deprecated: extremely unsafe, use 'combust' instead!!!; [-Wdeprecated-declarations]; explode();; ^. Query for this feature with; ``__has_extension(attribute_deprecated_with_message)`` and; ``__has_extension(attribute_unavailable_with_message)``. Attributes on Enumerators; =========================. Clang allows attributes to be written on individual enumerators. This allows; enumerators to be deprecated, made unavailable, etc. The attribute must appear; after the enumerator name and before any initializer, like so:. .. code-block:: c++. enum OperationMode {; OM_Invalid,; OM_Normal,; OM_Terrified __attribute__((deprecated)),; OM_AbortOnError __attribute__((deprecated)) = 4; };. Attributes on the ``enum`` declaration do not apply to individual enumerators. Query for this feature with ``__has_extension(enumerator_attributes)``. C++11 Attributes on using-declarations; =",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:65380,Integrability,depend,depending,65380,"g): Determines whether a; reference of type ``T`` bound to an expression of type ``U`` would bind to a; materialized temporary object. If ``T`` is not a reference type the result; is false. Note this trait will also return false when the initialization of; ``T`` from ``U`` is ill-formed.; Deprecated, use ``__reference_constructs_from_temporary``.; * ``__reference_constructs_from_temporary(T, U)`` (C++); Returns true if a reference ``T`` can be constructed from a temporary of type; a non-cv-qualified ``U``.; * ``__underlying_type`` (C++, GNU, Microsoft). In addition, the following expression traits are supported:. * ``__is_lvalue_expr(e)`` (Embarcadero):; Returns true if ``e`` is an lvalue expression.; Deprecated, use ``__is_lvalue_reference(decltype((e)))`` instead.; * ``__is_rvalue_expr(e)`` (Embarcadero):; Returns true if ``e`` is a prvalue expression.; Deprecated, use ``!__is_reference(decltype((e)))`` instead. There are multiple ways to detect support for a type trait ``__X`` in the; compiler, depending on the oldest version of Clang you wish to support. * From Clang 10 onwards, ``__has_builtin(__X)`` can be used.; * From Clang 6 onwards, ``!__is_identifier(__X)`` can be used.; * From Clang 3 onwards, ``__has_feature(X)`` can be used, but only supports; the following traits:. * ``__has_nothrow_assign``; * ``__has_nothrow_copy``; * ``__has_nothrow_constructor``; * ``__has_trivial_assign``; * ``__has_trivial_copy``; * ``__has_trivial_constructor``; * ``__has_trivial_destructor``; * ``__has_virtual_destructor``; * ``__is_abstract``; * ``__is_base_of``; * ``__is_class``; * ``__is_constructible``; * ``__is_convertible_to``; * ``__is_empty``; * ``__is_enum``; * ``__is_final``; * ``__is_literal``; * ``__is_standard_layout``; * ``__is_pod``; * ``__is_polymorphic``; * ``__is_sealed``; * ``__is_trivial``; * ``__is_trivially_assignable``; * ``__is_trivially_constructible``; * ``__is_trivially_copyable``; * ``__is_union``; * ``__underlying_type``. A simplistic usage example ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:68390,Integrability,message,message,68390,"using tied-outputs (i.e. outputs that are inputs and outputs, not just; outputs) with the `+r` constraint, there is a hidden input that's created; before the label, so numeric references to operands must account for that. .. code-block:: c++. int foo(int x) {; // %0 and %1 both refer to x; // %l2 refers to err; asm goto(""# %0 %1 %l2"" : ""+r""(x) : : : err);; return x;; err:; return -1;; }. This was changed to match GCC in clang-13; for better portability, symbolic; references can be used instead of numeric references. .. code-block:: c++. int foo(int x) {; asm goto(""# %[x] %l[err]"" : [x]""+r""(x) : : : err);; return x;; err:; return -1;; }. Objective-C Features; ====================. Related result types; --------------------. According to Cocoa conventions, Objective-C methods with certain names; (""``init``"", ""``alloc``"", etc.) always return objects that are an instance of; the receiving class's type. Such methods are said to have a ""related result; type"", meaning that a message send to one of these methods will have the same; static type as an instance of the receiver class. For example, given the; following classes:. .. code-block:: objc. @interface NSObject; + (id)alloc;; - (id)init;; @end. @interface NSArray : NSObject; @end. and this common initialization pattern. .. code-block:: objc. NSArray *array = [[NSArray alloc] init];. the type of the expression ``[NSArray alloc]`` is ``NSArray*`` because; ``alloc`` implicitly has a related result type. Similarly, the type of the; expression ``[[NSArray alloc] init]`` is ``NSArray*``, since ``init`` has a; related result type and its receiver is known to have the type ``NSArray *``.; If neither ``alloc`` nor ``init`` had a related result type, the expressions; would have had type ``id``, as declared in the method signature. A method with a related result type can be declared by using the type; ``instancetype`` as its result type. ``instancetype`` is a contextual keyword; that is only permitted in the result type of an Obje",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:68564,Integrability,interface,interface,68564,"nces to operands must account for that. .. code-block:: c++. int foo(int x) {; // %0 and %1 both refer to x; // %l2 refers to err; asm goto(""# %0 %1 %l2"" : ""+r""(x) : : : err);; return x;; err:; return -1;; }. This was changed to match GCC in clang-13; for better portability, symbolic; references can be used instead of numeric references. .. code-block:: c++. int foo(int x) {; asm goto(""# %[x] %l[err]"" : [x]""+r""(x) : : : err);; return x;; err:; return -1;; }. Objective-C Features; ====================. Related result types; --------------------. According to Cocoa conventions, Objective-C methods with certain names; (""``init``"", ""``alloc``"", etc.) always return objects that are an instance of; the receiving class's type. Such methods are said to have a ""related result; type"", meaning that a message send to one of these methods will have the same; static type as an instance of the receiver class. For example, given the; following classes:. .. code-block:: objc. @interface NSObject; + (id)alloc;; - (id)init;; @end. @interface NSArray : NSObject; @end. and this common initialization pattern. .. code-block:: objc. NSArray *array = [[NSArray alloc] init];. the type of the expression ``[NSArray alloc]`` is ``NSArray*`` because; ``alloc`` implicitly has a related result type. Similarly, the type of the; expression ``[[NSArray alloc] init]`` is ``NSArray*``, since ``init`` has a; related result type and its receiver is known to have the type ``NSArray *``.; If neither ``alloc`` nor ``init`` had a related result type, the expressions; would have had type ``id``, as declared in the method signature. A method with a related result type can be declared by using the type; ``instancetype`` as its result type. ``instancetype`` is a contextual keyword; that is only permitted in the result type of an Objective-C method, e.g. .. code-block:: objc. @interface A; + (instancetype)constructAnA;; @end. The related result type can also be inferred for some methods. To determine; whether a m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:68618,Integrability,interface,interface,68618,"de-block:: c++. int foo(int x) {; // %0 and %1 both refer to x; // %l2 refers to err; asm goto(""# %0 %1 %l2"" : ""+r""(x) : : : err);; return x;; err:; return -1;; }. This was changed to match GCC in clang-13; for better portability, symbolic; references can be used instead of numeric references. .. code-block:: c++. int foo(int x) {; asm goto(""# %[x] %l[err]"" : [x]""+r""(x) : : : err);; return x;; err:; return -1;; }. Objective-C Features; ====================. Related result types; --------------------. According to Cocoa conventions, Objective-C methods with certain names; (""``init``"", ""``alloc``"", etc.) always return objects that are an instance of; the receiving class's type. Such methods are said to have a ""related result; type"", meaning that a message send to one of these methods will have the same; static type as an instance of the receiver class. For example, given the; following classes:. .. code-block:: objc. @interface NSObject; + (id)alloc;; - (id)init;; @end. @interface NSArray : NSObject; @end. and this common initialization pattern. .. code-block:: objc. NSArray *array = [[NSArray alloc] init];. the type of the expression ``[NSArray alloc]`` is ``NSArray*`` because; ``alloc`` implicitly has a related result type. Similarly, the type of the; expression ``[[NSArray alloc] init]`` is ``NSArray*``, since ``init`` has a; related result type and its receiver is known to have the type ``NSArray *``.; If neither ``alloc`` nor ``init`` had a related result type, the expressions; would have had type ``id``, as declared in the method signature. A method with a related result type can be declared by using the type; ``instancetype`` as its result type. ``instancetype`` is a contextual keyword; that is only permitted in the result type of an Objective-C method, e.g. .. code-block:: objc. @interface A; + (instancetype)constructAnA;; @end. The related result type can also be inferred for some methods. To determine; whether a method has an inferred related result type, the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:69451,Integrability,interface,interface,69451,"of the receiver class. For example, given the; following classes:. .. code-block:: objc. @interface NSObject; + (id)alloc;; - (id)init;; @end. @interface NSArray : NSObject; @end. and this common initialization pattern. .. code-block:: objc. NSArray *array = [[NSArray alloc] init];. the type of the expression ``[NSArray alloc]`` is ``NSArray*`` because; ``alloc`` implicitly has a related result type. Similarly, the type of the; expression ``[[NSArray alloc] init]`` is ``NSArray*``, since ``init`` has a; related result type and its receiver is known to have the type ``NSArray *``.; If neither ``alloc`` nor ``init`` had a related result type, the expressions; would have had type ``id``, as declared in the method signature. A method with a related result type can be declared by using the type; ``instancetype`` as its result type. ``instancetype`` is a contextual keyword; that is only permitted in the result type of an Objective-C method, e.g. .. code-block:: objc. @interface A; + (instancetype)constructAnA;; @end. The related result type can also be inferred for some methods. To determine; whether a method has an inferred related result type, the first word in the; camel-case selector (e.g., ""``init``"" in ""``initWithObjects``"") is considered,; and the method will have a related result type if its return type is compatible; with the type of its class and if:. * the first word is ""``alloc``"" or ""``new``"", and the method is a class method,; or. * the first word is ""``autorelease``"", ""``init``"", ""``retain``"", or ""``self``"",; and the method is an instance method. If a method with a related result type is overridden by a subclass method, the; subclass method must also return a type that is compatible with the subclass; type. For example:. .. code-block:: objc. @interface NSString : NSObject; - (NSUnrelated *)init; // incorrect usage: NSUnrelated is not NSString or a superclass of NSString; @end. Related result types only affect the type of a message send or property access; v",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:70257,Integrability,interface,interface,70257,"ype`` is a contextual keyword; that is only permitted in the result type of an Objective-C method, e.g. .. code-block:: objc. @interface A; + (instancetype)constructAnA;; @end. The related result type can also be inferred for some methods. To determine; whether a method has an inferred related result type, the first word in the; camel-case selector (e.g., ""``init``"" in ""``initWithObjects``"") is considered,; and the method will have a related result type if its return type is compatible; with the type of its class and if:. * the first word is ""``alloc``"" or ""``new``"", and the method is a class method,; or. * the first word is ""``autorelease``"", ""``init``"", ""``retain``"", or ""``self``"",; and the method is an instance method. If a method with a related result type is overridden by a subclass method, the; subclass method must also return a type that is compatible with the subclass; type. For example:. .. code-block:: objc. @interface NSString : NSObject; - (NSUnrelated *)init; // incorrect usage: NSUnrelated is not NSString or a superclass of NSString; @end. Related result types only affect the type of a message send or property access; via the given method. In all other respects, a method with a related result; type is treated the same way as method that returns ``id``. Use ``__has_feature(objc_instancetype)`` to determine whether the; ``instancetype`` contextual keyword is available. Automatic reference counting; ----------------------------. Clang provides support for :doc:`automated reference counting; <AutomaticReferenceCounting>` in Objective-C, which eliminates the need; for manual ``retain``/``release``/``autorelease`` message sends. There are three; feature macros associated with automatic reference counting:; ``__has_feature(objc_arc)`` indicates the availability of automated reference; counting in general, while ``__has_feature(objc_arc_weak)`` indicates that; automated reference counting also includes support for ``__weak`` pointers to; Objective-C objects. `",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:70441,Integrability,message,message,70441,"objc. @interface A; + (instancetype)constructAnA;; @end. The related result type can also be inferred for some methods. To determine; whether a method has an inferred related result type, the first word in the; camel-case selector (e.g., ""``init``"" in ""``initWithObjects``"") is considered,; and the method will have a related result type if its return type is compatible; with the type of its class and if:. * the first word is ""``alloc``"" or ""``new``"", and the method is a class method,; or. * the first word is ""``autorelease``"", ""``init``"", ""``retain``"", or ""``self``"",; and the method is an instance method. If a method with a related result type is overridden by a subclass method, the; subclass method must also return a type that is compatible with the subclass; type. For example:. .. code-block:: objc. @interface NSString : NSObject; - (NSUnrelated *)init; // incorrect usage: NSUnrelated is not NSString or a superclass of NSString; @end. Related result types only affect the type of a message send or property access; via the given method. In all other respects, a method with a related result; type is treated the same way as method that returns ``id``. Use ``__has_feature(objc_instancetype)`` to determine whether the; ``instancetype`` contextual keyword is available. Automatic reference counting; ----------------------------. Clang provides support for :doc:`automated reference counting; <AutomaticReferenceCounting>` in Objective-C, which eliminates the need; for manual ``retain``/``release``/``autorelease`` message sends. There are three; feature macros associated with automatic reference counting:; ``__has_feature(objc_arc)`` indicates the availability of automated reference; counting in general, while ``__has_feature(objc_arc_weak)`` indicates that; automated reference counting also includes support for ``__weak`` pointers to; Objective-C objects. ``__has_feature(objc_arc_fields)`` indicates that C structs; are allowed to have fields that are pointers to Objective-C ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:70974,Integrability,message,message,70974,"""``new``"", and the method is a class method,; or. * the first word is ""``autorelease``"", ""``init``"", ""``retain``"", or ""``self``"",; and the method is an instance method. If a method with a related result type is overridden by a subclass method, the; subclass method must also return a type that is compatible with the subclass; type. For example:. .. code-block:: objc. @interface NSString : NSObject; - (NSUnrelated *)init; // incorrect usage: NSUnrelated is not NSString or a superclass of NSString; @end. Related result types only affect the type of a message send or property access; via the given method. In all other respects, a method with a related result; type is treated the same way as method that returns ``id``. Use ``__has_feature(objc_instancetype)`` to determine whether the; ``instancetype`` contextual keyword is available. Automatic reference counting; ----------------------------. Clang provides support for :doc:`automated reference counting; <AutomaticReferenceCounting>` in Objective-C, which eliminates the need; for manual ``retain``/``release``/``autorelease`` message sends. There are three; feature macros associated with automatic reference counting:; ``__has_feature(objc_arc)`` indicates the availability of automated reference; counting in general, while ``__has_feature(objc_arc_weak)`` indicates that; automated reference counting also includes support for ``__weak`` pointers to; Objective-C objects. ``__has_feature(objc_arc_fields)`` indicates that C structs; are allowed to have fields that are pointers to Objective-C objects managed by; automatic reference counting. .. _objc-weak:. Weak references; ---------------. Clang supports ARC-style weak and unsafe references in Objective-C even; outside of ARC mode. Weak references must be explicitly enabled with; the ``-fobjc-weak`` option; use ``__has_feature((objc_arc_weak))``; to test whether they are enabled. Unsafe references are enabled; unconditionally. ARC-style weak and unsafe references cannot be used",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:72757,Integrability,message,message,72757,"; use ``__has_feature((objc_arc_weak))``; to test whether they are enabled. Unsafe references are enabled; unconditionally. ARC-style weak and unsafe references cannot be used; when Objective-C garbage collection is enabled. Except as noted below, the language rules for the ``__weak`` and; ``__unsafe_unretained`` qualifiers (and the ``weak`` and; ``unsafe_unretained`` property attributes) are just as laid out; in the :doc:`ARC specification <AutomaticReferenceCounting>`.; In particular, note that some classes do not support forming weak; references to their instances, and note that special care must be; taken when storing weak references in memory where initialization; and deinitialization are outside the responsibility of the compiler; (such as in ``malloc``-ed memory). Loading from a ``__weak`` variable always implicitly retains the; loaded value. In non-ARC modes, this retain is normally balanced; by an implicit autorelease. This autorelease can be suppressed; by performing the load in the receiver position of a ``-retain``; message send (e.g. ``[weakReference retain]``); note that this performs; only a single retain (the retain done when primitively loading from; the weak reference). For the most part, ``__unsafe_unretained`` in non-ARC modes is just the; default behavior of variables and therefore is not needed. However,; it does have an effect on the semantics of block captures: normally,; copying a block which captures an Objective-C object or block pointer; causes the captured pointer to be retained or copied, respectively,; but that behavior is suppressed when the captured variable is qualified; with ``__unsafe_unretained``. Note that the ``__weak`` qualifier formerly meant the GC qualifier in; all non-ARC modes and was silently ignored outside of GC modes. It now; means the ARC-style qualifier in all non-GC modes and is no longer; allowed if not enabled by either ``-fobjc-arc`` or ``-fobjc-weak``.; It is expected that ``-fobjc-weak`` will eventually be enab",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:74422,Integrability,interoperab,interoperability,74422,"of GC modes. It now; means the ARC-style qualifier in all non-GC modes and is no longer; allowed if not enabled by either ``-fobjc-arc`` or ``-fobjc-weak``.; It is expected that ``-fobjc-weak`` will eventually be enabled by default; in all non-GC Objective-C modes. .. _objc-fixed-enum:. Enumerations with a fixed underlying type; -----------------------------------------. Clang provides support for C++11 enumerations with a fixed underlying type; within Objective-C. For example, one can write an enumeration type as:. .. code-block:: c++. typedef enum : unsigned char { Red, Green, Blue } Color;. This specifies that the underlying type, which is used to store the enumeration; value, is ``unsigned char``. Use ``__has_feature(objc_fixed_enum)`` to determine whether support for fixed; underlying types is available in Objective-C. Interoperability with C++11 lambdas; -----------------------------------. Clang provides interoperability between C++11 lambdas and blocks-based APIs, by; permitting a lambda to be implicitly converted to a block pointer with the; corresponding signature. For example, consider an API such as ``NSArray``'s; array-sorting method:. .. code-block:: objc. - (NSArray *)sortedArrayUsingComparator:(NSComparator)cmptr;. ``NSComparator`` is simply a typedef for the block pointer ``NSComparisonResult; (^)(id, id)``, and parameters of this type are generally provided with block; literals as arguments. However, one can also use a C++11 lambda so long as it; provides the same signature (in this case, accepting two parameters of type; ``id`` and returning an ``NSComparisonResult``):. .. code-block:: objc. NSArray *array = @[@""string 1"", @""string 21"", @""string 12"", @""String 11"",; @""String 02""];; const NSStringCompareOptions comparisonOptions; = NSCaseInsensitiveSearch | NSNumericSearch |; NSWidthInsensitiveSearch | NSForcedOrderingSearch;; NSLocale *currentLocale = [NSLocale currentLocale];; NSArray *sorted; = [array sortedArrayUsingComparator:[=](id s1, id s2) ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:81912,Integrability,wrap,wrap,81912,"for weakly-linked C functions, ``+class`` for Objective-C classes,; and ``-respondsToSelector:`` or ``+instancesRespondToSelector:`` for; Objective-C methods. If such a check was missed, the program would compile; fine, run fine on newer systems, but crash on older systems. As of LLVM 5.0, ``-Wunguarded-availability`` uses the `availability attributes; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ together; with the new ``@available()`` keyword to assist with this issue.; When a method that's introduced in the OS newer than the target OS is called, a; -Wunguarded-availability warning is emitted if that call is not guarded:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; // If fancyNewMethod was added in e.g. macOS 10.12, but the code is; // built with -mmacosx-version-min=10.11, then this unconditional call; // will emit a -Wunguarded-availability warning:; [var fancyNewMethod];; }. To fix the warning and to avoid the crash on macOS 10.11, wrap it in; ``if(@available())``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, *)) {; [var fancyNewMethod];; } else {; // Put fallback behavior for old macOS versions (and for non-mac; // platforms) here.; }; }. The ``*`` is required and means that platforms not explicitly listed will take; the true branch, and the compiler will emit ``-Wunguarded-availability``; warnings for unlisted platforms based on those platform's deployment target.; More than one platform can be listed in ``@available()``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, iOS 10, *)) {; [var fancyNewMethod];; }; }. If the caller of ``my_fun()`` already checks that ``my_fun()`` is only called; on 10.12, then add an `availability attribute; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ to it,; which will also suppress the warning and require that calls to my_fun() are; checked:. .. code-block:: objc. API_AVAILABLE(macos(10.12)) void m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:83571,Integrability,protocol,protocol-qualifier,83571,"ready checks that ``my_fun()`` is only called; on 10.12, then add an `availability attribute; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ to it,; which will also suppress the warning and require that calls to my_fun() are; checked:. .. code-block:: objc. API_AVAILABLE(macos(10.12)) void my_fun(NSSomeClass* var) {; [var fancyNewMethod]; // Now ok.; }. ``@available()`` is only available in Objective-C code. To use the feature; in C and C++ code, use the ``__builtin_available()`` spelling instead. If existing code uses null checks or ``-respondsToSelector:``, it should; be changed to use ``@available()`` (or ``__builtin_available``) instead. ``-Wunguarded-availability`` is disabled by default, but; ``-Wunguarded-availability-new``, which only emits this warning for APIs; that have been introduced in macOS >= 10.13, iOS >= 11, watchOS >= 4 and; tvOS >= 11, is enabled by default. .. _langext-overloading:. Objective-C++ ABI: protocol-qualifier mangling of parameters; ------------------------------------------------------------. Starting with LLVM 3.4, Clang produces a new mangling for parameters whose; type is a qualified-``id`` (e.g., ``id<Foo>``). This mangling allows such; parameters to be differentiated from those with the regular unqualified ``id``; type. This was a non-backward compatible mangling change to the ABI. This change; allows proper overloading, and also prevents mangling conflicts with template; parameters of protocol-qualified type. Query the presence of this new mangling with; ``__has_feature(objc_protocol_qualifier_mangling)``. Initializer lists for complex numbers in C; ==========================================. clang supports an extension which allows the following in C:. .. code-block:: c++. #include <math.h>; #include <complex.h>; complex float x = { 1.0f, INFINITY }; // Init to (1, Inf). This construct is useful because there is no way to separately initialize the; real and imaginary parts of a complex variable in standar",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:84082,Integrability,protocol,protocol-qualified,84082," code. To use the feature; in C and C++ code, use the ``__builtin_available()`` spelling instead. If existing code uses null checks or ``-respondsToSelector:``, it should; be changed to use ``@available()`` (or ``__builtin_available``) instead. ``-Wunguarded-availability`` is disabled by default, but; ``-Wunguarded-availability-new``, which only emits this warning for APIs; that have been introduced in macOS >= 10.13, iOS >= 11, watchOS >= 4 and; tvOS >= 11, is enabled by default. .. _langext-overloading:. Objective-C++ ABI: protocol-qualifier mangling of parameters; ------------------------------------------------------------. Starting with LLVM 3.4, Clang produces a new mangling for parameters whose; type is a qualified-``id`` (e.g., ``id<Foo>``). This mangling allows such; parameters to be differentiated from those with the regular unqualified ``id``; type. This was a non-backward compatible mangling change to the ABI. This change; allows proper overloading, and also prevents mangling conflicts with template; parameters of protocol-qualified type. Query the presence of this new mangling with; ``__has_feature(objc_protocol_qualifier_mangling)``. Initializer lists for complex numbers in C; ==========================================. clang supports an extension which allows the following in C:. .. code-block:: c++. #include <math.h>; #include <complex.h>; complex float x = { 1.0f, INFINITY }; // Init to (1, Inf). This construct is useful because there is no way to separately initialize the; real and imaginary parts of a complex variable in standard C, given that clang; does not support ``_Imaginary``. (Clang also supports the ``__real__`` and; ``__imag__`` extensions from gcc, which help in some cases, but are not usable; in static initializers.). Note that this extension does not allow eliding the braces; the meaning of the; following two lines is different:. .. code-block:: c++. complex float x[] = { { 1.0f, 1.0f } }; // [0] = (1, 1); complex float x[] = { 1.0f, 1.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:96597,Integrability,wrap,wrappers,96597,"o copy. It returns nothing. .. code-block:: c++. static __externref_t tableSrc[0];; static __externref_t tableDst[0];. // Copy nelem elements from [src, src + nelem - 1] in tableSrc to; // [dst, dst + nelem - 1] in tableDst; void copy(int dst, int src, int nelem) {; __builtin_wasm_table_copy(tableDst, tableSrc, dst, src, nelem);; }. Builtin Functions; =================. Clang supports a number of builtin library functions with the same syntax as; GCC, including things like ``__builtin_nan``, ``__builtin_constant_p``,; ``__builtin_choose_expr``, ``__builtin_types_compatible_p``,; ``__builtin_assume_aligned``, ``__sync_fetch_and_add``, etc. In addition to; the GCC builtins, Clang supports a number of builtins that GCC does not, which; are listed here. Please note that Clang does not and will not support all of the GCC builtins; for vector operations. Instead of using builtins, you should use the functions; defined in target-specific header files like ``<xmmintrin.h>``, which define; portable wrappers for these. Many of the Clang versions of these functions are; implemented directly in terms of :ref:`extended vector support; <langext-vectors>` instead of builtins, in order to reduce the number of; builtins that we need to implement. ``__builtin_alloca``; --------------------. ``__builtin_alloca`` is used to dynamically allocate memory on the stack. Memory; is automatically freed upon function termination. **Syntax**:. .. code-block:: c++. __builtin_alloca(size_t n). **Example of Use**:. .. code-block:: c++. void init(float* data, size_t nbelems);; void process(float* data, size_t nbelems);; int foo(size_t n) {; auto mem = (float*)__builtin_alloca(n * sizeof(float));; init(mem, n);; process(mem, n);; /* mem is automatically freed at this point */; }. **Description**:. ``__builtin_alloca`` is meant to be used to allocate a dynamic amount of memory; on the stack. This amount is subject to stack allocation limits. Query for this feature with ``__has_builtin(__builtin_alloc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:103468,Integrability,depend,depending,103468,"cking that ``expr`` is a non-member; static call expression. The call to that expression is made while using ``ptr``; as a function pointer stored in a dedicated register to implement *static chain*; calling convention, as used by some language to implement closures or nested; functions. Query for this feature with ``__has_builtin(__builtin_call_with_static_chain)``. ``__builtin_readcyclecounter``; ------------------------------. ``__builtin_readcyclecounter`` is used to access the cycle counter register (or; a similar low-latency, high-accuracy clock) on those targets that support it. **Syntax**:. .. code-block:: c++. __builtin_readcyclecounter(). **Example of Use**:. .. code-block:: c++. unsigned long long t0 = __builtin_readcyclecounter();; do_something();; unsigned long long t1 = __builtin_readcyclecounter();; unsigned long long cycles_to_do_something = t1 - t0; // assuming no overflow. **Description**:. The ``__builtin_readcyclecounter()`` builtin returns the cycle counter value,; which may be either global or process/thread-specific depending on the target.; As the backing counters often overflow quickly (on the order of seconds) this; should only be used for timing small intervals. When not supported by the; target, the return value is always zero. This builtin takes no arguments and; produces an unsigned long long result. Query for this feature with ``__has_builtin(__builtin_readcyclecounter)``. Note; that even if present, its use may depend on run-time privilege or other OS; controlled state. ``__builtin_dump_struct``; -------------------------. **Syntax**:. .. code-block:: c++. __builtin_dump_struct(&some_struct, some_printf_func, args...);. **Examples**:. .. code-block:: c++. struct S {; int x, y;; float f;; struct T {; int i;; } t;; };. void func(struct S *s) {; __builtin_dump_struct(s, printf);; }. Example output:. .. code-block:: none. struct S {; int x = 100; int y = 42; float f = 3.141593; struct T t = {; int i = 1997; }; }. .. code-block:: c++. #inc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:103880,Integrability,depend,depend,103880,"access the cycle counter register (or; a similar low-latency, high-accuracy clock) on those targets that support it. **Syntax**:. .. code-block:: c++. __builtin_readcyclecounter(). **Example of Use**:. .. code-block:: c++. unsigned long long t0 = __builtin_readcyclecounter();; do_something();; unsigned long long t1 = __builtin_readcyclecounter();; unsigned long long cycles_to_do_something = t1 - t0; // assuming no overflow. **Description**:. The ``__builtin_readcyclecounter()`` builtin returns the cycle counter value,; which may be either global or process/thread-specific depending on the target.; As the backing counters often overflow quickly (on the order of seconds) this; should only be used for timing small intervals. When not supported by the; target, the return value is always zero. This builtin takes no arguments and; produces an unsigned long long result. Query for this feature with ``__has_builtin(__builtin_readcyclecounter)``. Note; that even if present, its use may depend on run-time privilege or other OS; controlled state. ``__builtin_dump_struct``; -------------------------. **Syntax**:. .. code-block:: c++. __builtin_dump_struct(&some_struct, some_printf_func, args...);. **Examples**:. .. code-block:: c++. struct S {; int x, y;; float f;; struct T {; int i;; } t;; };. void func(struct S *s) {; __builtin_dump_struct(s, printf);; }. Example output:. .. code-block:: none. struct S {; int x = 100; int y = 42; float f = 3.141593; struct T t = {; int i = 1997; }; }. .. code-block:: c++. #include <string>; struct T { int a, b; };; constexpr void constexpr_sprintf(std::string &out, const char *format,; auto ...args) {; // ...; }; constexpr std::string dump_struct(auto &x) {; std::string s;; __builtin_dump_struct(&x, constexpr_sprintf, s);; return s;; }; static_assert(dump_struct(T{1, 2}) == R""(struct T {; int a = 1; int b = 2; }; )"");. **Description**:. The ``__builtin_dump_struct`` function is used to print the fields of a simple; structure and their values f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:163967,Integrability,depend,depends,163967,"g. ``vectorize(enable)``). If the transformation is; disabled (e.g. ``vectorize(disable)``), that takes precedence over; transformations option pragmas implying that transformation. Vectorization, Interleaving, and Predication; --------------------------------------------. A vectorized loop performs multiple iterations of the original loop; in parallel using vector instructions. The instruction set of the target; processor determines which vector instructions are available and their vector; widths. This restricts the types of loops that can be vectorized. The vectorizer; automatically determines if the loop is safe and profitable to vectorize. A; vector instruction cost model is used to select the vector width. Interleaving multiple loop iterations allows modern processors to further; improve instruction-level parallelism (ILP) using advanced hardware features,; such as multiple execution units and out-of-order execution. The vectorizer uses; a cost model that depends on the register pressure and generated code size to; select the interleaving count. Vectorization is enabled by ``vectorize(enable)`` and interleaving is enabled; by ``interleave(enable)``. This is useful when compiling with ``-Os`` to; manually enable vectorization or interleaving. .. code-block:: c++. #pragma clang loop vectorize(enable); #pragma clang loop interleave(enable); for(...) {; ...; }. The vector width is specified by; ``vectorize_width(_value_[, fixed|scalable])``, where _value_ is a positive; integer and the type of vectorization can be specified with an optional; second parameter. The default for the second parameter is 'fixed' and; refers to fixed width vectorization, whereas 'scalable' indicates the; compiler should use scalable vectors instead. Another use of vectorize_width; is ``vectorize_width(fixed|scalable)`` where the user can hint at the type; of vectorization to use without specifying the exact width. In both variants; of the pragma the vectorizer may decide to fall back on fi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:168089,Integrability,depend,dependencies,168089,"lled; if the loop count is not known at compile time. .. code-block:: c++. #pragma clang loop unroll(full); for(...) {; ...; }. The unroll count can be specified explicitly with ``unroll_count(_value_)`` where; _value_ is a positive integer. If this value is greater than the trip count the; loop will be fully unrolled. Otherwise the loop is partially unrolled subject; to the same code size limit as with ``unroll(enable)``. .. code-block:: c++. #pragma clang loop unroll_count(8); for(...) {; ...; }. Unrolling of a loop can be prevented by specifying ``unroll(disable)``. Loop unroll parameters can be controlled by options; `-mllvm -unroll-count=n` and `-mllvm -pragma-unroll-threshold=n`. Loop Distribution; -----------------. Loop Distribution allows splitting a loop into multiple loops. This is; beneficial for example when the entire loop cannot be vectorized but some of the; resulting loops can. If ``distribute(enable))`` is specified and the loop has memory dependencies; that inhibit vectorization, the compiler will attempt to isolate the offending; operations into a new loop. This optimization is not enabled by default, only; loops marked with the pragma are considered. .. code-block:: c++. #pragma clang loop distribute(enable); for (i = 0; i < N; ++i) {; S1: A[i + 1] = A[i] + B[i];; S2: C[i] = D[i] * E[i];; }. This loop will be split into two loops between statements S1 and S2. The; second loop containing S2 will be vectorized. Loop Distribution is currently not enabled by default in the optimizer because; it can hurt performance in some cases. For example, instruction-level; parallelism could be reduced by sequentializing the execution of the; statements S1 and S2 above. If Loop Distribution is turned on globally with; ``-mllvm -enable-loop-distribution``, specifying ``distribute(disable)`` can; be used the disable it on a per-loop basis. Additional Information; ----------------------. For convenience multiple loop hints can be specified on a single line. .. code",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:171316,Integrability,contract,contract,171316," for the translation unit with the ``-fassociative-math`` flag.; The pragma can take two values: ``on`` and ``off``. .. code-block:: c++. float f(float x, float y, float z); {; // Enable floating point reassociation across statements; #pragma clang fp reassociate(on); float t = x + y;; float v = t + z;; }. ``#pragma clang fp reciprocal`` allows control over using reciprocal; approximations in floating point expressions. When enabled, this; pragma allows the expression ``x / y`` to be approximated as ``x *; (1.0 / y)``. This pragma can be used to disable reciprocal; approximation when it is otherwise enabled for the translation unit; with the ``-freciprocal-math`` flag or other fast-math options. The; pragma can take two values: ``on`` and ``off``. .. code-block:: c++. float f(float x, float y); {; // Enable floating point reciprocal approximation; #pragma clang fp reciprocal(on); return x / y;; }. ``#pragma clang fp contract`` specifies whether the compiler should; contract a multiply and an addition (or subtraction) into a fused FMA; operation when supported by the target. The pragma can take three values: ``on``, ``fast`` and ``off``. The ``on``; option is identical to using ``#pragma STDC FP_CONTRACT(ON)`` and it allows; fusion as specified the language standard. The ``fast`` option allows fusion; in cases when the language standard does not make this possible (e.g. across; statements in C). .. code-block:: c++. for(...) {; #pragma clang fp contract(fast); a = b[i] * c[i];; d[i] += a;; }. The pragma can also be used with ``off`` which turns FP contraction off for a; section of the code. This can be useful when fast contraction is otherwise; enabled for the translation unit with the ``-ffp-contract=fast-honor-pragmas`` flag.; Note that ``-ffp-contract=fast`` will override pragmas to fuse multiply and; addition across statements regardless of any controlling pragmas. ``#pragma clang fp exceptions`` specifies floating point exception behavior. It; may take one of th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:171366,Integrability,contract,contract,171366," for the translation unit with the ``-fassociative-math`` flag.; The pragma can take two values: ``on`` and ``off``. .. code-block:: c++. float f(float x, float y, float z); {; // Enable floating point reassociation across statements; #pragma clang fp reassociate(on); float t = x + y;; float v = t + z;; }. ``#pragma clang fp reciprocal`` allows control over using reciprocal; approximations in floating point expressions. When enabled, this; pragma allows the expression ``x / y`` to be approximated as ``x *; (1.0 / y)``. This pragma can be used to disable reciprocal; approximation when it is otherwise enabled for the translation unit; with the ``-freciprocal-math`` flag or other fast-math options. The; pragma can take two values: ``on`` and ``off``. .. code-block:: c++. float f(float x, float y); {; // Enable floating point reciprocal approximation; #pragma clang fp reciprocal(on); return x / y;; }. ``#pragma clang fp contract`` specifies whether the compiler should; contract a multiply and an addition (or subtraction) into a fused FMA; operation when supported by the target. The pragma can take three values: ``on``, ``fast`` and ``off``. The ``on``; option is identical to using ``#pragma STDC FP_CONTRACT(ON)`` and it allows; fusion as specified the language standard. The ``fast`` option allows fusion; in cases when the language standard does not make this possible (e.g. across; statements in C). .. code-block:: c++. for(...) {; #pragma clang fp contract(fast); a = b[i] * c[i];; d[i] += a;; }. The pragma can also be used with ``off`` which turns FP contraction off for a; section of the code. This can be useful when fast contraction is otherwise; enabled for the translation unit with the ``-ffp-contract=fast-honor-pragmas`` flag.; Note that ``-ffp-contract=fast`` will override pragmas to fuse multiply and; addition across statements regardless of any controlling pragmas. ``#pragma clang fp exceptions`` specifies floating point exception behavior. It; may take one of th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:171854,Integrability,contract,contract,171854,"` to be approximated as ``x *; (1.0 / y)``. This pragma can be used to disable reciprocal; approximation when it is otherwise enabled for the translation unit; with the ``-freciprocal-math`` flag or other fast-math options. The; pragma can take two values: ``on`` and ``off``. .. code-block:: c++. float f(float x, float y); {; // Enable floating point reciprocal approximation; #pragma clang fp reciprocal(on); return x / y;; }. ``#pragma clang fp contract`` specifies whether the compiler should; contract a multiply and an addition (or subtraction) into a fused FMA; operation when supported by the target. The pragma can take three values: ``on``, ``fast`` and ``off``. The ``on``; option is identical to using ``#pragma STDC FP_CONTRACT(ON)`` and it allows; fusion as specified the language standard. The ``fast`` option allows fusion; in cases when the language standard does not make this possible (e.g. across; statements in C). .. code-block:: c++. for(...) {; #pragma clang fp contract(fast); a = b[i] * c[i];; d[i] += a;; }. The pragma can also be used with ``off`` which turns FP contraction off for a; section of the code. This can be useful when fast contraction is otherwise; enabled for the translation unit with the ``-ffp-contract=fast-honor-pragmas`` flag.; Note that ``-ffp-contract=fast`` will override pragmas to fuse multiply and; addition across statements regardless of any controlling pragmas. ``#pragma clang fp exceptions`` specifies floating point exception behavior. It; may take one of the values: ``ignore``, ``maytrap`` or ``strict``. Meaning of; these values is same as for `constrained floating point intrinsics <http://llvm.org/docs/LangRef.html#constrained-floating-point-intrinsics>`_. .. code-block:: c++. {; // Preserve floating point exceptions; #pragma clang fp exceptions(strict); z = x + y;; if (fetestexcept(FE_OVERFLOW)); ...; }. A ``#pragma clang fp`` pragma may contain any number of options:. .. code-block:: c++. void func(float *dest, float a, float",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:171959,Integrability,contract,contraction,171959,"ocal; approximation when it is otherwise enabled for the translation unit; with the ``-freciprocal-math`` flag or other fast-math options. The; pragma can take two values: ``on`` and ``off``. .. code-block:: c++. float f(float x, float y); {; // Enable floating point reciprocal approximation; #pragma clang fp reciprocal(on); return x / y;; }. ``#pragma clang fp contract`` specifies whether the compiler should; contract a multiply and an addition (or subtraction) into a fused FMA; operation when supported by the target. The pragma can take three values: ``on``, ``fast`` and ``off``. The ``on``; option is identical to using ``#pragma STDC FP_CONTRACT(ON)`` and it allows; fusion as specified the language standard. The ``fast`` option allows fusion; in cases when the language standard does not make this possible (e.g. across; statements in C). .. code-block:: c++. for(...) {; #pragma clang fp contract(fast); a = b[i] * c[i];; d[i] += a;; }. The pragma can also be used with ``off`` which turns FP contraction off for a; section of the code. This can be useful when fast contraction is otherwise; enabled for the translation unit with the ``-ffp-contract=fast-honor-pragmas`` flag.; Note that ``-ffp-contract=fast`` will override pragmas to fuse multiply and; addition across statements regardless of any controlling pragmas. ``#pragma clang fp exceptions`` specifies floating point exception behavior. It; may take one of the values: ``ignore``, ``maytrap`` or ``strict``. Meaning of; these values is same as for `constrained floating point intrinsics <http://llvm.org/docs/LangRef.html#constrained-floating-point-intrinsics>`_. .. code-block:: c++. {; // Preserve floating point exceptions; #pragma clang fp exceptions(strict); z = x + y;; if (fetestexcept(FE_OVERFLOW)); ...; }. A ``#pragma clang fp`` pragma may contain any number of options:. .. code-block:: c++. void func(float *dest, float a, float b) {; #pragma clang fp exceptions(maytrap) contract(fast) reassociate(on); ...; }. `",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:172032,Integrability,contract,contraction,172032,"fast-math options. The; pragma can take two values: ``on`` and ``off``. .. code-block:: c++. float f(float x, float y); {; // Enable floating point reciprocal approximation; #pragma clang fp reciprocal(on); return x / y;; }. ``#pragma clang fp contract`` specifies whether the compiler should; contract a multiply and an addition (or subtraction) into a fused FMA; operation when supported by the target. The pragma can take three values: ``on``, ``fast`` and ``off``. The ``on``; option is identical to using ``#pragma STDC FP_CONTRACT(ON)`` and it allows; fusion as specified the language standard. The ``fast`` option allows fusion; in cases when the language standard does not make this possible (e.g. across; statements in C). .. code-block:: c++. for(...) {; #pragma clang fp contract(fast); a = b[i] * c[i];; d[i] += a;; }. The pragma can also be used with ``off`` which turns FP contraction off for a; section of the code. This can be useful when fast contraction is otherwise; enabled for the translation unit with the ``-ffp-contract=fast-honor-pragmas`` flag.; Note that ``-ffp-contract=fast`` will override pragmas to fuse multiply and; addition across statements regardless of any controlling pragmas. ``#pragma clang fp exceptions`` specifies floating point exception behavior. It; may take one of the values: ``ignore``, ``maytrap`` or ``strict``. Meaning of; these values is same as for `constrained floating point intrinsics <http://llvm.org/docs/LangRef.html#constrained-floating-point-intrinsics>`_. .. code-block:: c++. {; // Preserve floating point exceptions; #pragma clang fp exceptions(strict); z = x + y;; if (fetestexcept(FE_OVERFLOW)); ...; }. A ``#pragma clang fp`` pragma may contain any number of options:. .. code-block:: c++. void func(float *dest, float a, float b) {; #pragma clang fp exceptions(maytrap) contract(fast) reassociate(on); ...; }. ``#pragma clang fp eval_method`` allows floating-point behavior to be specified; for a section of the source code. This p",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:172107,Integrability,contract,contract,172107,"fast-math options. The; pragma can take two values: ``on`` and ``off``. .. code-block:: c++. float f(float x, float y); {; // Enable floating point reciprocal approximation; #pragma clang fp reciprocal(on); return x / y;; }. ``#pragma clang fp contract`` specifies whether the compiler should; contract a multiply and an addition (or subtraction) into a fused FMA; operation when supported by the target. The pragma can take three values: ``on``, ``fast`` and ``off``. The ``on``; option is identical to using ``#pragma STDC FP_CONTRACT(ON)`` and it allows; fusion as specified the language standard. The ``fast`` option allows fusion; in cases when the language standard does not make this possible (e.g. across; statements in C). .. code-block:: c++. for(...) {; #pragma clang fp contract(fast); a = b[i] * c[i];; d[i] += a;; }. The pragma can also be used with ``off`` which turns FP contraction off for a; section of the code. This can be useful when fast contraction is otherwise; enabled for the translation unit with the ``-ffp-contract=fast-honor-pragmas`` flag.; Note that ``-ffp-contract=fast`` will override pragmas to fuse multiply and; addition across statements regardless of any controlling pragmas. ``#pragma clang fp exceptions`` specifies floating point exception behavior. It; may take one of the values: ``ignore``, ``maytrap`` or ``strict``. Meaning of; these values is same as for `constrained floating point intrinsics <http://llvm.org/docs/LangRef.html#constrained-floating-point-intrinsics>`_. .. code-block:: c++. {; // Preserve floating point exceptions; #pragma clang fp exceptions(strict); z = x + y;; if (fetestexcept(FE_OVERFLOW)); ...; }. A ``#pragma clang fp`` pragma may contain any number of options:. .. code-block:: c++. void func(float *dest, float a, float b) {; #pragma clang fp exceptions(maytrap) contract(fast) reassociate(on); ...; }. ``#pragma clang fp eval_method`` allows floating-point behavior to be specified; for a section of the source code. This p",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:172161,Integrability,contract,contract,172161,"point reciprocal approximation; #pragma clang fp reciprocal(on); return x / y;; }. ``#pragma clang fp contract`` specifies whether the compiler should; contract a multiply and an addition (or subtraction) into a fused FMA; operation when supported by the target. The pragma can take three values: ``on``, ``fast`` and ``off``. The ``on``; option is identical to using ``#pragma STDC FP_CONTRACT(ON)`` and it allows; fusion as specified the language standard. The ``fast`` option allows fusion; in cases when the language standard does not make this possible (e.g. across; statements in C). .. code-block:: c++. for(...) {; #pragma clang fp contract(fast); a = b[i] * c[i];; d[i] += a;; }. The pragma can also be used with ``off`` which turns FP contraction off for a; section of the code. This can be useful when fast contraction is otherwise; enabled for the translation unit with the ``-ffp-contract=fast-honor-pragmas`` flag.; Note that ``-ffp-contract=fast`` will override pragmas to fuse multiply and; addition across statements regardless of any controlling pragmas. ``#pragma clang fp exceptions`` specifies floating point exception behavior. It; may take one of the values: ``ignore``, ``maytrap`` or ``strict``. Meaning of; these values is same as for `constrained floating point intrinsics <http://llvm.org/docs/LangRef.html#constrained-floating-point-intrinsics>`_. .. code-block:: c++. {; // Preserve floating point exceptions; #pragma clang fp exceptions(strict); z = x + y;; if (fetestexcept(FE_OVERFLOW)); ...; }. A ``#pragma clang fp`` pragma may contain any number of options:. .. code-block:: c++. void func(float *dest, float a, float b) {; #pragma clang fp exceptions(maytrap) contract(fast) reassociate(on); ...; }. ``#pragma clang fp eval_method`` allows floating-point behavior to be specified; for a section of the source code. This pragma can appear at file or namespace; scope, or at the start of a compound statement (excluding comments).; The pragma is active within the s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:172911,Integrability,contract,contract,172911,"; d[i] += a;; }. The pragma can also be used with ``off`` which turns FP contraction off for a; section of the code. This can be useful when fast contraction is otherwise; enabled for the translation unit with the ``-ffp-contract=fast-honor-pragmas`` flag.; Note that ``-ffp-contract=fast`` will override pragmas to fuse multiply and; addition across statements regardless of any controlling pragmas. ``#pragma clang fp exceptions`` specifies floating point exception behavior. It; may take one of the values: ``ignore``, ``maytrap`` or ``strict``. Meaning of; these values is same as for `constrained floating point intrinsics <http://llvm.org/docs/LangRef.html#constrained-floating-point-intrinsics>`_. .. code-block:: c++. {; // Preserve floating point exceptions; #pragma clang fp exceptions(strict); z = x + y;; if (fetestexcept(FE_OVERFLOW)); ...; }. A ``#pragma clang fp`` pragma may contain any number of options:. .. code-block:: c++. void func(float *dest, float a, float b) {; #pragma clang fp exceptions(maytrap) contract(fast) reassociate(on); ...; }. ``#pragma clang fp eval_method`` allows floating-point behavior to be specified; for a section of the source code. This pragma can appear at file or namespace; scope, or at the start of a compound statement (excluding comments).; The pragma is active within the scope of the compound statement. When ``pragma clang fp eval_method(source)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=source`` is enabled. Rounds intermediate results to; source-defined precision. When ``pragma clang fp eval_method(double)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=double`` is enabled. Rounds intermediate results to; ``double`` precision. When ``pragma clang fp eval_method(extended)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-met",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:173953,Integrability,depend,dependent,173953,"``#pragma clang fp eval_method`` allows floating-point behavior to be specified; for a section of the source code. This pragma can appear at file or namespace; scope, or at the start of a compound statement (excluding comments).; The pragma is active within the scope of the compound statement. When ``pragma clang fp eval_method(source)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=source`` is enabled. Rounds intermediate results to; source-defined precision. When ``pragma clang fp eval_method(double)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=double`` is enabled. Rounds intermediate results to; ``double`` precision. When ``pragma clang fp eval_method(extended)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=extended`` is enabled. Rounds intermediate results to; target-dependent ``long double`` precision. In Win32 programming, for instance,; the long double data type maps to the double, 64-bit precision data type. The full syntax this pragma supports is; ``#pragma clang fp eval_method(source|double|extended)``. .. code-block:: c++. for(...) {; // The compiler will use long double as the floating-point evaluation; // method.; #pragma clang fp eval_method(extended); a = b[i] * c[i] + e;; }. Note: ``math.h`` defines the typedefs ``float_t`` and ``double_t`` based on the active; evaluation method at the point where the header is included, not where the; typedefs are used. Because of this, it is unwise to combine these typedefs with; ``#pragma clang fp eval_method``. To catch obvious bugs, Clang will emit an; error for any references to these typedefs within the scope of this pragma;; however, this is not a fool-proof protection, and programmers must take care. The ``#pragma float_control`` pragma allows precise floating-point; semantics and floating-po",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:175753,Integrability,contract,contract,175753,", Clang will emit an; error for any references to these typedefs within the scope of this pragma;; however, this is not a fool-proof protection, and programmers must take care. The ``#pragma float_control`` pragma allows precise floating-point; semantics and floating-point exception behavior to be specified; for a section of the source code. This pragma can only appear at file or; namespace scope, within a language linkage specification or at the start of a; compound statement (excluding comments). When used within a compound statement,; the pragma is active within the scope of the compound statement. This pragma; is modeled after a Microsoft pragma with the same spelling and syntax. For; pragmas specified at file or namespace scope, or within a language linkage; specification, a stack is supported so that the ``pragma float_control``; settings can be pushed or popped. When ``pragma float_control(precise, on)`` is enabled, the section of code; governed by the pragma uses precise floating point semantics, effectively; ``-ffast-math`` is disabled and ``-ffp-contract=on``; (fused multiply add) is enabled. This pragma enables ``-fmath-errno``. When ``pragma float_control(precise, off)`` is enabled, unsafe-floating point; optimizations are enabled in the section of code governed by the pragma.; Effectively ``-ffast-math`` is enabled and ``-ffp-contract=fast``. This pragma; disables ``-fmath-errno``. When ``pragma float_control(except, on)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-exception-behavior=strict`` is enabled,; when ``pragma float_control(except, off)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-exception-behavior=ignore`` is enabled. The full syntax this pragma supports is; ``float_control(except|precise, on|off [, push])`` and; ``float_control(push|pop)``.; The ``push`` and ``pop`` forms, including using ``push`` as the optional; thi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:176042,Integrability,contract,contract,176042," This pragma can only appear at file or; namespace scope, within a language linkage specification or at the start of a; compound statement (excluding comments). When used within a compound statement,; the pragma is active within the scope of the compound statement. This pragma; is modeled after a Microsoft pragma with the same spelling and syntax. For; pragmas specified at file or namespace scope, or within a language linkage; specification, a stack is supported so that the ``pragma float_control``; settings can be pushed or popped. When ``pragma float_control(precise, on)`` is enabled, the section of code; governed by the pragma uses precise floating point semantics, effectively; ``-ffast-math`` is disabled and ``-ffp-contract=on``; (fused multiply add) is enabled. This pragma enables ``-fmath-errno``. When ``pragma float_control(precise, off)`` is enabled, unsafe-floating point; optimizations are enabled in the section of code governed by the pragma.; Effectively ``-ffast-math`` is enabled and ``-ffp-contract=fast``. This pragma; disables ``-fmath-errno``. When ``pragma float_control(except, on)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-exception-behavior=strict`` is enabled,; when ``pragma float_control(except, off)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-exception-behavior=ignore`` is enabled. The full syntax this pragma supports is; ``float_control(except|precise, on|off [, push])`` and; ``float_control(push|pop)``.; The ``push`` and ``pop`` forms, including using ``push`` as the optional; third argument, can only occur at file scope. .. code-block:: c++. for(...) {; // This block will be compiled with -fno-fast-math and -ffp-contract=on; #pragma float_control(precise, on); a = b[i] * c[i] + e;; }. Specifying an attribute for multiple declarations (#pragma clang attribute); ========================================================",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:176817,Integrability,contract,contract,176817,"``-fmath-errno``. When ``pragma float_control(precise, off)`` is enabled, unsafe-floating point; optimizations are enabled in the section of code governed by the pragma.; Effectively ``-ffast-math`` is enabled and ``-ffp-contract=fast``. This pragma; disables ``-fmath-errno``. When ``pragma float_control(except, on)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-exception-behavior=strict`` is enabled,; when ``pragma float_control(except, off)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-exception-behavior=ignore`` is enabled. The full syntax this pragma supports is; ``float_control(except|precise, on|off [, push])`` and; ``float_control(push|pop)``.; The ``push`` and ``pop`` forms, including using ``push`` as the optional; third argument, can only occur at file scope. .. code-block:: c++. for(...) {; // This block will be compiled with -fno-fast-math and -ffp-contract=on; #pragma float_control(precise, on); a = b[i] * c[i] + e;; }. Specifying an attribute for multiple declarations (#pragma clang attribute); ===========================================================================. The ``#pragma clang attribute`` directive can be used to apply an attribute to; multiple declarations. The ``#pragma clang attribute push`` variation of the; directive pushes a new ""scope"" of ``#pragma clang attribute`` that attributes; can be added to. The ``#pragma clang attribute (...)`` variation adds an; attribute to that scope, and the ``#pragma clang attribute pop`` variation pops; the scope. You can also use ``#pragma clang attribute push (...)``, which is a; shorthand for when you want to add one attribute to a new scope. Multiple push; directives can be nested inside each other. The attributes that are used in the ``#pragma clang attribute`` directives; can be written using the GNU-style syntax:. .. code-block:: c++. #pragma clang attribute push (__attribu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:180875,Integrability,depend,depends,180875,"BLE_BEGIN _Pragma(""clang attribute Unavailable.push (__attribute__((unavailable)), apply_to=function)""); #define ASSUME_UNAVAILABLE_END _Pragma(""clang attribute Unavailable.pop""). ASSUME_NORETURN_BEGIN; ASSUME_UNAVAILABLE_BEGIN; void function(); // function has [[noreturn]] and __attribute__((unavailable)); ASSUME_NORETURN_END; void other_function(); // function has __attribute__((unavailable)); ASSUME_UNAVAILABLE_END. Without the namespaces on the macros, ``other_function`` will be annotated with; ``[[noreturn]]`` instead of ``__attribute__((unavailable))``. This may seem like; a contrived example, but its very possible for this kind of situation to appear; in real code if the pragmas are spread out across a large file. You can test if; your version of clang supports namespaces on ``#pragma clang attribute`` with; ``__has_extension(pragma_clang_attribute_namespaces)``. Subject Match Rules; -------------------. The set of declarations that receive a single attribute from the attribute stack; depends on the subject match rules that were specified in the pragma. Subject; match rules are specified after the attribute. The compiler expects an; identifier that corresponds to the subject set specifier. The ``apply_to``; specifier is currently the only supported subject set specifier. It allows you; to specify match rules that form a subset of the attribute's allowed subject; set, i.e. the compiler doesn't require all of the attribute's subjects. For; example, an attribute like ``[[nodiscard]]`` whose subject set includes; ``enum``, ``record`` and ``hasType(functionType)``, requires the presence of at; least one of these rules after ``apply_to``:. .. code-block:: c++. #pragma clang attribute push([[nodiscard]], apply_to = enum). enum Enum1 { A1, B1 }; // The enum will receive [[nodiscard]]. struct Record1 { }; // The struct will *not* receive [[nodiscard]]. #pragma clang attribute pop. #pragma clang attribute push([[nodiscard]], apply_to = any(record, enum)). enum Enum2 { ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:184661,Integrability,interface,interface,184661,"tant``: Can be used to apply attributes to enumerators. - ``variable``: Can be used to apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global variables; only. - ``variable(is_local)``: Can be used to apply attributes to local variables; only. - ``variable(is_parameter)``: Can be used to apply attributes to parameters; only. - ``variable(unless(is_parameter))``: Can be used to apply attributes to all; the variables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. - ``objc_category``: Can be used to apply attributes to category declarations,; including class extensions. - ``objc_method``: Can be used to apply attributes to Objective-C methods,; including instance and class methods. Implicit methods like implicit property; getters and setters do not receive the attribute. - ``objc_method(is_instance)``: Can be used to apply attributes to Objective-C; instance methods. - ``objc_property``: Can be used to apply attributes to ``@property``; declarations. - ``block``: Can be used to apply attributes to block declarations. This does; not include variables/fields of block pointer type. The use of ``unless`` in match rules is currently restricted to a strict set of; sub-rules that are used by the supported attributes. That means that even though; ``variable(unless(is_parameter))`` is a valid match rule,; ``variable(unless(is_t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:184747,Integrability,protocol,protocol,184747," apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global variables; only. - ``variable(is_local)``: Can be used to apply attributes to local variables; only. - ``variable(is_parameter)``: Can be used to apply attributes to parameters; only. - ``variable(unless(is_parameter))``: Can be used to apply attributes to all; the variables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. - ``objc_category``: Can be used to apply attributes to category declarations,; including class extensions. - ``objc_method``: Can be used to apply attributes to Objective-C methods,; including instance and class methods. Implicit methods like implicit property; getters and setters do not receive the attribute. - ``objc_method(is_instance)``: Can be used to apply attributes to Objective-C; instance methods. - ``objc_property``: Can be used to apply attributes to ``@property``; declarations. - ``block``: Can be used to apply attributes to block declarations. This does; not include variables/fields of block pointer type. The use of ``unless`` in match rules is currently restricted to a strict set of; sub-rules that are used by the supported attributes. That means that even though; ``variable(unless(is_parameter))`` is a valid match rule,; ``variable(unless(is_thread_local))`` is not. Supported Attributes; --------------------. Not all attributes",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:188245,Integrability,depend,dependent,188245,"re is only defined to work sensibly for ELF targets. * If section name is specified through _attribute_((section(""myname""))), then; the attribute name gains precedence. * Global variables that are initialized to zero will be placed in the named; bss section, if one is present. * The ``#pragma clang section`` directive does not does try to infer section-kind; from the name. For example, naming a section ""``.bss.mySec``"" does NOT mean; it will be a bss section name. * The decision about which section-kind applies to each global is taken in the back-end.; Once the section-kind is known, appropriate section name, as specified by the user using; ``#pragma clang section`` directive, is applied to that global. Specifying Linker Options on ELF Targets; ========================================. The ``#pragma comment(lib, ...)`` directive is supported on all ELF targets.; The second parameter is the library name (without the traditional Unix prefix of; ``lib``). This allows you to provide an implicit link of dependent libraries. Evaluating Object Size Dynamically; ==================================. Clang supports the builtin ``__builtin_dynamic_object_size``, the semantics are; the same as GCC's ``__builtin_object_size`` (which Clang also supports), but; ``__builtin_dynamic_object_size`` can evaluate the object's size at runtime.; ``__builtin_dynamic_object_size`` is meant to be used as a drop-in replacement; for ``__builtin_object_size`` in libraries that support it. For instance, here is a program that ``__builtin_dynamic_object_size`` will make; safer:. .. code-block:: c. void copy_into_buffer(size_t size) {; char* buffer = malloc(size);; strlcpy(buffer, ""some string"", strlen(""some string""));; // Previous line preprocesses to:; // __builtin___strlcpy_chk(buffer, ""some string"", strlen(""some string""), __builtin_object_size(buffer, 0)); }. Since the size of ``buffer`` can't be known at compile time, Clang will fold; ``__builtin_object_size(buffer, 0)`` into ``-1``. However, ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:193735,Integrability,interface,interfaces,193735," Enter an implicit ``extern ""C""`` region. This is not required on; modern systems where system headers are C++-aware. At most a single ``1`` or ``2`` can be present, and values must be in; ascending order. Examples are:. .. code-block:: c. # 57 // Advance (or return) to line 57 of the current source file; # 57 ""frob"" // Set to line 57 of ""frob""; # 1 ""foo.h"" 1 // Enter ""foo.h"" at line 1; # 59 ""main.c"" 2 // Leave current include and return to ""main.c""; # 1 ""/usr/include/stdio.h"" 1 3 // Enter a system header; # 60 """" 2 // return to ""main.c""; # 1 ""/usr/ancient/header.h"" 1 4 // Enter an implicit extern ""C"" header. Extended Integer Types; ======================. Clang supports the C23 ``_BitInt(N)`` feature as an extension in older C modes; and in C++. This type was previously implemented in Clang with the same; semantics, but spelled ``_ExtInt(N)``. This spelling has been deprecated in; favor of the standard type. Note: the ABI for ``_BitInt(N)`` is still in the process of being stabilized,; so this type should not yet be used in interfaces that require ABI stability. Intrinsics Support within Constant Expressions; ==============================================. The following builtin intrinsics can be used in constant expressions:. * ``__builtin_bitreverse8``; * ``__builtin_bitreverse16``; * ``__builtin_bitreverse32``; * ``__builtin_bitreverse64``; * ``__builtin_bswap16``; * ``__builtin_bswap32``; * ``__builtin_bswap64``; * ``__builtin_clrsb``; * ``__builtin_clrsbl``; * ``__builtin_clrsbll``; * ``__builtin_clz``; * ``__builtin_clzl``; * ``__builtin_clzll``; * ``__builtin_clzs``; * ``__builtin_ctz``; * ``__builtin_ctzl``; * ``__builtin_ctzll``; * ``__builtin_ctzs``; * ``__builtin_ffs``; * ``__builtin_ffsl``; * ``__builtin_ffsll``; * ``__builtin_fmax``; * ``__builtin_fmin``; * ``__builtin_fpclassify``; * ``__builtin_inf``; * ``__builtin_isinf``; * ``__builtin_isinf_sign``; * ``__builtin_isfinite``; * ``__builtin_isnan``; * ``__builtin_isnormal``; * ``__builtin_nan``; * ``__",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:196537,Integrability,depend,dependent,196537,"tin_isnormal``; * ``__builtin_nan``; * ``__builtin_nans``; * ``__builtin_parity``; * ``__builtin_parityl``; * ``__builtin_parityll``; * ``__builtin_popcount``; * ``__builtin_popcountl``; * ``__builtin_popcountll``; * ``__builtin_rotateleft8``; * ``__builtin_rotateleft16``; * ``__builtin_rotateleft32``; * ``__builtin_rotateleft64``; * ``__builtin_rotateright8``; * ``__builtin_rotateright16``; * ``__builtin_rotateright32``; * ``__builtin_rotateright64``. The following x86-specific intrinsics can be used in constant expressions:. * ``_bit_scan_forward``; * ``_bit_scan_reverse``; * ``__bsfd``; * ``__bsfq``; * ``__bsrd``; * ``__bsrq``; * ``__bswap``; * ``__bswapd``; * ``__bswap64``; * ``__bswapq``; * ``_castf32_u32``; * ``_castf64_u64``; * ``_castu32_f32``; * ``_castu64_f64``; * ``__lzcnt16``; * ``__lzcnt``; * ``__lzcnt64``; * ``_mm_popcnt_u32``; * ``_mm_popcnt_u64``; * ``_popcnt32``; * ``_popcnt64``; * ``__popcntd``; * ``__popcntq``; * ``__popcnt16``; * ``__popcnt``; * ``__popcnt64``; * ``__rolb``; * ``__rolw``; * ``__rold``; * ``__rolq``; * ``__rorb``; * ``__rorw``; * ``__rord``; * ``__rorq``; * ``_rotl``; * ``_rotr``; * ``_rotwl``; * ``_rotwr``; * ``_lrotl``; * ``_lrotr``. Debugging the Compiler; ======================. Clang supports a number of pragma directives that help debugging the compiler itself.; Syntax is the following: `#pragma clang __debug <command> <arguments>`.; Note, all of debugging pragmas are subject to change. `dump`; ------; Accepts either a single identifier or an expression. When a single identifier is passed,; the lookup results for the identifier are printed to `stderr`. When an expression is passed,; the AST for the expression is printed to `stderr`. The expression is an unevaluated operand,; so things like overload resolution and template instantiations are performed,; but the expression has no runtime effects.; Type- and value-dependent expressions are not supported yet. This facility is designed to aid with testing name lookup machinery.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:9474,Modifiability,variab,variable,9474,"argument that is the name of; an attribute implemented as a Microsoft-style ``__declspec`` attribute. It; evaluates to 1 if the attribute is supported by the current compilation target,; or 0 if not. It can be used like this:. .. code-block:: c++. #ifndef __has_declspec_attribute // Optional of course.; #define __has_declspec_attribute(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_declspec_attribute(dllexport); #define DLLEXPORT __declspec(dllexport); #else; #define DLLEXPORT; #endif; ... The attribute name can also be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``__dllexport__`` can be used instead of ``dllexport``. ``__is_identifier``; -------------------. This function-like macro takes a single identifier argument that might be either; a reserved word or a regular identifier. It evaluates to 1 if the argument is just; a regular identifier and not a reserved word, in the sense that it can then be; used as the name of a user-defined function or variable. Otherwise it evaluates; to 0. It can be used like this:. .. code-block:: c++. ...; #ifdef __is_identifier // Compatibility with non-clang compilers.; #if __is_identifier(__wchar_t); typedef wchar_t __wchar_t;; #endif; #endif. __wchar_t WideCharacter;; ... Include File Checking Macros; ============================. Not all developments systems have the same include files. The; :ref:`langext-__has_include` and :ref:`langext-__has_include_next` macros allow; you to check for the existence of an include file before doing a possibly; failing ``#include`` directive. Include file checking macros must be used; as expressions in ``#if`` or ``#elif`` preprocessing directives. .. _langext-__has_include:. ``__has_include``; -----------------. This function-like macro takes a single file name string argument that is the; name of an include file. It evaluates to 1 if the file can be found using the; include pa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:34631,Modifiability,portab,portable,34631,"has no; effect beyond ``standard``. The ``_Float16`` type is an interchange floating type specified in; ISO/IEC TS 18661-3:2015 (""Floating-point extensions for C""). It will; be supported on more targets as they define ABIs for it. The ``__bf16`` type is a non-standard extension, but it generally follows; the rules for arithmetic interchange floating types from ISO/IEC TS; 18661-3:2015. In previous versions of Clang, it was a storage-only type; that forbade arithmetic operations. It will be supported on more targets; as they define ABIs for it. The ``__fp16`` type was originally an ARM extension and is specified; by the `ARM C Language Extensions <https://github.com/ARM-software/acle/releases>`_.; Clang uses the ``binary16`` format from IEEE 754-2008 for ``__fp16``,; not the ARM alternative format. Operators that expect arithmetic operands; immediately promote ``__fp16`` operands to ``float``. It is recommended that portable code use ``_Float16`` instead of ``__fp16``,; as it has been defined by the C standards committee and has behavior that is; more familiar to most programmers. Because ``__fp16`` operands are always immediately promoted to ``float``, the; common real type of ``__fp16`` and ``_Float16`` for the purposes of the usual; arithmetic conversions is ``float``. A literal can be given ``_Float16`` type using the suffix ``f16``. For example,; ``3.14f16``. Because default argument promotion only applies to the standard floating-point; types, ``_Float16`` values are not promoted to ``double`` when passed as variadic; or untyped arguments. As a consequence, some caution must be taken when using; certain library facilities with ``_Float16``; for example, there is no ``printf`` format; specifier for ``_Float16``, and (unlike ``float``) it will not be implicitly promoted to; ``double`` when passed to ``printf``, so the programmer must explicitly cast it to; ``double`` before using it with an ``%f`` or similar specifier. Messages on ``deprecated`` and ``unavailable`",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:39145,Modifiability,portab,portable,39145,"one. .../TestFramework.framework; .../TestFramework.framework/.system_framework; .../TestFramework.framework/Headers; .../TestFramework.framework/Headers/TestFramework.h; ... Clang will treat the presence of this file as an indicator that the framework; should be treated as a system framework, regardless of how it was found in the; framework search path. For consistency, we recommend that such files never be; included in installed versions of the framework. Checks for Standard Language Features; =====================================. The ``__has_feature`` macro can be used to query if certain standard language; features are enabled. The ``__has_extension`` macro can be used to query if; language features are available as an extension when compiling for a standard; which does not provide them. The features which can be tested are listed here. Since Clang 3.4, the C++ SD-6 feature test macros are also supported.; These are macros with names of the form ``__cpp_<feature_name>``, and are; intended to be a portable way to query the supported features of the compiler.; See `the C++ status page <https://clang.llvm.org/cxx_status.html#ts>`_ for; information on the version of SD-6 supported by each Clang release, and the; macros provided by that revision of the recommendations. C++98; -----. The features listed below are part of the C++98 standard. These features are; enabled by default when compiling C++ code. C++ exceptions; ^^^^^^^^^^^^^^. Use ``__has_feature(cxx_exceptions)`` to determine if C++ exceptions have been; enabled. For example, compiling code with ``-fno-exceptions`` disables C++; exceptions. C++ RTTI; ^^^^^^^^. Use ``__has_feature(cxx_rtti)`` to determine if C++ RTTI has been enabled. For; example, compiling code with ``-fno-rtti`` disables the use of RTTI. C++11; -----. The features listed below are part of the C++11 standard. As a result, all; these features are enabled with the ``-std=c++11`` or ``-std=gnu++11`` option; when compiling C++ code. C++11 SFINAE",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:43673,Modifiability,inherit,inheriting,43673, delegating constructors is enabled. C++11 ``deleted`` functions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_deleted_functions)`` or; ``__has_extension(cxx_deleted_functions)`` to determine if support for deleted; function definitions (with ``= delete``) is enabled. C++11 explicit conversion functions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_explicit_conversions)`` to determine if support for; ``explicit`` conversion functions is enabled. C++11 generalized initializers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_generalized_initializers)`` to determine if support for; generalized initializers (using braced lists and ``std::initializer_list``) is; enabled. C++11 implicit move constructors/assignment operators; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_implicit_moves)`` to determine if Clang will implicitly; generate move constructors and move assignment operators where needed. C++11 inheriting constructors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_inheriting_constructors)`` to determine if support for; inheriting constructors is enabled. C++11 inline namespaces; ^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_inline_namespaces)`` or; ``__has_extension(cxx_inline_namespaces)`` to determine if support for inline; namespaces is enabled. C++11 lambdas; ^^^^^^^^^^^^^. Use ``__has_feature(cxx_lambdas)`` or ``__has_extension(cxx_lambdas)`` to; determine if support for lambdas is enabled. C++11 local and unnamed types as template arguments; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_local_type_template_args)`` or; ``__has_extension(cxx_local_type_template_args)`` to determine if support for; local and unnamed types as template arguments is enabled. C++11 noexcept; ^^^^^^^^^^^^^^. Use ``__has_feature(cxx_noexcept)`` or ``__has_extension(cxx_noexcept)`` to; determine if support for noexcept exception specifications is enabled. C++11 in-class non-sta,MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:43809,Modifiability,inherit,inheriting,43809,^^^^. Use ``__has_feature(cxx_deleted_functions)`` or; ``__has_extension(cxx_deleted_functions)`` to determine if support for deleted; function definitions (with ``= delete``) is enabled. C++11 explicit conversion functions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_explicit_conversions)`` to determine if support for; ``explicit`` conversion functions is enabled. C++11 generalized initializers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_generalized_initializers)`` to determine if support for; generalized initializers (using braced lists and ``std::initializer_list``) is; enabled. C++11 implicit move constructors/assignment operators; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_implicit_moves)`` to determine if Clang will implicitly; generate move constructors and move assignment operators where needed. C++11 inheriting constructors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_inheriting_constructors)`` to determine if support for; inheriting constructors is enabled. C++11 inline namespaces; ^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_inline_namespaces)`` or; ``__has_extension(cxx_inline_namespaces)`` to determine if support for inline; namespaces is enabled. C++11 lambdas; ^^^^^^^^^^^^^. Use ``__has_feature(cxx_lambdas)`` or ``__has_extension(cxx_lambdas)`` to; determine if support for lambdas is enabled. C++11 local and unnamed types as template arguments; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_local_type_template_args)`` or; ``__has_extension(cxx_local_type_template_args)`` to determine if support for; local and unnamed types as template arguments is enabled. C++11 noexcept; ^^^^^^^^^^^^^^. Use ``__has_feature(cxx_noexcept)`` or ``__has_extension(cxx_noexcept)`` to; determine if support for noexcept exception specifications is enabled. C++11 in-class non-static data member initialization; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use,MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:46581,Modifiability,variab,variables,46581,"g., member functions with ``&`` or ``&&``; applied to ``*this``) is enabled. C++11 range-based ``for`` loop; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_range_for)`` or ``__has_extension(cxx_range_for)`` to; determine if support for the range-based for loop is enabled. C++11 raw string literals; ^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_raw_string_literals)`` to determine if support for raw; string literals (e.g., ``R""x(foo\bar)x""``) is enabled. C++11 rvalue references; ^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_rvalue_references)`` or; ``__has_extension(cxx_rvalue_references)`` to determine if support for rvalue; references is enabled. C++11 ``static_assert()``; ^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_static_assert)`` or; ``__has_extension(cxx_static_assert)`` to determine if support for compile-time; assertions using ``static_assert`` is enabled. C++11 ``thread_local``; ^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_thread_local)`` to determine if support for; ``thread_local`` variables is enabled. C++11 type inference; ^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_auto_type)`` or ``__has_extension(cxx_auto_type)`` to; determine C++11 type inference is supported using the ``auto`` specifier. If; this is disabled, ``auto`` will instead be a storage class specifier, as in C; or C++98. C++11 strongly typed enumerations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_strong_enums)`` or; ``__has_extension(cxx_strong_enums)`` to determine if support for strongly; typed, scoped enumerations is enabled. C++11 trailing return type; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_trailing_return)`` or; ``__has_extension(cxx_trailing_return)`` to determine if support for the; alternate function declaration syntax with trailing return type is enabled. C++11 Unicode string literals; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_unicode_literals)`` to determine if support for Unicode; string literals is enabled. C+",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:50121,Modifiability,polymorphi,polymorphic,50121,"upport; for the ``decltype(auto)`` placeholder type is enabled. C++14 default initializers for aggregates; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_aggregate_nsdmi)`` or; ``__has_extension(cxx_aggregate_nsdmi)`` to determine if support; for default initializers in aggregate members is enabled. C++14 digit separators; ^^^^^^^^^^^^^^^^^^^^^^. Use ``__cpp_digit_separators`` to determine if support for digit separators; using single quotes (for instance, ``10'000``) is enabled. At this time, there; is no corresponding ``__has_feature`` name. C++14 generalized lambda capture; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_init_captures)`` or; ``__has_extension(cxx_init_captures)`` to determine if support for; lambda captures with explicit initializers is enabled; (for instance, ``[n(0)] { return ++n; }``). C++14 generic lambdas; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_generic_lambdas)`` or; ``__has_extension(cxx_generic_lambdas)`` to determine if support for generic; (polymorphic) lambdas is enabled; (for instance, ``[] (auto x) { return x + 1; }``). C++14 relaxed constexpr; ^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_relaxed_constexpr)`` or; ``__has_extension(cxx_relaxed_constexpr)`` to determine if variable; declarations, local variable modification, and control flow constructs; are permitted in ``constexpr`` functions. C++14 return type deduction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_return_type_deduction)`` or; ``__has_extension(cxx_return_type_deduction)`` to determine if support; for return type deduction for functions (using ``auto`` as a return type); is enabled. C++14 runtime-sized arrays; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_runtime_array)`` or; ``__has_extension(cxx_runtime_array)`` to determine if support; for arrays of runtime bound (a restricted form of variable-length arrays); is enabled.; Clang's implementation of this feature is incomplete. C++14 variable templates; ^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:50363,Modifiability,variab,variable,50363,"ult initializers in aggregate members is enabled. C++14 digit separators; ^^^^^^^^^^^^^^^^^^^^^^. Use ``__cpp_digit_separators`` to determine if support for digit separators; using single quotes (for instance, ``10'000``) is enabled. At this time, there; is no corresponding ``__has_feature`` name. C++14 generalized lambda capture; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_init_captures)`` or; ``__has_extension(cxx_init_captures)`` to determine if support for; lambda captures with explicit initializers is enabled; (for instance, ``[n(0)] { return ++n; }``). C++14 generic lambdas; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_generic_lambdas)`` or; ``__has_extension(cxx_generic_lambdas)`` to determine if support for generic; (polymorphic) lambdas is enabled; (for instance, ``[] (auto x) { return x + 1; }``). C++14 relaxed constexpr; ^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_relaxed_constexpr)`` or; ``__has_extension(cxx_relaxed_constexpr)`` to determine if variable; declarations, local variable modification, and control flow constructs; are permitted in ``constexpr`` functions. C++14 return type deduction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_return_type_deduction)`` or; ``__has_extension(cxx_return_type_deduction)`` to determine if support; for return type deduction for functions (using ``auto`` as a return type); is enabled. C++14 runtime-sized arrays; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_runtime_array)`` or; ``__has_extension(cxx_runtime_array)`` to determine if support; for arrays of runtime bound (a restricted form of variable-length arrays); is enabled.; Clang's implementation of this feature is incomplete. C++14 variable templates; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_variable_templates)`` or; ``__has_extension(cxx_variable_templates)`` to determine if support for; templated variable declarations is enabled. C11; ---. The features listed below are part of the C11 standard. As a result, all thes",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:50393,Modifiability,variab,variable,50393,"ult initializers in aggregate members is enabled. C++14 digit separators; ^^^^^^^^^^^^^^^^^^^^^^. Use ``__cpp_digit_separators`` to determine if support for digit separators; using single quotes (for instance, ``10'000``) is enabled. At this time, there; is no corresponding ``__has_feature`` name. C++14 generalized lambda capture; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_init_captures)`` or; ``__has_extension(cxx_init_captures)`` to determine if support for; lambda captures with explicit initializers is enabled; (for instance, ``[n(0)] { return ++n; }``). C++14 generic lambdas; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_generic_lambdas)`` or; ``__has_extension(cxx_generic_lambdas)`` to determine if support for generic; (polymorphic) lambdas is enabled; (for instance, ``[] (auto x) { return x + 1; }``). C++14 relaxed constexpr; ^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_relaxed_constexpr)`` or; ``__has_extension(cxx_relaxed_constexpr)`` to determine if variable; declarations, local variable modification, and control flow constructs; are permitted in ``constexpr`` functions. C++14 return type deduction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_return_type_deduction)`` or; ``__has_extension(cxx_return_type_deduction)`` to determine if support; for return type deduction for functions (using ``auto`` as a return type); is enabled. C++14 runtime-sized arrays; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_runtime_array)`` or; ``__has_extension(cxx_runtime_array)`` to determine if support; for arrays of runtime bound (a restricted form of variable-length arrays); is enabled.; Clang's implementation of this feature is incomplete. C++14 variable templates; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_variable_templates)`` or; ``__has_extension(cxx_variable_templates)`` to determine if support for; templated variable declarations is enabled. C11; ---. The features listed below are part of the C11 standard. As a result, all thes",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:50972,Modifiability,variab,variable-length,50972,"instance, ``[n(0)] { return ++n; }``). C++14 generic lambdas; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_generic_lambdas)`` or; ``__has_extension(cxx_generic_lambdas)`` to determine if support for generic; (polymorphic) lambdas is enabled; (for instance, ``[] (auto x) { return x + 1; }``). C++14 relaxed constexpr; ^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_relaxed_constexpr)`` or; ``__has_extension(cxx_relaxed_constexpr)`` to determine if variable; declarations, local variable modification, and control flow constructs; are permitted in ``constexpr`` functions. C++14 return type deduction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_return_type_deduction)`` or; ``__has_extension(cxx_return_type_deduction)`` to determine if support; for return type deduction for functions (using ``auto`` as a return type); is enabled. C++14 runtime-sized arrays; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_runtime_array)`` or; ``__has_extension(cxx_runtime_array)`` to determine if support; for arrays of runtime bound (a restricted form of variable-length arrays); is enabled.; Clang's implementation of this feature is incomplete. C++14 variable templates; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_variable_templates)`` or; ``__has_extension(cxx_variable_templates)`` to determine if support for; templated variable declarations is enabled. C11; ---. The features listed below are part of the C11 standard. As a result, all these; features are enabled with the ``-std=c11`` or ``-std=gnu11`` option when; compiling C code. Additionally, because these features are all; backward-compatible, they are available as extensions in all language modes. C11 alignment specifiers; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_alignas)`` or ``__has_extension(c_alignas)`` to determine; if support for alignment specifiers using ``_Alignas`` is enabled. Use ``__has_feature(c_alignof)`` or ``__has_extension(c_alignof)`` to determine; if support for the ``_Alignof`` keyword i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:51070,Modifiability,variab,variable,51070,"ermine if support for generic; (polymorphic) lambdas is enabled; (for instance, ``[] (auto x) { return x + 1; }``). C++14 relaxed constexpr; ^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_relaxed_constexpr)`` or; ``__has_extension(cxx_relaxed_constexpr)`` to determine if variable; declarations, local variable modification, and control flow constructs; are permitted in ``constexpr`` functions. C++14 return type deduction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_return_type_deduction)`` or; ``__has_extension(cxx_return_type_deduction)`` to determine if support; for return type deduction for functions (using ``auto`` as a return type); is enabled. C++14 runtime-sized arrays; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_runtime_array)`` or; ``__has_extension(cxx_runtime_array)`` to determine if support; for arrays of runtime bound (a restricted form of variable-length arrays); is enabled.; Clang's implementation of this feature is incomplete. C++14 variable templates; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_variable_templates)`` or; ``__has_extension(cxx_variable_templates)`` to determine if support for; templated variable declarations is enabled. C11; ---. The features listed below are part of the C11 standard. As a result, all these; features are enabled with the ``-std=c11`` or ``-std=gnu11`` option when; compiling C code. Additionally, because these features are all; backward-compatible, they are available as extensions in all language modes. C11 alignment specifiers; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_alignas)`` or ``__has_extension(c_alignas)`` to determine; if support for alignment specifiers using ``_Alignas`` is enabled. Use ``__has_feature(c_alignof)`` or ``__has_extension(c_alignof)`` to determine; if support for the ``_Alignof`` keyword is enabled. C11 atomic operations; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_atomic)`` or ``__has_extension(c_atomic)`` to determine; if support for atomic types using ``_Atomic",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:51249,Modifiability,variab,variable,51249," }``). C++14 relaxed constexpr; ^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_relaxed_constexpr)`` or; ``__has_extension(cxx_relaxed_constexpr)`` to determine if variable; declarations, local variable modification, and control flow constructs; are permitted in ``constexpr`` functions. C++14 return type deduction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_return_type_deduction)`` or; ``__has_extension(cxx_return_type_deduction)`` to determine if support; for return type deduction for functions (using ``auto`` as a return type); is enabled. C++14 runtime-sized arrays; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_runtime_array)`` or; ``__has_extension(cxx_runtime_array)`` to determine if support; for arrays of runtime bound (a restricted form of variable-length arrays); is enabled.; Clang's implementation of this feature is incomplete. C++14 variable templates; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_variable_templates)`` or; ``__has_extension(cxx_variable_templates)`` to determine if support for; templated variable declarations is enabled. C11; ---. The features listed below are part of the C11 standard. As a result, all these; features are enabled with the ``-std=c11`` or ``-std=gnu11`` option when; compiling C code. Additionally, because these features are all; backward-compatible, they are available as extensions in all language modes. C11 alignment specifiers; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_alignas)`` or ``__has_extension(c_alignas)`` to determine; if support for alignment specifiers using ``_Alignas`` is enabled. Use ``__has_feature(c_alignof)`` or ``__has_extension(c_alignof)`` to determine; if support for the ``_Alignof`` keyword is enabled. C11 atomic operations; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_atomic)`` or ``__has_extension(c_atomic)`` to determine; if support for atomic types using ``_Atomic`` is enabled. Clang also provides; :ref:`a set of builtins <langext-__c11_atomic>` which can be used to imple",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:53435,Modifiability,extend,extended,53435,"When using its own, implementations of the atomic; operations are provided as macros. In the cases where C11 also requires a real; function, this header provides only the declaration of that function (along; with a shadowing macro implementation), and you must link to a library which; provides a definition of the function if you use it instead of the macro. C11 generic selections; ^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_generic_selections)`` or; ``__has_extension(c_generic_selections)`` to determine if support for generic; selections is enabled. As an extension, the C11 generic selection expression is available in all; languages supported by Clang. The syntax is the same as that given in the C11; standard. In C, type compatibility is decided according to the rules given in the; appropriate standard, but in C++, which lacks the type compatibility rules used; in C, types are considered compatible only if they are equivalent. Clang also supports an extended form of ``_Generic`` with a controlling type; rather than a controlling expression. Unlike with a controlling expression, a; controlling type argument does not undergo any conversions and thus is suitable; for use when trying to match qualified types, incomplete types, or function; types. Variable-length array types lack the necessary compile-time information; to resolve which association they match with and thus are not allowed as a; controlling type argument. Use ``__has_extension(c_generic_selection_with_controlling_type)`` to determine; if support for this extension is enabled. C11 ``_Static_assert()``; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_static_assert)`` or ``__has_extension(c_static_assert)``; to determine if support for compile-time assertions using ``_Static_assert`` is; enabled. C11 ``_Thread_local``; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_thread_local)`` or ``__has_extension(c_thread_local)``; to determine if support for ``_Thread_local`` variables is enabled. Modules; -------. Use ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:54425,Modifiability,variab,variables,54425,"ompatible only if they are equivalent. Clang also supports an extended form of ``_Generic`` with a controlling type; rather than a controlling expression. Unlike with a controlling expression, a; controlling type argument does not undergo any conversions and thus is suitable; for use when trying to match qualified types, incomplete types, or function; types. Variable-length array types lack the necessary compile-time information; to resolve which association they match with and thus are not allowed as a; controlling type argument. Use ``__has_extension(c_generic_selection_with_controlling_type)`` to determine; if support for this extension is enabled. C11 ``_Static_assert()``; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_static_assert)`` or ``__has_extension(c_static_assert)``; to determine if support for compile-time assertions using ``_Static_assert`` is; enabled. C11 ``_Thread_local``; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_thread_local)`` or ``__has_extension(c_thread_local)``; to determine if support for ``_Thread_local`` variables is enabled. Modules; -------. Use ``__has_feature(modules)`` to determine if Modules have been enabled.; For example, compiling code with ``-fmodules`` enables the use of Modules. More information could be found `here <https://clang.llvm.org/docs/Modules.html>`_. Language Extensions Back-ported to Previous Standards; =====================================================. ====================================== ================================ ============= =============; Feature Feature Test Macro Introduced In Backported To; ====================================== ================================ ============= =============; variadic templates __cpp_variadic_templates C++11 C++03; Alias templates __cpp_alias_templates C++11 C++03; Non-static data member initializers __cpp_nsdmi C++11 C++03; Range-based ``for`` loop __cpp_range_based_for C++11 C++03; RValue references __cpp_rvalue_references C++11 C++03; Attributes __cpp_attri",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:55392,Modifiability,variab,variable,55392,,MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:55918,Modifiability,variab,variables,55918,===== ============= =============; Feature Feature Test Macro Introduced In Backported To; ====================================== ================================ ============= =============; variadic templates __cpp_variadic_templates C++11 C++03; Alias templates __cpp_alias_templates C++11 C++03; Non-static data member initializers __cpp_nsdmi C++11 C++03; Range-based ``for`` loop __cpp_range_based_for C++11 C++03; RValue references __cpp_rvalue_references C++11 C++03; Attributes __cpp_attributes C++11 C++03; variable templates __cpp_variable_templates C++14 C++03; Binary literals __cpp_binary_literals C++14 C++03; Relaxed constexpr __cpp_constexpr C++14 C++11; ``if constexpr`` __cpp_if_constexpr C++17 C++11; fold expressions __cpp_fold_expressions C++17 C++03; Lambda capture of \*this by value __cpp_capture_star_this C++17 C++11; Attributes on enums __cpp_enumerator_attributes C++17 C++03; Guaranteed copy elision __cpp_guaranteed_copy_elision C++17 C++03; Hexadecimal floating literals __cpp_hex_float C++17 C++03; ``inline`` variables __cpp_inline_variables C++17 C++03; Attributes on namespaces __cpp_namespace_attributes C++17 C++11; Structured bindings __cpp_structured_bindings C++17 C++03; template template arguments __cpp_template_template_args C++17 C++03; ``static operator[]`` __cpp_multidimensional_subscript C++20 C++03; Designated initializers __cpp_designated_initializers C++20 C++03; Conditional ``explicit`` __cpp_conditional_explicit C++20 C++03; ``using enum`` __cpp_using_enum C++20 C++03; ``if consteval`` __cpp_if_consteval C++23 C++20; ``static operator()`` __cpp_static_call_operator C++23 C++03; Attributes on Lambda-Expressions C++23 C++11; -------------------------------------- -------------------------------- ------------- -------------; Designated initializers (N494) C99 C89; Array & element qualification (N2607) C23 C89; Attributes (N2335) C23 C89; ====================================== ================================ ============= =============.,MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:58613,Modifiability,portab,portable,58613,"4(v=VS.100).aspx>`_,; as well as nearly all of the; `Embarcadero C++ type traits; <http://docwiki.embarcadero.com/RADStudio/Rio/en/Type_Trait_Functions_(C%2B%2B11)_Index>`_. The following type trait primitives are supported by Clang. Those traits marked; (C++) provide implementations for type traits specified by the C++ standard;; ``__X(...)`` has the same semantics and constraints as the corresponding; ``std::X_t<...>`` or ``std::X_v<...>`` type trait. * ``__array_rank(type)`` (Embarcadero):; Returns the number of levels of array in the type ``type``:; ``0`` if ``type`` is not an array type, and; ``__array_rank(element) + 1`` if ``type`` is an array of ``element``.; * ``__array_extent(type, dim)`` (Embarcadero):; The ``dim``'th array bound in the type ``type``, or ``0`` if; ``dim >= __array_rank(type)``.; * ``__can_pass_in_regs`` (C++); Returns whether a class can be passed in registers under the current; ABI. This type can only be applied to unqualified class types.; This is not a portable type trait.; * ``__has_nothrow_assign`` (GNU, Microsoft, Embarcadero):; Deprecated, use ``__is_nothrow_assignable`` instead.; * ``__has_nothrow_move_assign`` (GNU, Microsoft):; Deprecated, use ``__is_nothrow_assignable`` instead.; * ``__has_nothrow_copy`` (GNU, Microsoft):; Deprecated, use ``__is_nothrow_constructible`` instead.; * ``__has_nothrow_constructor`` (GNU, Microsoft):; Deprecated, use ``__is_nothrow_constructible`` instead.; * ``__has_trivial_assign`` (GNU, Microsoft, Embarcadero):; Deprecated, use ``__is_trivially_assignable`` instead.; * ``__has_trivial_move_assign`` (GNU, Microsoft):; Deprecated, use ``__is_trivially_assignable`` instead.; * ``__has_trivial_copy`` (GNU, Microsoft):; Deprecated, use ``__is_trivially_copyable`` instead.; * ``__has_trivial_constructor`` (GNU, Microsoft):; Deprecated, use ``__is_trivially_constructible`` instead.; * ``__has_trivial_move_constructor`` (GNU, Microsoft):; Deprecated, use ``__is_trivially_constructible`` instead.; * ``__ha",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:67852,Modifiability,portab,portability,67852,"ntation are in :doc:`Block-ABI-Apple<Block-ABI-Apple>`. Query for this feature with ``__has_extension(blocks)``. ASM Goto with Output Constraints; ================================. Outputs may be used along any branches from the ``asm goto`` whether the; branches are taken or not. Query for this feature with ``__has_extension(gnu_asm_goto_with_outputs)``. Prior to clang-16, the output may only be used safely when the indirect; branches are not taken. Query for this difference with; ``__has_extension(gnu_asm_goto_with_outputs_full)``. When using tied-outputs (i.e. outputs that are inputs and outputs, not just; outputs) with the `+r` constraint, there is a hidden input that's created; before the label, so numeric references to operands must account for that. .. code-block:: c++. int foo(int x) {; // %0 and %1 both refer to x; // %l2 refers to err; asm goto(""# %0 %1 %l2"" : ""+r""(x) : : : err);; return x;; err:; return -1;; }. This was changed to match GCC in clang-13; for better portability, symbolic; references can be used instead of numeric references. .. code-block:: c++. int foo(int x) {; asm goto(""# %[x] %l[err]"" : [x]""+r""(x) : : : err);; return x;; err:; return -1;; }. Objective-C Features; ====================. Related result types; --------------------. According to Cocoa conventions, Objective-C methods with certain names; (""``init``"", ""``alloc``"", etc.) always return objects that are an instance of; the receiving class's type. Such methods are said to have a ""related result; type"", meaning that a message send to one of these methods will have the same; static type as an instance of the receiver class. For example, given the; following classes:. .. code-block:: objc. @interface NSObject; + (id)alloc;; - (id)init;; @end. @interface NSArray : NSObject; @end. and this common initialization pattern. .. code-block:: objc. NSArray *array = [[NSArray alloc] init];. the type of the expression ``[NSArray alloc]`` is ``NSArray*`` because; ``alloc`` implicitly has a relate",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:72521,Modifiability,variab,variable,72521,"--------. Clang supports ARC-style weak and unsafe references in Objective-C even; outside of ARC mode. Weak references must be explicitly enabled with; the ``-fobjc-weak`` option; use ``__has_feature((objc_arc_weak))``; to test whether they are enabled. Unsafe references are enabled; unconditionally. ARC-style weak and unsafe references cannot be used; when Objective-C garbage collection is enabled. Except as noted below, the language rules for the ``__weak`` and; ``__unsafe_unretained`` qualifiers (and the ``weak`` and; ``unsafe_unretained`` property attributes) are just as laid out; in the :doc:`ARC specification <AutomaticReferenceCounting>`.; In particular, note that some classes do not support forming weak; references to their instances, and note that special care must be; taken when storing weak references in memory where initialization; and deinitialization are outside the responsibility of the compiler; (such as in ``malloc``-ed memory). Loading from a ``__weak`` variable always implicitly retains the; loaded value. In non-ARC modes, this retain is normally balanced; by an implicit autorelease. This autorelease can be suppressed; by performing the load in the receiver position of a ``-retain``; message send (e.g. ``[weakReference retain]``); note that this performs; only a single retain (the retain done when primitively loading from; the weak reference). For the most part, ``__unsafe_unretained`` in non-ARC modes is just the; default behavior of variables and therefore is not needed. However,; it does have an effect on the semantics of block captures: normally,; copying a block which captures an Objective-C object or block pointer; causes the captured pointer to be retained or copied, respectively,; but that behavior is suppressed when the captured variable is qualified; with ``__unsafe_unretained``. Note that the ``__weak`` qualifier formerly meant the GC qualifier in; all non-ARC modes and was silently ignored outside of GC modes. It now; means the ARC-st",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:73013,Modifiability,variab,variables,73013,"he ``__weak`` and; ``__unsafe_unretained`` qualifiers (and the ``weak`` and; ``unsafe_unretained`` property attributes) are just as laid out; in the :doc:`ARC specification <AutomaticReferenceCounting>`.; In particular, note that some classes do not support forming weak; references to their instances, and note that special care must be; taken when storing weak references in memory where initialization; and deinitialization are outside the responsibility of the compiler; (such as in ``malloc``-ed memory). Loading from a ``__weak`` variable always implicitly retains the; loaded value. In non-ARC modes, this retain is normally balanced; by an implicit autorelease. This autorelease can be suppressed; by performing the load in the receiver position of a ``-retain``; message send (e.g. ``[weakReference retain]``); note that this performs; only a single retain (the retain done when primitively loading from; the weak reference). For the most part, ``__unsafe_unretained`` in non-ARC modes is just the; default behavior of variables and therefore is not needed. However,; it does have an effect on the semantics of block captures: normally,; copying a block which captures an Objective-C object or block pointer; causes the captured pointer to be retained or copied, respectively,; but that behavior is suppressed when the captured variable is qualified; with ``__unsafe_unretained``. Note that the ``__weak`` qualifier formerly meant the GC qualifier in; all non-ARC modes and was silently ignored outside of GC modes. It now; means the ARC-style qualifier in all non-GC modes and is no longer; allowed if not enabled by either ``-fobjc-arc`` or ``-fobjc-weak``.; It is expected that ``-fobjc-weak`` will eventually be enabled by default; in all non-GC Objective-C modes. .. _objc-fixed-enum:. Enumerations with a fixed underlying type; -----------------------------------------. Clang provides support for C++11 enumerations with a fixed underlying type; within Objective-C. For example, one c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:73322,Modifiability,variab,variable,73322,"at some classes do not support forming weak; references to their instances, and note that special care must be; taken when storing weak references in memory where initialization; and deinitialization are outside the responsibility of the compiler; (such as in ``malloc``-ed memory). Loading from a ``__weak`` variable always implicitly retains the; loaded value. In non-ARC modes, this retain is normally balanced; by an implicit autorelease. This autorelease can be suppressed; by performing the load in the receiver position of a ``-retain``; message send (e.g. ``[weakReference retain]``); note that this performs; only a single retain (the retain done when primitively loading from; the weak reference). For the most part, ``__unsafe_unretained`` in non-ARC modes is just the; default behavior of variables and therefore is not needed. However,; it does have an effect on the semantics of block captures: normally,; copying a block which captures an Objective-C object or block pointer; causes the captured pointer to be retained or copied, respectively,; but that behavior is suppressed when the captured variable is qualified; with ``__unsafe_unretained``. Note that the ``__weak`` qualifier formerly meant the GC qualifier in; all non-ARC modes and was silently ignored outside of GC modes. It now; means the ARC-style qualifier in all non-GC modes and is no longer; allowed if not enabled by either ``-fobjc-arc`` or ``-fobjc-weak``.; It is expected that ``-fobjc-weak`` will eventually be enabled by default; in all non-GC Objective-C modes. .. _objc-fixed-enum:. Enumerations with a fixed underlying type; -----------------------------------------. Clang provides support for C++11 enumerations with a fixed underlying type; within Objective-C. For example, one can write an enumeration type as:. .. code-block:: c++. typedef enum : unsigned char { Red, Green, Blue } Color;. This specifies that the underlying type, which is used to store the enumeration; value, is ``unsigned char``. Use `",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:84594,Modifiability,variab,variable,84594,"rotocol-qualifier mangling of parameters; ------------------------------------------------------------. Starting with LLVM 3.4, Clang produces a new mangling for parameters whose; type is a qualified-``id`` (e.g., ``id<Foo>``). This mangling allows such; parameters to be differentiated from those with the regular unqualified ``id``; type. This was a non-backward compatible mangling change to the ABI. This change; allows proper overloading, and also prevents mangling conflicts with template; parameters of protocol-qualified type. Query the presence of this new mangling with; ``__has_feature(objc_protocol_qualifier_mangling)``. Initializer lists for complex numbers in C; ==========================================. clang supports an extension which allows the following in C:. .. code-block:: c++. #include <math.h>; #include <complex.h>; complex float x = { 1.0f, INFINITY }; // Init to (1, Inf). This construct is useful because there is no way to separately initialize the; real and imaginary parts of a complex variable in standard C, given that clang; does not support ``_Imaginary``. (Clang also supports the ``__real__`` and; ``__imag__`` extensions from gcc, which help in some cases, but are not usable; in static initializers.). Note that this extension does not allow eliding the braces; the meaning of the; following two lines is different:. .. code-block:: c++. complex float x[] = { { 1.0f, 1.0f } }; // [0] = (1, 1); complex float x[] = { 1.0f, 1.0f }; // [0] = (1, 0), [1] = (1, 0). This extension also works in C++ mode, as far as that goes, but does not apply; to the C++ ``std::complex``. (In C++11, list initialization allows the same; syntax to be used with ``std::complex`` with the same meaning.). For GCC compatibility, ``__builtin_complex(re, im)`` can also be used to; construct a complex number from the given real and imaginary components. OpenCL Features; ===============. Clang supports internal OpenCL extensions documented below. ``__cl_clang_bitfields``; -----",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:85946,Modifiability,portab,portability,85946,"x[] = { { 1.0f, 1.0f } }; // [0] = (1, 1); complex float x[] = { 1.0f, 1.0f }; // [0] = (1, 0), [1] = (1, 0). This extension also works in C++ mode, as far as that goes, but does not apply; to the C++ ``std::complex``. (In C++11, list initialization allows the same; syntax to be used with ``std::complex`` with the same meaning.). For GCC compatibility, ``__builtin_complex(re, im)`` can also be used to; construct a complex number from the given real and imaginary components. OpenCL Features; ===============. Clang supports internal OpenCL extensions documented below. ``__cl_clang_bitfields``; --------------------------------. With this extension it is possible to enable bitfields in structs; or unions using the OpenCL extension pragma mechanism detailed in; `the OpenCL Extension Specification, section 1.2; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview>`_. Use of bitfields in OpenCL kernels can result in reduced portability as struct; layout is not guaranteed to be consistent when compiled by different compilers.; If structs with bitfields are used as kernel function parameters, it can result; in incorrect functionality when the layout is different between the host and; device code. **Example of Use**:. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_bitfields : enable; struct with_bitfield {; unsigned int i : 5; // compiled - no diagnostic generated; };. #pragma OPENCL EXTENSION __cl_clang_bitfields : disable; struct without_bitfield {; unsigned int i : 5; // error - bitfields are not supported; };. ``__cl_clang_function_pointers``; --------------------------------. With this extension it is possible to enable various language features that; are relying on function pointers using regular OpenCL extension pragma; mechanism detailed in `the OpenCL Extension Specification,; section 1.2; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview>`_. In C++ for OpenCL t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:88430,Modifiability,portab,portably,88430,"lly. - the generated kernel binary does not contain indirect calls because they; are eliminated using compiler optimizations e.g. devirtualization. - the selected target supports the function pointer like functionality e.g.; most CPU targets. **Example of Use**:. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_function_pointers : enable; void foo(); {; void (*fp)(); // compiled - no diagnostic generated; }. #pragma OPENCL EXTENSION __cl_clang_function_pointers : disable; void bar(); {; void (*fp)(); // error - pointers to function are not allowed; }. ``__cl_clang_variadic_functions``; ---------------------------------. With this extension it is possible to enable variadic arguments in functions; using regular OpenCL extension pragma mechanism detailed in `the OpenCL; Extension Specification, section 1.2; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview>`_. This is not conformant behavior and it can only be used portably when the; functions with variadic prototypes do not get generated in binary e.g. the; variadic prototype is used to specify a function type with any number of; arguments in metaprogramming algorithms in C++ for OpenCL. This extensions can also be used when the kernel code is intended for targets; supporting the variadic arguments e.g. majority of CPU targets. **Example of Use**:. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_variadic_functions : enable; void foo(int a, ...); // compiled - no diagnostic generated. #pragma OPENCL EXTENSION __cl_clang_variadic_functions : disable; void bar(int a, ...); // error - variadic prototype is not allowed. ``__cl_clang_non_portable_kernel_param_types``; ----------------------------------------------. With this extension it is possible to enable the use of some restricted types; in kernel parameters specified in `C++ for OpenCL v1.0 s2.4; <https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html#kernel_function>`_.; The restrictions can be re",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:90947,Modifiability,variab,variable,90947,"onstructor.; // Standard layout type because there is only one access control.; struct OnlySL {; int a;; int b;; OnlySL() : a(0), b(0) {}; };. // Not standard layout type because of two different access controls.; struct NotSL {; int a;; private:; int b;; };. #pragma OPENCL EXTENSION __cl_clang_non_portable_kernel_param_types : enable; kernel void kernel_main(; Pod a,. OnlySL b,; global NotSL *c,; global OnlySL *d; );; #pragma OPENCL EXTENSION __cl_clang_non_portable_kernel_param_types : disable. Remove address space builtin function; -------------------------------------. ``__remove_address_space`` allows to derive types in C++ for OpenCL; that have address space qualifiers removed. This utility only affects; address space qualifiers, therefore, other type qualifiers such as; ``const`` or ``volatile`` remain unchanged. **Example of Use**:. .. code-block:: c++. template<typename T>; void foo(T *par){; T var1; // error - local function variable with global address space; __private T var2; // error - conflicting address space qualifiers; __private __remove_address_space<T>::type var3; // var3 is __private int; }. void bar(){; __global int* ptr;; foo(ptr);; }. Legacy 1.x atomics with generic address space; ---------------------------------------------. Clang allows use of atomic functions from the OpenCL 1.x standards; with the generic address space pointer in C++ for OpenCL mode. This is a non-portable feature and might not be supported by all; targets. **Example of Use**:. .. code-block:: c++. void foo(__generic volatile unsigned int* a) {; atomic_add(a, 1);; }. WebAssembly Features; ====================. Clang supports the WebAssembly features documented below. For further; information related to the semantics of the builtins, please refer to the `WebAssembly Specification <https://webassembly.github.io/spec/core/>`_.; In this section, when we refer to reference types, we are referring to; WebAssembly reference types, not C++ reference types unless stated; otherwise.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:91413,Modifiability,portab,portable,91413," EXTENSION __cl_clang_non_portable_kernel_param_types : disable. Remove address space builtin function; -------------------------------------. ``__remove_address_space`` allows to derive types in C++ for OpenCL; that have address space qualifiers removed. This utility only affects; address space qualifiers, therefore, other type qualifiers such as; ``const`` or ``volatile`` remain unchanged. **Example of Use**:. .. code-block:: c++. template<typename T>; void foo(T *par){; T var1; // error - local function variable with global address space; __private T var2; // error - conflicting address space qualifiers; __private __remove_address_space<T>::type var3; // var3 is __private int; }. void bar(){; __global int* ptr;; foo(ptr);; }. Legacy 1.x atomics with generic address space; ---------------------------------------------. Clang allows use of atomic functions from the OpenCL 1.x standards; with the generic address space pointer in C++ for OpenCL mode. This is a non-portable feature and might not be supported by all; targets. **Example of Use**:. .. code-block:: c++. void foo(__generic volatile unsigned int* a) {; atomic_add(a, 1);; }. WebAssembly Features; ====================. Clang supports the WebAssembly features documented below. For further; information related to the semantics of the builtins, please refer to the `WebAssembly Specification <https://webassembly.github.io/spec/core/>`_.; In this section, when we refer to reference types, we are referring to; WebAssembly reference types, not C++ reference types unless stated; otherwise. ``__builtin_wasm_table_set``; ----------------------------. This builtin function stores a value in a WebAssembly table.; It takes three arguments.; The first argument is the table to store a value into, the second; argument is the index to which to store the value into, and the; third argument is a value of reference type to store in the table.; It returns nothing. .. code-block:: c++. static __externref_t table[0];; extern __exter",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:96588,Modifiability,portab,portable,96588,"o copy. It returns nothing. .. code-block:: c++. static __externref_t tableSrc[0];; static __externref_t tableDst[0];. // Copy nelem elements from [src, src + nelem - 1] in tableSrc to; // [dst, dst + nelem - 1] in tableDst; void copy(int dst, int src, int nelem) {; __builtin_wasm_table_copy(tableDst, tableSrc, dst, src, nelem);; }. Builtin Functions; =================. Clang supports a number of builtin library functions with the same syntax as; GCC, including things like ``__builtin_nan``, ``__builtin_constant_p``,; ``__builtin_choose_expr``, ``__builtin_types_compatible_p``,; ``__builtin_assume_aligned``, ``__sync_fetch_and_add``, etc. In addition to; the GCC builtins, Clang supports a number of builtins that GCC does not, which; are listed here. Please note that Clang does not and will not support all of the GCC builtins; for vector operations. Instead of using builtins, you should use the functions; defined in target-specific header files like ``<xmmintrin.h>``, which define; portable wrappers for these. Many of the Clang versions of these functions are; implemented directly in terms of :ref:`extended vector support; <langext-vectors>` instead of builtins, in order to reduce the number of; builtins that we need to implement. ``__builtin_alloca``; --------------------. ``__builtin_alloca`` is used to dynamically allocate memory on the stack. Memory; is automatically freed upon function termination. **Syntax**:. .. code-block:: c++. __builtin_alloca(size_t n). **Example of Use**:. .. code-block:: c++. void init(float* data, size_t nbelems);; void process(float* data, size_t nbelems);; int foo(size_t n) {; auto mem = (float*)__builtin_alloca(n * sizeof(float));; init(mem, n);; process(mem, n);; /* mem is automatically freed at this point */; }. **Description**:. ``__builtin_alloca`` is meant to be used to allocate a dynamic amount of memory; on the stack. This amount is subject to stack allocation limits. Query for this feature with ``__has_builtin(__builtin_alloc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:96707,Modifiability,extend,extended,96707,"ments from [src, src + nelem - 1] in tableSrc to; // [dst, dst + nelem - 1] in tableDst; void copy(int dst, int src, int nelem) {; __builtin_wasm_table_copy(tableDst, tableSrc, dst, src, nelem);; }. Builtin Functions; =================. Clang supports a number of builtin library functions with the same syntax as; GCC, including things like ``__builtin_nan``, ``__builtin_constant_p``,; ``__builtin_choose_expr``, ``__builtin_types_compatible_p``,; ``__builtin_assume_aligned``, ``__sync_fetch_and_add``, etc. In addition to; the GCC builtins, Clang supports a number of builtins that GCC does not, which; are listed here. Please note that Clang does not and will not support all of the GCC builtins; for vector operations. Instead of using builtins, you should use the functions; defined in target-specific header files like ``<xmmintrin.h>``, which define; portable wrappers for these. Many of the Clang versions of these functions are; implemented directly in terms of :ref:`extended vector support; <langext-vectors>` instead of builtins, in order to reduce the number of; builtins that we need to implement. ``__builtin_alloca``; --------------------. ``__builtin_alloca`` is used to dynamically allocate memory on the stack. Memory; is automatically freed upon function termination. **Syntax**:. .. code-block:: c++. __builtin_alloca(size_t n). **Example of Use**:. .. code-block:: c++. void init(float* data, size_t nbelems);; void process(float* data, size_t nbelems);; int foo(size_t n) {; auto mem = (float*)__builtin_alloca(n * sizeof(float));; init(mem, n);; process(mem, n);; /* mem is automatically freed at this point */; }. **Description**:. ``__builtin_alloca`` is meant to be used to allocate a dynamic amount of memory; on the stack. This amount is subject to stack allocation limits. Query for this feature with ``__has_builtin(__builtin_alloca)``. ``__builtin_alloca_with_align``; -------------------------------. ``__builtin_alloca_with_align`` is used to dynamically allocate m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:100255,Modifiability,variab,variable,100255,"that information used to optimize the program. If the condition is violated; during execution, the behavior is undefined. The argument itself is never; evaluated, so any side effects of the expression will be discarded. Query for this feature with ``__has_builtin(__builtin_assume)``. .. _langext-__builtin_assume_separate_storage:. ``__builtin_assume_separate_storage``; -------------------------------------. ``__builtin_assume_separate_storage`` is used to provide the optimizer with the; knowledge that its two arguments point to separately allocated objects. **Syntax**:. .. code-block:: c++. __builtin_assume_separate_storage(const volatile void *, const volatile void *). **Example of Use**:. .. code-block:: c++. int foo(int *x, int *y) {; __builtin_assume_separate_storage(x, y);; *x = 0;; *y = 1;; // The optimizer may optimize this to return 0 without reloading from *x.; return *x;; }. **Description**:. The arguments to this function are assumed to point into separately allocated; storage (either different variable definitions or different dynamic storage; allocations). The optimizer may use this fact to aid in alias analysis. If the; arguments point into the same storage, the behavior is undefined. Note that the; definition of ""storage"" here refers to the outermost enclosing allocation of any; particular object (so for example, it's never correct to call this function; passing the addresses of fields in the same struct, elements of the same array,; etc.). Query for this feature with ``__has_builtin(__builtin_assume_separate_storage)``. ``__builtin_offsetof``; ----------------------. ``__builtin_offsetof`` is used to implement the ``offsetof`` macro, which; calculates the offset (in bytes) to a given member of the given type. **Syntax**:. .. code-block:: c++. __builtin_offsetof(type-name, member-designator). **Example of Use**:. .. code-block:: c++. struct S {; char c;; int i;; struct T {; float f[2];; } t;; };. const int offset_to_i = __builtin_offsetof(struct S, i)",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:101661,Modifiability,extend,extends,101661,"he same array,; etc.). Query for this feature with ``__has_builtin(__builtin_assume_separate_storage)``. ``__builtin_offsetof``; ----------------------. ``__builtin_offsetof`` is used to implement the ``offsetof`` macro, which; calculates the offset (in bytes) to a given member of the given type. **Syntax**:. .. code-block:: c++. __builtin_offsetof(type-name, member-designator). **Example of Use**:. .. code-block:: c++. struct S {; char c;; int i;; struct T {; float f[2];; } t;; };. const int offset_to_i = __builtin_offsetof(struct S, i);; const int ext1 = __builtin_offsetof(struct U { int i; }, i); // C extension; const int offset_to_subobject = __builtin_offsetof(struct S, t.f[1]);. **Description**:. This builtin is usable in an integer constant expression which returns a value; of type ``size_t``. The value returned is the offset in bytes to the subobject; designated by the member-designator from the beginning of an object of type; ``type-name``. Clang extends the required standard functionality in the; following way:. * In C language modes, the first argument may be the definition of a new type.; Any type declared this way is scoped to the nearest scope containing the call; to the builtin. Query for this feature with ``__has_builtin(__builtin_offsetof)``. ``__builtin_call_with_static_chain``; ------------------------------------. ``__builtin_call_with_static_chain`` is used to perform a static call while; setting updating the static chain register. **Syntax**:. .. code-block:: c++. T __builtin_call_with_static_chain(T expr, void* ptr). **Example of Use**:. .. code-block:: c++. auto v = __builtin_call_with_static_chain(foo(3), foo);. **Description**:. This builtin returns ``expr`` after checking that ``expr`` is a non-member; static call expression. The call to that expression is made while using ``ptr``; as a function pointer stored in a dedicated register to implement *static chain*; calling convention, as used by some language to implement closures or nested; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:116902,Modifiability,extend,extends,116902,"rstanding of which data; are going to be used next. ``addr`` is the address that needs to be brought into; the cache. ``rw`` indicates the expected access mode: ``0`` for *read* and ``1``; for *write*. In case of *read write* access, ``1`` is to be used. ``locality``; indicates the expected persistence of data in cache, from ``0`` which means that; data can be discarded from cache after its next use to ``3`` which means that; data is going to be reused a lot once in cache. ``1`` and ``2`` provide; intermediate behavior between these two extremes. Query for this feature with ``__has_builtin(__builtin_prefetch)``. ``__sync_swap``; ---------------. ``__sync_swap`` is used to atomically swap integers or pointers in memory. **Syntax**:. .. code-block:: c++. type __sync_swap(type *ptr, type value, ...). **Example of Use**:. .. code-block:: c++. int old_value = __sync_swap(&value, new_value);. **Description**:. The ``__sync_swap()`` builtin extends the existing ``__sync_*()`` family of; atomic intrinsics to allow code to atomically swap the current value with the; new value. More importantly, it helps developers write more efficient and; correct code by avoiding expensive loops around; ``__sync_bool_compare_and_swap()`` or relying on the platform specific; implementation details of ``__sync_lock_test_and_set()``. The; ``__sync_swap()`` builtin is a full barrier. ``__builtin_addressof``; -----------------------. ``__builtin_addressof`` performs the functionality of the built-in ``&``; operator, ignoring any ``operator&`` overload. This is useful in constant; expressions in C++11, where there is no other way to take the address of an; object that overloads ``operator&``. Clang automatically adds; ``[[clang::lifetimebound]]`` to the parameter of ``__builtin_addressof``. **Example of use**:. .. code-block:: c++. template<typename T> constexpr T *addressof(T &value) {; return __builtin_addressof(value);; }. ``__builtin_function_start``; -----------------------------. ``__builtin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:144287,Modifiability,variab,variable,144287,"upport atomic; scopes, then they will behave exactly as the standard GNU atomic builtins. Low-level ARM exclusive memory builtins; ---------------------------------------. Clang provides overloaded builtins giving direct access to the three key ARM; instructions for implementing atomic operations. .. code-block:: c. T __builtin_arm_ldrex(const volatile T *addr);; T __builtin_arm_ldaex(const volatile T *addr);; int __builtin_arm_strex(T val, volatile T *addr);; int __builtin_arm_stlex(T val, volatile T *addr);; void __builtin_arm_clrex(void);. The types ``T`` currently supported are:. * Integer types with width at most 64 bits (or 128 bits on AArch64).; * Floating-point types; * Pointer types. Note that the compiler does not guarantee it will not insert stores which clear; the exclusive monitor in between an ``ldrex`` type operation and its paired; ``strex``. In practice this is only usually a risk when the extra store is on; the same cache line as the variable being modified and Clang will only insert; stack stores on its own, so it is best not to use these operations on variables; with automatic storage duration. Also, loads and stores may be implicit in code written between the ``ldrex`` and; ``strex``. Clang will not necessarily mitigate the effects of these either, so; care should be exercised. For these reasons the higher level atomic primitives should be preferred where; possible. Non-temporal load/store builtins; --------------------------------. Clang provides overloaded builtins allowing generation of non-temporal memory; accesses. .. code-block:: c. T __builtin_nontemporal_load(T *addr);; void __builtin_nontemporal_store(T value, T *addr);. The types ``T`` currently supported are:. * Integer types.; * Floating-point types.; * Vector types. Note that the compiler does not guarantee that non-temporal loads or stores; will be used. C++ Coroutines support builtins; --------------------------------. .. warning::; This is a work in progress. Compatibility across ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:144409,Modifiability,variab,variables,144409,"upport atomic; scopes, then they will behave exactly as the standard GNU atomic builtins. Low-level ARM exclusive memory builtins; ---------------------------------------. Clang provides overloaded builtins giving direct access to the three key ARM; instructions for implementing atomic operations. .. code-block:: c. T __builtin_arm_ldrex(const volatile T *addr);; T __builtin_arm_ldaex(const volatile T *addr);; int __builtin_arm_strex(T val, volatile T *addr);; int __builtin_arm_stlex(T val, volatile T *addr);; void __builtin_arm_clrex(void);. The types ``T`` currently supported are:. * Integer types with width at most 64 bits (or 128 bits on AArch64).; * Floating-point types; * Pointer types. Note that the compiler does not guarantee it will not insert stores which clear; the exclusive monitor in between an ``ldrex`` type operation and its paired; ``strex``. In practice this is only usually a risk when the extra store is on; the same cache line as the variable being modified and Clang will only insert; stack stores on its own, so it is best not to use these operations on variables; with automatic storage duration. Also, loads and stores may be implicit in code written between the ``ldrex`` and; ``strex``. Clang will not necessarily mitigate the effects of these either, so; care should be exercised. For these reasons the higher level atomic primitives should be preferred where; possible. Non-temporal load/store builtins; --------------------------------. Clang provides overloaded builtins allowing generation of non-temporal memory; accesses. .. code-block:: c. T __builtin_nontemporal_load(T *addr);; void __builtin_nontemporal_store(T value, T *addr);. The types ``T`` currently supported are:. * Integer types.; * Floating-point types.; * Vector types. Note that the compiler does not guarantee that non-temporal loads or stores; will be used. C++ Coroutines support builtins; --------------------------------. .. warning::; This is a work in progress. Compatibility across ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:152889,Modifiability,variab,variables,152889,"_assert(!__builtin_is_aligned(123, 64), """");. **Description**:. The builtins ``__builtin_align_up``, ``__builtin_align_down``, return their; first argument aligned up/down to the next multiple of the second argument.; If the value is already sufficiently aligned, it is returned unchanged.; The builtin ``__builtin_is_aligned`` returns whether the first argument is; aligned to a multiple of the second argument.; All of these builtins expect the alignment to be expressed as a number of bytes. These builtins can be used for all integer types as well as (non-function); pointer types. For pointer types, these builtins operate in terms of the integer; address of the pointer and return a new pointer of the same type (including; qualifiers such as ``const``) with an adjusted address.; When aligning pointers up or down, the resulting value must be within the same; underlying allocation or one past the end (see C17 6.5.6p8, C++ [expr.add]).; This means that arbitrary integer values stored in pointer-type variables must; not be passed to these builtins. For those use cases, the builtins can still be; used, but the operation must be performed on the pointer cast to ``uintptr_t``. If Clang can determine that the alignment is not a power of two at compile time,; it will result in a compilation failure. If the alignment argument is not a; power of two at run time, the behavior of these builtins is undefined. Non-standard C++11 Attributes; =============================. Clang's non-standard C++11 attributes live in the ``clang`` attribute; namespace. Clang supports GCC's ``gnu`` attribute namespace. All GCC attributes which; are accepted with the ``__attribute__((foo))`` syntax are also accepted as; ``[[gnu::foo]]``. This only extends to attributes which are specified by GCC; (see the list of `GCC function attributes; <https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html>`_, `GCC variable; attributes <https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html>`_, and; `GCC t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:153620,Modifiability,extend,extends,153620,"When aligning pointers up or down, the resulting value must be within the same; underlying allocation or one past the end (see C17 6.5.6p8, C++ [expr.add]).; This means that arbitrary integer values stored in pointer-type variables must; not be passed to these builtins. For those use cases, the builtins can still be; used, but the operation must be performed on the pointer cast to ``uintptr_t``. If Clang can determine that the alignment is not a power of two at compile time,; it will result in a compilation failure. If the alignment argument is not a; power of two at run time, the behavior of these builtins is undefined. Non-standard C++11 Attributes; =============================. Clang's non-standard C++11 attributes live in the ``clang`` attribute; namespace. Clang supports GCC's ``gnu`` attribute namespace. All GCC attributes which; are accepted with the ``__attribute__((foo))`` syntax are also accepted as; ``[[gnu::foo]]``. This only extends to attributes which are specified by GCC; (see the list of `GCC function attributes; <https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html>`_, `GCC variable; attributes <https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html>`_, and; `GCC type attributes; <https://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html>`_). As with the GCC; implementation, these attributes must appertain to the *declarator-id* in a; declaration, which means they must go either at the start of the declaration or; immediately after the name being declared. For example, this applies the GNU ``unused`` attribute to ``a`` and ``f``, and; also applies the GNU ``noreturn`` attribute to ``f``. .. code-block:: c++. [[gnu::unused]] int a, f [[gnu::noreturn]] ();. Target-Specific Extensions; ==========================. Clang supports some language features conditionally on some targets. ARM/AArch64 Language Extensions; -------------------------------. Memory Barrier Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^; Clang implements the ``__dmb``, ``__dsb`` an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:153783,Modifiability,variab,variable,153783," C17 6.5.6p8, C++ [expr.add]).; This means that arbitrary integer values stored in pointer-type variables must; not be passed to these builtins. For those use cases, the builtins can still be; used, but the operation must be performed on the pointer cast to ``uintptr_t``. If Clang can determine that the alignment is not a power of two at compile time,; it will result in a compilation failure. If the alignment argument is not a; power of two at run time, the behavior of these builtins is undefined. Non-standard C++11 Attributes; =============================. Clang's non-standard C++11 attributes live in the ``clang`` attribute; namespace. Clang supports GCC's ``gnu`` attribute namespace. All GCC attributes which; are accepted with the ``__attribute__((foo))`` syntax are also accepted as; ``[[gnu::foo]]``. This only extends to attributes which are specified by GCC; (see the list of `GCC function attributes; <https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html>`_, `GCC variable; attributes <https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html>`_, and; `GCC type attributes; <https://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html>`_). As with the GCC; implementation, these attributes must appertain to the *declarator-id* in a; declaration, which means they must go either at the start of the declaration or; immediately after the name being declared. For example, this applies the GNU ``unused`` attribute to ``a`` and ``f``, and; also applies the GNU ``noreturn`` attribute to ``f``. .. code-block:: c++. [[gnu::unused]] int a, f [[gnu::noreturn]] ();. Target-Specific Extensions; ==========================. Clang supports some language features conditionally on some targets. ARM/AArch64 Language Extensions; -------------------------------. Memory Barrier Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^; Clang implements the ``__dmb``, ``__dsb`` and ``__isb`` intrinsics as defined; in the `Arm C Language Extensions; <https://github.com/ARM-software/acle/releases>`_.; Not",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:173761,Modifiability,extend,extended,173761,"ock:: c++. void func(float *dest, float a, float b) {; #pragma clang fp exceptions(maytrap) contract(fast) reassociate(on); ...; }. ``#pragma clang fp eval_method`` allows floating-point behavior to be specified; for a section of the source code. This pragma can appear at file or namespace; scope, or at the start of a compound statement (excluding comments).; The pragma is active within the scope of the compound statement. When ``pragma clang fp eval_method(source)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=source`` is enabled. Rounds intermediate results to; source-defined precision. When ``pragma clang fp eval_method(double)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=double`` is enabled. Rounds intermediate results to; ``double`` precision. When ``pragma clang fp eval_method(extended)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=extended`` is enabled. Rounds intermediate results to; target-dependent ``long double`` precision. In Win32 programming, for instance,; the long double data type maps to the double, 64-bit precision data type. The full syntax this pragma supports is; ``#pragma clang fp eval_method(source|double|extended)``. .. code-block:: c++. for(...) {; // The compiler will use long double as the floating-point evaluation; // method.; #pragma clang fp eval_method(extended); a = b[i] * c[i] + e;; }. Note: ``math.h`` defines the typedefs ``float_t`` and ``double_t`` based on the active; evaluation method at the point where the header is included, not where the; typedefs are used. Because of this, it is unwise to combine these typedefs with; ``#pragma clang fp eval_method``. To catch obvious bugs, Clang will emit an; error for any references to these typedefs within the scope of this pragma;; however, this is not a fool-proof prote",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:173891,Modifiability,extend,extended,173891,"ock:: c++. void func(float *dest, float a, float b) {; #pragma clang fp exceptions(maytrap) contract(fast) reassociate(on); ...; }. ``#pragma clang fp eval_method`` allows floating-point behavior to be specified; for a section of the source code. This pragma can appear at file or namespace; scope, or at the start of a compound statement (excluding comments).; The pragma is active within the scope of the compound statement. When ``pragma clang fp eval_method(source)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=source`` is enabled. Rounds intermediate results to; source-defined precision. When ``pragma clang fp eval_method(double)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=double`` is enabled. Rounds intermediate results to; ``double`` precision. When ``pragma clang fp eval_method(extended)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=extended`` is enabled. Rounds intermediate results to; target-dependent ``long double`` precision. In Win32 programming, for instance,; the long double data type maps to the double, 64-bit precision data type. The full syntax this pragma supports is; ``#pragma clang fp eval_method(source|double|extended)``. .. code-block:: c++. for(...) {; // The compiler will use long double as the floating-point evaluation; // method.; #pragma clang fp eval_method(extended); a = b[i] * c[i] + e;; }. Note: ``math.h`` defines the typedefs ``float_t`` and ``double_t`` based on the active; evaluation method at the point where the header is included, not where the; typedefs are used. Because of this, it is unwise to combine these typedefs with; ``#pragma clang fp eval_method``. To catch obvious bugs, Clang will emit an; error for any references to these typedefs within the scope of this pragma;; however, this is not a fool-proof prote",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:174187,Modifiability,extend,extended,174187,"tatement (excluding comments).; The pragma is active within the scope of the compound statement. When ``pragma clang fp eval_method(source)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=source`` is enabled. Rounds intermediate results to; source-defined precision. When ``pragma clang fp eval_method(double)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=double`` is enabled. Rounds intermediate results to; ``double`` precision. When ``pragma clang fp eval_method(extended)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=extended`` is enabled. Rounds intermediate results to; target-dependent ``long double`` precision. In Win32 programming, for instance,; the long double data type maps to the double, 64-bit precision data type. The full syntax this pragma supports is; ``#pragma clang fp eval_method(source|double|extended)``. .. code-block:: c++. for(...) {; // The compiler will use long double as the floating-point evaluation; // method.; #pragma clang fp eval_method(extended); a = b[i] * c[i] + e;; }. Note: ``math.h`` defines the typedefs ``float_t`` and ``double_t`` based on the active; evaluation method at the point where the header is included, not where the; typedefs are used. Because of this, it is unwise to combine these typedefs with; ``#pragma clang fp eval_method``. To catch obvious bugs, Clang will emit an; error for any references to these typedefs within the scope of this pragma;; however, this is not a fool-proof protection, and programmers must take care. The ``#pragma float_control`` pragma allows precise floating-point; semantics and floating-point exception behavior to be specified; for a section of the source code. This pragma can only appear at file or; namespace scope, within a language linkage specification or at the start of a; compou",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:174345,Modifiability,extend,extended,174345,"behaves as though the command-line option; ``-ffp-eval-method=source`` is enabled. Rounds intermediate results to; source-defined precision. When ``pragma clang fp eval_method(double)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=double`` is enabled. Rounds intermediate results to; ``double`` precision. When ``pragma clang fp eval_method(extended)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=extended`` is enabled. Rounds intermediate results to; target-dependent ``long double`` precision. In Win32 programming, for instance,; the long double data type maps to the double, 64-bit precision data type. The full syntax this pragma supports is; ``#pragma clang fp eval_method(source|double|extended)``. .. code-block:: c++. for(...) {; // The compiler will use long double as the floating-point evaluation; // method.; #pragma clang fp eval_method(extended); a = b[i] * c[i] + e;; }. Note: ``math.h`` defines the typedefs ``float_t`` and ``double_t`` based on the active; evaluation method at the point where the header is included, not where the; typedefs are used. Because of this, it is unwise to combine these typedefs with; ``#pragma clang fp eval_method``. To catch obvious bugs, Clang will emit an; error for any references to these typedefs within the scope of this pragma;; however, this is not a fool-proof protection, and programmers must take care. The ``#pragma float_control`` pragma allows precise floating-point; semantics and floating-point exception behavior to be specified; for a section of the source code. This pragma can only appear at file or; namespace scope, within a language linkage specification or at the start of a; compound statement (excluding comments). When used within a compound statement,; the pragma is active within the scope of the compound statement. This pragma; is modeled after a Microsoft pragma with the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:183126,Modifiability,variab,variables,183126,"attribute push([[nodiscard]], apply_to = any(record, namespace)). #pragma clang attribute pop. Multiple match rules can be specified using the ``any`` match rule, as shown; in the example above. The ``any`` rule applies attributes to all declarations; that are matched by at least one of the rules in the ``any``. It doesn't nest; and can't be used inside the other match rules. Redundant match rules or rules; that conflict with one another should not be used inside of ``any``. Failing to; specify a rule within the ``any`` rule results in an error. Clang supports the following match rules:. - ``function``: Can be used to apply attributes to functions. This includes C++; member functions, static functions, operators, and constructors/destructors. - ``function(is_member)``: Can be used to apply attributes to C++ member; functions. This includes members like static functions, operators, and; constructors/destructors. - ``hasType(functionType)``: Can be used to apply attributes to functions, C++; member functions, and variables/fields whose type is a function pointer. It; does not apply attributes to Objective-C methods or blocks. - ``type_alias``: Can be used to apply attributes to ``typedef`` declarations; and C++11 type aliases. - ``record``: Can be used to apply attributes to ``struct``, ``class``, and; ``union`` declarations. - ``record(unless(is_union))``: Can be used to apply attributes only to; ``struct`` and ``class`` declarations. - ``enum``: Can be used to apply attributes to enumeration declarations. - ``enum_constant``: Can be used to apply attributes to enumerators. - ``variable``: Can be used to apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global var",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:183703,Modifiability,variab,variable,183703,"+; member functions, static functions, operators, and constructors/destructors. - ``function(is_member)``: Can be used to apply attributes to C++ member; functions. This includes members like static functions, operators, and; constructors/destructors. - ``hasType(functionType)``: Can be used to apply attributes to functions, C++; member functions, and variables/fields whose type is a function pointer. It; does not apply attributes to Objective-C methods or blocks. - ``type_alias``: Can be used to apply attributes to ``typedef`` declarations; and C++11 type aliases. - ``record``: Can be used to apply attributes to ``struct``, ``class``, and; ``union`` declarations. - ``record(unless(is_union))``: Can be used to apply attributes only to; ``struct`` and ``class`` declarations. - ``enum``: Can be used to apply attributes to enumeration declarations. - ``enum_constant``: Can be used to apply attributes to enumerators. - ``variable``: Can be used to apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global variables; only. - ``variable(is_local)``: Can be used to apply attributes to local variables; only. - ``variable(is_parameter)``: Can be used to apply attributes to parameters; only. - ``variable(unless(is_parameter))``: Can be used to apply attributes to all; the variables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:183750,Modifiability,variab,variables,183750,"+; member functions, static functions, operators, and constructors/destructors. - ``function(is_member)``: Can be used to apply attributes to C++ member; functions. This includes members like static functions, operators, and; constructors/destructors. - ``hasType(functionType)``: Can be used to apply attributes to functions, C++; member functions, and variables/fields whose type is a function pointer. It; does not apply attributes to Objective-C methods or blocks. - ``type_alias``: Can be used to apply attributes to ``typedef`` declarations; and C++11 type aliases. - ``record``: Can be used to apply attributes to ``struct``, ``class``, and; ``union`` declarations. - ``record(unless(is_union))``: Can be used to apply attributes only to; ``struct`` and ``class`` declarations. - ``enum``: Can be used to apply attributes to enumeration declarations. - ``enum_constant``: Can be used to apply attributes to enumerators. - ``variable``: Can be used to apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global variables; only. - ``variable(is_local)``: Can be used to apply attributes to local variables; only. - ``variable(is_parameter)``: Can be used to apply attributes to parameters; only. - ``variable(unless(is_parameter))``: Can be used to apply attributes to all; the variables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:183778,Modifiability,variab,variables,183778,"+; member functions, static functions, operators, and constructors/destructors. - ``function(is_member)``: Can be used to apply attributes to C++ member; functions. This includes members like static functions, operators, and; constructors/destructors. - ``hasType(functionType)``: Can be used to apply attributes to functions, C++; member functions, and variables/fields whose type is a function pointer. It; does not apply attributes to Objective-C methods or blocks. - ``type_alias``: Can be used to apply attributes to ``typedef`` declarations; and C++11 type aliases. - ``record``: Can be used to apply attributes to ``struct``, ``class``, and; ``union`` declarations. - ``record(unless(is_union))``: Can be used to apply attributes only to; ``struct`` and ``class`` declarations. - ``enum``: Can be used to apply attributes to enumeration declarations. - ``enum_constant``: Can be used to apply attributes to enumerators. - ``variable``: Can be used to apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global variables; only. - ``variable(is_local)``: Can be used to apply attributes to local variables; only. - ``variable(is_parameter)``: Can be used to apply attributes to parameters; only. - ``variable(unless(is_parameter))``: Can be used to apply attributes to all; the variables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:183808,Modifiability,variab,variables,183808,"+; member functions, static functions, operators, and constructors/destructors. - ``function(is_member)``: Can be used to apply attributes to C++ member; functions. This includes members like static functions, operators, and; constructors/destructors. - ``hasType(functionType)``: Can be used to apply attributes to functions, C++; member functions, and variables/fields whose type is a function pointer. It; does not apply attributes to Objective-C methods or blocks. - ``type_alias``: Can be used to apply attributes to ``typedef`` declarations; and C++11 type aliases. - ``record``: Can be used to apply attributes to ``struct``, ``class``, and; ``union`` declarations. - ``record(unless(is_union))``: Can be used to apply attributes only to; ``struct`` and ``class`` declarations. - ``enum``: Can be used to apply attributes to enumeration declarations. - ``enum_constant``: Can be used to apply attributes to enumerators. - ``variable``: Can be used to apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global variables; only. - ``variable(is_local)``: Can be used to apply attributes to local variables; only. - ``variable(is_parameter)``: Can be used to apply attributes to parameters; only. - ``variable(unless(is_parameter))``: Can be used to apply attributes to all; the variables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:183837,Modifiability,variab,variables,183837,"+; member functions, static functions, operators, and constructors/destructors. - ``function(is_member)``: Can be used to apply attributes to C++ member; functions. This includes members like static functions, operators, and; constructors/destructors. - ``hasType(functionType)``: Can be used to apply attributes to functions, C++; member functions, and variables/fields whose type is a function pointer. It; does not apply attributes to Objective-C methods or blocks. - ``type_alias``: Can be used to apply attributes to ``typedef`` declarations; and C++11 type aliases. - ``record``: Can be used to apply attributes to ``struct``, ``class``, and; ``union`` declarations. - ``record(unless(is_union))``: Can be used to apply attributes only to; ``struct`` and ``class`` declarations. - ``enum``: Can be used to apply attributes to enumeration declarations. - ``enum_constant``: Can be used to apply attributes to enumerators. - ``variable``: Can be used to apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global variables; only. - ``variable(is_local)``: Can be used to apply attributes to local variables; only. - ``variable(is_parameter)``: Can be used to apply attributes to parameters; only. - ``variable(unless(is_parameter))``: Can be used to apply attributes to all; the variables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:183897,Modifiability,variab,variables,183897,"ed to apply attributes to C++ member; functions. This includes members like static functions, operators, and; constructors/destructors. - ``hasType(functionType)``: Can be used to apply attributes to functions, C++; member functions, and variables/fields whose type is a function pointer. It; does not apply attributes to Objective-C methods or blocks. - ``type_alias``: Can be used to apply attributes to ``typedef`` declarations; and C++11 type aliases. - ``record``: Can be used to apply attributes to ``struct``, ``class``, and; ``union`` declarations. - ``record(unless(is_union))``: Can be used to apply attributes only to; ``struct`` and ``class`` declarations. - ``enum``: Can be used to apply attributes to enumeration declarations. - ``enum_constant``: Can be used to apply attributes to enumerators. - ``variable``: Can be used to apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global variables; only. - ``variable(is_local)``: Can be used to apply attributes to local variables; only. - ``variable(is_parameter)``: Can be used to apply attributes to parameters; only. - ``variable(unless(is_parameter))``: Can be used to apply attributes to all; the variables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. - ``objc_category``: Can be used to apply attributes to category declarations,; including class extensions. - ``obj",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:183934,Modifiability,variab,variable,183934,"ns, operators, and; constructors/destructors. - ``hasType(functionType)``: Can be used to apply attributes to functions, C++; member functions, and variables/fields whose type is a function pointer. It; does not apply attributes to Objective-C methods or blocks. - ``type_alias``: Can be used to apply attributes to ``typedef`` declarations; and C++11 type aliases. - ``record``: Can be used to apply attributes to ``struct``, ``class``, and; ``union`` declarations. - ``record(unless(is_union))``: Can be used to apply attributes only to; ``struct`` and ``class`` declarations. - ``enum``: Can be used to apply attributes to enumeration declarations. - ``enum_constant``: Can be used to apply attributes to enumerators. - ``variable``: Can be used to apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global variables; only. - ``variable(is_local)``: Can be used to apply attributes to local variables; only. - ``variable(is_parameter)``: Can be used to apply attributes to parameters; only. - ``variable(unless(is_parameter))``: Can be used to apply attributes to all; the variables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. - ``objc_category``: Can be used to apply attributes to category declarations,; including class extensions. - ``objc_method``: Can be used to apply attributes to Objective-C methods,; including instance an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:184012,Modifiability,variab,variables,184012,"ns, operators, and; constructors/destructors. - ``hasType(functionType)``: Can be used to apply attributes to functions, C++; member functions, and variables/fields whose type is a function pointer. It; does not apply attributes to Objective-C methods or blocks. - ``type_alias``: Can be used to apply attributes to ``typedef`` declarations; and C++11 type aliases. - ``record``: Can be used to apply attributes to ``struct``, ``class``, and; ``union`` declarations. - ``record(unless(is_union))``: Can be used to apply attributes only to; ``struct`` and ``class`` declarations. - ``enum``: Can be used to apply attributes to enumeration declarations. - ``enum_constant``: Can be used to apply attributes to enumerators. - ``variable``: Can be used to apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global variables; only. - ``variable(is_local)``: Can be used to apply attributes to local variables; only. - ``variable(is_parameter)``: Can be used to apply attributes to parameters; only. - ``variable(unless(is_parameter))``: Can be used to apply attributes to all; the variables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. - ``objc_category``: Can be used to apply attributes to category declarations,; including class extensions. - ``objc_method``: Can be used to apply attributes to Objective-C methods,; including instance an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:184032,Modifiability,variab,variable,184032,"ply attributes to functions, C++; member functions, and variables/fields whose type is a function pointer. It; does not apply attributes to Objective-C methods or blocks. - ``type_alias``: Can be used to apply attributes to ``typedef`` declarations; and C++11 type aliases. - ``record``: Can be used to apply attributes to ``struct``, ``class``, and; ``union`` declarations. - ``record(unless(is_union))``: Can be used to apply attributes only to; ``struct`` and ``class`` declarations. - ``enum``: Can be used to apply attributes to enumeration declarations. - ``enum_constant``: Can be used to apply attributes to enumerators. - ``variable``: Can be used to apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global variables; only. - ``variable(is_local)``: Can be used to apply attributes to local variables; only. - ``variable(is_parameter)``: Can be used to apply attributes to parameters; only. - ``variable(unless(is_parameter))``: Can be used to apply attributes to all; the variables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. - ``objc_category``: Can be used to apply attributes to category declarations,; including class extensions. - ``objc_method``: Can be used to apply attributes to Objective-C methods,; including instance and class methods. Implicit methods like implicit property; getters and setters do not receive",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:184097,Modifiability,variab,variables,184097,"ply attributes to functions, C++; member functions, and variables/fields whose type is a function pointer. It; does not apply attributes to Objective-C methods or blocks. - ``type_alias``: Can be used to apply attributes to ``typedef`` declarations; and C++11 type aliases. - ``record``: Can be used to apply attributes to ``struct``, ``class``, and; ``union`` declarations. - ``record(unless(is_union))``: Can be used to apply attributes only to; ``struct`` and ``class`` declarations. - ``enum``: Can be used to apply attributes to enumeration declarations. - ``enum_constant``: Can be used to apply attributes to enumerators. - ``variable``: Can be used to apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global variables; only. - ``variable(is_local)``: Can be used to apply attributes to local variables; only. - ``variable(is_parameter)``: Can be used to apply attributes to parameters; only. - ``variable(unless(is_parameter))``: Can be used to apply attributes to all; the variables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. - ``objc_category``: Can be used to apply attributes to category declarations,; including class extensions. - ``objc_method``: Can be used to apply attributes to Objective-C methods,; including instance and class methods. Implicit methods like implicit property; getters and setters do not receive",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:184118,Modifiability,variab,variable,184118,"s a function pointer. It; does not apply attributes to Objective-C methods or blocks. - ``type_alias``: Can be used to apply attributes to ``typedef`` declarations; and C++11 type aliases. - ``record``: Can be used to apply attributes to ``struct``, ``class``, and; ``union`` declarations. - ``record(unless(is_union))``: Can be used to apply attributes only to; ``struct`` and ``class`` declarations. - ``enum``: Can be used to apply attributes to enumeration declarations. - ``enum_constant``: Can be used to apply attributes to enumerators. - ``variable``: Can be used to apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global variables; only. - ``variable(is_local)``: Can be used to apply attributes to local variables; only. - ``variable(is_parameter)``: Can be used to apply attributes to parameters; only. - ``variable(unless(is_parameter))``: Can be used to apply attributes to all; the variables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. - ``objc_category``: Can be used to apply attributes to category declarations,; including class extensions. - ``objc_method``: Can be used to apply attributes to Objective-C methods,; including instance and class methods. Implicit methods like implicit property; getters and setters do not receive the attribute. - ``objc_method(is_instance)``: Can be used to apply attributes to Ob",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:184181,Modifiability,variab,variables,184181,"s a function pointer. It; does not apply attributes to Objective-C methods or blocks. - ``type_alias``: Can be used to apply attributes to ``typedef`` declarations; and C++11 type aliases. - ``record``: Can be used to apply attributes to ``struct``, ``class``, and; ``union`` declarations. - ``record(unless(is_union))``: Can be used to apply attributes only to; ``struct`` and ``class`` declarations. - ``enum``: Can be used to apply attributes to enumeration declarations. - ``enum_constant``: Can be used to apply attributes to enumerators. - ``variable``: Can be used to apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global variables; only. - ``variable(is_local)``: Can be used to apply attributes to local variables; only. - ``variable(is_parameter)``: Can be used to apply attributes to parameters; only. - ``variable(unless(is_parameter))``: Can be used to apply attributes to all; the variables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. - ``objc_category``: Can be used to apply attributes to category declarations,; including class extensions. - ``objc_method``: Can be used to apply attributes to Objective-C methods,; including instance and class methods. Implicit methods like implicit property; getters and setters do not receive the attribute. - ``objc_method(is_instance)``: Can be used to apply attributes to Ob",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:184202,Modifiability,variab,variable,184202,"s. - ``type_alias``: Can be used to apply attributes to ``typedef`` declarations; and C++11 type aliases. - ``record``: Can be used to apply attributes to ``struct``, ``class``, and; ``union`` declarations. - ``record(unless(is_union))``: Can be used to apply attributes only to; ``struct`` and ``class`` declarations. - ``enum``: Can be used to apply attributes to enumeration declarations. - ``enum_constant``: Can be used to apply attributes to enumerators. - ``variable``: Can be used to apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global variables; only. - ``variable(is_local)``: Can be used to apply attributes to local variables; only. - ``variable(is_parameter)``: Can be used to apply attributes to parameters; only. - ``variable(unless(is_parameter))``: Can be used to apply attributes to all; the variables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. - ``objc_category``: Can be used to apply attributes to category declarations,; including class extensions. - ``objc_method``: Can be used to apply attributes to Objective-C methods,; including instance and class methods. Implicit methods like implicit property; getters and setters do not receive the attribute. - ``objc_method(is_instance)``: Can be used to apply attributes to Objective-C; instance methods. - ``objc_property``: Can be used to apply attributes to",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:184285,Modifiability,variab,variable,184285,"ases. - ``record``: Can be used to apply attributes to ``struct``, ``class``, and; ``union`` declarations. - ``record(unless(is_union))``: Can be used to apply attributes only to; ``struct`` and ``class`` declarations. - ``enum``: Can be used to apply attributes to enumeration declarations. - ``enum_constant``: Can be used to apply attributes to enumerators. - ``variable``: Can be used to apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global variables; only. - ``variable(is_local)``: Can be used to apply attributes to local variables; only. - ``variable(is_parameter)``: Can be used to apply attributes to parameters; only. - ``variable(unless(is_parameter))``: Can be used to apply attributes to all; the variables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. - ``objc_category``: Can be used to apply attributes to category declarations,; including class extensions. - ``objc_method``: Can be used to apply attributes to Objective-C methods,; including instance and class methods. Implicit methods like implicit property; getters and setters do not receive the attribute. - ``objc_method(is_instance)``: Can be used to apply attributes to Objective-C; instance methods. - ``objc_property``: Can be used to apply attributes to ``@property``; declarations. - ``block``: Can be used to apply attributes to block declarations. Th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:184363,Modifiability,variab,variables,184363,"ases. - ``record``: Can be used to apply attributes to ``struct``, ``class``, and; ``union`` declarations. - ``record(unless(is_union))``: Can be used to apply attributes only to; ``struct`` and ``class`` declarations. - ``enum``: Can be used to apply attributes to enumeration declarations. - ``enum_constant``: Can be used to apply attributes to enumerators. - ``variable``: Can be used to apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global variables; only. - ``variable(is_local)``: Can be used to apply attributes to local variables; only. - ``variable(is_parameter)``: Can be used to apply attributes to parameters; only. - ``variable(unless(is_parameter))``: Can be used to apply attributes to all; the variables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. - ``objc_category``: Can be used to apply attributes to category declarations,; including class extensions. - ``objc_method``: Can be used to apply attributes to Objective-C methods,; including instance and class methods. Implicit methods like implicit property; getters and setters do not receive the attribute. - ``objc_method(is_instance)``: Can be used to apply attributes to Objective-C; instance methods. - ``objc_property``: Can be used to apply attributes to ``@property``; declarations. - ``block``: Can be used to apply attributes to block declarations. Th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:184464,Modifiability,variab,variables,184464,"s. - ``record(unless(is_union))``: Can be used to apply attributes only to; ``struct`` and ``class`` declarations. - ``enum``: Can be used to apply attributes to enumeration declarations. - ``enum_constant``: Can be used to apply attributes to enumerators. - ``variable``: Can be used to apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global variables; only. - ``variable(is_local)``: Can be used to apply attributes to local variables; only. - ``variable(is_parameter)``: Can be used to apply attributes to parameters; only. - ``variable(unless(is_parameter))``: Can be used to apply attributes to all; the variables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. - ``objc_category``: Can be used to apply attributes to category declarations,; including class extensions. - ``objc_method``: Can be used to apply attributes to Objective-C methods,; including instance and class methods. Implicit methods like implicit property; getters and setters do not receive the attribute. - ``objc_method(is_instance)``: Can be used to apply attributes to Objective-C; instance methods. - ``objc_property``: Can be used to apply attributes to ``@property``; declarations. - ``block``: Can be used to apply attributes to block declarations. This does; not include variables/fields of block pointer type. The use of ``unless`` in match rules is cu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:185360,Modifiability,variab,variables,185360,"ables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. - ``objc_category``: Can be used to apply attributes to category declarations,; including class extensions. - ``objc_method``: Can be used to apply attributes to Objective-C methods,; including instance and class methods. Implicit methods like implicit property; getters and setters do not receive the attribute. - ``objc_method(is_instance)``: Can be used to apply attributes to Objective-C; instance methods. - ``objc_property``: Can be used to apply attributes to ``@property``; declarations. - ``block``: Can be used to apply attributes to block declarations. This does; not include variables/fields of block pointer type. The use of ``unless`` in match rules is currently restricted to a strict set of; sub-rules that are used by the supported attributes. That means that even though; ``variable(unless(is_parameter))`` is a valid match rule,; ``variable(unless(is_thread_local))`` is not. Supported Attributes; --------------------. Not all attributes can be used with the ``#pragma clang attribute`` directive.; Notably, statement attributes like ``[[fallthrough]]`` or type attributes; like ``address_space`` aren't supported by this directive. You can determine; whether or not an attribute is supported by the pragma by referring to the; :doc:`individual documentation for that attribute <AttributeReference>`. The attributes are applied to all matching declarations individually, even when; the attribute is semantically incorrect. The attributes that aren't applied to; any declaration are not verified semantically. Specifying section names for global objects (#pragma clang section",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:185565,Modifiability,variab,variable,185565," - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. - ``objc_category``: Can be used to apply attributes to category declarations,; including class extensions. - ``objc_method``: Can be used to apply attributes to Objective-C methods,; including instance and class methods. Implicit methods like implicit property; getters and setters do not receive the attribute. - ``objc_method(is_instance)``: Can be used to apply attributes to Objective-C; instance methods. - ``objc_property``: Can be used to apply attributes to ``@property``; declarations. - ``block``: Can be used to apply attributes to block declarations. This does; not include variables/fields of block pointer type. The use of ``unless`` in match rules is currently restricted to a strict set of; sub-rules that are used by the supported attributes. That means that even though; ``variable(unless(is_parameter))`` is a valid match rule,; ``variable(unless(is_thread_local))`` is not. Supported Attributes; --------------------. Not all attributes can be used with the ``#pragma clang attribute`` directive.; Notably, statement attributes like ``[[fallthrough]]`` or type attributes; like ``address_space`` aren't supported by this directive. You can determine; whether or not an attribute is supported by the pragma by referring to the; :doc:`individual documentation for that attribute <AttributeReference>`. The attributes are applied to all matching declarations individually, even when; the attribute is semantically incorrect. The attributes that aren't applied to; any declaration are not verified semantically. Specifying section names for global objects (#pragma clang section); ===================================================================. The ``#pragma clang section`` directive provides a means to assign section-names; to global variables, functions and static variables. The section names can be ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:185624,Modifiability,variab,variable,185624," - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. - ``objc_category``: Can be used to apply attributes to category declarations,; including class extensions. - ``objc_method``: Can be used to apply attributes to Objective-C methods,; including instance and class methods. Implicit methods like implicit property; getters and setters do not receive the attribute. - ``objc_method(is_instance)``: Can be used to apply attributes to Objective-C; instance methods. - ``objc_property``: Can be used to apply attributes to ``@property``; declarations. - ``block``: Can be used to apply attributes to block declarations. This does; not include variables/fields of block pointer type. The use of ``unless`` in match rules is currently restricted to a strict set of; sub-rules that are used by the supported attributes. That means that even though; ``variable(unless(is_parameter))`` is a valid match rule,; ``variable(unless(is_thread_local))`` is not. Supported Attributes; --------------------. Not all attributes can be used with the ``#pragma clang attribute`` directive.; Notably, statement attributes like ``[[fallthrough]]`` or type attributes; like ``address_space`` aren't supported by this directive. You can determine; whether or not an attribute is supported by the pragma by referring to the; :doc:`individual documentation for that attribute <AttributeReference>`. The attributes are applied to all matching declarations individually, even when; the attribute is semantically incorrect. The attributes that aren't applied to; any declaration are not verified semantically. Specifying section names for global objects (#pragma clang section); ===================================================================. The ``#pragma clang section`` directive provides a means to assign section-names; to global variables, functions and static variables. The section names can be ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:186532,Modifiability,variab,variables,186532,"y the supported attributes. That means that even though; ``variable(unless(is_parameter))`` is a valid match rule,; ``variable(unless(is_thread_local))`` is not. Supported Attributes; --------------------. Not all attributes can be used with the ``#pragma clang attribute`` directive.; Notably, statement attributes like ``[[fallthrough]]`` or type attributes; like ``address_space`` aren't supported by this directive. You can determine; whether or not an attribute is supported by the pragma by referring to the; :doc:`individual documentation for that attribute <AttributeReference>`. The attributes are applied to all matching declarations individually, even when; the attribute is semantically incorrect. The attributes that aren't applied to; any declaration are not verified semantically. Specifying section names for global objects (#pragma clang section); ===================================================================. The ``#pragma clang section`` directive provides a means to assign section-names; to global variables, functions and static variables. The section names can be specified as:. .. code-block:: c++. #pragma clang section bss=""myBSS"" data=""myData"" rodata=""myRodata"" relro=""myRelro"" text=""myText"". The section names can be reverted back to default name by supplying an empty; string to the section kind, for example:. .. code-block:: c++. #pragma clang section bss="""" data="""" text="""" rodata="""" relro="""". The ``#pragma clang section`` directive obeys the following rules:. * The pragma applies to all global variable, statics and function declarations; from the pragma to the end of the translation unit. * The pragma clang section is enabled automatically, without need of any flags. * This feature is only defined to work sensibly for ELF targets. * If section name is specified through _attribute_((section(""myname""))), then; the attribute name gains precedence. * Global variables that are initialized to zero will be placed in the named; bss section, if one is present",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:186564,Modifiability,variab,variables,186564,"y the supported attributes. That means that even though; ``variable(unless(is_parameter))`` is a valid match rule,; ``variable(unless(is_thread_local))`` is not. Supported Attributes; --------------------. Not all attributes can be used with the ``#pragma clang attribute`` directive.; Notably, statement attributes like ``[[fallthrough]]`` or type attributes; like ``address_space`` aren't supported by this directive. You can determine; whether or not an attribute is supported by the pragma by referring to the; :doc:`individual documentation for that attribute <AttributeReference>`. The attributes are applied to all matching declarations individually, even when; the attribute is semantically incorrect. The attributes that aren't applied to; any declaration are not verified semantically. Specifying section names for global objects (#pragma clang section); ===================================================================. The ``#pragma clang section`` directive provides a means to assign section-names; to global variables, functions and static variables. The section names can be specified as:. .. code-block:: c++. #pragma clang section bss=""myBSS"" data=""myData"" rodata=""myRodata"" relro=""myRelro"" text=""myText"". The section names can be reverted back to default name by supplying an empty; string to the section kind, for example:. .. code-block:: c++. #pragma clang section bss="""" data="""" text="""" rodata="""" relro="""". The ``#pragma clang section`` directive obeys the following rules:. * The pragma applies to all global variable, statics and function declarations; from the pragma to the end of the translation unit. * The pragma clang section is enabled automatically, without need of any flags. * This feature is only defined to work sensibly for ELF targets. * If section name is specified through _attribute_((section(""myname""))), then; the attribute name gains precedence. * Global variables that are initialized to zero will be placed in the named; bss section, if one is present",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:187042,Modifiability,variab,variable,187042,"AttributeReference>`. The attributes are applied to all matching declarations individually, even when; the attribute is semantically incorrect. The attributes that aren't applied to; any declaration are not verified semantically. Specifying section names for global objects (#pragma clang section); ===================================================================. The ``#pragma clang section`` directive provides a means to assign section-names; to global variables, functions and static variables. The section names can be specified as:. .. code-block:: c++. #pragma clang section bss=""myBSS"" data=""myData"" rodata=""myRodata"" relro=""myRelro"" text=""myText"". The section names can be reverted back to default name by supplying an empty; string to the section kind, for example:. .. code-block:: c++. #pragma clang section bss="""" data="""" text="""" rodata="""" relro="""". The ``#pragma clang section`` directive obeys the following rules:. * The pragma applies to all global variable, statics and function declarations; from the pragma to the end of the translation unit. * The pragma clang section is enabled automatically, without need of any flags. * This feature is only defined to work sensibly for ELF targets. * If section name is specified through _attribute_((section(""myname""))), then; the attribute name gains precedence. * Global variables that are initialized to zero will be placed in the named; bss section, if one is present. * The ``#pragma clang section`` directive does not does try to infer section-kind; from the name. For example, naming a section ""``.bss.mySec``"" does NOT mean; it will be a bss section name. * The decision about which section-kind applies to each global is taken in the back-end.; Once the section-kind is known, appropriate section name, as specified by the user using; ``#pragma clang section`` directive, is applied to that global. Specifying Linker Options on ELF Targets; ========================================. The ``#pragma comment(lib, ...)`` directive ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:187409,Modifiability,variab,variables,187409," clang section`` directive provides a means to assign section-names; to global variables, functions and static variables. The section names can be specified as:. .. code-block:: c++. #pragma clang section bss=""myBSS"" data=""myData"" rodata=""myRodata"" relro=""myRelro"" text=""myText"". The section names can be reverted back to default name by supplying an empty; string to the section kind, for example:. .. code-block:: c++. #pragma clang section bss="""" data="""" text="""" rodata="""" relro="""". The ``#pragma clang section`` directive obeys the following rules:. * The pragma applies to all global variable, statics and function declarations; from the pragma to the end of the translation unit. * The pragma clang section is enabled automatically, without need of any flags. * This feature is only defined to work sensibly for ELF targets. * If section name is specified through _attribute_((section(""myname""))), then; the attribute name gains precedence. * Global variables that are initialized to zero will be placed in the named; bss section, if one is present. * The ``#pragma clang section`` directive does not does try to infer section-kind; from the name. For example, naming a section ""``.bss.mySec``"" does NOT mean; it will be a bss section name. * The decision about which section-kind applies to each global is taken in the back-end.; Once the section-kind is known, appropriate section name, as specified by the user using; ``#pragma clang section`` directive, is applied to that global. Specifying Linker Options on ELF Targets; ========================================. The ``#pragma comment(lib, ...)`` directive is supported on all ELF targets.; The second parameter is the library name (without the traditional Unix prefix of; ``lib``). This allows you to provide an implicit link of dependent libraries. Evaluating Object Size Dynamically; ==================================. Clang supports the builtin ``__builtin_dynamic_object_size``, the semantics are; the same as GCC's ``__builtin_objec",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:20915,Performance,perform,perform,20915,"= ======= ============= ======= =====. See also :ref:`langext-__builtin_shufflevector`, :ref:`langext-__builtin_convertvector`. .. [#] ternary operator(?:) has different behaviors depending on condition; operand's vector type. If the condition is a GNU vector (i.e. __vector_size__),; a NEON vector or an SVE vector, it's only available in C++ and uses normal bool; conversions (that is, != 0).; If it's an extension (OpenCL) vector, it's only available in C and OpenCL C.; And it selects base on signedness of the condition operands (OpenCL v1.1 s6.3.9).; .. [#] sizeof can only be used on vector length specific SVE types.; .. [#] Clang does not allow the address of an element to be taken while GCC; allows this. This is intentional for vectors with a boolean element type and; not implemented otherwise. Vector Builtins; ---------------. **Note: The implementation of vector builtins is work-in-progress and incomplete.**. In addition to the operators mentioned above, Clang provides a set of builtins; to perform additional operations on certain scalar and vector types. Let ``T`` be one of the following types:. * an integer type (as in C23 6.2.5p22), but excluding enumerated types and ``bool``; * the standard floating types float or double; * a half-precision floating point type, if one is supported on the target; * a vector type. For scalar types, consider the operation applied to a vector with a single element. *Vector Size*; To determine the number of elements in a vector, use ``__builtin_vectorelements()``.; For fixed-sized vectors, e.g., defined via ``__attribute__((vector_size(N)))`` or ARM; NEON's vector types (e.g., ``uint16x8_t``), this returns the constant number of; elements at compile-time. For scalable vectors, e.g., SVE or RISC-V V, the number of; elements is not known at compile-time and is determined at runtime. This builtin can; be used, e.g., to increment the loop-counter in vector-type agnostic loops. *Elementwise Builtins*. Each builtin returns a vector equi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:21630,Performance,scalab,scalable,21630,"nal for vectors with a boolean element type and; not implemented otherwise. Vector Builtins; ---------------. **Note: The implementation of vector builtins is work-in-progress and incomplete.**. In addition to the operators mentioned above, Clang provides a set of builtins; to perform additional operations on certain scalar and vector types. Let ``T`` be one of the following types:. * an integer type (as in C23 6.2.5p22), but excluding enumerated types and ``bool``; * the standard floating types float or double; * a half-precision floating point type, if one is supported on the target; * a vector type. For scalar types, consider the operation applied to a vector with a single element. *Vector Size*; To determine the number of elements in a vector, use ``__builtin_vectorelements()``.; For fixed-sized vectors, e.g., defined via ``__attribute__((vector_size(N)))`` or ARM; NEON's vector types (e.g., ``uint16x8_t``), this returns the constant number of; elements at compile-time. For scalable vectors, e.g., SVE or RISC-V V, the number of; elements is not known at compile-time and is determined at runtime. This builtin can; be used, e.g., to increment the loop-counter in vector-type agnostic loops. *Elementwise Builtins*. Each builtin returns a vector equivalent to applying the specified operation; elementwise to the input. Unless specified otherwise operation(0) = 0 and operation(infinity) = infinity. =========================================== ================================================================ =========================================; Name Operation Supported element types; =========================================== ================================================================ =========================================; T __builtin_elementwise_abs(T x) return the absolute value of a number x; the absolute value of signed integer and floating point types; the most negative integer remains the most negative integer; T __builtin_elementwise_fma(T x, T y",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:30225,Performance,perform,performing,30225,":: c++. typedef float m4x4_t __attribute__((matrix_type(4, 4)));. m4x4_t f(m4x4_t a, m4x4_t b) {; a += b;; a -= b;; a *= b;; a += 23;; a -= 12;; return a;; }. The matrix type extension supports explicit casts. Implicit type conversion between matrix types is not allowed. .. code-block:: c++. typedef int ix5x5 __attribute__((matrix_type(5, 5)));; typedef float fx5x5 __attribute__((matrix_type(5, 5)));. fx5x5 f1(ix5x5 i, fx5x5 f) {; return (fx5x5) i;; }. template <typename X>; using matrix_4_4 = X __attribute__((matrix_type(4, 4)));. void f2() {; matrix_5_5<double> d;; matrix_5_5<int> i;; i = (matrix_5_5<int>)d;; i = static_cast<matrix_5_5<int>>(d);; }. Half-Precision Floating Point; =============================. Clang supports three half-precision (16-bit) floating point types:; ``__fp16``, ``_Float16`` and ``__bf16``. These types are supported; in all language modes, but their support differs between targets.; A target is said to have ""native support"" for a type if the target; processor offers instructions for directly performing basic arithmetic; on that type. In the absence of native support, a type can still be; supported if the compiler can emulate arithmetic on the type by promoting; to ``float``; see below for more information on this emulation. * ``__fp16`` is supported on all targets. The special semantics of this; type mean that no arithmetic is ever performed directly on ``__fp16`` values;; see below. * ``_Float16`` is supported on the following targets:. * 32-bit ARM (natively on some architecture versions); * 64-bit ARM (AArch64) (natively on ARMv8.2a and above); * AMDGPU (natively); * SPIR (natively); * X86 (if SSE2 is available; natively if AVX512-FP16 is also available); * RISC-V (natively if Zfh or Zhinx is available). * ``__bf16`` is supported on the following targets (currently never natively):. * 32-bit ARM; * 64-bit ARM (AArch64); * RISC-V; * X86 (when SSE2 is available). (For X86, SSE2 is available on 64-bit and all recent 32-bit processors.). `",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:30572,Performance,perform,performed,30572,"ibute__((matrix_type(5, 5)));. fx5x5 f1(ix5x5 i, fx5x5 f) {; return (fx5x5) i;; }. template <typename X>; using matrix_4_4 = X __attribute__((matrix_type(4, 4)));. void f2() {; matrix_5_5<double> d;; matrix_5_5<int> i;; i = (matrix_5_5<int>)d;; i = static_cast<matrix_5_5<int>>(d);; }. Half-Precision Floating Point; =============================. Clang supports three half-precision (16-bit) floating point types:; ``__fp16``, ``_Float16`` and ``__bf16``. These types are supported; in all language modes, but their support differs between targets.; A target is said to have ""native support"" for a type if the target; processor offers instructions for directly performing basic arithmetic; on that type. In the absence of native support, a type can still be; supported if the compiler can emulate arithmetic on the type by promoting; to ``float``; see below for more information on this emulation. * ``__fp16`` is supported on all targets. The special semantics of this; type mean that no arithmetic is ever performed directly on ``__fp16`` values;; see below. * ``_Float16`` is supported on the following targets:. * 32-bit ARM (natively on some architecture versions); * 64-bit ARM (AArch64) (natively on ARMv8.2a and above); * AMDGPU (natively); * SPIR (natively); * X86 (if SSE2 is available; natively if AVX512-FP16 is also available); * RISC-V (natively if Zfh or Zhinx is available). * ``__bf16`` is supported on the following targets (currently never natively):. * 32-bit ARM; * 64-bit ARM (AArch64); * RISC-V; * X86 (when SSE2 is available). (For X86, SSE2 is available on 64-bit and all recent 32-bit processors.). ``__fp16`` and ``_Float16`` both use the binary16 format from IEEE; 754-2008, which provides a 5-bit exponent and an 11-bit significand; (counting the implicit leading 1). ``__bf16`` uses the `bfloat16; <https://en.wikipedia.org/wiki/Bfloat16_floating-point_format>`_ format,; which provides an 8-bit exponent and an 8-bit significand; this is the same; exponent range as `fl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:31793,Performance,perform,performed,31793,"ARMv8.2a and above); * AMDGPU (natively); * SPIR (natively); * X86 (if SSE2 is available; natively if AVX512-FP16 is also available); * RISC-V (natively if Zfh or Zhinx is available). * ``__bf16`` is supported on the following targets (currently never natively):. * 32-bit ARM; * 64-bit ARM (AArch64); * RISC-V; * X86 (when SSE2 is available). (For X86, SSE2 is available on 64-bit and all recent 32-bit processors.). ``__fp16`` and ``_Float16`` both use the binary16 format from IEEE; 754-2008, which provides a 5-bit exponent and an 11-bit significand; (counting the implicit leading 1). ``__bf16`` uses the `bfloat16; <https://en.wikipedia.org/wiki/Bfloat16_floating-point_format>`_ format,; which provides an 8-bit exponent and an 8-bit significand; this is the same; exponent range as `float`, just with greatly reduced precision. ``_Float16`` and ``__bf16`` follow the usual rules for arithmetic; floating-point types. Most importantly, this means that arithmetic operations; on operands of these types are formally performed in the type and produce; values of the type. ``__fp16`` does not follow those rules: most operations; immediately promote operands of type ``__fp16`` to ``float``, and so; arithmetic operations are defined to be performed in ``float`` and so result in; a value of type ``float`` (unless further promoted because of other operands).; See below for more information on the exact specifications of these types. When compiling arithmetic on ``_Float16`` and ``__bf16`` for a target without; native support, Clang will perform the arithmetic in ``float``, inserting; extensions and truncations as necessary. This can be done in a way that; exactly matches the operation-by-operation behavior of native support,; but that can require many extra truncations and extensions. By default,; when emulating ``_Float16`` and ``__bf16`` arithmetic using ``float``, Clang; does not truncate intermediate operands back to their true type unless the; operand is the result of an explic",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:32015,Performance,perform,performed,32015,"llowing targets (currently never natively):. * 32-bit ARM; * 64-bit ARM (AArch64); * RISC-V; * X86 (when SSE2 is available). (For X86, SSE2 is available on 64-bit and all recent 32-bit processors.). ``__fp16`` and ``_Float16`` both use the binary16 format from IEEE; 754-2008, which provides a 5-bit exponent and an 11-bit significand; (counting the implicit leading 1). ``__bf16`` uses the `bfloat16; <https://en.wikipedia.org/wiki/Bfloat16_floating-point_format>`_ format,; which provides an 8-bit exponent and an 8-bit significand; this is the same; exponent range as `float`, just with greatly reduced precision. ``_Float16`` and ``__bf16`` follow the usual rules for arithmetic; floating-point types. Most importantly, this means that arithmetic operations; on operands of these types are formally performed in the type and produce; values of the type. ``__fp16`` does not follow those rules: most operations; immediately promote operands of type ``__fp16`` to ``float``, and so; arithmetic operations are defined to be performed in ``float`` and so result in; a value of type ``float`` (unless further promoted because of other operands).; See below for more information on the exact specifications of these types. When compiling arithmetic on ``_Float16`` and ``__bf16`` for a target without; native support, Clang will perform the arithmetic in ``float``, inserting; extensions and truncations as necessary. This can be done in a way that; exactly matches the operation-by-operation behavior of native support,; but that can require many extra truncations and extensions. By default,; when emulating ``_Float16`` and ``__bf16`` arithmetic using ``float``, Clang; does not truncate intermediate operands back to their true type unless the; operand is the result of an explicit cast or assignment. This is generally; much faster but can generate different results from strict operation-by-operation; emulation. Usually the results are more precise. This is permitted by the; C and C++ standards ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:32317,Performance,perform,perform,32317,"1-bit significand; (counting the implicit leading 1). ``__bf16`` uses the `bfloat16; <https://en.wikipedia.org/wiki/Bfloat16_floating-point_format>`_ format,; which provides an 8-bit exponent and an 8-bit significand; this is the same; exponent range as `float`, just with greatly reduced precision. ``_Float16`` and ``__bf16`` follow the usual rules for arithmetic; floating-point types. Most importantly, this means that arithmetic operations; on operands of these types are formally performed in the type and produce; values of the type. ``__fp16`` does not follow those rules: most operations; immediately promote operands of type ``__fp16`` to ``float``, and so; arithmetic operations are defined to be performed in ``float`` and so result in; a value of type ``float`` (unless further promoted because of other operands).; See below for more information on the exact specifications of these types. When compiling arithmetic on ``_Float16`` and ``__bf16`` for a target without; native support, Clang will perform the arithmetic in ``float``, inserting; extensions and truncations as necessary. This can be done in a way that; exactly matches the operation-by-operation behavior of native support,; but that can require many extra truncations and extensions. By default,; when emulating ``_Float16`` and ``__bf16`` arithmetic using ``float``, Clang; does not truncate intermediate operands back to their true type unless the; operand is the result of an explicit cast or assignment. This is generally; much faster but can generate different results from strict operation-by-operation; emulation. Usually the results are more precise. This is permitted by the; C and C++ standards under the rules for excess precision in intermediate operands;; see the discussion of evaluation formats in the C standard and [expr.pre] in; the C++ standard. The use of excess precision can be independently controlled for these two; types with the ``-ffloat16-excess-precision=`` and; ``-fbfloat16-excess-precision=",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:33366,Performance,perform,perform,33366," that; exactly matches the operation-by-operation behavior of native support,; but that can require many extra truncations and extensions. By default,; when emulating ``_Float16`` and ``__bf16`` arithmetic using ``float``, Clang; does not truncate intermediate operands back to their true type unless the; operand is the result of an explicit cast or assignment. This is generally; much faster but can generate different results from strict operation-by-operation; emulation. Usually the results are more precise. This is permitted by the; C and C++ standards under the rules for excess precision in intermediate operands;; see the discussion of evaluation formats in the C standard and [expr.pre] in; the C++ standard. The use of excess precision can be independently controlled for these two; types with the ``-ffloat16-excess-precision=`` and; ``-fbfloat16-excess-precision=`` options. Valid values include:. * ``none``: meaning to perform strict operation-by-operation emulation; * ``standard``: meaning that excess precision is permitted under the rules; described in the standard, i.e. never across explicit casts or statements; * ``fast``: meaning that excess precision is permitted whenever the; optimizer sees an opportunity to avoid truncations; currently this has no; effect beyond ``standard``. The ``_Float16`` type is an interchange floating type specified in; ISO/IEC TS 18661-3:2015 (""Floating-point extensions for C""). It will; be supported on more targets as they define ABIs for it. The ``__bf16`` type is a non-standard extension, but it generally follows; the rules for arithmetic interchange floating types from ISO/IEC TS; 18661-3:2015. In previous versions of Clang, it was a storage-only type; that forbade arithmetic operations. It will be supported on more targets; as they define ABIs for it. The ``__fp16`` type was originally an ARM extension and is specified; by the `ARM C Language Extensions <https://github.com/ARM-software/acle/releases>`_.; Clang uses the ``binary",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:33635,Performance,optimiz,optimizer,33635,"thmetic using ``float``, Clang; does not truncate intermediate operands back to their true type unless the; operand is the result of an explicit cast or assignment. This is generally; much faster but can generate different results from strict operation-by-operation; emulation. Usually the results are more precise. This is permitted by the; C and C++ standards under the rules for excess precision in intermediate operands;; see the discussion of evaluation formats in the C standard and [expr.pre] in; the C++ standard. The use of excess precision can be independently controlled for these two; types with the ``-ffloat16-excess-precision=`` and; ``-fbfloat16-excess-precision=`` options. Valid values include:. * ``none``: meaning to perform strict operation-by-operation emulation; * ``standard``: meaning that excess precision is permitted under the rules; described in the standard, i.e. never across explicit casts or statements; * ``fast``: meaning that excess precision is permitted whenever the; optimizer sees an opportunity to avoid truncations; currently this has no; effect beyond ``standard``. The ``_Float16`` type is an interchange floating type specified in; ISO/IEC TS 18661-3:2015 (""Floating-point extensions for C""). It will; be supported on more targets as they define ABIs for it. The ``__bf16`` type is a non-standard extension, but it generally follows; the rules for arithmetic interchange floating types from ISO/IEC TS; 18661-3:2015. In previous versions of Clang, it was a storage-only type; that forbade arithmetic operations. It will be supported on more targets; as they define ABIs for it. The ``__fp16`` type was originally an ARM extension and is specified; by the `ARM C Language Extensions <https://github.com/ARM-software/acle/releases>`_.; Clang uses the ``binary16`` format from IEEE 754-2008 for ``__fp16``,; not the ARM alternative format. Operators that expect arithmetic operands; immediately promote ``__fp16`` operands to ``float``. It is recommended that",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:48763,Performance,perform,performing,48763,"re(cxx_user_literals)`` to determine if support for; user-defined literals is enabled. C++11 variadic templates; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_variadic_templates)`` or; ``__has_extension(cxx_variadic_templates)`` to determine if support for; variadic templates is enabled. C++14; -----. The features listed below are part of the C++14 standard. As a result, all; these features are enabled with the ``-std=C++14`` or ``-std=gnu++14`` option; when compiling C++ code. C++14 binary literals; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_binary_literals)`` or; ``__has_extension(cxx_binary_literals)`` to determine whether; binary literals (for instance, ``0b10010``) are recognized. Clang supports this; feature as an extension in all language modes. C++14 contextual conversions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_contextual_conversions)`` or; ``__has_extension(cxx_contextual_conversions)`` to determine if the C++14 rules; are used when performing an implicit conversion for an array bound in a; *new-expression*, the operand of a *delete-expression*, an integral constant; expression, or a condition in a ``switch`` statement. C++14 decltype(auto); ^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_decltype_auto)`` or; ``__has_extension(cxx_decltype_auto)`` to determine if support; for the ``decltype(auto)`` placeholder type is enabled. C++14 default initializers for aggregates; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_aggregate_nsdmi)`` or; ``__has_extension(cxx_aggregate_nsdmi)`` to determine if support; for default initializers in aggregate members is enabled. C++14 digit separators; ^^^^^^^^^^^^^^^^^^^^^^. Use ``__cpp_digit_separators`` to determine if support for digit separators; using single quotes (for instance, ``10'000``) is enabled. At this time, there; is no corresponding ``__has_feature`` name. C++14 generalized lambda capture; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_init_captures)`` or; `",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:72561,Performance,load,loaded,72561,"--------. Clang supports ARC-style weak and unsafe references in Objective-C even; outside of ARC mode. Weak references must be explicitly enabled with; the ``-fobjc-weak`` option; use ``__has_feature((objc_arc_weak))``; to test whether they are enabled. Unsafe references are enabled; unconditionally. ARC-style weak and unsafe references cannot be used; when Objective-C garbage collection is enabled. Except as noted below, the language rules for the ``__weak`` and; ``__unsafe_unretained`` qualifiers (and the ``weak`` and; ``unsafe_unretained`` property attributes) are just as laid out; in the :doc:`ARC specification <AutomaticReferenceCounting>`.; In particular, note that some classes do not support forming weak; references to their instances, and note that special care must be; taken when storing weak references in memory where initialization; and deinitialization are outside the responsibility of the compiler; (such as in ``malloc``-ed memory). Loading from a ``__weak`` variable always implicitly retains the; loaded value. In non-ARC modes, this retain is normally balanced; by an implicit autorelease. This autorelease can be suppressed; by performing the load in the receiver position of a ``-retain``; message send (e.g. ``[weakReference retain]``); note that this performs; only a single retain (the retain done when primitively loading from; the weak reference). For the most part, ``__unsafe_unretained`` in non-ARC modes is just the; default behavior of variables and therefore is not needed. However,; it does have an effect on the semantics of block captures: normally,; copying a block which captures an Objective-C object or block pointer; causes the captured pointer to be retained or copied, respectively,; but that behavior is suppressed when the captured variable is qualified; with ``__unsafe_unretained``. Note that the ``__weak`` qualifier formerly meant the GC qualifier in; all non-ARC modes and was silently ignored outside of GC modes. It now; means the ARC-st",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:72694,Performance,perform,performing,72694,"; use ``__has_feature((objc_arc_weak))``; to test whether they are enabled. Unsafe references are enabled; unconditionally. ARC-style weak and unsafe references cannot be used; when Objective-C garbage collection is enabled. Except as noted below, the language rules for the ``__weak`` and; ``__unsafe_unretained`` qualifiers (and the ``weak`` and; ``unsafe_unretained`` property attributes) are just as laid out; in the :doc:`ARC specification <AutomaticReferenceCounting>`.; In particular, note that some classes do not support forming weak; references to their instances, and note that special care must be; taken when storing weak references in memory where initialization; and deinitialization are outside the responsibility of the compiler; (such as in ``malloc``-ed memory). Loading from a ``__weak`` variable always implicitly retains the; loaded value. In non-ARC modes, this retain is normally balanced; by an implicit autorelease. This autorelease can be suppressed; by performing the load in the receiver position of a ``-retain``; message send (e.g. ``[weakReference retain]``); note that this performs; only a single retain (the retain done when primitively loading from; the weak reference). For the most part, ``__unsafe_unretained`` in non-ARC modes is just the; default behavior of variables and therefore is not needed. However,; it does have an effect on the semantics of block captures: normally,; copying a block which captures an Objective-C object or block pointer; causes the captured pointer to be retained or copied, respectively,; but that behavior is suppressed when the captured variable is qualified; with ``__unsafe_unretained``. Note that the ``__weak`` qualifier formerly meant the GC qualifier in; all non-ARC modes and was silently ignored outside of GC modes. It now; means the ARC-style qualifier in all non-GC modes and is no longer; allowed if not enabled by either ``-fobjc-arc`` or ``-fobjc-weak``.; It is expected that ``-fobjc-weak`` will eventually be enab",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:72709,Performance,load,load,72709,"; use ``__has_feature((objc_arc_weak))``; to test whether they are enabled. Unsafe references are enabled; unconditionally. ARC-style weak and unsafe references cannot be used; when Objective-C garbage collection is enabled. Except as noted below, the language rules for the ``__weak`` and; ``__unsafe_unretained`` qualifiers (and the ``weak`` and; ``unsafe_unretained`` property attributes) are just as laid out; in the :doc:`ARC specification <AutomaticReferenceCounting>`.; In particular, note that some classes do not support forming weak; references to their instances, and note that special care must be; taken when storing weak references in memory where initialization; and deinitialization are outside the responsibility of the compiler; (such as in ``malloc``-ed memory). Loading from a ``__weak`` variable always implicitly retains the; loaded value. In non-ARC modes, this retain is normally balanced; by an implicit autorelease. This autorelease can be suppressed; by performing the load in the receiver position of a ``-retain``; message send (e.g. ``[weakReference retain]``); note that this performs; only a single retain (the retain done when primitively loading from; the weak reference). For the most part, ``__unsafe_unretained`` in non-ARC modes is just the; default behavior of variables and therefore is not needed. However,; it does have an effect on the semantics of block captures: normally,; copying a block which captures an Objective-C object or block pointer; causes the captured pointer to be retained or copied, respectively,; but that behavior is suppressed when the captured variable is qualified; with ``__unsafe_unretained``. Note that the ``__weak`` qualifier formerly meant the GC qualifier in; all non-ARC modes and was silently ignored outside of GC modes. It now; means the ARC-style qualifier in all non-GC modes and is no longer; allowed if not enabled by either ``-fobjc-arc`` or ``-fobjc-weak``.; It is expected that ``-fobjc-weak`` will eventually be enab",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:72820,Performance,perform,performs,72820,"weak and unsafe references cannot be used; when Objective-C garbage collection is enabled. Except as noted below, the language rules for the ``__weak`` and; ``__unsafe_unretained`` qualifiers (and the ``weak`` and; ``unsafe_unretained`` property attributes) are just as laid out; in the :doc:`ARC specification <AutomaticReferenceCounting>`.; In particular, note that some classes do not support forming weak; references to their instances, and note that special care must be; taken when storing weak references in memory where initialization; and deinitialization are outside the responsibility of the compiler; (such as in ``malloc``-ed memory). Loading from a ``__weak`` variable always implicitly retains the; loaded value. In non-ARC modes, this retain is normally balanced; by an implicit autorelease. This autorelease can be suppressed; by performing the load in the receiver position of a ``-retain``; message send (e.g. ``[weakReference retain]``); note that this performs; only a single retain (the retain done when primitively loading from; the weak reference). For the most part, ``__unsafe_unretained`` in non-ARC modes is just the; default behavior of variables and therefore is not needed. However,; it does have an effect on the semantics of block captures: normally,; copying a block which captures an Objective-C object or block pointer; causes the captured pointer to be retained or copied, respectively,; but that behavior is suppressed when the captured variable is qualified; with ``__unsafe_unretained``. Note that the ``__weak`` qualifier formerly meant the GC qualifier in; all non-ARC modes and was silently ignored outside of GC modes. It now; means the ARC-style qualifier in all non-GC modes and is no longer; allowed if not enabled by either ``-fobjc-arc`` or ``-fobjc-weak``.; It is expected that ``-fobjc-weak`` will eventually be enabled by default; in all non-GC Objective-C modes. .. _objc-fixed-enum:. Enumerations with a fixed underlying type; -------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:72885,Performance,load,loading,72885,"weak and unsafe references cannot be used; when Objective-C garbage collection is enabled. Except as noted below, the language rules for the ``__weak`` and; ``__unsafe_unretained`` qualifiers (and the ``weak`` and; ``unsafe_unretained`` property attributes) are just as laid out; in the :doc:`ARC specification <AutomaticReferenceCounting>`.; In particular, note that some classes do not support forming weak; references to their instances, and note that special care must be; taken when storing weak references in memory where initialization; and deinitialization are outside the responsibility of the compiler; (such as in ``malloc``-ed memory). Loading from a ``__weak`` variable always implicitly retains the; loaded value. In non-ARC modes, this retain is normally balanced; by an implicit autorelease. This autorelease can be suppressed; by performing the load in the receiver position of a ``-retain``; message send (e.g. ``[weakReference retain]``); note that this performs; only a single retain (the retain done when primitively loading from; the weak reference). For the most part, ``__unsafe_unretained`` in non-ARC modes is just the; default behavior of variables and therefore is not needed. However,; it does have an effect on the semantics of block captures: normally,; copying a block which captures an Objective-C object or block pointer; causes the captured pointer to be retained or copied, respectively,; but that behavior is suppressed when the captured variable is qualified; with ``__unsafe_unretained``. Note that the ``__weak`` qualifier formerly meant the GC qualifier in; all non-ARC modes and was silently ignored outside of GC modes. It now; means the ARC-style qualifier in all non-GC modes and is no longer; allowed if not enabled by either ``-fobjc-arc`` or ``-fobjc-weak``.; It is expected that ``-fobjc-weak`` will eventually be enabled by default; in all non-GC Objective-C modes. .. _objc-fixed-enum:. Enumerations with a fixed underlying type; -------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:76372,Performance,optimiz,optimization,76372,"Range = NSMakeRange(0, [s1 length]);; return [s1 compare:s2 options:comparisonOptions; range:string1Range locale:currentLocale];; }];; NSLog(@""sorted: %@"", sorted);. This code relies on an implicit conversion from the type of the lambda; expression (an unnamed, local class type called the *closure type*) to the; corresponding block pointer type. The conversion itself is expressed by a; conversion operator in that closure type that produces a block pointer with the; same signature as the lambda itself, e.g.,. .. code-block:: objc. operator NSComparisonResult (^)(id, id)() const;. This conversion function returns a new block that simply forwards the two; parameters to the lambda object (which it captures by copy), then returns the; result. The returned block is first copied (with ``Block_copy``) and then; autoreleased. As an optimization, if a lambda expression is immediately; converted to a block pointer (as in the first example, above), then the block; is not copied and autoreleased: rather, it is given the same lifetime as a; block literal written at that point in the program, which avoids the overhead; of copying a block to the heap in the common case. The conversion from a lambda to a block pointer is only available in; Objective-C++, and not in C++ with blocks, due to its use of Objective-C memory; management (autorelease). Object Literals and Subscripting; --------------------------------. Clang provides support for :doc:`Object Literals and Subscripting; <ObjectiveCLiterals>` in Objective-C, which simplifies common Objective-C; programming patterns, makes programs more concise, and improves the safety of; container creation. There are several feature macros associated with object; literals and subscripting: ``__has_feature(objc_array_literals)`` tests the; availability of array literals; ``__has_feature(objc_dictionary_literals)``; tests the availability of dictionary literals;; ``__has_feature(objc_subscripting)`` tests the availability of object; subscriptin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:87556,Performance,optimiz,optimizations,87556," // error - bitfields are not supported; };. ``__cl_clang_function_pointers``; --------------------------------. With this extension it is possible to enable various language features that; are relying on function pointers using regular OpenCL extension pragma; mechanism detailed in `the OpenCL Extension Specification,; section 1.2; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview>`_. In C++ for OpenCL this also enables:. - Use of member function pointers;. - Unrestricted use of references to functions;. - Virtual member functions. Such functionality is not conformant and does not guarantee to compile; correctly in any circumstances. It can be used if:. - the kernel source does not contain call expressions to (member-) function; pointers, or virtual functions. For example this extension can be used in; metaprogramming algorithms to be able to specify/detect types generically. - the generated kernel binary does not contain indirect calls because they; are eliminated using compiler optimizations e.g. devirtualization. - the selected target supports the function pointer like functionality e.g.; most CPU targets. **Example of Use**:. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_function_pointers : enable; void foo(); {; void (*fp)(); // compiled - no diagnostic generated; }. #pragma OPENCL EXTENSION __cl_clang_function_pointers : disable; void bar(); {; void (*fp)(); // error - pointers to function are not allowed; }. ``__cl_clang_variadic_functions``; ---------------------------------. With this extension it is possible to enable variadic arguments in functions; using regular OpenCL extension pragma mechanism detailed in `the OpenCL; Extension Specification, section 1.2; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview>`_. This is not conformant behavior and it can only be used portably when the; functions with variadic prototypes do not get generated in bin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:92665,Performance,load,loads,92665,"ly features documented below. For further; information related to the semantics of the builtins, please refer to the `WebAssembly Specification <https://webassembly.github.io/spec/core/>`_.; In this section, when we refer to reference types, we are referring to; WebAssembly reference types, not C++ reference types unless stated; otherwise. ``__builtin_wasm_table_set``; ----------------------------. This builtin function stores a value in a WebAssembly table.; It takes three arguments.; The first argument is the table to store a value into, the second; argument is the index to which to store the value into, and the; third argument is a value of reference type to store in the table.; It returns nothing. .. code-block:: c++. static __externref_t table[0];; extern __externref_t JSObj;. void store(int index) {; __builtin_wasm_table_set(table, index, JSObj);; }. ``__builtin_wasm_table_get``; ----------------------------. This builtin function is the counterpart to ``__builtin_wasm_table_set``; and loads a value from a WebAssembly table of reference typed values.; It takes 2 arguments.; The first argument is a table of reference typed values and the; second argument is an index from which to load the value. It returns; the loaded reference typed value. .. code-block:: c++. static __externref_t table[0];. __externref_t load(int index) {; __externref_t Obj = __builtin_wasm_table_get(table, index);; return Obj;; }. ``__builtin_wasm_table_size``; -----------------------------. This builtin function returns the size of the WebAssembly table.; Takes the table as an argument and returns an unsigned integer (``size_t``); with the current table size. .. code-block:: c++. typedef void (*__funcref funcref_t)();; static __funcref table[0];. size_t getSize() {; return __builtin_wasm_table_size(table);; }. ``__builtin_wasm_table_grow``; -----------------------------. This builtin function grows the WebAssembly table by a certain amount.; Currently, as all WebAssembly tables created in C",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:92862,Performance,load,load,92862,"ssembly.github.io/spec/core/>`_.; In this section, when we refer to reference types, we are referring to; WebAssembly reference types, not C++ reference types unless stated; otherwise. ``__builtin_wasm_table_set``; ----------------------------. This builtin function stores a value in a WebAssembly table.; It takes three arguments.; The first argument is the table to store a value into, the second; argument is the index to which to store the value into, and the; third argument is a value of reference type to store in the table.; It returns nothing. .. code-block:: c++. static __externref_t table[0];; extern __externref_t JSObj;. void store(int index) {; __builtin_wasm_table_set(table, index, JSObj);; }. ``__builtin_wasm_table_get``; ----------------------------. This builtin function is the counterpart to ``__builtin_wasm_table_set``; and loads a value from a WebAssembly table of reference typed values.; It takes 2 arguments.; The first argument is a table of reference typed values and the; second argument is an index from which to load the value. It returns; the loaded reference typed value. .. code-block:: c++. static __externref_t table[0];. __externref_t load(int index) {; __externref_t Obj = __builtin_wasm_table_get(table, index);; return Obj;; }. ``__builtin_wasm_table_size``; -----------------------------. This builtin function returns the size of the WebAssembly table.; Takes the table as an argument and returns an unsigned integer (``size_t``); with the current table size. .. code-block:: c++. typedef void (*__funcref funcref_t)();; static __funcref table[0];. size_t getSize() {; return __builtin_wasm_table_size(table);; }. ``__builtin_wasm_table_grow``; -----------------------------. This builtin function grows the WebAssembly table by a certain amount.; Currently, as all WebAssembly tables created in C/C++ are zero-sized,; this always needs to be called to grow the table. It takes three arguments. The first argument is the WebAssembly table; to grow. The s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:92894,Performance,load,loaded,92894,"we are referring to; WebAssembly reference types, not C++ reference types unless stated; otherwise. ``__builtin_wasm_table_set``; ----------------------------. This builtin function stores a value in a WebAssembly table.; It takes three arguments.; The first argument is the table to store a value into, the second; argument is the index to which to store the value into, and the; third argument is a value of reference type to store in the table.; It returns nothing. .. code-block:: c++. static __externref_t table[0];; extern __externref_t JSObj;. void store(int index) {; __builtin_wasm_table_set(table, index, JSObj);; }. ``__builtin_wasm_table_get``; ----------------------------. This builtin function is the counterpart to ``__builtin_wasm_table_set``; and loads a value from a WebAssembly table of reference typed values.; It takes 2 arguments.; The first argument is a table of reference typed values and the; second argument is an index from which to load the value. It returns; the loaded reference typed value. .. code-block:: c++. static __externref_t table[0];. __externref_t load(int index) {; __externref_t Obj = __builtin_wasm_table_get(table, index);; return Obj;; }. ``__builtin_wasm_table_size``; -----------------------------. This builtin function returns the size of the WebAssembly table.; Takes the table as an argument and returns an unsigned integer (``size_t``); with the current table size. .. code-block:: c++. typedef void (*__funcref funcref_t)();; static __funcref table[0];. size_t getSize() {; return __builtin_wasm_table_size(table);; }. ``__builtin_wasm_table_grow``; -----------------------------. This builtin function grows the WebAssembly table by a certain amount.; Currently, as all WebAssembly tables created in C/C++ are zero-sized,; this always needs to be called to grow the table. It takes three arguments. The first argument is the WebAssembly table; to grow. The second argument is the reference typed value to store in; the new table entries (the i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:92991,Performance,load,load,92991,"---------------------------. This builtin function stores a value in a WebAssembly table.; It takes three arguments.; The first argument is the table to store a value into, the second; argument is the index to which to store the value into, and the; third argument is a value of reference type to store in the table.; It returns nothing. .. code-block:: c++. static __externref_t table[0];; extern __externref_t JSObj;. void store(int index) {; __builtin_wasm_table_set(table, index, JSObj);; }. ``__builtin_wasm_table_get``; ----------------------------. This builtin function is the counterpart to ``__builtin_wasm_table_set``; and loads a value from a WebAssembly table of reference typed values.; It takes 2 arguments.; The first argument is a table of reference typed values and the; second argument is an index from which to load the value. It returns; the loaded reference typed value. .. code-block:: c++. static __externref_t table[0];. __externref_t load(int index) {; __externref_t Obj = __builtin_wasm_table_get(table, index);; return Obj;; }. ``__builtin_wasm_table_size``; -----------------------------. This builtin function returns the size of the WebAssembly table.; Takes the table as an argument and returns an unsigned integer (``size_t``); with the current table size. .. code-block:: c++. typedef void (*__funcref funcref_t)();; static __funcref table[0];. size_t getSize() {; return __builtin_wasm_table_size(table);; }. ``__builtin_wasm_table_grow``; -----------------------------. This builtin function grows the WebAssembly table by a certain amount.; Currently, as all WebAssembly tables created in C/C++ are zero-sized,; this always needs to be called to grow the table. It takes three arguments. The first argument is the WebAssembly table; to grow. The second argument is the reference typed value to store in; the new table entries (the initialization value), and the third argument; is the amount to grow the table by. It returns the previous table size; or -1. It wil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:98713,Performance,optimiz,optimizer,98713,"ocate memory on the; stack while controlling its alignment. Memory is automatically freed upon; function termination. **Syntax**:. .. code-block:: c++. __builtin_alloca_with_align(size_t n, size_t align). **Example of Use**:. .. code-block:: c++. void init(float* data, size_t nbelems);; void process(float* data, size_t nbelems);; int foo(size_t n) {; auto mem = (float*)__builtin_alloca_with_align(; n * sizeof(float),; CHAR_BIT * alignof(float));; init(mem, n);; process(mem, n);; /* mem is automatically freed at this point */; }. **Description**:. ``__builtin_alloca_with_align`` is meant to be used to allocate a dynamic amount of memory; on the stack. It is similar to ``__builtin_alloca`` but accepts a second; argument whose value is the alignment constraint, as a power of 2 in *bits*. Query for this feature with ``__has_builtin(__builtin_alloca_with_align)``. .. _langext-__builtin_assume:. ``__builtin_assume``; --------------------. ``__builtin_assume`` is used to provide the optimizer with a boolean; invariant that is defined to be true. **Syntax**:. .. code-block:: c++. __builtin_assume(bool). **Example of Use**:. .. code-block:: c++. int foo(int x) {; __builtin_assume(x != 0);; // The optimizer may short-circuit this check using the invariant.; if (x == 0); return do_something();; return do_something_else();; }. **Description**:. The boolean argument to this function is defined to be true. The optimizer may; analyze the form of the expression provided as the argument and deduce from; that information used to optimize the program. If the condition is violated; during execution, the behavior is undefined. The argument itself is never; evaluated, so any side effects of the expression will be discarded. Query for this feature with ``__has_builtin(__builtin_assume)``. .. _langext-__builtin_assume_separate_storage:. ``__builtin_assume_separate_storage``; -------------------------------------. ``__builtin_assume_separate_storage`` is used to provide the optimizer with t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:98929,Performance,optimiz,optimizer,98929,"mple of Use**:. .. code-block:: c++. void init(float* data, size_t nbelems);; void process(float* data, size_t nbelems);; int foo(size_t n) {; auto mem = (float*)__builtin_alloca_with_align(; n * sizeof(float),; CHAR_BIT * alignof(float));; init(mem, n);; process(mem, n);; /* mem is automatically freed at this point */; }. **Description**:. ``__builtin_alloca_with_align`` is meant to be used to allocate a dynamic amount of memory; on the stack. It is similar to ``__builtin_alloca`` but accepts a second; argument whose value is the alignment constraint, as a power of 2 in *bits*. Query for this feature with ``__has_builtin(__builtin_alloca_with_align)``. .. _langext-__builtin_assume:. ``__builtin_assume``; --------------------. ``__builtin_assume`` is used to provide the optimizer with a boolean; invariant that is defined to be true. **Syntax**:. .. code-block:: c++. __builtin_assume(bool). **Example of Use**:. .. code-block:: c++. int foo(int x) {; __builtin_assume(x != 0);; // The optimizer may short-circuit this check using the invariant.; if (x == 0); return do_something();; return do_something_else();; }. **Description**:. The boolean argument to this function is defined to be true. The optimizer may; analyze the form of the expression provided as the argument and deduce from; that information used to optimize the program. If the condition is violated; during execution, the behavior is undefined. The argument itself is never; evaluated, so any side effects of the expression will be discarded. Query for this feature with ``__has_builtin(__builtin_assume)``. .. _langext-__builtin_assume_separate_storage:. ``__builtin_assume_separate_storage``; -------------------------------------. ``__builtin_assume_separate_storage`` is used to provide the optimizer with the; knowledge that its two arguments point to separately allocated objects. **Syntax**:. .. code-block:: c++. __builtin_assume_separate_storage(const volatile void *, const volatile void *). **Example of Use**:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:99142,Performance,optimiz,optimizer,99142," mem is automatically freed at this point */; }. **Description**:. ``__builtin_alloca_with_align`` is meant to be used to allocate a dynamic amount of memory; on the stack. It is similar to ``__builtin_alloca`` but accepts a second; argument whose value is the alignment constraint, as a power of 2 in *bits*. Query for this feature with ``__has_builtin(__builtin_alloca_with_align)``. .. _langext-__builtin_assume:. ``__builtin_assume``; --------------------. ``__builtin_assume`` is used to provide the optimizer with a boolean; invariant that is defined to be true. **Syntax**:. .. code-block:: c++. __builtin_assume(bool). **Example of Use**:. .. code-block:: c++. int foo(int x) {; __builtin_assume(x != 0);; // The optimizer may short-circuit this check using the invariant.; if (x == 0); return do_something();; return do_something_else();; }. **Description**:. The boolean argument to this function is defined to be true. The optimizer may; analyze the form of the expression provided as the argument and deduce from; that information used to optimize the program. If the condition is violated; during execution, the behavior is undefined. The argument itself is never; evaluated, so any side effects of the expression will be discarded. Query for this feature with ``__has_builtin(__builtin_assume)``. .. _langext-__builtin_assume_separate_storage:. ``__builtin_assume_separate_storage``; -------------------------------------. ``__builtin_assume_separate_storage`` is used to provide the optimizer with the; knowledge that its two arguments point to separately allocated objects. **Syntax**:. .. code-block:: c++. __builtin_assume_separate_storage(const volatile void *, const volatile void *). **Example of Use**:. .. code-block:: c++. int foo(int *x, int *y) {; __builtin_assume_separate_storage(x, y);; *x = 0;; *y = 1;; // The optimizer may optimize this to return 0 without reloading from *x.; return *x;; }. **Description**:. The arguments to this function are assumed to point into se",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:99259,Performance,optimiz,optimize,99259," mem is automatically freed at this point */; }. **Description**:. ``__builtin_alloca_with_align`` is meant to be used to allocate a dynamic amount of memory; on the stack. It is similar to ``__builtin_alloca`` but accepts a second; argument whose value is the alignment constraint, as a power of 2 in *bits*. Query for this feature with ``__has_builtin(__builtin_alloca_with_align)``. .. _langext-__builtin_assume:. ``__builtin_assume``; --------------------. ``__builtin_assume`` is used to provide the optimizer with a boolean; invariant that is defined to be true. **Syntax**:. .. code-block:: c++. __builtin_assume(bool). **Example of Use**:. .. code-block:: c++. int foo(int x) {; __builtin_assume(x != 0);; // The optimizer may short-circuit this check using the invariant.; if (x == 0); return do_something();; return do_something_else();; }. **Description**:. The boolean argument to this function is defined to be true. The optimizer may; analyze the form of the expression provided as the argument and deduce from; that information used to optimize the program. If the condition is violated; during execution, the behavior is undefined. The argument itself is never; evaluated, so any side effects of the expression will be discarded. Query for this feature with ``__has_builtin(__builtin_assume)``. .. _langext-__builtin_assume_separate_storage:. ``__builtin_assume_separate_storage``; -------------------------------------. ``__builtin_assume_separate_storage`` is used to provide the optimizer with the; knowledge that its two arguments point to separately allocated objects. **Syntax**:. .. code-block:: c++. __builtin_assume_separate_storage(const volatile void *, const volatile void *). **Example of Use**:. .. code-block:: c++. int foo(int *x, int *y) {; __builtin_assume_separate_storage(x, y);; *x = 0;; *y = 1;; // The optimizer may optimize this to return 0 without reloading from *x.; return *x;; }. **Description**:. The arguments to this function are assumed to point into se",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:99706,Performance,optimiz,optimizer,99706,"er with a boolean; invariant that is defined to be true. **Syntax**:. .. code-block:: c++. __builtin_assume(bool). **Example of Use**:. .. code-block:: c++. int foo(int x) {; __builtin_assume(x != 0);; // The optimizer may short-circuit this check using the invariant.; if (x == 0); return do_something();; return do_something_else();; }. **Description**:. The boolean argument to this function is defined to be true. The optimizer may; analyze the form of the expression provided as the argument and deduce from; that information used to optimize the program. If the condition is violated; during execution, the behavior is undefined. The argument itself is never; evaluated, so any side effects of the expression will be discarded. Query for this feature with ``__has_builtin(__builtin_assume)``. .. _langext-__builtin_assume_separate_storage:. ``__builtin_assume_separate_storage``; -------------------------------------. ``__builtin_assume_separate_storage`` is used to provide the optimizer with the; knowledge that its two arguments point to separately allocated objects. **Syntax**:. .. code-block:: c++. __builtin_assume_separate_storage(const volatile void *, const volatile void *). **Example of Use**:. .. code-block:: c++. int foo(int *x, int *y) {; __builtin_assume_separate_storage(x, y);; *x = 0;; *y = 1;; // The optimizer may optimize this to return 0 without reloading from *x.; return *x;; }. **Description**:. The arguments to this function are assumed to point into separately allocated; storage (either different variable definitions or different dynamic storage; allocations). The optimizer may use this fact to aid in alias analysis. If the; arguments point into the same storage, the behavior is undefined. Note that the; definition of ""storage"" here refers to the outermost enclosing allocation of any; particular object (so for example, it's never correct to call this function; passing the addresses of fields in the same struct, elements of the same array,; etc.). Query f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:100049,Performance,optimiz,optimizer,100049,"do_something_else();; }. **Description**:. The boolean argument to this function is defined to be true. The optimizer may; analyze the form of the expression provided as the argument and deduce from; that information used to optimize the program. If the condition is violated; during execution, the behavior is undefined. The argument itself is never; evaluated, so any side effects of the expression will be discarded. Query for this feature with ``__has_builtin(__builtin_assume)``. .. _langext-__builtin_assume_separate_storage:. ``__builtin_assume_separate_storage``; -------------------------------------. ``__builtin_assume_separate_storage`` is used to provide the optimizer with the; knowledge that its two arguments point to separately allocated objects. **Syntax**:. .. code-block:: c++. __builtin_assume_separate_storage(const volatile void *, const volatile void *). **Example of Use**:. .. code-block:: c++. int foo(int *x, int *y) {; __builtin_assume_separate_storage(x, y);; *x = 0;; *y = 1;; // The optimizer may optimize this to return 0 without reloading from *x.; return *x;; }. **Description**:. The arguments to this function are assumed to point into separately allocated; storage (either different variable definitions or different dynamic storage; allocations). The optimizer may use this fact to aid in alias analysis. If the; arguments point into the same storage, the behavior is undefined. Note that the; definition of ""storage"" here refers to the outermost enclosing allocation of any; particular object (so for example, it's never correct to call this function; passing the addresses of fields in the same struct, elements of the same array,; etc.). Query for this feature with ``__has_builtin(__builtin_assume_separate_storage)``. ``__builtin_offsetof``; ----------------------. ``__builtin_offsetof`` is used to implement the ``offsetof`` macro, which; calculates the offset (in bytes) to a given member of the given type. **Syntax**:. .. code-block:: c++. __builtin_of",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:100063,Performance,optimiz,optimize,100063,"do_something_else();; }. **Description**:. The boolean argument to this function is defined to be true. The optimizer may; analyze the form of the expression provided as the argument and deduce from; that information used to optimize the program. If the condition is violated; during execution, the behavior is undefined. The argument itself is never; evaluated, so any side effects of the expression will be discarded. Query for this feature with ``__has_builtin(__builtin_assume)``. .. _langext-__builtin_assume_separate_storage:. ``__builtin_assume_separate_storage``; -------------------------------------. ``__builtin_assume_separate_storage`` is used to provide the optimizer with the; knowledge that its two arguments point to separately allocated objects. **Syntax**:. .. code-block:: c++. __builtin_assume_separate_storage(const volatile void *, const volatile void *). **Example of Use**:. .. code-block:: c++. int foo(int *x, int *y) {; __builtin_assume_separate_storage(x, y);; *x = 0;; *y = 1;; // The optimizer may optimize this to return 0 without reloading from *x.; return *x;; }. **Description**:. The arguments to this function are assumed to point into separately allocated; storage (either different variable definitions or different dynamic storage; allocations). The optimizer may use this fact to aid in alias analysis. If the; arguments point into the same storage, the behavior is undefined. Note that the; definition of ""storage"" here refers to the outermost enclosing allocation of any; particular object (so for example, it's never correct to call this function; passing the addresses of fields in the same struct, elements of the same array,; etc.). Query for this feature with ``__has_builtin(__builtin_assume_separate_storage)``. ``__builtin_offsetof``; ----------------------. ``__builtin_offsetof`` is used to implement the ``offsetof`` macro, which; calculates the offset (in bytes) to a given member of the given type. **Syntax**:. .. code-block:: c++. __builtin_of",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:100324,Performance,optimiz,optimizer,100324,"efined. The argument itself is never; evaluated, so any side effects of the expression will be discarded. Query for this feature with ``__has_builtin(__builtin_assume)``. .. _langext-__builtin_assume_separate_storage:. ``__builtin_assume_separate_storage``; -------------------------------------. ``__builtin_assume_separate_storage`` is used to provide the optimizer with the; knowledge that its two arguments point to separately allocated objects. **Syntax**:. .. code-block:: c++. __builtin_assume_separate_storage(const volatile void *, const volatile void *). **Example of Use**:. .. code-block:: c++. int foo(int *x, int *y) {; __builtin_assume_separate_storage(x, y);; *x = 0;; *y = 1;; // The optimizer may optimize this to return 0 without reloading from *x.; return *x;; }. **Description**:. The arguments to this function are assumed to point into separately allocated; storage (either different variable definitions or different dynamic storage; allocations). The optimizer may use this fact to aid in alias analysis. If the; arguments point into the same storage, the behavior is undefined. Note that the; definition of ""storage"" here refers to the outermost enclosing allocation of any; particular object (so for example, it's never correct to call this function; passing the addresses of fields in the same struct, elements of the same array,; etc.). Query for this feature with ``__has_builtin(__builtin_assume_separate_storage)``. ``__builtin_offsetof``; ----------------------. ``__builtin_offsetof`` is used to implement the ``offsetof`` macro, which; calculates the offset (in bytes) to a given member of the given type. **Syntax**:. .. code-block:: c++. __builtin_offsetof(type-name, member-designator). **Example of Use**:. .. code-block:: c++. struct S {; char c;; int i;; struct T {; float f[2];; } t;; };. const int offset_to_i = __builtin_offsetof(struct S, i);; const int ext1 = __builtin_offsetof(struct U { int i; }, i); // C extension; const int offset_to_subobject = __",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:102095,Performance,perform,perform,102095,"k:: c++. struct S {; char c;; int i;; struct T {; float f[2];; } t;; };. const int offset_to_i = __builtin_offsetof(struct S, i);; const int ext1 = __builtin_offsetof(struct U { int i; }, i); // C extension; const int offset_to_subobject = __builtin_offsetof(struct S, t.f[1]);. **Description**:. This builtin is usable in an integer constant expression which returns a value; of type ``size_t``. The value returned is the offset in bytes to the subobject; designated by the member-designator from the beginning of an object of type; ``type-name``. Clang extends the required standard functionality in the; following way:. * In C language modes, the first argument may be the definition of a new type.; Any type declared this way is scoped to the nearest scope containing the call; to the builtin. Query for this feature with ``__has_builtin(__builtin_offsetof)``. ``__builtin_call_with_static_chain``; ------------------------------------. ``__builtin_call_with_static_chain`` is used to perform a static call while; setting updating the static chain register. **Syntax**:. .. code-block:: c++. T __builtin_call_with_static_chain(T expr, void* ptr). **Example of Use**:. .. code-block:: c++. auto v = __builtin_call_with_static_chain(foo(3), foo);. **Description**:. This builtin returns ``expr`` after checking that ``expr`` is a non-member; static call expression. The call to that expression is made while using ``ptr``; as a function pointer stored in a dedicated register to implement *static chain*; calling convention, as used by some language to implement closures or nested; functions. Query for this feature with ``__has_builtin(__builtin_call_with_static_chain)``. ``__builtin_readcyclecounter``; ------------------------------. ``__builtin_readcyclecounter`` is used to access the cycle counter register (or; a similar low-latency, high-accuracy clock) on those targets that support it. **Syntax**:. .. code-block:: c++. __builtin_readcyclecounter(). **Example of Use**:. .. code-block:: ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:102942,Performance,latency,latency,102942,"e with ``__has_builtin(__builtin_offsetof)``. ``__builtin_call_with_static_chain``; ------------------------------------. ``__builtin_call_with_static_chain`` is used to perform a static call while; setting updating the static chain register. **Syntax**:. .. code-block:: c++. T __builtin_call_with_static_chain(T expr, void* ptr). **Example of Use**:. .. code-block:: c++. auto v = __builtin_call_with_static_chain(foo(3), foo);. **Description**:. This builtin returns ``expr`` after checking that ``expr`` is a non-member; static call expression. The call to that expression is made while using ``ptr``; as a function pointer stored in a dedicated register to implement *static chain*; calling convention, as used by some language to implement closures or nested; functions. Query for this feature with ``__has_builtin(__builtin_call_with_static_chain)``. ``__builtin_readcyclecounter``; ------------------------------. ``__builtin_readcyclecounter`` is used to access the cycle counter register (or; a similar low-latency, high-accuracy clock) on those targets that support it. **Syntax**:. .. code-block:: c++. __builtin_readcyclecounter(). **Example of Use**:. .. code-block:: c++. unsigned long long t0 = __builtin_readcyclecounter();; do_something();; unsigned long long t1 = __builtin_readcyclecounter();; unsigned long long cycles_to_do_something = t1 - t0; // assuming no overflow. **Description**:. The ``__builtin_readcyclecounter()`` builtin returns the cycle counter value,; which may be either global or process/thread-specific depending on the target.; As the backing counters often overflow quickly (on the order of seconds) this; should only be used for timing small intervals. When not supported by the; target, the return value is always zero. This builtin takes no arguments and; produces an unsigned long long result. Query for this feature with ``__has_builtin(__builtin_readcyclecounter)``. Note; that even if present, its use may depend on run-time privilege or other OS; cont",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:107868,Performance,optimiz,optimized,107868,"1, 0, 0, 0, 0). // Reverse 4-element vector V1.; __builtin_shufflevector(V1, V1, 3, 2, 1, 0). // Concatenate every other element of 4-element vectors V1 and V2.; __builtin_shufflevector(V1, V2, 0, 2, 4, 6). // Concatenate every other element of 8-element vectors V1 and V2.; __builtin_shufflevector(V1, V2, 0, 2, 4, 6, 8, 10, 12, 14). // Shuffle v1 with some elements being undefined; __builtin_shufflevector(v1, v1, 3, -1, 1, -1). **Description**:. The first two arguments to ``__builtin_shufflevector`` are vectors that have; the same element type. The remaining arguments are a list of integers that; specify the elements indices of the first two vectors that should be extracted; and returned in a new vector. These element indices are numbered sequentially; starting with the first vector, continuing into the second vector. Thus, if; ``vec1`` is a 4-element vector, index 5 would refer to the second element of; ``vec2``. An index of -1 can be used to indicate that the corresponding element; in the returned vector is a don't care and can be optimized by the backend. The result of ``__builtin_shufflevector`` is a vector with the same element; type as ``vec1``/``vec2`` but that has an element count equal to the number of; indices specified. Query for this feature with ``__has_builtin(__builtin_shufflevector)``. .. _langext-__builtin_convertvector:. ``__builtin_convertvector``; ---------------------------. ``__builtin_convertvector`` is used to express generic vector; type-conversion operations. The input vector and the output vector; type must have the same number of elements. **Syntax**:. .. code-block:: c++. __builtin_convertvector(src_vec, dst_vec_type). **Examples**:. .. code-block:: c++. typedef double vector4double __attribute__((__vector_size__(32)));; typedef float vector4float __attribute__((__vector_size__(16)));; typedef short vector4short __attribute__((__vector_size__(8)));; vector4float vf; vector4short vs;. // convert from a vector of 4 floats to a vector of 4 d",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:112409,Performance,optimiz,optimization,112409,"``. **Syntax**:. .. code-block:: c++. __builtin_rotateright32(x, y). **Examples**:. .. code-block:: c++. uint8_t rot_x = __builtin_rotateright8(x, y);; uint16_t rot_x = __builtin_rotateright16(x, y);; uint32_t rot_x = __builtin_rotateright32(x, y);; uint64_t rot_x = __builtin_rotateright64(x, y);. **Description**:. The '``__builtin_rotateright``' family of builtins is used to rotate; the bits in the first argument by the amount in the second argument.; For example, ``0b10000110`` rotated right by 3 becomes ``0b11010000``.; The shift value is treated as an unsigned amount modulo the size of; the arguments. Both arguments and the result have the bitwidth specified; by the name of the builtin. These builtins can be used within constant; expressions. ``__builtin_unreachable``; -------------------------. ``__builtin_unreachable`` is used to indicate that a specific point in the; program cannot be reached, even if the compiler might otherwise think it can.; This is useful to improve optimization and eliminates certain warnings. For; example, without the ``__builtin_unreachable`` in the example below, the; compiler assumes that the inline asm can fall through and prints a ""function; declared '``noreturn``' should not return"" warning. **Syntax**:. .. code-block:: c++. __builtin_unreachable(). **Example of use**:. .. code-block:: c++. void myabort(void) __attribute__((noreturn));; void myabort(void) {; asm(""int3"");; __builtin_unreachable();; }. **Description**:. The ``__builtin_unreachable()`` builtin has completely undefined behavior.; Since it has undefined behavior, it is a statement that it is never reached and; the optimizer can take advantage of this to produce better code. This builtin; takes no arguments and produces a void result. Query for this feature with ``__has_builtin(__builtin_unreachable)``. ``__builtin_unpredictable``; ---------------------------. ``__builtin_unpredictable`` is used to indicate that a branch condition is; unpredictable by hardware mechanisms",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:113056,Performance,optimiz,optimizer,113056,"ts and the result have the bitwidth specified; by the name of the builtin. These builtins can be used within constant; expressions. ``__builtin_unreachable``; -------------------------. ``__builtin_unreachable`` is used to indicate that a specific point in the; program cannot be reached, even if the compiler might otherwise think it can.; This is useful to improve optimization and eliminates certain warnings. For; example, without the ``__builtin_unreachable`` in the example below, the; compiler assumes that the inline asm can fall through and prints a ""function; declared '``noreturn``' should not return"" warning. **Syntax**:. .. code-block:: c++. __builtin_unreachable(). **Example of use**:. .. code-block:: c++. void myabort(void) __attribute__((noreturn));; void myabort(void) {; asm(""int3"");; __builtin_unreachable();; }. **Description**:. The ``__builtin_unreachable()`` builtin has completely undefined behavior.; Since it has undefined behavior, it is a statement that it is never reached and; the optimizer can take advantage of this to produce better code. This builtin; takes no arguments and produces a void result. Query for this feature with ``__has_builtin(__builtin_unreachable)``. ``__builtin_unpredictable``; ---------------------------. ``__builtin_unpredictable`` is used to indicate that a branch condition is; unpredictable by hardware mechanisms such as branch prediction logic. **Syntax**:. .. code-block:: c++. __builtin_unpredictable(long long). **Example of use**:. .. code-block:: c++. if (__builtin_unpredictable(x > 0)) {; foo();; }. **Description**:. The ``__builtin_unpredictable()`` builtin is expected to be used with control; flow conditions such as in ``if`` and ``switch`` statements. Query for this feature with ``__has_builtin(__builtin_unpredictable)``. ``__builtin_expect``; --------------------. ``__builtin_expect`` is used to indicate that the value of an expression is; anticipated to be the same as a statically known result. **Syntax**:. .. code-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:115563,Performance,cache,cache,115563,"expect_with_probability``; -------------------------------------. ``__builtin_expect_with_probability`` is similar to ``__builtin_expect`` but it; takes a probability as third argument. **Syntax**:. .. code-block:: c++. long __builtin_expect_with_probability(long expr, long val, double p). **Example of use**:. .. code-block:: c++. if (__builtin_expect_with_probability(x, 0, .3)) {; bar();; }. **Description**:. The ``__builtin_expect_with_probability()`` builtin is typically used with; control flow conditions such as in ``if`` and ``switch`` statements to help; branch prediction. It means that its first argument ``expr`` is expected to take; the value of its second argument ``val`` with probability ``p``. ``p`` must be; within ``[0.0 ; 1.0]`` bounds. This builtin always returns the value of ``expr``. Query for this feature with ``__has_builtin(__builtin_expect_with_probability)``. ``__builtin_prefetch``; ----------------------. ``__builtin_prefetch`` is used to communicate with the cache handler to bring; data into the cache before it gets used. **Syntax**:. .. code-block:: c++. void __builtin_prefetch(const void *addr, int rw=0, int locality=3). **Example of use**:. .. code-block:: c++. __builtin_prefetch(a + i);. **Description**:. The ``__builtin_prefetch(addr, rw, locality)`` builtin is expected to be used to; avoid cache misses when the developer has a good understanding of which data; are going to be used next. ``addr`` is the address that needs to be brought into; the cache. ``rw`` indicates the expected access mode: ``0`` for *read* and ``1``; for *write*. In case of *read write* access, ``1`` is to be used. ``locality``; indicates the expected persistence of data in cache, from ``0`` which means that; data can be discarded from cache after its next use to ``3`` which means that; data is going to be reused a lot once in cache. ``1`` and ``2`` provide; intermediate behavior between these two extremes. Query for this feature with ``__has_builtin(__builtin_prefet",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:115601,Performance,cache,cache,115601,"expect_with_probability``; -------------------------------------. ``__builtin_expect_with_probability`` is similar to ``__builtin_expect`` but it; takes a probability as third argument. **Syntax**:. .. code-block:: c++. long __builtin_expect_with_probability(long expr, long val, double p). **Example of use**:. .. code-block:: c++. if (__builtin_expect_with_probability(x, 0, .3)) {; bar();; }. **Description**:. The ``__builtin_expect_with_probability()`` builtin is typically used with; control flow conditions such as in ``if`` and ``switch`` statements to help; branch prediction. It means that its first argument ``expr`` is expected to take; the value of its second argument ``val`` with probability ``p``. ``p`` must be; within ``[0.0 ; 1.0]`` bounds. This builtin always returns the value of ``expr``. Query for this feature with ``__has_builtin(__builtin_expect_with_probability)``. ``__builtin_prefetch``; ----------------------. ``__builtin_prefetch`` is used to communicate with the cache handler to bring; data into the cache before it gets used. **Syntax**:. .. code-block:: c++. void __builtin_prefetch(const void *addr, int rw=0, int locality=3). **Example of use**:. .. code-block:: c++. __builtin_prefetch(a + i);. **Description**:. The ``__builtin_prefetch(addr, rw, locality)`` builtin is expected to be used to; avoid cache misses when the developer has a good understanding of which data; are going to be used next. ``addr`` is the address that needs to be brought into; the cache. ``rw`` indicates the expected access mode: ``0`` for *read* and ``1``; for *write*. In case of *read write* access, ``1`` is to be used. ``locality``; indicates the expected persistence of data in cache, from ``0`` which means that; data can be discarded from cache after its next use to ``3`` which means that; data is going to be reused a lot once in cache. ``1`` and ``2`` provide; intermediate behavior between these two extremes. Query for this feature with ``__has_builtin(__builtin_prefet",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:115907,Performance,cache,cache,115907,"in_expect_with_probability(x, 0, .3)) {; bar();; }. **Description**:. The ``__builtin_expect_with_probability()`` builtin is typically used with; control flow conditions such as in ``if`` and ``switch`` statements to help; branch prediction. It means that its first argument ``expr`` is expected to take; the value of its second argument ``val`` with probability ``p``. ``p`` must be; within ``[0.0 ; 1.0]`` bounds. This builtin always returns the value of ``expr``. Query for this feature with ``__has_builtin(__builtin_expect_with_probability)``. ``__builtin_prefetch``; ----------------------. ``__builtin_prefetch`` is used to communicate with the cache handler to bring; data into the cache before it gets used. **Syntax**:. .. code-block:: c++. void __builtin_prefetch(const void *addr, int rw=0, int locality=3). **Example of use**:. .. code-block:: c++. __builtin_prefetch(a + i);. **Description**:. The ``__builtin_prefetch(addr, rw, locality)`` builtin is expected to be used to; avoid cache misses when the developer has a good understanding of which data; are going to be used next. ``addr`` is the address that needs to be brought into; the cache. ``rw`` indicates the expected access mode: ``0`` for *read* and ``1``; for *write*. In case of *read write* access, ``1`` is to be used. ``locality``; indicates the expected persistence of data in cache, from ``0`` which means that; data can be discarded from cache after its next use to ``3`` which means that; data is going to be reused a lot once in cache. ``1`` and ``2`` provide; intermediate behavior between these two extremes. Query for this feature with ``__has_builtin(__builtin_prefetch)``. ``__sync_swap``; ---------------. ``__sync_swap`` is used to atomically swap integers or pointers in memory. **Syntax**:. .. code-block:: c++. type __sync_swap(type *ptr, type value, ...). **Example of Use**:. .. code-block:: c++. int old_value = __sync_swap(&value, new_value);. **Description**:. The ``__sync_swap()`` builtin extends th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:116065,Performance,cache,cache,116065,"pically used with; control flow conditions such as in ``if`` and ``switch`` statements to help; branch prediction. It means that its first argument ``expr`` is expected to take; the value of its second argument ``val`` with probability ``p``. ``p`` must be; within ``[0.0 ; 1.0]`` bounds. This builtin always returns the value of ``expr``. Query for this feature with ``__has_builtin(__builtin_expect_with_probability)``. ``__builtin_prefetch``; ----------------------. ``__builtin_prefetch`` is used to communicate with the cache handler to bring; data into the cache before it gets used. **Syntax**:. .. code-block:: c++. void __builtin_prefetch(const void *addr, int rw=0, int locality=3). **Example of use**:. .. code-block:: c++. __builtin_prefetch(a + i);. **Description**:. The ``__builtin_prefetch(addr, rw, locality)`` builtin is expected to be used to; avoid cache misses when the developer has a good understanding of which data; are going to be used next. ``addr`` is the address that needs to be brought into; the cache. ``rw`` indicates the expected access mode: ``0`` for *read* and ``1``; for *write*. In case of *read write* access, ``1`` is to be used. ``locality``; indicates the expected persistence of data in cache, from ``0`` which means that; data can be discarded from cache after its next use to ``3`` which means that; data is going to be reused a lot once in cache. ``1`` and ``2`` provide; intermediate behavior between these two extremes. Query for this feature with ``__has_builtin(__builtin_prefetch)``. ``__sync_swap``; ---------------. ``__sync_swap`` is used to atomically swap integers or pointers in memory. **Syntax**:. .. code-block:: c++. type __sync_swap(type *ptr, type value, ...). **Example of Use**:. .. code-block:: c++. int old_value = __sync_swap(&value, new_value);. **Description**:. The ``__sync_swap()`` builtin extends the existing ``__sync_*()`` family of; atomic intrinsics to allow code to atomically swap the current value with the; new value.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:116269,Performance,cache,cache,116269,"bounds. This builtin always returns the value of ``expr``. Query for this feature with ``__has_builtin(__builtin_expect_with_probability)``. ``__builtin_prefetch``; ----------------------. ``__builtin_prefetch`` is used to communicate with the cache handler to bring; data into the cache before it gets used. **Syntax**:. .. code-block:: c++. void __builtin_prefetch(const void *addr, int rw=0, int locality=3). **Example of use**:. .. code-block:: c++. __builtin_prefetch(a + i);. **Description**:. The ``__builtin_prefetch(addr, rw, locality)`` builtin is expected to be used to; avoid cache misses when the developer has a good understanding of which data; are going to be used next. ``addr`` is the address that needs to be brought into; the cache. ``rw`` indicates the expected access mode: ``0`` for *read* and ``1``; for *write*. In case of *read write* access, ``1`` is to be used. ``locality``; indicates the expected persistence of data in cache, from ``0`` which means that; data can be discarded from cache after its next use to ``3`` which means that; data is going to be reused a lot once in cache. ``1`` and ``2`` provide; intermediate behavior between these two extremes. Query for this feature with ``__has_builtin(__builtin_prefetch)``. ``__sync_swap``; ---------------. ``__sync_swap`` is used to atomically swap integers or pointers in memory. **Syntax**:. .. code-block:: c++. type __sync_swap(type *ptr, type value, ...). **Example of Use**:. .. code-block:: c++. int old_value = __sync_swap(&value, new_value);. **Description**:. The ``__sync_swap()`` builtin extends the existing ``__sync_*()`` family of; atomic intrinsics to allow code to atomically swap the current value with the; new value. More importantly, it helps developers write more efficient and; correct code by avoiding expensive loops around; ``__sync_bool_compare_and_swap()`` or relying on the platform specific; implementation details of ``__sync_lock_test_and_set()``. The; ``__sync_swap()`` builtin is a fu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:116332,Performance,cache,cache,116332,"bounds. This builtin always returns the value of ``expr``. Query for this feature with ``__has_builtin(__builtin_expect_with_probability)``. ``__builtin_prefetch``; ----------------------. ``__builtin_prefetch`` is used to communicate with the cache handler to bring; data into the cache before it gets used. **Syntax**:. .. code-block:: c++. void __builtin_prefetch(const void *addr, int rw=0, int locality=3). **Example of use**:. .. code-block:: c++. __builtin_prefetch(a + i);. **Description**:. The ``__builtin_prefetch(addr, rw, locality)`` builtin is expected to be used to; avoid cache misses when the developer has a good understanding of which data; are going to be used next. ``addr`` is the address that needs to be brought into; the cache. ``rw`` indicates the expected access mode: ``0`` for *read* and ``1``; for *write*. In case of *read write* access, ``1`` is to be used. ``locality``; indicates the expected persistence of data in cache, from ``0`` which means that; data can be discarded from cache after its next use to ``3`` which means that; data is going to be reused a lot once in cache. ``1`` and ``2`` provide; intermediate behavior between these two extremes. Query for this feature with ``__has_builtin(__builtin_prefetch)``. ``__sync_swap``; ---------------. ``__sync_swap`` is used to atomically swap integers or pointers in memory. **Syntax**:. .. code-block:: c++. type __sync_swap(type *ptr, type value, ...). **Example of Use**:. .. code-block:: c++. int old_value = __sync_swap(&value, new_value);. **Description**:. The ``__sync_swap()`` builtin extends the existing ``__sync_*()`` family of; atomic intrinsics to allow code to atomically swap the current value with the; new value. More importantly, it helps developers write more efficient and; correct code by avoiding expensive loops around; ``__sync_bool_compare_and_swap()`` or relying on the platform specific; implementation details of ``__sync_lock_test_and_set()``. The; ``__sync_swap()`` builtin is a fu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:116425,Performance,cache,cache,116425,"bounds. This builtin always returns the value of ``expr``. Query for this feature with ``__has_builtin(__builtin_expect_with_probability)``. ``__builtin_prefetch``; ----------------------. ``__builtin_prefetch`` is used to communicate with the cache handler to bring; data into the cache before it gets used. **Syntax**:. .. code-block:: c++. void __builtin_prefetch(const void *addr, int rw=0, int locality=3). **Example of use**:. .. code-block:: c++. __builtin_prefetch(a + i);. **Description**:. The ``__builtin_prefetch(addr, rw, locality)`` builtin is expected to be used to; avoid cache misses when the developer has a good understanding of which data; are going to be used next. ``addr`` is the address that needs to be brought into; the cache. ``rw`` indicates the expected access mode: ``0`` for *read* and ``1``; for *write*. In case of *read write* access, ``1`` is to be used. ``locality``; indicates the expected persistence of data in cache, from ``0`` which means that; data can be discarded from cache after its next use to ``3`` which means that; data is going to be reused a lot once in cache. ``1`` and ``2`` provide; intermediate behavior between these two extremes. Query for this feature with ``__has_builtin(__builtin_prefetch)``. ``__sync_swap``; ---------------. ``__sync_swap`` is used to atomically swap integers or pointers in memory. **Syntax**:. .. code-block:: c++. type __sync_swap(type *ptr, type value, ...). **Example of Use**:. .. code-block:: c++. int old_value = __sync_swap(&value, new_value);. **Description**:. The ``__sync_swap()`` builtin extends the existing ``__sync_*()`` family of; atomic intrinsics to allow code to atomically swap the current value with the; new value. More importantly, it helps developers write more efficient and; correct code by avoiding expensive loops around; ``__sync_bool_compare_and_swap()`` or relying on the platform specific; implementation details of ``__sync_lock_test_and_set()``. The; ``__sync_swap()`` builtin is a fu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:117406,Performance,perform,performs,117406," ``2`` provide; intermediate behavior between these two extremes. Query for this feature with ``__has_builtin(__builtin_prefetch)``. ``__sync_swap``; ---------------. ``__sync_swap`` is used to atomically swap integers or pointers in memory. **Syntax**:. .. code-block:: c++. type __sync_swap(type *ptr, type value, ...). **Example of Use**:. .. code-block:: c++. int old_value = __sync_swap(&value, new_value);. **Description**:. The ``__sync_swap()`` builtin extends the existing ``__sync_*()`` family of; atomic intrinsics to allow code to atomically swap the current value with the; new value. More importantly, it helps developers write more efficient and; correct code by avoiding expensive loops around; ``__sync_bool_compare_and_swap()`` or relying on the platform specific; implementation details of ``__sync_lock_test_and_set()``. The; ``__sync_swap()`` builtin is a full barrier. ``__builtin_addressof``; -----------------------. ``__builtin_addressof`` performs the functionality of the built-in ``&``; operator, ignoring any ``operator&`` overload. This is useful in constant; expressions in C++11, where there is no other way to take the address of an; object that overloads ``operator&``. Clang automatically adds; ``[[clang::lifetimebound]]`` to the parameter of ``__builtin_addressof``. **Example of use**:. .. code-block:: c++. template<typename T> constexpr T *addressof(T &value) {; return __builtin_addressof(value);; }. ``__builtin_function_start``; -----------------------------. ``__builtin_function_start`` returns the address of a function body. **Syntax**:. .. code-block:: c++. void *__builtin_function_start(function). **Example of use**:. .. code-block:: c++. void a() {}; void *p = __builtin_function_start(a);. class A {; public:; void a(int n);; void a();; };. void A::a(int n) {}; void A::a() {}. void *pa1 = __builtin_function_start((void(A::*)(int)) &A::a);; void *pa2 = __builtin_function_start((void(A::*)()) &A::a);. **Description**:. The ``__builtin_function_st",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:119200,Performance,optimiz,optimizations,119200,"id *pa1 = __builtin_function_start((void(A::*)(int)) &A::a);; void *pa2 = __builtin_function_start((void(A::*)()) &A::a);. **Description**:. The ``__builtin_function_start`` builtin accepts an argument that can be; constant-evaluated to a function, and returns the address of the function; body. This builtin is not supported on all targets. The returned pointer may differ from the normally taken function address; and is not safe to call. For example, with ``-fsanitize=cfi``, taking a; function address produces a callable pointer to a CFI jump table, while; ``__builtin_function_start`` returns an address that fails; :doc:`cfi-icall<ControlFlowIntegrity>` checks. ``__builtin_operator_new`` and ``__builtin_operator_delete``; ------------------------------------------------------------. A call to ``__builtin_operator_new(args)`` is exactly the same as a call to; ``::operator new(args)``, except that it allows certain optimizations; that the C++ standard does not permit for a direct function call to; ``::operator new`` (in particular, removing ``new`` / ``delete`` pairs and; merging allocations), and that the call is required to resolve to a; `replaceable global allocation function; <https://en.cppreference.com/w/cpp/memory/new/operator_new>`_. Likewise, ``__builtin_operator_delete`` is exactly the same as a call to; ``::operator delete(args)``, except that it permits optimizations; and that the call is required to resolve to a; `replaceable global deallocation function; <https://en.cppreference.com/w/cpp/memory/new/operator_delete>`_. These builtins are intended for use in the implementation of ``std::allocator``; and other similar allocation libraries, and are only available in C++. Query for this feature with ``__has_builtin(__builtin_operator_new)`` or; ``__has_builtin(__builtin_operator_delete)``:. * If the value is at least ``201802L``, the builtins behave as described above. * If the value is non-zero, the builtins may not support calling arbitrary; replaceable glo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:119659,Performance,optimiz,optimizations,119659,"he normally taken function address; and is not safe to call. For example, with ``-fsanitize=cfi``, taking a; function address produces a callable pointer to a CFI jump table, while; ``__builtin_function_start`` returns an address that fails; :doc:`cfi-icall<ControlFlowIntegrity>` checks. ``__builtin_operator_new`` and ``__builtin_operator_delete``; ------------------------------------------------------------. A call to ``__builtin_operator_new(args)`` is exactly the same as a call to; ``::operator new(args)``, except that it allows certain optimizations; that the C++ standard does not permit for a direct function call to; ``::operator new`` (in particular, removing ``new`` / ``delete`` pairs and; merging allocations), and that the call is required to resolve to a; `replaceable global allocation function; <https://en.cppreference.com/w/cpp/memory/new/operator_new>`_. Likewise, ``__builtin_operator_delete`` is exactly the same as a call to; ``::operator delete(args)``, except that it permits optimizations; and that the call is required to resolve to a; `replaceable global deallocation function; <https://en.cppreference.com/w/cpp/memory/new/operator_delete>`_. These builtins are intended for use in the implementation of ``std::allocator``; and other similar allocation libraries, and are only available in C++. Query for this feature with ``__has_builtin(__builtin_operator_new)`` or; ``__has_builtin(__builtin_operator_delete)``:. * If the value is at least ``201802L``, the builtins behave as described above. * If the value is non-zero, the builtins may not support calling arbitrary; replaceable global (de)allocation functions, but do support calling at least; ``::operator new(size_t)`` and ``::operator delete(void*)``. ``__builtin_preserve_access_index``; -----------------------------------. ``__builtin_preserve_access_index`` specifies a code section where; array subscript access and structure/union member access are relocatable; under bpf compile-once run-everywhere fr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:128372,Performance,perform,performs,128372,"ltin_usubll_overflow(unsigned long long x, unsigned long long y, unsigned long long *diff);; bool __builtin_umul_overflow (unsigned x, unsigned y, unsigned *prod);; bool __builtin_umull_overflow (unsigned long x, unsigned long y, unsigned long *prod);; bool __builtin_umulll_overflow(unsigned long long x, unsigned long long y, unsigned long long *prod);; bool __builtin_sadd_overflow (int x, int y, int *sum);; bool __builtin_saddl_overflow (long x, long y, long *sum);; bool __builtin_saddll_overflow(long long x, long long y, long long *sum);; bool __builtin_ssub_overflow (int x, int y, int *diff);; bool __builtin_ssubl_overflow (long x, long y, long *diff);; bool __builtin_ssubll_overflow(long long x, long long y, long long *diff);; bool __builtin_smul_overflow (int x, int y, int *prod);; bool __builtin_smull_overflow (long x, long y, long *prod);; bool __builtin_smulll_overflow(long long x, long long y, long long *prod);. Each builtin performs the specified mathematical operation on the; first two arguments and stores the result in the third argument. If; possible, the result will be equal to mathematically-correct result; and the builtin will return 0. Otherwise, the builtin will return; 1 and the result will be equal to the unique value that is equivalent; to the mathematically-correct result modulo two raised to the *k*; power, where *k* is the number of bits in the result type. The; behavior of these builtins is well-defined for all argument values. The first three builtins work generically for operands of any integer type,; including boolean types. The operands need not have the same type as each; other, or as the result. The other builtins may implicitly promote or; convert their operands before performing the operation. Query for this feature with ``__has_builtin(__builtin_add_overflow)``, etc. Floating point builtins; ---------------------------------------. ``__builtin_isfpclass``; -----------------------. ``__builtin_isfpclass`` is used to test if the speci",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:129154,Performance,perform,performing,129154,"g x, long long y, long long *diff);; bool __builtin_smul_overflow (int x, int y, int *prod);; bool __builtin_smull_overflow (long x, long y, long *prod);; bool __builtin_smulll_overflow(long long x, long long y, long long *prod);. Each builtin performs the specified mathematical operation on the; first two arguments and stores the result in the third argument. If; possible, the result will be equal to mathematically-correct result; and the builtin will return 0. Otherwise, the builtin will return; 1 and the result will be equal to the unique value that is equivalent; to the mathematically-correct result modulo two raised to the *k*; power, where *k* is the number of bits in the result type. The; behavior of these builtins is well-defined for all argument values. The first three builtins work generically for operands of any integer type,; including boolean types. The operands need not have the same type as each; other, or as the result. The other builtins may implicitly promote or; convert their operands before performing the operation. Query for this feature with ``__has_builtin(__builtin_add_overflow)``, etc. Floating point builtins; ---------------------------------------. ``__builtin_isfpclass``; -----------------------. ``__builtin_isfpclass`` is used to test if the specified floating-point values; fall into one of the specified floating-point classes. **Syntax**:. .. code-block:: c++. int __builtin_isfpclass(fp_type expr, int mask); int_vector __builtin_isfpclass(fp_vector expr, int mask). **Example of use**:. .. code-block:: c++. if (__builtin_isfpclass(x, 448)) {; // `x` is positive finite value; 	 ...; }. **Description**:. The ``__builtin_isfpclass()`` builtin is a generalization of functions ``isnan``,; ``isinf``, ``isfinite`` and some others defined by the C standard. It tests if; the floating-point value, specified by the first argument, falls into any of data; classes, specified by the second argument. The latter is an integer constant; bitmask expressio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:140407,Performance,load,load-store,140407,"hat this intrinsic cannot yet be called in a ``constexpr`` context. Atomic Min/Max builtins with memory ordering; --------------------------------------------. There are two atomic builtins with min/max in-memory comparison and swap.; The syntax and semantics are similar to GCC-compatible __atomic_* builtins. * ``__atomic_fetch_min``; * ``__atomic_fetch_max``. The builtins work with signed and unsigned integers and require to specify memory ordering.; The return value is the original value that was stored in memory before comparison. Example:. .. code-block:: c. unsigned int val = __atomic_fetch_min(unsigned int *pi, unsigned int ui, __ATOMIC_RELAXED);. The third argument is one of the memory ordering specifiers ``__ATOMIC_RELAXED``,; ``__ATOMIC_CONSUME``, ``__ATOMIC_ACQUIRE``, ``__ATOMIC_RELEASE``,; ``__ATOMIC_ACQ_REL``, or ``__ATOMIC_SEQ_CST`` following C++11 memory model semantics. In terms of acquire-release ordering barriers these two operations are always; considered as operations with *load-store* semantics, even when the original value; is not actually modified after comparison. .. _langext-__c11_atomic:. __c11_atomic builtins; ---------------------. Clang provides a set of builtins which are intended to be used to implement; C11's ``<stdatomic.h>`` header. These builtins provide the semantics of the; ``_explicit`` form of the corresponding C11 operation, and are named with a; ``__c11_`` prefix. The supported operations, and the differences from; the corresponding C11 operations, are:. * ``__c11_atomic_init``; * ``__c11_atomic_thread_fence``; * ``__c11_atomic_signal_fence``; * ``__c11_atomic_is_lock_free`` (The argument is the size of the; ``_Atomic(...)`` object, instead of its address); * ``__c11_atomic_store``; * ``__c11_atomic_load``; * ``__c11_atomic_exchange``; * ``__c11_atomic_compare_exchange_strong``; * ``__c11_atomic_compare_exchange_weak``; * ``__c11_atomic_fetch_add``; * ``__c11_atomic_fetch_sub``; * ``__c11_atomic_fetch_and``; * ``__c11_atomic_f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:142824,Performance,optimiz,optimizations,142824,"additionally provides GCC-compatible ``__atomic_*``; builtins and OpenCL 2.0 ``__opencl_atomic_*`` builtins. The OpenCL 2.0; atomic builtins are an explicit form of the corresponding OpenCL 2.0; builtin function, and are named with a ``__opencl_`` prefix. The macros; ``__OPENCL_MEMORY_SCOPE_WORK_ITEM``, ``__OPENCL_MEMORY_SCOPE_WORK_GROUP``,; ``__OPENCL_MEMORY_SCOPE_DEVICE``, ``__OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES``,; and ``__OPENCL_MEMORY_SCOPE_SUB_GROUP`` are provided, with values; corresponding to the enumerators of OpenCL's ``memory_scope`` enumeration.). __scoped_atomic builtins; ------------------------. Clang provides a set of atomics taking a memory scope argument. These atomics; are identical to the standard GNU / GCC atomic builtins but taking an extra; memory scope argument. These are designed to be a generic alternative to the; ``__opencl_atomic_*`` builtin functions for targets that support atomic memory; scopes. Atomic memory scopes are designed to assist optimizations for systems with; several levels of memory hierarchy like GPUs. The following memory scopes are; currently supported:. * ``__MEMORY_SCOPE_SYSTEM``; * ``__MEMORY_SCOPE_DEVICE``; * ``__MEMORY_SCOPE_WRKGRP``; * ``__MEMORY_SCOPE_WVFRNT``; * ``__MEMORY_SCOPE_SINGLE``. This controls whether or not the atomic operation is ordered with respect to the; whole system, the current device, an OpenCL workgroup, wavefront, or just a; single thread. If these are used on a target that does not support atomic; scopes, then they will behave exactly as the standard GNU atomic builtins. Low-level ARM exclusive memory builtins; ---------------------------------------. Clang provides overloaded builtins giving direct access to the three key ARM; instructions for implementing atomic operations. .. code-block:: c. T __builtin_arm_ldrex(const volatile T *addr);; T __builtin_arm_ldaex(const volatile T *addr);; int __builtin_arm_strex(T val, volatile T *addr);; int __builtin_arm_stlex(T val, volatile T *addr);; voi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:144269,Performance,cache,cache,144269,"upport atomic; scopes, then they will behave exactly as the standard GNU atomic builtins. Low-level ARM exclusive memory builtins; ---------------------------------------. Clang provides overloaded builtins giving direct access to the three key ARM; instructions for implementing atomic operations. .. code-block:: c. T __builtin_arm_ldrex(const volatile T *addr);; T __builtin_arm_ldaex(const volatile T *addr);; int __builtin_arm_strex(T val, volatile T *addr);; int __builtin_arm_stlex(T val, volatile T *addr);; void __builtin_arm_clrex(void);. The types ``T`` currently supported are:. * Integer types with width at most 64 bits (or 128 bits on AArch64).; * Floating-point types; * Pointer types. Note that the compiler does not guarantee it will not insert stores which clear; the exclusive monitor in between an ``ldrex`` type operation and its paired; ``strex``. In practice this is only usually a risk when the extra store is on; the same cache line as the variable being modified and Clang will only insert; stack stores on its own, so it is best not to use these operations on variables; with automatic storage duration. Also, loads and stores may be implicit in code written between the ``ldrex`` and; ``strex``. Clang will not necessarily mitigate the effects of these either, so; care should be exercised. For these reasons the higher level atomic primitives should be preferred where; possible. Non-temporal load/store builtins; --------------------------------. Clang provides overloaded builtins allowing generation of non-temporal memory; accesses. .. code-block:: c. T __builtin_nontemporal_load(T *addr);; void __builtin_nontemporal_store(T value, T *addr);. The types ``T`` currently supported are:. * Integer types.; * Floating-point types.; * Vector types. Note that the compiler does not guarantee that non-temporal loads or stores; will be used. C++ Coroutines support builtins; --------------------------------. .. warning::; This is a work in progress. Compatibility across ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:144459,Performance,load,loads,144459," provides overloaded builtins giving direct access to the three key ARM; instructions for implementing atomic operations. .. code-block:: c. T __builtin_arm_ldrex(const volatile T *addr);; T __builtin_arm_ldaex(const volatile T *addr);; int __builtin_arm_strex(T val, volatile T *addr);; int __builtin_arm_stlex(T val, volatile T *addr);; void __builtin_arm_clrex(void);. The types ``T`` currently supported are:. * Integer types with width at most 64 bits (or 128 bits on AArch64).; * Floating-point types; * Pointer types. Note that the compiler does not guarantee it will not insert stores which clear; the exclusive monitor in between an ``ldrex`` type operation and its paired; ``strex``. In practice this is only usually a risk when the extra store is on; the same cache line as the variable being modified and Clang will only insert; stack stores on its own, so it is best not to use these operations on variables; with automatic storage duration. Also, loads and stores may be implicit in code written between the ``ldrex`` and; ``strex``. Clang will not necessarily mitigate the effects of these either, so; care should be exercised. For these reasons the higher level atomic primitives should be preferred where; possible. Non-temporal load/store builtins; --------------------------------. Clang provides overloaded builtins allowing generation of non-temporal memory; accesses. .. code-block:: c. T __builtin_nontemporal_load(T *addr);; void __builtin_nontemporal_store(T value, T *addr);. The types ``T`` currently supported are:. * Integer types.; * Floating-point types.; * Vector types. Note that the compiler does not guarantee that non-temporal loads or stores; will be used. C++ Coroutines support builtins; --------------------------------. .. warning::; This is a work in progress. Compatibility across Clang/LLVM releases is not; guaranteed. Clang provides experimental builtins to support C++ Coroutines as defined by; https://wg21.link/P0057. The following four are intended to",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:144744,Performance,load,load,144744,", volatile T *addr);; int __builtin_arm_stlex(T val, volatile T *addr);; void __builtin_arm_clrex(void);. The types ``T`` currently supported are:. * Integer types with width at most 64 bits (or 128 bits on AArch64).; * Floating-point types; * Pointer types. Note that the compiler does not guarantee it will not insert stores which clear; the exclusive monitor in between an ``ldrex`` type operation and its paired; ``strex``. In practice this is only usually a risk when the extra store is on; the same cache line as the variable being modified and Clang will only insert; stack stores on its own, so it is best not to use these operations on variables; with automatic storage duration. Also, loads and stores may be implicit in code written between the ``ldrex`` and; ``strex``. Clang will not necessarily mitigate the effects of these either, so; care should be exercised. For these reasons the higher level atomic primitives should be preferred where; possible. Non-temporal load/store builtins; --------------------------------. Clang provides overloaded builtins allowing generation of non-temporal memory; accesses. .. code-block:: c. T __builtin_nontemporal_load(T *addr);; void __builtin_nontemporal_store(T value, T *addr);. The types ``T`` currently supported are:. * Integer types.; * Floating-point types.; * Vector types. Note that the compiler does not guarantee that non-temporal loads or stores; will be used. C++ Coroutines support builtins; --------------------------------. .. warning::; This is a work in progress. Compatibility across Clang/LLVM releases is not; guaranteed. Clang provides experimental builtins to support C++ Coroutines as defined by; https://wg21.link/P0057. The following four are intended to be used by the; standard library to implement the ``std::coroutine_handle`` type. **Syntax**:. .. code-block:: c. void __builtin_coro_resume(void *addr);; void __builtin_coro_destroy(void *addr);; bool __builtin_coro_done(void *addr);; void *__builtin_coro_promise",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:145161,Performance,load,loads,145161,"ex`` type operation and its paired; ``strex``. In practice this is only usually a risk when the extra store is on; the same cache line as the variable being modified and Clang will only insert; stack stores on its own, so it is best not to use these operations on variables; with automatic storage duration. Also, loads and stores may be implicit in code written between the ``ldrex`` and; ``strex``. Clang will not necessarily mitigate the effects of these either, so; care should be exercised. For these reasons the higher level atomic primitives should be preferred where; possible. Non-temporal load/store builtins; --------------------------------. Clang provides overloaded builtins allowing generation of non-temporal memory; accesses. .. code-block:: c. T __builtin_nontemporal_load(T *addr);; void __builtin_nontemporal_store(T value, T *addr);. The types ``T`` currently supported are:. * Integer types.; * Floating-point types.; * Vector types. Note that the compiler does not guarantee that non-temporal loads or stores; will be used. C++ Coroutines support builtins; --------------------------------. .. warning::; This is a work in progress. Compatibility across Clang/LLVM releases is not; guaranteed. Clang provides experimental builtins to support C++ Coroutines as defined by; https://wg21.link/P0057. The following four are intended to be used by the; standard library to implement the ``std::coroutine_handle`` type. **Syntax**:. .. code-block:: c. void __builtin_coro_resume(void *addr);; void __builtin_coro_destroy(void *addr);; bool __builtin_coro_done(void *addr);; void *__builtin_coro_promise(void *addr, int alignment, bool from_promise). **Example of use**:. .. code-block:: c++. template <> struct coroutine_handle<void> {; void resume() const { __builtin_coro_resume(ptr); }; void destroy() const { __builtin_coro_destroy(ptr); }; bool done() const { return __builtin_coro_done(ptr); }; // ...; protected:; void *ptr;; };. template <typename Promise> struct coroutine_ha",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:150768,Performance,perform,perform,150768,"e location of the builtin. When the invocation point of ``__builtin_FUNCTION`` is not a function scope the; empty string is returned. The builtin ``__builtin_source_location`` returns a pointer to constant static; data of type ``std::source_location::__impl``. This type must have already been; defined, and must contain exactly four fields: ``const char *_M_file_name``,; ``const char *_M_function_name``, ``<any-integral-type> _M_line``, and; ``<any-integral-type> _M_column``. The fields will be populated in the same; manner as the above four builtins, except that ``_M_function_name`` is populated; with ``__PRETTY_FUNCTION__`` rather than ``__FUNCTION__``. Alignment builtins; ------------------; Clang provides builtins to support checking and adjusting alignment of; pointers and integers.; These builtins can be used to avoid relying on implementation-defined behavior; of arithmetic on integers derived from pointers.; Additionally, these builtins retain type information and, unlike bitwise; arithmetic, they can perform semantic checking on the alignment value. **Syntax**:. .. code-block:: c. Type __builtin_align_up(Type value, size_t alignment);; Type __builtin_align_down(Type value, size_t alignment);; bool __builtin_is_aligned(Type value, size_t alignment);. **Example of use**:. .. code-block:: c++. char* global_alloc_buffer;; void* my_aligned_allocator(size_t alloc_size, size_t alignment) {; char* result = __builtin_align_up(global_alloc_buffer, alignment);; // result now contains the value of global_alloc_buffer rounded up to the; // next multiple of alignment.; global_alloc_buffer = result + alloc_size;; return result;; }. void* get_start_of_page(void* ptr) {; return __builtin_align_down(ptr, PAGE_SIZE);; }. void example(char* buffer) {; if (__builtin_is_aligned(buffer, 64)) {; do_fast_aligned_copy(buffer);; } else {; do_unaligned_copy(buffer);; }; }. // In addition to pointers, the builtins can also be used on integer types; // and are evaluatable inside constant",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:153018,Performance,perform,performed,153018,"wn``, return their; first argument aligned up/down to the next multiple of the second argument.; If the value is already sufficiently aligned, it is returned unchanged.; The builtin ``__builtin_is_aligned`` returns whether the first argument is; aligned to a multiple of the second argument.; All of these builtins expect the alignment to be expressed as a number of bytes. These builtins can be used for all integer types as well as (non-function); pointer types. For pointer types, these builtins operate in terms of the integer; address of the pointer and return a new pointer of the same type (including; qualifiers such as ``const``) with an adjusted address.; When aligning pointers up or down, the resulting value must be within the same; underlying allocation or one past the end (see C17 6.5.6p8, C++ [expr.add]).; This means that arbitrary integer values stored in pointer-type variables must; not be passed to these builtins. For those use cases, the builtins can still be; used, but the operation must be performed on the pointer cast to ``uintptr_t``. If Clang can determine that the alignment is not a power of two at compile time,; it will result in a compilation failure. If the alignment argument is not a; power of two at run time, the behavior of these builtins is undefined. Non-standard C++11 Attributes; =============================. Clang's non-standard C++11 attributes live in the ``clang`` attribute; namespace. Clang supports GCC's ``gnu`` attribute namespace. All GCC attributes which; are accepted with the ``__attribute__((foo))`` syntax are also accepted as; ``[[gnu::foo]]``. This only extends to attributes which are specified by GCC; (see the list of `GCC function attributes; <https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html>`_, `GCC variable; attributes <https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html>`_, and; `GCC type attributes; <https://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html>`_). As with the GCC; implementation, these attr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:156887,Performance,cache,cache,156887,"(%eax), %eax; ret. You can also use the GCC compatibility macros ``__seg_fs`` and ``__seg_gs`` for; the same purpose. The preprocessor symbols ``__SEG_FS`` and ``__SEG_GS``; indicate their support. PowerPC Language Extensions; ---------------------------. Set the Floating Point Rounding Mode; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; PowerPC64/PowerPC64le supports the builtin function ``__builtin_setrnd`` to set; the floating point rounding mode. This function will use the least significant; two bits of integer argument to set the floating point rounding mode. .. code-block:: c++. double __builtin_setrnd(int mode);. The effective values for mode are:. - 0 - round to nearest; - 1 - round to zero; - 2 - round to +infinity; - 3 - round to -infinity. Note that the mode argument will modulo 4, so if the integer argument is greater; than 3, it will only use the least significant two bits of the mode.; Namely, ``__builtin_setrnd(102))`` is equal to ``__builtin_setrnd(2)``. PowerPC cache builtins; ^^^^^^^^^^^^^^^^^^^^^^. The PowerPC architecture specifies instructions implementing cache operations.; Clang provides builtins that give direct programmer access to these cache; instructions. Currently the following builtins are implemented in clang:. ``__builtin_dcbf`` copies the contents of a modified block from the data cache; to main memory and flushes the copy from the data cache. **Syntax**:. .. code-block:: c. void __dcbf(const void* addr); /* Data Cache Block Flush */. **Example of Use**:. .. code-block:: c. int a = 1;; __builtin_dcbf (&a);. Extensions for Static Analysis; ==============================. Clang supports additional attributes that are useful for documenting program; invariants and rules for static analysis tools, such as the `Clang Static; Analyzer <https://clang-analyzer.llvm.org/>`_. These attributes are documented; in the analyzer's `list of source-level annotations; <https://clang-analyzer.llvm.org/annotations.html>`_. Extensions for Dynamic Analysis; =====",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:156988,Performance,cache,cache,156988,"s ``__seg_fs`` and ``__seg_gs`` for; the same purpose. The preprocessor symbols ``__SEG_FS`` and ``__SEG_GS``; indicate their support. PowerPC Language Extensions; ---------------------------. Set the Floating Point Rounding Mode; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; PowerPC64/PowerPC64le supports the builtin function ``__builtin_setrnd`` to set; the floating point rounding mode. This function will use the least significant; two bits of integer argument to set the floating point rounding mode. .. code-block:: c++. double __builtin_setrnd(int mode);. The effective values for mode are:. - 0 - round to nearest; - 1 - round to zero; - 2 - round to +infinity; - 3 - round to -infinity. Note that the mode argument will modulo 4, so if the integer argument is greater; than 3, it will only use the least significant two bits of the mode.; Namely, ``__builtin_setrnd(102))`` is equal to ``__builtin_setrnd(2)``. PowerPC cache builtins; ^^^^^^^^^^^^^^^^^^^^^^. The PowerPC architecture specifies instructions implementing cache operations.; Clang provides builtins that give direct programmer access to these cache; instructions. Currently the following builtins are implemented in clang:. ``__builtin_dcbf`` copies the contents of a modified block from the data cache; to main memory and flushes the copy from the data cache. **Syntax**:. .. code-block:: c. void __dcbf(const void* addr); /* Data Cache Block Flush */. **Example of Use**:. .. code-block:: c. int a = 1;; __builtin_dcbf (&a);. Extensions for Static Analysis; ==============================. Clang supports additional attributes that are useful for documenting program; invariants and rules for static analysis tools, such as the `Clang Static; Analyzer <https://clang-analyzer.llvm.org/>`_. These attributes are documented; in the analyzer's `list of source-level annotations; <https://clang-analyzer.llvm.org/annotations.html>`_. Extensions for Dynamic Analysis; ===============================. Use ``__has_feature(address_sanitize",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:157075,Performance,cache,cache,157075,"EG_FS`` and ``__SEG_GS``; indicate their support. PowerPC Language Extensions; ---------------------------. Set the Floating Point Rounding Mode; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; PowerPC64/PowerPC64le supports the builtin function ``__builtin_setrnd`` to set; the floating point rounding mode. This function will use the least significant; two bits of integer argument to set the floating point rounding mode. .. code-block:: c++. double __builtin_setrnd(int mode);. The effective values for mode are:. - 0 - round to nearest; - 1 - round to zero; - 2 - round to +infinity; - 3 - round to -infinity. Note that the mode argument will modulo 4, so if the integer argument is greater; than 3, it will only use the least significant two bits of the mode.; Namely, ``__builtin_setrnd(102))`` is equal to ``__builtin_setrnd(2)``. PowerPC cache builtins; ^^^^^^^^^^^^^^^^^^^^^^. The PowerPC architecture specifies instructions implementing cache operations.; Clang provides builtins that give direct programmer access to these cache; instructions. Currently the following builtins are implemented in clang:. ``__builtin_dcbf`` copies the contents of a modified block from the data cache; to main memory and flushes the copy from the data cache. **Syntax**:. .. code-block:: c. void __dcbf(const void* addr); /* Data Cache Block Flush */. **Example of Use**:. .. code-block:: c. int a = 1;; __builtin_dcbf (&a);. Extensions for Static Analysis; ==============================. Clang supports additional attributes that are useful for documenting program; invariants and rules for static analysis tools, such as the `Clang Static; Analyzer <https://clang-analyzer.llvm.org/>`_. These attributes are documented; in the analyzer's `list of source-level annotations; <https://clang-analyzer.llvm.org/annotations.html>`_. Extensions for Dynamic Analysis; ===============================. Use ``__has_feature(address_sanitizer)`` to check if the code is being built; with :doc:`AddressSanitizer`. Use ``__has_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:157229,Performance,cache,cache,157229,"^^^^^^^^^; PowerPC64/PowerPC64le supports the builtin function ``__builtin_setrnd`` to set; the floating point rounding mode. This function will use the least significant; two bits of integer argument to set the floating point rounding mode. .. code-block:: c++. double __builtin_setrnd(int mode);. The effective values for mode are:. - 0 - round to nearest; - 1 - round to zero; - 2 - round to +infinity; - 3 - round to -infinity. Note that the mode argument will modulo 4, so if the integer argument is greater; than 3, it will only use the least significant two bits of the mode.; Namely, ``__builtin_setrnd(102))`` is equal to ``__builtin_setrnd(2)``. PowerPC cache builtins; ^^^^^^^^^^^^^^^^^^^^^^. The PowerPC architecture specifies instructions implementing cache operations.; Clang provides builtins that give direct programmer access to these cache; instructions. Currently the following builtins are implemented in clang:. ``__builtin_dcbf`` copies the contents of a modified block from the data cache; to main memory and flushes the copy from the data cache. **Syntax**:. .. code-block:: c. void __dcbf(const void* addr); /* Data Cache Block Flush */. **Example of Use**:. .. code-block:: c. int a = 1;; __builtin_dcbf (&a);. Extensions for Static Analysis; ==============================. Clang supports additional attributes that are useful for documenting program; invariants and rules for static analysis tools, such as the `Clang Static; Analyzer <https://clang-analyzer.llvm.org/>`_. These attributes are documented; in the analyzer's `list of source-level annotations; <https://clang-analyzer.llvm.org/annotations.html>`_. Extensions for Dynamic Analysis; ===============================. Use ``__has_feature(address_sanitizer)`` to check if the code is being built; with :doc:`AddressSanitizer`. Use ``__has_feature(thread_sanitizer)`` to check if the code is being built; with :doc:`ThreadSanitizer`. Use ``__has_feature(memory_sanitizer)`` to check if the code is being built; wit",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:157286,Performance,cache,cache,157286,"^^^^^^^^^; PowerPC64/PowerPC64le supports the builtin function ``__builtin_setrnd`` to set; the floating point rounding mode. This function will use the least significant; two bits of integer argument to set the floating point rounding mode. .. code-block:: c++. double __builtin_setrnd(int mode);. The effective values for mode are:. - 0 - round to nearest; - 1 - round to zero; - 2 - round to +infinity; - 3 - round to -infinity. Note that the mode argument will modulo 4, so if the integer argument is greater; than 3, it will only use the least significant two bits of the mode.; Namely, ``__builtin_setrnd(102))`` is equal to ``__builtin_setrnd(2)``. PowerPC cache builtins; ^^^^^^^^^^^^^^^^^^^^^^. The PowerPC architecture specifies instructions implementing cache operations.; Clang provides builtins that give direct programmer access to these cache; instructions. Currently the following builtins are implemented in clang:. ``__builtin_dcbf`` copies the contents of a modified block from the data cache; to main memory and flushes the copy from the data cache. **Syntax**:. .. code-block:: c. void __dcbf(const void* addr); /* Data Cache Block Flush */. **Example of Use**:. .. code-block:: c. int a = 1;; __builtin_dcbf (&a);. Extensions for Static Analysis; ==============================. Clang supports additional attributes that are useful for documenting program; invariants and rules for static analysis tools, such as the `Clang Static; Analyzer <https://clang-analyzer.llvm.org/>`_. These attributes are documented; in the analyzer's `list of source-level annotations; <https://clang-analyzer.llvm.org/annotations.html>`_. Extensions for Dynamic Analysis; ===============================. Use ``__has_feature(address_sanitizer)`` to check if the code is being built; with :doc:`AddressSanitizer`. Use ``__has_feature(thread_sanitizer)`` to check if the code is being built; with :doc:`ThreadSanitizer`. Use ``__has_feature(memory_sanitizer)`` to check if the code is being built; wit",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:158491,Performance,optimiz,optimization,158491,"==================. Clang supports additional attributes that are useful for documenting program; invariants and rules for static analysis tools, such as the `Clang Static; Analyzer <https://clang-analyzer.llvm.org/>`_. These attributes are documented; in the analyzer's `list of source-level annotations; <https://clang-analyzer.llvm.org/annotations.html>`_. Extensions for Dynamic Analysis; ===============================. Use ``__has_feature(address_sanitizer)`` to check if the code is being built; with :doc:`AddressSanitizer`. Use ``__has_feature(thread_sanitizer)`` to check if the code is being built; with :doc:`ThreadSanitizer`. Use ``__has_feature(memory_sanitizer)`` to check if the code is being built; with :doc:`MemorySanitizer`. Use ``__has_feature(dataflow_sanitizer)`` to check if the code is being built; with :doc:`DataFlowSanitizer`. Use ``__has_feature(safe_stack)`` to check if the code is being built; with :doc:`SafeStack`. Extensions for selectively disabling optimization; =================================================. Clang provides a mechanism for selectively disabling optimizations in functions; and methods. To disable optimizations in a single function definition, the GNU-style or C++11; non-standard attribute ``optnone`` can be used. .. code-block:: c++. // The following functions will not be optimized.; // GNU-style attribute; __attribute__((optnone)) int foo() {; // ... code; }; // C++11 attribute; [[clang::optnone]] int bar() {; // ... code; }. To facilitate disabling optimization for a range of function definitions, a; range-based pragma is provided. Its syntax is ``#pragma clang optimize``; followed by ``off`` or ``on``. All function definitions in the region between an ``off`` and the following; ``on`` will be decorated with the ``optnone`` attribute unless doing so would; conflict with explicit attributes already present on the function (e.g. the; ones that control inlining). .. code-block:: c++. #pragma clang optimize off; // This funct",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:158609,Performance,optimiz,optimizations,158609,"invariants and rules for static analysis tools, such as the `Clang Static; Analyzer <https://clang-analyzer.llvm.org/>`_. These attributes are documented; in the analyzer's `list of source-level annotations; <https://clang-analyzer.llvm.org/annotations.html>`_. Extensions for Dynamic Analysis; ===============================. Use ``__has_feature(address_sanitizer)`` to check if the code is being built; with :doc:`AddressSanitizer`. Use ``__has_feature(thread_sanitizer)`` to check if the code is being built; with :doc:`ThreadSanitizer`. Use ``__has_feature(memory_sanitizer)`` to check if the code is being built; with :doc:`MemorySanitizer`. Use ``__has_feature(dataflow_sanitizer)`` to check if the code is being built; with :doc:`DataFlowSanitizer`. Use ``__has_feature(safe_stack)`` to check if the code is being built; with :doc:`SafeStack`. Extensions for selectively disabling optimization; =================================================. Clang provides a mechanism for selectively disabling optimizations in functions; and methods. To disable optimizations in a single function definition, the GNU-style or C++11; non-standard attribute ``optnone`` can be used. .. code-block:: c++. // The following functions will not be optimized.; // GNU-style attribute; __attribute__((optnone)) int foo() {; // ... code; }; // C++11 attribute; [[clang::optnone]] int bar() {; // ... code; }. To facilitate disabling optimization for a range of function definitions, a; range-based pragma is provided. Its syntax is ``#pragma clang optimize``; followed by ``off`` or ``on``. All function definitions in the region between an ``off`` and the following; ``on`` will be decorated with the ``optnone`` attribute unless doing so would; conflict with explicit attributes already present on the function (e.g. the; ones that control inlining). .. code-block:: c++. #pragma clang optimize off; // This function will be decorated with optnone.; int foo() {; // ... code; }. // optnone conflicts with always",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:158661,Performance,optimiz,optimizations,158661,".org/>`_. These attributes are documented; in the analyzer's `list of source-level annotations; <https://clang-analyzer.llvm.org/annotations.html>`_. Extensions for Dynamic Analysis; ===============================. Use ``__has_feature(address_sanitizer)`` to check if the code is being built; with :doc:`AddressSanitizer`. Use ``__has_feature(thread_sanitizer)`` to check if the code is being built; with :doc:`ThreadSanitizer`. Use ``__has_feature(memory_sanitizer)`` to check if the code is being built; with :doc:`MemorySanitizer`. Use ``__has_feature(dataflow_sanitizer)`` to check if the code is being built; with :doc:`DataFlowSanitizer`. Use ``__has_feature(safe_stack)`` to check if the code is being built; with :doc:`SafeStack`. Extensions for selectively disabling optimization; =================================================. Clang provides a mechanism for selectively disabling optimizations in functions; and methods. To disable optimizations in a single function definition, the GNU-style or C++11; non-standard attribute ``optnone`` can be used. .. code-block:: c++. // The following functions will not be optimized.; // GNU-style attribute; __attribute__((optnone)) int foo() {; // ... code; }; // C++11 attribute; [[clang::optnone]] int bar() {; // ... code; }. To facilitate disabling optimization for a range of function definitions, a; range-based pragma is provided. Its syntax is ``#pragma clang optimize``; followed by ``off`` or ``on``. All function definitions in the region between an ``off`` and the following; ``on`` will be decorated with the ``optnone`` attribute unless doing so would; conflict with explicit attributes already present on the function (e.g. the; ones that control inlining). .. code-block:: c++. #pragma clang optimize off; // This function will be decorated with optnone.; int foo() {; // ... code; }. // optnone conflicts with always_inline, so bar() will not be decorated.; __attribute__((always_inline)) int bar() {; // ... code; }; #pragma cl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:158840,Performance,optimiz,optimized,158840,"analyzer.llvm.org/annotations.html>`_. Extensions for Dynamic Analysis; ===============================. Use ``__has_feature(address_sanitizer)`` to check if the code is being built; with :doc:`AddressSanitizer`. Use ``__has_feature(thread_sanitizer)`` to check if the code is being built; with :doc:`ThreadSanitizer`. Use ``__has_feature(memory_sanitizer)`` to check if the code is being built; with :doc:`MemorySanitizer`. Use ``__has_feature(dataflow_sanitizer)`` to check if the code is being built; with :doc:`DataFlowSanitizer`. Use ``__has_feature(safe_stack)`` to check if the code is being built; with :doc:`SafeStack`. Extensions for selectively disabling optimization; =================================================. Clang provides a mechanism for selectively disabling optimizations in functions; and methods. To disable optimizations in a single function definition, the GNU-style or C++11; non-standard attribute ``optnone`` can be used. .. code-block:: c++. // The following functions will not be optimized.; // GNU-style attribute; __attribute__((optnone)) int foo() {; // ... code; }; // C++11 attribute; [[clang::optnone]] int bar() {; // ... code; }. To facilitate disabling optimization for a range of function definitions, a; range-based pragma is provided. Its syntax is ``#pragma clang optimize``; followed by ``off`` or ``on``. All function definitions in the region between an ``off`` and the following; ``on`` will be decorated with the ``optnone`` attribute unless doing so would; conflict with explicit attributes already present on the function (e.g. the; ones that control inlining). .. code-block:: c++. #pragma clang optimize off; // This function will be decorated with optnone.; int foo() {; // ... code; }. // optnone conflicts with always_inline, so bar() will not be decorated.; __attribute__((always_inline)) int bar() {; // ... code; }; #pragma clang optimize on. If no ``on`` is found to close an ``off`` region, the end of the region is the; end of the com",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:159022,Performance,optimiz,optimization,159022,"eature(thread_sanitizer)`` to check if the code is being built; with :doc:`ThreadSanitizer`. Use ``__has_feature(memory_sanitizer)`` to check if the code is being built; with :doc:`MemorySanitizer`. Use ``__has_feature(dataflow_sanitizer)`` to check if the code is being built; with :doc:`DataFlowSanitizer`. Use ``__has_feature(safe_stack)`` to check if the code is being built; with :doc:`SafeStack`. Extensions for selectively disabling optimization; =================================================. Clang provides a mechanism for selectively disabling optimizations in functions; and methods. To disable optimizations in a single function definition, the GNU-style or C++11; non-standard attribute ``optnone`` can be used. .. code-block:: c++. // The following functions will not be optimized.; // GNU-style attribute; __attribute__((optnone)) int foo() {; // ... code; }; // C++11 attribute; [[clang::optnone]] int bar() {; // ... code; }. To facilitate disabling optimization for a range of function definitions, a; range-based pragma is provided. Its syntax is ``#pragma clang optimize``; followed by ``off`` or ``on``. All function definitions in the region between an ``off`` and the following; ``on`` will be decorated with the ``optnone`` attribute unless doing so would; conflict with explicit attributes already present on the function (e.g. the; ones that control inlining). .. code-block:: c++. #pragma clang optimize off; // This function will be decorated with optnone.; int foo() {; // ... code; }. // optnone conflicts with always_inline, so bar() will not be decorated.; __attribute__((always_inline)) int bar() {; // ... code; }; #pragma clang optimize on. If no ``on`` is found to close an ``off`` region, the end of the region is the; end of the compilation unit. Note that a stray ``#pragma clang optimize on`` does not selectively enable; additional optimizations when compiling at low optimization levels. This feature; can only be used to selectively disable optimizations",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:159137,Performance,optimiz,optimize,159137,". Use ``__has_feature(memory_sanitizer)`` to check if the code is being built; with :doc:`MemorySanitizer`. Use ``__has_feature(dataflow_sanitizer)`` to check if the code is being built; with :doc:`DataFlowSanitizer`. Use ``__has_feature(safe_stack)`` to check if the code is being built; with :doc:`SafeStack`. Extensions for selectively disabling optimization; =================================================. Clang provides a mechanism for selectively disabling optimizations in functions; and methods. To disable optimizations in a single function definition, the GNU-style or C++11; non-standard attribute ``optnone`` can be used. .. code-block:: c++. // The following functions will not be optimized.; // GNU-style attribute; __attribute__((optnone)) int foo() {; // ... code; }; // C++11 attribute; [[clang::optnone]] int bar() {; // ... code; }. To facilitate disabling optimization for a range of function definitions, a; range-based pragma is provided. Its syntax is ``#pragma clang optimize``; followed by ``off`` or ``on``. All function definitions in the region between an ``off`` and the following; ``on`` will be decorated with the ``optnone`` attribute unless doing so would; conflict with explicit attributes already present on the function (e.g. the; ones that control inlining). .. code-block:: c++. #pragma clang optimize off; // This function will be decorated with optnone.; int foo() {; // ... code; }. // optnone conflicts with always_inline, so bar() will not be decorated.; __attribute__((always_inline)) int bar() {; // ... code; }; #pragma clang optimize on. If no ``on`` is found to close an ``off`` region, the end of the region is the; end of the compilation unit. Note that a stray ``#pragma clang optimize on`` does not selectively enable; additional optimizations when compiling at low optimization levels. This feature; can only be used to selectively disable optimizations. The pragma has an effect on functions only at the point of their definition; for; functio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:159477,Performance,optimiz,optimize,159477,"ion; =================================================. Clang provides a mechanism for selectively disabling optimizations in functions; and methods. To disable optimizations in a single function definition, the GNU-style or C++11; non-standard attribute ``optnone`` can be used. .. code-block:: c++. // The following functions will not be optimized.; // GNU-style attribute; __attribute__((optnone)) int foo() {; // ... code; }; // C++11 attribute; [[clang::optnone]] int bar() {; // ... code; }. To facilitate disabling optimization for a range of function definitions, a; range-based pragma is provided. Its syntax is ``#pragma clang optimize``; followed by ``off`` or ``on``. All function definitions in the region between an ``off`` and the following; ``on`` will be decorated with the ``optnone`` attribute unless doing so would; conflict with explicit attributes already present on the function (e.g. the; ones that control inlining). .. code-block:: c++. #pragma clang optimize off; // This function will be decorated with optnone.; int foo() {; // ... code; }. // optnone conflicts with always_inline, so bar() will not be decorated.; __attribute__((always_inline)) int bar() {; // ... code; }; #pragma clang optimize on. If no ``on`` is found to close an ``off`` region, the end of the region is the; end of the compilation unit. Note that a stray ``#pragma clang optimize on`` does not selectively enable; additional optimizations when compiling at low optimization levels. This feature; can only be used to selectively disable optimizations. The pragma has an effect on functions only at the point of their definition; for; function templates, this means that the state of the pragma at the point of an; instantiation is not necessarily relevant. Consider the following example:. .. code-block:: c++. template<typename T> T twice(T t) {; return 2 * t;; }. #pragma clang optimize off; template<typename T> T thrice(T t) {; return 3 * t;; }. int container(int a, int b) {; return twice(a) + ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:159718,Performance,optimiz,optimize,159718,"GNU-style or C++11; non-standard attribute ``optnone`` can be used. .. code-block:: c++. // The following functions will not be optimized.; // GNU-style attribute; __attribute__((optnone)) int foo() {; // ... code; }; // C++11 attribute; [[clang::optnone]] int bar() {; // ... code; }. To facilitate disabling optimization for a range of function definitions, a; range-based pragma is provided. Its syntax is ``#pragma clang optimize``; followed by ``off`` or ``on``. All function definitions in the region between an ``off`` and the following; ``on`` will be decorated with the ``optnone`` attribute unless doing so would; conflict with explicit attributes already present on the function (e.g. the; ones that control inlining). .. code-block:: c++. #pragma clang optimize off; // This function will be decorated with optnone.; int foo() {; // ... code; }. // optnone conflicts with always_inline, so bar() will not be decorated.; __attribute__((always_inline)) int bar() {; // ... code; }; #pragma clang optimize on. If no ``on`` is found to close an ``off`` region, the end of the region is the; end of the compilation unit. Note that a stray ``#pragma clang optimize on`` does not selectively enable; additional optimizations when compiling at low optimization levels. This feature; can only be used to selectively disable optimizations. The pragma has an effect on functions only at the point of their definition; for; function templates, this means that the state of the pragma at the point of an; instantiation is not necessarily relevant. Consider the following example:. .. code-block:: c++. template<typename T> T twice(T t) {; return 2 * t;; }. #pragma clang optimize off; template<typename T> T thrice(T t) {; return 3 * t;; }. int container(int a, int b) {; return twice(a) + thrice(b);; }; #pragma clang optimize on. In this example, the definition of the template function ``twice`` is outside; the pragma region, whereas the definition of ``thrice`` is inside the region.; The ``conta",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:159874,Performance,optimiz,optimize,159874,"{; // ... code; }; // C++11 attribute; [[clang::optnone]] int bar() {; // ... code; }. To facilitate disabling optimization for a range of function definitions, a; range-based pragma is provided. Its syntax is ``#pragma clang optimize``; followed by ``off`` or ``on``. All function definitions in the region between an ``off`` and the following; ``on`` will be decorated with the ``optnone`` attribute unless doing so would; conflict with explicit attributes already present on the function (e.g. the; ones that control inlining). .. code-block:: c++. #pragma clang optimize off; // This function will be decorated with optnone.; int foo() {; // ... code; }. // optnone conflicts with always_inline, so bar() will not be decorated.; __attribute__((always_inline)) int bar() {; // ... code; }; #pragma clang optimize on. If no ``on`` is found to close an ``off`` region, the end of the region is the; end of the compilation unit. Note that a stray ``#pragma clang optimize on`` does not selectively enable; additional optimizations when compiling at low optimization levels. This feature; can only be used to selectively disable optimizations. The pragma has an effect on functions only at the point of their definition; for; function templates, this means that the state of the pragma at the point of an; instantiation is not necessarily relevant. Consider the following example:. .. code-block:: c++. template<typename T> T twice(T t) {; return 2 * t;; }. #pragma clang optimize off; template<typename T> T thrice(T t) {; return 3 * t;; }. int container(int a, int b) {; return twice(a) + thrice(b);; }; #pragma clang optimize on. In this example, the definition of the template function ``twice`` is outside; the pragma region, whereas the definition of ``thrice`` is inside the region.; The ``container`` function is also in the region and will not be optimized, but; it causes the instantiation of ``twice`` and ``thrice`` with an ``int`` type; of; these two instantiations, ``twice`` will be opti",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:159928,Performance,optimiz,optimizations,159928,"{; // ... code; }; // C++11 attribute; [[clang::optnone]] int bar() {; // ... code; }. To facilitate disabling optimization for a range of function definitions, a; range-based pragma is provided. Its syntax is ``#pragma clang optimize``; followed by ``off`` or ``on``. All function definitions in the region between an ``off`` and the following; ``on`` will be decorated with the ``optnone`` attribute unless doing so would; conflict with explicit attributes already present on the function (e.g. the; ones that control inlining). .. code-block:: c++. #pragma clang optimize off; // This function will be decorated with optnone.; int foo() {; // ... code; }. // optnone conflicts with always_inline, so bar() will not be decorated.; __attribute__((always_inline)) int bar() {; // ... code; }; #pragma clang optimize on. If no ``on`` is found to close an ``off`` region, the end of the region is the; end of the compilation unit. Note that a stray ``#pragma clang optimize on`` does not selectively enable; additional optimizations when compiling at low optimization levels. This feature; can only be used to selectively disable optimizations. The pragma has an effect on functions only at the point of their definition; for; function templates, this means that the state of the pragma at the point of an; instantiation is not necessarily relevant. Consider the following example:. .. code-block:: c++. template<typename T> T twice(T t) {; return 2 * t;; }. #pragma clang optimize off; template<typename T> T thrice(T t) {; return 3 * t;; }. int container(int a, int b) {; return twice(a) + thrice(b);; }; #pragma clang optimize on. In this example, the definition of the template function ``twice`` is outside; the pragma region, whereas the definition of ``thrice`` is inside the region.; The ``container`` function is also in the region and will not be optimized, but; it causes the instantiation of ``twice`` and ``thrice`` with an ``int`` type; of; these two instantiations, ``twice`` will be opti",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:159964,Performance,optimiz,optimization,159964,"{; // ... code; }; // C++11 attribute; [[clang::optnone]] int bar() {; // ... code; }. To facilitate disabling optimization for a range of function definitions, a; range-based pragma is provided. Its syntax is ``#pragma clang optimize``; followed by ``off`` or ``on``. All function definitions in the region between an ``off`` and the following; ``on`` will be decorated with the ``optnone`` attribute unless doing so would; conflict with explicit attributes already present on the function (e.g. the; ones that control inlining). .. code-block:: c++. #pragma clang optimize off; // This function will be decorated with optnone.; int foo() {; // ... code; }. // optnone conflicts with always_inline, so bar() will not be decorated.; __attribute__((always_inline)) int bar() {; // ... code; }; #pragma clang optimize on. If no ``on`` is found to close an ``off`` region, the end of the region is the; end of the compilation unit. Note that a stray ``#pragma clang optimize on`` does not selectively enable; additional optimizations when compiling at low optimization levels. This feature; can only be used to selectively disable optimizations. The pragma has an effect on functions only at the point of their definition; for; function templates, this means that the state of the pragma at the point of an; instantiation is not necessarily relevant. Consider the following example:. .. code-block:: c++. template<typename T> T twice(T t) {; return 2 * t;; }. #pragma clang optimize off; template<typename T> T thrice(T t) {; return 3 * t;; }. int container(int a, int b) {; return twice(a) + thrice(b);; }; #pragma clang optimize on. In this example, the definition of the template function ``twice`` is outside; the pragma region, whereas the definition of ``thrice`` is inside the region.; The ``container`` function is also in the region and will not be optimized, but; it causes the instantiation of ``twice`` and ``thrice`` with an ``int`` type; of; these two instantiations, ``twice`` will be opti",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:160039,Performance,optimiz,optimizations,160039,"ing optimization for a range of function definitions, a; range-based pragma is provided. Its syntax is ``#pragma clang optimize``; followed by ``off`` or ``on``. All function definitions in the region between an ``off`` and the following; ``on`` will be decorated with the ``optnone`` attribute unless doing so would; conflict with explicit attributes already present on the function (e.g. the; ones that control inlining). .. code-block:: c++. #pragma clang optimize off; // This function will be decorated with optnone.; int foo() {; // ... code; }. // optnone conflicts with always_inline, so bar() will not be decorated.; __attribute__((always_inline)) int bar() {; // ... code; }; #pragma clang optimize on. If no ``on`` is found to close an ``off`` region, the end of the region is the; end of the compilation unit. Note that a stray ``#pragma clang optimize on`` does not selectively enable; additional optimizations when compiling at low optimization levels. This feature; can only be used to selectively disable optimizations. The pragma has an effect on functions only at the point of their definition; for; function templates, this means that the state of the pragma at the point of an; instantiation is not necessarily relevant. Consider the following example:. .. code-block:: c++. template<typename T> T twice(T t) {; return 2 * t;; }. #pragma clang optimize off; template<typename T> T thrice(T t) {; return 3 * t;; }. int container(int a, int b) {; return twice(a) + thrice(b);; }; #pragma clang optimize on. In this example, the definition of the template function ``twice`` is outside; the pragma region, whereas the definition of ``thrice`` is inside the region.; The ``container`` function is also in the region and will not be optimized, but; it causes the instantiation of ``twice`` and ``thrice`` with an ``int`` type; of; these two instantiations, ``twice`` will be optimized (because its definition; was outside the region) and ``thrice`` will not be optimized. Clang also imp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:160382,Performance,optimiz,optimize,160382,"he; ones that control inlining). .. code-block:: c++. #pragma clang optimize off; // This function will be decorated with optnone.; int foo() {; // ... code; }. // optnone conflicts with always_inline, so bar() will not be decorated.; __attribute__((always_inline)) int bar() {; // ... code; }; #pragma clang optimize on. If no ``on`` is found to close an ``off`` region, the end of the region is the; end of the compilation unit. Note that a stray ``#pragma clang optimize on`` does not selectively enable; additional optimizations when compiling at low optimization levels. This feature; can only be used to selectively disable optimizations. The pragma has an effect on functions only at the point of their definition; for; function templates, this means that the state of the pragma at the point of an; instantiation is not necessarily relevant. Consider the following example:. .. code-block:: c++. template<typename T> T twice(T t) {; return 2 * t;; }. #pragma clang optimize off; template<typename T> T thrice(T t) {; return 3 * t;; }. int container(int a, int b) {; return twice(a) + thrice(b);; }; #pragma clang optimize on. In this example, the definition of the template function ``twice`` is outside; the pragma region, whereas the definition of ``thrice`` is inside the region.; The ``container`` function is also in the region and will not be optimized, but; it causes the instantiation of ``twice`` and ``thrice`` with an ``int`` type; of; these two instantiations, ``twice`` will be optimized (because its definition; was outside the region) and ``thrice`` will not be optimized. Clang also implements MSVC's range-based pragma,; ``#pragma optimize(""[optimization-list]"", on | off)``. At the moment, Clang only; supports an empty optimization list, whereas MSVC supports the arguments, ``s``,; ``g``, ``t``, and ``y``. Currently, the implementation of ``pragma optimize`` behaves; the same as ``#pragma clang optimize``. All functions; between ``off`` and ``on`` will be decorated wit",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:160530,Performance,optimiz,optimize,160530,"is function will be decorated with optnone.; int foo() {; // ... code; }. // optnone conflicts with always_inline, so bar() will not be decorated.; __attribute__((always_inline)) int bar() {; // ... code; }; #pragma clang optimize on. If no ``on`` is found to close an ``off`` region, the end of the region is the; end of the compilation unit. Note that a stray ``#pragma clang optimize on`` does not selectively enable; additional optimizations when compiling at low optimization levels. This feature; can only be used to selectively disable optimizations. The pragma has an effect on functions only at the point of their definition; for; function templates, this means that the state of the pragma at the point of an; instantiation is not necessarily relevant. Consider the following example:. .. code-block:: c++. template<typename T> T twice(T t) {; return 2 * t;; }. #pragma clang optimize off; template<typename T> T thrice(T t) {; return 3 * t;; }. int container(int a, int b) {; return twice(a) + thrice(b);; }; #pragma clang optimize on. In this example, the definition of the template function ``twice`` is outside; the pragma region, whereas the definition of ``thrice`` is inside the region.; The ``container`` function is also in the region and will not be optimized, but; it causes the instantiation of ``twice`` and ``thrice`` with an ``int`` type; of; these two instantiations, ``twice`` will be optimized (because its definition; was outside the region) and ``thrice`` will not be optimized. Clang also implements MSVC's range-based pragma,; ``#pragma optimize(""[optimization-list]"", on | off)``. At the moment, Clang only; supports an empty optimization list, whereas MSVC supports the arguments, ``s``,; ``g``, ``t``, and ``y``. Currently, the implementation of ``pragma optimize`` behaves; the same as ``#pragma clang optimize``. All functions; between ``off`` and ``on`` will be decorated with the ``optnone`` attribute. .. code-block:: c++. #pragma optimize("""", off); // This fun",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:160766,Performance,optimiz,optimized,160766," stray ``#pragma clang optimize on`` does not selectively enable; additional optimizations when compiling at low optimization levels. This feature; can only be used to selectively disable optimizations. The pragma has an effect on functions only at the point of their definition; for; function templates, this means that the state of the pragma at the point of an; instantiation is not necessarily relevant. Consider the following example:. .. code-block:: c++. template<typename T> T twice(T t) {; return 2 * t;; }. #pragma clang optimize off; template<typename T> T thrice(T t) {; return 3 * t;; }. int container(int a, int b) {; return twice(a) + thrice(b);; }; #pragma clang optimize on. In this example, the definition of the template function ``twice`` is outside; the pragma region, whereas the definition of ``thrice`` is inside the region.; The ``container`` function is also in the region and will not be optimized, but; it causes the instantiation of ``twice`` and ``thrice`` with an ``int`` type; of; these two instantiations, ``twice`` will be optimized (because its definition; was outside the region) and ``thrice`` will not be optimized. Clang also implements MSVC's range-based pragma,; ``#pragma optimize(""[optimization-list]"", on | off)``. At the moment, Clang only; supports an empty optimization list, whereas MSVC supports the arguments, ``s``,; ``g``, ``t``, and ``y``. Currently, the implementation of ``pragma optimize`` behaves; the same as ``#pragma clang optimize``. All functions; between ``off`` and ``on`` will be decorated with the ``optnone`` attribute. .. code-block:: c++. #pragma optimize("""", off); // This function will be decorated with optnone.; void f1() {}. #pragma optimize("""", on); // This function will be optimized with whatever was specified on; // the commandline.; void f2() {}. // This will warn with Clang's current implementation.; #pragma optimize(""g"", on); void f3() {}. For MSVC, an empty optimization list and ``off`` parameter will turn off; all",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:160908,Performance,optimiz,optimized,160908," stray ``#pragma clang optimize on`` does not selectively enable; additional optimizations when compiling at low optimization levels. This feature; can only be used to selectively disable optimizations. The pragma has an effect on functions only at the point of their definition; for; function templates, this means that the state of the pragma at the point of an; instantiation is not necessarily relevant. Consider the following example:. .. code-block:: c++. template<typename T> T twice(T t) {; return 2 * t;; }. #pragma clang optimize off; template<typename T> T thrice(T t) {; return 3 * t;; }. int container(int a, int b) {; return twice(a) + thrice(b);; }; #pragma clang optimize on. In this example, the definition of the template function ``twice`` is outside; the pragma region, whereas the definition of ``thrice`` is inside the region.; The ``container`` function is also in the region and will not be optimized, but; it causes the instantiation of ``twice`` and ``thrice`` with an ``int`` type; of; these two instantiations, ``twice`` will be optimized (because its definition; was outside the region) and ``thrice`` will not be optimized. Clang also implements MSVC's range-based pragma,; ``#pragma optimize(""[optimization-list]"", on | off)``. At the moment, Clang only; supports an empty optimization list, whereas MSVC supports the arguments, ``s``,; ``g``, ``t``, and ``y``. Currently, the implementation of ``pragma optimize`` behaves; the same as ``#pragma clang optimize``. All functions; between ``off`` and ``on`` will be decorated with the ``optnone`` attribute. .. code-block:: c++. #pragma optimize("""", off); // This function will be decorated with optnone.; void f1() {}. #pragma optimize("""", on); // This function will be optimized with whatever was specified on; // the commandline.; void f2() {}. // This will warn with Clang's current implementation.; #pragma optimize(""g"", on); void f3() {}. For MSVC, an empty optimization list and ``off`` parameter will turn off; all",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:160994,Performance,optimiz,optimized,160994," stray ``#pragma clang optimize on`` does not selectively enable; additional optimizations when compiling at low optimization levels. This feature; can only be used to selectively disable optimizations. The pragma has an effect on functions only at the point of their definition; for; function templates, this means that the state of the pragma at the point of an; instantiation is not necessarily relevant. Consider the following example:. .. code-block:: c++. template<typename T> T twice(T t) {; return 2 * t;; }. #pragma clang optimize off; template<typename T> T thrice(T t) {; return 3 * t;; }. int container(int a, int b) {; return twice(a) + thrice(b);; }; #pragma clang optimize on. In this example, the definition of the template function ``twice`` is outside; the pragma region, whereas the definition of ``thrice`` is inside the region.; The ``container`` function is also in the region and will not be optimized, but; it causes the instantiation of ``twice`` and ``thrice`` with an ``int`` type; of; these two instantiations, ``twice`` will be optimized (because its definition; was outside the region) and ``thrice`` will not be optimized. Clang also implements MSVC's range-based pragma,; ``#pragma optimize(""[optimization-list]"", on | off)``. At the moment, Clang only; supports an empty optimization list, whereas MSVC supports the arguments, ``s``,; ``g``, ``t``, and ``y``. Currently, the implementation of ``pragma optimize`` behaves; the same as ``#pragma clang optimize``. All functions; between ``off`` and ``on`` will be decorated with the ``optnone`` attribute. .. code-block:: c++. #pragma optimize("""", off); // This function will be decorated with optnone.; void f1() {}. #pragma optimize("""", on); // This function will be optimized with whatever was specified on; // the commandline.; void f2() {}. // This will warn with Clang's current implementation.; #pragma optimize(""g"", on); void f3() {}. For MSVC, an empty optimization list and ``off`` parameter will turn off; all",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:161065,Performance,optimiz,optimize,161065,"e pragma has an effect on functions only at the point of their definition; for; function templates, this means that the state of the pragma at the point of an; instantiation is not necessarily relevant. Consider the following example:. .. code-block:: c++. template<typename T> T twice(T t) {; return 2 * t;; }. #pragma clang optimize off; template<typename T> T thrice(T t) {; return 3 * t;; }. int container(int a, int b) {; return twice(a) + thrice(b);; }; #pragma clang optimize on. In this example, the definition of the template function ``twice`` is outside; the pragma region, whereas the definition of ``thrice`` is inside the region.; The ``container`` function is also in the region and will not be optimized, but; it causes the instantiation of ``twice`` and ``thrice`` with an ``int`` type; of; these two instantiations, ``twice`` will be optimized (because its definition; was outside the region) and ``thrice`` will not be optimized. Clang also implements MSVC's range-based pragma,; ``#pragma optimize(""[optimization-list]"", on | off)``. At the moment, Clang only; supports an empty optimization list, whereas MSVC supports the arguments, ``s``,; ``g``, ``t``, and ``y``. Currently, the implementation of ``pragma optimize`` behaves; the same as ``#pragma clang optimize``. All functions; between ``off`` and ``on`` will be decorated with the ``optnone`` attribute. .. code-block:: c++. #pragma optimize("""", off); // This function will be decorated with optnone.; void f1() {}. #pragma optimize("""", on); // This function will be optimized with whatever was specified on; // the commandline.; void f2() {}. // This will warn with Clang's current implementation.; #pragma optimize(""g"", on); void f3() {}. For MSVC, an empty optimization list and ``off`` parameter will turn off; all optimizations, ``s``, ``g``, ``t``, and ``y``. An empty optimization and; ``on`` parameter will reset the optimizations to the ones specified on the; commandline. .. list-table:: Parameters (unsupported b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:161076,Performance,optimiz,optimization-list,161076,"e pragma has an effect on functions only at the point of their definition; for; function templates, this means that the state of the pragma at the point of an; instantiation is not necessarily relevant. Consider the following example:. .. code-block:: c++. template<typename T> T twice(T t) {; return 2 * t;; }. #pragma clang optimize off; template<typename T> T thrice(T t) {; return 3 * t;; }. int container(int a, int b) {; return twice(a) + thrice(b);; }; #pragma clang optimize on. In this example, the definition of the template function ``twice`` is outside; the pragma region, whereas the definition of ``thrice`` is inside the region.; The ``container`` function is also in the region and will not be optimized, but; it causes the instantiation of ``twice`` and ``thrice`` with an ``int`` type; of; these two instantiations, ``twice`` will be optimized (because its definition; was outside the region) and ``thrice`` will not be optimized. Clang also implements MSVC's range-based pragma,; ``#pragma optimize(""[optimization-list]"", on | off)``. At the moment, Clang only; supports an empty optimization list, whereas MSVC supports the arguments, ``s``,; ``g``, ``t``, and ``y``. Currently, the implementation of ``pragma optimize`` behaves; the same as ``#pragma clang optimize``. All functions; between ``off`` and ``on`` will be decorated with the ``optnone`` attribute. .. code-block:: c++. #pragma optimize("""", off); // This function will be decorated with optnone.; void f1() {}. #pragma optimize("""", on); // This function will be optimized with whatever was specified on; // the commandline.; void f2() {}. // This will warn with Clang's current implementation.; #pragma optimize(""g"", on); void f3() {}. For MSVC, an empty optimization list and ``off`` parameter will turn off; all optimizations, ``s``, ``g``, ``t``, and ``y``. An empty optimization and; ``on`` parameter will reset the optimizations to the ones specified on the; commandline. .. list-table:: Parameters (unsupported b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:161155,Performance,optimiz,optimization,161155,"state of the pragma at the point of an; instantiation is not necessarily relevant. Consider the following example:. .. code-block:: c++. template<typename T> T twice(T t) {; return 2 * t;; }. #pragma clang optimize off; template<typename T> T thrice(T t) {; return 3 * t;; }. int container(int a, int b) {; return twice(a) + thrice(b);; }; #pragma clang optimize on. In this example, the definition of the template function ``twice`` is outside; the pragma region, whereas the definition of ``thrice`` is inside the region.; The ``container`` function is also in the region and will not be optimized, but; it causes the instantiation of ``twice`` and ``thrice`` with an ``int`` type; of; these two instantiations, ``twice`` will be optimized (because its definition; was outside the region) and ``thrice`` will not be optimized. Clang also implements MSVC's range-based pragma,; ``#pragma optimize(""[optimization-list]"", on | off)``. At the moment, Clang only; supports an empty optimization list, whereas MSVC supports the arguments, ``s``,; ``g``, ``t``, and ``y``. Currently, the implementation of ``pragma optimize`` behaves; the same as ``#pragma clang optimize``. All functions; between ``off`` and ``on`` will be decorated with the ``optnone`` attribute. .. code-block:: c++. #pragma optimize("""", off); // This function will be decorated with optnone.; void f1() {}. #pragma optimize("""", on); // This function will be optimized with whatever was specified on; // the commandline.; void f2() {}. // This will warn with Clang's current implementation.; #pragma optimize(""g"", on); void f3() {}. For MSVC, an empty optimization list and ``off`` parameter will turn off; all optimizations, ``s``, ``g``, ``t``, and ``y``. An empty optimization and; ``on`` parameter will reset the optimizations to the ones specified on the; commandline. .. list-table:: Parameters (unsupported by Clang). * - Parameter; - Type of optimization; * - g; - Deprecated; * - s or t; - Short or fast sequences of machine ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:161286,Performance,optimiz,optimize,161286," code-block:: c++. template<typename T> T twice(T t) {; return 2 * t;; }. #pragma clang optimize off; template<typename T> T thrice(T t) {; return 3 * t;; }. int container(int a, int b) {; return twice(a) + thrice(b);; }; #pragma clang optimize on. In this example, the definition of the template function ``twice`` is outside; the pragma region, whereas the definition of ``thrice`` is inside the region.; The ``container`` function is also in the region and will not be optimized, but; it causes the instantiation of ``twice`` and ``thrice`` with an ``int`` type; of; these two instantiations, ``twice`` will be optimized (because its definition; was outside the region) and ``thrice`` will not be optimized. Clang also implements MSVC's range-based pragma,; ``#pragma optimize(""[optimization-list]"", on | off)``. At the moment, Clang only; supports an empty optimization list, whereas MSVC supports the arguments, ``s``,; ``g``, ``t``, and ``y``. Currently, the implementation of ``pragma optimize`` behaves; the same as ``#pragma clang optimize``. All functions; between ``off`` and ``on`` will be decorated with the ``optnone`` attribute. .. code-block:: c++. #pragma optimize("""", off); // This function will be decorated with optnone.; void f1() {}. #pragma optimize("""", on); // This function will be optimized with whatever was specified on; // the commandline.; void f2() {}. // This will warn with Clang's current implementation.; #pragma optimize(""g"", on); void f3() {}. For MSVC, an empty optimization list and ``off`` parameter will turn off; all optimizations, ``s``, ``g``, ``t``, and ``y``. An empty optimization and; ``on`` parameter will reset the optimizations to the ones specified on the; commandline. .. list-table:: Parameters (unsupported by Clang). * - Parameter; - Type of optimization; * - g; - Deprecated; * - s or t; - Short or fast sequences of machine code; * - y; - Enable frame pointers. Extensions for loop hint optimizations; ======================================. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:161334,Performance,optimiz,optimize,161334," code-block:: c++. template<typename T> T twice(T t) {; return 2 * t;; }. #pragma clang optimize off; template<typename T> T thrice(T t) {; return 3 * t;; }. int container(int a, int b) {; return twice(a) + thrice(b);; }; #pragma clang optimize on. In this example, the definition of the template function ``twice`` is outside; the pragma region, whereas the definition of ``thrice`` is inside the region.; The ``container`` function is also in the region and will not be optimized, but; it causes the instantiation of ``twice`` and ``thrice`` with an ``int`` type; of; these two instantiations, ``twice`` will be optimized (because its definition; was outside the region) and ``thrice`` will not be optimized. Clang also implements MSVC's range-based pragma,; ``#pragma optimize(""[optimization-list]"", on | off)``. At the moment, Clang only; supports an empty optimization list, whereas MSVC supports the arguments, ``s``,; ``g``, ``t``, and ``y``. Currently, the implementation of ``pragma optimize`` behaves; the same as ``#pragma clang optimize``. All functions; between ``off`` and ``on`` will be decorated with the ``optnone`` attribute. .. code-block:: c++. #pragma optimize("""", off); // This function will be decorated with optnone.; void f1() {}. #pragma optimize("""", on); // This function will be optimized with whatever was specified on; // the commandline.; void f2() {}. // This will warn with Clang's current implementation.; #pragma optimize(""g"", on); void f3() {}. For MSVC, an empty optimization list and ``off`` parameter will turn off; all optimizations, ``s``, ``g``, ``t``, and ``y``. An empty optimization and; ``on`` parameter will reset the optimizations to the ones specified on the; commandline. .. list-table:: Parameters (unsupported by Clang). * - Parameter; - Type of optimization; * - g; - Deprecated; * - s or t; - Short or fast sequences of machine code; * - y; - Enable frame pointers. Extensions for loop hint optimizations; ======================================. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:161467,Performance,optimiz,optimize,161467,"a) + thrice(b);; }; #pragma clang optimize on. In this example, the definition of the template function ``twice`` is outside; the pragma region, whereas the definition of ``thrice`` is inside the region.; The ``container`` function is also in the region and will not be optimized, but; it causes the instantiation of ``twice`` and ``thrice`` with an ``int`` type; of; these two instantiations, ``twice`` will be optimized (because its definition; was outside the region) and ``thrice`` will not be optimized. Clang also implements MSVC's range-based pragma,; ``#pragma optimize(""[optimization-list]"", on | off)``. At the moment, Clang only; supports an empty optimization list, whereas MSVC supports the arguments, ``s``,; ``g``, ``t``, and ``y``. Currently, the implementation of ``pragma optimize`` behaves; the same as ``#pragma clang optimize``. All functions; between ``off`` and ``on`` will be decorated with the ``optnone`` attribute. .. code-block:: c++. #pragma optimize("""", off); // This function will be decorated with optnone.; void f1() {}. #pragma optimize("""", on); // This function will be optimized with whatever was specified on; // the commandline.; void f2() {}. // This will warn with Clang's current implementation.; #pragma optimize(""g"", on); void f3() {}. For MSVC, an empty optimization list and ``off`` parameter will turn off; all optimizations, ``s``, ``g``, ``t``, and ``y``. An empty optimization and; ``on`` parameter will reset the optimizations to the ones specified on the; commandline. .. list-table:: Parameters (unsupported by Clang). * - Parameter; - Type of optimization; * - g; - Deprecated; * - s or t; - Short or fast sequences of machine code; * - y; - Enable frame pointers. Extensions for loop hint optimizations; ======================================. The ``#pragma clang loop`` directive is used to specify hints for optimizing the; subsequent for, while, do-while, or c++11 range-based for loop. The directive; provides options for vectorization, inter",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:161558,Performance,optimiz,optimize,161558,"ce`` is outside; the pragma region, whereas the definition of ``thrice`` is inside the region.; The ``container`` function is also in the region and will not be optimized, but; it causes the instantiation of ``twice`` and ``thrice`` with an ``int`` type; of; these two instantiations, ``twice`` will be optimized (because its definition; was outside the region) and ``thrice`` will not be optimized. Clang also implements MSVC's range-based pragma,; ``#pragma optimize(""[optimization-list]"", on | off)``. At the moment, Clang only; supports an empty optimization list, whereas MSVC supports the arguments, ``s``,; ``g``, ``t``, and ``y``. Currently, the implementation of ``pragma optimize`` behaves; the same as ``#pragma clang optimize``. All functions; between ``off`` and ``on`` will be decorated with the ``optnone`` attribute. .. code-block:: c++. #pragma optimize("""", off); // This function will be decorated with optnone.; void f1() {}. #pragma optimize("""", on); // This function will be optimized with whatever was specified on; // the commandline.; void f2() {}. // This will warn with Clang's current implementation.; #pragma optimize(""g"", on); void f3() {}. For MSVC, an empty optimization list and ``off`` parameter will turn off; all optimizations, ``s``, ``g``, ``t``, and ``y``. An empty optimization and; ``on`` parameter will reset the optimizations to the ones specified on the; commandline. .. list-table:: Parameters (unsupported by Clang). * - Parameter; - Type of optimization; * - g; - Deprecated; * - s or t; - Short or fast sequences of machine code; * - y; - Enable frame pointers. Extensions for loop hint optimizations; ======================================. The ``#pragma clang loop`` directive is used to specify hints for optimizing the; subsequent for, while, do-while, or c++11 range-based for loop. The directive; provides options for vectorization, interleaving, predication, unrolling and; distribution. Loop hints can be specified before any loop and will be ign",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:161601,Performance,optimiz,optimized,161601,"ce`` is outside; the pragma region, whereas the definition of ``thrice`` is inside the region.; The ``container`` function is also in the region and will not be optimized, but; it causes the instantiation of ``twice`` and ``thrice`` with an ``int`` type; of; these two instantiations, ``twice`` will be optimized (because its definition; was outside the region) and ``thrice`` will not be optimized. Clang also implements MSVC's range-based pragma,; ``#pragma optimize(""[optimization-list]"", on | off)``. At the moment, Clang only; supports an empty optimization list, whereas MSVC supports the arguments, ``s``,; ``g``, ``t``, and ``y``. Currently, the implementation of ``pragma optimize`` behaves; the same as ``#pragma clang optimize``. All functions; between ``off`` and ``on`` will be decorated with the ``optnone`` attribute. .. code-block:: c++. #pragma optimize("""", off); // This function will be decorated with optnone.; void f1() {}. #pragma optimize("""", on); // This function will be optimized with whatever was specified on; // the commandline.; void f2() {}. // This will warn with Clang's current implementation.; #pragma optimize(""g"", on); void f3() {}. For MSVC, an empty optimization list and ``off`` parameter will turn off; all optimizations, ``s``, ``g``, ``t``, and ``y``. An empty optimization and; ``on`` parameter will reset the optimizations to the ones specified on the; commandline. .. list-table:: Parameters (unsupported by Clang). * - Parameter; - Type of optimization; * - g; - Deprecated; * - s or t; - Short or fast sequences of machine code; * - y; - Enable frame pointers. Extensions for loop hint optimizations; ======================================. The ``#pragma clang loop`` directive is used to specify hints for optimizing the; subsequent for, while, do-while, or c++11 range-based for loop. The directive; provides options for vectorization, interleaving, predication, unrolling and; distribution. Loop hints can be specified before any loop and will be ign",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:161742,Performance,optimiz,optimize,161742," will not be optimized, but; it causes the instantiation of ``twice`` and ``thrice`` with an ``int`` type; of; these two instantiations, ``twice`` will be optimized (because its definition; was outside the region) and ``thrice`` will not be optimized. Clang also implements MSVC's range-based pragma,; ``#pragma optimize(""[optimization-list]"", on | off)``. At the moment, Clang only; supports an empty optimization list, whereas MSVC supports the arguments, ``s``,; ``g``, ``t``, and ``y``. Currently, the implementation of ``pragma optimize`` behaves; the same as ``#pragma clang optimize``. All functions; between ``off`` and ``on`` will be decorated with the ``optnone`` attribute. .. code-block:: c++. #pragma optimize("""", off); // This function will be decorated with optnone.; void f1() {}. #pragma optimize("""", on); // This function will be optimized with whatever was specified on; // the commandline.; void f2() {}. // This will warn with Clang's current implementation.; #pragma optimize(""g"", on); void f3() {}. For MSVC, an empty optimization list and ``off`` parameter will turn off; all optimizations, ``s``, ``g``, ``t``, and ``y``. An empty optimization and; ``on`` parameter will reset the optimizations to the ones specified on the; commandline. .. list-table:: Parameters (unsupported by Clang). * - Parameter; - Type of optimization; * - g; - Deprecated; * - s or t; - Short or fast sequences of machine code; * - y; - Enable frame pointers. Extensions for loop hint optimizations; ======================================. The ``#pragma clang loop`` directive is used to specify hints for optimizing the; subsequent for, while, do-while, or c++11 range-based for loop. The directive; provides options for vectorization, interleaving, predication, unrolling and; distribution. Loop hints can be specified before any loop and will be ignored if; the optimization is not safe to apply. There are loop hints that control transformations (e.g. vectorization, loop; unrolling) and there a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:161794,Performance,optimiz,optimization,161794,"` with an ``int`` type; of; these two instantiations, ``twice`` will be optimized (because its definition; was outside the region) and ``thrice`` will not be optimized. Clang also implements MSVC's range-based pragma,; ``#pragma optimize(""[optimization-list]"", on | off)``. At the moment, Clang only; supports an empty optimization list, whereas MSVC supports the arguments, ``s``,; ``g``, ``t``, and ``y``. Currently, the implementation of ``pragma optimize`` behaves; the same as ``#pragma clang optimize``. All functions; between ``off`` and ``on`` will be decorated with the ``optnone`` attribute. .. code-block:: c++. #pragma optimize("""", off); // This function will be decorated with optnone.; void f1() {}. #pragma optimize("""", on); // This function will be optimized with whatever was specified on; // the commandline.; void f2() {}. // This will warn with Clang's current implementation.; #pragma optimize(""g"", on); void f3() {}. For MSVC, an empty optimization list and ``off`` parameter will turn off; all optimizations, ``s``, ``g``, ``t``, and ``y``. An empty optimization and; ``on`` parameter will reset the optimizations to the ones specified on the; commandline. .. list-table:: Parameters (unsupported by Clang). * - Parameter; - Type of optimization; * - g; - Deprecated; * - s or t; - Short or fast sequences of machine code; * - y; - Enable frame pointers. Extensions for loop hint optimizations; ======================================. The ``#pragma clang loop`` directive is used to specify hints for optimizing the; subsequent for, while, do-while, or c++11 range-based for loop. The directive; provides options for vectorization, interleaving, predication, unrolling and; distribution. Loop hints can be specified before any loop and will be ignored if; the optimization is not safe to apply. There are loop hints that control transformations (e.g. vectorization, loop; unrolling) and there are loop hints that set transformation options (e.g.; ``vectorize_width``, ``unroll_c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:161853,Performance,optimiz,optimizations,161853,"` with an ``int`` type; of; these two instantiations, ``twice`` will be optimized (because its definition; was outside the region) and ``thrice`` will not be optimized. Clang also implements MSVC's range-based pragma,; ``#pragma optimize(""[optimization-list]"", on | off)``. At the moment, Clang only; supports an empty optimization list, whereas MSVC supports the arguments, ``s``,; ``g``, ``t``, and ``y``. Currently, the implementation of ``pragma optimize`` behaves; the same as ``#pragma clang optimize``. All functions; between ``off`` and ``on`` will be decorated with the ``optnone`` attribute. .. code-block:: c++. #pragma optimize("""", off); // This function will be decorated with optnone.; void f1() {}. #pragma optimize("""", on); // This function will be optimized with whatever was specified on; // the commandline.; void f2() {}. // This will warn with Clang's current implementation.; #pragma optimize(""g"", on); void f3() {}. For MSVC, an empty optimization list and ``off`` parameter will turn off; all optimizations, ``s``, ``g``, ``t``, and ``y``. An empty optimization and; ``on`` parameter will reset the optimizations to the ones specified on the; commandline. .. list-table:: Parameters (unsupported by Clang). * - Parameter; - Type of optimization; * - g; - Deprecated; * - s or t; - Short or fast sequences of machine code; * - y; - Enable frame pointers. Extensions for loop hint optimizations; ======================================. The ``#pragma clang loop`` directive is used to specify hints for optimizing the; subsequent for, while, do-while, or c++11 range-based for loop. The directive; provides options for vectorization, interleaving, predication, unrolling and; distribution. Loop hints can be specified before any loop and will be ignored if; the optimization is not safe to apply. There are loop hints that control transformations (e.g. vectorization, loop; unrolling) and there are loop hints that set transformation options (e.g.; ``vectorize_width``, ``unroll_c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:161909,Performance,optimiz,optimization,161909,"e region) and ``thrice`` will not be optimized. Clang also implements MSVC's range-based pragma,; ``#pragma optimize(""[optimization-list]"", on | off)``. At the moment, Clang only; supports an empty optimization list, whereas MSVC supports the arguments, ``s``,; ``g``, ``t``, and ``y``. Currently, the implementation of ``pragma optimize`` behaves; the same as ``#pragma clang optimize``. All functions; between ``off`` and ``on`` will be decorated with the ``optnone`` attribute. .. code-block:: c++. #pragma optimize("""", off); // This function will be decorated with optnone.; void f1() {}. #pragma optimize("""", on); // This function will be optimized with whatever was specified on; // the commandline.; void f2() {}. // This will warn with Clang's current implementation.; #pragma optimize(""g"", on); void f3() {}. For MSVC, an empty optimization list and ``off`` parameter will turn off; all optimizations, ``s``, ``g``, ``t``, and ``y``. An empty optimization and; ``on`` parameter will reset the optimizations to the ones specified on the; commandline. .. list-table:: Parameters (unsupported by Clang). * - Parameter; - Type of optimization; * - g; - Deprecated; * - s or t; - Short or fast sequences of machine code; * - y; - Enable frame pointers. Extensions for loop hint optimizations; ======================================. The ``#pragma clang loop`` directive is used to specify hints for optimizing the; subsequent for, while, do-while, or c++11 range-based for loop. The directive; provides options for vectorization, interleaving, predication, unrolling and; distribution. Loop hints can be specified before any loop and will be ignored if; the optimization is not safe to apply. There are loop hints that control transformations (e.g. vectorization, loop; unrolling) and there are loop hints that set transformation options (e.g.; ``vectorize_width``, ``unroll_count``). Pragmas setting transformation options; imply the transformation is enabled, as if it was enabled via the corre",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:161959,Performance,optimiz,optimizations,161959,"e region) and ``thrice`` will not be optimized. Clang also implements MSVC's range-based pragma,; ``#pragma optimize(""[optimization-list]"", on | off)``. At the moment, Clang only; supports an empty optimization list, whereas MSVC supports the arguments, ``s``,; ``g``, ``t``, and ``y``. Currently, the implementation of ``pragma optimize`` behaves; the same as ``#pragma clang optimize``. All functions; between ``off`` and ``on`` will be decorated with the ``optnone`` attribute. .. code-block:: c++. #pragma optimize("""", off); // This function will be decorated with optnone.; void f1() {}. #pragma optimize("""", on); // This function will be optimized with whatever was specified on; // the commandline.; void f2() {}. // This will warn with Clang's current implementation.; #pragma optimize(""g"", on); void f3() {}. For MSVC, an empty optimization list and ``off`` parameter will turn off; all optimizations, ``s``, ``g``, ``t``, and ``y``. An empty optimization and; ``on`` parameter will reset the optimizations to the ones specified on the; commandline. .. list-table:: Parameters (unsupported by Clang). * - Parameter; - Type of optimization; * - g; - Deprecated; * - s or t; - Short or fast sequences of machine code; * - y; - Enable frame pointers. Extensions for loop hint optimizations; ======================================. The ``#pragma clang loop`` directive is used to specify hints for optimizing the; subsequent for, while, do-while, or c++11 range-based for loop. The directive; provides options for vectorization, interleaving, predication, unrolling and; distribution. Loop hints can be specified before any loop and will be ignored if; the optimization is not safe to apply. There are loop hints that control transformations (e.g. vectorization, loop; unrolling) and there are loop hints that set transformation options (e.g.; ``vectorize_width``, ``unroll_count``). Pragmas setting transformation options; imply the transformation is enabled, as if it was enabled via the corre",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:162092,Performance,optimiz,optimization,162092,"pports an empty optimization list, whereas MSVC supports the arguments, ``s``,; ``g``, ``t``, and ``y``. Currently, the implementation of ``pragma optimize`` behaves; the same as ``#pragma clang optimize``. All functions; between ``off`` and ``on`` will be decorated with the ``optnone`` attribute. .. code-block:: c++. #pragma optimize("""", off); // This function will be decorated with optnone.; void f1() {}. #pragma optimize("""", on); // This function will be optimized with whatever was specified on; // the commandline.; void f2() {}. // This will warn with Clang's current implementation.; #pragma optimize(""g"", on); void f3() {}. For MSVC, an empty optimization list and ``off`` parameter will turn off; all optimizations, ``s``, ``g``, ``t``, and ``y``. An empty optimization and; ``on`` parameter will reset the optimizations to the ones specified on the; commandline. .. list-table:: Parameters (unsupported by Clang). * - Parameter; - Type of optimization; * - g; - Deprecated; * - s or t; - Short or fast sequences of machine code; * - y; - Enable frame pointers. Extensions for loop hint optimizations; ======================================. The ``#pragma clang loop`` directive is used to specify hints for optimizing the; subsequent for, while, do-while, or c++11 range-based for loop. The directive; provides options for vectorization, interleaving, predication, unrolling and; distribution. Loop hints can be specified before any loop and will be ignored if; the optimization is not safe to apply. There are loop hints that control transformations (e.g. vectorization, loop; unrolling) and there are loop hints that set transformation options (e.g.; ``vectorize_width``, ``unroll_count``). Pragmas setting transformation options; imply the transformation is enabled, as if it was enabled via the corresponding; transformation pragma (e.g. ``vectorize(enable)``). If the transformation is; disabled (e.g. ``vectorize(disable)``), that takes precedence over; transformations option prag",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:162239,Performance,optimiz,optimizations,162239,", the implementation of ``pragma optimize`` behaves; the same as ``#pragma clang optimize``. All functions; between ``off`` and ``on`` will be decorated with the ``optnone`` attribute. .. code-block:: c++. #pragma optimize("""", off); // This function will be decorated with optnone.; void f1() {}. #pragma optimize("""", on); // This function will be optimized with whatever was specified on; // the commandline.; void f2() {}. // This will warn with Clang's current implementation.; #pragma optimize(""g"", on); void f3() {}. For MSVC, an empty optimization list and ``off`` parameter will turn off; all optimizations, ``s``, ``g``, ``t``, and ``y``. An empty optimization and; ``on`` parameter will reset the optimizations to the ones specified on the; commandline. .. list-table:: Parameters (unsupported by Clang). * - Parameter; - Type of optimization; * - g; - Deprecated; * - s or t; - Short or fast sequences of machine code; * - y; - Enable frame pointers. Extensions for loop hint optimizations; ======================================. The ``#pragma clang loop`` directive is used to specify hints for optimizing the; subsequent for, while, do-while, or c++11 range-based for loop. The directive; provides options for vectorization, interleaving, predication, unrolling and; distribution. Loop hints can be specified before any loop and will be ignored if; the optimization is not safe to apply. There are loop hints that control transformations (e.g. vectorization, loop; unrolling) and there are loop hints that set transformation options (e.g.; ``vectorize_width``, ``unroll_count``). Pragmas setting transformation options; imply the transformation is enabled, as if it was enabled via the corresponding; transformation pragma (e.g. ``vectorize(enable)``). If the transformation is; disabled (e.g. ``vectorize(disable)``), that takes precedence over; transformations option pragmas implying that transformation. Vectorization, Interleaving, and Predication; ---------------------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:162360,Performance,optimiz,optimizing,162360,"en ``off`` and ``on`` will be decorated with the ``optnone`` attribute. .. code-block:: c++. #pragma optimize("""", off); // This function will be decorated with optnone.; void f1() {}. #pragma optimize("""", on); // This function will be optimized with whatever was specified on; // the commandline.; void f2() {}. // This will warn with Clang's current implementation.; #pragma optimize(""g"", on); void f3() {}. For MSVC, an empty optimization list and ``off`` parameter will turn off; all optimizations, ``s``, ``g``, ``t``, and ``y``. An empty optimization and; ``on`` parameter will reset the optimizations to the ones specified on the; commandline. .. list-table:: Parameters (unsupported by Clang). * - Parameter; - Type of optimization; * - g; - Deprecated; * - s or t; - Short or fast sequences of machine code; * - y; - Enable frame pointers. Extensions for loop hint optimizations; ======================================. The ``#pragma clang loop`` directive is used to specify hints for optimizing the; subsequent for, while, do-while, or c++11 range-based for loop. The directive; provides options for vectorization, interleaving, predication, unrolling and; distribution. Loop hints can be specified before any loop and will be ignored if; the optimization is not safe to apply. There are loop hints that control transformations (e.g. vectorization, loop; unrolling) and there are loop hints that set transformation options (e.g.; ``vectorize_width``, ``unroll_count``). Pragmas setting transformation options; imply the transformation is enabled, as if it was enabled via the corresponding; transformation pragma (e.g. ``vectorize(enable)``). If the transformation is; disabled (e.g. ``vectorize(disable)``), that takes precedence over; transformations option pragmas implying that transformation. Vectorization, Interleaving, and Predication; --------------------------------------------. A vectorized loop performs multiple iterations of the original loop; in parallel using vector instru",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:162619,Performance,optimiz,optimization,162619,"e optimized with whatever was specified on; // the commandline.; void f2() {}. // This will warn with Clang's current implementation.; #pragma optimize(""g"", on); void f3() {}. For MSVC, an empty optimization list and ``off`` parameter will turn off; all optimizations, ``s``, ``g``, ``t``, and ``y``. An empty optimization and; ``on`` parameter will reset the optimizations to the ones specified on the; commandline. .. list-table:: Parameters (unsupported by Clang). * - Parameter; - Type of optimization; * - g; - Deprecated; * - s or t; - Short or fast sequences of machine code; * - y; - Enable frame pointers. Extensions for loop hint optimizations; ======================================. The ``#pragma clang loop`` directive is used to specify hints for optimizing the; subsequent for, while, do-while, or c++11 range-based for loop. The directive; provides options for vectorization, interleaving, predication, unrolling and; distribution. Loop hints can be specified before any loop and will be ignored if; the optimization is not safe to apply. There are loop hints that control transformations (e.g. vectorization, loop; unrolling) and there are loop hints that set transformation options (e.g.; ``vectorize_width``, ``unroll_count``). Pragmas setting transformation options; imply the transformation is enabled, as if it was enabled via the corresponding; transformation pragma (e.g. ``vectorize(enable)``). If the transformation is; disabled (e.g. ``vectorize(disable)``), that takes precedence over; transformations option pragmas implying that transformation. Vectorization, Interleaving, and Predication; --------------------------------------------. A vectorized loop performs multiple iterations of the original loop; in parallel using vector instructions. The instruction set of the target; processor determines which vector instructions are available and their vector; widths. This restricts the types of loops that can be vectorized. The vectorizer; automatically determines if th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:163284,Performance,perform,performs,163284,"` directive is used to specify hints for optimizing the; subsequent for, while, do-while, or c++11 range-based for loop. The directive; provides options for vectorization, interleaving, predication, unrolling and; distribution. Loop hints can be specified before any loop and will be ignored if; the optimization is not safe to apply. There are loop hints that control transformations (e.g. vectorization, loop; unrolling) and there are loop hints that set transformation options (e.g.; ``vectorize_width``, ``unroll_count``). Pragmas setting transformation options; imply the transformation is enabled, as if it was enabled via the corresponding; transformation pragma (e.g. ``vectorize(enable)``). If the transformation is; disabled (e.g. ``vectorize(disable)``), that takes precedence over; transformations option pragmas implying that transformation. Vectorization, Interleaving, and Predication; --------------------------------------------. A vectorized loop performs multiple iterations of the original loop; in parallel using vector instructions. The instruction set of the target; processor determines which vector instructions are available and their vector; widths. This restricts the types of loops that can be vectorized. The vectorizer; automatically determines if the loop is safe and profitable to vectorize. A; vector instruction cost model is used to select the vector width. Interleaving multiple loop iterations allows modern processors to further; improve instruction-level parallelism (ILP) using advanced hardware features,; such as multiple execution units and out-of-order execution. The vectorizer uses; a cost model that depends on the register pressure and generated code size to; select the interleaving count. Vectorization is enabled by ``vectorize(enable)`` and interleaving is enabled; by ``interleave(enable)``. This is useful when compiling with ``-Os`` to; manually enable vectorization or interleaving. .. code-block:: c++. #pragma clang loop vectorize(enable); #",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:164445,Performance,scalab,scalable,164445,"ir vector; widths. This restricts the types of loops that can be vectorized. The vectorizer; automatically determines if the loop is safe and profitable to vectorize. A; vector instruction cost model is used to select the vector width. Interleaving multiple loop iterations allows modern processors to further; improve instruction-level parallelism (ILP) using advanced hardware features,; such as multiple execution units and out-of-order execution. The vectorizer uses; a cost model that depends on the register pressure and generated code size to; select the interleaving count. Vectorization is enabled by ``vectorize(enable)`` and interleaving is enabled; by ``interleave(enable)``. This is useful when compiling with ``-Os`` to; manually enable vectorization or interleaving. .. code-block:: c++. #pragma clang loop vectorize(enable); #pragma clang loop interleave(enable); for(...) {; ...; }. The vector width is specified by; ``vectorize_width(_value_[, fixed|scalable])``, where _value_ is a positive; integer and the type of vectorization can be specified with an optional; second parameter. The default for the second parameter is 'fixed' and; refers to fixed width vectorization, whereas 'scalable' indicates the; compiler should use scalable vectors instead. Another use of vectorize_width; is ``vectorize_width(fixed|scalable)`` where the user can hint at the type; of vectorization to use without specifying the exact width. In both variants; of the pragma the vectorizer may decide to fall back on fixed width; vectorization if the target does not support scalable vectors. The interleave count is specified by ``interleave_count(_value_)``, where; _value_ is a positive integer. This is useful for specifying the optimal; width/count of the set of target architectures supported by your application. .. code-block:: c++. #pragma clang loop vectorize_width(2); #pragma clang loop interleave_count(2); for(...) {; ...; }. Specifying a width/count of 1 disables the optimization, and is",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:164678,Performance,scalab,scalable,164678,"on cost model is used to select the vector width. Interleaving multiple loop iterations allows modern processors to further; improve instruction-level parallelism (ILP) using advanced hardware features,; such as multiple execution units and out-of-order execution. The vectorizer uses; a cost model that depends on the register pressure and generated code size to; select the interleaving count. Vectorization is enabled by ``vectorize(enable)`` and interleaving is enabled; by ``interleave(enable)``. This is useful when compiling with ``-Os`` to; manually enable vectorization or interleaving. .. code-block:: c++. #pragma clang loop vectorize(enable); #pragma clang loop interleave(enable); for(...) {; ...; }. The vector width is specified by; ``vectorize_width(_value_[, fixed|scalable])``, where _value_ is a positive; integer and the type of vectorization can be specified with an optional; second parameter. The default for the second parameter is 'fixed' and; refers to fixed width vectorization, whereas 'scalable' indicates the; compiler should use scalable vectors instead. Another use of vectorize_width; is ``vectorize_width(fixed|scalable)`` where the user can hint at the type; of vectorization to use without specifying the exact width. In both variants; of the pragma the vectorizer may decide to fall back on fixed width; vectorization if the target does not support scalable vectors. The interleave count is specified by ``interleave_count(_value_)``, where; _value_ is a positive integer. This is useful for specifying the optimal; width/count of the set of target architectures supported by your application. .. code-block:: c++. #pragma clang loop vectorize_width(2); #pragma clang loop interleave_count(2); for(...) {; ...; }. Specifying a width/count of 1 disables the optimization, and is equivalent to; ``vectorize(disable)`` or ``interleave(disable)``. Vector predication is enabled by ``vectorize_predicate(enable)``, for example:. .. code-block:: c++. #pragma clang loop",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:164723,Performance,scalab,scalable,164723,"on cost model is used to select the vector width. Interleaving multiple loop iterations allows modern processors to further; improve instruction-level parallelism (ILP) using advanced hardware features,; such as multiple execution units and out-of-order execution. The vectorizer uses; a cost model that depends on the register pressure and generated code size to; select the interleaving count. Vectorization is enabled by ``vectorize(enable)`` and interleaving is enabled; by ``interleave(enable)``. This is useful when compiling with ``-Os`` to; manually enable vectorization or interleaving. .. code-block:: c++. #pragma clang loop vectorize(enable); #pragma clang loop interleave(enable); for(...) {; ...; }. The vector width is specified by; ``vectorize_width(_value_[, fixed|scalable])``, where _value_ is a positive; integer and the type of vectorization can be specified with an optional; second parameter. The default for the second parameter is 'fixed' and; refers to fixed width vectorization, whereas 'scalable' indicates the; compiler should use scalable vectors instead. Another use of vectorize_width; is ``vectorize_width(fixed|scalable)`` where the user can hint at the type; of vectorization to use without specifying the exact width. In both variants; of the pragma the vectorizer may decide to fall back on fixed width; vectorization if the target does not support scalable vectors. The interleave count is specified by ``interleave_count(_value_)``, where; _value_ is a positive integer. This is useful for specifying the optimal; width/count of the set of target architectures supported by your application. .. code-block:: c++. #pragma clang loop vectorize_width(2); #pragma clang loop interleave_count(2); for(...) {; ...; }. Specifying a width/count of 1 disables the optimization, and is equivalent to; ``vectorize(disable)`` or ``interleave(disable)``. Vector predication is enabled by ``vectorize_predicate(enable)``, for example:. .. code-block:: c++. #pragma clang loop",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:164808,Performance,scalab,scalable,164808,"using advanced hardware features,; such as multiple execution units and out-of-order execution. The vectorizer uses; a cost model that depends on the register pressure and generated code size to; select the interleaving count. Vectorization is enabled by ``vectorize(enable)`` and interleaving is enabled; by ``interleave(enable)``. This is useful when compiling with ``-Os`` to; manually enable vectorization or interleaving. .. code-block:: c++. #pragma clang loop vectorize(enable); #pragma clang loop interleave(enable); for(...) {; ...; }. The vector width is specified by; ``vectorize_width(_value_[, fixed|scalable])``, where _value_ is a positive; integer and the type of vectorization can be specified with an optional; second parameter. The default for the second parameter is 'fixed' and; refers to fixed width vectorization, whereas 'scalable' indicates the; compiler should use scalable vectors instead. Another use of vectorize_width; is ``vectorize_width(fixed|scalable)`` where the user can hint at the type; of vectorization to use without specifying the exact width. In both variants; of the pragma the vectorizer may decide to fall back on fixed width; vectorization if the target does not support scalable vectors. The interleave count is specified by ``interleave_count(_value_)``, where; _value_ is a positive integer. This is useful for specifying the optimal; width/count of the set of target architectures supported by your application. .. code-block:: c++. #pragma clang loop vectorize_width(2); #pragma clang loop interleave_count(2); for(...) {; ...; }. Specifying a width/count of 1 disables the optimization, and is equivalent to; ``vectorize(disable)`` or ``interleave(disable)``. Vector predication is enabled by ``vectorize_predicate(enable)``, for example:. .. code-block:: c++. #pragma clang loop vectorize(enable); #pragma clang loop vectorize_predicate(enable); for(...) {; ...; }. This predicates (masks) all instructions in the loop, which allows the scalar; re",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:165049,Performance,scalab,scalable,165049,"pressure and generated code size to; select the interleaving count. Vectorization is enabled by ``vectorize(enable)`` and interleaving is enabled; by ``interleave(enable)``. This is useful when compiling with ``-Os`` to; manually enable vectorization or interleaving. .. code-block:: c++. #pragma clang loop vectorize(enable); #pragma clang loop interleave(enable); for(...) {; ...; }. The vector width is specified by; ``vectorize_width(_value_[, fixed|scalable])``, where _value_ is a positive; integer and the type of vectorization can be specified with an optional; second parameter. The default for the second parameter is 'fixed' and; refers to fixed width vectorization, whereas 'scalable' indicates the; compiler should use scalable vectors instead. Another use of vectorize_width; is ``vectorize_width(fixed|scalable)`` where the user can hint at the type; of vectorization to use without specifying the exact width. In both variants; of the pragma the vectorizer may decide to fall back on fixed width; vectorization if the target does not support scalable vectors. The interleave count is specified by ``interleave_count(_value_)``, where; _value_ is a positive integer. This is useful for specifying the optimal; width/count of the set of target architectures supported by your application. .. code-block:: c++. #pragma clang loop vectorize_width(2); #pragma clang loop interleave_count(2); for(...) {; ...; }. Specifying a width/count of 1 disables the optimization, and is equivalent to; ``vectorize(disable)`` or ``interleave(disable)``. Vector predication is enabled by ``vectorize_predicate(enable)``, for example:. .. code-block:: c++. #pragma clang loop vectorize(enable); #pragma clang loop vectorize_predicate(enable); for(...) {; ...; }. This predicates (masks) all instructions in the loop, which allows the scalar; remainder loop (the tail) to be folded into the main vectorized loop. This; might be more efficient when vector predication is efficiently supported by the; targ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:165457,Performance,optimiz,optimization,165457,"positive; integer and the type of vectorization can be specified with an optional; second parameter. The default for the second parameter is 'fixed' and; refers to fixed width vectorization, whereas 'scalable' indicates the; compiler should use scalable vectors instead. Another use of vectorize_width; is ``vectorize_width(fixed|scalable)`` where the user can hint at the type; of vectorization to use without specifying the exact width. In both variants; of the pragma the vectorizer may decide to fall back on fixed width; vectorization if the target does not support scalable vectors. The interleave count is specified by ``interleave_count(_value_)``, where; _value_ is a positive integer. This is useful for specifying the optimal; width/count of the set of target architectures supported by your application. .. code-block:: c++. #pragma clang loop vectorize_width(2); #pragma clang loop interleave_count(2); for(...) {; ...; }. Specifying a width/count of 1 disables the optimization, and is equivalent to; ``vectorize(disable)`` or ``interleave(disable)``. Vector predication is enabled by ``vectorize_predicate(enable)``, for example:. .. code-block:: c++. #pragma clang loop vectorize(enable); #pragma clang loop vectorize_predicate(enable); for(...) {; ...; }. This predicates (masks) all instructions in the loop, which allows the scalar; remainder loop (the tail) to be folded into the main vectorized loop. This; might be more efficient when vector predication is efficiently supported by the; target platform. Loop Unrolling; --------------. Unrolling a loop reduces the loop control overhead and exposes more; opportunities for ILP. Loops can be fully or partially unrolled. Full unrolling; eliminates the loop and replaces it with an enumerated sequence of loop; iterations. Full unrolling is only possible if the loop trip count is known at; compile time. Partial unrolling replicates the loop body within the loop and; reduces the trip count. If ``unroll(enable)`` is specified th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:168216,Performance,optimiz,optimization,168216,"unt can be specified explicitly with ``unroll_count(_value_)`` where; _value_ is a positive integer. If this value is greater than the trip count the; loop will be fully unrolled. Otherwise the loop is partially unrolled subject; to the same code size limit as with ``unroll(enable)``. .. code-block:: c++. #pragma clang loop unroll_count(8); for(...) {; ...; }. Unrolling of a loop can be prevented by specifying ``unroll(disable)``. Loop unroll parameters can be controlled by options; `-mllvm -unroll-count=n` and `-mllvm -pragma-unroll-threshold=n`. Loop Distribution; -----------------. Loop Distribution allows splitting a loop into multiple loops. This is; beneficial for example when the entire loop cannot be vectorized but some of the; resulting loops can. If ``distribute(enable))`` is specified and the loop has memory dependencies; that inhibit vectorization, the compiler will attempt to isolate the offending; operations into a new loop. This optimization is not enabled by default, only; loops marked with the pragma are considered. .. code-block:: c++. #pragma clang loop distribute(enable); for (i = 0; i < N; ++i) {; S1: A[i + 1] = A[i] + B[i];; S2: C[i] = D[i] * E[i];; }. This loop will be split into two loops between statements S1 and S2. The; second loop containing S2 will be vectorized. Loop Distribution is currently not enabled by default in the optimizer because; it can hurt performance in some cases. For example, instruction-level; parallelism could be reduced by sequentializing the execution of the; statements S1 and S2 above. If Loop Distribution is turned on globally with; ``-mllvm -enable-loop-distribution``, specifying ``distribute(disable)`` can; be used the disable it on a per-loop basis. Additional Information; ----------------------. For convenience multiple loop hints can be specified on a single line. .. code-block:: c++. #pragma clang loop vectorize_width(4) interleave_count(8); for(...) {; ...; }. If an optimization cannot be applied any hints t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:168632,Performance,optimiz,optimizer,168632,"g of a loop can be prevented by specifying ``unroll(disable)``. Loop unroll parameters can be controlled by options; `-mllvm -unroll-count=n` and `-mllvm -pragma-unroll-threshold=n`. Loop Distribution; -----------------. Loop Distribution allows splitting a loop into multiple loops. This is; beneficial for example when the entire loop cannot be vectorized but some of the; resulting loops can. If ``distribute(enable))`` is specified and the loop has memory dependencies; that inhibit vectorization, the compiler will attempt to isolate the offending; operations into a new loop. This optimization is not enabled by default, only; loops marked with the pragma are considered. .. code-block:: c++. #pragma clang loop distribute(enable); for (i = 0; i < N; ++i) {; S1: A[i + 1] = A[i] + B[i];; S2: C[i] = D[i] * E[i];; }. This loop will be split into two loops between statements S1 and S2. The; second loop containing S2 will be vectorized. Loop Distribution is currently not enabled by default in the optimizer because; it can hurt performance in some cases. For example, instruction-level; parallelism could be reduced by sequentializing the execution of the; statements S1 and S2 above. If Loop Distribution is turned on globally with; ``-mllvm -enable-loop-distribution``, specifying ``distribute(disable)`` can; be used the disable it on a per-loop basis. Additional Information; ----------------------. For convenience multiple loop hints can be specified on a single line. .. code-block:: c++. #pragma clang loop vectorize_width(4) interleave_count(8); for(...) {; ...; }. If an optimization cannot be applied any hints that apply to it will be ignored.; For example, the hint ``vectorize_width(4)`` is ignored if the loop is not; proven safe to vectorize. To identify and diagnose optimization issues use; `-Rpass`, `-Rpass-missed`, and `-Rpass-analysis` command line options. See the; user guide for details. Extensions to specify floating-point flags; ======================================",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:168663,Performance,perform,performance,168663,"g of a loop can be prevented by specifying ``unroll(disable)``. Loop unroll parameters can be controlled by options; `-mllvm -unroll-count=n` and `-mllvm -pragma-unroll-threshold=n`. Loop Distribution; -----------------. Loop Distribution allows splitting a loop into multiple loops. This is; beneficial for example when the entire loop cannot be vectorized but some of the; resulting loops can. If ``distribute(enable))`` is specified and the loop has memory dependencies; that inhibit vectorization, the compiler will attempt to isolate the offending; operations into a new loop. This optimization is not enabled by default, only; loops marked with the pragma are considered. .. code-block:: c++. #pragma clang loop distribute(enable); for (i = 0; i < N; ++i) {; S1: A[i + 1] = A[i] + B[i];; S2: C[i] = D[i] * E[i];; }. This loop will be split into two loops between statements S1 and S2. The; second loop containing S2 will be vectorized. Loop Distribution is currently not enabled by default in the optimizer because; it can hurt performance in some cases. For example, instruction-level; parallelism could be reduced by sequentializing the execution of the; statements S1 and S2 above. If Loop Distribution is turned on globally with; ``-mllvm -enable-loop-distribution``, specifying ``distribute(disable)`` can; be used the disable it on a per-loop basis. Additional Information; ----------------------. For convenience multiple loop hints can be specified on a single line. .. code-block:: c++. #pragma clang loop vectorize_width(4) interleave_count(8); for(...) {; ...; }. If an optimization cannot be applied any hints that apply to it will be ignored.; For example, the hint ``vectorize_width(4)`` is ignored if the loop is not; proven safe to vectorize. To identify and diagnose optimization issues use; `-Rpass`, `-Rpass-missed`, and `-Rpass-analysis` command line options. See the; user guide for details. Extensions to specify floating-point flags; ======================================",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:169216,Performance,optimiz,optimization,169216,"fault, only; loops marked with the pragma are considered. .. code-block:: c++. #pragma clang loop distribute(enable); for (i = 0; i < N; ++i) {; S1: A[i + 1] = A[i] + B[i];; S2: C[i] = D[i] * E[i];; }. This loop will be split into two loops between statements S1 and S2. The; second loop containing S2 will be vectorized. Loop Distribution is currently not enabled by default in the optimizer because; it can hurt performance in some cases. For example, instruction-level; parallelism could be reduced by sequentializing the execution of the; statements S1 and S2 above. If Loop Distribution is turned on globally with; ``-mllvm -enable-loop-distribution``, specifying ``distribute(disable)`` can; be used the disable it on a per-loop basis. Additional Information; ----------------------. For convenience multiple loop hints can be specified on a single line. .. code-block:: c++. #pragma clang loop vectorize_width(4) interleave_count(8); for(...) {; ...; }. If an optimization cannot be applied any hints that apply to it will be ignored.; For example, the hint ``vectorize_width(4)`` is ignored if the loop is not; proven safe to vectorize. To identify and diagnose optimization issues use; `-Rpass`, `-Rpass-missed`, and `-Rpass-analysis` command line options. See the; user guide for details. Extensions to specify floating-point flags; ====================================================. The ``#pragma clang fp`` pragma allows floating-point options to be specified; for a section of the source code. This pragma can only appear at file scope or; at the start of a compound statement (excluding comments). When using within a; compound statement, the pragma is active within the scope of the compound; statement. Currently, the following settings can be controlled with this pragma:. ``#pragma clang fp reassociate`` allows control over the reassociation; of floating point expressions. When enabled, this pragma allows the expression; ``x + (y + z)`` to be reassociated as ``(x + y) + z``.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:169419,Performance,optimiz,optimization,169419,"is loop will be split into two loops between statements S1 and S2. The; second loop containing S2 will be vectorized. Loop Distribution is currently not enabled by default in the optimizer because; it can hurt performance in some cases. For example, instruction-level; parallelism could be reduced by sequentializing the execution of the; statements S1 and S2 above. If Loop Distribution is turned on globally with; ``-mllvm -enable-loop-distribution``, specifying ``distribute(disable)`` can; be used the disable it on a per-loop basis. Additional Information; ----------------------. For convenience multiple loop hints can be specified on a single line. .. code-block:: c++. #pragma clang loop vectorize_width(4) interleave_count(8); for(...) {; ...; }. If an optimization cannot be applied any hints that apply to it will be ignored.; For example, the hint ``vectorize_width(4)`` is ignored if the loop is not; proven safe to vectorize. To identify and diagnose optimization issues use; `-Rpass`, `-Rpass-missed`, and `-Rpass-analysis` command line options. See the; user guide for details. Extensions to specify floating-point flags; ====================================================. The ``#pragma clang fp`` pragma allows floating-point options to be specified; for a section of the source code. This pragma can only appear at file scope or; at the start of a compound statement (excluding comments). When using within a; compound statement, the pragma is active within the scope of the compound; statement. Currently, the following settings can be controlled with this pragma:. ``#pragma clang fp reassociate`` allows control over the reassociation; of floating point expressions. When enabled, this pragma allows the expression; ``x + (y + z)`` to be reassociated as ``(x + y) + z``.; Reassociation can also occur across multiple statements.; This pragma can be used to disable reassociation when it is otherwise; enabled for the translation unit with the ``-fassociative-math`` flag.; The",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:175918,Performance,optimiz,optimizations,175918,"ting-point; semantics and floating-point exception behavior to be specified; for a section of the source code. This pragma can only appear at file or; namespace scope, within a language linkage specification or at the start of a; compound statement (excluding comments). When used within a compound statement,; the pragma is active within the scope of the compound statement. This pragma; is modeled after a Microsoft pragma with the same spelling and syntax. For; pragmas specified at file or namespace scope, or within a language linkage; specification, a stack is supported so that the ``pragma float_control``; settings can be pushed or popped. When ``pragma float_control(precise, on)`` is enabled, the section of code; governed by the pragma uses precise floating point semantics, effectively; ``-ffast-math`` is disabled and ``-ffp-contract=on``; (fused multiply add) is enabled. This pragma enables ``-fmath-errno``. When ``pragma float_control(precise, off)`` is enabled, unsafe-floating point; optimizations are enabled in the section of code governed by the pragma.; Effectively ``-ffast-math`` is enabled and ``-ffp-contract=fast``. This pragma; disables ``-fmath-errno``. When ``pragma float_control(except, on)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-exception-behavior=strict`` is enabled,; when ``pragma float_control(except, off)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-exception-behavior=ignore`` is enabled. The full syntax this pragma supports is; ``float_control(except|precise, on|off [, push])`` and; ``float_control(push|pop)``.; The ``push`` and ``pop`` forms, including using ``push`` as the optional; third argument, can only occur at file scope. .. code-block:: c++. for(...) {; // This block will be compiled with -fno-fast-math and -ffp-contract=on; #pragma float_control(precise, on); a = b[i] * c[i] + e;; }. Specifying an attribute",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:196465,Performance,perform,performed,196465,"tin_isnormal``; * ``__builtin_nan``; * ``__builtin_nans``; * ``__builtin_parity``; * ``__builtin_parityl``; * ``__builtin_parityll``; * ``__builtin_popcount``; * ``__builtin_popcountl``; * ``__builtin_popcountll``; * ``__builtin_rotateleft8``; * ``__builtin_rotateleft16``; * ``__builtin_rotateleft32``; * ``__builtin_rotateleft64``; * ``__builtin_rotateright8``; * ``__builtin_rotateright16``; * ``__builtin_rotateright32``; * ``__builtin_rotateright64``. The following x86-specific intrinsics can be used in constant expressions:. * ``_bit_scan_forward``; * ``_bit_scan_reverse``; * ``__bsfd``; * ``__bsfq``; * ``__bsrd``; * ``__bsrq``; * ``__bswap``; * ``__bswapd``; * ``__bswap64``; * ``__bswapq``; * ``_castf32_u32``; * ``_castf64_u64``; * ``_castu32_f32``; * ``_castu64_f64``; * ``__lzcnt16``; * ``__lzcnt``; * ``__lzcnt64``; * ``_mm_popcnt_u32``; * ``_mm_popcnt_u64``; * ``_popcnt32``; * ``_popcnt64``; * ``__popcntd``; * ``__popcntq``; * ``__popcnt16``; * ``__popcnt``; * ``__popcnt64``; * ``__rolb``; * ``__rolw``; * ``__rold``; * ``__rolq``; * ``__rorb``; * ``__rorw``; * ``__rord``; * ``__rorq``; * ``_rotl``; * ``_rotr``; * ``_rotwl``; * ``_rotwr``; * ``_lrotl``; * ``_lrotr``. Debugging the Compiler; ======================. Clang supports a number of pragma directives that help debugging the compiler itself.; Syntax is the following: `#pragma clang __debug <command> <arguments>`.; Note, all of debugging pragmas are subject to change. `dump`; ------; Accepts either a single identifier or an expression. When a single identifier is passed,; the lookup results for the identifier are printed to `stderr`. When an expression is passed,; the AST for the expression is printed to `stderr`. The expression is an unevaluated operand,; so things like overload resolution and template instantiations are performed,; but the expression has no runtime effects.; Type- and value-dependent expressions are not supported yet. This facility is designed to aid with testing name lookup machinery.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:1505,Safety,abort,abort,1505,"nu.org/onlinedocs/gcc/C-Extensions.html>`_ for more information on; these extensions. .. _langext-feature_check:. Feature Checking Macros; =======================. Language extensions can be very useful, but only if you know you can depend on; them. In order to allow fine-grain features checks, we support three builtin; function-like macros. This allows you to directly test for a feature in your; code without having to resort to something like autoconf or fragile ""compiler; version checks"". ``__has_builtin``; -----------------. This function-like macro takes a single identifier argument that is the name of; a builtin function, a builtin pseudo-function (taking one or more type; arguments), or a builtin template.; It evaluates to 1 if the builtin is supported or 0 if not.; It can be used like this:. .. code-block:: c++. #ifndef __has_builtin // Optional of course.; #define __has_builtin(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_builtin(__builtin_trap); __builtin_trap();; #else; abort();; #endif; ... .. note::. Prior to Clang 10, ``__has_builtin`` could not be used to detect most builtin; pseudo-functions. ``__has_builtin`` should not be used to detect support for a builtin macro;; use ``#ifdef`` instead. ``__has_constexpr_builtin``; ---------------------------. This function-like macro takes a single identifier argument that is the name of; a builtin function, a builtin pseudo-function (taking one or more type; arguments), or a builtin template.; It evaluates to 1 if the builtin is supported and can be constant evaluated or; 0 if not. It can be used for writing conditionally constexpr code like this:. .. code-block:: c++. #ifndef __has_constexpr_builtin // Optional of course.; #define __has_constexpr_builtin(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_constexpr_builtin(__builtin_fmax); constexpr; #endif; double money_fee(double amount) {; return __builtin_fmax(amount * 0.03, 10.0);; }; ... For example, ``__has",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:1596,Safety,detect,detect,1596,"ure_check:. Feature Checking Macros; =======================. Language extensions can be very useful, but only if you know you can depend on; them. In order to allow fine-grain features checks, we support three builtin; function-like macros. This allows you to directly test for a feature in your; code without having to resort to something like autoconf or fragile ""compiler; version checks"". ``__has_builtin``; -----------------. This function-like macro takes a single identifier argument that is the name of; a builtin function, a builtin pseudo-function (taking one or more type; arguments), or a builtin template.; It evaluates to 1 if the builtin is supported or 0 if not.; It can be used like this:. .. code-block:: c++. #ifndef __has_builtin // Optional of course.; #define __has_builtin(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_builtin(__builtin_trap); __builtin_trap();; #else; abort();; #endif; ... .. note::. Prior to Clang 10, ``__has_builtin`` could not be used to detect most builtin; pseudo-functions. ``__has_builtin`` should not be used to detect support for a builtin macro;; use ``#ifdef`` instead. ``__has_constexpr_builtin``; ---------------------------. This function-like macro takes a single identifier argument that is the name of; a builtin function, a builtin pseudo-function (taking one or more type; arguments), or a builtin template.; It evaluates to 1 if the builtin is supported and can be constant evaluated or; 0 if not. It can be used for writing conditionally constexpr code like this:. .. code-block:: c++. #ifndef __has_constexpr_builtin // Optional of course.; #define __has_constexpr_builtin(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_constexpr_builtin(__builtin_fmax); constexpr; #endif; double money_fee(double amount) {; return __builtin_fmax(amount * 0.03, 10.0);; }; ... For example, ``__has_constexpr_builtin`` is used in libcxx's implementation of; the ``<cmath>`` header file to conditionall",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:1675,Safety,detect,detect,1675,"l, but only if you know you can depend on; them. In order to allow fine-grain features checks, we support three builtin; function-like macros. This allows you to directly test for a feature in your; code without having to resort to something like autoconf or fragile ""compiler; version checks"". ``__has_builtin``; -----------------. This function-like macro takes a single identifier argument that is the name of; a builtin function, a builtin pseudo-function (taking one or more type; arguments), or a builtin template.; It evaluates to 1 if the builtin is supported or 0 if not.; It can be used like this:. .. code-block:: c++. #ifndef __has_builtin // Optional of course.; #define __has_builtin(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_builtin(__builtin_trap); __builtin_trap();; #else; abort();; #endif; ... .. note::. Prior to Clang 10, ``__has_builtin`` could not be used to detect most builtin; pseudo-functions. ``__has_builtin`` should not be used to detect support for a builtin macro;; use ``#ifdef`` instead. ``__has_constexpr_builtin``; ---------------------------. This function-like macro takes a single identifier argument that is the name of; a builtin function, a builtin pseudo-function (taking one or more type; arguments), or a builtin template.; It evaluates to 1 if the builtin is supported and can be constant evaluated or; 0 if not. It can be used for writing conditionally constexpr code like this:. .. code-block:: c++. #ifndef __has_constexpr_builtin // Optional of course.; #define __has_constexpr_builtin(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_constexpr_builtin(__builtin_fmax); constexpr; #endif; double money_fee(double amount) {; return __builtin_fmax(amount * 0.03, 10.0);; }; ... For example, ``__has_constexpr_builtin`` is used in libcxx's implementation of; the ``<cmath>`` header file to conditionally make a function constexpr whenever; the constant evaluation of the corresponding builtin (for exa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:4746,Safety,avoid,avoid,4746,"ly be compiled with the -std=c++11 and -std=gnu++11; // options, because rvalue references are only standardized in C++11.; #endif. #if __has_extension(cxx_rvalue_references); // This code will be compiled with the -std=c++11, -std=gnu++11, -std=c++98; // and -std=gnu++98 options, because rvalue references are supported as a; // language extension in C++98.; #endif. .. _langext-has-feature-back-compat:. For backward compatibility, ``__has_feature`` can also be used to test; for support for non-standardized features, i.e. features not prefixed ``c_``,; ``cxx_`` or ``objc_``. Another use of ``__has_feature`` is to check for compiler features not related; to the language standard, such as e.g. :doc:`AddressSanitizer; <AddressSanitizer>`. If the ``-pedantic-errors`` option is given, ``__has_extension`` is equivalent; to ``__has_feature``. The feature tag is described along with the language feature below. The feature name or extension name can also be specified with a preceding and; following ``__`` (double underscore) to avoid interference from a macro with; the same name. For instance, ``__cxx_rvalue_references__`` can be used instead; of ``cxx_rvalue_references``. ``__has_cpp_attribute``; -----------------------. This function-like macro is available in C++20 by default, and is provided as an; extension in earlier language standards. It takes a single argument that is the; name of a double-square-bracket-style attribute. The argument can either be a; single identifier or a scoped identifier. If the attribute is supported, a; nonzero value is returned. If the attribute is a standards-based attribute, this; macro returns a nonzero value based on the year and month in which the attribute; was voted into the working draft. See `WG21 SD-6; <https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations>`_; for the list of values returned for standards-based attributes. If the attribute; is not supported by the current compilation target, this macro evalu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:6268,Safety,avoid,avoid,6268,"f the attribute is supported, a; nonzero value is returned. If the attribute is a standards-based attribute, this; macro returns a nonzero value based on the year and month in which the attribute; was voted into the working draft. See `WG21 SD-6; <https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations>`_; for the list of values returned for standards-based attributes. If the attribute; is not supported by the current compilation target, this macro evaluates to 0.; It can be used like this:. .. code-block:: c++. #ifndef __has_cpp_attribute // For backwards compatibility; #define __has_cpp_attribute(x) 0; #endif. ...; #if __has_cpp_attribute(clang::fallthrough); #define FALLTHROUGH [[clang::fallthrough]]; #else; #define FALLTHROUGH; #endif; ... The attribute scope tokens ``clang`` and ``_Clang`` are interchangeable, as are; the attribute scope tokens ``gnu`` and ``__gnu__``. Attribute tokens in either; of these namespaces can be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``gnu::__const__`` can be used instead of ``gnu::const``. ``__has_c_attribute``; ---------------------. This function-like macro takes a single argument that is the name of an; attribute exposed with the double square-bracket syntax in C mode. The argument; can either be a single identifier or a scoped identifier. If the attribute is; supported, a nonzero value is returned. If the attribute is not supported by the; current compilation target, this macro evaluates to 0. It can be used like this:. .. code-block:: c. #ifndef __has_c_attribute // Optional of course.; #define __has_c_attribute(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_c_attribute(fallthrough); #define FALLTHROUGH [[fallthrough]]; #else; #define FALLTHROUGH; #endif; ... The attribute scope tokens ``clang`` and ``_Clang`` are interchangeable, as are; the attribute scope tokens ``gnu`` and ``__",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:7366,Safety,avoid,avoid,7366,"stance, ``gnu::__const__`` can be used instead of ``gnu::const``. ``__has_c_attribute``; ---------------------. This function-like macro takes a single argument that is the name of an; attribute exposed with the double square-bracket syntax in C mode. The argument; can either be a single identifier or a scoped identifier. If the attribute is; supported, a nonzero value is returned. If the attribute is not supported by the; current compilation target, this macro evaluates to 0. It can be used like this:. .. code-block:: c. #ifndef __has_c_attribute // Optional of course.; #define __has_c_attribute(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_c_attribute(fallthrough); #define FALLTHROUGH [[fallthrough]]; #else; #define FALLTHROUGH; #endif; ... The attribute scope tokens ``clang`` and ``_Clang`` are interchangeable, as are; the attribute scope tokens ``gnu`` and ``__gnu__``. Attribute tokens in either; of these namespaces can be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``gnu::__const__`` can be used instead of ``gnu::const``. ``__has_attribute``; -------------------. This function-like macro takes a single identifier argument that is the name of; a GNU-style attribute. It evaluates to 1 if the attribute is supported by the; current compilation target, or 0 if not. It can be used like this:. .. code-block:: c++. #ifndef __has_attribute // Optional of course.; #define __has_attribute(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_attribute(always_inline); #define ALWAYS_INLINE __attribute__((always_inline)); #else; #define ALWAYS_INLINE; #endif; ... The attribute name can also be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``__always_inline__`` can be used instead of ``always_inline``. ``__has_declspec_attribute``; ----------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:8151,Safety,avoid,avoid,8151,"e tokens ``clang`` and ``_Clang`` are interchangeable, as are; the attribute scope tokens ``gnu`` and ``__gnu__``. Attribute tokens in either; of these namespaces can be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``gnu::__const__`` can be used instead of ``gnu::const``. ``__has_attribute``; -------------------. This function-like macro takes a single identifier argument that is the name of; a GNU-style attribute. It evaluates to 1 if the attribute is supported by the; current compilation target, or 0 if not. It can be used like this:. .. code-block:: c++. #ifndef __has_attribute // Optional of course.; #define __has_attribute(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_attribute(always_inline); #define ALWAYS_INLINE __attribute__((always_inline)); #else; #define ALWAYS_INLINE; #endif; ... The attribute name can also be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``__always_inline__`` can be used instead of ``always_inline``. ``__has_declspec_attribute``; ----------------------------. This function-like macro takes a single identifier argument that is the name of; an attribute implemented as a Microsoft-style ``__declspec`` attribute. It; evaluates to 1 if the attribute is supported by the current compilation target,; or 0 if not. It can be used like this:. .. code-block:: c++. #ifndef __has_declspec_attribute // Optional of course.; #define __has_declspec_attribute(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_declspec_attribute(dllexport); #define DLLEXPORT __declspec(dllexport); #else; #define DLLEXPORT; #endif; ... The attribute name can also be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``__dllexport__`` can be used instead of `",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:9016,Safety,avoid,avoid,9016,"always_inline)); #else; #define ALWAYS_INLINE; #endif; ... The attribute name can also be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``__always_inline__`` can be used instead of ``always_inline``. ``__has_declspec_attribute``; ----------------------------. This function-like macro takes a single identifier argument that is the name of; an attribute implemented as a Microsoft-style ``__declspec`` attribute. It; evaluates to 1 if the attribute is supported by the current compilation target,; or 0 if not. It can be used like this:. .. code-block:: c++. #ifndef __has_declspec_attribute // Optional of course.; #define __has_declspec_attribute(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_declspec_attribute(dllexport); #define DLLEXPORT __declspec(dllexport); #else; #define DLLEXPORT; #endif; ... The attribute name can also be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``__dllexport__`` can be used instead of ``dllexport``. ``__is_identifier``; -------------------. This function-like macro takes a single identifier argument that might be either; a reserved word or a regular identifier. It evaluates to 1 if the argument is just; a regular identifier and not a reserved word, in the sense that it can then be; used as the name of a user-defined function or variable. Otherwise it evaluates; to 0. It can be used like this:. .. code-block:: c++. ...; #ifdef __is_identifier // Compatibility with non-clang compilers.; #if __is_identifier(__wchar_t); typedef wchar_t __wchar_t;; #endif; #endif. __wchar_t WideCharacter;; ... Include File Checking Macros; ============================. Not all developments systems have the same include files. The; :ref:`langext-__has_include` and :ref:`langext-__has_include_next` macros allow; you to check for the existence of an include f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:10674,Safety,avoid,avoid,10674," #endif. __wchar_t WideCharacter;; ... Include File Checking Macros; ============================. Not all developments systems have the same include files. The; :ref:`langext-__has_include` and :ref:`langext-__has_include_next` macros allow; you to check for the existence of an include file before doing a possibly; failing ``#include`` directive. Include file checking macros must be used; as expressions in ``#if`` or ``#elif`` preprocessing directives. .. _langext-__has_include:. ``__has_include``; -----------------. This function-like macro takes a single file name string argument that is the; name of an include file. It evaluates to 1 if the file can be found using the; include paths, or 0 otherwise:. .. code-block:: c++. // Note the two possible file name string formats.; #if __has_include(""myinclude.h"") && __has_include(<stdint.h>); # include ""myinclude.h""; #endif. To test for this feature, use ``#if defined(__has_include)``:. .. code-block:: c++. // To avoid problem with non-clang compilers not having this macro.; #if defined(__has_include); #if __has_include(""myinclude.h""); # include ""myinclude.h""; #endif; #endif. .. _langext-__has_include_next:. ``__has_include_next``; ----------------------. This function-like macro takes a single file name string argument that is the; name of an include file. It is like ``__has_include`` except that it looks for; the second instance of the given file found in the include paths. It evaluates; to 1 if the second instance of the file can be found using the include paths,; or 0 otherwise:. .. code-block:: c++. // Note the two possible file name string formats.; #if __has_include_next(""myinclude.h"") && __has_include_next(<stdint.h>); # include_next ""myinclude.h""; #endif. // To avoid problem with non-clang compilers not having this macro.; #if defined(__has_include_next); #if __has_include_next(""myinclude.h""); # include_next ""myinclude.h""; #endif; #endif. Note that ``__has_include_next``, like the GNU extension ``#include_next``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:11446,Safety,avoid,avoid,11446,"ring formats.; #if __has_include(""myinclude.h"") && __has_include(<stdint.h>); # include ""myinclude.h""; #endif. To test for this feature, use ``#if defined(__has_include)``:. .. code-block:: c++. // To avoid problem with non-clang compilers not having this macro.; #if defined(__has_include); #if __has_include(""myinclude.h""); # include ""myinclude.h""; #endif; #endif. .. _langext-__has_include_next:. ``__has_include_next``; ----------------------. This function-like macro takes a single file name string argument that is the; name of an include file. It is like ``__has_include`` except that it looks for; the second instance of the given file found in the include paths. It evaluates; to 1 if the second instance of the file can be found using the include paths,; or 0 otherwise:. .. code-block:: c++. // Note the two possible file name string formats.; #if __has_include_next(""myinclude.h"") && __has_include_next(<stdint.h>); # include_next ""myinclude.h""; #endif. // To avoid problem with non-clang compilers not having this macro.; #if defined(__has_include_next); #if __has_include_next(""myinclude.h""); # include_next ""myinclude.h""; #endif; #endif. Note that ``__has_include_next``, like the GNU extension ``#include_next``; directive, is intended for use in headers only, and will issue a warning if; used in the top-level compilation file. A warning will also be issued if an; absolute path is used in the file argument. ``__has_warning``; -----------------. This function-like macro takes a string literal that represents a command line; option for a warning and returns true if that is a valid warning option. .. code-block:: c++. #if __has_warning(""-Wformat""); ...; #endif. .. _languageextensions-builtin-macros:. Builtin Macros; ==============. ``__BASE_FILE__``; Defined to a string that contains the name of the main input file passed to; Clang. ``__FILE_NAME__``; Clang-specific extension that functions similar to ``__FILE__`` but only; renders the last path component (the filename) i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:33668,Safety,avoid,avoid,33668,"thmetic using ``float``, Clang; does not truncate intermediate operands back to their true type unless the; operand is the result of an explicit cast or assignment. This is generally; much faster but can generate different results from strict operation-by-operation; emulation. Usually the results are more precise. This is permitted by the; C and C++ standards under the rules for excess precision in intermediate operands;; see the discussion of evaluation formats in the C standard and [expr.pre] in; the C++ standard. The use of excess precision can be independently controlled for these two; types with the ``-ffloat16-excess-precision=`` and; ``-fbfloat16-excess-precision=`` options. Valid values include:. * ``none``: meaning to perform strict operation-by-operation emulation; * ``standard``: meaning that excess precision is permitted under the rules; described in the standard, i.e. never across explicit casts or statements; * ``fast``: meaning that excess precision is permitted whenever the; optimizer sees an opportunity to avoid truncations; currently this has no; effect beyond ``standard``. The ``_Float16`` type is an interchange floating type specified in; ISO/IEC TS 18661-3:2015 (""Floating-point extensions for C""). It will; be supported on more targets as they define ABIs for it. The ``__bf16`` type is a non-standard extension, but it generally follows; the rules for arithmetic interchange floating types from ISO/IEC TS; 18661-3:2015. In previous versions of Clang, it was a storage-only type; that forbade arithmetic operations. It will be supported on more targets; as they define ABIs for it. The ``__fp16`` type was originally an ARM extension and is specified; by the `ARM C Language Extensions <https://github.com/ARM-software/acle/releases>`_.; Clang uses the ``binary16`` format from IEEE 754-2008 for ``__fp16``,; not the ARM alternative format. Operators that expect arithmetic operands; immediately promote ``__fp16`` operands to ``float``. It is recommended that",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:35962,Safety,unsafe,unsafe,35962,"ual; arithmetic conversions is ``float``. A literal can be given ``_Float16`` type using the suffix ``f16``. For example,; ``3.14f16``. Because default argument promotion only applies to the standard floating-point; types, ``_Float16`` values are not promoted to ``double`` when passed as variadic; or untyped arguments. As a consequence, some caution must be taken when using; certain library facilities with ``_Float16``; for example, there is no ``printf`` format; specifier for ``_Float16``, and (unlike ``float``) it will not be implicitly promoted to; ``double`` when passed to ``printf``, so the programmer must explicitly cast it to; ``double`` before using it with an ``%f`` or similar specifier. Messages on ``deprecated`` and ``unavailable`` Attributes; =========================================================. An optional string message can be added to the ``deprecated`` and; ``unavailable`` attributes. For example:. .. code-block:: c++. void explode(void) __attribute__((deprecated(""extremely unsafe, use 'combust' instead!!!"")));. If the deprecated or unavailable declaration is used, the message will be; incorporated into the appropriate diagnostic:. .. code-block:: none. harmless.c:4:3: warning: 'explode' is deprecated: extremely unsafe, use 'combust' instead!!!; [-Wdeprecated-declarations]; explode();; ^. Query for this feature with; ``__has_extension(attribute_deprecated_with_message)`` and; ``__has_extension(attribute_unavailable_with_message)``. Attributes on Enumerators; =========================. Clang allows attributes to be written on individual enumerators. This allows; enumerators to be deprecated, made unavailable, etc. The attribute must appear; after the enumerator name and before any initializer, like so:. .. code-block:: c++. enum OperationMode {; OM_Invalid,; OM_Normal,; OM_Terrified __attribute__((deprecated)),; OM_AbortOnError __attribute__((deprecated)) = 4; };. Attributes on the ``enum`` declaration do not apply to individual enumerators. Query",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:36205,Safety,unsafe,unsafe,36205,"ouble`` when passed as variadic; or untyped arguments. As a consequence, some caution must be taken when using; certain library facilities with ``_Float16``; for example, there is no ``printf`` format; specifier for ``_Float16``, and (unlike ``float``) it will not be implicitly promoted to; ``double`` when passed to ``printf``, so the programmer must explicitly cast it to; ``double`` before using it with an ``%f`` or similar specifier. Messages on ``deprecated`` and ``unavailable`` Attributes; =========================================================. An optional string message can be added to the ``deprecated`` and; ``unavailable`` attributes. For example:. .. code-block:: c++. void explode(void) __attribute__((deprecated(""extremely unsafe, use 'combust' instead!!!"")));. If the deprecated or unavailable declaration is used, the message will be; incorporated into the appropriate diagnostic:. .. code-block:: none. harmless.c:4:3: warning: 'explode' is deprecated: extremely unsafe, use 'combust' instead!!!; [-Wdeprecated-declarations]; explode();; ^. Query for this feature with; ``__has_extension(attribute_deprecated_with_message)`` and; ``__has_extension(attribute_unavailable_with_message)``. Attributes on Enumerators; =========================. Clang allows attributes to be written on individual enumerators. This allows; enumerators to be deprecated, made unavailable, etc. The attribute must appear; after the enumerator name and before any initializer, like so:. .. code-block:: c++. enum OperationMode {; OM_Invalid,; OM_Normal,; OM_Terrified __attribute__((deprecated)),; OM_AbortOnError __attribute__((deprecated)) = 4; };. Attributes on the ``enum`` declaration do not apply to individual enumerators. Query for this feature with ``__has_extension(enumerator_attributes)``. C++11 Attributes on using-declarations; ======================================. Clang allows C++-style ``[[]]`` attributes to be written on using-declarations.; For instance:. .. code-block:: c++. [",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:65322,Safety,detect,detect,65322,"g): Determines whether a; reference of type ``T`` bound to an expression of type ``U`` would bind to a; materialized temporary object. If ``T`` is not a reference type the result; is false. Note this trait will also return false when the initialization of; ``T`` from ``U`` is ill-formed.; Deprecated, use ``__reference_constructs_from_temporary``.; * ``__reference_constructs_from_temporary(T, U)`` (C++); Returns true if a reference ``T`` can be constructed from a temporary of type; a non-cv-qualified ``U``.; * ``__underlying_type`` (C++, GNU, Microsoft). In addition, the following expression traits are supported:. * ``__is_lvalue_expr(e)`` (Embarcadero):; Returns true if ``e`` is an lvalue expression.; Deprecated, use ``__is_lvalue_reference(decltype((e)))`` instead.; * ``__is_rvalue_expr(e)`` (Embarcadero):; Returns true if ``e`` is a prvalue expression.; Deprecated, use ``!__is_reference(decltype((e)))`` instead. There are multiple ways to detect support for a type trait ``__X`` in the; compiler, depending on the oldest version of Clang you wish to support. * From Clang 10 onwards, ``__has_builtin(__X)`` can be used.; * From Clang 6 onwards, ``!__is_identifier(__X)`` can be used.; * From Clang 3 onwards, ``__has_feature(X)`` can be used, but only supports; the following traits:. * ``__has_nothrow_assign``; * ``__has_nothrow_copy``; * ``__has_nothrow_constructor``; * ``__has_trivial_assign``; * ``__has_trivial_copy``; * ``__has_trivial_constructor``; * ``__has_trivial_destructor``; * ``__has_virtual_destructor``; * ``__is_abstract``; * ``__is_base_of``; * ``__is_class``; * ``__is_constructible``; * ``__is_convertible_to``; * ``__is_empty``; * ``__is_enum``; * ``__is_final``; * ``__is_literal``; * ``__is_standard_layout``; * ``__is_pod``; * ``__is_polymorphic``; * ``__is_sealed``; * ``__is_trivial``; * ``__is_trivially_assignable``; * ``__is_trivially_constructible``; * ``__is_trivially_copyable``; * ``__is_union``; * ``__underlying_type``. A simplistic usage example ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:67267,Safety,safe,safely,67267,"* ``__is_trivially_copyable``; * ``__is_union``; * ``__underlying_type``. A simplistic usage example as might be seen in standard C++ headers follows:. .. code-block:: c++. #if __has_builtin(__is_convertible_to); template<typename From, typename To>; struct is_convertible_to {; static const bool value = __is_convertible_to(From, To);; };; #else; // Emulate type trait for compatibility with other compilers.; #endif. Blocks; ======. The syntax and high level language feature description is in; :doc:`BlockLanguageSpec<BlockLanguageSpec>`. Implementation and ABI details for; the clang implementation are in :doc:`Block-ABI-Apple<Block-ABI-Apple>`. Query for this feature with ``__has_extension(blocks)``. ASM Goto with Output Constraints; ================================. Outputs may be used along any branches from the ``asm goto`` whether the; branches are taken or not. Query for this feature with ``__has_extension(gnu_asm_goto_with_outputs)``. Prior to clang-16, the output may only be used safely when the indirect; branches are not taken. Query for this difference with; ``__has_extension(gnu_asm_goto_with_outputs_full)``. When using tied-outputs (i.e. outputs that are inputs and outputs, not just; outputs) with the `+r` constraint, there is a hidden input that's created; before the label, so numeric references to operands must account for that. .. code-block:: c++. int foo(int x) {; // %0 and %1 both refer to x; // %l2 refers to err; asm goto(""# %0 %1 %l2"" : ""+r""(x) : : : err);; return x;; err:; return -1;; }. This was changed to match GCC in clang-13; for better portability, symbolic; references can be used instead of numeric references. .. code-block:: c++. int foo(int x) {; asm goto(""# %[x] %l[err]"" : [x]""+r""(x) : : : err);; return x;; err:; return -1;; }. Objective-C Features; ====================. Related result types; --------------------. According to Cocoa conventions, Objective-C methods with certain names; (""``init``"", ""``alloc``"", etc.) always return objects th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:71578,Safety,unsafe,unsafe,71578,"that returns ``id``. Use ``__has_feature(objc_instancetype)`` to determine whether the; ``instancetype`` contextual keyword is available. Automatic reference counting; ----------------------------. Clang provides support for :doc:`automated reference counting; <AutomaticReferenceCounting>` in Objective-C, which eliminates the need; for manual ``retain``/``release``/``autorelease`` message sends. There are three; feature macros associated with automatic reference counting:; ``__has_feature(objc_arc)`` indicates the availability of automated reference; counting in general, while ``__has_feature(objc_arc_weak)`` indicates that; automated reference counting also includes support for ``__weak`` pointers to; Objective-C objects. ``__has_feature(objc_arc_fields)`` indicates that C structs; are allowed to have fields that are pointers to Objective-C objects managed by; automatic reference counting. .. _objc-weak:. Weak references; ---------------. Clang supports ARC-style weak and unsafe references in Objective-C even; outside of ARC mode. Weak references must be explicitly enabled with; the ``-fobjc-weak`` option; use ``__has_feature((objc_arc_weak))``; to test whether they are enabled. Unsafe references are enabled; unconditionally. ARC-style weak and unsafe references cannot be used; when Objective-C garbage collection is enabled. Except as noted below, the language rules for the ``__weak`` and; ``__unsafe_unretained`` qualifiers (and the ``weak`` and; ``unsafe_unretained`` property attributes) are just as laid out; in the :doc:`ARC specification <AutomaticReferenceCounting>`.; In particular, note that some classes do not support forming weak; references to their instances, and note that special care must be; taken when storing weak references in memory where initialization; and deinitialization are outside the responsibility of the compiler; (such as in ``malloc``-ed memory). Loading from a ``__weak`` variable always implicitly retains the; loaded value. In non-ARC mode",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:71856,Safety,unsafe,unsafe,71856,"jective-C, which eliminates the need; for manual ``retain``/``release``/``autorelease`` message sends. There are three; feature macros associated with automatic reference counting:; ``__has_feature(objc_arc)`` indicates the availability of automated reference; counting in general, while ``__has_feature(objc_arc_weak)`` indicates that; automated reference counting also includes support for ``__weak`` pointers to; Objective-C objects. ``__has_feature(objc_arc_fields)`` indicates that C structs; are allowed to have fields that are pointers to Objective-C objects managed by; automatic reference counting. .. _objc-weak:. Weak references; ---------------. Clang supports ARC-style weak and unsafe references in Objective-C even; outside of ARC mode. Weak references must be explicitly enabled with; the ``-fobjc-weak`` option; use ``__has_feature((objc_arc_weak))``; to test whether they are enabled. Unsafe references are enabled; unconditionally. ARC-style weak and unsafe references cannot be used; when Objective-C garbage collection is enabled. Except as noted below, the language rules for the ``__weak`` and; ``__unsafe_unretained`` qualifiers (and the ``weak`` and; ``unsafe_unretained`` property attributes) are just as laid out; in the :doc:`ARC specification <AutomaticReferenceCounting>`.; In particular, note that some classes do not support forming weak; references to their instances, and note that special care must be; taken when storing weak references in memory where initialization; and deinitialization are outside the responsibility of the compiler; (such as in ``malloc``-ed memory). Loading from a ``__weak`` variable always implicitly retains the; loaded value. In non-ARC modes, this retain is normally balanced; by an implicit autorelease. This autorelease can be suppressed; by performing the load in the receiver position of a ``-retain``; message send (e.g. ``[weakReference retain]``); note that this performs; only a single retain (the retain done when primitively lo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:76638,Safety,avoid,avoids,76638,"Range = NSMakeRange(0, [s1 length]);; return [s1 compare:s2 options:comparisonOptions; range:string1Range locale:currentLocale];; }];; NSLog(@""sorted: %@"", sorted);. This code relies on an implicit conversion from the type of the lambda; expression (an unnamed, local class type called the *closure type*) to the; corresponding block pointer type. The conversion itself is expressed by a; conversion operator in that closure type that produces a block pointer with the; same signature as the lambda itself, e.g.,. .. code-block:: objc. operator NSComparisonResult (^)(id, id)() const;. This conversion function returns a new block that simply forwards the two; parameters to the lambda object (which it captures by copy), then returns the; result. The returned block is first copied (with ``Block_copy``) and then; autoreleased. As an optimization, if a lambda expression is immediately; converted to a block pointer (as in the first example, above), then the block; is not copied and autoreleased: rather, it is given the same lifetime as a; block literal written at that point in the program, which avoids the overhead; of copying a block to the heap in the common case. The conversion from a lambda to a block pointer is only available in; Objective-C++, and not in C++ with blocks, due to its use of Objective-C memory; management (autorelease). Object Literals and Subscripting; --------------------------------. Clang provides support for :doc:`Object Literals and Subscripting; <ObjectiveCLiterals>` in Objective-C, which simplifies common Objective-C; programming patterns, makes programs more concise, and improves the safety of; container creation. There are several feature macros associated with object; literals and subscripting: ``__has_feature(objc_array_literals)`` tests the; availability of array literals; ``__has_feature(objc_dictionary_literals)``; tests the availability of dictionary literals;; ``__has_feature(objc_subscripting)`` tests the availability of object; subscriptin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:77165,Safety,safe,safety,77165,"perator NSComparisonResult (^)(id, id)() const;. This conversion function returns a new block that simply forwards the two; parameters to the lambda object (which it captures by copy), then returns the; result. The returned block is first copied (with ``Block_copy``) and then; autoreleased. As an optimization, if a lambda expression is immediately; converted to a block pointer (as in the first example, above), then the block; is not copied and autoreleased: rather, it is given the same lifetime as a; block literal written at that point in the program, which avoids the overhead; of copying a block to the heap in the common case. The conversion from a lambda to a block pointer is only available in; Objective-C++, and not in C++ with blocks, due to its use of Objective-C memory; management (autorelease). Object Literals and Subscripting; --------------------------------. Clang provides support for :doc:`Object Literals and Subscripting; <ObjectiveCLiterals>` in Objective-C, which simplifies common Objective-C; programming patterns, makes programs more concise, and improves the safety of; container creation. There are several feature macros associated with object; literals and subscripting: ``__has_feature(objc_array_literals)`` tests the; availability of array literals; ``__has_feature(objc_dictionary_literals)``; tests the availability of dictionary literals;; ``__has_feature(objc_subscripting)`` tests the availability of object; subscripting. Objective-C Autosynthesis of Properties; ---------------------------------------. Clang provides support for autosynthesis of declared properties. Using this; feature, clang provides default synthesis of those properties not declared; @dynamic and not having user provided backing getter and setter methods.; ``__has_feature(objc_default_synthesize_properties)`` checks for availability; of this feature in version of clang being used. .. _langext-objc-retain-release:. Objective-C retaining behavior attributes; ----------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:81880,Safety,avoid,avoid,81880,"function exists at runtime, using; null checks for weakly-linked C functions, ``+class`` for Objective-C classes,; and ``-respondsToSelector:`` or ``+instancesRespondToSelector:`` for; Objective-C methods. If such a check was missed, the program would compile; fine, run fine on newer systems, but crash on older systems. As of LLVM 5.0, ``-Wunguarded-availability`` uses the `availability attributes; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ together; with the new ``@available()`` keyword to assist with this issue.; When a method that's introduced in the OS newer than the target OS is called, a; -Wunguarded-availability warning is emitted if that call is not guarded:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; // If fancyNewMethod was added in e.g. macOS 10.12, but the code is; // built with -mmacosx-version-min=10.11, then this unconditional call; // will emit a -Wunguarded-availability warning:; [var fancyNewMethod];; }. To fix the warning and to avoid the crash on macOS 10.11, wrap it in; ``if(@available())``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, *)) {; [var fancyNewMethod];; } else {; // Put fallback behavior for old macOS versions (and for non-mac; // platforms) here.; }; }. The ``*`` is required and means that platforms not explicitly listed will take; the true branch, and the compiler will emit ``-Wunguarded-availability``; warnings for unlisted platforms based on those platform's deployment target.; More than one platform can be listed in ``@available()``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, iOS 10, *)) {; [var fancyNewMethod];; }; }. If the caller of ``my_fun()`` already checks that ``my_fun()`` is only called; on 10.12, then add an `availability attribute; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ to it,; which will also suppress the warning and require that calls to my_fun() are; checked:. .. code-bl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:87424,Safety,detect,detect,87424,"c generated; };. #pragma OPENCL EXTENSION __cl_clang_bitfields : disable; struct without_bitfield {; unsigned int i : 5; // error - bitfields are not supported; };. ``__cl_clang_function_pointers``; --------------------------------. With this extension it is possible to enable various language features that; are relying on function pointers using regular OpenCL extension pragma; mechanism detailed in `the OpenCL Extension Specification,; section 1.2; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview>`_. In C++ for OpenCL this also enables:. - Use of member function pointers;. - Unrestricted use of references to functions;. - Virtual member functions. Such functionality is not conformant and does not guarantee to compile; correctly in any circumstances. It can be used if:. - the kernel source does not contain call expressions to (member-) function; pointers, or virtual functions. For example this extension can be used in; metaprogramming algorithms to be able to specify/detect types generically. - the generated kernel binary does not contain indirect calls because they; are eliminated using compiler optimizations e.g. devirtualization. - the selected target supports the function pointer like functionality e.g.; most CPU targets. **Example of Use**:. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_function_pointers : enable; void foo(); {; void (*fp)(); // compiled - no diagnostic generated; }. #pragma OPENCL EXTENSION __cl_clang_function_pointers : disable; void bar(); {; void (*fp)(); // error - pointers to function are not allowed; }. ``__cl_clang_variadic_functions``; ---------------------------------. With this extension it is possible to enable variadic arguments in functions; using regular OpenCL extension pragma mechanism detailed in `the OpenCL; Extension Specification, section 1.2; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview>`_. This is not conf",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:105922,Safety,detect,detect,105922," argument of the; builtin should be a pointer to a complete record type to dump. The second argument ``f``; should be some callable expression, and can be a function object or an overload; set. The builtin calls ``f``, passing any further arguments ``args...``; followed by a ``printf``-compatible format string and the corresponding; arguments. ``f`` may be called more than once, and ``f`` and ``args`` will be; evaluated once per call. In C++, ``f`` may be a template or overload set and; resolve to different functions for each call. In the format string, a suitable format specifier will be used for builtin; types that Clang knows how to format. This includes standard builtin types, as; well as aggregate structures, ``void*`` (printed with ``%p``), and ``const; char*`` (printed with ``%s``). A ``*%p`` specifier will be used for a field; that Clang doesn't know how to format, and the corresponding argument will be a; pointer to the field. This allows a C++ templated formatting function to detect; this case and implement custom formatting. A ``*`` will otherwise not precede a; format specifier. This builtin does not return a value. This builtin can be used in constant expressions. Query for this feature with ``__has_builtin(__builtin_dump_struct)``. .. _langext-__builtin_shufflevector:. ``__builtin_shufflevector``; ---------------------------. ``__builtin_shufflevector`` is used to express generic vector; permutation/shuffle/swizzle operations. This builtin is also very important; for the implementation of various target-specific header files like; ``<xmmintrin.h>``. **Syntax**:. .. code-block:: c++. __builtin_shufflevector(vec1, vec2, index1, index2, ...). **Examples**:. .. code-block:: c++. // identity operation - return 4-element vector v1.; __builtin_shufflevector(v1, v1, 0, 1, 2, 3). // ""Splat"" element 0 of V1 into a 4-element result.; __builtin_shufflevector(V1, V1, 0, 0, 0, 0). // Reverse 4-element vector V1.; __builtin_shufflevector(V1, V1, 3, 2, 1, 0). // Conca",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:113434,Safety,predict,prediction,113434,"an.; This is useful to improve optimization and eliminates certain warnings. For; example, without the ``__builtin_unreachable`` in the example below, the; compiler assumes that the inline asm can fall through and prints a ""function; declared '``noreturn``' should not return"" warning. **Syntax**:. .. code-block:: c++. __builtin_unreachable(). **Example of use**:. .. code-block:: c++. void myabort(void) __attribute__((noreturn));; void myabort(void) {; asm(""int3"");; __builtin_unreachable();; }. **Description**:. The ``__builtin_unreachable()`` builtin has completely undefined behavior.; Since it has undefined behavior, it is a statement that it is never reached and; the optimizer can take advantage of this to produce better code. This builtin; takes no arguments and produces a void result. Query for this feature with ``__has_builtin(__builtin_unreachable)``. ``__builtin_unpredictable``; ---------------------------. ``__builtin_unpredictable`` is used to indicate that a branch condition is; unpredictable by hardware mechanisms such as branch prediction logic. **Syntax**:. .. code-block:: c++. __builtin_unpredictable(long long). **Example of use**:. .. code-block:: c++. if (__builtin_unpredictable(x > 0)) {; foo();; }. **Description**:. The ``__builtin_unpredictable()`` builtin is expected to be used with control; flow conditions such as in ``if`` and ``switch`` statements. Query for this feature with ``__has_builtin(__builtin_unpredictable)``. ``__builtin_expect``; --------------------. ``__builtin_expect`` is used to indicate that the value of an expression is; anticipated to be the same as a statically known result. **Syntax**:. .. code-block:: c++. long __builtin_expect(long expr, long val). **Example of use**:. .. code-block:: c++. if (__builtin_expect(x, 0)) {; bar();; }. **Description**:. The ``__builtin_expect()`` builtin is typically used with control flow; conditions such as in ``if`` and ``switch`` statements to help branch; prediction. It means that its fir",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:114345,Safety,predict,prediction,114345,"--------------------------. ``__builtin_unpredictable`` is used to indicate that a branch condition is; unpredictable by hardware mechanisms such as branch prediction logic. **Syntax**:. .. code-block:: c++. __builtin_unpredictable(long long). **Example of use**:. .. code-block:: c++. if (__builtin_unpredictable(x > 0)) {; foo();; }. **Description**:. The ``__builtin_unpredictable()`` builtin is expected to be used with control; flow conditions such as in ``if`` and ``switch`` statements. Query for this feature with ``__has_builtin(__builtin_unpredictable)``. ``__builtin_expect``; --------------------. ``__builtin_expect`` is used to indicate that the value of an expression is; anticipated to be the same as a statically known result. **Syntax**:. .. code-block:: c++. long __builtin_expect(long expr, long val). **Example of use**:. .. code-block:: c++. if (__builtin_expect(x, 0)) {; bar();; }. **Description**:. The ``__builtin_expect()`` builtin is typically used with control flow; conditions such as in ``if`` and ``switch`` statements to help branch; prediction. It means that its first argument ``expr`` is expected to take the; value of its second argument ``val``. It always returns ``expr``. Query for this feature with ``__has_builtin(__builtin_expect)``. ``__builtin_expect_with_probability``; -------------------------------------. ``__builtin_expect_with_probability`` is similar to ``__builtin_expect`` but it; takes a probability as third argument. **Syntax**:. .. code-block:: c++. long __builtin_expect_with_probability(long expr, long val, double p). **Example of use**:. .. code-block:: c++. if (__builtin_expect_with_probability(x, 0, .3)) {; bar();; }. **Description**:. The ``__builtin_expect_with_probability()`` builtin is typically used with; control flow conditions such as in ``if`` and ``switch`` statements to help; branch prediction. It means that its first argument ``expr`` is expected to take; the value of its second argument ``val`` with probability ``p``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:115141,Safety,predict,prediction,115141,"ltin_expect(long expr, long val). **Example of use**:. .. code-block:: c++. if (__builtin_expect(x, 0)) {; bar();; }. **Description**:. The ``__builtin_expect()`` builtin is typically used with control flow; conditions such as in ``if`` and ``switch`` statements to help branch; prediction. It means that its first argument ``expr`` is expected to take the; value of its second argument ``val``. It always returns ``expr``. Query for this feature with ``__has_builtin(__builtin_expect)``. ``__builtin_expect_with_probability``; -------------------------------------. ``__builtin_expect_with_probability`` is similar to ``__builtin_expect`` but it; takes a probability as third argument. **Syntax**:. .. code-block:: c++. long __builtin_expect_with_probability(long expr, long val, double p). **Example of use**:. .. code-block:: c++. if (__builtin_expect_with_probability(x, 0, .3)) {; bar();; }. **Description**:. The ``__builtin_expect_with_probability()`` builtin is typically used with; control flow conditions such as in ``if`` and ``switch`` statements to help; branch prediction. It means that its first argument ``expr`` is expected to take; the value of its second argument ``val`` with probability ``p``. ``p`` must be; within ``[0.0 ; 1.0]`` bounds. This builtin always returns the value of ``expr``. Query for this feature with ``__has_builtin(__builtin_expect_with_probability)``. ``__builtin_prefetch``; ----------------------. ``__builtin_prefetch`` is used to communicate with the cache handler to bring; data into the cache before it gets used. **Syntax**:. .. code-block:: c++. void __builtin_prefetch(const void *addr, int rw=0, int locality=3). **Example of use**:. .. code-block:: c++. __builtin_prefetch(a + i);. **Description**:. The ``__builtin_prefetch(addr, rw, locality)`` builtin is expected to be used to; avoid cache misses when the developer has a good understanding of which data; are going to be used next. ``addr`` is the address that needs to be brought into; the c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:115901,Safety,avoid,avoid,115901,"in_expect_with_probability(x, 0, .3)) {; bar();; }. **Description**:. The ``__builtin_expect_with_probability()`` builtin is typically used with; control flow conditions such as in ``if`` and ``switch`` statements to help; branch prediction. It means that its first argument ``expr`` is expected to take; the value of its second argument ``val`` with probability ``p``. ``p`` must be; within ``[0.0 ; 1.0]`` bounds. This builtin always returns the value of ``expr``. Query for this feature with ``__has_builtin(__builtin_expect_with_probability)``. ``__builtin_prefetch``; ----------------------. ``__builtin_prefetch`` is used to communicate with the cache handler to bring; data into the cache before it gets used. **Syntax**:. .. code-block:: c++. void __builtin_prefetch(const void *addr, int rw=0, int locality=3). **Example of use**:. .. code-block:: c++. __builtin_prefetch(a + i);. **Description**:. The ``__builtin_prefetch(addr, rw, locality)`` builtin is expected to be used to; avoid cache misses when the developer has a good understanding of which data; are going to be used next. ``addr`` is the address that needs to be brought into; the cache. ``rw`` indicates the expected access mode: ``0`` for *read* and ``1``; for *write*. In case of *read write* access, ``1`` is to be used. ``locality``; indicates the expected persistence of data in cache, from ``0`` which means that; data can be discarded from cache after its next use to ``3`` which means that; data is going to be reused a lot once in cache. ``1`` and ``2`` provide; intermediate behavior between these two extremes. Query for this feature with ``__has_builtin(__builtin_prefetch)``. ``__sync_swap``; ---------------. ``__sync_swap`` is used to atomically swap integers or pointers in memory. **Syntax**:. .. code-block:: c++. type __sync_swap(type *ptr, type value, ...). **Example of Use**:. .. code-block:: c++. int old_value = __sync_swap(&value, new_value);. **Description**:. The ``__sync_swap()`` builtin extends th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:117119,Safety,avoid,avoiding,117119,"case of *read write* access, ``1`` is to be used. ``locality``; indicates the expected persistence of data in cache, from ``0`` which means that; data can be discarded from cache after its next use to ``3`` which means that; data is going to be reused a lot once in cache. ``1`` and ``2`` provide; intermediate behavior between these two extremes. Query for this feature with ``__has_builtin(__builtin_prefetch)``. ``__sync_swap``; ---------------. ``__sync_swap`` is used to atomically swap integers or pointers in memory. **Syntax**:. .. code-block:: c++. type __sync_swap(type *ptr, type value, ...). **Example of Use**:. .. code-block:: c++. int old_value = __sync_swap(&value, new_value);. **Description**:. The ``__sync_swap()`` builtin extends the existing ``__sync_*()`` family of; atomic intrinsics to allow code to atomically swap the current value with the; new value. More importantly, it helps developers write more efficient and; correct code by avoiding expensive loops around; ``__sync_bool_compare_and_swap()`` or relying on the platform specific; implementation details of ``__sync_lock_test_and_set()``. The; ``__sync_swap()`` builtin is a full barrier. ``__builtin_addressof``; -----------------------. ``__builtin_addressof`` performs the functionality of the built-in ``&``; operator, ignoring any ``operator&`` overload. This is useful in constant; expressions in C++11, where there is no other way to take the address of an; object that overloads ``operator&``. Clang automatically adds; ``[[clang::lifetimebound]]`` to the parameter of ``__builtin_addressof``. **Example of use**:. .. code-block:: c++. template<typename T> constexpr T *addressof(T &value) {; return __builtin_addressof(value);; }. ``__builtin_function_start``; -----------------------------. ``__builtin_function_start`` returns the address of a function body. **Syntax**:. .. code-block:: c++. void *__builtin_function_start(function). **Example of use**:. .. code-block:: c++. void a() {}; void *p = __buil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:118701,Safety,safe,safe,118701," adds; ``[[clang::lifetimebound]]`` to the parameter of ``__builtin_addressof``. **Example of use**:. .. code-block:: c++. template<typename T> constexpr T *addressof(T &value) {; return __builtin_addressof(value);; }. ``__builtin_function_start``; -----------------------------. ``__builtin_function_start`` returns the address of a function body. **Syntax**:. .. code-block:: c++. void *__builtin_function_start(function). **Example of use**:. .. code-block:: c++. void a() {}; void *p = __builtin_function_start(a);. class A {; public:; void a(int n);; void a();; };. void A::a(int n) {}; void A::a() {}. void *pa1 = __builtin_function_start((void(A::*)(int)) &A::a);; void *pa2 = __builtin_function_start((void(A::*)()) &A::a);. **Description**:. The ``__builtin_function_start`` builtin accepts an argument that can be; constant-evaluated to a function, and returns the address of the function; body. This builtin is not supported on all targets. The returned pointer may differ from the normally taken function address; and is not safe to call. For example, with ``-fsanitize=cfi``, taking a; function address produces a callable pointer to a CFI jump table, while; ``__builtin_function_start`` returns an address that fails; :doc:`cfi-icall<ControlFlowIntegrity>` checks. ``__builtin_operator_new`` and ``__builtin_operator_delete``; ------------------------------------------------------------. A call to ``__builtin_operator_new(args)`` is exactly the same as a call to; ``::operator new(args)``, except that it allows certain optimizations; that the C++ standard does not permit for a direct function call to; ``::operator new`` (in particular, removing ``new`` / ``delete`` pairs and; merging allocations), and that the call is required to resolve to a; `replaceable global allocation function; <https://en.cppreference.com/w/cpp/memory/new/operator_new>`_. Likewise, ``__builtin_operator_delete`` is exactly the same as a call to; ``::operator delete(args)``, except that it permits optimi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:134965,Safety,detect,detected,134965,"; * ``strcmp``; * ``strlen``; * ``strncmp``; * ``wcschr``; * ``wcscmp``; * ``wcslen``; * ``wcsncmp``; * ``wmemchr``; * ``wmemcmp``. In each case, the builtin form has the name of the C library function prefixed; by ``__builtin_``. Example:. .. code-block:: c. void *p = __builtin_memchr(""foobar"", 'b', 5);. In addition to the above, one further builtin is provided:. .. code-block:: c. char *__builtin_char_memchr(const char *haystack, int needle, size_t size);. ``__builtin_char_memchr(a, b, c)`` is identical to; ``(char*)__builtin_memchr(a, b, c)`` except that its use is permitted within; constant expressions in C++11 onwards (where a cast from ``void*`` to ``char*``; is disallowed in general). Constant evaluation support for the ``__builtin_mem*`` functions is provided; only for arrays of ``char``, ``signed char``, ``unsigned char``, or ``char8_t``,; despite these functions accepting an argument of type ``const void*``. Support for constant expression evaluation for the above builtins can be detected; with ``__has_feature(cxx_constexpr_string_builtins)``. Variadic function builtins; --------------------------. Clang provides several builtins for working with variadic functions from the C; standard library ``<stdarg.h>`` header:. * ``__builtin_va_list``. A predefined typedef for the target-specific ``va_list`` type. * ``void __builtin_va_start(__builtin_va_list list, <parameter-name>)``. A builtin function for the target-specific ``va_start`` function-like macro.; The ``parameter-name`` argument is the name of the parameter preceding the; ellipsis (``...``) in the function signature. Alternatively, in C23 mode or; later, it may be the integer literal ``0`` if there is no parameter preceding; the ellipsis. This function initializes the given ``__builtin_va_list`` object.; It is undefined behavior to call this function on an already initialized; ``__builin_va_list`` object. * ``void __builtin_va_end(__builtin_va_list list)``. A builtin function for the target-specific ``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:144227,Safety,risk,risk,144227,"upport atomic; scopes, then they will behave exactly as the standard GNU atomic builtins. Low-level ARM exclusive memory builtins; ---------------------------------------. Clang provides overloaded builtins giving direct access to the three key ARM; instructions for implementing atomic operations. .. code-block:: c. T __builtin_arm_ldrex(const volatile T *addr);; T __builtin_arm_ldaex(const volatile T *addr);; int __builtin_arm_strex(T val, volatile T *addr);; int __builtin_arm_stlex(T val, volatile T *addr);; void __builtin_arm_clrex(void);. The types ``T`` currently supported are:. * Integer types with width at most 64 bits (or 128 bits on AArch64).; * Floating-point types; * Pointer types. Note that the compiler does not guarantee it will not insert stores which clear; the exclusive monitor in between an ``ldrex`` type operation and its paired; ``strex``. In practice this is only usually a risk when the extra store is on; the same cache line as the variable being modified and Clang will only insert; stack stores on its own, so it is best not to use these operations on variables; with automatic storage duration. Also, loads and stores may be implicit in code written between the ``ldrex`` and; ``strex``. Clang will not necessarily mitigate the effects of these either, so; care should be exercised. For these reasons the higher level atomic primitives should be preferred where; possible. Non-temporal load/store builtins; --------------------------------. Clang provides overloaded builtins allowing generation of non-temporal memory; accesses. .. code-block:: c. T __builtin_nontemporal_load(T *addr);; void __builtin_nontemporal_store(T value, T *addr);. The types ``T`` currently supported are:. * Integer types.; * Floating-point types.; * Vector types. Note that the compiler does not guarantee that non-temporal loads or stores; will be used. C++ Coroutines support builtins; --------------------------------. .. warning::; This is a work in progress. Compatibility across ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:148602,Safety,abort,abort,148602,"f the first argument to `llvm.coro.suspend` is; token `none`. If a user calls `__builin_suspend`, clang will insert `token none`; as the first argument to the intrinsic. Source location builtins; ------------------------. Clang provides builtins to support C++ standard library implementation; of ``std::source_location`` as specified in C++20. With the exception; of ``__builtin_COLUMN``, ``__builtin_FILE_NAME`` and ``__builtin_FUNCSIG``,; these builtins are also implemented by GCC. **Syntax**:. .. code-block:: c. const char *__builtin_FILE();; const char *__builtin_FILE_NAME(); // Clang only; const char *__builtin_FUNCTION();; const char *__builtin_FUNCSIG(); // Microsoft; unsigned __builtin_LINE();; unsigned __builtin_COLUMN(); // Clang only; const std::source_location::__impl *__builtin_source_location();. **Example of use**:. .. code-block:: c++. void my_assert(bool pred, int line = __builtin_LINE(), // Captures line of caller; const char* file = __builtin_FILE(),; const char* function = __builtin_FUNCTION()) {; if (pred) return;; printf(""%s:%d assertion failed in function %s\n"", file, line, function);; std::abort();; }. struct MyAggregateType {; int x;; int line = __builtin_LINE(); // captures line where aggregate initialization occurs; };; static_assert(MyAggregateType{42}.line == __LINE__);. struct MyClassType {; int line = __builtin_LINE(); // captures line of the constructor used during initialization; constexpr MyClassType(int) { assert(line == __LINE__); }; };. **Description**:. The builtins ``__builtin_LINE``, ``__builtin_FUNCTION``, ``__builtin_FUNCSIG``,; ``__builtin_FILE`` and ``__builtin_FILE_NAME`` return the values, at the; ""invocation point"", for ``__LINE__``, ``__FUNCTION__``, ``__FUNCSIG__``,; ``__FILE__`` and ``__FILE_NAME__`` respectively. ``__builtin_COLUMN`` similarly; returns the column, though there is no corresponding macro. These builtins are; constant expressions. When the builtins appear as part of a default function argument the invocat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:150573,Safety,avoid,avoid,150573," the location of the; constructor or aggregate initialization used to create the object. Otherwise; the invocation point is the same as the location of the builtin. When the invocation point of ``__builtin_FUNCTION`` is not a function scope the; empty string is returned. The builtin ``__builtin_source_location`` returns a pointer to constant static; data of type ``std::source_location::__impl``. This type must have already been; defined, and must contain exactly four fields: ``const char *_M_file_name``,; ``const char *_M_function_name``, ``<any-integral-type> _M_line``, and; ``<any-integral-type> _M_column``. The fields will be populated in the same; manner as the above four builtins, except that ``_M_function_name`` is populated; with ``__PRETTY_FUNCTION__`` rather than ``__FUNCTION__``. Alignment builtins; ------------------; Clang provides builtins to support checking and adjusting alignment of; pointers and integers.; These builtins can be used to avoid relying on implementation-defined behavior; of arithmetic on integers derived from pointers.; Additionally, these builtins retain type information and, unlike bitwise; arithmetic, they can perform semantic checking on the alignment value. **Syntax**:. .. code-block:: c. Type __builtin_align_up(Type value, size_t alignment);; Type __builtin_align_down(Type value, size_t alignment);; bool __builtin_is_aligned(Type value, size_t alignment);. **Example of use**:. .. code-block:: c++. char* global_alloc_buffer;; void* my_aligned_allocator(size_t alloc_size, size_t alignment) {; char* result = __builtin_align_up(global_alloc_buffer, alignment);; // result now contains the value of global_alloc_buffer rounded up to the; // next multiple of alignment.; global_alloc_buffer = result + alloc_size;; return result;; }. void* get_start_of_page(void* ptr) {; return __builtin_align_down(ptr, PAGE_SIZE);; }. void example(char* buffer) {; if (__builtin_is_aligned(buffer, 64)) {; do_fast_aligned_copy(buffer);; } else {; do_unalign",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:162639,Safety,safe,safe,162639,"e optimized with whatever was specified on; // the commandline.; void f2() {}. // This will warn with Clang's current implementation.; #pragma optimize(""g"", on); void f3() {}. For MSVC, an empty optimization list and ``off`` parameter will turn off; all optimizations, ``s``, ``g``, ``t``, and ``y``. An empty optimization and; ``on`` parameter will reset the optimizations to the ones specified on the; commandline. .. list-table:: Parameters (unsupported by Clang). * - Parameter; - Type of optimization; * - g; - Deprecated; * - s or t; - Short or fast sequences of machine code; * - y; - Enable frame pointers. Extensions for loop hint optimizations; ======================================. The ``#pragma clang loop`` directive is used to specify hints for optimizing the; subsequent for, while, do-while, or c++11 range-based for loop. The directive; provides options for vectorization, interleaving, predication, unrolling and; distribution. Loop hints can be specified before any loop and will be ignored if; the optimization is not safe to apply. There are loop hints that control transformations (e.g. vectorization, loop; unrolling) and there are loop hints that set transformation options (e.g.; ``vectorize_width``, ``unroll_count``). Pragmas setting transformation options; imply the transformation is enabled, as if it was enabled via the corresponding; transformation pragma (e.g. ``vectorize(enable)``). If the transformation is; disabled (e.g. ``vectorize(disable)``), that takes precedence over; transformations option pragmas implying that transformation. Vectorization, Interleaving, and Predication; --------------------------------------------. A vectorized loop performs multiple iterations of the original loop; in parallel using vector instructions. The instruction set of the target; processor determines which vector instructions are available and their vector; widths. This restricts the types of loops that can be vectorized. The vectorizer; automatically determines if th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:163610,Safety,safe,safe,163610,"l be ignored if; the optimization is not safe to apply. There are loop hints that control transformations (e.g. vectorization, loop; unrolling) and there are loop hints that set transformation options (e.g.; ``vectorize_width``, ``unroll_count``). Pragmas setting transformation options; imply the transformation is enabled, as if it was enabled via the corresponding; transformation pragma (e.g. ``vectorize(enable)``). If the transformation is; disabled (e.g. ``vectorize(disable)``), that takes precedence over; transformations option pragmas implying that transformation. Vectorization, Interleaving, and Predication; --------------------------------------------. A vectorized loop performs multiple iterations of the original loop; in parallel using vector instructions. The instruction set of the target; processor determines which vector instructions are available and their vector; widths. This restricts the types of loops that can be vectorized. The vectorizer; automatically determines if the loop is safe and profitable to vectorize. A; vector instruction cost model is used to select the vector width. Interleaving multiple loop iterations allows modern processors to further; improve instruction-level parallelism (ILP) using advanced hardware features,; such as multiple execution units and out-of-order execution. The vectorizer uses; a cost model that depends on the register pressure and generated code size to; select the interleaving count. Vectorization is enabled by ``vectorize(enable)`` and interleaving is enabled; by ``interleave(enable)``. This is useful when compiling with ``-Os`` to; manually enable vectorization or interleaving. .. code-block:: c++. #pragma clang loop vectorize(enable); #pragma clang loop interleave(enable); for(...) {; ...; }. The vector width is specified by; ``vectorize_width(_value_[, fixed|scalable])``, where _value_ is a positive; integer and the type of vectorization can be specified with an optional; second parameter. The default for the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:169375,Safety,safe,safe,169375," loop distribute(enable); for (i = 0; i < N; ++i) {; S1: A[i + 1] = A[i] + B[i];; S2: C[i] = D[i] * E[i];; }. This loop will be split into two loops between statements S1 and S2. The; second loop containing S2 will be vectorized. Loop Distribution is currently not enabled by default in the optimizer because; it can hurt performance in some cases. For example, instruction-level; parallelism could be reduced by sequentializing the execution of the; statements S1 and S2 above. If Loop Distribution is turned on globally with; ``-mllvm -enable-loop-distribution``, specifying ``distribute(disable)`` can; be used the disable it on a per-loop basis. Additional Information; ----------------------. For convenience multiple loop hints can be specified on a single line. .. code-block:: c++. #pragma clang loop vectorize_width(4) interleave_count(8); for(...) {; ...; }. If an optimization cannot be applied any hints that apply to it will be ignored.; For example, the hint ``vectorize_width(4)`` is ignored if the loop is not; proven safe to vectorize. To identify and diagnose optimization issues use; `-Rpass`, `-Rpass-missed`, and `-Rpass-analysis` command line options. See the; user guide for details. Extensions to specify floating-point flags; ====================================================. The ``#pragma clang fp`` pragma allows floating-point options to be specified; for a section of the source code. This pragma can only appear at file scope or; at the start of a compound statement (excluding comments). When using within a; compound statement, the pragma is active within the scope of the compound; statement. Currently, the following settings can be controlled with this pragma:. ``#pragma clang fp reassociate`` allows control over the reassociation; of floating point expressions. When enabled, this pragma allows the expression; ``x + (y + z)`` to be reassociated as ``(x + y) + z``.; Reassociation can also occur across multiple statements.; This pragma can be used to disable",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:175895,Safety,unsafe,unsafe-floating,175895,"ting-point; semantics and floating-point exception behavior to be specified; for a section of the source code. This pragma can only appear at file or; namespace scope, within a language linkage specification or at the start of a; compound statement (excluding comments). When used within a compound statement,; the pragma is active within the scope of the compound statement. This pragma; is modeled after a Microsoft pragma with the same spelling and syntax. For; pragmas specified at file or namespace scope, or within a language linkage; specification, a stack is supported so that the ``pragma float_control``; settings can be pushed or popped. When ``pragma float_control(precise, on)`` is enabled, the section of code; governed by the pragma uses precise floating point semantics, effectively; ``-ffast-math`` is disabled and ``-ffp-contract=on``; (fused multiply add) is enabled. This pragma enables ``-fmath-errno``. When ``pragma float_control(precise, off)`` is enabled, unsafe-floating point; optimizations are enabled in the section of code governed by the pragma.; Effectively ``-ffast-math`` is enabled and ``-ffp-contract=fast``. This pragma; disables ``-fmath-errno``. When ``pragma float_control(except, on)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-exception-behavior=strict`` is enabled,; when ``pragma float_control(except, off)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-exception-behavior=ignore`` is enabled. The full syntax this pragma supports is; ``float_control(except|precise, on|off [, push])`` and; ``float_control(push|pop)``.; The ``push`` and ``pop`` forms, including using ``push`` as the optional; third argument, can only occur at file scope. .. code-block:: c++. for(...) {; // This block will be compiled with -fno-fast-math and -ffp-contract=on; #pragma float_control(precise, on); a = b[i] * c[i] + e;; }. Specifying an attribute",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:188797,Safety,safe,safer,188797,"bal is taken in the back-end.; Once the section-kind is known, appropriate section name, as specified by the user using; ``#pragma clang section`` directive, is applied to that global. Specifying Linker Options on ELF Targets; ========================================. The ``#pragma comment(lib, ...)`` directive is supported on all ELF targets.; The second parameter is the library name (without the traditional Unix prefix of; ``lib``). This allows you to provide an implicit link of dependent libraries. Evaluating Object Size Dynamically; ==================================. Clang supports the builtin ``__builtin_dynamic_object_size``, the semantics are; the same as GCC's ``__builtin_object_size`` (which Clang also supports), but; ``__builtin_dynamic_object_size`` can evaluate the object's size at runtime.; ``__builtin_dynamic_object_size`` is meant to be used as a drop-in replacement; for ``__builtin_object_size`` in libraries that support it. For instance, here is a program that ``__builtin_dynamic_object_size`` will make; safer:. .. code-block:: c. void copy_into_buffer(size_t size) {; char* buffer = malloc(size);; strlcpy(buffer, ""some string"", strlen(""some string""));; // Previous line preprocesses to:; // __builtin___strlcpy_chk(buffer, ""some string"", strlen(""some string""), __builtin_object_size(buffer, 0)); }. Since the size of ``buffer`` can't be known at compile time, Clang will fold; ``__builtin_object_size(buffer, 0)`` into ``-1``. However, if this was written; as ``__builtin_dynamic_object_size(buffer, 0)``, Clang will fold it into; ``size``, providing some extra runtime safety. Deprecating Macros; ==================. Clang supports the pragma ``#pragma clang deprecated``, which can be used to; provide deprecation warnings for macro uses. For example:. .. code-block:: c. #define MIN(x, y) x < y ? x : y; #pragma clang deprecated(MIN, ""use std::min instead""). int min(int a, int b) {; return MIN(a, b); // warning: MIN is deprecated: use std::min instead; }. ``#",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:189365,Safety,safe,safety,189365,"ally; ==================================. Clang supports the builtin ``__builtin_dynamic_object_size``, the semantics are; the same as GCC's ``__builtin_object_size`` (which Clang also supports), but; ``__builtin_dynamic_object_size`` can evaluate the object's size at runtime.; ``__builtin_dynamic_object_size`` is meant to be used as a drop-in replacement; for ``__builtin_object_size`` in libraries that support it. For instance, here is a program that ``__builtin_dynamic_object_size`` will make; safer:. .. code-block:: c. void copy_into_buffer(size_t size) {; char* buffer = malloc(size);; strlcpy(buffer, ""some string"", strlen(""some string""));; // Previous line preprocesses to:; // __builtin___strlcpy_chk(buffer, ""some string"", strlen(""some string""), __builtin_object_size(buffer, 0)); }. Since the size of ``buffer`` can't be known at compile time, Clang will fold; ``__builtin_object_size(buffer, 0)`` into ``-1``. However, if this was written; as ``__builtin_dynamic_object_size(buffer, 0)``, Clang will fold it into; ``size``, providing some extra runtime safety. Deprecating Macros; ==================. Clang supports the pragma ``#pragma clang deprecated``, which can be used to; provide deprecation warnings for macro uses. For example:. .. code-block:: c. #define MIN(x, y) x < y ? x : y; #pragma clang deprecated(MIN, ""use std::min instead""). int min(int a, int b) {; return MIN(a, b); // warning: MIN is deprecated: use std::min instead; }. ``#pragma clang deprecated`` should be preferred for this purpose over; ``#pragma GCC warning`` because the warning can be controlled with; ``-Wdeprecated``. Restricted Expansion Macros; ===========================. Clang supports the pragma ``#pragma clang restrict_expansion``, which can be; used restrict macro expansion in headers. This can be valuable when providing; headers with ABI stability requirements. Any expansion of the annotated macro; processed by the preprocessor after the ``#pragma`` annotation will log a; warning. Redef",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:190608,Safety,unsafe,unsafe,190608,"ang deprecated(MIN, ""use std::min instead""). int min(int a, int b) {; return MIN(a, b); // warning: MIN is deprecated: use std::min instead; }. ``#pragma clang deprecated`` should be preferred for this purpose over; ``#pragma GCC warning`` because the warning can be controlled with; ``-Wdeprecated``. Restricted Expansion Macros; ===========================. Clang supports the pragma ``#pragma clang restrict_expansion``, which can be; used restrict macro expansion in headers. This can be valuable when providing; headers with ABI stability requirements. Any expansion of the annotated macro; processed by the preprocessor after the ``#pragma`` annotation will log a; warning. Redefining the macro or undefining the macro will not be diagnosed, nor; will expansion of the macro within the main source file. For example:. .. code-block:: c. #define TARGET_ARM 1; #pragma clang restrict_expansion(TARGET_ARM, ""<reason>""). /// Foo.h; struct Foo {; #if TARGET_ARM // warning: TARGET_ARM is marked unsafe in headers: <reason>; uint32_t X;; #else; uint64_t X;; #endif; };. /// main.c; #include ""foo.h""; #if TARGET_ARM // No warning in main source file; X_TYPE uint32_t; #else; X_TYPE uint64_t; #endif. This warning is controlled by ``-Wpedantic-macros``. Final Macros; ============. Clang supports the pragma ``#pragma clang final``, which can be used to; mark macros as final, meaning they cannot be undef'd or re-defined. For example:. .. code-block:: c. #define FINAL_MACRO 1; #pragma clang final(FINAL_MACRO). #define FINAL_MACRO // warning: FINAL_MACRO is marked final and should not be redefined; #undef FINAL_MACRO // warning: FINAL_MACRO is marked final and should not be undefined. This is useful for enforcing system-provided macros that should not be altered; in user headers or code. This is controlled by ``-Wpedantic-macros``. Final; macros will always warn on redefinition, including situations with identical; bodies and in system headers. Line Control; ============. Clang supports an e",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:6522,Security,expose,exposed,6522,"-documents/sd-6-sg10-feature-test-recommendations>`_; for the list of values returned for standards-based attributes. If the attribute; is not supported by the current compilation target, this macro evaluates to 0.; It can be used like this:. .. code-block:: c++. #ifndef __has_cpp_attribute // For backwards compatibility; #define __has_cpp_attribute(x) 0; #endif. ...; #if __has_cpp_attribute(clang::fallthrough); #define FALLTHROUGH [[clang::fallthrough]]; #else; #define FALLTHROUGH; #endif; ... The attribute scope tokens ``clang`` and ``_Clang`` are interchangeable, as are; the attribute scope tokens ``gnu`` and ``__gnu__``. Attribute tokens in either; of these namespaces can be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``gnu::__const__`` can be used instead of ``gnu::const``. ``__has_c_attribute``; ---------------------. This function-like macro takes a single argument that is the name of an; attribute exposed with the double square-bracket syntax in C mode. The argument; can either be a single identifier or a scoped identifier. If the attribute is; supported, a nonzero value is returned. If the attribute is not supported by the; current compilation target, this macro evaluates to 0. It can be used like this:. .. code-block:: c. #ifndef __has_c_attribute // Optional of course.; #define __has_c_attribute(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_c_attribute(fallthrough); #define FALLTHROUGH [[fallthrough]]; #else; #define FALLTHROUGH; #endif; ... The attribute scope tokens ``clang`` and ``_Clang`` are interchangeable, as are; the attribute scope tokens ``gnu`` and ``__gnu__``. Attribute tokens in either; of these namespaces can be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``gnu::__const__`` can be used instead of ``gnu::const``. ``__has_attribute",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:17528,Security,access,access,17528," legal for Clang, error for GCC:; typedef bool bool4 __attribute__((ext_vector_type(4)));; // Objects of bool4 type hold 8 bits, sizeof(bool4) == 1. bool4 foo(bool4 a) {; bool4 v;; v = a;; return v;; }. Boolean vectors are a Clang extension of the ext vector type. Boolean vectors; are intended, though not guaranteed, to map to vector mask registers. The size; parameter of a boolean vector type is the number of bits in the vector. The; boolean vector is dense and each bit in the boolean vector is one vector; element. The semantics of boolean vectors borrows from C bit-fields with the following; differences:. * Distinct boolean vectors are always distinct memory objects (there is no; packing).; * Only the operators `?:`, `!`, `~`, `|`, `&`, `^` and comparison are allowed on; boolean vectors.; * Casting a scalar bool value to a boolean vector type means broadcasting the; scalar value onto all lanes (same as general ext_vector_type).; * It is not possible to access or swizzle elements of a boolean vector; (different than general ext_vector_type). The size and alignment are both the number of bits rounded up to the next power; of two, but the alignment is at most the maximum vector alignment of the; target. Vector Literals; ---------------. Vector literals can be used to create vectors from a set of scalars, or; vectors. Either parentheses or braces form can be used. In the parentheses; form the number of literal values specified must be one, i.e. referring to a; scalar value, or must match the size of the vector type being created. If a; single scalar literal value is specified, the scalar literal value will be; replicated to all the components of the vector type. In the brackets form any; number of literals can be specified. For example:. .. code-block:: c++. typedef int v4si __attribute__((__vector_size__(16)));; typedef float float4 __attribute__((ext_vector_type(4)));; typedef float float2 __attribute__((ext_vector_type(2)));. v4si vsi = (v4si){1, 2, 3, 4};; float4 v",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:40139,Security,access,access,40139,"way to query the supported features of the compiler.; See `the C++ status page <https://clang.llvm.org/cxx_status.html#ts>`_ for; information on the version of SD-6 supported by each Clang release, and the; macros provided by that revision of the recommendations. C++98; -----. The features listed below are part of the C++98 standard. These features are; enabled by default when compiling C++ code. C++ exceptions; ^^^^^^^^^^^^^^. Use ``__has_feature(cxx_exceptions)`` to determine if C++ exceptions have been; enabled. For example, compiling code with ``-fno-exceptions`` disables C++; exceptions. C++ RTTI; ^^^^^^^^. Use ``__has_feature(cxx_rtti)`` to determine if C++ RTTI has been enabled. For; example, compiling code with ``-fno-rtti`` disables the use of RTTI. C++11; -----. The features listed below are part of the C++11 standard. As a result, all; these features are enabled with the ``-std=c++11`` or ``-std=gnu++11`` option; when compiling C++ code. C++11 SFINAE includes access control; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_access_control_sfinae)`` or; ``__has_extension(cxx_access_control_sfinae)`` to determine whether; access-control errors (e.g., calling a private constructor) are considered to; be template argument deduction errors (aka SFINAE errors), per `C++ DR1170; <http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1170>`_. C++11 alias templates; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_alias_templates)`` or; ``__has_extension(cxx_alias_templates)`` to determine if support for C++11's; alias declarations and alias templates is enabled. C++11 alignment specifiers; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_alignas)`` or ``__has_extension(cxx_alignas)`` to; determine if support for alignment specifiers using ``alignas`` is enabled. Use ``__has_feature(cxx_alignof)`` or ``__has_extension(cxx_alignof)`` to; determine if support for the ``alignof`` keyword is enabled. C++11 attributes; ^^^^^^^^^^^^^^^^. Use ``__has_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:40315,Security,access,access-control,40315,"s.html#ts>`_ for; information on the version of SD-6 supported by each Clang release, and the; macros provided by that revision of the recommendations. C++98; -----. The features listed below are part of the C++98 standard. These features are; enabled by default when compiling C++ code. C++ exceptions; ^^^^^^^^^^^^^^. Use ``__has_feature(cxx_exceptions)`` to determine if C++ exceptions have been; enabled. For example, compiling code with ``-fno-exceptions`` disables C++; exceptions. C++ RTTI; ^^^^^^^^. Use ``__has_feature(cxx_rtti)`` to determine if C++ RTTI has been enabled. For; example, compiling code with ``-fno-rtti`` disables the use of RTTI. C++11; -----. The features listed below are part of the C++11 standard. As a result, all; these features are enabled with the ``-std=c++11`` or ``-std=gnu++11`` option; when compiling C++ code. C++11 SFINAE includes access control; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_access_control_sfinae)`` or; ``__has_extension(cxx_access_control_sfinae)`` to determine whether; access-control errors (e.g., calling a private constructor) are considered to; be template argument deduction errors (aka SFINAE errors), per `C++ DR1170; <http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1170>`_. C++11 alias templates; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_alias_templates)`` or; ``__has_extension(cxx_alias_templates)`` to determine if support for C++11's; alias declarations and alias templates is enabled. C++11 alignment specifiers; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_alignas)`` or ``__has_extension(cxx_alignas)`` to; determine if support for alignment specifiers using ``alignas`` is enabled. Use ``__has_feature(cxx_alignof)`` or ``__has_extension(cxx_alignof)`` to; determine if support for the ``alignof`` keyword is enabled. C++11 attributes; ^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_attributes)`` or ``__has_extension(cxx_attributes)`` to; determine if support for attribute parsing ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:70466,Security,access,access,70466,"objc. @interface A; + (instancetype)constructAnA;; @end. The related result type can also be inferred for some methods. To determine; whether a method has an inferred related result type, the first word in the; camel-case selector (e.g., ""``init``"" in ""``initWithObjects``"") is considered,; and the method will have a related result type if its return type is compatible; with the type of its class and if:. * the first word is ""``alloc``"" or ""``new``"", and the method is a class method,; or. * the first word is ""``autorelease``"", ""``init``"", ""``retain``"", or ""``self``"",; and the method is an instance method. If a method with a related result type is overridden by a subclass method, the; subclass method must also return a type that is compatible with the subclass; type. For example:. .. code-block:: objc. @interface NSString : NSObject; - (NSUnrelated *)init; // incorrect usage: NSUnrelated is not NSString or a superclass of NSString; @end. Related result types only affect the type of a message send or property access; via the given method. In all other respects, a method with a related result; type is treated the same way as method that returns ``id``. Use ``__has_feature(objc_instancetype)`` to determine whether the; ``instancetype`` contextual keyword is available. Automatic reference counting; ----------------------------. Clang provides support for :doc:`automated reference counting; <AutomaticReferenceCounting>` in Objective-C, which eliminates the need; for manual ``retain``/``release``/``autorelease`` message sends. There are three; feature macros associated with automatic reference counting:; ``__has_feature(objc_arc)`` indicates the availability of automated reference; counting in general, while ``__has_feature(objc_arc_weak)`` indicates that; automated reference counting also includes support for ``__weak`` pointers to; Objective-C objects. ``__has_feature(objc_arc_fields)`` indicates that C structs; are allowed to have fields that are pointers to Objective-C ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:89759,Security,access,accessed,89759,"uments e.g. majority of CPU targets. **Example of Use**:. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_variadic_functions : enable; void foo(int a, ...); // compiled - no diagnostic generated. #pragma OPENCL EXTENSION __cl_clang_variadic_functions : disable; void bar(int a, ...); // error - variadic prototype is not allowed. ``__cl_clang_non_portable_kernel_param_types``; ----------------------------------------------. With this extension it is possible to enable the use of some restricted types; in kernel parameters specified in `C++ for OpenCL v1.0 s2.4; <https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html#kernel_function>`_.; The restrictions can be relaxed using regular OpenCL extension pragma mechanism; detailed in `the OpenCL Extension Specification, section 1.2; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview>`_. This is not a conformant behavior and it can only be used when the; kernel arguments are not accessed on the host side or the data layout/size; between the host and device is known to be compatible. **Example of Use**:. .. code-block:: c++. // Plain Old Data type.; struct Pod {; int a;; int b;; };. // Not POD type because of the constructor.; // Standard layout type because there is only one access control.; struct OnlySL {; int a;; int b;; OnlySL() : a(0), b(0) {}; };. // Not standard layout type because of two different access controls.; struct NotSL {; int a;; private:; int b;; };. #pragma OPENCL EXTENSION __cl_clang_non_portable_kernel_param_types : enable; kernel void kernel_main(; Pod a,. OnlySL b,; global NotSL *c,; global OnlySL *d; );; #pragma OPENCL EXTENSION __cl_clang_non_portable_kernel_param_types : disable. Remove address space builtin function; -------------------------------------. ``__remove_address_space`` allows to derive types in C++ for OpenCL; that have address space qualifiers removed. This utility only affects; address space qualifiers, therefore, other type",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:90061,Security,access,access,90061,"r(int a, ...); // error - variadic prototype is not allowed. ``__cl_clang_non_portable_kernel_param_types``; ----------------------------------------------. With this extension it is possible to enable the use of some restricted types; in kernel parameters specified in `C++ for OpenCL v1.0 s2.4; <https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html#kernel_function>`_.; The restrictions can be relaxed using regular OpenCL extension pragma mechanism; detailed in `the OpenCL Extension Specification, section 1.2; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview>`_. This is not a conformant behavior and it can only be used when the; kernel arguments are not accessed on the host side or the data layout/size; between the host and device is known to be compatible. **Example of Use**:. .. code-block:: c++. // Plain Old Data type.; struct Pod {; int a;; int b;; };. // Not POD type because of the constructor.; // Standard layout type because there is only one access control.; struct OnlySL {; int a;; int b;; OnlySL() : a(0), b(0) {}; };. // Not standard layout type because of two different access controls.; struct NotSL {; int a;; private:; int b;; };. #pragma OPENCL EXTENSION __cl_clang_non_portable_kernel_param_types : enable; kernel void kernel_main(; Pod a,. OnlySL b,; global NotSL *c,; global OnlySL *d; );; #pragma OPENCL EXTENSION __cl_clang_non_portable_kernel_param_types : disable. Remove address space builtin function; -------------------------------------. ``__remove_address_space`` allows to derive types in C++ for OpenCL; that have address space qualifiers removed. This utility only affects; address space qualifiers, therefore, other type qualifiers such as; ``const`` or ``volatile`` remain unchanged. **Example of Use**:. .. code-block:: c++. template<typename T>; void foo(T *par){; T var1; // error - local function variable with global address space; __private T var2; // error - conflicting address space quali",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:90194,Security,access,access,90194,"----------------------. With this extension it is possible to enable the use of some restricted types; in kernel parameters specified in `C++ for OpenCL v1.0 s2.4; <https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html#kernel_function>`_.; The restrictions can be relaxed using regular OpenCL extension pragma mechanism; detailed in `the OpenCL Extension Specification, section 1.2; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview>`_. This is not a conformant behavior and it can only be used when the; kernel arguments are not accessed on the host side or the data layout/size; between the host and device is known to be compatible. **Example of Use**:. .. code-block:: c++. // Plain Old Data type.; struct Pod {; int a;; int b;; };. // Not POD type because of the constructor.; // Standard layout type because there is only one access control.; struct OnlySL {; int a;; int b;; OnlySL() : a(0), b(0) {}; };. // Not standard layout type because of two different access controls.; struct NotSL {; int a;; private:; int b;; };. #pragma OPENCL EXTENSION __cl_clang_non_portable_kernel_param_types : enable; kernel void kernel_main(; Pod a,. OnlySL b,; global NotSL *c,; global OnlySL *d; );; #pragma OPENCL EXTENSION __cl_clang_non_portable_kernel_param_types : disable. Remove address space builtin function; -------------------------------------. ``__remove_address_space`` allows to derive types in C++ for OpenCL; that have address space qualifiers removed. This utility only affects; address space qualifiers, therefore, other type qualifiers such as; ``const`` or ``volatile`` remain unchanged. **Example of Use**:. .. code-block:: c++. template<typename T>; void foo(T *par){; T var1; // error - local function variable with global address space; __private T var2; // error - conflicting address space qualifiers; __private __remove_address_space<T>::type var3; // var3 is __private int; }. void bar(){; __global int* ptr;; foo(ptr);; }. L",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:102889,Security,access,access,102889,"e with ``__has_builtin(__builtin_offsetof)``. ``__builtin_call_with_static_chain``; ------------------------------------. ``__builtin_call_with_static_chain`` is used to perform a static call while; setting updating the static chain register. **Syntax**:. .. code-block:: c++. T __builtin_call_with_static_chain(T expr, void* ptr). **Example of Use**:. .. code-block:: c++. auto v = __builtin_call_with_static_chain(foo(3), foo);. **Description**:. This builtin returns ``expr`` after checking that ``expr`` is a non-member; static call expression. The call to that expression is made while using ``ptr``; as a function pointer stored in a dedicated register to implement *static chain*; calling convention, as used by some language to implement closures or nested; functions. Query for this feature with ``__has_builtin(__builtin_call_with_static_chain)``. ``__builtin_readcyclecounter``; ------------------------------. ``__builtin_readcyclecounter`` is used to access the cycle counter register (or; a similar low-latency, high-accuracy clock) on those targets that support it. **Syntax**:. .. code-block:: c++. __builtin_readcyclecounter(). **Example of Use**:. .. code-block:: c++. unsigned long long t0 = __builtin_readcyclecounter();; do_something();; unsigned long long t1 = __builtin_readcyclecounter();; unsigned long long cycles_to_do_something = t1 - t0; // assuming no overflow. **Description**:. The ``__builtin_readcyclecounter()`` builtin returns the cycle counter value,; which may be either global or process/thread-specific depending on the target.; As the backing counters often overflow quickly (on the order of seconds) this; should only be used for timing small intervals. When not supported by the; target, the return value is always zero. This builtin takes no arguments and; produces an unsigned long long result. Query for this feature with ``__has_builtin(__builtin_readcyclecounter)``. Note; that even if present, its use may depend on run-time privilege or other OS; cont",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:116102,Security,access,access,116102," statements to help; branch prediction. It means that its first argument ``expr`` is expected to take; the value of its second argument ``val`` with probability ``p``. ``p`` must be; within ``[0.0 ; 1.0]`` bounds. This builtin always returns the value of ``expr``. Query for this feature with ``__has_builtin(__builtin_expect_with_probability)``. ``__builtin_prefetch``; ----------------------. ``__builtin_prefetch`` is used to communicate with the cache handler to bring; data into the cache before it gets used. **Syntax**:. .. code-block:: c++. void __builtin_prefetch(const void *addr, int rw=0, int locality=3). **Example of use**:. .. code-block:: c++. __builtin_prefetch(a + i);. **Description**:. The ``__builtin_prefetch(addr, rw, locality)`` builtin is expected to be used to; avoid cache misses when the developer has a good understanding of which data; are going to be used next. ``addr`` is the address that needs to be brought into; the cache. ``rw`` indicates the expected access mode: ``0`` for *read* and ``1``; for *write*. In case of *read write* access, ``1`` is to be used. ``locality``; indicates the expected persistence of data in cache, from ``0`` which means that; data can be discarded from cache after its next use to ``3`` which means that; data is going to be reused a lot once in cache. ``1`` and ``2`` provide; intermediate behavior between these two extremes. Query for this feature with ``__has_builtin(__builtin_prefetch)``. ``__sync_swap``; ---------------. ``__sync_swap`` is used to atomically swap integers or pointers in memory. **Syntax**:. .. code-block:: c++. type __sync_swap(type *ptr, type value, ...). **Example of Use**:. .. code-block:: c++. int old_value = __sync_swap(&value, new_value);. **Description**:. The ``__sync_swap()`` builtin extends the existing ``__sync_*()`` family of; atomic intrinsics to allow code to atomically swap the current value with the; new value. More importantly, it helps developers write more efficient and; correct co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:116180,Security,access,access,116180,"ment ``expr`` is expected to take; the value of its second argument ``val`` with probability ``p``. ``p`` must be; within ``[0.0 ; 1.0]`` bounds. This builtin always returns the value of ``expr``. Query for this feature with ``__has_builtin(__builtin_expect_with_probability)``. ``__builtin_prefetch``; ----------------------. ``__builtin_prefetch`` is used to communicate with the cache handler to bring; data into the cache before it gets used. **Syntax**:. .. code-block:: c++. void __builtin_prefetch(const void *addr, int rw=0, int locality=3). **Example of use**:. .. code-block:: c++. __builtin_prefetch(a + i);. **Description**:. The ``__builtin_prefetch(addr, rw, locality)`` builtin is expected to be used to; avoid cache misses when the developer has a good understanding of which data; are going to be used next. ``addr`` is the address that needs to be brought into; the cache. ``rw`` indicates the expected access mode: ``0`` for *read* and ``1``; for *write*. In case of *read write* access, ``1`` is to be used. ``locality``; indicates the expected persistence of data in cache, from ``0`` which means that; data can be discarded from cache after its next use to ``3`` which means that; data is going to be reused a lot once in cache. ``1`` and ``2`` provide; intermediate behavior between these two extremes. Query for this feature with ``__has_builtin(__builtin_prefetch)``. ``__sync_swap``; ---------------. ``__sync_swap`` is used to atomically swap integers or pointers in memory. **Syntax**:. .. code-block:: c++. type __sync_swap(type *ptr, type value, ...). **Example of Use**:. .. code-block:: c++. int old_value = __sync_swap(&value, new_value);. **Description**:. The ``__sync_swap()`` builtin extends the existing ``__sync_*()`` family of; atomic intrinsics to allow code to atomically swap the current value with the; new value. More importantly, it helps developers write more efficient and; correct code by avoiding expensive loops around; ``__sync_bool_compare_and_swap",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:120556,Security,access,access,120556,"lete`` is exactly the same as a call to; ``::operator delete(args)``, except that it permits optimizations; and that the call is required to resolve to a; `replaceable global deallocation function; <https://en.cppreference.com/w/cpp/memory/new/operator_delete>`_. These builtins are intended for use in the implementation of ``std::allocator``; and other similar allocation libraries, and are only available in C++. Query for this feature with ``__has_builtin(__builtin_operator_new)`` or; ``__has_builtin(__builtin_operator_delete)``:. * If the value is at least ``201802L``, the builtins behave as described above. * If the value is non-zero, the builtins may not support calling arbitrary; replaceable global (de)allocation functions, but do support calling at least; ``::operator new(size_t)`` and ``::operator delete(void*)``. ``__builtin_preserve_access_index``; -----------------------------------. ``__builtin_preserve_access_index`` specifies a code section where; array subscript access and structure/union member access are relocatable; under bpf compile-once run-everywhere framework. Debuginfo (typically; with ``-g``) is needed, otherwise, the compiler will exit with an error.; The return type for the intrinsic is the same as the type of the; argument. **Syntax**:. .. code-block:: c. type __builtin_preserve_access_index(type arg). **Example of Use**:. .. code-block:: c. struct t {; int i;; int j;; union {; int a;; int b;; } c[4];; };; struct t *v = ...;; int *pb =__builtin_preserve_access_index(&v->c[3].b);; __builtin_preserve_access_index(v->j);. ``__builtin_debugtrap``; -----------------------. ``__builtin_debugtrap`` causes the program to stop its execution in such a way that a debugger can catch it. **Syntax**:. .. code-block:: c++. __builtin_debugtrap(). **Description**. ``__builtin_debugtrap`` is lowered to the ` ``llvm.debugtrap`` <https://llvm.org/docs/LangRef.html#llvm-debugtrap-intrinsic>`_ builtin. It should have the same effect as setting a breakpoint on the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:120590,Security,access,access,120590,"lete`` is exactly the same as a call to; ``::operator delete(args)``, except that it permits optimizations; and that the call is required to resolve to a; `replaceable global deallocation function; <https://en.cppreference.com/w/cpp/memory/new/operator_delete>`_. These builtins are intended for use in the implementation of ``std::allocator``; and other similar allocation libraries, and are only available in C++. Query for this feature with ``__has_builtin(__builtin_operator_new)`` or; ``__has_builtin(__builtin_operator_delete)``:. * If the value is at least ``201802L``, the builtins behave as described above. * If the value is non-zero, the builtins may not support calling arbitrary; replaceable global (de)allocation functions, but do support calling at least; ``::operator new(size_t)`` and ``::operator delete(void*)``. ``__builtin_preserve_access_index``; -----------------------------------. ``__builtin_preserve_access_index`` specifies a code section where; array subscript access and structure/union member access are relocatable; under bpf compile-once run-everywhere framework. Debuginfo (typically; with ``-g``) is needed, otherwise, the compiler will exit with an error.; The return type for the intrinsic is the same as the type of the; argument. **Syntax**:. .. code-block:: c. type __builtin_preserve_access_index(type arg). **Example of Use**:. .. code-block:: c. struct t {; int i;; int j;; union {; int a;; int b;; } c[4];; };; struct t *v = ...;; int *pb =__builtin_preserve_access_index(&v->c[3].b);; __builtin_preserve_access_index(v->j);. ``__builtin_debugtrap``; -----------------------. ``__builtin_debugtrap`` causes the program to stop its execution in such a way that a debugger can catch it. **Syntax**:. .. code-block:: c++. __builtin_debugtrap(). **Description**. ``__builtin_debugtrap`` is lowered to the ` ``llvm.debugtrap`` <https://llvm.org/docs/LangRef.html#llvm-debugtrap-intrinsic>`_ builtin. It should have the same effect as setting a breakpoint on the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:124415,Security,expose,expose,124415,"s value encodes lambda functions based on a; stable numbering order in which they appear in their local declaration contexts.; Once this builtin is evaluated in a constexpr context, it is erroneous to use; it in an instantiation which changes its value. In order to produce the unique name, the current implementation of the builtin; uses Itanium mangling even if the host compilation uses a different name; mangling scheme at runtime. The mangler marks all the lambdas required to name; the SYCL kernel and emits a stable local ordering of the respective lambdas.; The resulting pattern is demanglable. When non-lambda types are passed to the; builtin, the mangler emits their usual pattern without any special treatment. **Syntax**:. .. code-block:: c. // Computes a unique stable name for the given type.; constexpr const char * __builtin_sycl_unique_stable_name( type-id );. Multiprecision Arithmetic Builtins; ----------------------------------. Clang provides a set of builtins which expose multiprecision arithmetic in a; manner amenable to C. They all have the following form:. .. code-block:: c. unsigned x = ..., y = ..., carryin = ..., carryout;; unsigned sum = __builtin_addc(x, y, carryin, &carryout);. Thus one can form a multiprecision addition chain in the following manner:. .. code-block:: c. unsigned *x, *y, *z, carryin=0, carryout;; z[0] = __builtin_addc(x[0], y[0], carryin, &carryout);; carryin = carryout;; z[1] = __builtin_addc(x[1], y[1], carryin, &carryout);; carryin = carryout;; z[2] = __builtin_addc(x[2], y[2], carryin, &carryout);; carryin = carryout;; z[3] = __builtin_addc(x[3], y[3], carryin, &carryout);. The complete list of builtins are:. .. code-block:: c. unsigned char __builtin_addcb (unsigned char x, unsigned char y, unsigned char carryin, unsigned char *carryout);; unsigned short __builtin_addcs (unsigned short x, unsigned short y, unsigned short carryin, unsigned short *carryout);; unsigned __builtin_addc (unsigned x, unsigned y, unsigned carryin, un",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:126408,Security,secur,security,126408,"carryin, unsigned *carryout);; unsigned long __builtin_addcl (unsigned long x, unsigned long y, unsigned long carryin, unsigned long *carryout);; unsigned long long __builtin_addcll(unsigned long long x, unsigned long long y, unsigned long long carryin, unsigned long long *carryout);; unsigned char __builtin_subcb (unsigned char x, unsigned char y, unsigned char carryin, unsigned char *carryout);; unsigned short __builtin_subcs (unsigned short x, unsigned short y, unsigned short carryin, unsigned short *carryout);; unsigned __builtin_subc (unsigned x, unsigned y, unsigned carryin, unsigned *carryout);; unsigned long __builtin_subcl (unsigned long x, unsigned long y, unsigned long carryin, unsigned long *carryout);; unsigned long long __builtin_subcll(unsigned long long x, unsigned long long y, unsigned long long carryin, unsigned long long *carryout);. Checked Arithmetic Builtins; ---------------------------. Clang provides a set of builtins that implement checked arithmetic for security; critical applications in a manner that is fast and easily expressible in C. As; an example of their usage:. .. code-block:: c. errorcode_t security_critical_application(...) {; unsigned x, y, result;; ...; if (__builtin_mul_overflow(x, y, &result)); return kErrorCodeHackers;; ...; use_multiply(result);; ...; }. Clang provides the following checked arithmetic builtins:. .. code-block:: c. bool __builtin_add_overflow (type1 x, type2 y, type3 *sum);; bool __builtin_sub_overflow (type1 x, type2 y, type3 *diff);; bool __builtin_mul_overflow (type1 x, type2 y, type3 *prod);; bool __builtin_uadd_overflow (unsigned x, unsigned y, unsigned *sum);; bool __builtin_uaddl_overflow (unsigned long x, unsigned long y, unsigned long *sum);; bool __builtin_uaddll_overflow(unsigned long long x, unsigned long long y, unsigned long long *sum);; bool __builtin_usub_overflow (unsigned x, unsigned y, unsigned *diff);; bool __builtin_usubl_overflow (unsigned long x, unsigned long y, unsigned long *diff);; b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:133599,Security,access,accessing-the-floating-point-environment,133599,"` and ``__builtin_set_flt_rounds``; ---------------------------------------------------------. .. code-block:: c. int __builtin_flt_rounds();; void __builtin_set_flt_rounds(int);. Returns and sets current floating point rounding mode. The encoding of returned; values and input parameters is same as the result of FLT_ROUNDS, specified by C; standard:; - ``0`` - toward zero; - ``1`` - to nearest, ties to even; - ``2`` - toward positive infinity; - ``3`` - toward negative infinity; - ``4`` - to nearest, ties away from zero; The effect of passing some other value to ``__builtin_flt_rounds`` is; implementation-defined. ``__builtin_set_flt_rounds`` is currently only supported; to work on x86, x86_64, Arm and AArch64 targets. These builtins read and modify; the floating-point environment, which is not always allowed and may have unexpected; behavior. Please see the section on `Accessing the floating point environment <https://clang.llvm.org/docs/UsersManual.html#accessing-the-floating-point-environment>`_ for more information. String builtins; ---------------. Clang provides constant expression evaluation support for builtins forms of; the following functions from the C standard library headers; ``<string.h>`` and ``<wchar.h>``:. * ``memchr``; * ``memcmp`` (and its deprecated BSD / POSIX alias ``bcmp``); * ``strchr``; * ``strcmp``; * ``strlen``; * ``strncmp``; * ``wcschr``; * ``wcscmp``; * ``wcslen``; * ``wcsncmp``; * ``wmemchr``; * ``wmemcmp``. In each case, the builtin form has the name of the C library function prefixed; by ``__builtin_``. Example:. .. code-block:: c. void *p = __builtin_memchr(""foobar"", 'b', 5);. In addition to the above, one further builtin is provided:. .. code-block:: c. char *__builtin_char_memchr(const char *haystack, int needle, size_t size);. ``__builtin_char_memchr(a, b, c)`` is identical to; ``(char*)__builtin_memchr(a, b, c)`` except that its use is permitted within; constant expressions in C++11 onwards (where a cast from ``void*`` to ``char",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:137915,Security,access,accessible,137915,"he second argument. It is undefined behavior to call; this function with a ``list`` that has not been initialized by either; ``__builtin_va_start`` or ``__builtin_va_copy``. * ``void __builtin_va_copy(__builtin_va_list dest, __builtin_va_list src)``. A builtin function for the target-specific ``va_copy`` function-like macro.; This function initializes ``dest`` as a copy of ``src``. It is undefined; behavior to call this function with an already initialized ``dest`` argument. Memory builtins; ---------------. Clang provides constant expression evaluation support for builtin forms of the; following functions from the C standard library headers; ``<string.h>`` and ``<wchar.h>``:. * ``memcpy``; * ``memmove``; * ``wmemcpy``; * ``wmemmove``. In each case, the builtin form has the name of the C library function prefixed; by ``__builtin_``. Constant evaluation support is only provided when the source and destination; are pointers to arrays with the same trivially copyable element type, and the; given size is an exact multiple of the element size that is no greater than; the number of elements accessible through the source and destination operands. Guaranteed inlined copy; ^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c. void __builtin_memcpy_inline(void *dst, const void *src, size_t size);. ``__builtin_memcpy_inline`` has been designed as a building block for efficient; ``memcpy`` implementations. It is identical to ``__builtin_memcpy`` but also; guarantees not to call any external functions. See LLVM IR `llvm.memcpy.inline; <https://llvm.org/docs/LangRef.html#llvm-memcpy-inline-intrinsic>`_ intrinsic; for more information. This is useful to implement a custom version of ``memcpy``, implement a; ``libc`` memcpy or work around the absence of a ``libc``. Note that the `size` argument must be a compile time constant. Note that this intrinsic cannot yet be called in a ``constexpr`` context. Guaranteed inlined memset; ^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c. void __builtin_memset",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:143542,Security,access,access,143542,"he standard GNU / GCC atomic builtins but taking an extra; memory scope argument. These are designed to be a generic alternative to the; ``__opencl_atomic_*`` builtin functions for targets that support atomic memory; scopes. Atomic memory scopes are designed to assist optimizations for systems with; several levels of memory hierarchy like GPUs. The following memory scopes are; currently supported:. * ``__MEMORY_SCOPE_SYSTEM``; * ``__MEMORY_SCOPE_DEVICE``; * ``__MEMORY_SCOPE_WRKGRP``; * ``__MEMORY_SCOPE_WVFRNT``; * ``__MEMORY_SCOPE_SINGLE``. This controls whether or not the atomic operation is ordered with respect to the; whole system, the current device, an OpenCL workgroup, wavefront, or just a; single thread. If these are used on a target that does not support atomic; scopes, then they will behave exactly as the standard GNU atomic builtins. Low-level ARM exclusive memory builtins; ---------------------------------------. Clang provides overloaded builtins giving direct access to the three key ARM; instructions for implementing atomic operations. .. code-block:: c. T __builtin_arm_ldrex(const volatile T *addr);; T __builtin_arm_ldaex(const volatile T *addr);; int __builtin_arm_strex(T val, volatile T *addr);; int __builtin_arm_stlex(T val, volatile T *addr);; void __builtin_arm_clrex(void);. The types ``T`` currently supported are:. * Integer types with width at most 64 bits (or 128 bits on AArch64).; * Floating-point types; * Pointer types. Note that the compiler does not guarantee it will not insert stores which clear; the exclusive monitor in between an ``ldrex`` type operation and its paired; ``strex``. In practice this is only usually a risk when the extra store is on; the same cache line as the variable being modified and Clang will only insert; stack stores on its own, so it is best not to use these operations on variables; with automatic storage duration. Also, loads and stores may be implicit in code written between the ``ldrex`` and; ``strex``. Clang will",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:144878,Security,access,accesses,144878,"__builtin_arm_clrex(void);. The types ``T`` currently supported are:. * Integer types with width at most 64 bits (or 128 bits on AArch64).; * Floating-point types; * Pointer types. Note that the compiler does not guarantee it will not insert stores which clear; the exclusive monitor in between an ``ldrex`` type operation and its paired; ``strex``. In practice this is only usually a risk when the extra store is on; the same cache line as the variable being modified and Clang will only insert; stack stores on its own, so it is best not to use these operations on variables; with automatic storage duration. Also, loads and stores may be implicit in code written between the ``ldrex`` and; ``strex``. Clang will not necessarily mitigate the effects of these either, so; care should be exercised. For these reasons the higher level atomic primitives should be preferred where; possible. Non-temporal load/store builtins; --------------------------------. Clang provides overloaded builtins allowing generation of non-temporal memory; accesses. .. code-block:: c. T __builtin_nontemporal_load(T *addr);; void __builtin_nontemporal_store(T value, T *addr);. The types ``T`` currently supported are:. * Integer types.; * Floating-point types.; * Vector types. Note that the compiler does not guarantee that non-temporal loads or stores; will be used. C++ Coroutines support builtins; --------------------------------. .. warning::; This is a work in progress. Compatibility across Clang/LLVM releases is not; guaranteed. Clang provides experimental builtins to support C++ Coroutines as defined by; https://wg21.link/P0057. The following four are intended to be used by the; standard library to implement the ``std::coroutine_handle`` type. **Syntax**:. .. code-block:: c. void __builtin_coro_resume(void *addr);; void __builtin_coro_destroy(void *addr);; bool __builtin_coro_done(void *addr);; void *__builtin_coro_promise(void *addr, int alignment, bool from_promise). **Example of use**:. .. code-bl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:154885,Security,access,accesses,154885,"utes.html>`_, and; `GCC type attributes; <https://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html>`_). As with the GCC; implementation, these attributes must appertain to the *declarator-id* in a; declaration, which means they must go either at the start of the declaration or; immediately after the name being declared. For example, this applies the GNU ``unused`` attribute to ``a`` and ``f``, and; also applies the GNU ``noreturn`` attribute to ``f``. .. code-block:: c++. [[gnu::unused]] int a, f [[gnu::noreturn]] ();. Target-Specific Extensions; ==========================. Clang supports some language features conditionally on some targets. ARM/AArch64 Language Extensions; -------------------------------. Memory Barrier Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^; Clang implements the ``__dmb``, ``__dsb`` and ``__isb`` intrinsics as defined; in the `Arm C Language Extensions; <https://github.com/ARM-software/acle/releases>`_.; Note that these intrinsics are implemented as motion barriers that block; reordering of memory accesses and side effect instructions. Other instructions; like simple arithmetic may be reordered around the intrinsic. If you expect to; have no reordering at all, use inline assembly instead. X86/X86-64 Language Extensions; ------------------------------. The X86 backend has these language extensions:. Memory references to specified segments; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Annotating a pointer with address space #256 causes it to be code generated; relative to the X86 GS segment register, address space #257 causes it to be; relative to the X86 FS segment, and address space #258 causes it to be; relative to the X86 SS segment. Note that this is a very very low-level; feature that should only be used if you know what you're doing (for example in; an OS kernel). Here is an example:. .. code-block:: c++. #define GS_RELATIVE __attribute__((address_space(256))); int foo(int GS_RELATIVE *P) {; return *P;; }. Which compiles to (on X86-32):. .. code-blo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:157059,Security,access,access,157059,"EG_FS`` and ``__SEG_GS``; indicate their support. PowerPC Language Extensions; ---------------------------. Set the Floating Point Rounding Mode; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; PowerPC64/PowerPC64le supports the builtin function ``__builtin_setrnd`` to set; the floating point rounding mode. This function will use the least significant; two bits of integer argument to set the floating point rounding mode. .. code-block:: c++. double __builtin_setrnd(int mode);. The effective values for mode are:. - 0 - round to nearest; - 1 - round to zero; - 2 - round to +infinity; - 3 - round to -infinity. Note that the mode argument will modulo 4, so if the integer argument is greater; than 3, it will only use the least significant two bits of the mode.; Namely, ``__builtin_setrnd(102))`` is equal to ``__builtin_setrnd(2)``. PowerPC cache builtins; ^^^^^^^^^^^^^^^^^^^^^^. The PowerPC architecture specifies instructions implementing cache operations.; Clang provides builtins that give direct programmer access to these cache; instructions. Currently the following builtins are implemented in clang:. ``__builtin_dcbf`` copies the contents of a modified block from the data cache; to main memory and flushes the copy from the data cache. **Syntax**:. .. code-block:: c. void __dcbf(const void* addr); /* Data Cache Block Flush */. **Example of Use**:. .. code-block:: c. int a = 1;; __builtin_dcbf (&a);. Extensions for Static Analysis; ==============================. Clang supports additional attributes that are useful for documenting program; invariants and rules for static analysis tools, such as the `Clang Static; Analyzer <https://clang-analyzer.llvm.org/>`_. These attributes are documented; in the analyzer's `list of source-level annotations; <https://clang-analyzer.llvm.org/annotations.html>`_. Extensions for Dynamic Analysis; ===============================. Use ``__has_feature(address_sanitizer)`` to check if the code is being built; with :doc:`AddressSanitizer`. Use ``__has_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:166091,Security,expose,exposes,166091," count is specified by ``interleave_count(_value_)``, where; _value_ is a positive integer. This is useful for specifying the optimal; width/count of the set of target architectures supported by your application. .. code-block:: c++. #pragma clang loop vectorize_width(2); #pragma clang loop interleave_count(2); for(...) {; ...; }. Specifying a width/count of 1 disables the optimization, and is equivalent to; ``vectorize(disable)`` or ``interleave(disable)``. Vector predication is enabled by ``vectorize_predicate(enable)``, for example:. .. code-block:: c++. #pragma clang loop vectorize(enable); #pragma clang loop vectorize_predicate(enable); for(...) {; ...; }. This predicates (masks) all instructions in the loop, which allows the scalar; remainder loop (the tail) to be folded into the main vectorized loop. This; might be more efficient when vector predication is efficiently supported by the; target platform. Loop Unrolling; --------------. Unrolling a loop reduces the loop control overhead and exposes more; opportunities for ILP. Loops can be fully or partially unrolled. Full unrolling; eliminates the loop and replaces it with an enumerated sequence of loop; iterations. Full unrolling is only possible if the loop trip count is known at; compile time. Partial unrolling replicates the loop body within the loop and; reduces the trip count. If ``unroll(enable)`` is specified the unroller will attempt to fully unroll the; loop if the trip count is known at compile time. If the fully unrolled code size; is greater than an internal limit the loop will be partially unrolled up to this; limit. If the trip count is not known at compile time the loop will be partially; unrolled with a heuristically chosen unroll factor. .. code-block:: c++. #pragma clang loop unroll(enable); for(...) {; ...; }. If ``unroll(full)`` is specified the unroller will attempt to fully unroll the; loop if the trip count is known at compile time identically to; ``unroll(enable)``. However, with ``unro",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:855,Testability,test,test,855,"=========================; Clang Language Extensions; =========================. .. contents::; :local:; :depth: 1. .. toctree::; :hidden:. ObjectiveCLiterals; BlockLanguageSpec; Block-ABI-Apple; AutomaticReferenceCounting; MatrixTypes. Introduction; ============. This document describes the language extensions provided by Clang. In addition; to the language extensions listed here, Clang aims to support a broad range of; GCC extensions. Please see the `GCC manual; <https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html>`_ for more information on; these extensions. .. _langext-feature_check:. Feature Checking Macros; =======================. Language extensions can be very useful, but only if you know you can depend on; them. In order to allow fine-grain features checks, we support three builtin; function-like macros. This allows you to directly test for a feature in your; code without having to resort to something like autoconf or fragile ""compiler; version checks"". ``__has_builtin``; -----------------. This function-like macro takes a single identifier argument that is the name of; a builtin function, a builtin pseudo-function (taking one or more type; arguments), or a builtin template.; It evaluates to 1 if the builtin is supported or 0 if not.; It can be used like this:. .. code-block:: c++. #ifndef __has_builtin // Optional of course.; #define __has_builtin(x) 0 // Compatibility with non-clang compilers.; #endif. ...; #if __has_builtin(__builtin_trap); __builtin_trap();; #else; abort();; #endif; ... .. note::. Prior to Clang 10, ``__has_builtin`` could not be used to detect most builtin; pseudo-functions. ``__has_builtin`` should not be used to detect support for a builtin macro;; use ``#ifdef`` instead. ``__has_constexpr_builtin``; ---------------------------. This function-like macro takes a single identifier argument that is the name of; a builtin function, a builtin pseudo-function (taking one or more type; arguments), or a builtin template.; It evaluates to 1 ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:4185,Testability,test,test,4185,"ile; ``__has_extension`` evaluates to 1 if the feature is supported by Clang in the; current language (either as a language extension or a standard language; feature) or 0 if not. They can be used like this:. .. code-block:: c++. #ifndef __has_feature // Optional of course.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif; #ifndef __has_extension; #define __has_extension __has_feature // Compatibility with pre-3.0 compilers.; #endif. ...; #if __has_feature(cxx_rvalue_references); // This code will only be compiled with the -std=c++11 and -std=gnu++11; // options, because rvalue references are only standardized in C++11.; #endif. #if __has_extension(cxx_rvalue_references); // This code will be compiled with the -std=c++11, -std=gnu++11, -std=c++98; // and -std=gnu++98 options, because rvalue references are supported as a; // language extension in C++98.; #endif. .. _langext-has-feature-back-compat:. For backward compatibility, ``__has_feature`` can also be used to test; for support for non-standardized features, i.e. features not prefixed ``c_``,; ``cxx_`` or ``objc_``. Another use of ``__has_feature`` is to check for compiler features not related; to the language standard, such as e.g. :doc:`AddressSanitizer; <AddressSanitizer>`. If the ``-pedantic-errors`` option is given, ``__has_extension`` is equivalent; to ``__has_feature``. The feature tag is described along with the language feature below. The feature name or extension name can also be specified with a preceding and; following ``__`` (double underscore) to avoid interference from a macro with; the same name. For instance, ``__cxx_rvalue_references__`` can be used instead; of ``cxx_rvalue_references``. ``__has_cpp_attribute``; -----------------------. This function-like macro is available in C++20 by default, and is provided as an; extension in earlier language standards. It takes a single argument that is the; name of a double-square-bracket-style attribute. The argument can eith",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:5537,Testability,test,test-recommendations,5537," The feature tag is described along with the language feature below. The feature name or extension name can also be specified with a preceding and; following ``__`` (double underscore) to avoid interference from a macro with; the same name. For instance, ``__cxx_rvalue_references__`` can be used instead; of ``cxx_rvalue_references``. ``__has_cpp_attribute``; -----------------------. This function-like macro is available in C++20 by default, and is provided as an; extension in earlier language standards. It takes a single argument that is the; name of a double-square-bracket-style attribute. The argument can either be a; single identifier or a scoped identifier. If the attribute is supported, a; nonzero value is returned. If the attribute is a standards-based attribute, this; macro returns a nonzero value based on the year and month in which the attribute; was voted into the working draft. See `WG21 SD-6; <https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations>`_; for the list of values returned for standards-based attributes. If the attribute; is not supported by the current compilation target, this macro evaluates to 0.; It can be used like this:. .. code-block:: c++. #ifndef __has_cpp_attribute // For backwards compatibility; #define __has_cpp_attribute(x) 0; #endif. ...; #if __has_cpp_attribute(clang::fallthrough); #define FALLTHROUGH [[clang::fallthrough]]; #else; #define FALLTHROUGH; #endif; ... The attribute scope tokens ``clang`` and ``_Clang`` are interchangeable, as are; the attribute scope tokens ``gnu`` and ``__gnu__``. Attribute tokens in either; of these namespaces can be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``gnu::__const__`` can be used instead of ``gnu::const``. ``__has_c_attribute``; ---------------------. This function-like macro takes a single argument that is the name of an; attribute exposed with the double square-bracke",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:10587,Testability,test,test,10587,"n-clang compilers.; #if __is_identifier(__wchar_t); typedef wchar_t __wchar_t;; #endif; #endif. __wchar_t WideCharacter;; ... Include File Checking Macros; ============================. Not all developments systems have the same include files. The; :ref:`langext-__has_include` and :ref:`langext-__has_include_next` macros allow; you to check for the existence of an include file before doing a possibly; failing ``#include`` directive. Include file checking macros must be used; as expressions in ``#if`` or ``#elif`` preprocessing directives. .. _langext-__has_include:. ``__has_include``; -----------------. This function-like macro takes a single file name string argument that is the; name of an include file. It evaluates to 1 if the file can be found using the; include paths, or 0 otherwise:. .. code-block:: c++. // Note the two possible file name string formats.; #if __has_include(""myinclude.h"") && __has_include(<stdint.h>); # include ""myinclude.h""; #endif. To test for this feature, use ``#if defined(__has_include)``:. .. code-block:: c++. // To avoid problem with non-clang compilers not having this macro.; #if defined(__has_include); #if __has_include(""myinclude.h""); # include ""myinclude.h""; #endif; #endif. .. _langext-__has_include_next:. ``__has_include_next``; ----------------------. This function-like macro takes a single file name string argument that is the; name of an include file. It is like ``__has_include`` except that it looks for; the second instance of the given file found in the include paths. It evaluates; to 1 if the second instance of the file can be found using the include paths,; or 0 otherwise:. .. code-block:: c++. // Note the two possible file name string formats.; #if __has_include_next(""myinclude.h"") && __has_include_next(<stdint.h>); # include_next ""myinclude.h""; #endif. // To avoid problem with non-clang compilers not having this macro.; #if defined(__has_include_next); #if __has_include_next(""myinclude.h""); # include_next ""myinclude.h""; #end",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:23209,Testability,log,logarithm,23209,"======================== ================================================================ =========================================; T __builtin_elementwise_abs(T x) return the absolute value of a number x; the absolute value of signed integer and floating point types; the most negative integer remains the most negative integer; T __builtin_elementwise_fma(T x, T y, T z) fused multiply add, (x * y) + z. floating point types; T __builtin_elementwise_ceil(T x) return the smallest integral value greater than or equal to x floating point types; T __builtin_elementwise_sin(T x) return the sine of x interpreted as an angle in radians floating point types; T __builtin_elementwise_cos(T x) return the cosine of x interpreted as an angle in radians floating point types; T __builtin_elementwise_floor(T x) return the largest integral value less than or equal to x floating point types; T __builtin_elementwise_log(T x) return the natural logarithm of x floating point types; T __builtin_elementwise_log2(T x) return the base 2 logarithm of x floating point types; T __builtin_elementwise_log10(T x) return the base 10 logarithm of x floating point types; T __builtin_elementwise_pow(T x, T y) return x raised to the power of y floating point types; T __builtin_elementwise_bitreverse(T x) return the integer represented after reversing the bits of x integer types; T __builtin_elementwise_exp(T x) returns the base-e exponential, e^x, of the specified value floating point types; T __builtin_elementwise_exp2(T x) returns the base-2 exponential, 2^x, of the specified value floating point types. T __builtin_elementwise_sqrt(T x) return the square root of a floating-point number floating point types; T __builtin_elementwise_roundeven(T x) round x to the nearest integer value in floating point format, floating point types; rounding halfway cases to even (that is, to the nearest value; that is an even integer), regardless of the current rounding; direction.; T __builtin_elementwise_round(T x) rou",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:23298,Testability,log,logarithm,23298,"======================== ================================================================ =========================================; T __builtin_elementwise_abs(T x) return the absolute value of a number x; the absolute value of signed integer and floating point types; the most negative integer remains the most negative integer; T __builtin_elementwise_fma(T x, T y, T z) fused multiply add, (x * y) + z. floating point types; T __builtin_elementwise_ceil(T x) return the smallest integral value greater than or equal to x floating point types; T __builtin_elementwise_sin(T x) return the sine of x interpreted as an angle in radians floating point types; T __builtin_elementwise_cos(T x) return the cosine of x interpreted as an angle in radians floating point types; T __builtin_elementwise_floor(T x) return the largest integral value less than or equal to x floating point types; T __builtin_elementwise_log(T x) return the natural logarithm of x floating point types; T __builtin_elementwise_log2(T x) return the base 2 logarithm of x floating point types; T __builtin_elementwise_log10(T x) return the base 10 logarithm of x floating point types; T __builtin_elementwise_pow(T x, T y) return x raised to the power of y floating point types; T __builtin_elementwise_bitreverse(T x) return the integer represented after reversing the bits of x integer types; T __builtin_elementwise_exp(T x) returns the base-e exponential, e^x, of the specified value floating point types; T __builtin_elementwise_exp2(T x) returns the base-2 exponential, 2^x, of the specified value floating point types. T __builtin_elementwise_sqrt(T x) return the square root of a floating-point number floating point types; T __builtin_elementwise_roundeven(T x) round x to the nearest integer value in floating point format, floating point types; rounding halfway cases to even (that is, to the nearest value; that is an even integer), regardless of the current rounding; direction.; T __builtin_elementwise_round(T x) rou",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:23389,Testability,log,logarithm,23389,"======================== ================================================================ =========================================; T __builtin_elementwise_abs(T x) return the absolute value of a number x; the absolute value of signed integer and floating point types; the most negative integer remains the most negative integer; T __builtin_elementwise_fma(T x, T y, T z) fused multiply add, (x * y) + z. floating point types; T __builtin_elementwise_ceil(T x) return the smallest integral value greater than or equal to x floating point types; T __builtin_elementwise_sin(T x) return the sine of x interpreted as an angle in radians floating point types; T __builtin_elementwise_cos(T x) return the cosine of x interpreted as an angle in radians floating point types; T __builtin_elementwise_floor(T x) return the largest integral value less than or equal to x floating point types; T __builtin_elementwise_log(T x) return the natural logarithm of x floating point types; T __builtin_elementwise_log2(T x) return the base 2 logarithm of x floating point types; T __builtin_elementwise_log10(T x) return the base 10 logarithm of x floating point types; T __builtin_elementwise_pow(T x, T y) return x raised to the power of y floating point types; T __builtin_elementwise_bitreverse(T x) return the integer represented after reversing the bits of x integer types; T __builtin_elementwise_exp(T x) returns the base-e exponential, e^x, of the specified value floating point types; T __builtin_elementwise_exp2(T x) returns the base-2 exponential, 2^x, of the specified value floating point types. T __builtin_elementwise_sqrt(T x) return the square root of a floating-point number floating point types; T __builtin_elementwise_roundeven(T x) round x to the nearest integer value in floating point format, floating point types; rounding halfway cases to even (that is, to the nearest value; that is an even integer), regardless of the current rounding; direction.; T __builtin_elementwise_round(T x) rou",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:37313,Testability,test,test,37313,"ssage)`` and; ``__has_extension(attribute_unavailable_with_message)``. Attributes on Enumerators; =========================. Clang allows attributes to be written on individual enumerators. This allows; enumerators to be deprecated, made unavailable, etc. The attribute must appear; after the enumerator name and before any initializer, like so:. .. code-block:: c++. enum OperationMode {; OM_Invalid,; OM_Normal,; OM_Terrified __attribute__((deprecated)),; OM_AbortOnError __attribute__((deprecated)) = 4; };. Attributes on the ``enum`` declaration do not apply to individual enumerators. Query for this feature with ``__has_extension(enumerator_attributes)``. C++11 Attributes on using-declarations; ======================================. Clang allows C++-style ``[[]]`` attributes to be written on using-declarations.; For instance:. .. code-block:: c++. [[clang::using_if_exists]] using foo::bar;; using foo::baz [[clang::using_if_exists]];. You can test for support for this extension with; ``__has_extension(cxx_attributes_on_using_declarations)``. 'User-Specified' System Frameworks; ==================================. Clang provides a mechanism by which frameworks can be built in such a way that; they will always be treated as being ""system frameworks"", even if they are not; present in a system framework directory. This can be useful to system; framework developers who want to be able to test building other applications; with development builds of their framework, including the manner in which the; compiler changes warning behavior for system headers. Framework developers can opt-in to this mechanism by creating a; ""``.system_framework``"" file at the top-level of their framework. That is, the; framework should have contents like:. .. code-block:: none. .../TestFramework.framework; .../TestFramework.framework/.system_framework; .../TestFramework.framework/Headers; .../TestFramework.framework/Headers/TestFramework.h; ... Clang will treat the presence of this file as an indicat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:37761,Testability,test,test,37761,"cated)),; OM_AbortOnError __attribute__((deprecated)) = 4; };. Attributes on the ``enum`` declaration do not apply to individual enumerators. Query for this feature with ``__has_extension(enumerator_attributes)``. C++11 Attributes on using-declarations; ======================================. Clang allows C++-style ``[[]]`` attributes to be written on using-declarations.; For instance:. .. code-block:: c++. [[clang::using_if_exists]] using foo::bar;; using foo::baz [[clang::using_if_exists]];. You can test for support for this extension with; ``__has_extension(cxx_attributes_on_using_declarations)``. 'User-Specified' System Frameworks; ==================================. Clang provides a mechanism by which frameworks can be built in such a way that; they will always be treated as being ""system frameworks"", even if they are not; present in a system framework directory. This can be useful to system; framework developers who want to be able to test building other applications; with development builds of their framework, including the manner in which the; compiler changes warning behavior for system headers. Framework developers can opt-in to this mechanism by creating a; ""``.system_framework``"" file at the top-level of their framework. That is, the; framework should have contents like:. .. code-block:: none. .../TestFramework.framework; .../TestFramework.framework/.system_framework; .../TestFramework.framework/Headers; .../TestFramework.framework/Headers/TestFramework.h; ... Clang will treat the presence of this file as an indicator that the framework; should be treated as a system framework, regardless of how it was found in the; framework search path. For consistency, we recommend that such files never be; included in installed versions of the framework. Checks for Standard Language Features; =====================================. The ``__has_feature`` macro can be used to query if certain standard language; features are enabled. The ``__has_extension`` macro can be u",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:38958,Testability,test,tested,38958,"-in to this mechanism by creating a; ""``.system_framework``"" file at the top-level of their framework. That is, the; framework should have contents like:. .. code-block:: none. .../TestFramework.framework; .../TestFramework.framework/.system_framework; .../TestFramework.framework/Headers; .../TestFramework.framework/Headers/TestFramework.h; ... Clang will treat the presence of this file as an indicator that the framework; should be treated as a system framework, regardless of how it was found in the; framework search path. For consistency, we recommend that such files never be; included in installed versions of the framework. Checks for Standard Language Features; =====================================. The ``__has_feature`` macro can be used to query if certain standard language; features are enabled. The ``__has_extension`` macro can be used to query if; language features are available as an extension when compiling for a standard; which does not provide them. The features which can be tested are listed here. Since Clang 3.4, the C++ SD-6 feature test macros are also supported.; These are macros with names of the form ``__cpp_<feature_name>``, and are; intended to be a portable way to query the supported features of the compiler.; See `the C++ status page <https://clang.llvm.org/cxx_status.html#ts>`_ for; information on the version of SD-6 supported by each Clang release, and the; macros provided by that revision of the recommendations. C++98; -----. The features listed below are part of the C++98 standard. These features are; enabled by default when compiling C++ code. C++ exceptions; ^^^^^^^^^^^^^^. Use ``__has_feature(cxx_exceptions)`` to determine if C++ exceptions have been; enabled. For example, compiling code with ``-fno-exceptions`` disables C++; exceptions. C++ RTTI; ^^^^^^^^. Use ``__has_feature(cxx_rtti)`` to determine if C++ RTTI has been enabled. For; example, compiling code with ``-fno-rtti`` disables the use of RTTI. C++11; -----. The features listed",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:39020,Testability,test,test,39020,"t the top-level of their framework. That is, the; framework should have contents like:. .. code-block:: none. .../TestFramework.framework; .../TestFramework.framework/.system_framework; .../TestFramework.framework/Headers; .../TestFramework.framework/Headers/TestFramework.h; ... Clang will treat the presence of this file as an indicator that the framework; should be treated as a system framework, regardless of how it was found in the; framework search path. For consistency, we recommend that such files never be; included in installed versions of the framework. Checks for Standard Language Features; =====================================. The ``__has_feature`` macro can be used to query if certain standard language; features are enabled. The ``__has_extension`` macro can be used to query if; language features are available as an extension when compiling for a standard; which does not provide them. The features which can be tested are listed here. Since Clang 3.4, the C++ SD-6 feature test macros are also supported.; These are macros with names of the form ``__cpp_<feature_name>``, and are; intended to be a portable way to query the supported features of the compiler.; See `the C++ status page <https://clang.llvm.org/cxx_status.html#ts>`_ for; information on the version of SD-6 supported by each Clang release, and the; macros provided by that revision of the recommendations. C++98; -----. The features listed below are part of the C++98 standard. These features are; enabled by default when compiling C++ code. C++ exceptions; ^^^^^^^^^^^^^^. Use ``__has_feature(cxx_exceptions)`` to determine if C++ exceptions have been; enabled. For example, compiling code with ``-fno-exceptions`` disables C++; exceptions. C++ RTTI; ^^^^^^^^. Use ``__has_feature(cxx_rtti)`` to determine if C++ RTTI has been enabled. For; example, compiling code with ``-fno-rtti`` disables the use of RTTI. C++11; -----. The features listed below are part of the C++11 standard. As a result, all; these featu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:46400,Testability,assert,assertions,46400,"^^^^^^^^^. Use ``__has_feature(cxx_reference_qualified_functions)`` or; ``__has_extension(cxx_reference_qualified_functions)`` to determine if support; for reference-qualified functions (e.g., member functions with ``&`` or ``&&``; applied to ``*this``) is enabled. C++11 range-based ``for`` loop; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_range_for)`` or ``__has_extension(cxx_range_for)`` to; determine if support for the range-based for loop is enabled. C++11 raw string literals; ^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_raw_string_literals)`` to determine if support for raw; string literals (e.g., ``R""x(foo\bar)x""``) is enabled. C++11 rvalue references; ^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_rvalue_references)`` or; ``__has_extension(cxx_rvalue_references)`` to determine if support for rvalue; references is enabled. C++11 ``static_assert()``; ^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_static_assert)`` or; ``__has_extension(cxx_static_assert)`` to determine if support for compile-time; assertions using ``static_assert`` is enabled. C++11 ``thread_local``; ^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_thread_local)`` to determine if support for; ``thread_local`` variables is enabled. C++11 type inference; ^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_auto_type)`` or ``__has_extension(cxx_auto_type)`` to; determine C++11 type inference is supported using the ``auto`` specifier. If; this is disabled, ``auto`` will instead be a storage class specifier, as in C; or C++98. C++11 strongly typed enumerations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_strong_enums)`` or; ``__has_extension(cxx_strong_enums)`` to determine if support for strongly; typed, scoped enumerations is enabled. C++11 trailing return type; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_trailing_return)`` or; ``__has_extension(cxx_trailing_return)`` to determine if support for the; alternate function declaration syntax with trailing return ty",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:54206,Testability,assert,assertions,54206,"in the C11; standard. In C, type compatibility is decided according to the rules given in the; appropriate standard, but in C++, which lacks the type compatibility rules used; in C, types are considered compatible only if they are equivalent. Clang also supports an extended form of ``_Generic`` with a controlling type; rather than a controlling expression. Unlike with a controlling expression, a; controlling type argument does not undergo any conversions and thus is suitable; for use when trying to match qualified types, incomplete types, or function; types. Variable-length array types lack the necessary compile-time information; to resolve which association they match with and thus are not allowed as a; controlling type argument. Use ``__has_extension(c_generic_selection_with_controlling_type)`` to determine; if support for this extension is enabled. C11 ``_Static_assert()``; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_static_assert)`` or ``__has_extension(c_static_assert)``; to determine if support for compile-time assertions using ``_Static_assert`` is; enabled. C11 ``_Thread_local``; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_thread_local)`` or ``__has_extension(c_thread_local)``; to determine if support for ``_Thread_local`` variables is enabled. Modules; -------. Use ``__has_feature(modules)`` to determine if Modules have been enabled.; For example, compiling code with ``-fmodules`` enables the use of Modules. More information could be found `here <https://clang.llvm.org/docs/Modules.html>`_. Language Extensions Back-ported to Previous Standards; =====================================================. ====================================== ================================ ============= =============; Feature Feature Test Macro Introduced In Backported To; ====================================== ================================ ============= =============; variadic templates __cpp_variadic_templates C++11 C++03; Alias templates __cpp_alias_templates C++11 C",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:71758,Testability,test,test,71758,"d is available. Automatic reference counting; ----------------------------. Clang provides support for :doc:`automated reference counting; <AutomaticReferenceCounting>` in Objective-C, which eliminates the need; for manual ``retain``/``release``/``autorelease`` message sends. There are three; feature macros associated with automatic reference counting:; ``__has_feature(objc_arc)`` indicates the availability of automated reference; counting in general, while ``__has_feature(objc_arc_weak)`` indicates that; automated reference counting also includes support for ``__weak`` pointers to; Objective-C objects. ``__has_feature(objc_arc_fields)`` indicates that C structs; are allowed to have fields that are pointers to Objective-C objects managed by; automatic reference counting. .. _objc-weak:. Weak references; ---------------. Clang supports ARC-style weak and unsafe references in Objective-C even; outside of ARC mode. Weak references must be explicitly enabled with; the ``-fobjc-weak`` option; use ``__has_feature((objc_arc_weak))``; to test whether they are enabled. Unsafe references are enabled; unconditionally. ARC-style weak and unsafe references cannot be used; when Objective-C garbage collection is enabled. Except as noted below, the language rules for the ``__weak`` and; ``__unsafe_unretained`` qualifiers (and the ``weak`` and; ``unsafe_unretained`` property attributes) are just as laid out; in the :doc:`ARC specification <AutomaticReferenceCounting>`.; In particular, note that some classes do not support forming weak; references to their instances, and note that special care must be; taken when storing weak references in memory where initialization; and deinitialization are outside the responsibility of the compiler; (such as in ``malloc``-ed memory). Loading from a ``__weak`` variable always implicitly retains the; loaded value. In non-ARC modes, this retain is normally balanced; by an implicit autorelease. This autorelease can be suppressed; by performing the load",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:77319,Testability,test,tests,77319,"s an optimization, if a lambda expression is immediately; converted to a block pointer (as in the first example, above), then the block; is not copied and autoreleased: rather, it is given the same lifetime as a; block literal written at that point in the program, which avoids the overhead; of copying a block to the heap in the common case. The conversion from a lambda to a block pointer is only available in; Objective-C++, and not in C++ with blocks, due to its use of Objective-C memory; management (autorelease). Object Literals and Subscripting; --------------------------------. Clang provides support for :doc:`Object Literals and Subscripting; <ObjectiveCLiterals>` in Objective-C, which simplifies common Objective-C; programming patterns, makes programs more concise, and improves the safety of; container creation. There are several feature macros associated with object; literals and subscripting: ``__has_feature(objc_array_literals)`` tests the; availability of array literals; ``__has_feature(objc_dictionary_literals)``; tests the availability of dictionary literals;; ``__has_feature(objc_subscripting)`` tests the availability of object; subscripting. Objective-C Autosynthesis of Properties; ---------------------------------------. Clang provides support for autosynthesis of declared properties. Using this; feature, clang provides default synthesis of those properties not declared; @dynamic and not having user provided backing getter and setter methods.; ``__has_feature(objc_default_synthesize_properties)`` checks for availability; of this feature in version of clang being used. .. _langext-objc-retain-release:. Objective-C retaining behavior attributes; -----------------------------------------. In Objective-C, functions and methods are generally assumed to follow the; `Cocoa Memory Management; <https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html>`_; conventions for ownership of object arguments and; return va",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:77407,Testability,test,tests,77407,"s an optimization, if a lambda expression is immediately; converted to a block pointer (as in the first example, above), then the block; is not copied and autoreleased: rather, it is given the same lifetime as a; block literal written at that point in the program, which avoids the overhead; of copying a block to the heap in the common case. The conversion from a lambda to a block pointer is only available in; Objective-C++, and not in C++ with blocks, due to its use of Objective-C memory; management (autorelease). Object Literals and Subscripting; --------------------------------. Clang provides support for :doc:`Object Literals and Subscripting; <ObjectiveCLiterals>` in Objective-C, which simplifies common Objective-C; programming patterns, makes programs more concise, and improves the safety of; container creation. There are several feature macros associated with object; literals and subscripting: ``__has_feature(objc_array_literals)`` tests the; availability of array literals; ``__has_feature(objc_dictionary_literals)``; tests the availability of dictionary literals;; ``__has_feature(objc_subscripting)`` tests the availability of object; subscripting. Objective-C Autosynthesis of Properties; ---------------------------------------. Clang provides support for autosynthesis of declared properties. Using this; feature, clang provides default synthesis of those properties not declared; @dynamic and not having user provided backing getter and setter methods.; ``__has_feature(objc_default_synthesize_properties)`` checks for availability; of this feature in version of clang being used. .. _langext-objc-retain-release:. Objective-C retaining behavior attributes; -----------------------------------------. In Objective-C, functions and methods are generally assumed to follow the; `Cocoa Memory Management; <https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html>`_; conventions for ownership of object arguments and; return va",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:77492,Testability,test,tests,77492,"s an optimization, if a lambda expression is immediately; converted to a block pointer (as in the first example, above), then the block; is not copied and autoreleased: rather, it is given the same lifetime as a; block literal written at that point in the program, which avoids the overhead; of copying a block to the heap in the common case. The conversion from a lambda to a block pointer is only available in; Objective-C++, and not in C++ with blocks, due to its use of Objective-C memory; management (autorelease). Object Literals and Subscripting; --------------------------------. Clang provides support for :doc:`Object Literals and Subscripting; <ObjectiveCLiterals>` in Objective-C, which simplifies common Objective-C; programming patterns, makes programs more concise, and improves the safety of; container creation. There are several feature macros associated with object; literals and subscripting: ``__has_feature(objc_array_literals)`` tests the; availability of array literals; ``__has_feature(objc_dictionary_literals)``; tests the availability of dictionary literals;; ``__has_feature(objc_subscripting)`` tests the availability of object; subscripting. Objective-C Autosynthesis of Properties; ---------------------------------------. Clang provides support for autosynthesis of declared properties. Using this; feature, clang provides default synthesis of those properties not declared; @dynamic and not having user provided backing getter and setter methods.; ``__has_feature(objc_default_synthesize_properties)`` checks for availability; of this feature in version of clang being used. .. _langext-objc-retain-release:. Objective-C retaining behavior attributes; -----------------------------------------. In Objective-C, functions and methods are generally assumed to follow the; `Cocoa Memory Management; <https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html>`_; conventions for ownership of object arguments and; return va",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:113445,Testability,log,logic,113445,"an.; This is useful to improve optimization and eliminates certain warnings. For; example, without the ``__builtin_unreachable`` in the example below, the; compiler assumes that the inline asm can fall through and prints a ""function; declared '``noreturn``' should not return"" warning. **Syntax**:. .. code-block:: c++. __builtin_unreachable(). **Example of use**:. .. code-block:: c++. void myabort(void) __attribute__((noreturn));; void myabort(void) {; asm(""int3"");; __builtin_unreachable();; }. **Description**:. The ``__builtin_unreachable()`` builtin has completely undefined behavior.; Since it has undefined behavior, it is a statement that it is never reached and; the optimizer can take advantage of this to produce better code. This builtin; takes no arguments and produces a void result. Query for this feature with ``__has_builtin(__builtin_unreachable)``. ``__builtin_unpredictable``; ---------------------------. ``__builtin_unpredictable`` is used to indicate that a branch condition is; unpredictable by hardware mechanisms such as branch prediction logic. **Syntax**:. .. code-block:: c++. __builtin_unpredictable(long long). **Example of use**:. .. code-block:: c++. if (__builtin_unpredictable(x > 0)) {; foo();; }. **Description**:. The ``__builtin_unpredictable()`` builtin is expected to be used with control; flow conditions such as in ``if`` and ``switch`` statements. Query for this feature with ``__has_builtin(__builtin_unpredictable)``. ``__builtin_expect``; --------------------. ``__builtin_expect`` is used to indicate that the value of an expression is; anticipated to be the same as a statically known result. **Syntax**:. .. code-block:: c++. long __builtin_expect(long expr, long val). **Example of use**:. .. code-block:: c++. if (__builtin_expect(x, 0)) {; bar();; }. **Description**:. The ``__builtin_expect()`` builtin is typically used with control flow; conditions such as in ``if`` and ``switch`` statements to help branch; prediction. It means that its fir",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:129407,Testability,test,test,129407,"guments and stores the result in the third argument. If; possible, the result will be equal to mathematically-correct result; and the builtin will return 0. Otherwise, the builtin will return; 1 and the result will be equal to the unique value that is equivalent; to the mathematically-correct result modulo two raised to the *k*; power, where *k* is the number of bits in the result type. The; behavior of these builtins is well-defined for all argument values. The first three builtins work generically for operands of any integer type,; including boolean types. The operands need not have the same type as each; other, or as the result. The other builtins may implicitly promote or; convert their operands before performing the operation. Query for this feature with ``__has_builtin(__builtin_add_overflow)``, etc. Floating point builtins; ---------------------------------------. ``__builtin_isfpclass``; -----------------------. ``__builtin_isfpclass`` is used to test if the specified floating-point values; fall into one of the specified floating-point classes. **Syntax**:. .. code-block:: c++. int __builtin_isfpclass(fp_type expr, int mask); int_vector __builtin_isfpclass(fp_vector expr, int mask). **Example of use**:. .. code-block:: c++. if (__builtin_isfpclass(x, 448)) {; // `x` is positive finite value; 	 ...; }. **Description**:. The ``__builtin_isfpclass()`` builtin is a generalization of functions ``isnan``,; ``isinf``, ``isfinite`` and some others defined by the C standard. It tests if; the floating-point value, specified by the first argument, falls into any of data; classes, specified by the second argument. The latter is an integer constant; bitmask expression, in which each data class is represented by a bit; using the encoding:. ========== =================== ======================; Mask value Data class Macro; ========== =================== ======================; 0x0001 Signaling NaN __FPCLASS_SNAN; 0x0002 Quiet NaN __FPCLASS_QNAN; 0x0004 Negative infinity __F",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:129940,Testability,test,tests,129940,"e operands need not have the same type as each; other, or as the result. The other builtins may implicitly promote or; convert their operands before performing the operation. Query for this feature with ``__has_builtin(__builtin_add_overflow)``, etc. Floating point builtins; ---------------------------------------. ``__builtin_isfpclass``; -----------------------. ``__builtin_isfpclass`` is used to test if the specified floating-point values; fall into one of the specified floating-point classes. **Syntax**:. .. code-block:: c++. int __builtin_isfpclass(fp_type expr, int mask); int_vector __builtin_isfpclass(fp_vector expr, int mask). **Example of use**:. .. code-block:: c++. if (__builtin_isfpclass(x, 448)) {; // `x` is positive finite value; 	 ...; }. **Description**:. The ``__builtin_isfpclass()`` builtin is a generalization of functions ``isnan``,; ``isinf``, ``isfinite`` and some others defined by the C standard. It tests if; the floating-point value, specified by the first argument, falls into any of data; classes, specified by the second argument. The latter is an integer constant; bitmask expression, in which each data class is represented by a bit; using the encoding:. ========== =================== ======================; Mask value Data class Macro; ========== =================== ======================; 0x0001 Signaling NaN __FPCLASS_SNAN; 0x0002 Quiet NaN __FPCLASS_QNAN; 0x0004 Negative infinity __FPCLASS_NEGINF; 0x0008 Negative normal __FPCLASS_NEGNORMAL; 0x0010 Negative subnormal __FPCLASS_NEGSUBNORMAL; 0x0020 Negative zero __FPCLASS_NEGZERO; 0x0040 Positive zero __FPCLASS_POSZERO; 0x0080 Positive subnormal __FPCLASS_POSSUBNORMAL; 0x0100 Positive normal __FPCLASS_POSNORMAL; 0x0200 Positive infinity __FPCLASS_POSINF; ========== =================== ======================. For convenience preprocessor defines macros for these values. The function; returns 1 if ``expr`` falls into one of the specified data classes, 0 otherwise. In the example above the mask",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:148537,Testability,assert,assertion,148537,"f the first argument to `llvm.coro.suspend` is; token `none`. If a user calls `__builin_suspend`, clang will insert `token none`; as the first argument to the intrinsic. Source location builtins; ------------------------. Clang provides builtins to support C++ standard library implementation; of ``std::source_location`` as specified in C++20. With the exception; of ``__builtin_COLUMN``, ``__builtin_FILE_NAME`` and ``__builtin_FUNCSIG``,; these builtins are also implemented by GCC. **Syntax**:. .. code-block:: c. const char *__builtin_FILE();; const char *__builtin_FILE_NAME(); // Clang only; const char *__builtin_FUNCTION();; const char *__builtin_FUNCSIG(); // Microsoft; unsigned __builtin_LINE();; unsigned __builtin_COLUMN(); // Clang only; const std::source_location::__impl *__builtin_source_location();. **Example of use**:. .. code-block:: c++. void my_assert(bool pred, int line = __builtin_LINE(), // Captures line of caller; const char* file = __builtin_FILE(),; const char* function = __builtin_FUNCTION()) {; if (pred) return;; printf(""%s:%d assertion failed in function %s\n"", file, line, function);; std::abort();; }. struct MyAggregateType {; int x;; int line = __builtin_LINE(); // captures line where aggregate initialization occurs; };; static_assert(MyAggregateType{42}.line == __LINE__);. struct MyClassType {; int line = __builtin_LINE(); // captures line of the constructor used during initialization; constexpr MyClassType(int) { assert(line == __LINE__); }; };. **Description**:. The builtins ``__builtin_LINE``, ``__builtin_FUNCTION``, ``__builtin_FUNCSIG``,; ``__builtin_FILE`` and ``__builtin_FILE_NAME`` return the values, at the; ""invocation point"", for ``__LINE__``, ``__FUNCTION__``, ``__FUNCSIG__``,; ``__FILE__`` and ``__FILE_NAME__`` respectively. ``__builtin_COLUMN`` similarly; returns the column, though there is no corresponding macro. These builtins are; constant expressions. When the builtins appear as part of a default function argument the invocat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:148936,Testability,assert,assert,148936,"E_NAME`` and ``__builtin_FUNCSIG``,; these builtins are also implemented by GCC. **Syntax**:. .. code-block:: c. const char *__builtin_FILE();; const char *__builtin_FILE_NAME(); // Clang only; const char *__builtin_FUNCTION();; const char *__builtin_FUNCSIG(); // Microsoft; unsigned __builtin_LINE();; unsigned __builtin_COLUMN(); // Clang only; const std::source_location::__impl *__builtin_source_location();. **Example of use**:. .. code-block:: c++. void my_assert(bool pred, int line = __builtin_LINE(), // Captures line of caller; const char* file = __builtin_FILE(),; const char* function = __builtin_FUNCTION()) {; if (pred) return;; printf(""%s:%d assertion failed in function %s\n"", file, line, function);; std::abort();; }. struct MyAggregateType {; int x;; int line = __builtin_LINE(); // captures line where aggregate initialization occurs; };; static_assert(MyAggregateType{42}.line == __LINE__);. struct MyClassType {; int line = __builtin_LINE(); // captures line of the constructor used during initialization; constexpr MyClassType(int) { assert(line == __LINE__); }; };. **Description**:. The builtins ``__builtin_LINE``, ``__builtin_FUNCTION``, ``__builtin_FUNCSIG``,; ``__builtin_FILE`` and ``__builtin_FILE_NAME`` return the values, at the; ""invocation point"", for ``__LINE__``, ``__FUNCTION__``, ``__FUNCSIG__``,; ``__FILE__`` and ``__FILE_NAME__`` respectively. ``__builtin_COLUMN`` similarly; returns the column, though there is no corresponding macro. These builtins are; constant expressions. When the builtins appear as part of a default function argument the invocation; point is the location of the caller. When the builtins appear as part of a; default member initializer, the invocation point is the location of the; constructor or aggregate initialization used to create the object. Otherwise; the invocation point is the same as the location of the builtin. When the invocation point of ``__builtin_FUNCTION`` is not a function scope the; empty string is returned. Th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:180607,Testability,test,test,180607,"ETURN_BEGIN _Pragma(""clang attribute AssumeNoreturn.push ([[noreturn]], apply_to = function)""); #define ASSUME_NORETURN_END _Pragma(""clang attribute AssumeNoreturn.pop""). #define ASSUME_UNAVAILABLE_BEGIN _Pragma(""clang attribute Unavailable.push (__attribute__((unavailable)), apply_to=function)""); #define ASSUME_UNAVAILABLE_END _Pragma(""clang attribute Unavailable.pop""). ASSUME_NORETURN_BEGIN; ASSUME_UNAVAILABLE_BEGIN; void function(); // function has [[noreturn]] and __attribute__((unavailable)); ASSUME_NORETURN_END; void other_function(); // function has __attribute__((unavailable)); ASSUME_UNAVAILABLE_END. Without the namespaces on the macros, ``other_function`` will be annotated with; ``[[noreturn]]`` instead of ``__attribute__((unavailable))``. This may seem like; a contrived example, but its very possible for this kind of situation to appear; in real code if the pragmas are spread out across a large file. You can test if; your version of clang supports namespaces on ``#pragma clang attribute`` with; ``__has_extension(pragma_clang_attribute_namespaces)``. Subject Match Rules; -------------------. The set of declarations that receive a single attribute from the attribute stack; depends on the subject match rules that were specified in the pragma. Subject; match rules are specified after the attribute. The compiler expects an; identifier that corresponds to the subject set specifier. The ``apply_to``; specifier is currently the only supported subject set specifier. It allows you; to specify match rules that form a subset of the attribute's allowed subject; set, i.e. the compiler doesn't require all of the attribute's subjects. For; example, an attribute like ``[[nodiscard]]`` whose subject set includes; ``enum``, ``record`` and ``hasType(functionType)``, requires the presence of at; least one of these rules after ``apply_to``:. .. code-block:: c++. #pragma clang attribute push([[nodiscard]], apply_to = enum). enum Enum1 { A1, B1 }; // The enum will receive [[nodi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:190276,Testability,log,log,190276," if this was written; as ``__builtin_dynamic_object_size(buffer, 0)``, Clang will fold it into; ``size``, providing some extra runtime safety. Deprecating Macros; ==================. Clang supports the pragma ``#pragma clang deprecated``, which can be used to; provide deprecation warnings for macro uses. For example:. .. code-block:: c. #define MIN(x, y) x < y ? x : y; #pragma clang deprecated(MIN, ""use std::min instead""). int min(int a, int b) {; return MIN(a, b); // warning: MIN is deprecated: use std::min instead; }. ``#pragma clang deprecated`` should be preferred for this purpose over; ``#pragma GCC warning`` because the warning can be controlled with; ``-Wdeprecated``. Restricted Expansion Macros; ===========================. Clang supports the pragma ``#pragma clang restrict_expansion``, which can be; used restrict macro expansion in headers. This can be valuable when providing; headers with ABI stability requirements. Any expansion of the annotated macro; processed by the preprocessor after the ``#pragma`` annotation will log a; warning. Redefining the macro or undefining the macro will not be diagnosed, nor; will expansion of the macro within the main source file. For example:. .. code-block:: c. #define TARGET_ARM 1; #pragma clang restrict_expansion(TARGET_ARM, ""<reason>""). /// Foo.h; struct Foo {; #if TARGET_ARM // warning: TARGET_ARM is marked unsafe in headers: <reason>; uint32_t X;; #else; uint64_t X;; #endif; };. /// main.c; #include ""foo.h""; #if TARGET_ARM // No warning in main source file; X_TYPE uint32_t; #else; X_TYPE uint64_t; #endif. This warning is controlled by ``-Wpedantic-macros``. Final Macros; ============. Clang supports the pragma ``#pragma clang final``, which can be used to; mark macros as final, meaning they cannot be undef'd or re-defined. For example:. .. code-block:: c. #define FINAL_MACRO 1; #pragma clang final(FINAL_MACRO). #define FINAL_MACRO // warning: FINAL_MACRO is marked final and should not be redefined; #undef FINAL_MACRO",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:196620,Testability,test,testing,196620,"tin_isnormal``; * ``__builtin_nan``; * ``__builtin_nans``; * ``__builtin_parity``; * ``__builtin_parityl``; * ``__builtin_parityll``; * ``__builtin_popcount``; * ``__builtin_popcountl``; * ``__builtin_popcountll``; * ``__builtin_rotateleft8``; * ``__builtin_rotateleft16``; * ``__builtin_rotateleft32``; * ``__builtin_rotateleft64``; * ``__builtin_rotateright8``; * ``__builtin_rotateright16``; * ``__builtin_rotateright32``; * ``__builtin_rotateright64``. The following x86-specific intrinsics can be used in constant expressions:. * ``_bit_scan_forward``; * ``_bit_scan_reverse``; * ``__bsfd``; * ``__bsfq``; * ``__bsrd``; * ``__bsrq``; * ``__bswap``; * ``__bswapd``; * ``__bswap64``; * ``__bswapq``; * ``_castf32_u32``; * ``_castf64_u64``; * ``_castu32_f32``; * ``_castu64_f64``; * ``__lzcnt16``; * ``__lzcnt``; * ``__lzcnt64``; * ``_mm_popcnt_u32``; * ``_mm_popcnt_u64``; * ``_popcnt32``; * ``_popcnt64``; * ``__popcntd``; * ``__popcntq``; * ``__popcnt16``; * ``__popcnt``; * ``__popcnt64``; * ``__rolb``; * ``__rolw``; * ``__rold``; * ``__rolq``; * ``__rorb``; * ``__rorw``; * ``__rord``; * ``__rorq``; * ``_rotl``; * ``_rotr``; * ``_rotwl``; * ``_rotwr``; * ``_lrotl``; * ``_lrotr``. Debugging the Compiler; ======================. Clang supports a number of pragma directives that help debugging the compiler itself.; Syntax is the following: `#pragma clang __debug <command> <arguments>`.; Note, all of debugging pragmas are subject to change. `dump`; ------; Accepts either a single identifier or an expression. When a single identifier is passed,; the lookup results for the identifier are printed to `stderr`. When an expression is passed,; the AST for the expression is printed to `stderr`. The expression is an unevaluated operand,; so things like overload resolution and template instantiations are performed,; but the expression has no runtime effects.; Type- and value-dependent expressions are not supported yet. This facility is designed to aid with testing name lookup machinery.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:57049,Usability,simpl,simplify,57049,"; Structured bindings __cpp_structured_bindings C++17 C++03; template template arguments __cpp_template_template_args C++17 C++03; ``static operator[]`` __cpp_multidimensional_subscript C++20 C++03; Designated initializers __cpp_designated_initializers C++20 C++03; Conditional ``explicit`` __cpp_conditional_explicit C++20 C++03; ``using enum`` __cpp_using_enum C++20 C++03; ``if consteval`` __cpp_if_consteval C++23 C++20; ``static operator()`` __cpp_static_call_operator C++23 C++03; Attributes on Lambda-Expressions C++23 C++11; -------------------------------------- -------------------------------- ------------- -------------; Designated initializers (N494) C99 C89; Array & element qualification (N2607) C23 C89; Attributes (N2335) C23 C89; ====================================== ================================ ============= =============. Type Trait Primitives; =====================. Type trait primitives are special builtin constant expressions that can be used; by the standard C++ library to facilitate or simplify the implementation of; user-facing type traits in the <type_traits> header. They are not intended to be used directly by user code because they are; implementation-defined and subject to change -- as such they're tied closely to; the supported set of system headers, currently:. * LLVM's own libc++; * GNU libstdc++; * The Microsoft standard C++ library. Clang supports the `GNU C++ type traits; <https://gcc.gnu.org/onlinedocs/gcc/Type-Traits.html>`_ and a subset of the; `Microsoft Visual C++ type traits; <https://msdn.microsoft.com/en-us/library/ms177194(v=VS.100).aspx>`_,; as well as nearly all of the; `Embarcadero C++ type traits; <http://docwiki.embarcadero.com/RADStudio/Rio/en/Type_Trait_Functions_(C%2B%2B11)_Index>`_. The following type trait primitives are supported by Clang. Those traits marked; (C++) provide implementations for type traits specified by the C++ standard;; ``__X(...)`` has the same semantics and constraints as the corresponding; ``std:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:66343,Usability,simpl,simplistic,66343," depending on the oldest version of Clang you wish to support. * From Clang 10 onwards, ``__has_builtin(__X)`` can be used.; * From Clang 6 onwards, ``!__is_identifier(__X)`` can be used.; * From Clang 3 onwards, ``__has_feature(X)`` can be used, but only supports; the following traits:. * ``__has_nothrow_assign``; * ``__has_nothrow_copy``; * ``__has_nothrow_constructor``; * ``__has_trivial_assign``; * ``__has_trivial_copy``; * ``__has_trivial_constructor``; * ``__has_trivial_destructor``; * ``__has_virtual_destructor``; * ``__is_abstract``; * ``__is_base_of``; * ``__is_class``; * ``__is_constructible``; * ``__is_convertible_to``; * ``__is_empty``; * ``__is_enum``; * ``__is_final``; * ``__is_literal``; * ``__is_standard_layout``; * ``__is_pod``; * ``__is_polymorphic``; * ``__is_sealed``; * ``__is_trivial``; * ``__is_trivially_assignable``; * ``__is_trivially_constructible``; * ``__is_trivially_copyable``; * ``__is_union``; * ``__underlying_type``. A simplistic usage example as might be seen in standard C++ headers follows:. .. code-block:: c++. #if __has_builtin(__is_convertible_to); template<typename From, typename To>; struct is_convertible_to {; static const bool value = __is_convertible_to(From, To);; };; #else; // Emulate type trait for compatibility with other compilers.; #endif. Blocks; ======. The syntax and high level language feature description is in; :doc:`BlockLanguageSpec<BlockLanguageSpec>`. Implementation and ABI details for; the clang implementation are in :doc:`Block-ABI-Apple<Block-ABI-Apple>`. Query for this feature with ``__has_extension(blocks)``. ASM Goto with Output Constraints; ================================. Outputs may be used along any branches from the ``asm goto`` whether the; branches are taken or not. Query for this feature with ``__has_extension(gnu_asm_goto_with_outputs)``. Prior to clang-16, the output may only be used safely when the indirect; branches are not taken. Query for this difference with; ``__has_extension(gnu_asm_goto",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:74768,Usability,simpl,simply,74768,"-------------------------------. Clang provides support for C++11 enumerations with a fixed underlying type; within Objective-C. For example, one can write an enumeration type as:. .. code-block:: c++. typedef enum : unsigned char { Red, Green, Blue } Color;. This specifies that the underlying type, which is used to store the enumeration; value, is ``unsigned char``. Use ``__has_feature(objc_fixed_enum)`` to determine whether support for fixed; underlying types is available in Objective-C. Interoperability with C++11 lambdas; -----------------------------------. Clang provides interoperability between C++11 lambdas and blocks-based APIs, by; permitting a lambda to be implicitly converted to a block pointer with the; corresponding signature. For example, consider an API such as ``NSArray``'s; array-sorting method:. .. code-block:: objc. - (NSArray *)sortedArrayUsingComparator:(NSComparator)cmptr;. ``NSComparator`` is simply a typedef for the block pointer ``NSComparisonResult; (^)(id, id)``, and parameters of this type are generally provided with block; literals as arguments. However, one can also use a C++11 lambda so long as it; provides the same signature (in this case, accepting two parameters of type; ``id`` and returning an ``NSComparisonResult``):. .. code-block:: objc. NSArray *array = @[@""string 1"", @""string 21"", @""string 12"", @""String 11"",; @""String 02""];; const NSStringCompareOptions comparisonOptions; = NSCaseInsensitiveSearch | NSNumericSearch |; NSWidthInsensitiveSearch | NSForcedOrderingSearch;; NSLocale *currentLocale = [NSLocale currentLocale];; NSArray *sorted; = [array sortedArrayUsingComparator:[=](id s1, id s2) -> NSComparisonResult {; NSRange string1Range = NSMakeRange(0, [s1 length]);; return [s1 compare:s2 options:comparisonOptions; range:string1Range locale:currentLocale];; }];; NSLog(@""sorted: %@"", sorted);. This code relies on an implicit conversion from the type of the lambda; expression (an unnamed, local class type called the *closure ty",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:76173,Usability,simpl,simply,76173," 11"",; @""String 02""];; const NSStringCompareOptions comparisonOptions; = NSCaseInsensitiveSearch | NSNumericSearch |; NSWidthInsensitiveSearch | NSForcedOrderingSearch;; NSLocale *currentLocale = [NSLocale currentLocale];; NSArray *sorted; = [array sortedArrayUsingComparator:[=](id s1, id s2) -> NSComparisonResult {; NSRange string1Range = NSMakeRange(0, [s1 length]);; return [s1 compare:s2 options:comparisonOptions; range:string1Range locale:currentLocale];; }];; NSLog(@""sorted: %@"", sorted);. This code relies on an implicit conversion from the type of the lambda; expression (an unnamed, local class type called the *closure type*) to the; corresponding block pointer type. The conversion itself is expressed by a; conversion operator in that closure type that produces a block pointer with the; same signature as the lambda itself, e.g.,. .. code-block:: objc. operator NSComparisonResult (^)(id, id)() const;. This conversion function returns a new block that simply forwards the two; parameters to the lambda object (which it captures by copy), then returns the; result. The returned block is first copied (with ``Block_copy``) and then; autoreleased. As an optimization, if a lambda expression is immediately; converted to a block pointer (as in the first example, above), then the block; is not copied and autoreleased: rather, it is given the same lifetime as a; block literal written at that point in the program, which avoids the overhead; of copying a block to the heap in the common case. The conversion from a lambda to a block pointer is only available in; Objective-C++, and not in C++ with blocks, due to its use of Objective-C memory; management (autorelease). Object Literals and Subscripting; --------------------------------. Clang provides support for :doc:`Object Literals and Subscripting; <ObjectiveCLiterals>` in Objective-C, which simplifies common Objective-C; programming patterns, makes programs more concise, and improves the safety of; container creation. There a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:77066,Usability,simpl,simplifies,77066,"perator NSComparisonResult (^)(id, id)() const;. This conversion function returns a new block that simply forwards the two; parameters to the lambda object (which it captures by copy), then returns the; result. The returned block is first copied (with ``Block_copy``) and then; autoreleased. As an optimization, if a lambda expression is immediately; converted to a block pointer (as in the first example, above), then the block; is not copied and autoreleased: rather, it is given the same lifetime as a; block literal written at that point in the program, which avoids the overhead; of copying a block to the heap in the common case. The conversion from a lambda to a block pointer is only available in; Objective-C++, and not in C++ with blocks, due to its use of Objective-C memory; management (autorelease). Object Literals and Subscripting; --------------------------------. Clang provides support for :doc:`Object Literals and Subscripting; <ObjectiveCLiterals>` in Objective-C, which simplifies common Objective-C; programming patterns, makes programs more concise, and improves the safety of; container creation. There are several feature macros associated with object; literals and subscripting: ``__has_feature(objc_array_literals)`` tests the; availability of array literals; ``__has_feature(objc_dictionary_literals)``; tests the availability of dictionary literals;; ``__has_feature(objc_subscripting)`` tests the availability of object; subscripting. Objective-C Autosynthesis of Properties; ---------------------------------------. Clang provides support for autosynthesis of declared properties. Using this; feature, clang provides default synthesis of those properties not declared; @dynamic and not having user provided backing getter and setter methods.; ``__has_feature(objc_default_synthesize_properties)`` checks for availability; of this feature in version of clang being used. .. _langext-objc-retain-release:. Objective-C retaining behavior attributes; ----------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:84784,Usability,usab,usable,84784,"ers whose; type is a qualified-``id`` (e.g., ``id<Foo>``). This mangling allows such; parameters to be differentiated from those with the regular unqualified ``id``; type. This was a non-backward compatible mangling change to the ABI. This change; allows proper overloading, and also prevents mangling conflicts with template; parameters of protocol-qualified type. Query the presence of this new mangling with; ``__has_feature(objc_protocol_qualifier_mangling)``. Initializer lists for complex numbers in C; ==========================================. clang supports an extension which allows the following in C:. .. code-block:: c++. #include <math.h>; #include <complex.h>; complex float x = { 1.0f, INFINITY }; // Init to (1, Inf). This construct is useful because there is no way to separately initialize the; real and imaginary parts of a complex variable in standard C, given that clang; does not support ``_Imaginary``. (Clang also supports the ``__real__`` and; ``__imag__`` extensions from gcc, which help in some cases, but are not usable; in static initializers.). Note that this extension does not allow eliding the braces; the meaning of the; following two lines is different:. .. code-block:: c++. complex float x[] = { { 1.0f, 1.0f } }; // [0] = (1, 1); complex float x[] = { 1.0f, 1.0f }; // [0] = (1, 0), [1] = (1, 0). This extension also works in C++ mode, as far as that goes, but does not apply; to the C++ ``std::complex``. (In C++11, list initialization allows the same; syntax to be used with ``std::complex`` with the same meaning.). For GCC compatibility, ``__builtin_complex(re, im)`` can also be used to; construct a complex number from the given real and imaginary components. OpenCL Features; ===============. Clang supports internal OpenCL extensions documented below. ``__cl_clang_bitfields``; --------------------------------. With this extension it is possible to enable bitfields in structs; or unions using the OpenCL extension pragma mechanism detailed in; `the Op",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:101419,Usability,usab,usable,101419,"Note that the; definition of ""storage"" here refers to the outermost enclosing allocation of any; particular object (so for example, it's never correct to call this function; passing the addresses of fields in the same struct, elements of the same array,; etc.). Query for this feature with ``__has_builtin(__builtin_assume_separate_storage)``. ``__builtin_offsetof``; ----------------------. ``__builtin_offsetof`` is used to implement the ``offsetof`` macro, which; calculates the offset (in bytes) to a given member of the given type. **Syntax**:. .. code-block:: c++. __builtin_offsetof(type-name, member-designator). **Example of Use**:. .. code-block:: c++. struct S {; char c;; int i;; struct T {; float f[2];; } t;; };. const int offset_to_i = __builtin_offsetof(struct S, i);; const int ext1 = __builtin_offsetof(struct U { int i; }, i); // C extension; const int offset_to_subobject = __builtin_offsetof(struct S, t.f[1]);. **Description**:. This builtin is usable in an integer constant expression which returns a value; of type ``size_t``. The value returned is the offset in bytes to the subobject; designated by the member-designator from the beginning of an object of type; ``type-name``. Clang extends the required standard functionality in the; following way:. * In C language modes, the first argument may be the definition of a new type.; Any type declared this way is scoped to the nearest scope containing the call; to the builtin. Query for this feature with ``__has_builtin(__builtin_offsetof)``. ``__builtin_call_with_static_chain``; ------------------------------------. ``__builtin_call_with_static_chain`` is used to perform a static call while; setting updating the static chain register. **Syntax**:. .. code-block:: c++. T __builtin_call_with_static_chain(T expr, void* ptr). **Example of Use**:. .. code-block:: c++. auto v = __builtin_call_with_static_chain(foo(3), foo);. **Description**:. This builtin returns ``expr`` after checking that ``expr`` is a non-member; st",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:104853,Usability,simpl,simple,104853," that even if present, its use may depend on run-time privilege or other OS; controlled state. ``__builtin_dump_struct``; -------------------------. **Syntax**:. .. code-block:: c++. __builtin_dump_struct(&some_struct, some_printf_func, args...);. **Examples**:. .. code-block:: c++. struct S {; int x, y;; float f;; struct T {; int i;; } t;; };. void func(struct S *s) {; __builtin_dump_struct(s, printf);; }. Example output:. .. code-block:: none. struct S {; int x = 100; int y = 42; float f = 3.141593; struct T t = {; int i = 1997; }; }. .. code-block:: c++. #include <string>; struct T { int a, b; };; constexpr void constexpr_sprintf(std::string &out, const char *format,; auto ...args) {; // ...; }; constexpr std::string dump_struct(auto &x) {; std::string s;; __builtin_dump_struct(&x, constexpr_sprintf, s);; return s;; }; static_assert(dump_struct(T{1, 2}) == R""(struct T {; int a = 1; int b = 2; }; )"");. **Description**:. The ``__builtin_dump_struct`` function is used to print the fields of a simple; structure and their values for debugging purposes. The first argument of the; builtin should be a pointer to a complete record type to dump. The second argument ``f``; should be some callable expression, and can be a function object or an overload; set. The builtin calls ``f``, passing any further arguments ``args...``; followed by a ``printf``-compatible format string and the corresponding; arguments. ``f`` may be called more than once, and ``f`` and ``args`` will be; evaluated once per call. In C++, ``f`` may be a template or overload set and; resolve to different functions for each call. In the format string, a suitable format specifier will be used for builtin; types that Clang knows how to format. This includes standard builtin types, as; well as aggregate structures, ``void*`` (printed with ``%p``), and ``const; char*`` (printed with ``%s``). A ``*%p`` specifier will be used for a field; that Clang doesn't know how to format, and the corresponding argument will be ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:136081,Usability,usab,usable,136081,"---. Clang provides several builtins for working with variadic functions from the C; standard library ``<stdarg.h>`` header:. * ``__builtin_va_list``. A predefined typedef for the target-specific ``va_list`` type. * ``void __builtin_va_start(__builtin_va_list list, <parameter-name>)``. A builtin function for the target-specific ``va_start`` function-like macro.; The ``parameter-name`` argument is the name of the parameter preceding the; ellipsis (``...``) in the function signature. Alternatively, in C23 mode or; later, it may be the integer literal ``0`` if there is no parameter preceding; the ellipsis. This function initializes the given ``__builtin_va_list`` object.; It is undefined behavior to call this function on an already initialized; ``__builin_va_list`` object. * ``void __builtin_va_end(__builtin_va_list list)``. A builtin function for the target-specific ``va_end`` function-like macro. This; function finalizes the given ``__builtin_va_list`` object such that it is no; longer usable unless re-initialized with a call to ``__builtin_va_start`` or; ``__builtin_va_copy``. It is undefined behavior to call this function with a; ``list`` that has not been initialized by either ``__builtin_va_start`` or; ``__builtin_va_copy``. * ``<type-name> __builtin_va_arg(__builtin_va_list list, <type-name>)``. A builtin function for the target-specific ``va_arg`` function-like macro. This; function returns the value of the next variadic argument to the call. It is; undefined behavior to call this builtin when there is no next variadic argument; to retrieve or if the next variadic argument does not have a type compatible; with the given ``type-name``. The return type of the function is the; ``type-name`` given as the second argument. It is undefined behavior to call; this function with a ``list`` that has not been initialized by either; ``__builtin_va_start`` or ``__builtin_va_copy``. * ``void __builtin_va_copy(__builtin_va_list dest, __builtin_va_list src)``. A builtin function",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:144097,Usability,clear,clear,144097," controls whether or not the atomic operation is ordered with respect to the; whole system, the current device, an OpenCL workgroup, wavefront, or just a; single thread. If these are used on a target that does not support atomic; scopes, then they will behave exactly as the standard GNU atomic builtins. Low-level ARM exclusive memory builtins; ---------------------------------------. Clang provides overloaded builtins giving direct access to the three key ARM; instructions for implementing atomic operations. .. code-block:: c. T __builtin_arm_ldrex(const volatile T *addr);; T __builtin_arm_ldaex(const volatile T *addr);; int __builtin_arm_strex(T val, volatile T *addr);; int __builtin_arm_stlex(T val, volatile T *addr);; void __builtin_arm_clrex(void);. The types ``T`` currently supported are:. * Integer types with width at most 64 bits (or 128 bits on AArch64).; * Floating-point types; * Pointer types. Note that the compiler does not guarantee it will not insert stores which clear; the exclusive monitor in between an ``ldrex`` type operation and its paired; ``strex``. In practice this is only usually a risk when the extra store is on; the same cache line as the variable being modified and Clang will only insert; stack stores on its own, so it is best not to use these operations on variables; with automatic storage duration. Also, loads and stores may be implicit in code written between the ``ldrex`` and; ``strex``. Clang will not necessarily mitigate the effects of these either, so; care should be exercised. For these reasons the higher level atomic primitives should be preferred where; possible. Non-temporal load/store builtins; --------------------------------. Clang provides overloaded builtins allowing generation of non-temporal memory; accesses. .. code-block:: c. T __builtin_nontemporal_load(T *addr);; void __builtin_nontemporal_store(T value, T *addr);. The types ``T`` currently supported are:. * Integer types.; * Floating-point types.; * Vector types. Note t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:145904,Usability,resume,resume,145904,"n_nontemporal_store(T value, T *addr);. The types ``T`` currently supported are:. * Integer types.; * Floating-point types.; * Vector types. Note that the compiler does not guarantee that non-temporal loads or stores; will be used. C++ Coroutines support builtins; --------------------------------. .. warning::; This is a work in progress. Compatibility across Clang/LLVM releases is not; guaranteed. Clang provides experimental builtins to support C++ Coroutines as defined by; https://wg21.link/P0057. The following four are intended to be used by the; standard library to implement the ``std::coroutine_handle`` type. **Syntax**:. .. code-block:: c. void __builtin_coro_resume(void *addr);; void __builtin_coro_destroy(void *addr);; bool __builtin_coro_done(void *addr);; void *__builtin_coro_promise(void *addr, int alignment, bool from_promise). **Example of use**:. .. code-block:: c++. template <> struct coroutine_handle<void> {; void resume() const { __builtin_coro_resume(ptr); }; void destroy() const { __builtin_coro_destroy(ptr); }; bool done() const { return __builtin_coro_done(ptr); }; // ...; protected:; void *ptr;; };. template <typename Promise> struct coroutine_handle : coroutine_handle<> {; // ...; Promise &promise() const {; return *reinterpret_cast<Promise *>(; __builtin_coro_promise(ptr, alignof(Promise), /*from-promise=*/false));; }; static coroutine_handle from_promise(Promise &promise) {; coroutine_handle p;; p.ptr = __builtin_coro_promise(&promise, alignof(Promise),; /*from-promise=*/true);; return p;; }; };. Other coroutine builtins are either for internal clang use or for use during; development of the coroutine feature. See `Coroutines in LLVM; <https://llvm.org/docs/Coroutines.html#intrinsics>`_ for; more information on their semantics. Note that builtins matching the intrinsics; that take token as the first parameter (llvm.coro.begin, llvm.coro.alloc,; llvm.coro.free and llvm.coro.suspend) omit the token parameter and fill it to; an appropriate valu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:154949,Usability,simpl,simple,154949,"h the GCC; implementation, these attributes must appertain to the *declarator-id* in a; declaration, which means they must go either at the start of the declaration or; immediately after the name being declared. For example, this applies the GNU ``unused`` attribute to ``a`` and ``f``, and; also applies the GNU ``noreturn`` attribute to ``f``. .. code-block:: c++. [[gnu::unused]] int a, f [[gnu::noreturn]] ();. Target-Specific Extensions; ==========================. Clang supports some language features conditionally on some targets. ARM/AArch64 Language Extensions; -------------------------------. Memory Barrier Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^; Clang implements the ``__dmb``, ``__dsb`` and ``__isb`` intrinsics as defined; in the `Arm C Language Extensions; <https://github.com/ARM-software/acle/releases>`_.; Note that these intrinsics are implemented as motion barriers that block; reordering of memory accesses and side effect instructions. Other instructions; like simple arithmetic may be reordered around the intrinsic. If you expect to; have no reordering at all, use inline assembly instead. X86/X86-64 Language Extensions; ------------------------------. The X86 backend has these language extensions:. Memory references to specified segments; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Annotating a pointer with address space #256 causes it to be code generated; relative to the X86 GS segment register, address space #257 causes it to be; relative to the X86 FS segment, and address space #258 causes it to be; relative to the X86 SS segment. Note that this is a very very low-level; feature that should only be used if you know what you're doing (for example in; an OS kernel). Here is an example:. .. code-block:: c++. #define GS_RELATIVE __attribute__((address_space(256))); int foo(int GS_RELATIVE *P) {; return *P;; }. Which compiles to (on X86-32):. .. code-block:: gas. _foo:; movl 4(%esp), %eax; movl %gs:(%eax), %eax; ret. You can also use the GCC compatibility macr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:169529,Usability,guid,guide,169529,"d loop containing S2 will be vectorized. Loop Distribution is currently not enabled by default in the optimizer because; it can hurt performance in some cases. For example, instruction-level; parallelism could be reduced by sequentializing the execution of the; statements S1 and S2 above. If Loop Distribution is turned on globally with; ``-mllvm -enable-loop-distribution``, specifying ``distribute(disable)`` can; be used the disable it on a per-loop basis. Additional Information; ----------------------. For convenience multiple loop hints can be specified on a single line. .. code-block:: c++. #pragma clang loop vectorize_width(4) interleave_count(8); for(...) {; ...; }. If an optimization cannot be applied any hints that apply to it will be ignored.; For example, the hint ``vectorize_width(4)`` is ignored if the loop is not; proven safe to vectorize. To identify and diagnose optimization issues use; `-Rpass`, `-Rpass-missed`, and `-Rpass-analysis` command line options. See the; user guide for details. Extensions to specify floating-point flags; ====================================================. The ``#pragma clang fp`` pragma allows floating-point options to be specified; for a section of the source code. This pragma can only appear at file scope or; at the start of a compound statement (excluding comments). When using within a; compound statement, the pragma is active within the scope of the compound; statement. Currently, the following settings can be controlled with this pragma:. ``#pragma clang fp reassociate`` allows control over the reassociation; of floating point expressions. When enabled, this pragma allows the expression; ``x + (y + z)`` to be reassociated as ``(x + y) + z``.; Reassociation can also occur across multiple statements.; This pragma can be used to disable reassociation when it is otherwise; enabled for the translation unit with the ``-fassociative-math`` flag.; The pragma can take two values: ``on`` and ``off``. .. code-block:: c++. float f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LeakSanitizer.rst:221,Availability,error,error,221,"================; LeakSanitizer; ================. .. contents::; :local:. Introduction; ============. LeakSanitizer is a run-time memory leak detector. It can be combined with; :doc:`AddressSanitizer` to get both memory error and leak detection, or; used in a stand-alone mode. LSan adds almost no performance overhead; until the very end of the process, at which point there is an extra leak; detection phase. Usage; =====. :doc:`AddressSanitizer`: integrates LeakSanitizer and enables it by default on; supported platforms. .. code-block:: console. $ cat memory-leak.c; #include <stdlib.h>; void *p;; int main() {; p = malloc(7);; p = 0; // The memory is leaked here.; return 0;; }; % clang -fsanitize=address -g memory-leak.c ; ASAN_OPTIONS=detect_leaks=1 ./a.out; ==23646==ERROR: LeakSanitizer: detected memory leaks; Direct leak of 7 byte(s) in 1 object(s) allocated from:; #0 0x4af01b in __interceptor_malloc /projects/compiler-rt/lib/asan/asan_malloc_linux.cc:52:3; #1 0x4da26a in main memory-leak.c:4:7; #2 0x7f076fd9cec4 in __libc_start_main libc-start.c:287; SUMMARY: AddressSanitizer: 7 byte(s) leaked in 1 allocation(s). To use LeakSanitizer in stand-alone mode, link your program with; ``-fsanitize=leak`` flag. Make sure to use ``clang`` (not ``ld``) for the; link step, so that it would link in proper LeakSanitizer run-time library; into the final executable. Supported Platforms; ===================. * Android aarch64/i386/x86_64; * Fuchsia aarch64/x86_64; * Linux arm/aarch64/mips64/ppc64/ppc64le/riscv64/s390x/i386/x86\_64; * macOS aarch64/i386/x86\_64; * NetBSD i386/x86_64. More Information; ================. `<https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LeakSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LeakSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LeakSanitizer.rst:451,Deployability,integrat,integrates,451,"================; LeakSanitizer; ================. .. contents::; :local:. Introduction; ============. LeakSanitizer is a run-time memory leak detector. It can be combined with; :doc:`AddressSanitizer` to get both memory error and leak detection, or; used in a stand-alone mode. LSan adds almost no performance overhead; until the very end of the process, at which point there is an extra leak; detection phase. Usage; =====. :doc:`AddressSanitizer`: integrates LeakSanitizer and enables it by default on; supported platforms. .. code-block:: console. $ cat memory-leak.c; #include <stdlib.h>; void *p;; int main() {; p = malloc(7);; p = 0; // The memory is leaked here.; return 0;; }; % clang -fsanitize=address -g memory-leak.c ; ASAN_OPTIONS=detect_leaks=1 ./a.out; ==23646==ERROR: LeakSanitizer: detected memory leaks; Direct leak of 7 byte(s) in 1 object(s) allocated from:; #0 0x4af01b in __interceptor_malloc /projects/compiler-rt/lib/asan/asan_malloc_linux.cc:52:3; #1 0x4da26a in main memory-leak.c:4:7; #2 0x7f076fd9cec4 in __libc_start_main libc-start.c:287; SUMMARY: AddressSanitizer: 7 byte(s) leaked in 1 allocation(s). To use LeakSanitizer in stand-alone mode, link your program with; ``-fsanitize=leak`` flag. Make sure to use ``clang`` (not ``ld``) for the; link step, so that it would link in proper LeakSanitizer run-time library; into the final executable. Supported Platforms; ===================. * Android aarch64/i386/x86_64; * Fuchsia aarch64/x86_64; * Linux arm/aarch64/mips64/ppc64/ppc64le/riscv64/s390x/i386/x86\_64; * macOS aarch64/i386/x86\_64; * NetBSD i386/x86_64. More Information; ================. `<https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LeakSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LeakSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LeakSanitizer.rst:863,Energy Efficiency,allocate,allocated,863,"================; LeakSanitizer; ================. .. contents::; :local:. Introduction; ============. LeakSanitizer is a run-time memory leak detector. It can be combined with; :doc:`AddressSanitizer` to get both memory error and leak detection, or; used in a stand-alone mode. LSan adds almost no performance overhead; until the very end of the process, at which point there is an extra leak; detection phase. Usage; =====. :doc:`AddressSanitizer`: integrates LeakSanitizer and enables it by default on; supported platforms. .. code-block:: console. $ cat memory-leak.c; #include <stdlib.h>; void *p;; int main() {; p = malloc(7);; p = 0; // The memory is leaked here.; return 0;; }; % clang -fsanitize=address -g memory-leak.c ; ASAN_OPTIONS=detect_leaks=1 ./a.out; ==23646==ERROR: LeakSanitizer: detected memory leaks; Direct leak of 7 byte(s) in 1 object(s) allocated from:; #0 0x4af01b in __interceptor_malloc /projects/compiler-rt/lib/asan/asan_malloc_linux.cc:52:3; #1 0x4da26a in main memory-leak.c:4:7; #2 0x7f076fd9cec4 in __libc_start_main libc-start.c:287; SUMMARY: AddressSanitizer: 7 byte(s) leaked in 1 allocation(s). To use LeakSanitizer in stand-alone mode, link your program with; ``-fsanitize=leak`` flag. Make sure to use ``clang`` (not ``ld``) for the; link step, so that it would link in proper LeakSanitizer run-time library; into the final executable. Supported Platforms; ===================. * Android aarch64/i386/x86_64; * Fuchsia aarch64/x86_64; * Linux arm/aarch64/mips64/ppc64/ppc64le/riscv64/s390x/i386/x86\_64; * macOS aarch64/i386/x86\_64; * NetBSD i386/x86_64. More Information; ================. `<https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LeakSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LeakSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LeakSanitizer.rst:451,Integrability,integrat,integrates,451,"================; LeakSanitizer; ================. .. contents::; :local:. Introduction; ============. LeakSanitizer is a run-time memory leak detector. It can be combined with; :doc:`AddressSanitizer` to get both memory error and leak detection, or; used in a stand-alone mode. LSan adds almost no performance overhead; until the very end of the process, at which point there is an extra leak; detection phase. Usage; =====. :doc:`AddressSanitizer`: integrates LeakSanitizer and enables it by default on; supported platforms. .. code-block:: console. $ cat memory-leak.c; #include <stdlib.h>; void *p;; int main() {; p = malloc(7);; p = 0; // The memory is leaked here.; return 0;; }; % clang -fsanitize=address -g memory-leak.c ; ASAN_OPTIONS=detect_leaks=1 ./a.out; ==23646==ERROR: LeakSanitizer: detected memory leaks; Direct leak of 7 byte(s) in 1 object(s) allocated from:; #0 0x4af01b in __interceptor_malloc /projects/compiler-rt/lib/asan/asan_malloc_linux.cc:52:3; #1 0x4da26a in main memory-leak.c:4:7; #2 0x7f076fd9cec4 in __libc_start_main libc-start.c:287; SUMMARY: AddressSanitizer: 7 byte(s) leaked in 1 allocation(s). To use LeakSanitizer in stand-alone mode, link your program with; ``-fsanitize=leak`` flag. Make sure to use ``clang`` (not ``ld``) for the; link step, so that it would link in proper LeakSanitizer run-time library; into the final executable. Supported Platforms; ===================. * Android aarch64/i386/x86_64; * Fuchsia aarch64/x86_64; * Linux arm/aarch64/mips64/ppc64/ppc64le/riscv64/s390x/i386/x86\_64; * macOS aarch64/i386/x86\_64; * NetBSD i386/x86_64. More Information; ================. `<https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LeakSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LeakSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LeakSanitizer.rst:299,Performance,perform,performance,299,"================; LeakSanitizer; ================. .. contents::; :local:. Introduction; ============. LeakSanitizer is a run-time memory leak detector. It can be combined with; :doc:`AddressSanitizer` to get both memory error and leak detection, or; used in a stand-alone mode. LSan adds almost no performance overhead; until the very end of the process, at which point there is an extra leak; detection phase. Usage; =====. :doc:`AddressSanitizer`: integrates LeakSanitizer and enables it by default on; supported platforms. .. code-block:: console. $ cat memory-leak.c; #include <stdlib.h>; void *p;; int main() {; p = malloc(7);; p = 0; // The memory is leaked here.; return 0;; }; % clang -fsanitize=address -g memory-leak.c ; ASAN_OPTIONS=detect_leaks=1 ./a.out; ==23646==ERROR: LeakSanitizer: detected memory leaks; Direct leak of 7 byte(s) in 1 object(s) allocated from:; #0 0x4af01b in __interceptor_malloc /projects/compiler-rt/lib/asan/asan_malloc_linux.cc:52:3; #1 0x4da26a in main memory-leak.c:4:7; #2 0x7f076fd9cec4 in __libc_start_main libc-start.c:287; SUMMARY: AddressSanitizer: 7 byte(s) leaked in 1 allocation(s). To use LeakSanitizer in stand-alone mode, link your program with; ``-fsanitize=leak`` flag. Make sure to use ``clang`` (not ``ld``) for the; link step, so that it would link in proper LeakSanitizer run-time library; into the final executable. Supported Platforms; ===================. * Android aarch64/i386/x86_64; * Fuchsia aarch64/x86_64; * Linux arm/aarch64/mips64/ppc64/ppc64le/riscv64/s390x/i386/x86\_64; * macOS aarch64/i386/x86\_64; * NetBSD i386/x86_64. More Information; ================. `<https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LeakSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LeakSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LeakSanitizer.rst:143,Safety,detect,detector,143,"================; LeakSanitizer; ================. .. contents::; :local:. Introduction; ============. LeakSanitizer is a run-time memory leak detector. It can be combined with; :doc:`AddressSanitizer` to get both memory error and leak detection, or; used in a stand-alone mode. LSan adds almost no performance overhead; until the very end of the process, at which point there is an extra leak; detection phase. Usage; =====. :doc:`AddressSanitizer`: integrates LeakSanitizer and enables it by default on; supported platforms. .. code-block:: console. $ cat memory-leak.c; #include <stdlib.h>; void *p;; int main() {; p = malloc(7);; p = 0; // The memory is leaked here.; return 0;; }; % clang -fsanitize=address -g memory-leak.c ; ASAN_OPTIONS=detect_leaks=1 ./a.out; ==23646==ERROR: LeakSanitizer: detected memory leaks; Direct leak of 7 byte(s) in 1 object(s) allocated from:; #0 0x4af01b in __interceptor_malloc /projects/compiler-rt/lib/asan/asan_malloc_linux.cc:52:3; #1 0x4da26a in main memory-leak.c:4:7; #2 0x7f076fd9cec4 in __libc_start_main libc-start.c:287; SUMMARY: AddressSanitizer: 7 byte(s) leaked in 1 allocation(s). To use LeakSanitizer in stand-alone mode, link your program with; ``-fsanitize=leak`` flag. Make sure to use ``clang`` (not ``ld``) for the; link step, so that it would link in proper LeakSanitizer run-time library; into the final executable. Supported Platforms; ===================. * Android aarch64/i386/x86_64; * Fuchsia aarch64/x86_64; * Linux arm/aarch64/mips64/ppc64/ppc64le/riscv64/s390x/i386/x86\_64; * macOS aarch64/i386/x86\_64; * NetBSD i386/x86_64. More Information; ================. `<https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LeakSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LeakSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LeakSanitizer.rst:236,Safety,detect,detection,236,"================; LeakSanitizer; ================. .. contents::; :local:. Introduction; ============. LeakSanitizer is a run-time memory leak detector. It can be combined with; :doc:`AddressSanitizer` to get both memory error and leak detection, or; used in a stand-alone mode. LSan adds almost no performance overhead; until the very end of the process, at which point there is an extra leak; detection phase. Usage; =====. :doc:`AddressSanitizer`: integrates LeakSanitizer and enables it by default on; supported platforms. .. code-block:: console. $ cat memory-leak.c; #include <stdlib.h>; void *p;; int main() {; p = malloc(7);; p = 0; // The memory is leaked here.; return 0;; }; % clang -fsanitize=address -g memory-leak.c ; ASAN_OPTIONS=detect_leaks=1 ./a.out; ==23646==ERROR: LeakSanitizer: detected memory leaks; Direct leak of 7 byte(s) in 1 object(s) allocated from:; #0 0x4af01b in __interceptor_malloc /projects/compiler-rt/lib/asan/asan_malloc_linux.cc:52:3; #1 0x4da26a in main memory-leak.c:4:7; #2 0x7f076fd9cec4 in __libc_start_main libc-start.c:287; SUMMARY: AddressSanitizer: 7 byte(s) leaked in 1 allocation(s). To use LeakSanitizer in stand-alone mode, link your program with; ``-fsanitize=leak`` flag. Make sure to use ``clang`` (not ``ld``) for the; link step, so that it would link in proper LeakSanitizer run-time library; into the final executable. Supported Platforms; ===================. * Android aarch64/i386/x86_64; * Fuchsia aarch64/x86_64; * Linux arm/aarch64/mips64/ppc64/ppc64le/riscv64/s390x/i386/x86\_64; * macOS aarch64/i386/x86\_64; * NetBSD i386/x86_64. More Information; ================. `<https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LeakSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LeakSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LeakSanitizer.rst:395,Safety,detect,detection,395,"================; LeakSanitizer; ================. .. contents::; :local:. Introduction; ============. LeakSanitizer is a run-time memory leak detector. It can be combined with; :doc:`AddressSanitizer` to get both memory error and leak detection, or; used in a stand-alone mode. LSan adds almost no performance overhead; until the very end of the process, at which point there is an extra leak; detection phase. Usage; =====. :doc:`AddressSanitizer`: integrates LeakSanitizer and enables it by default on; supported platforms. .. code-block:: console. $ cat memory-leak.c; #include <stdlib.h>; void *p;; int main() {; p = malloc(7);; p = 0; // The memory is leaked here.; return 0;; }; % clang -fsanitize=address -g memory-leak.c ; ASAN_OPTIONS=detect_leaks=1 ./a.out; ==23646==ERROR: LeakSanitizer: detected memory leaks; Direct leak of 7 byte(s) in 1 object(s) allocated from:; #0 0x4af01b in __interceptor_malloc /projects/compiler-rt/lib/asan/asan_malloc_linux.cc:52:3; #1 0x4da26a in main memory-leak.c:4:7; #2 0x7f076fd9cec4 in __libc_start_main libc-start.c:287; SUMMARY: AddressSanitizer: 7 byte(s) leaked in 1 allocation(s). To use LeakSanitizer in stand-alone mode, link your program with; ``-fsanitize=leak`` flag. Make sure to use ``clang`` (not ``ld``) for the; link step, so that it would link in proper LeakSanitizer run-time library; into the final executable. Supported Platforms; ===================. * Android aarch64/i386/x86_64; * Fuchsia aarch64/x86_64; * Linux arm/aarch64/mips64/ppc64/ppc64le/riscv64/s390x/i386/x86\_64; * macOS aarch64/i386/x86\_64; * NetBSD i386/x86_64. More Information; ================. `<https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LeakSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LeakSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LeakSanitizer.rst:800,Safety,detect,detected,800,"================; LeakSanitizer; ================. .. contents::; :local:. Introduction; ============. LeakSanitizer is a run-time memory leak detector. It can be combined with; :doc:`AddressSanitizer` to get both memory error and leak detection, or; used in a stand-alone mode. LSan adds almost no performance overhead; until the very end of the process, at which point there is an extra leak; detection phase. Usage; =====. :doc:`AddressSanitizer`: integrates LeakSanitizer and enables it by default on; supported platforms. .. code-block:: console. $ cat memory-leak.c; #include <stdlib.h>; void *p;; int main() {; p = malloc(7);; p = 0; // The memory is leaked here.; return 0;; }; % clang -fsanitize=address -g memory-leak.c ; ASAN_OPTIONS=detect_leaks=1 ./a.out; ==23646==ERROR: LeakSanitizer: detected memory leaks; Direct leak of 7 byte(s) in 1 object(s) allocated from:; #0 0x4af01b in __interceptor_malloc /projects/compiler-rt/lib/asan/asan_malloc_linux.cc:52:3; #1 0x4da26a in main memory-leak.c:4:7; #2 0x7f076fd9cec4 in __libc_start_main libc-start.c:287; SUMMARY: AddressSanitizer: 7 byte(s) leaked in 1 allocation(s). To use LeakSanitizer in stand-alone mode, link your program with; ``-fsanitize=leak`` flag. Make sure to use ``clang`` (not ``ld``) for the; link step, so that it would link in proper LeakSanitizer run-time library; into the final executable. Supported Platforms; ===================. * Android aarch64/i386/x86_64; * Fuchsia aarch64/x86_64; * Linux arm/aarch64/mips64/ppc64/ppc64le/riscv64/s390x/i386/x86\_64; * macOS aarch64/i386/x86\_64; * NetBSD i386/x86_64. More Information; ================. `<https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LeakSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LeakSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LeakSanitizer.rst:1661,Security,sanitiz,sanitizers,1661,"================; LeakSanitizer; ================. .. contents::; :local:. Introduction; ============. LeakSanitizer is a run-time memory leak detector. It can be combined with; :doc:`AddressSanitizer` to get both memory error and leak detection, or; used in a stand-alone mode. LSan adds almost no performance overhead; until the very end of the process, at which point there is an extra leak; detection phase. Usage; =====. :doc:`AddressSanitizer`: integrates LeakSanitizer and enables it by default on; supported platforms. .. code-block:: console. $ cat memory-leak.c; #include <stdlib.h>; void *p;; int main() {; p = malloc(7);; p = 0; // The memory is leaked here.; return 0;; }; % clang -fsanitize=address -g memory-leak.c ; ASAN_OPTIONS=detect_leaks=1 ./a.out; ==23646==ERROR: LeakSanitizer: detected memory leaks; Direct leak of 7 byte(s) in 1 object(s) allocated from:; #0 0x4af01b in __interceptor_malloc /projects/compiler-rt/lib/asan/asan_malloc_linux.cc:52:3; #1 0x4da26a in main memory-leak.c:4:7; #2 0x7f076fd9cec4 in __libc_start_main libc-start.c:287; SUMMARY: AddressSanitizer: 7 byte(s) leaked in 1 allocation(s). To use LeakSanitizer in stand-alone mode, link your program with; ``-fsanitize=leak`` flag. Make sure to use ``clang`` (not ``ld``) for the; link step, so that it would link in proper LeakSanitizer run-time library; into the final executable. Supported Platforms; ===================. * Android aarch64/i386/x86_64; * Fuchsia aarch64/x86_64; * Linux arm/aarch64/mips64/ppc64/ppc64le/riscv64/s390x/i386/x86\_64; * macOS aarch64/i386/x86\_64; * NetBSD i386/x86_64. More Information; ================. `<https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LeakSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LeakSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:3452,Availability,error,error,3452,"at the structurally equivalent nodes in the different translation units are not getting duplicated in the merged AST.; E.g. if we include the definition of the vector template (``#include <vector>``) in two translation units, then their merged AST should have only one node which represents the template.; Also, we have to discover *one definition rule* (ODR) violations.; For instance, if there is a class definition with the same name in both translation units, but one of the definition contains a different number of fields.; So, we look up existing definitions, and then we check the structural equivalency on those nodes.; The following pseudo-code demonstrates the basics of the import mechanism:. .. code-block:: cpp. // Pseudo-code(!) of import:; ErrorOrDecl Import(Decl *FromD) {; Decl *ToDecl = nullptr;; FoundDeclsList = Look up all Decls in the ""to"" Ctx with the same name of FromD;; for (auto FoundDecl : FoundDeclsList) {; if (StructurallyEquivalentDecls(FoundDecl, FromD)) {; ToDecl = FoundDecl;; Mark FromD as imported;; break;; } else {; Report ODR violation;; return error;; }; }; if (FoundDeclsList is empty) {; Import dependent declarations and types of ToDecl;; ToDecl = create a new AST node in ""to"" Ctx;; Mark FromD as imported;; }; return ToDecl;; }. Two AST nodes are *structurally equivalent* if they are. - builtin types and refer to the same type, e.g. ``int`` and ``int`` are structurally equivalent,; - function types and all their parameters have structurally equivalent types,; - record types and all their fields in order of their definition have the same identifier names and structurally equivalent types,; - variable or function declarations and they have the same identifier name and their types are structurally equivalent. We could extend the definition of structural equivalency to templates similarly. If A and B are AST nodes and *A depends on B*, then we say that A is a **dependant** of B and B is a **dependency** of A.; The words ""dependant"" and ""depend",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:5705,Availability,error,error,5705,"; First, we build two ASTs from virtual files; the content of the virtual files are synthesized from string literals:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc""); // empty file; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");. The first AST corresponds to the destination (""to"") context - which is empty - and the second for the source (""from"") context.; Next, we define a matcher to match ``MyClass`` in the ""from"" context:. .. code-block:: cpp. auto Matcher = cxxRecordDecl(hasName(""MyClass""));; auto *From = getFirstDecl<CXXRecordDecl>(Matcher, FromUnit);. Now we create the Importer and do the import:. .. code-block:: cpp. ASTImporter Importer(ToUnit->getASTContext(), ToUnit->getFileManager(),; FromUnit->getASTContext(), FromUnit->getFileManager(),; /*MinimalImport=*/true);; llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);. The ``Import`` call returns with ``llvm::Expected``, so, we must check for any error.; Please refer to the `error handling <https://llvm.org/docs/ProgrammersManual.html#recoverable-errors>`_ documentation for details. .. code-block:: cpp. if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }. If there's no error then we can get the underlying value.; In this example we will print the AST of the ""to"" context. .. code-block:: cpp. Decl *Imported = *ImportedOrErr;; Imported->getTranslationUnitDecl()->dump();. Since we set **minimal import** in the constructor of the importer, the AST will not contain the declaration of the members (once we run the test tool). .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; `-DefinitionData pass_in_registers standard_layout trivially_copyable trivial literal; |-DefaultConstructor exists",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:5734,Availability,error,error,5734,"tual files are synthesized from string literals:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc""); // empty file; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");. The first AST corresponds to the destination (""to"") context - which is empty - and the second for the source (""from"") context.; Next, we define a matcher to match ``MyClass`` in the ""from"" context:. .. code-block:: cpp. auto Matcher = cxxRecordDecl(hasName(""MyClass""));; auto *From = getFirstDecl<CXXRecordDecl>(Matcher, FromUnit);. Now we create the Importer and do the import:. .. code-block:: cpp. ASTImporter Importer(ToUnit->getASTContext(), ToUnit->getFileManager(),; FromUnit->getASTContext(), FromUnit->getFileManager(),; /*MinimalImport=*/true);; llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);. The ``Import`` call returns with ``llvm::Expected``, so, we must check for any error.; Please refer to the `error handling <https://llvm.org/docs/ProgrammersManual.html#recoverable-errors>`_ documentation for details. .. code-block:: cpp. if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }. If there's no error then we can get the underlying value.; In this example we will print the AST of the ""to"" context. .. code-block:: cpp. Decl *Imported = *ImportedOrErr;; Imported->getTranslationUnitDecl()->dump();. Since we set **minimal import** in the constructor of the importer, the AST will not contain the declaration of the members (once we run the test tool). .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; `-DefinitionData pass_in_registers standard_layout trivially_copyable trivial literal; |-DefaultConstructor exists trivial needs_implicit; |-CopyConstructor simple trivial has_const_p",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:5795,Availability,recover,recoverable-errors,5795,"que_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc""); // empty file; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");. The first AST corresponds to the destination (""to"") context - which is empty - and the second for the source (""from"") context.; Next, we define a matcher to match ``MyClass`` in the ""from"" context:. .. code-block:: cpp. auto Matcher = cxxRecordDecl(hasName(""MyClass""));; auto *From = getFirstDecl<CXXRecordDecl>(Matcher, FromUnit);. Now we create the Importer and do the import:. .. code-block:: cpp. ASTImporter Importer(ToUnit->getASTContext(), ToUnit->getFileManager(),; FromUnit->getASTContext(), FromUnit->getFileManager(),; /*MinimalImport=*/true);; llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);. The ``Import`` call returns with ``llvm::Expected``, so, we must check for any error.; Please refer to the `error handling <https://llvm.org/docs/ProgrammersManual.html#recoverable-errors>`_ documentation for details. .. code-block:: cpp. if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }. If there's no error then we can get the underlying value.; In this example we will print the AST of the ""to"" context. .. code-block:: cpp. Decl *Imported = *ImportedOrErr;; Imported->getTranslationUnitDecl()->dump();. Since we set **minimal import** in the constructor of the importer, the AST will not contain the declaration of the members (once we run the test tool). .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; `-DefinitionData pass_in_registers standard_layout trivially_copyable trivial literal; |-DefaultConstructor exists trivial needs_implicit; |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; |-MoveConstructor exists simple tr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:6036,Availability,error,error,6036,"n (""to"") context - which is empty - and the second for the source (""from"") context.; Next, we define a matcher to match ``MyClass`` in the ""from"" context:. .. code-block:: cpp. auto Matcher = cxxRecordDecl(hasName(""MyClass""));; auto *From = getFirstDecl<CXXRecordDecl>(Matcher, FromUnit);. Now we create the Importer and do the import:. .. code-block:: cpp. ASTImporter Importer(ToUnit->getASTContext(), ToUnit->getFileManager(),; FromUnit->getASTContext(), FromUnit->getFileManager(),; /*MinimalImport=*/true);; llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);. The ``Import`` call returns with ``llvm::Expected``, so, we must check for any error.; Please refer to the `error handling <https://llvm.org/docs/ProgrammersManual.html#recoverable-errors>`_ documentation for details. .. code-block:: cpp. if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }. If there's no error then we can get the underlying value.; In this example we will print the AST of the ""to"" context. .. code-block:: cpp. Decl *Imported = *ImportedOrErr;; Imported->getTranslationUnitDecl()->dump();. Since we set **minimal import** in the constructor of the importer, the AST will not contain the declaration of the members (once we run the test tool). .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; `-DefinitionData pass_in_registers standard_layout trivially_copyable trivial literal; |-DefaultConstructor exists trivial needs_implicit; |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; |-MoveConstructor exists simple trivial needs_implicit; |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; |-MoveAssignment exists simple trivial needs_implicit; `-Destructor simple irrelevant trivial needs_implicit. We'd like to get th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:13302,Availability,error,error,13302,"ClassTemplateSpecializationDecl>(Matcher, ToUnit);. ASTImporter Importer(ToUnit->getASTContext(), ToUnit->getFileManager(),; FromUnit->getASTContext(), FromUnit->getFileManager(),; /*MinimalImport=*/false);; llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; To->getTranslationUnitDecl()->dump();; return 1;; }; return 0;; };. When we run the tool we have the following warning:. .. code-block:: bash. to.cc:7:14: warning: type 'X<int>' has incompatible definitions in different translation units [-Wodr]; struct X<int> { int i; };; ^; to.cc:7:27: note: field has name 'i' here; struct X<int> { int i; };; ^; from.cc:7:27: note: field has name 'i2' here; struct X<int> { int i2; };; ^. Note, because of these diagnostics we had to call ``enableSourceFileDiagnostics`` on the ``ASTUnit`` objects. Since we could not import the specified declaration (``From``), we get an error in the return value.; The AST does not contain the conflicting definition, so we are left with the original AST. .. code-block:: bash. ERROR: NameConflict; TranslationUnitDecl 0xe54a48 <<invalid sloc>> <invalid sloc>; |-ClassTemplateDecl 0xe91020 <to.cc:3:7, line:4:17> col:14 X; | |-TemplateTypeParmDecl 0xe90ed0 <line:3:17, col:26> col:26 typename depth 0 index 0 T; | |-CXXRecordDecl 0xe90f90 <line:4:7, col:17> col:14 struct X definition; | | |-DefinitionData empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init; | | | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr; | | | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | | | |-MoveConstructor exists simple trivial needs_implicit; | | | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | | | |-MoveAssignment exists simple triv",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:15361,Availability,error,error,15361,"eds_implicit; | | `-CXXRecordDecl 0xe91270 <col:7, col:14> col:14 implicit struct X; | `-ClassTemplateSpecialization 0xe91340 'X'; `-ClassTemplateSpecializationDecl 0xe91340 <line:6:7, line:7:30> col:14 struct X definition; |-DefinitionData pass_in_registers aggregate standard_layout trivially_copyable pod trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-TemplateArgument type 'int'; |-CXXRecordDecl 0xe91558 <col:7, col:14> col:14 implicit struct X; `-FieldDecl 0xe91600 <col:23, col:27> col:27 i 'int'. Error propagation; """""""""""""""""""""""""""""""""". If there is a dependent node we have to import before we could import a given node then the import error associated to the dependency propagates to the dependant node.; Let's modify the previous example and import a ``FieldDecl`` instead of the ``ClassTemplateSpecializationDecl``. .. code-block:: cpp. auto Matcher = fieldDecl(hasName(""i2""));; auto *From = getFirstDecl<FieldDecl>(Matcher, FromUnit);. In this case we can see that an error is associated (``getImportDeclErrorIfAny``) to the specialization also, not just to the field:. .. code-block:: cpp. llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // check that the ClassTemplateSpecializationDecl is also marked as; // erroneous.; auto *FromSpec = getFirstDecl<ClassTemplateSpecializationDecl>(; classTemplateSpecializationDecl(hasName(""X"")), FromUnit);; assert(Importer.getImportDeclErrorIfAny(FromSpec));; // Btw, the error is also set for the FieldDecl.; assert(Importer.getImportDeclErrorIfAny(From));; re",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:15697,Availability,error,error,15697,"yConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-TemplateArgument type 'int'; |-CXXRecordDecl 0xe91558 <col:7, col:14> col:14 implicit struct X; `-FieldDecl 0xe91600 <col:23, col:27> col:27 i 'int'. Error propagation; """""""""""""""""""""""""""""""""". If there is a dependent node we have to import before we could import a given node then the import error associated to the dependency propagates to the dependant node.; Let's modify the previous example and import a ``FieldDecl`` instead of the ``ClassTemplateSpecializationDecl``. .. code-block:: cpp. auto Matcher = fieldDecl(hasName(""i2""));; auto *From = getFirstDecl<FieldDecl>(Matcher, FromUnit);. In this case we can see that an error is associated (``getImportDeclErrorIfAny``) to the specialization also, not just to the field:. .. code-block:: cpp. llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // check that the ClassTemplateSpecializationDecl is also marked as; // erroneous.; auto *FromSpec = getFirstDecl<ClassTemplateSpecializationDecl>(; classTemplateSpecializationDecl(hasName(""X"")), FromUnit);; assert(Importer.getImportDeclErrorIfAny(FromSpec));; // Btw, the error is also set for the FieldDecl.; assert(Importer.getImportDeclErrorIfAny(From));; return 1;; }. Polluted AST; """""""""""""""""""""""". We may recognize an error during the import of a dependent node. However, by that time, we had already created the dependant.; In these cases we do not remove the existing erroneous node from the ""to"" context, rather we associate an error to that node.; Let's extend the previous example with another class ``Y``.; This class has a forward defini",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:16256,Availability,error,error,16256,""""""""""""""""""""""". If there is a dependent node we have to import before we could import a given node then the import error associated to the dependency propagates to the dependant node.; Let's modify the previous example and import a ``FieldDecl`` instead of the ``ClassTemplateSpecializationDecl``. .. code-block:: cpp. auto Matcher = fieldDecl(hasName(""i2""));; auto *From = getFirstDecl<FieldDecl>(Matcher, FromUnit);. In this case we can see that an error is associated (``getImportDeclErrorIfAny``) to the specialization also, not just to the field:. .. code-block:: cpp. llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // check that the ClassTemplateSpecializationDecl is also marked as; // erroneous.; auto *FromSpec = getFirstDecl<ClassTemplateSpecializationDecl>(; classTemplateSpecializationDecl(hasName(""X"")), FromUnit);; assert(Importer.getImportDeclErrorIfAny(FromSpec));; // Btw, the error is also set for the FieldDecl.; assert(Importer.getImportDeclErrorIfAny(From));; return 1;; }. Polluted AST; """""""""""""""""""""""". We may recognize an error during the import of a dependent node. However, by that time, we had already created the dependant.; In these cases we do not remove the existing erroneous node from the ""to"" context, rather we associate an error to that node.; Let's extend the previous example with another class ``Y``.; This class has a forward definition in the ""to"" context, but its definition is in the ""from"" context.; We'd like to import the definition, but it contains a member whose type conflicts with the type in the ""to"" context:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct X {};; // explicit specialization; template<>; struct X<int> { int i; };. class Y;; )"",; ""to.cc"");; ToUnit->enableSourceFileDiagnostics();; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:16405,Availability,error,error,16405,"pendant node.; Let's modify the previous example and import a ``FieldDecl`` instead of the ``ClassTemplateSpecializationDecl``. .. code-block:: cpp. auto Matcher = fieldDecl(hasName(""i2""));; auto *From = getFirstDecl<FieldDecl>(Matcher, FromUnit);. In this case we can see that an error is associated (``getImportDeclErrorIfAny``) to the specialization also, not just to the field:. .. code-block:: cpp. llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // check that the ClassTemplateSpecializationDecl is also marked as; // erroneous.; auto *FromSpec = getFirstDecl<ClassTemplateSpecializationDecl>(; classTemplateSpecializationDecl(hasName(""X"")), FromUnit);; assert(Importer.getImportDeclErrorIfAny(FromSpec));; // Btw, the error is also set for the FieldDecl.; assert(Importer.getImportDeclErrorIfAny(From));; return 1;; }. Polluted AST; """""""""""""""""""""""". We may recognize an error during the import of a dependent node. However, by that time, we had already created the dependant.; In these cases we do not remove the existing erroneous node from the ""to"" context, rather we associate an error to that node.; Let's extend the previous example with another class ``Y``.; This class has a forward definition in the ""to"" context, but its definition is in the ""from"" context.; We'd like to import the definition, but it contains a member whose type conflicts with the type in the ""to"" context:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct X {};; // explicit specialization; template<>; struct X<int> { int i; };. class Y;; )"",; ""to.cc"");; ToUnit->enableSourceFileDiagnostics();; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct X {};; // explicit specialization; template<>; struct X<int> { int i2; };; // field mismatch: ^^. class Y { void f(",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:16618,Availability,error,error,16618,"cher = fieldDecl(hasName(""i2""));; auto *From = getFirstDecl<FieldDecl>(Matcher, FromUnit);. In this case we can see that an error is associated (``getImportDeclErrorIfAny``) to the specialization also, not just to the field:. .. code-block:: cpp. llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // check that the ClassTemplateSpecializationDecl is also marked as; // erroneous.; auto *FromSpec = getFirstDecl<ClassTemplateSpecializationDecl>(; classTemplateSpecializationDecl(hasName(""X"")), FromUnit);; assert(Importer.getImportDeclErrorIfAny(FromSpec));; // Btw, the error is also set for the FieldDecl.; assert(Importer.getImportDeclErrorIfAny(From));; return 1;; }. Polluted AST; """""""""""""""""""""""". We may recognize an error during the import of a dependent node. However, by that time, we had already created the dependant.; In these cases we do not remove the existing erroneous node from the ""to"" context, rather we associate an error to that node.; Let's extend the previous example with another class ``Y``.; This class has a forward definition in the ""to"" context, but its definition is in the ""from"" context.; We'd like to import the definition, but it contains a member whose type conflicts with the type in the ""to"" context:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct X {};; // explicit specialization; template<>; struct X<int> { int i; };. class Y;; )"",; ""to.cc"");; ToUnit->enableSourceFileDiagnostics();; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct X {};; // explicit specialization; template<>; struct X<int> { int i2; };; // field mismatch: ^^. class Y { void f() { X<int> xi; } };; )"",; ""from.cc"");; FromUnit->enableSourceFileDiagnostics();; auto Matcher = cxxRecordDecl(hasName(""Y""));; auto *From = getFirstDecl<CXXRe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:17753,Availability,error,errors,17753,"ard definition in the ""to"" context, but its definition is in the ""from"" context.; We'd like to import the definition, but it contains a member whose type conflicts with the type in the ""to"" context:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct X {};; // explicit specialization; template<>; struct X<int> { int i; };. class Y;; )"",; ""to.cc"");; ToUnit->enableSourceFileDiagnostics();; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct X {};; // explicit specialization; template<>; struct X<int> { int i2; };; // field mismatch: ^^. class Y { void f() { X<int> xi; } };; )"",; ""from.cc"");; FromUnit->enableSourceFileDiagnostics();; auto Matcher = cxxRecordDecl(hasName(""Y""));; auto *From = getFirstDecl<CXXRecordDecl>(Matcher, FromUnit);; auto *To = getFirstDecl<CXXRecordDecl>(Matcher, ToUnit);. This time we create a shared_ptr for ``ASTImporterSharedState`` which owns the associated errors for the ""to"" context.; Note, there may be several different ASTImporter objects which import into the same ""to"" context but from different ""from"" contexts; they should share the same ``ASTImporterSharedState``.; (Also note, we have to include the corresponding ``ASTImporterSharedState.h`` header file.). .. code-block:: cpp. auto ImporterState = std::make_shared<ASTImporterSharedState>();; ASTImporter Importer(ToUnit->getASTContext(), ToUnit->getFileManager(),; FromUnit->getASTContext(), FromUnit->getFileManager(),; /*MinimalImport=*/false, ImporterState);; llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // ... but the node had been created.; auto *ToYDef = getFirstDecl<CXXRecordDecl>(; cxxRecordDecl(hasName(""Y""), isDefinition()), ToUnit);; ToYDef->dump();; // An error is set for ""ToYDef"" in the shared state.; Optional<ASTImportError> O",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:18648,Availability,error,error,18648,"o *To = getFirstDecl<CXXRecordDecl>(Matcher, ToUnit);. This time we create a shared_ptr for ``ASTImporterSharedState`` which owns the associated errors for the ""to"" context.; Note, there may be several different ASTImporter objects which import into the same ""to"" context but from different ""from"" contexts; they should share the same ``ASTImporterSharedState``.; (Also note, we have to include the corresponding ``ASTImporterSharedState.h`` header file.). .. code-block:: cpp. auto ImporterState = std::make_shared<ASTImporterSharedState>();; ASTImporter Importer(ToUnit->getASTContext(), ToUnit->getFileManager(),; FromUnit->getASTContext(), FromUnit->getFileManager(),; /*MinimalImport=*/false, ImporterState);; llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // ... but the node had been created.; auto *ToYDef = getFirstDecl<CXXRecordDecl>(; cxxRecordDecl(hasName(""Y""), isDefinition()), ToUnit);; ToYDef->dump();; // An error is set for ""ToYDef"" in the shared state.; Optional<ASTImportError> OptErr =; ImporterState->getImportDeclErrorIfAny(ToYDef);; assert(OptErr);. return 1;; }. If we take a look at the AST, then we can see that the Decl with the definition is created, but the field is missing. .. code-block:: bash. |-CXXRecordDecl 0xf66678 <line:9:7, col:13> col:13 class Y; `-CXXRecordDecl 0xf66730 prev 0xf66678 <:10:7, col:13> col:13 class Y definition; |-DefinitionData pass_in_registers empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init; | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:19836,Availability,error,error,19836,"e can see that the Decl with the definition is created, but the field is missing. .. code-block:: bash. |-CXXRecordDecl 0xf66678 <line:9:7, col:13> col:13 class Y; `-CXXRecordDecl 0xf66730 prev 0xf66678 <:10:7, col:13> col:13 class Y definition; |-DefinitionData pass_in_registers empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init; | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; `-CXXRecordDecl 0xf66828 <col:7, col:13> col:13 implicit class Y. We do not remove the erroneous nodes because by the time when we recognize the error it is too late to remove the node, there may be additional references to that already in the AST.; This is aligned with the overall `design principle of the Clang AST <InternalsManual.html#immutability>`_: Clang AST nodes (types, declarations, statements, expressions, and so on) are generally designed to be **immutable once created**.; Thus, clients of the ASTImporter library should always check if there is any associated error for the node which they inspect in the destination context.; We recommend skipping the processing of those nodes which have an error associated with them. Using the ``-ast-merge`` Clang front-end action; -----------------------------------------------. The ``-ast-merge <pch-file>`` command-line switch can be used to merge from the given serialized AST file.; This file represents the source context.; When this switch is present then each top-level AST node of the source context is being merged into the destination context.; If the merge was successful then ``ASTConsume",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:20268,Availability,error,error,20268," | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; `-CXXRecordDecl 0xf66828 <col:7, col:13> col:13 implicit class Y. We do not remove the erroneous nodes because by the time when we recognize the error it is too late to remove the node, there may be additional references to that already in the AST.; This is aligned with the overall `design principle of the Clang AST <InternalsManual.html#immutability>`_: Clang AST nodes (types, declarations, statements, expressions, and so on) are generally designed to be **immutable once created**.; Thus, clients of the ASTImporter library should always check if there is any associated error for the node which they inspect in the destination context.; We recommend skipping the processing of those nodes which have an error associated with them. Using the ``-ast-merge`` Clang front-end action; -----------------------------------------------. The ``-ast-merge <pch-file>`` command-line switch can be used to merge from the given serialized AST file.; This file represents the source context.; When this switch is present then each top-level AST node of the source context is being merged into the destination context.; If the merge was successful then ``ASTConsumer::HandleTopLevelDecl`` is called for the Decl.; This results that we can execute the original front-end action on the extended AST. Example for C; ^^^^^^^^^^^^^. Let's consider the following three files:. .. code-block:: c. // bar.h; #ifndef BAR_H; #define BAR_H; int bar();; #endif /* BAR_H */. // bar.c; #include ""bar.h""; int bar() {; return 41;; }. // main.c; #include ""bar.h""; int main() {; return bar()",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:20401,Availability,error,error,20401,"s_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; `-CXXRecordDecl 0xf66828 <col:7, col:13> col:13 implicit class Y. We do not remove the erroneous nodes because by the time when we recognize the error it is too late to remove the node, there may be additional references to that already in the AST.; This is aligned with the overall `design principle of the Clang AST <InternalsManual.html#immutability>`_: Clang AST nodes (types, declarations, statements, expressions, and so on) are generally designed to be **immutable once created**.; Thus, clients of the ASTImporter library should always check if there is any associated error for the node which they inspect in the destination context.; We recommend skipping the processing of those nodes which have an error associated with them. Using the ``-ast-merge`` Clang front-end action; -----------------------------------------------. The ``-ast-merge <pch-file>`` command-line switch can be used to merge from the given serialized AST file.; This file represents the source context.; When this switch is present then each top-level AST node of the source context is being merged into the destination context.; If the merge was successful then ``ASTConsumer::HandleTopLevelDecl`` is called for the Decl.; This results that we can execute the original front-end action on the extended AST. Example for C; ^^^^^^^^^^^^^. Let's consider the following three files:. .. code-block:: c. // bar.h; #ifndef BAR_H; #define BAR_H; int bar();; #endif /* BAR_H */. // bar.c; #include ""bar.h""; int bar() {; return 41;; }. // main.c; #include ""bar.h""; int main() {; return bar();; }. Let's generate the AST files for the two source files:. .. code-block:: bash. $ clang -cc1 -emit-pch -o bar.ast bar.c; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:22792,Availability,echo,echo,22792,"id sloc>; |-FunctionDecl 0x12b1470 </path/bar.h:4:1, col:9> col:5 used bar 'int ()'; |-FunctionDecl 0x12b1538 prev 0x12b1470 </path/bar.c:3:1, line:5:1> line:3:5 used bar 'int ()'; | `-CompoundStmt 0x12b1608 <col:11, line:5:1>; | `-ReturnStmt 0x12b15f8 <line:4:3, col:10>; | `-IntegerLiteral 0x12b15d8 <col:10> 'int' 41; |-FunctionDecl 0x12b1648 prev 0x12b1538 </path/bar.h:4:1, col:9> col:5 used bar 'int ()'. We can inspect that the prototype of the function and the definition of it is merged into the same redeclaration chain.; What's more there is a third prototype declaration merged to the chain.; The functions are merged in a way that prototypes are added to the redecl chain if they refer to the same type, but we can have only one definition.; The first two declarations are from ``bar.ast``, the third is from ``main.ast``. Now, let's create an object file from the merged AST:. .. code-block:: bash. $ clang -cc1 -ast-merge bar.ast -ast-merge main.ast /dev/null -emit-obj -o main.o. Next, we may call the linker and execute the created binary file. .. code-block:: bash. $ clang -o a.out main.o; $ ./a.out; $ echo $?; 41; $. Example for C++; ^^^^^^^^^^^^^^^. In the case of C++, the generation of the AST files and the way how we invoke the front-end is a bit different.; Assuming we have these three files:. .. code-block:: cpp. // foo.h; #ifndef FOO_H; #define FOO_H; struct foo {; virtual int fun();; };; #endif /* FOO_H */. // foo.cpp; #include ""foo.h""; int foo::fun() {; return 42;; }. // main.cpp; #include ""foo.h""; int main() {; return foo().fun();; }. We shall generate the AST files, merge them, create the executable and then run it:. .. code-block:: bash. $ clang++ -x c++-header -o foo.ast foo.cpp; $ clang++ -x c++-header -o main.ast main.cpp; $ clang++ -cc1 -x c++ -ast-merge foo.ast -ast-merge main.ast /dev/null -ast-dump; $ clang++ -cc1 -x c++ -ast-merge foo.ast -ast-merge main.ast /dev/null -emit-obj -o main.o; $ clang++ -o a.out main.o; $ ./a.out; $ echo $?; 42; $; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:23654,Availability,echo,echo,23654,"id sloc>; |-FunctionDecl 0x12b1470 </path/bar.h:4:1, col:9> col:5 used bar 'int ()'; |-FunctionDecl 0x12b1538 prev 0x12b1470 </path/bar.c:3:1, line:5:1> line:3:5 used bar 'int ()'; | `-CompoundStmt 0x12b1608 <col:11, line:5:1>; | `-ReturnStmt 0x12b15f8 <line:4:3, col:10>; | `-IntegerLiteral 0x12b15d8 <col:10> 'int' 41; |-FunctionDecl 0x12b1648 prev 0x12b1538 </path/bar.h:4:1, col:9> col:5 used bar 'int ()'. We can inspect that the prototype of the function and the definition of it is merged into the same redeclaration chain.; What's more there is a third prototype declaration merged to the chain.; The functions are merged in a way that prototypes are added to the redecl chain if they refer to the same type, but we can have only one definition.; The first two declarations are from ``bar.ast``, the third is from ``main.ast``. Now, let's create an object file from the merged AST:. .. code-block:: bash. $ clang -cc1 -ast-merge bar.ast -ast-merge main.ast /dev/null -emit-obj -o main.o. Next, we may call the linker and execute the created binary file. .. code-block:: bash. $ clang -o a.out main.o; $ ./a.out; $ echo $?; 41; $. Example for C++; ^^^^^^^^^^^^^^^. In the case of C++, the generation of the AST files and the way how we invoke the front-end is a bit different.; Assuming we have these three files:. .. code-block:: cpp. // foo.h; #ifndef FOO_H; #define FOO_H; struct foo {; virtual int fun();; };; #endif /* FOO_H */. // foo.cpp; #include ""foo.h""; int foo::fun() {; return 42;; }. // main.cpp; #include ""foo.h""; int main() {; return foo().fun();; }. We shall generate the AST files, merge them, create the executable and then run it:. .. code-block:: bash. $ clang++ -x c++-header -o foo.ast foo.cpp; $ clang++ -x c++-header -o main.ast main.cpp; $ clang++ -cc1 -x c++ -ast-merge foo.ast -ast-merge main.ast /dev/null -ast-dump; $ clang++ -cc1 -x c++ -ast-merge foo.ast -ast-merge main.ast /dev/null -emit-obj -o main.o; $ clang++ -o a.out main.o; $ ./a.out; $ echo $?; 42; $; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:3505,Integrability,depend,dependent,3505,"at the structurally equivalent nodes in the different translation units are not getting duplicated in the merged AST.; E.g. if we include the definition of the vector template (``#include <vector>``) in two translation units, then their merged AST should have only one node which represents the template.; Also, we have to discover *one definition rule* (ODR) violations.; For instance, if there is a class definition with the same name in both translation units, but one of the definition contains a different number of fields.; So, we look up existing definitions, and then we check the structural equivalency on those nodes.; The following pseudo-code demonstrates the basics of the import mechanism:. .. code-block:: cpp. // Pseudo-code(!) of import:; ErrorOrDecl Import(Decl *FromD) {; Decl *ToDecl = nullptr;; FoundDeclsList = Look up all Decls in the ""to"" Ctx with the same name of FromD;; for (auto FoundDecl : FoundDeclsList) {; if (StructurallyEquivalentDecls(FoundDecl, FromD)) {; ToDecl = FoundDecl;; Mark FromD as imported;; break;; } else {; Report ODR violation;; return error;; }; }; if (FoundDeclsList is empty) {; Import dependent declarations and types of ToDecl;; ToDecl = create a new AST node in ""to"" Ctx;; Mark FromD as imported;; }; return ToDecl;; }. Two AST nodes are *structurally equivalent* if they are. - builtin types and refer to the same type, e.g. ``int`` and ``int`` are structurally equivalent,; - function types and all their parameters have structurally equivalent types,; - record types and all their fields in order of their definition have the same identifier names and structurally equivalent types,; - variable or function declarations and they have the same identifier name and their types are structurally equivalent. We could extend the definition of structural equivalency to templates similarly. If A and B are AST nodes and *A depends on B*, then we say that A is a **dependant** of B and B is a **dependency** of A.; The words ""dependant"" and ""depend",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:4242,Integrability,depend,depends,4242,"to FoundDecl : FoundDeclsList) {; if (StructurallyEquivalentDecls(FoundDecl, FromD)) {; ToDecl = FoundDecl;; Mark FromD as imported;; break;; } else {; Report ODR violation;; return error;; }; }; if (FoundDeclsList is empty) {; Import dependent declarations and types of ToDecl;; ToDecl = create a new AST node in ""to"" Ctx;; Mark FromD as imported;; }; return ToDecl;; }. Two AST nodes are *structurally equivalent* if they are. - builtin types and refer to the same type, e.g. ``int`` and ``int`` are structurally equivalent,; - function types and all their parameters have structurally equivalent types,; - record types and all their fields in order of their definition have the same identifier names and structurally equivalent types,; - variable or function declarations and they have the same identifier name and their types are structurally equivalent. We could extend the definition of structural equivalency to templates similarly. If A and B are AST nodes and *A depends on B*, then we say that A is a **dependant** of B and B is a **dependency** of A.; The words ""dependant"" and ""dependency"" are nouns in British English.; Unfortunately, in American English, the adjective ""dependent"" is used for both meanings.; In this document, with the ""dependent"" adjective we always address the dependencies, the B node in the example. API; ---. Let's create a tool which uses the ASTImporter class!; First, we build two ASTs from virtual files; the content of the virtual files are synthesized from string literals:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc""); // empty file; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");. The first AST corresponds to the destination (""to"") context - which is empty - and the second for the source (""from"") context.; Next, we define a matcher to match ``MyClass`` in the ""from"" context:. .. code-block:: cpp. auto Matcher = cxxRecordDecl(hasName(""MyCla",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:4283,Integrability,depend,dependant,4283,"to FoundDecl : FoundDeclsList) {; if (StructurallyEquivalentDecls(FoundDecl, FromD)) {; ToDecl = FoundDecl;; Mark FromD as imported;; break;; } else {; Report ODR violation;; return error;; }; }; if (FoundDeclsList is empty) {; Import dependent declarations and types of ToDecl;; ToDecl = create a new AST node in ""to"" Ctx;; Mark FromD as imported;; }; return ToDecl;; }. Two AST nodes are *structurally equivalent* if they are. - builtin types and refer to the same type, e.g. ``int`` and ``int`` are structurally equivalent,; - function types and all their parameters have structurally equivalent types,; - record types and all their fields in order of their definition have the same identifier names and structurally equivalent types,; - variable or function declarations and they have the same identifier name and their types are structurally equivalent. We could extend the definition of structural equivalency to templates similarly. If A and B are AST nodes and *A depends on B*, then we say that A is a **dependant** of B and B is a **dependency** of A.; The words ""dependant"" and ""dependency"" are nouns in British English.; Unfortunately, in American English, the adjective ""dependent"" is used for both meanings.; In this document, with the ""dependent"" adjective we always address the dependencies, the B node in the example. API; ---. Let's create a tool which uses the ASTImporter class!; First, we build two ASTs from virtual files; the content of the virtual files are synthesized from string literals:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc""); // empty file; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");. The first AST corresponds to the destination (""to"") context - which is empty - and the second for the source (""from"") context.; Next, we define a matcher to match ``MyClass`` in the ""from"" context:. .. code-block:: cpp. auto Matcher = cxxRecordDecl(hasName(""MyCla",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:4313,Integrability,depend,dependency,4313,"to FoundDecl : FoundDeclsList) {; if (StructurallyEquivalentDecls(FoundDecl, FromD)) {; ToDecl = FoundDecl;; Mark FromD as imported;; break;; } else {; Report ODR violation;; return error;; }; }; if (FoundDeclsList is empty) {; Import dependent declarations and types of ToDecl;; ToDecl = create a new AST node in ""to"" Ctx;; Mark FromD as imported;; }; return ToDecl;; }. Two AST nodes are *structurally equivalent* if they are. - builtin types and refer to the same type, e.g. ``int`` and ``int`` are structurally equivalent,; - function types and all their parameters have structurally equivalent types,; - record types and all their fields in order of their definition have the same identifier names and structurally equivalent types,; - variable or function declarations and they have the same identifier name and their types are structurally equivalent. We could extend the definition of structural equivalency to templates similarly. If A and B are AST nodes and *A depends on B*, then we say that A is a **dependant** of B and B is a **dependency** of A.; The words ""dependant"" and ""dependency"" are nouns in British English.; Unfortunately, in American English, the adjective ""dependent"" is used for both meanings.; In this document, with the ""dependent"" adjective we always address the dependencies, the B node in the example. API; ---. Let's create a tool which uses the ASTImporter class!; First, we build two ASTs from virtual files; the content of the virtual files are synthesized from string literals:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc""); // empty file; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");. The first AST corresponds to the destination (""to"") context - which is empty - and the second for the source (""from"") context.; Next, we define a matcher to match ``MyClass`` in the ""from"" context:. .. code-block:: cpp. auto Matcher = cxxRecordDecl(hasName(""MyCla",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:4344,Integrability,depend,dependant,4344," FoundDecl;; Mark FromD as imported;; break;; } else {; Report ODR violation;; return error;; }; }; if (FoundDeclsList is empty) {; Import dependent declarations and types of ToDecl;; ToDecl = create a new AST node in ""to"" Ctx;; Mark FromD as imported;; }; return ToDecl;; }. Two AST nodes are *structurally equivalent* if they are. - builtin types and refer to the same type, e.g. ``int`` and ``int`` are structurally equivalent,; - function types and all their parameters have structurally equivalent types,; - record types and all their fields in order of their definition have the same identifier names and structurally equivalent types,; - variable or function declarations and they have the same identifier name and their types are structurally equivalent. We could extend the definition of structural equivalency to templates similarly. If A and B are AST nodes and *A depends on B*, then we say that A is a **dependant** of B and B is a **dependency** of A.; The words ""dependant"" and ""dependency"" are nouns in British English.; Unfortunately, in American English, the adjective ""dependent"" is used for both meanings.; In this document, with the ""dependent"" adjective we always address the dependencies, the B node in the example. API; ---. Let's create a tool which uses the ASTImporter class!; First, we build two ASTs from virtual files; the content of the virtual files are synthesized from string literals:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc""); // empty file; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");. The first AST corresponds to the destination (""to"") context - which is empty - and the second for the source (""from"") context.; Next, we define a matcher to match ``MyClass`` in the ""from"" context:. .. code-block:: cpp. auto Matcher = cxxRecordDecl(hasName(""MyClass""));; auto *From = getFirstDecl<CXXRecordDecl>(Matcher, FromUnit);. Now we create the Importer",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:4360,Integrability,depend,dependency,4360," FoundDecl;; Mark FromD as imported;; break;; } else {; Report ODR violation;; return error;; }; }; if (FoundDeclsList is empty) {; Import dependent declarations and types of ToDecl;; ToDecl = create a new AST node in ""to"" Ctx;; Mark FromD as imported;; }; return ToDecl;; }. Two AST nodes are *structurally equivalent* if they are. - builtin types and refer to the same type, e.g. ``int`` and ``int`` are structurally equivalent,; - function types and all their parameters have structurally equivalent types,; - record types and all their fields in order of their definition have the same identifier names and structurally equivalent types,; - variable or function declarations and they have the same identifier name and their types are structurally equivalent. We could extend the definition of structural equivalency to templates similarly. If A and B are AST nodes and *A depends on B*, then we say that A is a **dependant** of B and B is a **dependency** of A.; The words ""dependant"" and ""dependency"" are nouns in British English.; Unfortunately, in American English, the adjective ""dependent"" is used for both meanings.; In this document, with the ""dependent"" adjective we always address the dependencies, the B node in the example. API; ---. Let's create a tool which uses the ASTImporter class!; First, we build two ASTs from virtual files; the content of the virtual files are synthesized from string literals:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc""); // empty file; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");. The first AST corresponds to the destination (""to"") context - which is empty - and the second for the source (""from"") context.; Next, we define a matcher to match ``MyClass`` in the ""from"" context:. .. code-block:: cpp. auto Matcher = cxxRecordDecl(hasName(""MyClass""));; auto *From = getFirstDecl<CXXRecordDecl>(Matcher, FromUnit);. Now we create the Importer",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:4454,Integrability,depend,dependent,4454,"eturn error;; }; }; if (FoundDeclsList is empty) {; Import dependent declarations and types of ToDecl;; ToDecl = create a new AST node in ""to"" Ctx;; Mark FromD as imported;; }; return ToDecl;; }. Two AST nodes are *structurally equivalent* if they are. - builtin types and refer to the same type, e.g. ``int`` and ``int`` are structurally equivalent,; - function types and all their parameters have structurally equivalent types,; - record types and all their fields in order of their definition have the same identifier names and structurally equivalent types,; - variable or function declarations and they have the same identifier name and their types are structurally equivalent. We could extend the definition of structural equivalency to templates similarly. If A and B are AST nodes and *A depends on B*, then we say that A is a **dependant** of B and B is a **dependency** of A.; The words ""dependant"" and ""dependency"" are nouns in British English.; Unfortunately, in American English, the adjective ""dependent"" is used for both meanings.; In this document, with the ""dependent"" adjective we always address the dependencies, the B node in the example. API; ---. Let's create a tool which uses the ASTImporter class!; First, we build two ASTs from virtual files; the content of the virtual files are synthesized from string literals:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc""); // empty file; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");. The first AST corresponds to the destination (""to"") context - which is empty - and the second for the source (""from"") context.; Next, we define a matcher to match ``MyClass`` in the ""from"" context:. .. code-block:: cpp. auto Matcher = cxxRecordDecl(hasName(""MyClass""));; auto *From = getFirstDecl<CXXRecordDecl>(Matcher, FromUnit);. Now we create the Importer and do the import:. .. code-block:: cpp. ASTImporter Importer(ToUnit->getASTCon",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:4521,Integrability,depend,dependent,4521,";; ToDecl = create a new AST node in ""to"" Ctx;; Mark FromD as imported;; }; return ToDecl;; }. Two AST nodes are *structurally equivalent* if they are. - builtin types and refer to the same type, e.g. ``int`` and ``int`` are structurally equivalent,; - function types and all their parameters have structurally equivalent types,; - record types and all their fields in order of their definition have the same identifier names and structurally equivalent types,; - variable or function declarations and they have the same identifier name and their types are structurally equivalent. We could extend the definition of structural equivalency to templates similarly. If A and B are AST nodes and *A depends on B*, then we say that A is a **dependant** of B and B is a **dependency** of A.; The words ""dependant"" and ""dependency"" are nouns in British English.; Unfortunately, in American English, the adjective ""dependent"" is used for both meanings.; In this document, with the ""dependent"" adjective we always address the dependencies, the B node in the example. API; ---. Let's create a tool which uses the ASTImporter class!; First, we build two ASTs from virtual files; the content of the virtual files are synthesized from string literals:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc""); // empty file; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");. The first AST corresponds to the destination (""to"") context - which is empty - and the second for the source (""from"") context.; Next, we define a matcher to match ``MyClass`` in the ""from"" context:. .. code-block:: cpp. auto Matcher = cxxRecordDecl(hasName(""MyClass""));; auto *From = getFirstDecl<CXXRecordDecl>(Matcher, FromUnit);. Now we create the Importer and do the import:. .. code-block:: cpp. ASTImporter Importer(ToUnit->getASTContext(), ToUnit->getFileManager(),; FromUnit->getASTContext(), FromUnit->getFileManager(),; /*MinimalIm",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:4564,Integrability,depend,dependencies,4564,";; ToDecl = create a new AST node in ""to"" Ctx;; Mark FromD as imported;; }; return ToDecl;; }. Two AST nodes are *structurally equivalent* if they are. - builtin types and refer to the same type, e.g. ``int`` and ``int`` are structurally equivalent,; - function types and all their parameters have structurally equivalent types,; - record types and all their fields in order of their definition have the same identifier names and structurally equivalent types,; - variable or function declarations and they have the same identifier name and their types are structurally equivalent. We could extend the definition of structural equivalency to templates similarly. If A and B are AST nodes and *A depends on B*, then we say that A is a **dependant** of B and B is a **dependency** of A.; The words ""dependant"" and ""dependency"" are nouns in British English.; Unfortunately, in American English, the adjective ""dependent"" is used for both meanings.; In this document, with the ""dependent"" adjective we always address the dependencies, the B node in the example. API; ---. Let's create a tool which uses the ASTImporter class!; First, we build two ASTs from virtual files; the content of the virtual files are synthesized from string literals:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc""); // empty file; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");. The first AST corresponds to the destination (""to"") context - which is empty - and the second for the source (""from"") context.; Next, we define a matcher to match ``MyClass`` in the ""from"" context:. .. code-block:: cpp. auto Matcher = cxxRecordDecl(hasName(""MyClass""));; auto *From = getFirstDecl<CXXRecordDecl>(Matcher, FromUnit);. Now we create the Importer and do the import:. .. code-block:: cpp. ASTImporter Importer(ToUnit->getASTContext(), ToUnit->getFileManager(),; FromUnit->getASTContext(), FromUnit->getFileManager(),; /*MinimalIm",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:8554,Integrability,depend,dependent,8554,"d sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; |-DefinitionData pass_in_registers standard_layout trivially_copyable trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-CXXRecordDecl 0x6c7f48 <col:7, col:13> col:13 implicit class MyClass; |-FieldDecl 0x6c7ff0 <line:3:9, col:13> col:13 m1 'int'; `-FieldDecl 0x6c8058 <line:4:9, col:13> col:13 m2 'int'. We can spare the call for ``ImportDefinition`` if we set up the importer to do a ""normal"" (not minimal) import. .. code-block:: cpp. ASTImporter Importer( .... /*MinimalImport=*/false);. With **normal import**, all dependent declarations are imported normally.; However, with minimal import, the dependent Decls are imported without definition, and we have to import their definition for each if we later need that. Putting this all together here is how the source of the tool looks like:. .. code-block:: cpp. #include ""clang/AST/ASTImporter.h""; #include ""clang/ASTMatchers/ASTMatchFinder.h""; #include ""clang/ASTMatchers/ASTMatchers.h""; #include ""clang/Tooling/Tooling.h"". using namespace clang;; using namespace tooling;; using namespace ast_matchers;. template <typename Node, typename Matcher>; Node *getFirstDecl(Matcher M, const std::unique_ptr<ASTUnit> &Unit) {; auto MB = M.bind(""bindStr""); // Bind the to-be-matched node to a string key.; auto MatchRes = match(MB, Unit->getASTContext());; // We should have at least one match.; assert(MatchRes.size() >= 1);; // Get the first matched and bound node.; Node *Result =; const_cast<Node *>(MatchRes[0].template getNodeAs<Node>(""bindStr""));; assert(Result);; return Re",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:8635,Integrability,depend,dependent,8635,"Data pass_in_registers standard_layout trivially_copyable trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-CXXRecordDecl 0x6c7f48 <col:7, col:13> col:13 implicit class MyClass; |-FieldDecl 0x6c7ff0 <line:3:9, col:13> col:13 m1 'int'; `-FieldDecl 0x6c8058 <line:4:9, col:13> col:13 m2 'int'. We can spare the call for ``ImportDefinition`` if we set up the importer to do a ""normal"" (not minimal) import. .. code-block:: cpp. ASTImporter Importer( .... /*MinimalImport=*/false);. With **normal import**, all dependent declarations are imported normally.; However, with minimal import, the dependent Decls are imported without definition, and we have to import their definition for each if we later need that. Putting this all together here is how the source of the tool looks like:. .. code-block:: cpp. #include ""clang/AST/ASTImporter.h""; #include ""clang/ASTMatchers/ASTMatchFinder.h""; #include ""clang/ASTMatchers/ASTMatchers.h""; #include ""clang/Tooling/Tooling.h"". using namespace clang;; using namespace tooling;; using namespace ast_matchers;. template <typename Node, typename Matcher>; Node *getFirstDecl(Matcher M, const std::unique_ptr<ASTUnit> &Unit) {; auto MB = M.bind(""bindStr""); // Bind the to-be-matched node to a string key.; auto MatchRes = match(MB, Unit->getASTContext());; // We should have at least one match.; assert(MatchRes.size() >= 1);; // Get the first matched and bound node.; Node *Result =; const_cast<Node *>(MatchRes[0].template getNodeAs<Node>(""bindStr""));; assert(Result);; return Result;; }. int main() {; std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc"");; std::unique_ptr<ASTUnit",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:15276,Integrability,depend,dependent,15276,"eds_implicit; | | `-CXXRecordDecl 0xe91270 <col:7, col:14> col:14 implicit struct X; | `-ClassTemplateSpecialization 0xe91340 'X'; `-ClassTemplateSpecializationDecl 0xe91340 <line:6:7, line:7:30> col:14 struct X definition; |-DefinitionData pass_in_registers aggregate standard_layout trivially_copyable pod trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-TemplateArgument type 'int'; |-CXXRecordDecl 0xe91558 <col:7, col:14> col:14 implicit struct X; `-FieldDecl 0xe91600 <col:23, col:27> col:27 i 'int'. Error propagation; """""""""""""""""""""""""""""""""". If there is a dependent node we have to import before we could import a given node then the import error associated to the dependency propagates to the dependant node.; Let's modify the previous example and import a ``FieldDecl`` instead of the ``ClassTemplateSpecializationDecl``. .. code-block:: cpp. auto Matcher = fieldDecl(hasName(""i2""));; auto *From = getFirstDecl<FieldDecl>(Matcher, FromUnit);. In this case we can see that an error is associated (``getImportDeclErrorIfAny``) to the specialization also, not just to the field:. .. code-block:: cpp. llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // check that the ClassTemplateSpecializationDecl is also marked as; // erroneous.; auto *FromSpec = getFirstDecl<ClassTemplateSpecializationDecl>(; classTemplateSpecializationDecl(hasName(""X"")), FromUnit);; assert(Importer.getImportDeclErrorIfAny(FromSpec));; // Btw, the error is also set for the FieldDecl.; assert(Importer.getImportDeclErrorIfAny(From));; re",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:15385,Integrability,depend,dependency,15385,"eds_implicit; | | `-CXXRecordDecl 0xe91270 <col:7, col:14> col:14 implicit struct X; | `-ClassTemplateSpecialization 0xe91340 'X'; `-ClassTemplateSpecializationDecl 0xe91340 <line:6:7, line:7:30> col:14 struct X definition; |-DefinitionData pass_in_registers aggregate standard_layout trivially_copyable pod trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-TemplateArgument type 'int'; |-CXXRecordDecl 0xe91558 <col:7, col:14> col:14 implicit struct X; `-FieldDecl 0xe91600 <col:23, col:27> col:27 i 'int'. Error propagation; """""""""""""""""""""""""""""""""". If there is a dependent node we have to import before we could import a given node then the import error associated to the dependency propagates to the dependant node.; Let's modify the previous example and import a ``FieldDecl`` instead of the ``ClassTemplateSpecializationDecl``. .. code-block:: cpp. auto Matcher = fieldDecl(hasName(""i2""));; auto *From = getFirstDecl<FieldDecl>(Matcher, FromUnit);. In this case we can see that an error is associated (``getImportDeclErrorIfAny``) to the specialization also, not just to the field:. .. code-block:: cpp. llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // check that the ClassTemplateSpecializationDecl is also marked as; // erroneous.; auto *FromSpec = getFirstDecl<ClassTemplateSpecializationDecl>(; classTemplateSpecializationDecl(hasName(""X"")), FromUnit);; assert(Importer.getImportDeclErrorIfAny(FromSpec));; // Btw, the error is also set for the FieldDecl.; assert(Importer.getImportDeclErrorIfAny(From));; re",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:15414,Integrability,depend,dependant,15414,"eds_implicit; | | `-CXXRecordDecl 0xe91270 <col:7, col:14> col:14 implicit struct X; | `-ClassTemplateSpecialization 0xe91340 'X'; `-ClassTemplateSpecializationDecl 0xe91340 <line:6:7, line:7:30> col:14 struct X definition; |-DefinitionData pass_in_registers aggregate standard_layout trivially_copyable pod trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-TemplateArgument type 'int'; |-CXXRecordDecl 0xe91558 <col:7, col:14> col:14 implicit struct X; `-FieldDecl 0xe91600 <col:23, col:27> col:27 i 'int'. Error propagation; """""""""""""""""""""""""""""""""". If there is a dependent node we have to import before we could import a given node then the import error associated to the dependency propagates to the dependant node.; Let's modify the previous example and import a ``FieldDecl`` instead of the ``ClassTemplateSpecializationDecl``. .. code-block:: cpp. auto Matcher = fieldDecl(hasName(""i2""));; auto *From = getFirstDecl<FieldDecl>(Matcher, FromUnit);. In this case we can see that an error is associated (``getImportDeclErrorIfAny``) to the specialization also, not just to the field:. .. code-block:: cpp. llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // check that the ClassTemplateSpecializationDecl is also marked as; // erroneous.; auto *FromSpec = getFirstDecl<ClassTemplateSpecializationDecl>(; classTemplateSpecializationDecl(hasName(""X"")), FromUnit);; assert(Importer.getImportDeclErrorIfAny(FromSpec));; // Btw, the error is also set for the FieldDecl.; assert(Importer.getImportDeclErrorIfAny(From));; re",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:16434,Integrability,depend,dependent,16434,"pendant node.; Let's modify the previous example and import a ``FieldDecl`` instead of the ``ClassTemplateSpecializationDecl``. .. code-block:: cpp. auto Matcher = fieldDecl(hasName(""i2""));; auto *From = getFirstDecl<FieldDecl>(Matcher, FromUnit);. In this case we can see that an error is associated (``getImportDeclErrorIfAny``) to the specialization also, not just to the field:. .. code-block:: cpp. llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // check that the ClassTemplateSpecializationDecl is also marked as; // erroneous.; auto *FromSpec = getFirstDecl<ClassTemplateSpecializationDecl>(; classTemplateSpecializationDecl(hasName(""X"")), FromUnit);; assert(Importer.getImportDeclErrorIfAny(FromSpec));; // Btw, the error is also set for the FieldDecl.; assert(Importer.getImportDeclErrorIfAny(From));; return 1;; }. Polluted AST; """""""""""""""""""""""". We may recognize an error during the import of a dependent node. However, by that time, we had already created the dependant.; In these cases we do not remove the existing erroneous node from the ""to"" context, rather we associate an error to that node.; Let's extend the previous example with another class ``Y``.; This class has a forward definition in the ""to"" context, but its definition is in the ""from"" context.; We'd like to import the definition, but it contains a member whose type conflicts with the type in the ""to"" context:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct X {};; // explicit specialization; template<>; struct X<int> { int i; };. class Y;; )"",; ""to.cc"");; ToUnit->enableSourceFileDiagnostics();; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct X {};; // explicit specialization; template<>; struct X<int> { int i2; };; // field mismatch: ^^. class Y { void f(",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:16500,Integrability,depend,dependant,16500,"`FieldDecl`` instead of the ``ClassTemplateSpecializationDecl``. .. code-block:: cpp. auto Matcher = fieldDecl(hasName(""i2""));; auto *From = getFirstDecl<FieldDecl>(Matcher, FromUnit);. In this case we can see that an error is associated (``getImportDeclErrorIfAny``) to the specialization also, not just to the field:. .. code-block:: cpp. llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // check that the ClassTemplateSpecializationDecl is also marked as; // erroneous.; auto *FromSpec = getFirstDecl<ClassTemplateSpecializationDecl>(; classTemplateSpecializationDecl(hasName(""X"")), FromUnit);; assert(Importer.getImportDeclErrorIfAny(FromSpec));; // Btw, the error is also set for the FieldDecl.; assert(Importer.getImportDeclErrorIfAny(From));; return 1;; }. Polluted AST; """""""""""""""""""""""". We may recognize an error during the import of a dependent node. However, by that time, we had already created the dependant.; In these cases we do not remove the existing erroneous node from the ""to"" context, rather we associate an error to that node.; Let's extend the previous example with another class ``Y``.; This class has a forward definition in the ""to"" context, but its definition is in the ""from"" context.; We'd like to import the definition, but it contains a member whose type conflicts with the type in the ""to"" context:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct X {};; // explicit specialization; template<>; struct X<int> { int i; };. class Y;; )"",; ""to.cc"");; ToUnit->enableSourceFileDiagnostics();; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct X {};; // explicit specialization; template<>; struct X<int> { int i2; };; // field mismatch: ^^. class Y { void f() { X<int> xi; } };; )"",; ""from.cc"");; FromUnit->enableSourceFi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:4011,Modifiability,variab,variable,4011,"then we check the structural equivalency on those nodes.; The following pseudo-code demonstrates the basics of the import mechanism:. .. code-block:: cpp. // Pseudo-code(!) of import:; ErrorOrDecl Import(Decl *FromD) {; Decl *ToDecl = nullptr;; FoundDeclsList = Look up all Decls in the ""to"" Ctx with the same name of FromD;; for (auto FoundDecl : FoundDeclsList) {; if (StructurallyEquivalentDecls(FoundDecl, FromD)) {; ToDecl = FoundDecl;; Mark FromD as imported;; break;; } else {; Report ODR violation;; return error;; }; }; if (FoundDeclsList is empty) {; Import dependent declarations and types of ToDecl;; ToDecl = create a new AST node in ""to"" Ctx;; Mark FromD as imported;; }; return ToDecl;; }. Two AST nodes are *structurally equivalent* if they are. - builtin types and refer to the same type, e.g. ``int`` and ``int`` are structurally equivalent,; - function types and all their parameters have structurally equivalent types,; - record types and all their fields in order of their definition have the same identifier names and structurally equivalent types,; - variable or function declarations and they have the same identifier name and their types are structurally equivalent. We could extend the definition of structural equivalency to templates similarly. If A and B are AST nodes and *A depends on B*, then we say that A is a **dependant** of B and B is a **dependency** of A.; The words ""dependant"" and ""dependency"" are nouns in British English.; Unfortunately, in American English, the adjective ""dependent"" is used for both meanings.; In this document, with the ""dependent"" adjective we always address the dependencies, the B node in the example. API; ---. Let's create a tool which uses the ASTImporter class!; First, we build two ASTs from virtual files; the content of the virtual files are synthesized from string literals:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc""); // empty file; std::unique_ptr<ASTUnit> FromUnit = buildASTFrom",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:4138,Modifiability,extend,extend,4138,"l = nullptr;; FoundDeclsList = Look up all Decls in the ""to"" Ctx with the same name of FromD;; for (auto FoundDecl : FoundDeclsList) {; if (StructurallyEquivalentDecls(FoundDecl, FromD)) {; ToDecl = FoundDecl;; Mark FromD as imported;; break;; } else {; Report ODR violation;; return error;; }; }; if (FoundDeclsList is empty) {; Import dependent declarations and types of ToDecl;; ToDecl = create a new AST node in ""to"" Ctx;; Mark FromD as imported;; }; return ToDecl;; }. Two AST nodes are *structurally equivalent* if they are. - builtin types and refer to the same type, e.g. ``int`` and ``int`` are structurally equivalent,; - function types and all their parameters have structurally equivalent types,; - record types and all their fields in order of their definition have the same identifier names and structurally equivalent types,; - variable or function declarations and they have the same identifier name and their types are structurally equivalent. We could extend the definition of structural equivalency to templates similarly. If A and B are AST nodes and *A depends on B*, then we say that A is a **dependant** of B and B is a **dependency** of A.; The words ""dependant"" and ""dependency"" are nouns in British English.; Unfortunately, in American English, the adjective ""dependent"" is used for both meanings.; In this document, with the ""dependent"" adjective we always address the dependencies, the B node in the example. API; ---. Let's create a tool which uses the ASTImporter class!; First, we build two ASTs from virtual files; the content of the virtual files are synthesized from string literals:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc""); // empty file; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");. The first AST corresponds to the destination (""to"") context - which is empty - and the second for the source (""from"") context.; Next, we define a matcher to match",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:10594,Modifiability,extend,extend,10594,"ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc"");; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");; auto Matcher = cxxRecordDecl(hasName(""MyClass""));; auto *From = getFirstDecl<CXXRecordDecl>(Matcher, FromUnit);. ASTImporter Importer(ToUnit->getASTContext(), ToUnit->getFileManager(),; FromUnit->getASTContext(), FromUnit->getFileManager(),; /*MinimalImport=*/true);; llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }; Decl *Imported = *ImportedOrErr;; Imported->getTranslationUnitDecl()->dump();. if (llvm::Error Err = Importer.ImportDefinition(From)) {; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }; llvm::errs() << ""Imported definition.\n"";; Imported->getTranslationUnitDecl()->dump();. return 0;; };. We may extend the ``CMakeLists.txt`` under let's say ``clang/tools`` with the build and link instructions:. .. code-block:: bash. add_clang_executable(astimporter-demo ASTImporterDemo.cpp); clang_target_link_libraries(astimporter-demo; PRIVATE; LLVMSupport; clangAST; clangASTMatchers; clangBasic; clangFrontend; clangSerialization; clangTooling; ). Then we can build and execute the new tool. .. code-block:: bash. $ ninja astimporter-demo && ./bin/astimporter-demo. Errors during the import process; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Normally, either the source or the destination context contains the definition of a declaration.; However, there may be cases when both of the contexts have a definition for a given symbol.; If these definitions differ, then we have a name conflict, in C++ it is known as ODR (one definition rule) violation.; Let's modify the previous tool we had written and try to import a ``ClassTemplateSpecializationDecl`` with a conflicting definition:. .. code-block:: cpp. int main() {; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:16645,Modifiability,extend,extend,16645," this case we can see that an error is associated (``getImportDeclErrorIfAny``) to the specialization also, not just to the field:. .. code-block:: cpp. llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // check that the ClassTemplateSpecializationDecl is also marked as; // erroneous.; auto *FromSpec = getFirstDecl<ClassTemplateSpecializationDecl>(; classTemplateSpecializationDecl(hasName(""X"")), FromUnit);; assert(Importer.getImportDeclErrorIfAny(FromSpec));; // Btw, the error is also set for the FieldDecl.; assert(Importer.getImportDeclErrorIfAny(From));; return 1;; }. Polluted AST; """""""""""""""""""""""". We may recognize an error during the import of a dependent node. However, by that time, we had already created the dependant.; In these cases we do not remove the existing erroneous node from the ""to"" context, rather we associate an error to that node.; Let's extend the previous example with another class ``Y``.; This class has a forward definition in the ""to"" context, but its definition is in the ""from"" context.; We'd like to import the definition, but it contains a member whose type conflicts with the type in the ""to"" context:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct X {};; // explicit specialization; template<>; struct X<int> { int i; };. class Y;; )"",; ""to.cc"");; ToUnit->enableSourceFileDiagnostics();; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct X {};; // explicit specialization; template<>; struct X<int> { int i2; };; // field mismatch: ^^. class Y { void f() { X<int> xi; } };; )"",; ""from.cc"");; FromUnit->enableSourceFileDiagnostics();; auto Matcher = cxxRecordDecl(hasName(""Y""));; auto *From = getFirstDecl<CXXRecordDecl>(Matcher, FromUnit);; auto *To = getFirstDecl<CXXRecordDecl>(Matcher, ToUnit);. This ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:20967,Modifiability,extend,extended,20967,"T.; This is aligned with the overall `design principle of the Clang AST <InternalsManual.html#immutability>`_: Clang AST nodes (types, declarations, statements, expressions, and so on) are generally designed to be **immutable once created**.; Thus, clients of the ASTImporter library should always check if there is any associated error for the node which they inspect in the destination context.; We recommend skipping the processing of those nodes which have an error associated with them. Using the ``-ast-merge`` Clang front-end action; -----------------------------------------------. The ``-ast-merge <pch-file>`` command-line switch can be used to merge from the given serialized AST file.; This file represents the source context.; When this switch is present then each top-level AST node of the source context is being merged into the destination context.; If the merge was successful then ``ASTConsumer::HandleTopLevelDecl`` is called for the Decl.; This results that we can execute the original front-end action on the extended AST. Example for C; ^^^^^^^^^^^^^. Let's consider the following three files:. .. code-block:: c. // bar.h; #ifndef BAR_H; #define BAR_H; int bar();; #endif /* BAR_H */. // bar.c; #include ""bar.h""; int bar() {; return 41;; }. // main.c; #include ""bar.h""; int main() {; return bar();; }. Let's generate the AST files for the two source files:. .. code-block:: bash. $ clang -cc1 -emit-pch -o bar.ast bar.c; $ clang -cc1 -emit-pch -o main.ast main.c. Then, let's check how the merged AST would look like if we consider only the ``bar()`` function:. .. code-block:: bash. $ clang -cc1 -ast-merge bar.ast -ast-merge main.ast /dev/null -ast-dump; TranslationUnitDecl 0x12b0738 <<invalid sloc>> <invalid sloc>; |-FunctionDecl 0x12b1470 </path/bar.h:4:1, col:9> col:5 used bar 'int ()'; |-FunctionDecl 0x12b1538 prev 0x12b1470 </path/bar.c:3:1, line:5:1> line:3:5 used bar 'int ()'; | `-CompoundStmt 0x12b1608 <col:11, line:5:1>; | `-ReturnStmt 0x12b15f8 <line:4:3, col:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:5795,Safety,recover,recoverable-errors,5795,"que_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc""); // empty file; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");. The first AST corresponds to the destination (""to"") context - which is empty - and the second for the source (""from"") context.; Next, we define a matcher to match ``MyClass`` in the ""from"" context:. .. code-block:: cpp. auto Matcher = cxxRecordDecl(hasName(""MyClass""));; auto *From = getFirstDecl<CXXRecordDecl>(Matcher, FromUnit);. Now we create the Importer and do the import:. .. code-block:: cpp. ASTImporter Importer(ToUnit->getASTContext(), ToUnit->getFileManager(),; FromUnit->getASTContext(), FromUnit->getFileManager(),; /*MinimalImport=*/true);; llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);. The ``Import`` call returns with ``llvm::Expected``, so, we must check for any error.; Please refer to the `error handling <https://llvm.org/docs/ProgrammersManual.html#recoverable-errors>`_ documentation for details. .. code-block:: cpp. if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }. If there's no error then we can get the underlying value.; In this example we will print the AST of the ""to"" context. .. code-block:: cpp. Decl *Imported = *ImportedOrErr;; Imported->getTranslationUnitDecl()->dump();. Since we set **minimal import** in the constructor of the importer, the AST will not contain the declaration of the members (once we run the test tool). .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; `-DefinitionData pass_in_registers standard_layout trivially_copyable trivial literal; |-DefaultConstructor exists trivial needs_implicit; |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; |-MoveConstructor exists simple tr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:6381,Testability,test,test,6381,"cl>(Matcher, FromUnit);. Now we create the Importer and do the import:. .. code-block:: cpp. ASTImporter Importer(ToUnit->getASTContext(), ToUnit->getFileManager(),; FromUnit->getASTContext(), FromUnit->getFileManager(),; /*MinimalImport=*/true);; llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);. The ``Import`` call returns with ``llvm::Expected``, so, we must check for any error.; Please refer to the `error handling <https://llvm.org/docs/ProgrammersManual.html#recoverable-errors>`_ documentation for details. .. code-block:: cpp. if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }. If there's no error then we can get the underlying value.; In this example we will print the AST of the ""to"" context. .. code-block:: cpp. Decl *Imported = *ImportedOrErr;; Imported->getTranslationUnitDecl()->dump();. Since we set **minimal import** in the constructor of the importer, the AST will not contain the declaration of the members (once we run the test tool). .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; `-DefinitionData pass_in_registers standard_layout trivially_copyable trivial literal; |-DefaultConstructor exists trivial needs_implicit; |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; |-MoveConstructor exists simple trivial needs_implicit; |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; |-MoveAssignment exists simple trivial needs_implicit; `-Destructor simple irrelevant trivial needs_implicit. We'd like to get the members too, so, we use ``ImportDefinition`` to copy the whole definition of ``MyClass`` into the ""to"" context.; Then we dump the AST again. .. code-block:: cpp. if (llvm::Error Err = Importer.ImportDefinition(From)) {; llvm::errs() << ""ERROR: "" << Err << ""\n"";; c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:9377,Testability,assert,assert,9377,"` if we set up the importer to do a ""normal"" (not minimal) import. .. code-block:: cpp. ASTImporter Importer( .... /*MinimalImport=*/false);. With **normal import**, all dependent declarations are imported normally.; However, with minimal import, the dependent Decls are imported without definition, and we have to import their definition for each if we later need that. Putting this all together here is how the source of the tool looks like:. .. code-block:: cpp. #include ""clang/AST/ASTImporter.h""; #include ""clang/ASTMatchers/ASTMatchFinder.h""; #include ""clang/ASTMatchers/ASTMatchers.h""; #include ""clang/Tooling/Tooling.h"". using namespace clang;; using namespace tooling;; using namespace ast_matchers;. template <typename Node, typename Matcher>; Node *getFirstDecl(Matcher M, const std::unique_ptr<ASTUnit> &Unit) {; auto MB = M.bind(""bindStr""); // Bind the to-be-matched node to a string key.; auto MatchRes = match(MB, Unit->getASTContext());; // We should have at least one match.; assert(MatchRes.size() >= 1);; // Get the first matched and bound node.; Node *Result =; const_cast<Node *>(MatchRes[0].template getNodeAs<Node>(""bindStr""));; assert(Result);; return Result;; }. int main() {; std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc"");; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");; auto Matcher = cxxRecordDecl(hasName(""MyClass""));; auto *From = getFirstDecl<CXXRecordDecl>(Matcher, FromUnit);. ASTImporter Importer(ToUnit->getASTContext(), ToUnit->getFileManager(),; FromUnit->getASTContext(), FromUnit->getFileManager(),; /*MinimalImport=*/true);; llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }; Decl *Imported = *ImportedOrErr;; Imported->getTranslationUnitDecl()->dump();. if (llvm::Error Err = Importer.ImportDefinitio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:9536,Testability,assert,assert,9536,"ormal import**, all dependent declarations are imported normally.; However, with minimal import, the dependent Decls are imported without definition, and we have to import their definition for each if we later need that. Putting this all together here is how the source of the tool looks like:. .. code-block:: cpp. #include ""clang/AST/ASTImporter.h""; #include ""clang/ASTMatchers/ASTMatchFinder.h""; #include ""clang/ASTMatchers/ASTMatchers.h""; #include ""clang/Tooling/Tooling.h"". using namespace clang;; using namespace tooling;; using namespace ast_matchers;. template <typename Node, typename Matcher>; Node *getFirstDecl(Matcher M, const std::unique_ptr<ASTUnit> &Unit) {; auto MB = M.bind(""bindStr""); // Bind the to-be-matched node to a string key.; auto MatchRes = match(MB, Unit->getASTContext());; // We should have at least one match.; assert(MatchRes.size() >= 1);; // Get the first matched and bound node.; Node *Result =; const_cast<Node *>(MatchRes[0].template getNodeAs<Node>(""bindStr""));; assert(Result);; return Result;; }. int main() {; std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc"");; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");; auto Matcher = cxxRecordDecl(hasName(""MyClass""));; auto *From = getFirstDecl<CXXRecordDecl>(Matcher, FromUnit);. ASTImporter Importer(ToUnit->getASTContext(), ToUnit->getFileManager(),; FromUnit->getASTContext(), FromUnit->getFileManager(),; /*MinimalImport=*/true);; llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }; Decl *Imported = *ImportedOrErr;; Imported->getTranslationUnitDecl()->dump();. if (llvm::Error Err = Importer.ImportDefinition(From)) {; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }; llvm::errs() << ""Imported definition.\n"";; Importe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:16191,Testability,assert,assert,16191,"col:14> col:14 implicit struct X; `-FieldDecl 0xe91600 <col:23, col:27> col:27 i 'int'. Error propagation; """""""""""""""""""""""""""""""""". If there is a dependent node we have to import before we could import a given node then the import error associated to the dependency propagates to the dependant node.; Let's modify the previous example and import a ``FieldDecl`` instead of the ``ClassTemplateSpecializationDecl``. .. code-block:: cpp. auto Matcher = fieldDecl(hasName(""i2""));; auto *From = getFirstDecl<FieldDecl>(Matcher, FromUnit);. In this case we can see that an error is associated (``getImportDeclErrorIfAny``) to the specialization also, not just to the field:. .. code-block:: cpp. llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // check that the ClassTemplateSpecializationDecl is also marked as; // erroneous.; auto *FromSpec = getFirstDecl<ClassTemplateSpecializationDecl>(; classTemplateSpecializationDecl(hasName(""X"")), FromUnit);; assert(Importer.getImportDeclErrorIfAny(FromSpec));; // Btw, the error is also set for the FieldDecl.; assert(Importer.getImportDeclErrorIfAny(From));; return 1;; }. Polluted AST; """""""""""""""""""""""". We may recognize an error during the import of a dependent node. However, by that time, we had already created the dependant.; In these cases we do not remove the existing erroneous node from the ""to"" context, rather we associate an error to that node.; Let's extend the previous example with another class ``Y``.; This class has a forward definition in the ""to"" context, but its definition is in the ""from"" context.; We'd like to import the definition, but it contains a member whose type conflicts with the type in the ""to"" context:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct X {};; // explicit specialization; template<>; struct X<int> { int i; };. class Y;; )",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:16294,Testability,assert,assert,16294," import before we could import a given node then the import error associated to the dependency propagates to the dependant node.; Let's modify the previous example and import a ``FieldDecl`` instead of the ``ClassTemplateSpecializationDecl``. .. code-block:: cpp. auto Matcher = fieldDecl(hasName(""i2""));; auto *From = getFirstDecl<FieldDecl>(Matcher, FromUnit);. In this case we can see that an error is associated (``getImportDeclErrorIfAny``) to the specialization also, not just to the field:. .. code-block:: cpp. llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // check that the ClassTemplateSpecializationDecl is also marked as; // erroneous.; auto *FromSpec = getFirstDecl<ClassTemplateSpecializationDecl>(; classTemplateSpecializationDecl(hasName(""X"")), FromUnit);; assert(Importer.getImportDeclErrorIfAny(FromSpec));; // Btw, the error is also set for the FieldDecl.; assert(Importer.getImportDeclErrorIfAny(From));; return 1;; }. Polluted AST; """""""""""""""""""""""". We may recognize an error during the import of a dependent node. However, by that time, we had already created the dependant.; In these cases we do not remove the existing erroneous node from the ""to"" context, rather we associate an error to that node.; Let's extend the previous example with another class ``Y``.; This class has a forward definition in the ""to"" context, but its definition is in the ""from"" context.; We'd like to import the definition, but it contains a member whose type conflicts with the type in the ""to"" context:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct X {};; // explicit specialization; template<>; struct X<int> { int i; };. class Y;; )"",; ""to.cc"");; ToUnit->enableSourceFileDiagnostics();; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:18780,Testability,assert,assert,18780,"ociated errors for the ""to"" context.; Note, there may be several different ASTImporter objects which import into the same ""to"" context but from different ""from"" contexts; they should share the same ``ASTImporterSharedState``.; (Also note, we have to include the corresponding ``ASTImporterSharedState.h`` header file.). .. code-block:: cpp. auto ImporterState = std::make_shared<ASTImporterSharedState>();; ASTImporter Importer(ToUnit->getASTContext(), ToUnit->getFileManager(),; FromUnit->getASTContext(), FromUnit->getFileManager(),; /*MinimalImport=*/false, ImporterState);; llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // ... but the node had been created.; auto *ToYDef = getFirstDecl<CXXRecordDecl>(; cxxRecordDecl(hasName(""Y""), isDefinition()), ToUnit);; ToYDef->dump();; // An error is set for ""ToYDef"" in the shared state.; Optional<ASTImportError> OptErr =; ImporterState->getImportDeclErrorIfAny(ToYDef);; assert(OptErr);. return 1;; }. If we take a look at the AST, then we can see that the Decl with the definition is created, but the field is missing. .. code-block:: bash. |-CXXRecordDecl 0xf66678 <line:9:7, col:13> col:13 class Y; `-CXXRecordDecl 0xf66730 prev 0xf66678 <:10:7, col:13> col:13 class Y definition; |-DefinitionData pass_in_registers empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init; | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; `-CXXRecordDecl 0xf66828 <col:7, col:13> col:13 implic",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:397,Usability,learn,learn,397,"===============================; ASTImporter: Merging Clang ASTs; ===============================. The ``ASTImporter`` class is part of Clang's core library, the AST library.; It imports nodes of an ``ASTContext`` into another ``ASTContext``. In this document, we assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured.; Knowledge about :doc:`matching the Clang AST <LibASTMatchers>` and the `reference for the matchers <https://clang.llvm.org/docs/LibASTMatchersReference.html>`_ are also useful. .. contents::; :local:. Introduction; ------------. ``ASTContext`` holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic analysis of a file.; In some cases it is preferable to work with more than one ``ASTContext``.; For example, we'd like to parse multiple different files inside the same Clang tool.; It may be convenient if we could view the set of the resulting ASTs as if they were one AST resulting from the parsing of each file together.; ``ASTImporter`` provides the way to copy types or declarations from one ``ASTContext`` to another.; We refer to the context from which we import as the **""from"" context** or *source context*; and the context into which we import as the **""to"" context** or *destination context*. Existing clients of the ``ASTImporter`` library are Cross Translation Unit (CTU) static analysis and the LLDB expression parser.; CTU static analysis imports a definition of a function if its definition is found in another translation unit (TU).; This way the analysis can breach out from the single TU limitation.; LLDB's ``expr`` command parses a user-defined expression, creates an ``ASTContext`` for that and then imports the missing definitions from the AST what we got from the debug information (DWARF, etc). Algorithm of the import; -----------------------. Importing one AST node copies that node int",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:6711,Usability,simpl,simple,6711,"fer to the `error handling <https://llvm.org/docs/ProgrammersManual.html#recoverable-errors>`_ documentation for details. .. code-block:: cpp. if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }. If there's no error then we can get the underlying value.; In this example we will print the AST of the ""to"" context. .. code-block:: cpp. Decl *Imported = *ImportedOrErr;; Imported->getTranslationUnitDecl()->dump();. Since we set **minimal import** in the constructor of the importer, the AST will not contain the declaration of the members (once we run the test tool). .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; `-DefinitionData pass_in_registers standard_layout trivially_copyable trivial literal; |-DefaultConstructor exists trivial needs_implicit; |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; |-MoveConstructor exists simple trivial needs_implicit; |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; |-MoveAssignment exists simple trivial needs_implicit; `-Destructor simple irrelevant trivial needs_implicit. We'd like to get the members too, so, we use ``ImportDefinition`` to copy the whole definition of ``MyClass`` into the ""to"" context.; Then we dump the AST again. .. code-block:: cpp. if (llvm::Error Err = Importer.ImportDefinition(From)) {; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }; llvm::errs() << ""Imported definition.\n"";; Imported->getTranslationUnitDecl()->dump();. This time the AST is going to contain the members too. .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; |-DefinitionData pass_in_registers standard_layout trivial",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:6808,Usability,simpl,simple,6808,"fer to the `error handling <https://llvm.org/docs/ProgrammersManual.html#recoverable-errors>`_ documentation for details. .. code-block:: cpp. if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }. If there's no error then we can get the underlying value.; In this example we will print the AST of the ""to"" context. .. code-block:: cpp. Decl *Imported = *ImportedOrErr;; Imported->getTranslationUnitDecl()->dump();. Since we set **minimal import** in the constructor of the importer, the AST will not contain the declaration of the members (once we run the test tool). .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; `-DefinitionData pass_in_registers standard_layout trivially_copyable trivial literal; |-DefaultConstructor exists trivial needs_implicit; |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; |-MoveConstructor exists simple trivial needs_implicit; |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; |-MoveAssignment exists simple trivial needs_implicit; `-Destructor simple irrelevant trivial needs_implicit. We'd like to get the members too, so, we use ``ImportDefinition`` to copy the whole definition of ``MyClass`` into the ""to"" context.; Then we dump the AST again. .. code-block:: cpp. if (llvm::Error Err = Importer.ImportDefinition(From)) {; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }; llvm::errs() << ""Imported definition.\n"";; Imported->getTranslationUnitDecl()->dump();. This time the AST is going to contain the members too. .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; |-DefinitionData pass_in_registers standard_layout trivial",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:6945,Usability,simpl,simple,6945,"fer to the `error handling <https://llvm.org/docs/ProgrammersManual.html#recoverable-errors>`_ documentation for details. .. code-block:: cpp. if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }. If there's no error then we can get the underlying value.; In this example we will print the AST of the ""to"" context. .. code-block:: cpp. Decl *Imported = *ImportedOrErr;; Imported->getTranslationUnitDecl()->dump();. Since we set **minimal import** in the constructor of the importer, the AST will not contain the declaration of the members (once we run the test tool). .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; `-DefinitionData pass_in_registers standard_layout trivially_copyable trivial literal; |-DefaultConstructor exists trivial needs_implicit; |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; |-MoveConstructor exists simple trivial needs_implicit; |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; |-MoveAssignment exists simple trivial needs_implicit; `-Destructor simple irrelevant trivial needs_implicit. We'd like to get the members too, so, we use ``ImportDefinition`` to copy the whole definition of ``MyClass`` into the ""to"" context.; Then we dump the AST again. .. code-block:: cpp. if (llvm::Error Err = Importer.ImportDefinition(From)) {; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }; llvm::errs() << ""Imported definition.\n"";; Imported->getTranslationUnitDecl()->dump();. This time the AST is going to contain the members too. .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; |-DefinitionData pass_in_registers standard_layout trivial",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:6989,Usability,simpl,simple,6989,"fer to the `error handling <https://llvm.org/docs/ProgrammersManual.html#recoverable-errors>`_ documentation for details. .. code-block:: cpp. if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }. If there's no error then we can get the underlying value.; In this example we will print the AST of the ""to"" context. .. code-block:: cpp. Decl *Imported = *ImportedOrErr;; Imported->getTranslationUnitDecl()->dump();. Since we set **minimal import** in the constructor of the importer, the AST will not contain the declaration of the members (once we run the test tool). .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; `-DefinitionData pass_in_registers standard_layout trivially_copyable trivial literal; |-DefaultConstructor exists trivial needs_implicit; |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; |-MoveConstructor exists simple trivial needs_implicit; |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; |-MoveAssignment exists simple trivial needs_implicit; `-Destructor simple irrelevant trivial needs_implicit. We'd like to get the members too, so, we use ``ImportDefinition`` to copy the whole definition of ``MyClass`` into the ""to"" context.; Then we dump the AST again. .. code-block:: cpp. if (llvm::Error Err = Importer.ImportDefinition(From)) {; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }; llvm::errs() << ""Imported definition.\n"";; Imported->getTranslationUnitDecl()->dump();. This time the AST is going to contain the members too. .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; |-DefinitionData pass_in_registers standard_layout trivial",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:7825,Usability,simpl,simple,7825,"gnment exists simple trivial needs_implicit; `-Destructor simple irrelevant trivial needs_implicit. We'd like to get the members too, so, we use ``ImportDefinition`` to copy the whole definition of ``MyClass`` into the ""to"" context.; Then we dump the AST again. .. code-block:: cpp. if (llvm::Error Err = Importer.ImportDefinition(From)) {; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }; llvm::errs() << ""Imported definition.\n"";; Imported->getTranslationUnitDecl()->dump();. This time the AST is going to contain the members too. .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; |-DefinitionData pass_in_registers standard_layout trivially_copyable trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-CXXRecordDecl 0x6c7f48 <col:7, col:13> col:13 implicit class MyClass; |-FieldDecl 0x6c7ff0 <line:3:9, col:13> col:13 m1 'int'; `-FieldDecl 0x6c8058 <line:4:9, col:13> col:13 m2 'int'. We can spare the call for ``ImportDefinition`` if we set up the importer to do a ""normal"" (not minimal) import. .. code-block:: cpp. ASTImporter Importer( .... /*MinimalImport=*/false);. With **normal import**, all dependent declarations are imported normally.; However, with minimal import, the dependent Decls are imported without definition, and we have to import their definition for each if we later need that. Putting this all together here is how the source of the tool looks like:. .. code-block:: cpp. #include ""clang/AST/ASTImporter.h""; #include ""clang/ASTMatchers/ASTMatchFinder.h""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:7924,Usability,simpl,simple,7924,"gnment exists simple trivial needs_implicit; `-Destructor simple irrelevant trivial needs_implicit. We'd like to get the members too, so, we use ``ImportDefinition`` to copy the whole definition of ``MyClass`` into the ""to"" context.; Then we dump the AST again. .. code-block:: cpp. if (llvm::Error Err = Importer.ImportDefinition(From)) {; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }; llvm::errs() << ""Imported definition.\n"";; Imported->getTranslationUnitDecl()->dump();. This time the AST is going to contain the members too. .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; |-DefinitionData pass_in_registers standard_layout trivially_copyable trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-CXXRecordDecl 0x6c7f48 <col:7, col:13> col:13 implicit class MyClass; |-FieldDecl 0x6c7ff0 <line:3:9, col:13> col:13 m1 'int'; `-FieldDecl 0x6c8058 <line:4:9, col:13> col:13 m2 'int'. We can spare the call for ``ImportDefinition`` if we set up the importer to do a ""normal"" (not minimal) import. .. code-block:: cpp. ASTImporter Importer( .... /*MinimalImport=*/false);. With **normal import**, all dependent declarations are imported normally.; However, with minimal import, the dependent Decls are imported without definition, and we have to import their definition for each if we later need that. Putting this all together here is how the source of the tool looks like:. .. code-block:: cpp. #include ""clang/AST/ASTImporter.h""; #include ""clang/ASTMatchers/ASTMatchFinder.h""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:8065,Usability,simpl,simple,8065,"gnment exists simple trivial needs_implicit; `-Destructor simple irrelevant trivial needs_implicit. We'd like to get the members too, so, we use ``ImportDefinition`` to copy the whole definition of ``MyClass`` into the ""to"" context.; Then we dump the AST again. .. code-block:: cpp. if (llvm::Error Err = Importer.ImportDefinition(From)) {; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }; llvm::errs() << ""Imported definition.\n"";; Imported->getTranslationUnitDecl()->dump();. This time the AST is going to contain the members too. .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; |-DefinitionData pass_in_registers standard_layout trivially_copyable trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-CXXRecordDecl 0x6c7f48 <col:7, col:13> col:13 implicit class MyClass; |-FieldDecl 0x6c7ff0 <line:3:9, col:13> col:13 m1 'int'; `-FieldDecl 0x6c8058 <line:4:9, col:13> col:13 m2 'int'. We can spare the call for ``ImportDefinition`` if we set up the importer to do a ""normal"" (not minimal) import. .. code-block:: cpp. ASTImporter Importer( .... /*MinimalImport=*/false);. With **normal import**, all dependent declarations are imported normally.; However, with minimal import, the dependent Decls are imported without definition, and we have to import their definition for each if we later need that. Putting this all together here is how the source of the tool looks like:. .. code-block:: cpp. #include ""clang/AST/ASTImporter.h""; #include ""clang/ASTMatchers/ASTMatchFinder.h""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:8111,Usability,simpl,simple,8111,"gnment exists simple trivial needs_implicit; `-Destructor simple irrelevant trivial needs_implicit. We'd like to get the members too, so, we use ``ImportDefinition`` to copy the whole definition of ``MyClass`` into the ""to"" context.; Then we dump the AST again. .. code-block:: cpp. if (llvm::Error Err = Importer.ImportDefinition(From)) {; llvm::errs() << ""ERROR: "" << Err << ""\n"";; consumeError(std::move(Err));; return 1;; }; llvm::errs() << ""Imported definition.\n"";; Imported->getTranslationUnitDecl()->dump();. This time the AST is going to contain the members too. .. code-block:: bash. TranslationUnitDecl 0x68b9a8 <<invalid sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; |-DefinitionData pass_in_registers standard_layout trivially_copyable trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-CXXRecordDecl 0x6c7f48 <col:7, col:13> col:13 implicit class MyClass; |-FieldDecl 0x6c7ff0 <line:3:9, col:13> col:13 m1 'int'; `-FieldDecl 0x6c8058 <line:4:9, col:13> col:13 m2 'int'. We can spare the call for ``ImportDefinition`` if we set up the importer to do a ""normal"" (not minimal) import. .. code-block:: cpp. ASTImporter Importer( .... /*MinimalImport=*/false);. With **normal import**, all dependent declarations are imported normally.; However, with minimal import, the dependent Decls are imported without definition, and we have to import their definition for each if we later need that. Putting this all together here is how the source of the tool looks like:. .. code-block:: cpp. #include ""clang/AST/ASTImporter.h""; #include ""clang/ASTMatchers/ASTMatchFinder.h""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:14015,Usability,simpl,simple,14015,"e left with the original AST. .. code-block:: bash. ERROR: NameConflict; TranslationUnitDecl 0xe54a48 <<invalid sloc>> <invalid sloc>; |-ClassTemplateDecl 0xe91020 <to.cc:3:7, line:4:17> col:14 X; | |-TemplateTypeParmDecl 0xe90ed0 <line:3:17, col:26> col:26 typename depth 0 index 0 T; | |-CXXRecordDecl 0xe90f90 <line:4:7, col:17> col:14 struct X definition; | | |-DefinitionData empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init; | | | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr; | | | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | | | |-MoveConstructor exists simple trivial needs_implicit; | | | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | | | |-MoveAssignment exists simple trivial needs_implicit; | | | `-Destructor simple irrelevant trivial needs_implicit; | | `-CXXRecordDecl 0xe91270 <col:7, col:14> col:14 implicit struct X; | `-ClassTemplateSpecialization 0xe91340 'X'; `-ClassTemplateSpecializationDecl 0xe91340 <line:6:7, line:7:30> col:14 struct X definition; |-DefinitionData pass_in_registers aggregate standard_layout trivially_copyable pod trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-TemplateArgument type 'int'; |-CXXRecordDecl 0xe91558 <col:7, col:14> col:14 implicit struct X; `-FieldDecl 0xe91600 <col:23, col:27> col:27 i 'int'. Error propagation; """""""""""""""""""""""""""""""""". If there is a dependent node we have to import before we could import a given node then the import error associated to the depend",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:14118,Usability,simpl,simple,14118,"e left with the original AST. .. code-block:: bash. ERROR: NameConflict; TranslationUnitDecl 0xe54a48 <<invalid sloc>> <invalid sloc>; |-ClassTemplateDecl 0xe91020 <to.cc:3:7, line:4:17> col:14 X; | |-TemplateTypeParmDecl 0xe90ed0 <line:3:17, col:26> col:26 typename depth 0 index 0 T; | |-CXXRecordDecl 0xe90f90 <line:4:7, col:17> col:14 struct X definition; | | |-DefinitionData empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init; | | | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr; | | | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | | | |-MoveConstructor exists simple trivial needs_implicit; | | | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | | | |-MoveAssignment exists simple trivial needs_implicit; | | | `-Destructor simple irrelevant trivial needs_implicit; | | `-CXXRecordDecl 0xe91270 <col:7, col:14> col:14 implicit struct X; | `-ClassTemplateSpecialization 0xe91340 'X'; `-ClassTemplateSpecializationDecl 0xe91340 <line:6:7, line:7:30> col:14 struct X definition; |-DefinitionData pass_in_registers aggregate standard_layout trivially_copyable pod trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-TemplateArgument type 'int'; |-CXXRecordDecl 0xe91558 <col:7, col:14> col:14 implicit struct X; `-FieldDecl 0xe91600 <col:23, col:27> col:27 i 'int'. Error propagation; """""""""""""""""""""""""""""""""". If there is a dependent node we have to import before we could import a given node then the import error associated to the depend",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:14267,Usability,simpl,simple,14267,"e left with the original AST. .. code-block:: bash. ERROR: NameConflict; TranslationUnitDecl 0xe54a48 <<invalid sloc>> <invalid sloc>; |-ClassTemplateDecl 0xe91020 <to.cc:3:7, line:4:17> col:14 X; | |-TemplateTypeParmDecl 0xe90ed0 <line:3:17, col:26> col:26 typename depth 0 index 0 T; | |-CXXRecordDecl 0xe90f90 <line:4:7, col:17> col:14 struct X definition; | | |-DefinitionData empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init; | | | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr; | | | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | | | |-MoveConstructor exists simple trivial needs_implicit; | | | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | | | |-MoveAssignment exists simple trivial needs_implicit; | | | `-Destructor simple irrelevant trivial needs_implicit; | | `-CXXRecordDecl 0xe91270 <col:7, col:14> col:14 implicit struct X; | `-ClassTemplateSpecialization 0xe91340 'X'; `-ClassTemplateSpecializationDecl 0xe91340 <line:6:7, line:7:30> col:14 struct X definition; |-DefinitionData pass_in_registers aggregate standard_layout trivially_copyable pod trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-TemplateArgument type 'int'; |-CXXRecordDecl 0xe91558 <col:7, col:14> col:14 implicit struct X; `-FieldDecl 0xe91600 <col:23, col:27> col:27 i 'int'. Error propagation; """""""""""""""""""""""""""""""""". If there is a dependent node we have to import before we could import a given node then the import error associated to the depend",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:14317,Usability,simpl,simple,14317,"e left with the original AST. .. code-block:: bash. ERROR: NameConflict; TranslationUnitDecl 0xe54a48 <<invalid sloc>> <invalid sloc>; |-ClassTemplateDecl 0xe91020 <to.cc:3:7, line:4:17> col:14 X; | |-TemplateTypeParmDecl 0xe90ed0 <line:3:17, col:26> col:26 typename depth 0 index 0 T; | |-CXXRecordDecl 0xe90f90 <line:4:7, col:17> col:14 struct X definition; | | |-DefinitionData empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init; | | | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr; | | | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | | | |-MoveConstructor exists simple trivial needs_implicit; | | | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | | | |-MoveAssignment exists simple trivial needs_implicit; | | | `-Destructor simple irrelevant trivial needs_implicit; | | `-CXXRecordDecl 0xe91270 <col:7, col:14> col:14 implicit struct X; | `-ClassTemplateSpecialization 0xe91340 'X'; `-ClassTemplateSpecializationDecl 0xe91340 <line:6:7, line:7:30> col:14 struct X definition; |-DefinitionData pass_in_registers aggregate standard_layout trivially_copyable pod trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-TemplateArgument type 'int'; |-CXXRecordDecl 0xe91558 <col:7, col:14> col:14 implicit struct X; `-FieldDecl 0xe91600 <col:23, col:27> col:27 i 'int'. Error propagation; """""""""""""""""""""""""""""""""". If there is a dependent node we have to import before we could import a given node then the import error associated to the depend",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:14744,Usability,simpl,simple,14744,"e left with the original AST. .. code-block:: bash. ERROR: NameConflict; TranslationUnitDecl 0xe54a48 <<invalid sloc>> <invalid sloc>; |-ClassTemplateDecl 0xe91020 <to.cc:3:7, line:4:17> col:14 X; | |-TemplateTypeParmDecl 0xe90ed0 <line:3:17, col:26> col:26 typename depth 0 index 0 T; | |-CXXRecordDecl 0xe90f90 <line:4:7, col:17> col:14 struct X definition; | | |-DefinitionData empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init; | | | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr; | | | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | | | |-MoveConstructor exists simple trivial needs_implicit; | | | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | | | |-MoveAssignment exists simple trivial needs_implicit; | | | `-Destructor simple irrelevant trivial needs_implicit; | | `-CXXRecordDecl 0xe91270 <col:7, col:14> col:14 implicit struct X; | `-ClassTemplateSpecialization 0xe91340 'X'; `-ClassTemplateSpecializationDecl 0xe91340 <line:6:7, line:7:30> col:14 struct X definition; |-DefinitionData pass_in_registers aggregate standard_layout trivially_copyable pod trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-TemplateArgument type 'int'; |-CXXRecordDecl 0xe91558 <col:7, col:14> col:14 implicit struct X; `-FieldDecl 0xe91600 <col:23, col:27> col:27 i 'int'. Error propagation; """""""""""""""""""""""""""""""""". If there is a dependent node we have to import before we could import a given node then the import error associated to the depend",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:14843,Usability,simpl,simple,14843,"e left with the original AST. .. code-block:: bash. ERROR: NameConflict; TranslationUnitDecl 0xe54a48 <<invalid sloc>> <invalid sloc>; |-ClassTemplateDecl 0xe91020 <to.cc:3:7, line:4:17> col:14 X; | |-TemplateTypeParmDecl 0xe90ed0 <line:3:17, col:26> col:26 typename depth 0 index 0 T; | |-CXXRecordDecl 0xe90f90 <line:4:7, col:17> col:14 struct X definition; | | |-DefinitionData empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init; | | | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr; | | | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | | | |-MoveConstructor exists simple trivial needs_implicit; | | | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | | | |-MoveAssignment exists simple trivial needs_implicit; | | | `-Destructor simple irrelevant trivial needs_implicit; | | `-CXXRecordDecl 0xe91270 <col:7, col:14> col:14 implicit struct X; | `-ClassTemplateSpecialization 0xe91340 'X'; `-ClassTemplateSpecializationDecl 0xe91340 <line:6:7, line:7:30> col:14 struct X definition; |-DefinitionData pass_in_registers aggregate standard_layout trivially_copyable pod trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-TemplateArgument type 'int'; |-CXXRecordDecl 0xe91558 <col:7, col:14> col:14 implicit struct X; `-FieldDecl 0xe91600 <col:23, col:27> col:27 i 'int'. Error propagation; """""""""""""""""""""""""""""""""". If there is a dependent node we have to import before we could import a given node then the import error associated to the depend",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:14984,Usability,simpl,simple,14984,"e left with the original AST. .. code-block:: bash. ERROR: NameConflict; TranslationUnitDecl 0xe54a48 <<invalid sloc>> <invalid sloc>; |-ClassTemplateDecl 0xe91020 <to.cc:3:7, line:4:17> col:14 X; | |-TemplateTypeParmDecl 0xe90ed0 <line:3:17, col:26> col:26 typename depth 0 index 0 T; | |-CXXRecordDecl 0xe90f90 <line:4:7, col:17> col:14 struct X definition; | | |-DefinitionData empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init; | | | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr; | | | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | | | |-MoveConstructor exists simple trivial needs_implicit; | | | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | | | |-MoveAssignment exists simple trivial needs_implicit; | | | `-Destructor simple irrelevant trivial needs_implicit; | | `-CXXRecordDecl 0xe91270 <col:7, col:14> col:14 implicit struct X; | `-ClassTemplateSpecialization 0xe91340 'X'; `-ClassTemplateSpecializationDecl 0xe91340 <line:6:7, line:7:30> col:14 struct X definition; |-DefinitionData pass_in_registers aggregate standard_layout trivially_copyable pod trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-TemplateArgument type 'int'; |-CXXRecordDecl 0xe91558 <col:7, col:14> col:14 implicit struct X; `-FieldDecl 0xe91600 <col:23, col:27> col:27 i 'int'. Error propagation; """""""""""""""""""""""""""""""""". If there is a dependent node we have to import before we could import a given node then the import error associated to the depend",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:15030,Usability,simpl,simple,15030,"e left with the original AST. .. code-block:: bash. ERROR: NameConflict; TranslationUnitDecl 0xe54a48 <<invalid sloc>> <invalid sloc>; |-ClassTemplateDecl 0xe91020 <to.cc:3:7, line:4:17> col:14 X; | |-TemplateTypeParmDecl 0xe90ed0 <line:3:17, col:26> col:26 typename depth 0 index 0 T; | |-CXXRecordDecl 0xe90f90 <line:4:7, col:17> col:14 struct X definition; | | |-DefinitionData empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init; | | | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr; | | | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | | | |-MoveConstructor exists simple trivial needs_implicit; | | | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | | | |-MoveAssignment exists simple trivial needs_implicit; | | | `-Destructor simple irrelevant trivial needs_implicit; | | `-CXXRecordDecl 0xe91270 <col:7, col:14> col:14 implicit struct X; | `-ClassTemplateSpecialization 0xe91340 'X'; `-ClassTemplateSpecializationDecl 0xe91340 <line:6:7, line:7:30> col:14 struct X definition; |-DefinitionData pass_in_registers aggregate standard_layout trivially_copyable pod trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-TemplateArgument type 'int'; |-CXXRecordDecl 0xe91558 <col:7, col:14> col:14 implicit struct X; `-FieldDecl 0xe91600 <col:23, col:27> col:27 i 'int'. Error propagation; """""""""""""""""""""""""""""""""". If there is a dependent node we have to import before we could import a given node then the import error associated to the depend",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:19363,Usability,simpl,simple,19363,"dOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // ... but the node had been created.; auto *ToYDef = getFirstDecl<CXXRecordDecl>(; cxxRecordDecl(hasName(""Y""), isDefinition()), ToUnit);; ToYDef->dump();; // An error is set for ""ToYDef"" in the shared state.; Optional<ASTImportError> OptErr =; ImporterState->getImportDeclErrorIfAny(ToYDef);; assert(OptErr);. return 1;; }. If we take a look at the AST, then we can see that the Decl with the definition is created, but the field is missing. .. code-block:: bash. |-CXXRecordDecl 0xf66678 <line:9:7, col:13> col:13 class Y; `-CXXRecordDecl 0xf66730 prev 0xf66678 <:10:7, col:13> col:13 class Y definition; |-DefinitionData pass_in_registers empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init; | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; `-CXXRecordDecl 0xf66828 <col:7, col:13> col:13 implicit class Y. We do not remove the erroneous nodes because by the time when we recognize the error it is too late to remove the node, there may be additional references to that already in the AST.; This is aligned with the overall `design principle of the Clang AST <InternalsManual.html#immutability>`_: Clang AST nodes (types, declarations, statements, expressions, and so on) are generally designed to be **immutable once created**.; Thus, clients of the ASTImporter library should always check if there is any associated error for the node which they inspect in the destination context.; We recommend skipp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:19462,Usability,simpl,simple,19462,"dOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // ... but the node had been created.; auto *ToYDef = getFirstDecl<CXXRecordDecl>(; cxxRecordDecl(hasName(""Y""), isDefinition()), ToUnit);; ToYDef->dump();; // An error is set for ""ToYDef"" in the shared state.; Optional<ASTImportError> OptErr =; ImporterState->getImportDeclErrorIfAny(ToYDef);; assert(OptErr);. return 1;; }. If we take a look at the AST, then we can see that the Decl with the definition is created, but the field is missing. .. code-block:: bash. |-CXXRecordDecl 0xf66678 <line:9:7, col:13> col:13 class Y; `-CXXRecordDecl 0xf66730 prev 0xf66678 <:10:7, col:13> col:13 class Y definition; |-DefinitionData pass_in_registers empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init; | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; `-CXXRecordDecl 0xf66828 <col:7, col:13> col:13 implicit class Y. We do not remove the erroneous nodes because by the time when we recognize the error it is too late to remove the node, there may be additional references to that already in the AST.; This is aligned with the overall `design principle of the Clang AST <InternalsManual.html#immutability>`_: Clang AST nodes (types, declarations, statements, expressions, and so on) are generally designed to be **immutable once created**.; Thus, clients of the ASTImporter library should always check if there is any associated error for the node which they inspect in the destination context.; We recommend skipp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:19603,Usability,simpl,simple,19603,"dOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // ... but the node had been created.; auto *ToYDef = getFirstDecl<CXXRecordDecl>(; cxxRecordDecl(hasName(""Y""), isDefinition()), ToUnit);; ToYDef->dump();; // An error is set for ""ToYDef"" in the shared state.; Optional<ASTImportError> OptErr =; ImporterState->getImportDeclErrorIfAny(ToYDef);; assert(OptErr);. return 1;; }. If we take a look at the AST, then we can see that the Decl with the definition is created, but the field is missing. .. code-block:: bash. |-CXXRecordDecl 0xf66678 <line:9:7, col:13> col:13 class Y; `-CXXRecordDecl 0xf66730 prev 0xf66678 <:10:7, col:13> col:13 class Y definition; |-DefinitionData pass_in_registers empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init; | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; `-CXXRecordDecl 0xf66828 <col:7, col:13> col:13 implicit class Y. We do not remove the erroneous nodes because by the time when we recognize the error it is too late to remove the node, there may be additional references to that already in the AST.; This is aligned with the overall `design principle of the Clang AST <InternalsManual.html#immutability>`_: Clang AST nodes (types, declarations, statements, expressions, and so on) are generally designed to be **immutable once created**.; Thus, clients of the ASTImporter library should always check if there is any associated error for the node which they inspect in the destination context.; We recommend skipp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:19649,Usability,simpl,simple,19649,"dOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // ... but the node had been created.; auto *ToYDef = getFirstDecl<CXXRecordDecl>(; cxxRecordDecl(hasName(""Y""), isDefinition()), ToUnit);; ToYDef->dump();; // An error is set for ""ToYDef"" in the shared state.; Optional<ASTImportError> OptErr =; ImporterState->getImportDeclErrorIfAny(ToYDef);; assert(OptErr);. return 1;; }. If we take a look at the AST, then we can see that the Decl with the definition is created, but the field is missing. .. code-block:: bash. |-CXXRecordDecl 0xf66678 <line:9:7, col:13> col:13 class Y; `-CXXRecordDecl 0xf66730 prev 0xf66678 <:10:7, col:13> col:13 class Y definition; |-DefinitionData pass_in_registers empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init; | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; `-CXXRecordDecl 0xf66828 <col:7, col:13> col:13 implicit class Y. We do not remove the erroneous nodes because by the time when we recognize the error it is too late to remove the node, there may be additional references to that already in the AST.; This is aligned with the overall `design principle of the Clang AST <InternalsManual.html#immutability>`_: Clang AST nodes (types, declarations, statements, expressions, and so on) are generally designed to be **immutable once created**.; Thus, clients of the ASTImporter library should always check if there is any associated error for the node which they inspect in the destination context.; We recommend skipp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTImporter.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst:1345,Availability,down,down,1345,"tion; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create tutorial and link to the tutorial. Introduction; ------------. LibASTMatchers provides a domain specific language to create predicates on; Clang's AST. This DSL is written in and can be used from C++, allowing users; to write a single program to both match AST nodes and access the node's C++; interface to extract attributes, source locations, or any other information; provided on the AST level. AST matchers are predicates on nodes in the AST. Matchers are created by; calling creator functions that allow building up a tree of matchers, where; inner matchers are used to make the match more specific. For example, to create a matcher that matches all class or union declarations; in the AST of a translation unit, you can call `recordDecl(); <LibASTMatchersReference.html#recordDecl0Anchor>`_. To narrow the match down,; for example to find all class or union declarations with the name ""``Foo``"",; insert a `hasName <LibASTMatchersReference.html#hasName0Anchor>`_ matcher: the; call ``recordDecl(hasName(""Foo""))`` returns a matcher that matches classes or; unions that are named ""``Foo``"", in any namespace. By default, matchers that; accept multiple inner matchers use an implicit `allOf(); <LibASTMatchersReference.html#allOf0Anchor>`_. This allows further narrowing; down the match, for example to match all classes that are derived from; ""``Bar``"": ``recordDecl(hasName(""Foo""), isDerivedFrom(""Bar""))``. How to create a matcher; -----------------------. With more than a thousand classes in the Clang AST, one can quickly get lost; when trying to figure out how to create a matcher for a specific pattern. This; section will teach you how to use a rigorous step-by-step pattern to build the; matcher you are interested in. Note that there will always be matchers missing; for some part of the AST. See the section about :ref:`how to write your own; AST matchers <a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst:1802,Availability,down,down,1802,"source locations, or any other information; provided on the AST level. AST matchers are predicates on nodes in the AST. Matchers are created by; calling creator functions that allow building up a tree of matchers, where; inner matchers are used to make the match more specific. For example, to create a matcher that matches all class or union declarations; in the AST of a translation unit, you can call `recordDecl(); <LibASTMatchersReference.html#recordDecl0Anchor>`_. To narrow the match down,; for example to find all class or union declarations with the name ""``Foo``"",; insert a `hasName <LibASTMatchersReference.html#hasName0Anchor>`_ matcher: the; call ``recordDecl(hasName(""Foo""))`` returns a matcher that matches classes or; unions that are named ""``Foo``"", in any namespace. By default, matchers that; accept multiple inner matchers use an implicit `allOf(); <LibASTMatchersReference.html#allOf0Anchor>`_. This allows further narrowing; down the match, for example to match all classes that are derived from; ""``Bar``"": ``recordDecl(hasName(""Foo""), isDerivedFrom(""Bar""))``. How to create a matcher; -----------------------. With more than a thousand classes in the Clang AST, one can quickly get lost; when trying to figure out how to create a matcher for a specific pattern. This; section will teach you how to use a rigorous step-by-step pattern to build the; matcher you are interested in. Note that there will always be matchers missing; for some part of the AST. See the section about :ref:`how to write your own; AST matchers <astmatchers-writing>` later in this document. .. FIXME: why is it linking back to the same section?!. The precondition to using the matchers is to understand how the AST for what you; want to match looks like. The; :doc:`Introduction to the Clang AST <IntroductionToTheClangAST>` teaches you; how to dump a translation unit's AST into a human readable format. .. FIXME: Introduce link to ASTMatchersTutorial.html; .. FIXME: Introduce link to ASTMatchersCoo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst:3131,Availability,down,down,3131,"e a matcher for a specific pattern. This; section will teach you how to use a rigorous step-by-step pattern to build the; matcher you are interested in. Note that there will always be matchers missing; for some part of the AST. See the section about :ref:`how to write your own; AST matchers <astmatchers-writing>` later in this document. .. FIXME: why is it linking back to the same section?!. The precondition to using the matchers is to understand how the AST for what you; want to match looks like. The; :doc:`Introduction to the Clang AST <IntroductionToTheClangAST>` teaches you; how to dump a translation unit's AST into a human readable format. .. FIXME: Introduce link to ASTMatchersTutorial.html; .. FIXME: Introduce link to ASTMatchersCookbook.html. In general, the strategy to create the right matchers is:. #. Find the outermost class in Clang's AST you want to match.; #. Look at the `AST Matcher Reference <LibASTMatchersReference.html>`_ for; matchers that either match the node you're interested in or narrow down; attributes on the node.; #. Create your outer match expression. Verify that it works as expected.; #. Examine the matchers for what the next inner node you want to match is.; #. Repeat until the matcher is finished. .. _astmatchers-bind:. Binding nodes in match expressions; ----------------------------------. Matcher expressions allow you to specify which parts of the AST are interesting; for a certain task. Often you will want to then do something with the nodes; that were matched, like building source code transformations. To that end, matchers that match specific AST nodes (so called node matchers); are bindable; for example, ``recordDecl(hasName(""MyClass"")).bind(""id"")`` will; bind the matched ``recordDecl`` node to the string ""``id``"", to be later; retrieved in the `match callback; <https://clang.llvm.org/doxygen/classclang_1_1ast__matchers_1_1MatchFinder_1_1MatchCallback.html>`_. .. FIXME: Introduce link to ASTMatchersTutorial.html; .. FIXME: Introdu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst:821,Integrability,interface,interface,821,"======================; Matching the Clang AST; ======================. This document explains how to use Clang's LibASTMatchers to match interesting; nodes of the AST and execute code that uses the matched nodes. Combined with; :doc:`LibTooling`, LibASTMatchers helps to write code-to-code transformation; tools or query tools. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create tutorial and link to the tutorial. Introduction; ------------. LibASTMatchers provides a domain specific language to create predicates on; Clang's AST. This DSL is written in and can be used from C++, allowing users; to write a single program to both match AST nodes and access the node's C++; interface to extract attributes, source locations, or any other information; provided on the AST level. AST matchers are predicates on nodes in the AST. Matchers are created by; calling creator functions that allow building up a tree of matchers, where; inner matchers are used to make the match more specific. For example, to create a matcher that matches all class or union declarations; in the AST of a translation unit, you can call `recordDecl(); <LibASTMatchersReference.html#recordDecl0Anchor>`_. To narrow the match down,; for example to find all class or union declarations with the name ""``Foo``"",; insert a `hasName <LibASTMatchersReference.html#hasName0Anchor>`_ matcher: the; call ``recordDecl(hasName(""Foo""))`` returns a matcher that matches classes or; unions that are named ""``Foo``"", in any namespace. By default, matchers that; accept multiple inner matchers use an implicit `allOf(); <LibASTMatchersReference.html#allOf0Anchor>`_. This allows further narrowing; down the match, for example to match all classes that are derived from; ""``Bar``"": ``recordDecl(hasName(""Foo""), isDerivedFrom(""Bar""))``. How to create a matcher; -----------------------. With more th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst:4252,Integrability,depend,depending,4252,"ine the matchers for what the next inner node you want to match is.; #. Repeat until the matcher is finished. .. _astmatchers-bind:. Binding nodes in match expressions; ----------------------------------. Matcher expressions allow you to specify which parts of the AST are interesting; for a certain task. Often you will want to then do something with the nodes; that were matched, like building source code transformations. To that end, matchers that match specific AST nodes (so called node matchers); are bindable; for example, ``recordDecl(hasName(""MyClass"")).bind(""id"")`` will; bind the matched ``recordDecl`` node to the string ""``id``"", to be later; retrieved in the `match callback; <https://clang.llvm.org/doxygen/classclang_1_1ast__matchers_1_1MatchFinder_1_1MatchCallback.html>`_. .. FIXME: Introduce link to ASTMatchersTutorial.html; .. FIXME: Introduce link to ASTMatchersCookbook.html. Writing your own matchers; -------------------------. There are multiple different ways to define a matcher, depending on its type; and flexibility. ``VariadicDynCastAllOfMatcher<Base, Derived>``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Those match all nodes of type *Base* if they can be dynamically casted to; *Derived*. The names of those matchers are nouns, which closely resemble; *Derived*. ``VariadicDynCastAllOfMatchers`` are the backbone of the matcher; hierarchy. Most often, your match expression will start with one of them, and; you can :ref:`bind <astmatchers-bind>` the node they represent to ids for later; processing. ``VariadicDynCastAllOfMatchers`` are callable classes that model variadic; template functions in C++03. They take an arbitrary number of; ``Matcher<Derived>`` and return a ``Matcher<Base>``. ``AST_MATCHER_P(Type, Name, ParamType, Param)``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Most matcher definitions use the matcher creation macros. Those define both; the matcher of type ``Matcher<Type>`` itself, and a matcher-creation function; named *Name* ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst:5387,Modifiability,polymorphi,polymorphic,5387,".. FIXME: Introduce link to ASTMatchersCookbook.html. Writing your own matchers; -------------------------. There are multiple different ways to define a matcher, depending on its type; and flexibility. ``VariadicDynCastAllOfMatcher<Base, Derived>``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Those match all nodes of type *Base* if they can be dynamically casted to; *Derived*. The names of those matchers are nouns, which closely resemble; *Derived*. ``VariadicDynCastAllOfMatchers`` are the backbone of the matcher; hierarchy. Most often, your match expression will start with one of them, and; you can :ref:`bind <astmatchers-bind>` the node they represent to ids for later; processing. ``VariadicDynCastAllOfMatchers`` are callable classes that model variadic; template functions in C++03. They take an arbitrary number of; ``Matcher<Derived>`` and return a ``Matcher<Base>``. ``AST_MATCHER_P(Type, Name, ParamType, Param)``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Most matcher definitions use the matcher creation macros. Those define both; the matcher of type ``Matcher<Type>`` itself, and a matcher-creation function; named *Name* that takes a parameter of type *ParamType* and returns the; corresponding matcher. There are multiple matcher definition macros that deal with polymorphic return; values and different parameter counts. See `ASTMatchersMacros.h; <https://clang.llvm.org/doxygen/ASTMatchersMacros_8h.html>`_. .. _astmatchers-writing:. Matcher creation functions; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Matchers are generated by nesting calls to matcher creation functions. Most of; the time those functions are either created by using; ``VariadicDynCastAllOfMatcher`` or the matcher creation macros (see below).; The free-standing functions are an indication that this matcher is just a; combination of other matchers, as is for example the case with `callee; <LibASTMatchersReference.html#callee1Anchor>`_. .. FIXME: ""... macros (see below)"" --- there isn't anything below. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst:798,Security,access,access,798,"======================; Matching the Clang AST; ======================. This document explains how to use Clang's LibASTMatchers to match interesting; nodes of the AST and execute code that uses the matched nodes. Combined with; :doc:`LibTooling`, LibASTMatchers helps to write code-to-code transformation; tools or query tools. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create tutorial and link to the tutorial. Introduction; ------------. LibASTMatchers provides a domain specific language to create predicates on; Clang's AST. This DSL is written in and can be used from C++, allowing users; to write a single program to both match AST nodes and access the node's C++; interface to extract attributes, source locations, or any other information; provided on the AST level. AST matchers are predicates on nodes in the AST. Matchers are created by; calling creator functions that allow building up a tree of matchers, where; inner matchers are used to make the match more specific. For example, to create a matcher that matches all class or union declarations; in the AST of a translation unit, you can call `recordDecl(); <LibASTMatchersReference.html#recordDecl0Anchor>`_. To narrow the match down,; for example to find all class or union declarations with the name ""``Foo``"",; insert a `hasName <LibASTMatchersReference.html#hasName0Anchor>`_ matcher: the; call ``recordDecl(hasName(""Foo""))`` returns a matcher that matches classes or; unions that are named ""``Foo``"", in any namespace. By default, matchers that; accept multiple inner matchers use an implicit `allOf(); <LibASTMatchersReference.html#allOf0Anchor>`_. This allows further narrowing; down the match, for example to match all classes that are derived from; ""``Bar``"": ``recordDecl(hasName(""Foo""), isDerivedFrom(""Bar""))``. How to create a matcher; -----------------------. With more th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst:465,Usability,learn,learn,465,"======================; Matching the Clang AST; ======================. This document explains how to use Clang's LibASTMatchers to match interesting; nodes of the AST and execute code that uses the matched nodes. Combined with; :doc:`LibTooling`, LibASTMatchers helps to write code-to-code transformation; tools or query tools. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create tutorial and link to the tutorial. Introduction; ------------. LibASTMatchers provides a domain specific language to create predicates on; Clang's AST. This DSL is written in and can be used from C++, allowing users; to write a single program to both match AST nodes and access the node's C++; interface to extract attributes, source locations, or any other information; provided on the AST level. AST matchers are predicates on nodes in the AST. Matchers are created by; calling creator functions that allow building up a tree of matchers, where; inner matchers are used to make the match more specific. For example, to create a matcher that matches all class or union declarations; in the AST of a translation unit, you can call `recordDecl(); <LibASTMatchersReference.html#recordDecl0Anchor>`_. To narrow the match down,; for example to find all class or union declarations with the name ""``Foo``"",; insert a `hasName <LibASTMatchersReference.html#hasName0Anchor>`_ matcher: the; call ``recordDecl(hasName(""Foo""))`` returns a matcher that matches classes or; unions that are named ""``Foo``"", in any namespace. By default, matchers that; accept multiple inner matchers use an implicit `allOf(); <LibASTMatchersReference.html#allOf0Anchor>`_. This allows further narrowing; down the match, for example to match all classes that are derived from; ""``Bar``"": ``recordDecl(hasName(""Foo""), isDerivedFrom(""Bar""))``. How to create a matcher; -----------------------. With more th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:789,Availability,down,download,789,"===============================================================; Tutorial for building tools using LibTooling and LibASTMatchers; ===============================================================. This document is intended to show how to build a useful source-to-source; translation tool based on Clang's `LibTooling <LibTooling.html>`_. It is; explicitly aimed at people who are new to Clang, so all you should need; is a working knowledge of C++ and the command line. In order to work on the compiler, you need some basic knowledge of the; abstract syntax tree (AST). To this end, the reader is encouraged to; skim the :doc:`Introduction to the Clang; AST <IntroductionToTheClangAST>`. Step 0: Obtaining Clang; =======================. As Clang is part of the LLVM project, you'll need to download LLVM's; source code first. Both Clang and LLVM are in the same git repository,; under different directories. For further information, see the `getting; started guide <https://llvm.org/docs/GettingStarted.html>`_. .. code-block:: console. mkdir ~/clang-llvm && cd ~/clang-llvm; git clone https://github.com/llvm/llvm-project.git. Next you need to obtain the CMake build system and Ninja build tool. .. code-block:: console. cd ~/clang-llvm; git clone https://github.com/martine/ninja.git; cd ninja; git checkout release; ./configure.py --bootstrap; sudo cp ninja /usr/bin/. cd ~/clang-llvm; git clone https://gitlab.kitware.com/cmake/cmake.git; cd cmake; git checkout next; ./bootstrap; make; sudo make install. Okay. Now we'll build Clang!. .. code-block:: console. cd ~/clang-llvm; mkdir build && cd build; cmake -G Ninja ../llvm-project/llvm -DLLVM_ENABLE_PROJECTS=""clang;clang-tools-extra"" -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TESTS=ON; ninja; ninja check # Test LLVM only.; ninja clang-test # Test Clang only.; ninja install. And we're live. All of the tests should pass. Finally, we want to set Clang as its own compiler. .. code-block:: console. cd ~/clang-llvm/build; ccmake ../llvm-project/ll",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:2170,Availability,down,down,2170,"sole. cd ~/clang-llvm; git clone https://github.com/martine/ninja.git; cd ninja; git checkout release; ./configure.py --bootstrap; sudo cp ninja /usr/bin/. cd ~/clang-llvm; git clone https://gitlab.kitware.com/cmake/cmake.git; cd cmake; git checkout next; ./bootstrap; make; sudo make install. Okay. Now we'll build Clang!. .. code-block:: console. cd ~/clang-llvm; mkdir build && cd build; cmake -G Ninja ../llvm-project/llvm -DLLVM_ENABLE_PROJECTS=""clang;clang-tools-extra"" -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TESTS=ON; ninja; ninja check # Test LLVM only.; ninja clang-test # Test Clang only.; ninja install. And we're live. All of the tests should pass. Finally, we want to set Clang as its own compiler. .. code-block:: console. cd ~/clang-llvm/build; ccmake ../llvm-project/llvm. The second command will bring up a GUI for configuring Clang. You need; to set the entry for ``CMAKE_CXX_COMPILER``. Press ``'t'`` to turn on; advanced mode. Scroll down to ``CMAKE_CXX_COMPILER``, and set it to; ``/usr/bin/clang++``, or wherever you installed it. Press ``'c'`` to; configure, then ``'g'`` to generate CMake's files. Finally, run ninja one last time, and you're done. Step 1: Create a ClangTool; ==========================. Now that we have enough background knowledge, it's time to create the; simplest productive ClangTool in existence: a syntax checker. While this; already exists as ``clang-check``, it's important to understand what's; going on. First, we'll need to create a new directory for our tool and tell CMake; that it exists. As this is not going to be a core clang tool, it will; live in the ``clang-tools-extra`` repository. .. code-block:: console. cd ~/clang-llvm/llvm-project; mkdir clang-tools-extra/loop-convert; echo 'add_subdirectory(loop-convert)' >> clang-tools-extra/CMakeLists.txt; vim clang-tools-extra/loop-convert/CMakeLists.txt. CMakeLists.txt should have the following contents:. ::. set(LLVM_LINK_COMPONENTS support). add_clang_executable(loop-convert; LoopConv",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:2955,Availability,echo,echo,2955," ~/clang-llvm/build; ccmake ../llvm-project/llvm. The second command will bring up a GUI for configuring Clang. You need; to set the entry for ``CMAKE_CXX_COMPILER``. Press ``'t'`` to turn on; advanced mode. Scroll down to ``CMAKE_CXX_COMPILER``, and set it to; ``/usr/bin/clang++``, or wherever you installed it. Press ``'c'`` to; configure, then ``'g'`` to generate CMake's files. Finally, run ninja one last time, and you're done. Step 1: Create a ClangTool; ==========================. Now that we have enough background knowledge, it's time to create the; simplest productive ClangTool in existence: a syntax checker. While this; already exists as ``clang-check``, it's important to understand what's; going on. First, we'll need to create a new directory for our tool and tell CMake; that it exists. As this is not going to be a core clang tool, it will; live in the ``clang-tools-extra`` repository. .. code-block:: console. cd ~/clang-llvm/llvm-project; mkdir clang-tools-extra/loop-convert; echo 'add_subdirectory(loop-convert)' >> clang-tools-extra/CMakeLists.txt; vim clang-tools-extra/loop-convert/CMakeLists.txt. CMakeLists.txt should have the following contents:. ::. set(LLVM_LINK_COMPONENTS support). add_clang_executable(loop-convert; LoopConvert.cpp; ); target_link_libraries(loop-convert; PRIVATE; clangAST; clangASTMatchers; clangBasic; clangFrontend; clangSerialization; clangTooling; ). With that done, Ninja will be able to compile our tool. Let's give it; something to compile! Put the following into; ``clang-tools-extra/loop-convert/LoopConvert.cpp``. A detailed explanation of; why the different parts are needed can be found in the `LibTooling; documentation <LibTooling.html>`_. .. code-block:: c++. // Declares clang::SyntaxOnlyAction.; #include ""clang/Frontend/FrontendActions.h""; #include ""clang/Tooling/CommonOptionsParser.h""; #include ""clang/Tooling/Tooling.h""; // Declares llvm::cl::extrahelp.; #include ""llvm/Support/CommandLine.h"". using namespace clang::tooling;;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:5327,Availability,echo,echo,5327,"n all tools.; static cl::extrahelp CommonHelp(CommonOptionsParser::HelpMessage);. // A help message for this specific tool can be added afterwards.; static cl::extrahelp MoreHelp(""\nMore help text...\n"");. int main(int argc, const char **argv) {; auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory);; if (!ExpectedParser) {; // Fail gracefully for unsupported options.; llvm::errs() << ExpectedParser.takeError();; return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());; return Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());; }. And that's it! You can compile our new tool by running ninja from the; ``build`` directory. .. code-block:: console. cd ~/clang-llvm/build; ninja. You should now be able to run the syntax checker, which is located in; ``~/clang-llvm/build/bin``, on any source file. Try it!. .. code-block:: console. echo ""int main() { return 0; }"" > test.cpp; bin/loop-convert test.cpp --. Note the two dashes after we specify the source file. The additional; options for the compiler are passed after the dashes rather than loading; them from a compilation database - there just aren't any options needed; right now. Intermezzo: Learn AST matcher basics; ====================================. Clang recently introduced the :doc:`ASTMatcher; library <LibASTMatchers>` to provide a simple, powerful, and; concise way to describe specific patterns in the AST. Implemented as a; DSL powered by macros and templates (see; `ASTMatchers.h <../doxygen/ASTMatchers_8h_source.html>`_ if you're; curious), matchers offer the feel of algebraic data types common to; functional programming languages. For example, suppose you wanted to examine only binary operators. There; is a matcher to do exactly that, conveniently named ``binaryOperator``.; I'll give you one guess what this matcher does:. .. code-block:: c++. binaryOperator(hasOperatorName",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:1309,Deployability,release,release,1309,"'s `LibTooling <LibTooling.html>`_. It is; explicitly aimed at people who are new to Clang, so all you should need; is a working knowledge of C++ and the command line. In order to work on the compiler, you need some basic knowledge of the; abstract syntax tree (AST). To this end, the reader is encouraged to; skim the :doc:`Introduction to the Clang; AST <IntroductionToTheClangAST>`. Step 0: Obtaining Clang; =======================. As Clang is part of the LLVM project, you'll need to download LLVM's; source code first. Both Clang and LLVM are in the same git repository,; under different directories. For further information, see the `getting; started guide <https://llvm.org/docs/GettingStarted.html>`_. .. code-block:: console. mkdir ~/clang-llvm && cd ~/clang-llvm; git clone https://github.com/llvm/llvm-project.git. Next you need to obtain the CMake build system and Ninja build tool. .. code-block:: console. cd ~/clang-llvm; git clone https://github.com/martine/ninja.git; cd ninja; git checkout release; ./configure.py --bootstrap; sudo cp ninja /usr/bin/. cd ~/clang-llvm; git clone https://gitlab.kitware.com/cmake/cmake.git; cd cmake; git checkout next; ./bootstrap; make; sudo make install. Okay. Now we'll build Clang!. .. code-block:: console. cd ~/clang-llvm; mkdir build && cd build; cmake -G Ninja ../llvm-project/llvm -DLLVM_ENABLE_PROJECTS=""clang;clang-tools-extra"" -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TESTS=ON; ninja; ninja check # Test LLVM only.; ninja clang-test # Test Clang only.; ninja install. And we're live. All of the tests should pass. Finally, we want to set Clang as its own compiler. .. code-block:: console. cd ~/clang-llvm/build; ccmake ../llvm-project/llvm. The second command will bring up a GUI for configuring Clang. You need; to set the entry for ``CMAKE_CXX_COMPILER``. Press ``'t'`` to turn on; advanced mode. Scroll down to ``CMAKE_CXX_COMPILER``, and set it to; ``/usr/bin/clang++``, or wherever you installed it. Press ``'c'`` to; configure, th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:1500,Deployability,install,install,1500,"e compiler, you need some basic knowledge of the; abstract syntax tree (AST). To this end, the reader is encouraged to; skim the :doc:`Introduction to the Clang; AST <IntroductionToTheClangAST>`. Step 0: Obtaining Clang; =======================. As Clang is part of the LLVM project, you'll need to download LLVM's; source code first. Both Clang and LLVM are in the same git repository,; under different directories. For further information, see the `getting; started guide <https://llvm.org/docs/GettingStarted.html>`_. .. code-block:: console. mkdir ~/clang-llvm && cd ~/clang-llvm; git clone https://github.com/llvm/llvm-project.git. Next you need to obtain the CMake build system and Ninja build tool. .. code-block:: console. cd ~/clang-llvm; git clone https://github.com/martine/ninja.git; cd ninja; git checkout release; ./configure.py --bootstrap; sudo cp ninja /usr/bin/. cd ~/clang-llvm; git clone https://gitlab.kitware.com/cmake/cmake.git; cd cmake; git checkout next; ./bootstrap; make; sudo make install. Okay. Now we'll build Clang!. .. code-block:: console. cd ~/clang-llvm; mkdir build && cd build; cmake -G Ninja ../llvm-project/llvm -DLLVM_ENABLE_PROJECTS=""clang;clang-tools-extra"" -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TESTS=ON; ninja; ninja check # Test LLVM only.; ninja clang-test # Test Clang only.; ninja install. And we're live. All of the tests should pass. Finally, we want to set Clang as its own compiler. .. code-block:: console. cd ~/clang-llvm/build; ccmake ../llvm-project/llvm. The second command will bring up a GUI for configuring Clang. You need; to set the entry for ``CMAKE_CXX_COMPILER``. Press ``'t'`` to turn on; advanced mode. Scroll down to ``CMAKE_CXX_COMPILER``, and set it to; ``/usr/bin/clang++``, or wherever you installed it. Press ``'c'`` to; configure, then ``'g'`` to generate CMake's files. Finally, run ninja one last time, and you're done. Step 1: Create a ClangTool; ==========================. Now that we have enough background knowledge,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:1822,Deployability,install,install,1822,"t. Both Clang and LLVM are in the same git repository,; under different directories. For further information, see the `getting; started guide <https://llvm.org/docs/GettingStarted.html>`_. .. code-block:: console. mkdir ~/clang-llvm && cd ~/clang-llvm; git clone https://github.com/llvm/llvm-project.git. Next you need to obtain the CMake build system and Ninja build tool. .. code-block:: console. cd ~/clang-llvm; git clone https://github.com/martine/ninja.git; cd ninja; git checkout release; ./configure.py --bootstrap; sudo cp ninja /usr/bin/. cd ~/clang-llvm; git clone https://gitlab.kitware.com/cmake/cmake.git; cd cmake; git checkout next; ./bootstrap; make; sudo make install. Okay. Now we'll build Clang!. .. code-block:: console. cd ~/clang-llvm; mkdir build && cd build; cmake -G Ninja ../llvm-project/llvm -DLLVM_ENABLE_PROJECTS=""clang;clang-tools-extra"" -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TESTS=ON; ninja; ninja check # Test LLVM only.; ninja clang-test # Test Clang only.; ninja install. And we're live. All of the tests should pass. Finally, we want to set Clang as its own compiler. .. code-block:: console. cd ~/clang-llvm/build; ccmake ../llvm-project/llvm. The second command will bring up a GUI for configuring Clang. You need; to set the entry for ``CMAKE_CXX_COMPILER``. Press ``'t'`` to turn on; advanced mode. Scroll down to ``CMAKE_CXX_COMPILER``, and set it to; ``/usr/bin/clang++``, or wherever you installed it. Press ``'c'`` to; configure, then ``'g'`` to generate CMake's files. Finally, run ninja one last time, and you're done. Step 1: Create a ClangTool; ==========================. Now that we have enough background knowledge, it's time to create the; simplest productive ClangTool in existence: a syntax checker. While this; already exists as ``clang-check``, it's important to understand what's; going on. First, we'll need to create a new directory for our tool and tell CMake; that it exists. As this is not going to be a core clang tool, it will; live i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:2255,Deployability,install,installed,2255,"sole. cd ~/clang-llvm; git clone https://github.com/martine/ninja.git; cd ninja; git checkout release; ./configure.py --bootstrap; sudo cp ninja /usr/bin/. cd ~/clang-llvm; git clone https://gitlab.kitware.com/cmake/cmake.git; cd cmake; git checkout next; ./bootstrap; make; sudo make install. Okay. Now we'll build Clang!. .. code-block:: console. cd ~/clang-llvm; mkdir build && cd build; cmake -G Ninja ../llvm-project/llvm -DLLVM_ENABLE_PROJECTS=""clang;clang-tools-extra"" -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TESTS=ON; ninja; ninja check # Test LLVM only.; ninja clang-test # Test Clang only.; ninja install. And we're live. All of the tests should pass. Finally, we want to set Clang as its own compiler. .. code-block:: console. cd ~/clang-llvm/build; ccmake ../llvm-project/llvm. The second command will bring up a GUI for configuring Clang. You need; to set the entry for ``CMAKE_CXX_COMPILER``. Press ``'t'`` to turn on; advanced mode. Scroll down to ``CMAKE_CXX_COMPILER``, and set it to; ``/usr/bin/clang++``, or wherever you installed it. Press ``'c'`` to; configure, then ``'g'`` to generate CMake's files. Finally, run ninja one last time, and you're done. Step 1: Create a ClangTool; ==========================. Now that we have enough background knowledge, it's time to create the; simplest productive ClangTool in existence: a syntax checker. While this; already exists as ``clang-check``, it's important to understand what's; going on. First, we'll need to create a new directory for our tool and tell CMake; that it exists. As this is not going to be a core clang tool, it will; live in the ``clang-tools-extra`` repository. .. code-block:: console. cd ~/clang-llvm/llvm-project; mkdir clang-tools-extra/loop-convert; echo 'add_subdirectory(loop-convert)' >> clang-tools-extra/CMakeLists.txt; vim clang-tools-extra/loop-convert/CMakeLists.txt. CMakeLists.txt should have the following contents:. ::. set(LLVM_LINK_COMPONENTS support). add_clang_executable(loop-convert; LoopConv",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:5800,Energy Efficiency,power,powerful,5800," return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());; return Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());; }. And that's it! You can compile our new tool by running ninja from the; ``build`` directory. .. code-block:: console. cd ~/clang-llvm/build; ninja. You should now be able to run the syntax checker, which is located in; ``~/clang-llvm/build/bin``, on any source file. Try it!. .. code-block:: console. echo ""int main() { return 0; }"" > test.cpp; bin/loop-convert test.cpp --. Note the two dashes after we specify the source file. The additional; options for the compiler are passed after the dashes rather than loading; them from a compilation database - there just aren't any options needed; right now. Intermezzo: Learn AST matcher basics; ====================================. Clang recently introduced the :doc:`ASTMatcher; library <LibASTMatchers>` to provide a simple, powerful, and; concise way to describe specific patterns in the AST. Implemented as a; DSL powered by macros and templates (see; `ASTMatchers.h <../doxygen/ASTMatchers_8h_source.html>`_ if you're; curious), matchers offer the feel of algebraic data types common to; functional programming languages. For example, suppose you wanted to examine only binary operators. There; is a matcher to do exactly that, conveniently named ``binaryOperator``.; I'll give you one guess what this matcher does:. .. code-block:: c++. binaryOperator(hasOperatorName(""+""), hasLHS(integerLiteral(equals(0)))). Shockingly, it will match against addition expressions whose left hand; side is exactly the literal 0. It will not match against other forms of; 0, such as ``'\0'`` or ``NULL``, but it will match against macros that; expand to 0. The matcher will also not match against calls to the; overloaded operator ``'+'``, as there is a separate ``operatorCallExpr``; matcher to handle overloaded operators.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:5891,Energy Efficiency,power,powered,5891,"(),; OptionsParser.getSourcePathList());; return Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());; }. And that's it! You can compile our new tool by running ninja from the; ``build`` directory. .. code-block:: console. cd ~/clang-llvm/build; ninja. You should now be able to run the syntax checker, which is located in; ``~/clang-llvm/build/bin``, on any source file. Try it!. .. code-block:: console. echo ""int main() { return 0; }"" > test.cpp; bin/loop-convert test.cpp --. Note the two dashes after we specify the source file. The additional; options for the compiler are passed after the dashes rather than loading; them from a compilation database - there just aren't any options needed; right now. Intermezzo: Learn AST matcher basics; ====================================. Clang recently introduced the :doc:`ASTMatcher; library <LibASTMatchers>` to provide a simple, powerful, and; concise way to describe specific patterns in the AST. Implemented as a; DSL powered by macros and templates (see; `ASTMatchers.h <../doxygen/ASTMatchers_8h_source.html>`_ if you're; curious), matchers offer the feel of algebraic data types common to; functional programming languages. For example, suppose you wanted to examine only binary operators. There; is a matcher to do exactly that, conveniently named ``binaryOperator``.; I'll give you one guess what this matcher does:. .. code-block:: c++. binaryOperator(hasOperatorName(""+""), hasLHS(integerLiteral(equals(0)))). Shockingly, it will match against addition expressions whose left hand; side is exactly the literal 0. It will not match against other forms of; 0, such as ``'\0'`` or ``NULL``, but it will match against macros that; expand to 0. The matcher will also not match against calls to the; overloaded operator ``'+'``, as there is a separate ``operatorCallExpr``; matcher to handle overloaded operators. There are AST matchers to match all the different nodes of the AST,; narrowing matchers to only match AST nodes fulfil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:4337,Integrability,message,message,4337,"gSerialization; clangTooling; ). With that done, Ninja will be able to compile our tool. Let's give it; something to compile! Put the following into; ``clang-tools-extra/loop-convert/LoopConvert.cpp``. A detailed explanation of; why the different parts are needed can be found in the `LibTooling; documentation <LibTooling.html>`_. .. code-block:: c++. // Declares clang::SyntaxOnlyAction.; #include ""clang/Frontend/FrontendActions.h""; #include ""clang/Tooling/CommonOptionsParser.h""; #include ""clang/Tooling/Tooling.h""; // Declares llvm::cl::extrahelp.; #include ""llvm/Support/CommandLine.h"". using namespace clang::tooling;; using namespace llvm;. // Apply a custom category to all command-line options so that they are the; // only ones displayed.; static llvm::cl::OptionCategory MyToolCategory(""my-tool options"");. // CommonOptionsParser declares HelpMessage with a description of the common; // command-line options related to the compilation database and input files.; // It's nice to have this help message in all tools.; static cl::extrahelp CommonHelp(CommonOptionsParser::HelpMessage);. // A help message for this specific tool can be added afterwards.; static cl::extrahelp MoreHelp(""\nMore help text...\n"");. int main(int argc, const char **argv) {; auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory);; if (!ExpectedParser) {; // Fail gracefully for unsupported options.; llvm::errs() << ExpectedParser.takeError();; return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());; return Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());; }. And that's it! You can compile our new tool by running ninja from the; ``build`` directory. .. code-block:: console. cd ~/clang-llvm/build; ninja. You should now be able to run the syntax checker, which is located in; ``~/clang-llvm/build/bin``, on any source file. Try it!. .. code-block:: console. echo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:4438,Integrability,message,message,4438," the following into; ``clang-tools-extra/loop-convert/LoopConvert.cpp``. A detailed explanation of; why the different parts are needed can be found in the `LibTooling; documentation <LibTooling.html>`_. .. code-block:: c++. // Declares clang::SyntaxOnlyAction.; #include ""clang/Frontend/FrontendActions.h""; #include ""clang/Tooling/CommonOptionsParser.h""; #include ""clang/Tooling/Tooling.h""; // Declares llvm::cl::extrahelp.; #include ""llvm/Support/CommandLine.h"". using namespace clang::tooling;; using namespace llvm;. // Apply a custom category to all command-line options so that they are the; // only ones displayed.; static llvm::cl::OptionCategory MyToolCategory(""my-tool options"");. // CommonOptionsParser declares HelpMessage with a description of the common; // command-line options related to the compilation database and input files.; // It's nice to have this help message in all tools.; static cl::extrahelp CommonHelp(CommonOptionsParser::HelpMessage);. // A help message for this specific tool can be added afterwards.; static cl::extrahelp MoreHelp(""\nMore help text...\n"");. int main(int argc, const char **argv) {; auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory);; if (!ExpectedParser) {; // Fail gracefully for unsupported options.; llvm::errs() << ExpectedParser.takeError();; return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());; return Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());; }. And that's it! You can compile our new tool by running ninja from the; ``build`` directory. .. code-block:: console. cd ~/clang-llvm/build; ninja. You should now be able to run the syntax checker, which is located in; ``~/clang-llvm/build/bin``, on any source file. Try it!. .. code-block:: console. echo ""int main() { return 0; }"" > test.cpp; bin/loop-convert test.cpp --. Note the two dashes after we specify the source file. The a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:18562,Integrability,message,message,18562,"odeAs<VarDecl>(""incVarName"");; const VarDecl *CondVar = Result.Nodes.getNodeAs<VarDecl>(""condVarName"");; const VarDecl *InitVar = Result.Nodes.getNodeAs<VarDecl>(""initVarName"");. if (!areSameVariable(IncVar, CondVar) || !areSameVariable(IncVar, InitVar)); return;; llvm::outs() << ""Potential array-based loop discovered.\n"";; }. Clang associates a ``VarDecl`` with each variable to represent the variable's; declaration. Since the ""canonical"" form of each declaration is unique by; address, all we need to do is make sure neither ``ValueDecl`` (base class of; ``VarDecl``) is ``NULL`` and compare the canonical Decls. .. code-block:: c++. static bool areSameVariable(const ValueDecl *First, const ValueDecl *Second) {; return First && Second &&; First->getCanonicalDecl() == Second->getCanonicalDecl();; }. If execution reaches the end of ``LoopPrinter::run()``, we know that the; loop shell looks like. .. code-block:: c++. for (int i= 0; i < expr(); ++i) { ... }. For now, we will just print a message explaining that we found a loop.; The next section will deal with recursively traversing the AST to; discover all changes needed. As a side note, it's not as trivial to test if two expressions are the same,; though Clang has already done the hard work for us by providing a way to; canonicalize expressions:. .. code-block:: c++. static bool areSameExpr(ASTContext *Context, const Expr *First,; const Expr *Second) {; if (!First || !Second); return false;; llvm::FoldingSetNodeID FirstID, SecondID;; First->Profile(FirstID, *Context, true);; Second->Profile(SecondID, *Context, true);; return FirstID == SecondID;; }. This code relies on the comparison between two; ``llvm::FoldingSetNodeIDs``. As the documentation for; ``Stmt::Profile()`` indicates, the ``Profile()`` member function builds; a description of a node in the AST, based on its properties, along with; those of its children. ``FoldingSetNodeID`` then serves as a hash we can; use to compare expressions. We will need ``areSameExpr``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:1320,Modifiability,config,configure,1320,"ng.html>`_. It is; explicitly aimed at people who are new to Clang, so all you should need; is a working knowledge of C++ and the command line. In order to work on the compiler, you need some basic knowledge of the; abstract syntax tree (AST). To this end, the reader is encouraged to; skim the :doc:`Introduction to the Clang; AST <IntroductionToTheClangAST>`. Step 0: Obtaining Clang; =======================. As Clang is part of the LLVM project, you'll need to download LLVM's; source code first. Both Clang and LLVM are in the same git repository,; under different directories. For further information, see the `getting; started guide <https://llvm.org/docs/GettingStarted.html>`_. .. code-block:: console. mkdir ~/clang-llvm && cd ~/clang-llvm; git clone https://github.com/llvm/llvm-project.git. Next you need to obtain the CMake build system and Ninja build tool. .. code-block:: console. cd ~/clang-llvm; git clone https://github.com/martine/ninja.git; cd ninja; git checkout release; ./configure.py --bootstrap; sudo cp ninja /usr/bin/. cd ~/clang-llvm; git clone https://gitlab.kitware.com/cmake/cmake.git; cd cmake; git checkout next; ./bootstrap; make; sudo make install. Okay. Now we'll build Clang!. .. code-block:: console. cd ~/clang-llvm; mkdir build && cd build; cmake -G Ninja ../llvm-project/llvm -DLLVM_ENABLE_PROJECTS=""clang;clang-tools-extra"" -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TESTS=ON; ninja; ninja check # Test LLVM only.; ninja clang-test # Test Clang only.; ninja install. And we're live. All of the tests should pass. Finally, we want to set Clang as its own compiler. .. code-block:: console. cd ~/clang-llvm/build; ccmake ../llvm-project/llvm. The second command will bring up a GUI for configuring Clang. You need; to set the entry for ``CMAKE_CXX_COMPILER``. Press ``'t'`` to turn on; advanced mode. Scroll down to ``CMAKE_CXX_COMPILER``, and set it to; ``/usr/bin/clang++``, or wherever you installed it. Press ``'c'`` to; configure, then ``'g'`` to generate CM",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:2048,Modifiability,config,configuring,2048," mkdir ~/clang-llvm && cd ~/clang-llvm; git clone https://github.com/llvm/llvm-project.git. Next you need to obtain the CMake build system and Ninja build tool. .. code-block:: console. cd ~/clang-llvm; git clone https://github.com/martine/ninja.git; cd ninja; git checkout release; ./configure.py --bootstrap; sudo cp ninja /usr/bin/. cd ~/clang-llvm; git clone https://gitlab.kitware.com/cmake/cmake.git; cd cmake; git checkout next; ./bootstrap; make; sudo make install. Okay. Now we'll build Clang!. .. code-block:: console. cd ~/clang-llvm; mkdir build && cd build; cmake -G Ninja ../llvm-project/llvm -DLLVM_ENABLE_PROJECTS=""clang;clang-tools-extra"" -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TESTS=ON; ninja; ninja check # Test LLVM only.; ninja clang-test # Test Clang only.; ninja install. And we're live. All of the tests should pass. Finally, we want to set Clang as its own compiler. .. code-block:: console. cd ~/clang-llvm/build; ccmake ../llvm-project/llvm. The second command will bring up a GUI for configuring Clang. You need; to set the entry for ``CMAKE_CXX_COMPILER``. Press ``'t'`` to turn on; advanced mode. Scroll down to ``CMAKE_CXX_COMPILER``, and set it to; ``/usr/bin/clang++``, or wherever you installed it. Press ``'c'`` to; configure, then ``'g'`` to generate CMake's files. Finally, run ninja one last time, and you're done. Step 1: Create a ClangTool; ==========================. Now that we have enough background knowledge, it's time to create the; simplest productive ClangTool in existence: a syntax checker. While this; already exists as ``clang-check``, it's important to understand what's; going on. First, we'll need to create a new directory for our tool and tell CMake; that it exists. As this is not going to be a core clang tool, it will; live in the ``clang-tools-extra`` repository. .. code-block:: console. cd ~/clang-llvm/llvm-project; mkdir clang-tools-extra/loop-convert; echo 'add_subdirectory(loop-convert)' >> clang-tools-extra/CMakeLists.txt; vim c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:2287,Modifiability,config,configure,2287,"eckout release; ./configure.py --bootstrap; sudo cp ninja /usr/bin/. cd ~/clang-llvm; git clone https://gitlab.kitware.com/cmake/cmake.git; cd cmake; git checkout next; ./bootstrap; make; sudo make install. Okay. Now we'll build Clang!. .. code-block:: console. cd ~/clang-llvm; mkdir build && cd build; cmake -G Ninja ../llvm-project/llvm -DLLVM_ENABLE_PROJECTS=""clang;clang-tools-extra"" -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TESTS=ON; ninja; ninja check # Test LLVM only.; ninja clang-test # Test Clang only.; ninja install. And we're live. All of the tests should pass. Finally, we want to set Clang as its own compiler. .. code-block:: console. cd ~/clang-llvm/build; ccmake ../llvm-project/llvm. The second command will bring up a GUI for configuring Clang. You need; to set the entry for ``CMAKE_CXX_COMPILER``. Press ``'t'`` to turn on; advanced mode. Scroll down to ``CMAKE_CXX_COMPILER``, and set it to; ``/usr/bin/clang++``, or wherever you installed it. Press ``'c'`` to; configure, then ``'g'`` to generate CMake's files. Finally, run ninja one last time, and you're done. Step 1: Create a ClangTool; ==========================. Now that we have enough background knowledge, it's time to create the; simplest productive ClangTool in existence: a syntax checker. While this; already exists as ``clang-check``, it's important to understand what's; going on. First, we'll need to create a new directory for our tool and tell CMake; that it exists. As this is not going to be a core clang tool, it will; live in the ``clang-tools-extra`` repository. .. code-block:: console. cd ~/clang-llvm/llvm-project; mkdir clang-tools-extra/loop-convert; echo 'add_subdirectory(loop-convert)' >> clang-tools-extra/CMakeLists.txt; vim clang-tools-extra/loop-convert/CMakeLists.txt. CMakeLists.txt should have the following contents:. ::. set(LLVM_LINK_COMPONENTS support). add_clang_executable(loop-convert; LoopConvert.cpp; ); target_link_libraries(loop-convert; PRIVATE; clangAST; clangASTMatchers; cla",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:7338,Modifiability,variab,variable,7338,"hasLHS(integerLiteral(equals(0)))). Shockingly, it will match against addition expressions whose left hand; side is exactly the literal 0. It will not match against other forms of; 0, such as ``'\0'`` or ``NULL``, but it will match against macros that; expand to 0. The matcher will also not match against calls to the; overloaded operator ``'+'``, as there is a separate ``operatorCallExpr``; matcher to handle overloaded operators. There are AST matchers to match all the different nodes of the AST,; narrowing matchers to only match AST nodes fulfilling specific criteria,; and traversal matchers to get from one kind of AST node to another. For; a complete list of AST matchers, take a look at the `AST Matcher; References <LibASTMatchersReference.html>`_. All matcher that are nouns describe entities in the AST and can be; bound, so that they can be referred to whenever a match is found. To do; so, simply call the method ``bind`` on these matchers, e.g.:. .. code-block:: c++. variable(hasType(isInteger())).bind(""intvar""). Step 2: Using AST matchers; ==========================. Okay, on to using matchers for real. Let's start by defining a matcher; which will capture all ``for`` statements that define a new variable; initialized to zero. Let's start with matching all ``for`` loops:. .. code-block:: c++. forStmt(). Next, we want to specify that a single variable is declared in the first; portion of the loop, so we can extend the matcher to. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl())))). Finally, we can add the condition that the variable is initialized to; zero. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))). It is fairly easy to read and understand the matcher definition (""match; loops whose init portion declares a single variable which is initialized; to the integer literal 0""), but deciding that every piece is necessary; is more difficult. Note that this matcher will",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:7573,Modifiability,variab,variable,7573,"h as ``'\0'`` or ``NULL``, but it will match against macros that; expand to 0. The matcher will also not match against calls to the; overloaded operator ``'+'``, as there is a separate ``operatorCallExpr``; matcher to handle overloaded operators. There are AST matchers to match all the different nodes of the AST,; narrowing matchers to only match AST nodes fulfilling specific criteria,; and traversal matchers to get from one kind of AST node to another. For; a complete list of AST matchers, take a look at the `AST Matcher; References <LibASTMatchersReference.html>`_. All matcher that are nouns describe entities in the AST and can be; bound, so that they can be referred to whenever a match is found. To do; so, simply call the method ``bind`` on these matchers, e.g.:. .. code-block:: c++. variable(hasType(isInteger())).bind(""intvar""). Step 2: Using AST matchers; ==========================. Okay, on to using matchers for real. Let's start by defining a matcher; which will capture all ``for`` statements that define a new variable; initialized to zero. Let's start with matching all ``for`` loops:. .. code-block:: c++. forStmt(). Next, we want to specify that a single variable is declared in the first; portion of the loop, so we can extend the matcher to. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl())))). Finally, we can add the condition that the variable is initialized to; zero. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))). It is fairly easy to read and understand the matcher definition (""match; loops whose init portion declares a single variable which is initialized; to the integer literal 0""), but deciding that every piece is necessary; is more difficult. Note that this matcher will not match loops whose; variables are initialized to ``'\0'``, ``0.0``, ``NULL``, or any form of; zero besides the integer 0. The last step is giving the matcher a name and binding the ``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:7721,Modifiability,variab,variable,7721,"; matcher to handle overloaded operators. There are AST matchers to match all the different nodes of the AST,; narrowing matchers to only match AST nodes fulfilling specific criteria,; and traversal matchers to get from one kind of AST node to another. For; a complete list of AST matchers, take a look at the `AST Matcher; References <LibASTMatchersReference.html>`_. All matcher that are nouns describe entities in the AST and can be; bound, so that they can be referred to whenever a match is found. To do; so, simply call the method ``bind`` on these matchers, e.g.:. .. code-block:: c++. variable(hasType(isInteger())).bind(""intvar""). Step 2: Using AST matchers; ==========================. Okay, on to using matchers for real. Let's start by defining a matcher; which will capture all ``for`` statements that define a new variable; initialized to zero. Let's start with matching all ``for`` loops:. .. code-block:: c++. forStmt(). Next, we want to specify that a single variable is declared in the first; portion of the loop, so we can extend the matcher to. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl())))). Finally, we can add the condition that the variable is initialized to; zero. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))). It is fairly easy to read and understand the matcher definition (""match; loops whose init portion declares a single variable which is initialized; to the integer literal 0""), but deciding that every piece is necessary; is more difficult. Note that this matcher will not match loops whose; variables are initialized to ``'\0'``, ``0.0``, ``NULL``, or any form of; zero besides the integer 0. The last step is giving the matcher a name and binding the ``ForStmt``; as we will want to do something with it:. .. code-block:: c++. StatementMatcher LoopMatcher =; forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0))))))))",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:7787,Modifiability,extend,extend,7787,"; matcher to handle overloaded operators. There are AST matchers to match all the different nodes of the AST,; narrowing matchers to only match AST nodes fulfilling specific criteria,; and traversal matchers to get from one kind of AST node to another. For; a complete list of AST matchers, take a look at the `AST Matcher; References <LibASTMatchersReference.html>`_. All matcher that are nouns describe entities in the AST and can be; bound, so that they can be referred to whenever a match is found. To do; so, simply call the method ``bind`` on these matchers, e.g.:. .. code-block:: c++. variable(hasType(isInteger())).bind(""intvar""). Step 2: Using AST matchers; ==========================. Okay, on to using matchers for real. Let's start by defining a matcher; which will capture all ``for`` statements that define a new variable; initialized to zero. Let's start with matching all ``for`` loops:. .. code-block:: c++. forStmt(). Next, we want to specify that a single variable is declared in the first; portion of the loop, so we can extend the matcher to. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl())))). Finally, we can add the condition that the variable is initialized to; zero. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))). It is fairly easy to read and understand the matcher definition (""match; loops whose init portion declares a single variable which is initialized; to the integer literal 0""), but deciding that every piece is necessary; is more difficult. Note that this matcher will not match loops whose; variables are initialized to ``'\0'``, ``0.0``, ``NULL``, or any form of; zero besides the integer 0. The last step is giving the matcher a name and binding the ``ForStmt``; as we will want to do something with it:. .. code-block:: c++. StatementMatcher LoopMatcher =; forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0))))))))",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:7932,Modifiability,variab,variable,7932,"a,; and traversal matchers to get from one kind of AST node to another. For; a complete list of AST matchers, take a look at the `AST Matcher; References <LibASTMatchersReference.html>`_. All matcher that are nouns describe entities in the AST and can be; bound, so that they can be referred to whenever a match is found. To do; so, simply call the method ``bind`` on these matchers, e.g.:. .. code-block:: c++. variable(hasType(isInteger())).bind(""intvar""). Step 2: Using AST matchers; ==========================. Okay, on to using matchers for real. Let's start by defining a matcher; which will capture all ``for`` statements that define a new variable; initialized to zero. Let's start with matching all ``for`` loops:. .. code-block:: c++. forStmt(). Next, we want to specify that a single variable is declared in the first; portion of the loop, so we can extend the matcher to. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl())))). Finally, we can add the condition that the variable is initialized to; zero. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))). It is fairly easy to read and understand the matcher definition (""match; loops whose init portion declares a single variable which is initialized; to the integer literal 0""), but deciding that every piece is necessary; is more difficult. Note that this matcher will not match loops whose; variables are initialized to ``'\0'``, ``0.0``, ``NULL``, or any form of; zero besides the integer 0. The last step is giving the matcher a name and binding the ``ForStmt``; as we will want to do something with it:. .. code-block:: c++. StatementMatcher LoopMatcher =; forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))).bind(""forLoop"");. Once you have defined your matchers, you will need to add a little more; scaffolding in order to run them. Matchers are paired with a; ``MatchCallback`` and regist",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:8204,Modifiability,variab,variable,8204,"be referred to whenever a match is found. To do; so, simply call the method ``bind`` on these matchers, e.g.:. .. code-block:: c++. variable(hasType(isInteger())).bind(""intvar""). Step 2: Using AST matchers; ==========================. Okay, on to using matchers for real. Let's start by defining a matcher; which will capture all ``for`` statements that define a new variable; initialized to zero. Let's start with matching all ``for`` loops:. .. code-block:: c++. forStmt(). Next, we want to specify that a single variable is declared in the first; portion of the loop, so we can extend the matcher to. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl())))). Finally, we can add the condition that the variable is initialized to; zero. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))). It is fairly easy to read and understand the matcher definition (""match; loops whose init portion declares a single variable which is initialized; to the integer literal 0""), but deciding that every piece is necessary; is more difficult. Note that this matcher will not match loops whose; variables are initialized to ``'\0'``, ``0.0``, ``NULL``, or any form of; zero besides the integer 0. The last step is giving the matcher a name and binding the ``ForStmt``; as we will want to do something with it:. .. code-block:: c++. StatementMatcher LoopMatcher =; forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))).bind(""forLoop"");. Once you have defined your matchers, you will need to add a little more; scaffolding in order to run them. Matchers are paired with a; ``MatchCallback`` and registered with a ``MatchFinder`` object, then run; from a ``ClangTool``. More code!. Add the following to ``LoopConvert.cpp``:. .. code-block:: c++. #include ""clang/ASTMatchers/ASTMatchers.h""; #include ""clang/ASTMatchers/ASTMatchFinder.h"". using namespace clang;; using namespace clan",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:8377,Modifiability,variab,variables,8377,"d(""intvar""). Step 2: Using AST matchers; ==========================. Okay, on to using matchers for real. Let's start by defining a matcher; which will capture all ``for`` statements that define a new variable; initialized to zero. Let's start with matching all ``for`` loops:. .. code-block:: c++. forStmt(). Next, we want to specify that a single variable is declared in the first; portion of the loop, so we can extend the matcher to. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl())))). Finally, we can add the condition that the variable is initialized to; zero. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))). It is fairly easy to read and understand the matcher definition (""match; loops whose init portion declares a single variable which is initialized; to the integer literal 0""), but deciding that every piece is necessary; is more difficult. Note that this matcher will not match loops whose; variables are initialized to ``'\0'``, ``0.0``, ``NULL``, or any form of; zero besides the integer 0. The last step is giving the matcher a name and binding the ``ForStmt``; as we will want to do something with it:. .. code-block:: c++. StatementMatcher LoopMatcher =; forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))).bind(""forLoop"");. Once you have defined your matchers, you will need to add a little more; scaffolding in order to run them. Matchers are paired with a; ``MatchCallback`` and registered with a ``MatchFinder`` object, then run; from a ``ClangTool``. More code!. Add the following to ``LoopConvert.cpp``:. .. code-block:: c++. #include ""clang/ASTMatchers/ASTMatchers.h""; #include ""clang/ASTMatchers/ASTMatchFinder.h"". using namespace clang;; using namespace clang::ast_matchers;. StatementMatcher LoopMatcher =; forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))).bind(""forLoop"");.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:11186,Modifiability,variab,variable,11186,"ow, you should be able to recompile and run the code to discover for; loops. Create a new file with a few examples, and test out our new; handiwork:. .. code-block:: console. cd ~/clang-llvm/build/; ninja loop-convert; vim ~/test-files/simple-loops.cc; bin/loop-convert ~/test-files/simple-loops.cc. Step 3.5: More Complicated Matchers; ===================================. Our simple matcher is capable of discovering for loops, but we would; still need to filter out many more ourselves. We can do a good portion; of the remaining work with some cleverly chosen matchers, but first we; need to decide exactly which properties we want to allow. How can we characterize for loops over arrays which would be eligible; for translation to range-based syntax? Range based loops over arrays of; size ``N`` that:. - start at index ``0``; - iterate consecutively; - end at index ``N-1``. We already check for (1), so all we need to add is a check to the loop's; condition to ensure that the loop's index variable is compared against; ``N`` and another check to ensure that the increment step just; increments this same variable. The matcher for (2) is straightforward:; require a pre- or post-increment of the same variable declared in the; init portion. Unfortunately, such a matcher is impossible to write. Matchers contain; no logic for comparing two arbitrary AST nodes and determining whether; or not they are equal, so the best we can do is matching more than we; would like to allow, and punting extra comparisons to the callback. In any case, we can start building this sub-matcher. We can require that; the increment step be a unary increment like this:. .. code-block:: c++. hasIncrement(unaryOperator(hasOperatorName(""++""))). Specifying what is incremented introduces another quirk of Clang's AST:; Usages of variables are represented as ``DeclRefExpr``'s (""declaration; reference expressions"") because they are expressions which refer to; variable declarations. To find a ``unaryOperator`` that r",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:11301,Modifiability,variab,variable,11301,"ow, you should be able to recompile and run the code to discover for; loops. Create a new file with a few examples, and test out our new; handiwork:. .. code-block:: console. cd ~/clang-llvm/build/; ninja loop-convert; vim ~/test-files/simple-loops.cc; bin/loop-convert ~/test-files/simple-loops.cc. Step 3.5: More Complicated Matchers; ===================================. Our simple matcher is capable of discovering for loops, but we would; still need to filter out many more ourselves. We can do a good portion; of the remaining work with some cleverly chosen matchers, but first we; need to decide exactly which properties we want to allow. How can we characterize for loops over arrays which would be eligible; for translation to range-based syntax? Range based loops over arrays of; size ``N`` that:. - start at index ``0``; - iterate consecutively; - end at index ``N-1``. We already check for (1), so all we need to add is a check to the loop's; condition to ensure that the loop's index variable is compared against; ``N`` and another check to ensure that the increment step just; increments this same variable. The matcher for (2) is straightforward:; require a pre- or post-increment of the same variable declared in the; init portion. Unfortunately, such a matcher is impossible to write. Matchers contain; no logic for comparing two arbitrary AST nodes and determining whether; or not they are equal, so the best we can do is matching more than we; would like to allow, and punting extra comparisons to the callback. In any case, we can start building this sub-matcher. We can require that; the increment step be a unary increment like this:. .. code-block:: c++. hasIncrement(unaryOperator(hasOperatorName(""++""))). Specifying what is incremented introduces another quirk of Clang's AST:; Usages of variables are represented as ``DeclRefExpr``'s (""declaration; reference expressions"") because they are expressions which refer to; variable declarations. To find a ``unaryOperator`` that r",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:11397,Modifiability,variab,variable,11397,"g-llvm/build/; ninja loop-convert; vim ~/test-files/simple-loops.cc; bin/loop-convert ~/test-files/simple-loops.cc. Step 3.5: More Complicated Matchers; ===================================. Our simple matcher is capable of discovering for loops, but we would; still need to filter out many more ourselves. We can do a good portion; of the remaining work with some cleverly chosen matchers, but first we; need to decide exactly which properties we want to allow. How can we characterize for loops over arrays which would be eligible; for translation to range-based syntax? Range based loops over arrays of; size ``N`` that:. - start at index ``0``; - iterate consecutively; - end at index ``N-1``. We already check for (1), so all we need to add is a check to the loop's; condition to ensure that the loop's index variable is compared against; ``N`` and another check to ensure that the increment step just; increments this same variable. The matcher for (2) is straightforward:; require a pre- or post-increment of the same variable declared in the; init portion. Unfortunately, such a matcher is impossible to write. Matchers contain; no logic for comparing two arbitrary AST nodes and determining whether; or not they are equal, so the best we can do is matching more than we; would like to allow, and punting extra comparisons to the callback. In any case, we can start building this sub-matcher. We can require that; the increment step be a unary increment like this:. .. code-block:: c++. hasIncrement(unaryOperator(hasOperatorName(""++""))). Specifying what is incremented introduces another quirk of Clang's AST:; Usages of variables are represented as ``DeclRefExpr``'s (""declaration; reference expressions"") because they are expressions which refer to; variable declarations. To find a ``unaryOperator`` that refers to a; specific declaration, we can simply add a second condition to it:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr())",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:12002,Modifiability,variab,variables,12002,"cutively; - end at index ``N-1``. We already check for (1), so all we need to add is a check to the loop's; condition to ensure that the loop's index variable is compared against; ``N`` and another check to ensure that the increment step just; increments this same variable. The matcher for (2) is straightforward:; require a pre- or post-increment of the same variable declared in the; init portion. Unfortunately, such a matcher is impossible to write. Matchers contain; no logic for comparing two arbitrary AST nodes and determining whether; or not they are equal, so the best we can do is matching more than we; would like to allow, and punting extra comparisons to the callback. In any case, we can start building this sub-matcher. We can require that; the increment step be a unary increment like this:. .. code-block:: c++. hasIncrement(unaryOperator(hasOperatorName(""++""))). Specifying what is incremented introduces another quirk of Clang's AST:; Usages of variables are represented as ``DeclRefExpr``'s (""declaration; reference expressions"") because they are expressions which refer to; variable declarations. To find a ``unaryOperator`` that refers to a; specific declaration, we can simply add a second condition to it:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr()))). Furthermore, we can restrict our matcher to only match if the; incremented variable is an integer:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(varDecl(hasType(isInteger()))))))). And the last step will be to attach an identifier to this variable, so; that we can retrieve it in the callback:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(; varDecl(hasType(isInteger())).bind(""incrementVariable"")))))). We can add this code to the definition of ``LoopMatcher`` and make sure; that our program, outfitted with the new matcher, only prints o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:12133,Modifiability,variab,variable,12133,"cutively; - end at index ``N-1``. We already check for (1), so all we need to add is a check to the loop's; condition to ensure that the loop's index variable is compared against; ``N`` and another check to ensure that the increment step just; increments this same variable. The matcher for (2) is straightforward:; require a pre- or post-increment of the same variable declared in the; init portion. Unfortunately, such a matcher is impossible to write. Matchers contain; no logic for comparing two arbitrary AST nodes and determining whether; or not they are equal, so the best we can do is matching more than we; would like to allow, and punting extra comparisons to the callback. In any case, we can start building this sub-matcher. We can require that; the increment step be a unary increment like this:. .. code-block:: c++. hasIncrement(unaryOperator(hasOperatorName(""++""))). Specifying what is incremented introduces another quirk of Clang's AST:; Usages of variables are represented as ``DeclRefExpr``'s (""declaration; reference expressions"") because they are expressions which refer to; variable declarations. To find a ``unaryOperator`` that refers to a; specific declaration, we can simply add a second condition to it:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr()))). Furthermore, we can restrict our matcher to only match if the; incremented variable is an integer:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(varDecl(hasType(isInteger()))))))). And the last step will be to attach an identifier to this variable, so; that we can retrieve it in the callback:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(; varDecl(hasType(isInteger())).bind(""incrementVariable"")))))). We can add this code to the definition of ``LoopMatcher`` and make sure; that our program, outfitted with the new matcher, only prints o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:12452,Modifiability,variab,variable,12452,"t portion. Unfortunately, such a matcher is impossible to write. Matchers contain; no logic for comparing two arbitrary AST nodes and determining whether; or not they are equal, so the best we can do is matching more than we; would like to allow, and punting extra comparisons to the callback. In any case, we can start building this sub-matcher. We can require that; the increment step be a unary increment like this:. .. code-block:: c++. hasIncrement(unaryOperator(hasOperatorName(""++""))). Specifying what is incremented introduces another quirk of Clang's AST:; Usages of variables are represented as ``DeclRefExpr``'s (""declaration; reference expressions"") because they are expressions which refer to; variable declarations. To find a ``unaryOperator`` that refers to a; specific declaration, we can simply add a second condition to it:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr()))). Furthermore, we can restrict our matcher to only match if the; incremented variable is an integer:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(varDecl(hasType(isInteger()))))))). And the last step will be to attach an identifier to this variable, so; that we can retrieve it in the callback:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(; varDecl(hasType(isInteger())).bind(""incrementVariable"")))))). We can add this code to the definition of ``LoopMatcher`` and make sure; that our program, outfitted with the new matcher, only prints out loops; that declare a single variable initialized to zero and have an increment; step consisting of a unary increment of some variable. Now, we just need to add a matcher to check if the condition part of the; ``for`` loop compares a variable against the size of the array. There is; only one problem - we don't know which array we're iterating over; without looking at the body of the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:12676,Modifiability,variab,variable,12676,"nd punting extra comparisons to the callback. In any case, we can start building this sub-matcher. We can require that; the increment step be a unary increment like this:. .. code-block:: c++. hasIncrement(unaryOperator(hasOperatorName(""++""))). Specifying what is incremented introduces another quirk of Clang's AST:; Usages of variables are represented as ``DeclRefExpr``'s (""declaration; reference expressions"") because they are expressions which refer to; variable declarations. To find a ``unaryOperator`` that refers to a; specific declaration, we can simply add a second condition to it:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr()))). Furthermore, we can restrict our matcher to only match if the; incremented variable is an integer:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(varDecl(hasType(isInteger()))))))). And the last step will be to attach an identifier to this variable, so; that we can retrieve it in the callback:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(; varDecl(hasType(isInteger())).bind(""incrementVariable"")))))). We can add this code to the definition of ``LoopMatcher`` and make sure; that our program, outfitted with the new matcher, only prints out loops; that declare a single variable initialized to zero and have an increment; step consisting of a unary increment of some variable. Now, we just need to add a matcher to check if the condition part of the; ``for`` loop compares a variable against the size of the array. There is; only one problem - we don't know which array we're iterating over; without looking at the body of the loop! We are again restricted to; approximating the result we want with matchers, filling in the details; in the callback. So we start with:. .. code-block:: c++. hasCondition(binaryOperator(hasOperatorName(""<""))). It makes sense to ensure that the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:13069,Modifiability,variab,variable,13069,"RefExpr``'s (""declaration; reference expressions"") because they are expressions which refer to; variable declarations. To find a ``unaryOperator`` that refers to a; specific declaration, we can simply add a second condition to it:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr()))). Furthermore, we can restrict our matcher to only match if the; incremented variable is an integer:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(varDecl(hasType(isInteger()))))))). And the last step will be to attach an identifier to this variable, so; that we can retrieve it in the callback:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(; varDecl(hasType(isInteger())).bind(""incrementVariable"")))))). We can add this code to the definition of ``LoopMatcher`` and make sure; that our program, outfitted with the new matcher, only prints out loops; that declare a single variable initialized to zero and have an increment; step consisting of a unary increment of some variable. Now, we just need to add a matcher to check if the condition part of the; ``for`` loop compares a variable against the size of the array. There is; only one problem - we don't know which array we're iterating over; without looking at the body of the loop! We are again restricted to; approximating the result we want with matchers, filling in the details; in the callback. So we start with:. .. code-block:: c++. hasCondition(binaryOperator(hasOperatorName(""<""))). It makes sense to ensure that the left-hand side is a reference to a; variable, and that the right-hand side has integer type. .. code-block:: c++. hasCondition(binaryOperator(; hasOperatorName(""<""),; hasLHS(declRefExpr(to(varDecl(hasType(isInteger()))))),; hasRHS(expr(hasType(isInteger()))))). Why? Because it doesn't work. Of the three loops provided in; ``test-files/simple.cpp``, zero of them",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:13166,Modifiability,variab,variable,13166,"RefExpr``'s (""declaration; reference expressions"") because they are expressions which refer to; variable declarations. To find a ``unaryOperator`` that refers to a; specific declaration, we can simply add a second condition to it:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr()))). Furthermore, we can restrict our matcher to only match if the; incremented variable is an integer:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(varDecl(hasType(isInteger()))))))). And the last step will be to attach an identifier to this variable, so; that we can retrieve it in the callback:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(; varDecl(hasType(isInteger())).bind(""incrementVariable"")))))). We can add this code to the definition of ``LoopMatcher`` and make sure; that our program, outfitted with the new matcher, only prints out loops; that declare a single variable initialized to zero and have an increment; step consisting of a unary increment of some variable. Now, we just need to add a matcher to check if the condition part of the; ``for`` loop compares a variable against the size of the array. There is; only one problem - we don't know which array we're iterating over; without looking at the body of the loop! We are again restricted to; approximating the result we want with matchers, filling in the details; in the callback. So we start with:. .. code-block:: c++. hasCondition(binaryOperator(hasOperatorName(""<""))). It makes sense to ensure that the left-hand side is a reference to a; variable, and that the right-hand side has integer type. .. code-block:: c++. hasCondition(binaryOperator(; hasOperatorName(""<""),; hasLHS(declRefExpr(to(varDecl(hasType(isInteger()))))),; hasRHS(expr(hasType(isInteger()))))). Why? Because it doesn't work. Of the three loops provided in; ``test-files/simple.cpp``, zero of them",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:13274,Modifiability,variab,variable,13274,"second condition to it:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr()))). Furthermore, we can restrict our matcher to only match if the; incremented variable is an integer:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(varDecl(hasType(isInteger()))))))). And the last step will be to attach an identifier to this variable, so; that we can retrieve it in the callback:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(; varDecl(hasType(isInteger())).bind(""incrementVariable"")))))). We can add this code to the definition of ``LoopMatcher`` and make sure; that our program, outfitted with the new matcher, only prints out loops; that declare a single variable initialized to zero and have an increment; step consisting of a unary increment of some variable. Now, we just need to add a matcher to check if the condition part of the; ``for`` loop compares a variable against the size of the array. There is; only one problem - we don't know which array we're iterating over; without looking at the body of the loop! We are again restricted to; approximating the result we want with matchers, filling in the details; in the callback. So we start with:. .. code-block:: c++. hasCondition(binaryOperator(hasOperatorName(""<""))). It makes sense to ensure that the left-hand side is a reference to a; variable, and that the right-hand side has integer type. .. code-block:: c++. hasCondition(binaryOperator(; hasOperatorName(""<""),; hasLHS(declRefExpr(to(varDecl(hasType(isInteger()))))),; hasRHS(expr(hasType(isInteger()))))). Why? Because it doesn't work. Of the three loops provided in; ``test-files/simple.cpp``, zero of them have a matching condition. A; quick look at the AST dump of the first for loop, produced by the; previous iteration of loop-convert, shows us the answer:. ::. (ForStmt 0x173b240; (DeclStmt 0x173afc8; 0x173",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
