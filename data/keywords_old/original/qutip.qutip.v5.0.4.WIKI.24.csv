id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:42320,Deployability,update,updated,42320,"eeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm : float; fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time : float; Time spent computing the pulse optimisation so far; (in seconds of elapsed time); """"""; # Note there is some duplication here with Optimizer attributes; # this exists solely to be copied into the summary dump; min_col_width = 11; summary_property_names = (; ""idx"", ""iter_num"", ""fid_func_call_num"", ""grad_func_call_num"",; ""fid_err"", ""grad_norm"", ""wall_time""; ). summary_property_fmt_type = (; 'd', 'd', 'd', 'd',; 'g', 'g', 'g'; ). summary_property_fmt_prec = (; 0, 0, 0, 0,; 4, 4, 2; ). def __init__(self):; self.reset(). def reset(self):; qtrldump.DumpSummaryItem.reset(self); self.iter_num = None; self.fid_func_call_num = None; self.grad_func_call_num = None; self.fid_err = None; self.grad_norm = None; self.wall_time = 0.0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:9421,Energy Efficiency,reduce,reduce,9421,"the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Not",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:3913,Integrability,wrap,wrapper,3913," to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import functools; import numpy as np; import timeit; import warnings; from packaging.version import parse as _parse_version; import scipy; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import quti",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:4205,Integrability,wrap,wrappers,4205,"ar from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import functools; import numpy as np; import timeit; import warnings; from packaging.version import parse as _parse_version; import scipy; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. # Older versions of SciPy use the method numpy.ndarray.tostring(), which has; # been deprecated since Numpy 1.19 in favour of the identical-in-all-but-name; # tobytes() method. This is simply ",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:5526,Integrability,wrap,wraps,5526,"t parse as _parse_version; import scipy; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. # Older versions of SciPy use the method numpy.ndarray.tostring(), which has; # been deprecated since Numpy 1.19 in favour of the identical-in-all-but-name; # tobytes() method. This is simply a deprecated call in SciPy, there's nothing; # we or our users can do about it, and the function shouldn't actually be; # removed from Numpy until at least 1.22, by which point we'll have been able; # to drop support for SciPy 1.4.; if _parse_version(scipy.__version__) < _parse_version(""1.5""):; @functools.wraps(spopt.fmin_l_bfgs_b); def fmin_l_bfgs_b(*args, **kwargs):; with warnings.catch_warnings():; message = r""tostring\(\) is deprecated\. Use tobytes\(\) instead\.""; warnings.filterwarnings(""ignore"", message=message,; category=DeprecationWarning); return spopt.fmin_l_bfgs_b(*args, **kwargs); else:; fmin_l_bfgs_b = spopt.fmin_l_bfgs_b. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. - ``OptimConfig`` instance - various configuration options; - ``Dynamics`` instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : in",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:5624,Integrability,message,message,5624,"ns; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. # Older versions of SciPy use the method numpy.ndarray.tostring(), which has; # been deprecated since Numpy 1.19 in favour of the identical-in-all-but-name; # tobytes() method. This is simply a deprecated call in SciPy, there's nothing; # we or our users can do about it, and the function shouldn't actually be; # removed from Numpy until at least 1.22, by which point we'll have been able; # to drop support for SciPy 1.4.; if _parse_version(scipy.__version__) < _parse_version(""1.5""):; @functools.wraps(spopt.fmin_l_bfgs_b); def fmin_l_bfgs_b(*args, **kwargs):; with warnings.catch_warnings():; message = r""tostring\(\) is deprecated\. Use tobytes\(\) instead\.""; warnings.filterwarnings(""ignore"", message=message,; category=DeprecationWarning); return spopt.fmin_l_bfgs_b(*args, **kwargs); else:; fmin_l_bfgs_b = spopt.fmin_l_bfgs_b. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. - ``OptimConfig`` instance - various configuration options; - ``Dynamics`` instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger. Options are attributes of; qutip.logging_utils, in de",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:5727,Integrability,message,message,5727," # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. # Older versions of SciPy use the method numpy.ndarray.tostring(), which has; # been deprecated since Numpy 1.19 in favour of the identical-in-all-but-name; # tobytes() method. This is simply a deprecated call in SciPy, there's nothing; # we or our users can do about it, and the function shouldn't actually be; # removed from Numpy until at least 1.22, by which point we'll have been able; # to drop support for SciPy 1.4.; if _parse_version(scipy.__version__) < _parse_version(""1.5""):; @functools.wraps(spopt.fmin_l_bfgs_b); def fmin_l_bfgs_b(*args, **kwargs):; with warnings.catch_warnings():; message = r""tostring\(\) is deprecated\. Use tobytes\(\) instead\.""; warnings.filterwarnings(""ignore"", message=message,; category=DeprecationWarning); return spopt.fmin_l_bfgs_b(*args, **kwargs); else:; fmin_l_bfgs_b = spopt.fmin_l_bfgs_b. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. - ``OptimConfig`` instance - various configuration options; - ``Dynamics`` instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:5735,Integrability,message,message,5735," # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. # Older versions of SciPy use the method numpy.ndarray.tostring(), which has; # been deprecated since Numpy 1.19 in favour of the identical-in-all-but-name; # tobytes() method. This is simply a deprecated call in SciPy, there's nothing; # we or our users can do about it, and the function shouldn't actually be; # removed from Numpy until at least 1.22, by which point we'll have been able; # to drop support for SciPy 1.4.; if _parse_version(scipy.__version__) < _parse_version(""1.5""):; @functools.wraps(spopt.fmin_l_bfgs_b); def fmin_l_bfgs_b(*args, **kwargs):; with warnings.catch_warnings():; message = r""tostring\(\) is deprecated\. Use tobytes\(\) instead\.""; warnings.filterwarnings(""ignore"", message=message,; category=DeprecationWarning); return spopt.fmin_l_bfgs_b(*args, **kwargs); else:; fmin_l_bfgs_b = spopt.fmin_l_bfgs_b. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. - ``OptimConfig`` instance - various configuration options; - ``Dynamics`` instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:7416,Integrability,message,message,7416,"``Dynamics`` instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the pulse optim algorithm ``alg``. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the con",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:17970,Integrability,wrap,wrapper,17970,"instance(params, dict):; self.method_params = params; unused_params = {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult obj",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:20083,Integrability,message,message,20083,"als = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the functi",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:27129,Integrability,wrap,wrapper,27129,"d_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimizer.reset(self); self.id_text = 'BFGS'. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self.",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:30915,Integrability,wrap,wrapper,30915,"ard compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self.",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:37335,Integrability,wrap,wrapper,37335,"misation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1]_, [2]_.; It uses the ``scipy.optimize.fmin`` function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB. References; ----------; .. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011).; .. [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; me",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:37909,Integrability,wrap,wrapper,37909,"+ p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1]_, [2]_.; It uses the ``scipy.optimize.fmin`` function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB. References; ----------; .. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011).; .. [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_v",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:2707,Modifiability,variab,variables,2707," LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the Hessian approxim",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:3862,Modifiability,variab,variables,3862," to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import functools; import numpy as np; import timeit; import warnings; from packaging.version import parse as _parse_version; import scipy; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import quti",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:6372,Modifiability,config,configuration,6372,"ble; # to drop support for SciPy 1.4.; if _parse_version(scipy.__version__) < _parse_version(""1.5""):; @functools.wraps(spopt.fmin_l_bfgs_b); def fmin_l_bfgs_b(*args, **kwargs):; with warnings.catch_warnings():; message = r""tostring\(\) is deprecated\. Use tobytes\(\) instead\.""; warnings.filterwarnings(""ignore"", message=message,; category=DeprecationWarning); return spopt.fmin_l_bfgs_b(*args, **kwargs); else:; fmin_l_bfgs_b = spopt.fmin_l_bfgs_b. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. - ``OptimConfig`` instance - various configuration options; - ``Dynamics`` instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the pulse optim algorithm ``alg``. disp_conv_msg : bool; Set true to display a convergenc",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:8967,Modifiability,config,config,8967,"lled; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be s",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:9006,Modifiability,config,configuration,9006,"lled; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be s",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:10454,Modifiability,config,config,10454,"Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, ",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:10508,Modifiability,config,config,10508,"p : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_uboun",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:10517,Modifiability,config,config,10517,"p : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_uboun",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:10620,Modifiability,config,config,10620,"g the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @l",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:11282,Modifiability,config,config,11282," setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, ke",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:11343,Modifiability,config,config,11343,"f the most recent iteration.; Note this is only set if dummping is on; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of da",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:11375,Modifiability,config,config,11375,"teration.; Note this is only set if dummping is on; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:11418,Modifiability,config,config,11418,"g is on; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation. - NONE : No",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:11453,Modifiability,config,config,11453,"rams=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation. - NONE : No processing data dumped (Default); - SUMMARY : ",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:11485,Modifiability,config,config,11485,"ynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation. - NONE : No processing data dumped (Default); - SUMMARY : A summary at each it",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:11528,Modifiability,config,config,11528,"arams = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation. - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:14017,Modifiability,config,configuration,14017,".upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.full_evo.copy(); result.time = self.dynamics.time.copy(); result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping ",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:17422,Modifiability,config,config,17422,"radient_norm; if not 'disp' in mo:; mo['disp'] = self.disp_conv_msg. return mo. [docs] def apply_method_params(self, params=None):; """"""; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function; """"""; if not params:; params = self.method_params. if isinstance(params, dict):; self.method_params = params; unused_params = {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The functio",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:19123,Modifiability,config,config,19123,"_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in t",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:20720,Modifiability,variab,variable,20720,"d)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the s",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:20995,Modifiability,variab,variable,20995,"func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:21606,Modifiability,variab,variable,21606,"t, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(e",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:22830,Modifiability,variab,variables,22830,"hey have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].c",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:22984,Modifiability,variab,variables,22984,"1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that r",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:23024,Modifiability,variab,variable,23024,"unc_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:23923,Modifiability,config,config,23923,"tion algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.w",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:29178,Modifiability,variab,variable,29178,"grad, invHess, nFCalls, nGCalls, warn = \; spopt.fmin_bfgs(self.fid_err_func_wrapper,; self.optim_var_vals,; fprime=fprime,; # approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; s",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:29761,Modifiability,config,configuration,29761,"ion_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisa",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:29890,Modifiability,config,config,29890,"efault_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Esse",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:29951,Modifiability,config,config,29951,"ime). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function;",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:29988,Modifiability,config,config,29988,"docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a war",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:30041,Modifiability,config,config,30041,"ts the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BF",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:30081,Modifiability,config,config,30081,"ithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; ",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:30118,Modifiability,config,config,30118,"------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy d",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:30180,Modifiability,config,config,30180,"ble metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the ",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:31568,Modifiability,config,config,31568,"algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self._create_result(). if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if 'accuracy_factor' in self.method_options:; factr = self.method_options['accuracy_factor']; elif 'ftol' in self.method_options:; factr = self.method_options['ftol']; elif hasattr(term_conds, 'accuracy_factor'):; factr = term_conds.accuracy_factor; else:; factr = 1e7. if 'max_metric_corr' in self.method_options:; m = self.method_options['max_metric_corr']; elif 'maxcor' in self.method_options:; m = self.method_options['maxcor']; elif hasattr(self, 'max_metric_corr'):; m = self.max_metric_corr; else:; m = 10. if self.log_level <= logging.INFO:; msg = (""Op",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:34416,Modifiability,config,configuration,34416,"elity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.abc.Iterable):; pulse_gen_valid = False; err_msg = ""pulse_generator is not iterable"". elif len(self.pulse_generator) != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generators {} does not equal ""; ""the number of controls {}"".format(; len(self.pulse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:35886,Modifiability,variab,variable,35886,") != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generators {} does not equal ""; ""the number of controls {}"".format(; len(self.pulse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:36082,Modifiability,extend,extend,36082,"lse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:36233,Modifiability,variab,variable,36233,".PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Op",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:38851,Modifiability,config,config,38851,"None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). #print(""Initial values:\n{}"".format(self.optim_var_vals)); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. result = self._create_result(). if self.log_level <= logging.INFO:; logger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:16,Performance,optimiz,optimizer,16,". qutip.control.optimizer — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISE",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:299,Performance,optimiz,optimizer,299,". qutip.control.optimizer — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISE",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:340,Performance,optimiz,optimizer,340,". qutip.control.optimizer — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISE",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:3232,Performance,optimiz,optimize,3232,"ity; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and it",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:3814,Performance,perform,performs,3814," to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import functools; import numpy as np; import timeit; import warnings; from packaging.version import parse as _parse_version; import scipy; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import quti",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:4093,Performance,optimiz,optimize,4093," a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import functools; import numpy as np; import timeit; import warnings; from packaging.version import parse as _parse_version; import scipy; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. # Older versions of SciPy use the method numpy.ndarray.tostring(), whic",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:4586,Performance,optimiz,optimize,4586,"imizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import functools; import numpy as np; import timeit; import warnings; from packaging.version import parse as _parse_version; import scipy; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. # Older versions of SciPy use the method numpy.ndarray.tostring(), which has; # been deprecated since Numpy 1.19 in favour of the identical-in-all-but-name; # tobytes() method. This is simply a deprecated call in SciPy, there's nothing; # we or our users can do about it, and the function shouldn't actually be; # removed from Numpy until at least 1.22, by which point we'll have been able; # to drop support for SciPy 1.4.; if _parse_version(scipy.__version__) < _parse_version(""1.5""):; @functools.wraps(spopt.fmin_l_bfgs_b); def fmin_l_bfgs_b(*args, **kwargs):; with warnings.catch_warnings():",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:7436,Performance,optimiz,optimize,7436,"ics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the pulse optim algorithm ``alg``. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value appl",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:7502,Performance,optimiz,optimize,7502,"----------; log_level : integer; level of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the pulse optim algorithm ``alg``. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds ",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:9366,Performance,perform,performance,9366,"the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Not",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:13766,Performance,optimiz,optimizer,13766,"lf.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.full_evo.copy(); result.time = self.dynamics.time.copy(); result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_c",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:15427,Performance,optimiz,optimize,15427,"check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_options attribute may already contain items.; These values will NOT be overridden; """"""; tc = self.termination_conditions; if self.method_options is None:; self.method_options = {}; mo = self.method_options. if 'max_metric_corr' in mo and not 'maxcor' in mo:; mo['maxcor'] = mo['max_metric_corr']; elif hasattr(self, 'max_metric_corr') and not 'maxcor' in mo:; mo['maxcor'] = self.max_metric_corr; if 'accuracy_factor' in mo and not 'ftol' in mo:; mo['ftol'] = mo['accuracy_factor']; elif hasattr(tc, 'accuracy_factor') and not 'ftol' in mo:; mo['ftol'] = tc.accuracy_factor; if tc.max_iterations > 0 and not 'maxiter' in mo:; mo['maxiter'] = tc.max_iterations; if tc.max_fid_func_calls > 0 and not 'maxfev' in mo:; mo['maxfev'] = tc.max_fid_func_calls; if tc.min_gradient_norm > 0 and not 'gtol' in mo:; mo['gtol'] = tc.min_gr",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:16845,Performance,optimiz,optimize,16845,"maxcor' in mo:; mo['maxcor'] = mo['max_metric_corr']; elif hasattr(self, 'max_metric_corr') and not 'maxcor' in mo:; mo['maxcor'] = self.max_metric_corr; if 'accuracy_factor' in mo and not 'ftol' in mo:; mo['ftol'] = mo['accuracy_factor']; elif hasattr(tc, 'accuracy_factor') and not 'ftol' in mo:; mo['ftol'] = tc.accuracy_factor; if tc.max_iterations > 0 and not 'maxiter' in mo:; mo['maxiter'] = tc.max_iterations; if tc.max_fid_func_calls > 0 and not 'maxfev' in mo:; mo['maxfev'] = tc.max_fid_func_calls; if tc.min_gradient_norm > 0 and not 'gtol' in mo:; mo['gtol'] = tc.min_gradient_norm; if not 'disp' in mo:; mo['disp'] = self.disp_conv_msg. return mo. [docs] def apply_method_params(self, params=None):; """"""; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function; """"""; if not params:; params = self.method_params. if isinstance(params, dict):; self.method_params = params; unused_params = {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.app",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:17992,Performance,optimiz,optimize,17992,"= {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for t",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:27152,Performance,optimiz,optimize,27152,"result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimizer.reset(self); self.id_text = 'BFGS'. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self._create_result(); try:; opt",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:29353,Performance,optimiz,optimize,29353,"_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_lev",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:30938,Performance,optimiz,optimize,30938,"ttr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self._create_result(). if self.a",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:33849,Performance,optimiz,optimize,33849,"f.approx_grad,; callback=self.iter_step_callback_func,; bounds=self.bounds, m=m, factr=factr,; pgtol=term_conds.min_gradient_norm,; disp=self.msg_level,; maxfun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.abc.Iterable):; pulse_gen_valid = False",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:37287,Performance,optimiz,optimize,37287," the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1]_, [2]_.; It uses the ``scipy.optimize.fmin`` function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB. References; ----------; .. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011).; .. [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration co",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:37931,Performance,optimiz,optimize,37931,"aram_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1]_, [2]_.; It uses the ``scipy.optimize.fmin`` function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB. References; ----------; .. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011).; .. [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:4706,Testability,log,logging,4706,"here the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import functools; import numpy as np; import timeit; import warnings; from packaging.version import parse as _parse_version; import scipy; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. # Older versions of SciPy use the method numpy.ndarray.tostring(), which has; # been deprecated since Numpy 1.19 in favour of the identical-in-all-but-name; # tobytes() method. This is simply a deprecated call in SciPy, there's nothing; # we or our users can do about it, and the function shouldn't actually be; # removed from Numpy until at least 1.22, by which point we'll have been able; # to drop support for SciPy 1.4.; if _parse_version(scipy.__version__) < _parse_version(""1.5""):; @functools.wraps(spopt.fmin_l_bfgs_b); def fmin_l_bfgs_b(*args, **kwargs):; with warnings.catch_warnings():; message = r""tostring\(\) is deprecated\. Use tobytes\(\) instead\.""; warnings.filterwar",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:4715,Testability,log,logger,4715,"here the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import functools; import numpy as np; import timeit; import warnings; from packaging.version import parse as _parse_version; import scipy; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. # Older versions of SciPy use the method numpy.ndarray.tostring(), which has; # been deprecated since Numpy 1.19 in favour of the identical-in-all-but-name; # tobytes() method. This is simply a deprecated call in SciPy, there's nothing; # we or our users can do about it, and the function shouldn't actually be; # removed from Numpy until at least 1.22, by which point we'll have been able; # to drop support for SciPy 1.4.; if _parse_version(scipy.__version__) < _parse_version(""1.5""):; @functools.wraps(spopt.fmin_l_bfgs_b); def fmin_l_bfgs_b(*args, **kwargs):; with warnings.catch_warnings():; message = r""tostring\(\) is deprecated\. Use tobytes\(\) instead\.""; warnings.filterwar",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:4724,Testability,log,logging,4724,"here the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import functools; import numpy as np; import timeit; import warnings; from packaging.version import parse as _parse_version; import scipy; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. # Older versions of SciPy use the method numpy.ndarray.tostring(), which has; # been deprecated since Numpy 1.19 in favour of the identical-in-all-but-name; # tobytes() method. This is simply a deprecated call in SciPy, there's nothing; # we or our users can do about it, and the function shouldn't actually be; # removed from Numpy until at least 1.22, by which point we'll have been able; # to drop support for SciPy 1.4.; if _parse_version(scipy.__version__) < _parse_version(""1.5""):; @functools.wraps(spopt.fmin_l_bfgs_b); def fmin_l_bfgs_b(*args, **kwargs):; with warnings.catch_warnings():; message = r""tostring\(\) is deprecated\. Use tobytes\(\) instead\.""; warnings.filterwar",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:6574,Testability,log,logger,6574,".fmin_l_bfgs_b); def fmin_l_bfgs_b(*args, **kwargs):; with warnings.catch_warnings():; message = r""tostring\(\) is deprecated\. Use tobytes\(\) instead\.""; warnings.filterwarnings(""ignore"", message=message,; category=DeprecationWarning); return spopt.fmin_l_bfgs_b(*args, **kwargs); else:; fmin_l_bfgs_b = spopt.fmin_l_bfgs_b. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. - ``OptimConfig`` instance - various configuration options; - ``Dynamics`` instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the pulse optim algorithm ``alg``. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will ",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:11608,Testability,log,logger,11608,"elf):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation. - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised l",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:11726,Testability,log,logger,11726,"one; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation. - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to ",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:11747,Testability,log,logger,11747,"one; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation. - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to ",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:11774,Testability,log,logger,11774,"on_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation. - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped; """"""; if self.dump is None:; lvl = 'NONE'; e",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:12528,Testability,log,logs,12528,"f.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation. - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; resul",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:12708,Testability,log,logs,12708," and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation. - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:15057,Testability,log,logger,15057," is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_options attribute may already contain items.; These values will NOT be overridden; """"""; tc = self.termination_conditions; if self.method_options is None:; self.method_options = {}; mo = self.method_options. if 'max_metric_corr' in mo and not 'maxcor' in mo:; mo['maxcor'] = mo['max_metric_corr']; elif hasattr(self, 'max_metric_corr') and not 'maxcor' in mo:; mo['maxcor'] = self.max_metric_corr; if 'accuracy_factor' in mo and not 'ftol' in mo:",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:18542,Testability,test,tested,18542,"s):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_gra",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:19596,Testability,log,logging,19596," some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:19758,Testability,log,logger,19758,"ameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of th",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:20237,Testability,log,logger,20237,"e_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamic",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:22076,Testability,log,logging,22076,"s passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed a",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:22092,Testability,log,logger,22092,"optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. H",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:23650,Testability,log,logging,23650,"unc_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; se",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:23666,Testability,log,logger,23666,"errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. ",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:24687,Testability,log,logging,24687,"ient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_re",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:24703,Testability,log,logger,24703,"at(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:27951,Testability,log,logging,27951,"d when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self._create_result(); try:; optim_var_vals, cost, grad, invHess, nFCalls, nGCalls, warn = \; spopt.fmin_bfgs(self.fid_err_func_wrapper,; self.optim_var_vals,; fprime=fprime,; # approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(re",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:28098,Testability,log,logger,28098," iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self._create_result(); try:; optim_var_vals, cost, grad, invHess, nFCalls, nGCalls, warn = \; spopt.fmin_bfgs(self.fid_err_func_wrapper,; self.optim_var_vals,; fprime=fprime,; # approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using t",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:30305,Testability,log,logging,30305,"re used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if th",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:30364,Testability,log,logging,30364,".fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an Opti",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:32550,Testability,log,logging,32550,"dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self._create_result(). if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if 'accuracy_factor' in self.method_options:; factr = self.method_options['accuracy_factor']; elif 'ftol' in self.method_options:; factr = self.method_options['ftol']; elif hasattr(term_conds, 'accuracy_factor'):; factr = term_conds.accuracy_factor; else:; factr = 1e7. if 'max_metric_corr' in self.method_options:; m = self.method_options['max_metric_corr']; elif 'maxcor' in self.method_options:; m = self.method_options['maxcor']; elif hasattr(self, 'max_metric_corr'):; m = self.max_metric_corr; else:; m = 10. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_l_bfgs_b' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg); try:; optim_var_vals, fid, res_dict = fmin_l_bfgs_b(; self.fid_err_func_wrapper, self.optim_var_vals,; fprime=fprime,; approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; bounds=self.bounds, m=m, factr=factr,; pgtol=term_conds.min_gradient_norm,; disp=self.msg_level,; maxfun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTe",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:32701,Testability,log,logger,32701,"r(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self._create_result(). if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if 'accuracy_factor' in self.method_options:; factr = self.method_options['accuracy_factor']; elif 'ftol' in self.method_options:; factr = self.method_options['ftol']; elif hasattr(term_conds, 'accuracy_factor'):; factr = term_conds.accuracy_factor; else:; factr = 1e7. if 'max_metric_corr' in self.method_options:; m = self.method_options['max_metric_corr']; elif 'maxcor' in self.method_options:; m = self.method_options['maxcor']; elif hasattr(self, 'max_metric_corr'):; m = self.max_metric_corr; else:; m = 10. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_l_bfgs_b' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg); try:; optim_var_vals, fid, res_dict = fmin_l_bfgs_b(; self.fid_err_func_wrapper, self.optim_var_vals,; fprime=fprime,; approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; bounds=self.bounds, m=m, factr=factr,; pgtol=term_conds.min_gradient_norm,; disp=self.msg_level,; maxfun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:36543,Testability,log,logging,36543,"h control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1]_, [2]_.; It uses the ``scipy.optimize.fmin`` function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB. References; ----------; .. [1] P",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:36615,Testability,log,logger,36615,"""""""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1]_, [2]_.; It uses the ``scipy.optimize.fmin`` function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB. References; ----------; .. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 19",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:39261,Testability,log,logging,39261," or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). #print(""Initial values:\n{}"".format(self.optim_var_vals)); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. result = self._create_result(). if self.log_level <= logging.INFO:; logger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Func",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:39276,Testability,log,logger,39276," or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). #print(""Initial values:\n{}"".format(self.optim_var_vals)); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. result = self._create_result(). if self.log_level <= logging.INFO:; logger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Function converged (w",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:40024,Testability,log,logger,40024,"efault_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. result = self._create_result(). if self.log_level <= logging.INFO:; logger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Function converged (within tolerance)""; elif warn_flag == 1:; result.termination_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_nu",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:5212,Usability,simpl,simply,5212,"re called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import functools; import numpy as np; import timeit; import warnings; from packaging.version import parse as _parse_version; import scipy; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. # Older versions of SciPy use the method numpy.ndarray.tostring(), which has; # been deprecated since Numpy 1.19 in favour of the identical-in-all-but-name; # tobytes() method. This is simply a deprecated call in SciPy, there's nothing; # we or our users can do about it, and the function shouldn't actually be; # removed from Numpy until at least 1.22, by which point we'll have been able; # to drop support for SciPy 1.4.; if _parse_version(scipy.__version__) < _parse_version(""1.5""):; @functools.wraps(spopt.fmin_l_bfgs_b); def fmin_l_bfgs_b(*args, **kwargs):; with warnings.catch_warnings():; message = r""tostring\(\) is deprecated\. Use tobytes\(\) instead\.""; warnings.filterwarnings(""ignore"", message=message,; category=DeprecationWarning); return spopt.fmin_l_bfgs_b(*args, **kwargs); else:; fmin_l_bfgs_b = spopt.fmin_l_bfgs_b. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All s",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:14915,Usability,clear,clear,14915,"e optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_options attribute may already contain items.; These values will NOT be overridden; """"""; tc = self.termination_conditions; if self.method_options is None:; self.method_options = {}; mo = self.method_options. if 'max_metric_corr' in mo and not 'maxcor' in mo:; mo['maxcor'] = mo['max_metric_corr']; elif hasattr(sel",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimresult.html:2695,Availability,error,error,2695,"OODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tsl",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.6/modules/qutip/control/optimresult.html:2765,Availability,error,error,2765,"OODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tsl",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.6/modules/qutip/control/optimresult.html:2834,Availability,error,error,2834,"# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operat",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.6/modules/qutip/control/optimresult.html:2964,Availability,error,error,2964,"R OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator fro",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.6/modules/qutip/control/optimresult.html:4924,Deployability,update,updated,4924,"ptimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from t=0 to t=T based on the initial amps; ; stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.evo_full_initial = None; self.stats = None; self.optimizer = None. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.6/modules/qutip/control/optimresult.html:4043,Performance,optimiz,optimizer,4043,"True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from t=0 to t=T based on the initial amps; ; stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.evo_full_initial = None; self.stats = None; self.optimizer = None. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read ",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.6/modules/qutip/control/optimresult.html:4718,Performance,optimiz,optimizer,4718,"ptimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from t=0 to t=T based on the initial amps; ; stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.evo_full_initial = None; self.stats = None; self.optimizer = None. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:2860,Availability,error,errors,2860,"NTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' ",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:6269,Availability,error,errors,6269,"he logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX';",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:6715,Availability,error,errors,6715," dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """""";",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:4357,Deployability,configurat,configuration,4357,"ted with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been ",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:7067,Deployability,configurat,configuration,7067,"""""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generat",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:7851,Deployability,configurat,configuration,7851,"e a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generator (H); As part of the calc the the eigen decomposition is required, which; is reused in the propagator gradient calculation; """"""; dyn = self.parent; dyn._ensure_decomp_curr(k). if dyn.oper_dtype == Qobj:. prop = (dyn._dyn_gen_eigenvectors[k]*dyn._prop_eigen[k]*; dyn._get_dyn_gen_eigenvectors_adj(k)); else:; prop = dyn._dyn_gen_eigenvectors[k].dot(; dyn._prop_eigen[k]).dot(; dyn._get_dyn_gen_eigenvectors_adj(k)). return prop. def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot. Returns:; [prop], prop_grad; """"""; dyn = self.parent; dyn._ensure_decomp_curr(k). if compute_prop:; prop = self._compute_propagator(k). if",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:13629,Deployability,update,updated,13629," = la.expm(aug); prop_grad = aug_exp[:dg.shape[0], dg.shape[1]:]; if compute_prop:; prop = aug_exp[:dg.shape[0], :dg.shape[1]]. if compute_prop:; return prop, prop_grad; else:; return prop_grad. [docs]class PropCompFrechet(PropagatorComputer):; """"""; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; :obj:`PropagatorComputer` subclasses that may be more efficient.; """"""; [docs] def reset(self):; PropagatorComputer.reset(self); self.id_text = 'FRECHET'; self.grad_exact = True; self.apply_params(). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot using the expm_frechet method; The propagtor is calculated (almost) for 'free' in this method; and hence it is returned if compute_prop==True; Returns:; [prop], prop_grad; """"""; dyn = self.parent. if dyn.oper_dtype == Qobj:; A = dyn._get_phased_dyn_gen(k).full()*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j).full()*dyn.tau[k]; if compute_prop:; prop_dense, prop_grad_dense = la.expm_frechet(A, E); prop = Qobj(prop_dense, dims=dyn.dyn_dims); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); else:; prop_grad_dense = la.expm_frechet(A, E, compute_expm=False); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); else:; A = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j)*dyn.tau[k]; if compute_prop:; prop, prop_grad = la.expm_frechet(A, E); else:; prop_grad = la.expm_frechet(A, E,; compute_expm=False); if compute_prop:; return prop, prop_grad; else:; return prop_grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:9950,Energy Efficiency,efficient,efficient,9950,"genvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = Qobj(np.multiply(cdg.full()*dyn.tau[k],; dyn._dyn_gen_factormatrix[k]), dims=dyn.dyn_dims); # Return to canonical basis; prop_grad = (dyn._dyn_gen_eigenvectors[k]*cdg*; dyn._get_dyn_gen_eigenvectors_adj(k)); else:; # put control dyn_gen in combined dg diagonal basis; cdg = dyn._get_dyn_gen_eigenvectors_adj(k).dot(; dyn._get_phased_ctrl_dyn_gen(k, j)).dot(; dyn._dyn_gen_eigenvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = np.multiply(cdg*dyn.tau[k], dyn._dyn_gen_factormatrix[k]); # Return to canonical basis; prop_grad = dyn._dyn_gen_eigenvectors[k].dot(cdg).dot(; dyn._get_dyn_gen_eigenvectors_adj(k)). if compute_prop:; return prop, prop_grad; else:; return prop_grad. class PropCompAugMat(PropagatorComputer):; """"""; Augmented Matrix (deprecated - see _Frechet). It should work for all systems, e.g. open, symplectic; There will be other PropagatorComputer subclasses that are more efficient; The _Frechet class should provide exactly the same functionality; more efficiently. Note the propagator gradient calculation using the augmented matrix; is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer; """"""; def reset(self):; PropagatorComputer.reset(self); self.id_text = 'AUG_MAT'; self.grad_exact = True; self.apply_params(). def _get_aug_mat(self, k, j):; """"""; Generate the matrix [[A, E], [0, A]] where; A is the overall dynamics generator; E is the control dynamics generator; for a given timeslot and control; returns this augmented matrix; """"""; dyn = self.parent; dg = dyn._get_phased_dyn_gen(k). if dyn.oper_dtype == Qobj:; A = dg.data*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j).data*dyn.tau[k]; Z = sp.csr_matrix(dg.data.shape); aug = Qobj(sp.vstack([sp.hstack([A, E]), sp.hstack([Z, A])])); else:; A = dg*dyn.tau[k]; E = dyn._get_phased_ctrl",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:10032,Energy Efficiency,efficient,efficiently,10032,"genvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = Qobj(np.multiply(cdg.full()*dyn.tau[k],; dyn._dyn_gen_factormatrix[k]), dims=dyn.dyn_dims); # Return to canonical basis; prop_grad = (dyn._dyn_gen_eigenvectors[k]*cdg*; dyn._get_dyn_gen_eigenvectors_adj(k)); else:; # put control dyn_gen in combined dg diagonal basis; cdg = dyn._get_dyn_gen_eigenvectors_adj(k).dot(; dyn._get_phased_ctrl_dyn_gen(k, j)).dot(; dyn._dyn_gen_eigenvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = np.multiply(cdg*dyn.tau[k], dyn._dyn_gen_factormatrix[k]); # Return to canonical basis; prop_grad = dyn._dyn_gen_eigenvectors[k].dot(cdg).dot(; dyn._get_dyn_gen_eigenvectors_adj(k)). if compute_prop:; return prop, prop_grad; else:; return prop_grad. class PropCompAugMat(PropagatorComputer):; """"""; Augmented Matrix (deprecated - see _Frechet). It should work for all systems, e.g. open, symplectic; There will be other PropagatorComputer subclasses that are more efficient; The _Frechet class should provide exactly the same functionality; more efficiently. Note the propagator gradient calculation using the augmented matrix; is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer; """"""; def reset(self):; PropagatorComputer.reset(self); self.id_text = 'AUG_MAT'; self.grad_exact = True; self.apply_params(). def _get_aug_mat(self, k, j):; """"""; Generate the matrix [[A, E], [0, A]] where; A is the overall dynamics generator; E is the control dynamics generator; for a given timeslot and control; returns this augmented matrix; """"""; dyn = self.parent; dg = dyn._get_phased_dyn_gen(k). if dyn.oper_dtype == Qobj:; A = dg.data*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j).data*dyn.tau[k]; Z = sp.csr_matrix(dg.data.shape); aug = Qobj(sp.vstack([sp.hstack([A, E]), sp.hstack([Z, A])])); else:; A = dg*dyn.tau[k]; E = dyn._get_phased_ctrl",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:12240,Energy Efficiency,efficient,efficient,12240,"imeslot using the exponentiation of the the augmented; matrix.; The propagtor is calculated for 'free' in this method; and hence it is returned if compute_prop==True; Returns:; [prop], prop_grad; """"""; dyn = self.parent; dg = dyn._get_phased_dyn_gen(k); aug = self._get_aug_mat(k, j). if dyn.oper_dtype == Qobj:; aug_exp = aug.expm(); prop_grad = Qobj(aug_exp.data[:dg.shape[0], dg.shape[1]:],; dims=dyn.dyn_dims); if compute_prop:; prop = Qobj(aug_exp.data[:dg.shape[0], :dg.shape[1]],; dims=dyn.dyn_dims); else:; aug_exp = la.expm(aug); prop_grad = aug_exp[:dg.shape[0], dg.shape[1]:]; if compute_prop:; prop = aug_exp[:dg.shape[0], :dg.shape[1]]. if compute_prop:; return prop, prop_grad; else:; return prop_grad. [docs]class PropCompFrechet(PropagatorComputer):; """"""; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; :obj:`PropagatorComputer` subclasses that may be more efficient.; """"""; [docs] def reset(self):; PropagatorComputer.reset(self); self.id_text = 'FRECHET'; self.grad_exact = True; self.apply_params(). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot using the expm_frechet method; The propagtor is calculated (almost) for 'free' in this method; and hence it is returned if compute_prop==True; Returns:; [prop], prop_grad; """"""; dyn = self.parent. if dyn.oper_dtype == Qobj:; A = dyn._get_phased_dyn_gen(k).full()*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j).full()*dyn.tau[k]; if compute_prop:; prop_dense, prop_grad_dense = la.expm_frechet(A, E); prop = Qobj(prop_dense, dims=dyn.dyn_dims); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); else:; prop_grad_dense = la.expm_frechet(A, E, compute_expm=False); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); else:; A = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; E = dyn.",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:2890,Integrability,message,message,2890,"# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken f",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:2978,Integrability,message,message,2978,"# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken f",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:3066,Integrability,message,message,3066,"##########################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:4357,Modifiability,config,configuration,4357,"ted with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been ",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:7067,Modifiability,config,configuration,7067,"""""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generat",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:7851,Modifiability,config,configuration,7851,"e a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generator (H); As part of the calc the the eigen decomposition is required, which; is reused in the propagator gradient calculation; """"""; dyn = self.parent; dyn._ensure_decomp_curr(k). if dyn.oper_dtype == Qobj:. prop = (dyn._dyn_gen_eigenvectors[k]*dyn._prop_eigen[k]*; dyn._get_dyn_gen_eigenvectors_adj(k)); else:; prop = dyn._dyn_gen_eigenvectors[k].dot(; dyn._prop_eigen[k]).dot(; dyn._get_dyn_gen_eigenvectors_adj(k)). return prop. def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot. Returns:; [prop], prop_grad; """"""; dyn = self.parent; dyn._ensure_decomp_curr(k). if compute_prop:; prop = self._compute_propagator(k). if",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:2730,Testability,log,logging,2730,"CES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of m",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:2769,Testability,log,logging,2769,"INESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, ",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:2778,Testability,log,logger,2778,"INESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, ",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:2787,Testability,log,logging,2787,"INESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, ",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:3646,Testability,log,logger,3646," import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instanti",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:3693,Testability,log,logging,3693,"logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exi",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:5033,Testability,log,logger,5033,"RN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsil",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:5151,Testability,log,logger,5151,"gator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:5172,Testability,log,logger,5172,"gator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:5199,Testability,log,logger,5199,"rop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the dire",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:6911,Usability,simpl,simply,6911,"epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""",MatchSource.WIKI,docs/4.6/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:2701,Availability,error,errors,2701,"TUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0. These are the periodic options. SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave. If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied over. """""". if ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:2711,Availability,error,errors,2711,"TUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0. These are the periodic options. SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave. If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied over. """""". if ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:8514,Availability,error,errors,8514," self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None. self.apply_params(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots. if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]. self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None. if not self.ubound is None and not self.lbound is None:; if self.ubound < self.lbound:; raise ValueError(""ubound cannot be less the lbound""). def _apply_bounds_and_offset(self, pulse):; """"""; Ensure that the randomly generated pulse fits within the bounds; (after apply",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:36458,Deployability,update,updated,36458,": float array[num_coeffs]; Frequencies for the basis functions; randomize_freqs : bool; If True (default) the some random offset is applied to the frequencies; """""". [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGenCrab.reset(self); self.freqs = None; self.randomize_freqs = True. [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGenCrab.init_pulse(self). self.init_freqs(). [docs] def init_freqs(self):; """"""; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset; """"""; self.freqs = np.empty(self.num_coeffs); ff = 2*np.pi / self.pulse_time; for i in range(self.num_coeffs):; self.freqs[i] = ff*(i + 1). if self.randomize_freqs:; self.freqs += np.random.random(self.num_coeffs) - 0.5. [docs] def gen_pulse(self, coeffs=None):; """"""; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters; ----------; coeffs : float array[num_coeffs, num_basis_funcs]; The basis coefficient values; If given this overides the default and sets the attribute; of the same name.; """"""; if coeffs:; self.coeffs = coeffs. if not self._pulse_initialised:; self.init_pulse(). pulse = np.zeros(self.num_tslots). for i in range(self.num_coeffs):; phase = self.freqs[i]*self.time; # basis1comp = self.coeffs[i, 0]*np.sin(phase); # basis2comp = self.coeffs[i, 1]*np.cos(phase); # pulse += basis1comp + basis2comp; pulse += self.coeffs[i, 0]*np.sin(phase) + \; self.coeffs[i, 1]*np.cos(phase). if self.guess_pulse_func:; pulse = self.guess_pulse_func(pulse); if self.ramping_pulse is not None:; pulse = self._apply_ramping_pulse(pulse). return self._apply_bounds(pulse). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:30684,Energy Efficiency,efficient,efficient,30684,"on; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs. self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs. if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)). if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs,; self.num_basis_funcs])*self.scaling. [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs. [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats; """"""; return self.coeffs.ravel().tolist(). [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically t",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:30767,Integrability,message,message,30767,"m_coeffs:; self.num_coeffs = num_coeffs. self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs. if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)). if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs,; self.num_basis_funcs])*self.scaling. [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs. [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats; """"""; return self.coeffs.ravel().tolist(). [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is i",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:29224,Modifiability,variab,variables,29224,"ne):; self.parent = dyn; self.num_coeffs = num_coeffs; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.NUM_COEFFS_WARN_LVL = 20; self.DEF_NUM_COEFFS = 4; self._BSC_ALL = 1; self._BSC_GT_MEAN = 2; self._BSC_LT_MEAN = 3. self._uses_time = True; self.time = None; self.num_basis_funcs = 2; self.num_optim_vars = 0; self.coeffs = None; self.randomize_coeffs = True; self._num_coeffs_estimated = False; self.guess_pulse_action = 'MODULATE'; self.guess_pulse = None; self.guess_pulse_func = None; self.apply_params(). [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGen.init_pulse(self); self.init_coeffs(num_coeffs=num_coeffs). if self.guess_pulse is not None:; self.init_guess_pulse(); self._init_bounds(). if self.log_level <= logging.DEBUG and not self._num_coeffs_estimated:; logger.debug(; ""CRAB pulse initialised with {} coefficients per basis ""; ""function, which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)). # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse. [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values. Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs. self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs. if self._num_coeffs_estimated:; if self.log_level <= loggin",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:30325,Modifiability,variab,variables,30325,"ffs, self.num_optim_vars)). # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse. [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values. Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs. self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs. if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)). if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs,; self.num_basis_funcs])*self.scaling. [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, di",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:12655,Safety,avoid,avoid,12655,"scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). min_wavelen : float; Minimum wavelength of any component wave; Set by default to 1/10th of the pulse time; """""". def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.random = True; self._uses_time = True; try:; self.min_wavelen = self.pulse_time / 10.0; except:; self.min_wavelen = 0.1; self.apply_params(). def gen_pulse(self, min_wavelen=None):; """"""; Generate a random pulse based on a Fourier series with a minimum; wavelength; """""". if min_wavelen is not None:; self.min_wavelen = min_wavelen; min_wavelen = self.min_wavelen. if min_wavelen > self.pulse_time:; raise ValueError(""Minimum wavelength cannot be greater than ""; ""the pulse time""); if not self._pulse_initialised:; self.init_pulse(). # use some phase to avoid the first pulse being always 0. sum_wave = np.zeros(self.tau.shape); wavelen = 2.0*self.pulse_time. t = self.time; wl = []; while wavelen > min_wavelen:; wl.append(wavelen); wavelen = wavelen/2.0. num_comp_waves = len(wl); amp_scale = np.sqrt(8)*self.scaling / float(num_comp_waves). for wavelen in wl:; amp = amp_scale*(np.random.rand()*2 - 1); phase_off = np.random.rand()*np.pi/2.0; curr_wave = amp*np.sin(2*np.pi*t/wavelen + phase_off); sum_wave += curr_wave. return self._apply_bounds_and_offset(sum_wave). class PulseGenRndWaves(PulseGen):; """"""; Generates pulses by summing sine waves with random frequencies; amplitudes and phase offset. Attributes; ----------; scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). num_comp_waves : integer; Number of component waves. That is the number of waves that; are summe",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:15051,Safety,avoid,avoid,15051,"elf.num_comp_waves = 20; try:; self.min_wavelen = self.pulse_time / 10.0; except:; self.min_wavelen = 0.1; try:; self.max_wavelen = 2*self.pulse_time; except:; self.max_wavelen = 10.0; self.apply_params(). def gen_pulse(self, num_comp_waves=None,; min_wavelen=None, max_wavelen=None):; """"""; Generate a random pulse by summing sine waves with random freq,; amplitude and phase offset; """""". if num_comp_waves is not None:; self.num_comp_waves = num_comp_waves; if min_wavelen is not None:; self.min_wavelen = min_wavelen; if max_wavelen is not None:; self.max_wavelen = max_wavelen. num_comp_waves = self.num_comp_waves; min_wavelen = self.min_wavelen; max_wavelen = self.max_wavelen. if min_wavelen > self.pulse_time:; raise ValueError(""Minimum wavelength cannot be greater than ""; ""the pulse time""); if max_wavelen <= min_wavelen:; raise ValueError(""Maximum wavelength must be greater than ""; ""the minimum wavelength""). if not self._pulse_initialised:; self.init_pulse(). # use some phase to avoid the first pulse being always 0. sum_wave = np.zeros(self.tau.shape). t = self.time; wl_range = max_wavelen - min_wavelen; amp_scale = np.sqrt(8)*self.scaling / float(num_comp_waves); for n in range(num_comp_waves):; amp = amp_scale*(np.random.rand()*2 - 1); phase_off = np.random.rand()*np.pi/2.0; wavelen = min_wavelen + np.random.rand()*wl_range; curr_wave = amp*np.sin(2*np.pi*t/wavelen + phase_off); sum_wave += curr_wave. return self._apply_bounds_and_offset(sum_wave). class PulseGenRndWalk1(PulseGen):; """"""; Generates pulses by using a random walk algorithm. Attributes; ----------; scaling : float; Used as the range for the starting amplitude; Note must used bounds if values must be restricted.; Also scales the max_d_amp value; (copied from Dynamics.initial_ctrl_scaling if given). max_d_amp : float; Maximum amount amplitude will change between timeslots; Note this is also factored by the scaling attribute; """"""; def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.res",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:31718,Safety,avoid,avoided,31718,"ients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)). if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs,; self.num_basis_funcs])*self.scaling. [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs. [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats; """"""; return self.coeffs.ravel().tolist(). [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the; # main optmisation call sequence; self.set_coeffs(param_vals). def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]). def init_guess_pulse(self):. self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)). def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse. def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse. def _init_bounds(self):; add_guess_pulse_scale = False; if self.l",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:2597,Testability,log,logging,2597,"AL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0. These are the periodic options. SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave. If a Dynamics object is passed in then this is used ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:2606,Testability,log,logger,2606,"AL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0. These are the periodic options. SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave. If a Dynamics object is passed in then this is used ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:2615,Testability,log,logging,2615,"AL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0. These are the periodic options. SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave. If a Dynamics object is passed in then this is used ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:6565,Testability,log,logger,6565,"caling applied to the pulse; (copied from Dynamics.initial_ctrl_scaling if given). offset : float; linear offset applied to the pulse; (copied from Dynamics.initial_ctrl_offset if given). tau : array[num_tslots] of float; Duration of each timeslot; (copied from Dynamics if given). lbound : float; Lower boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is -Inf. ubound : float; Upper boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is Inf. periodic : boolean; True if the pulse generator produces periodic pulses. random : boolean; True if the pulse generator produces random pulses. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; """"""; def __init__(self, dyn=None, params=None):; self.parent = dyn; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset attributes to default values; """"""; if isinstance(self.parent, dynamics.Dynamics):; dyn = self.parent; self.num_tslots = dyn.num_tslots; self.pulse_time = dyn.evo_time; self.scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pul",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:8155,Testability,log,logger,8155,"t, dynamics.Dynamics):; dyn = self.parent; self.num_tslots = dyn.num_tslots; self.pulse_time = dyn.evo_time; self.scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None. self.apply_params(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots. if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]. self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubou",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:8273,Testability,log,logger,8273,"_time; self.scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None. self.apply_params(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots. if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]. self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None. if not self.ubound is None and not self.lbound is None:; if self.ubound < sel",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:8294,Testability,log,logger,8294,"_time; self.scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None. self.apply_params(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots. if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]. self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None. if not self.ubound is None and not self.lbound is None:; if self.ubound < sel",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:8321,Testability,log,logger,8321,"ctrl_offset; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None. self.apply_params(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots. if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]. self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None. if not self.ubound is None and not self.lbound is None:; if self.ubound < self.lbound:; raise ValueError(""ubound cannot be less the lbound""). def _appl",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:29046,Testability,log,logging,29046,"lues; when initialised, otherwise they will all be equal to self.scaling; """"""; def __init__(self, dyn=None, num_coeffs=None, params=None):; self.parent = dyn; self.num_coeffs = num_coeffs; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.NUM_COEFFS_WARN_LVL = 20; self.DEF_NUM_COEFFS = 4; self._BSC_ALL = 1; self._BSC_GT_MEAN = 2; self._BSC_LT_MEAN = 3. self._uses_time = True; self.time = None; self.num_basis_funcs = 2; self.num_optim_vars = 0; self.coeffs = None; self.randomize_coeffs = True; self._num_coeffs_estimated = False; self.guess_pulse_action = 'MODULATE'; self.guess_pulse = None; self.guess_pulse_func = None; self.apply_params(). [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGen.init_pulse(self); self.init_coeffs(num_coeffs=num_coeffs). if self.guess_pulse is not None:; self.init_guess_pulse(); self._init_bounds(). if self.log_level <= logging.DEBUG and not self._num_coeffs_estimated:; logger.debug(; ""CRAB pulse initialised with {} coefficients per basis ""; ""function, which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)). # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse. [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values. Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs. self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DE",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:29097,Testability,log,logger,29097,"ll be equal to self.scaling; """"""; def __init__(self, dyn=None, num_coeffs=None, params=None):; self.parent = dyn; self.num_coeffs = num_coeffs; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.NUM_COEFFS_WARN_LVL = 20; self.DEF_NUM_COEFFS = 4; self._BSC_ALL = 1; self._BSC_GT_MEAN = 2; self._BSC_LT_MEAN = 3. self._uses_time = True; self.time = None; self.num_basis_funcs = 2; self.num_optim_vars = 0; self.coeffs = None; self.randomize_coeffs = True; self._num_coeffs_estimated = False; self.guess_pulse_action = 'MODULATE'; self.guess_pulse = None; self.guess_pulse_func = None; self.apply_params(). [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGen.init_pulse(self); self.init_coeffs(num_coeffs=num_coeffs). if self.guess_pulse is not None:; self.init_guess_pulse(); self._init_bounds(). if self.log_level <= logging.DEBUG and not self._num_coeffs_estimated:; logger.debug(; ""CRAB pulse initialised with {} coefficients per basis ""; ""function, which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)). # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse. [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values. Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs. self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:30171,Testability,log,logging,30171,"; ""function, which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)). # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse. [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values. Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs. self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs. if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)). if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs,; self.num_basis_funcs])*self.scaling. [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; sys",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:30186,Testability,log,logger,30186," means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)). # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse. [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values. Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs. self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs. if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)). if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs,; self.num_basis_funcs])*self.scaling. [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; --",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:30522,Testability,log,logging,30522,"erate the initial ceofficent values. Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs. self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs. if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)). if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs,; self.num_basis_funcs])*self.scaling. [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs. [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats; """"""; return self.coeffs.ravel().tolist(). [docs] def set_optim_var_vals(self, param_vals",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:30585,Testability,log,logger,30585,"-; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs. self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs. if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)). if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs,; self.num_basis_funcs])*self.scaling. [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs. [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats; """"""; return self.coeffs.ravel().tolist(). [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:32017,Testability,log,logger,32017," self.num_basis_funcs])*self.scaling. [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs. [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats; """"""; return self.coeffs.ravel().tolist(). [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the; # main optmisation call sequence; self.set_coeffs(param_vals). def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]). def init_guess_pulse(self):. self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)). def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse. def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse. def _init_bounds(self):; add_guess_pulse_scale = False; if self.lbound is None and self.ubound is None:; # no bounds to apply; self._bound_scale_cond = None; elif self.lbound is None:; # only upper bound; if self.ubound > 0:; self._bound_mean = 0.0; self._bound_scale = self.ubound; else:; add_guess_pulse_scale = True; self._bound_scale = self.scaling*self.num_coeffs + \; self.get_guess_pulse_scale(); self._bound_mean = -abs(self._bound_scal",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:32282,Testability,log,logger,32282," - 1); return num_coeffs. [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats; """"""; return self.coeffs.ravel().tolist(). [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the; # main optmisation call sequence; self.set_coeffs(param_vals). def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]). def init_guess_pulse(self):. self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)). def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse. def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse. def _init_bounds(self):; add_guess_pulse_scale = False; if self.lbound is None and self.ubound is None:; # no bounds to apply; self._bound_scale_cond = None; elif self.lbound is None:; # only upper bound; if self.ubound > 0:; self._bound_mean = 0.0; self._bound_scale = self.ubound; else:; add_guess_pulse_scale = True; self._bound_scale = self.scaling*self.num_coeffs + \; self.get_guess_pulse_scale(); self._bound_mean = -abs(self._bound_scale) + self.ubound; self._bound_scale_cond = self._BSC_GT_MEAN. elif self.ubound is None:; # only lower bound; if self.lbound < 0:; self._bound_mean = 0.0; self._bound_scale = abs(self.lbound); else:; self._bound_scale = self.scaling*self.num_coeffs + \; self.get_gu",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:11033,Usability,simpl,simply,11033,"ound - max_amp; else:; # min_amp + offset must exceed the lbound; return pulse + self.lbound - min_amp; else:; bound_range = self.ubound - self.lbound; amp_range = max_amp - min_amp; if max_amp - min_amp > bound_range:; # pulse range is too high, it must be scaled; pulse = pulse * bound_range / amp_range. # otherwise the pulse should fit anyway; return pulse + self.lbound - min(pulse). def _apply_ramping_pulse(self, pulse, ramping_pulse=None):; if ramping_pulse is None:; ramping_pulse = self.ramping_pulse; if ramping_pulse is not None:; pulse = pulse*ramping_pulse. return pulse. [docs]class PulseGenZero(PulseGen):; """"""; Generates a flat pulse; """"""; [docs] def gen_pulse(self):; """"""; Generate a pulse with the same value in every timeslot.; The value will be zero, unless the offset is not zero,; in which case it will be the offset; """"""; pulse = np.zeros(self.num_tslots); return self._apply_bounds_and_offset(pulse). [docs]class PulseGenRandom(PulseGen):; """"""; Generates random pulses as simply random values for each timeslot; """"""; [docs] def reset(self):; PulseGen.reset(self); self.random = True; self.apply_params(). [docs] def gen_pulse(self):; """"""; Generate a pulse of random values between 1 and -1; Values are scaled using the scaling property; and shifted using the offset property; Returns the pulse as an array of vales for each timeslot; """"""; pulse = (2*np.random.random(self.num_tslots) - 1) * self.scaling. return self._apply_bounds_and_offset(pulse). class PulseGenRndFourier(PulseGen):; """"""; Generates pulses by summing sine waves as a Fourier series; with random coefficients. Attributes; ----------; scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). min_wavelen : float; Minimum wavelength of any component wave; Set by default to 1/10th of the pulse time; """""". def reset(self):; """"""; re",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:2501,Availability,error,error,2501,"TORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number o",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:2669,Availability,error,error,2669,"# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the co",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:2966,Availability,error,error,2966,"F THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal con",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:3219,Availability,error,error,3219,"email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; ar",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:3897,Availability,error,error,3897,"is module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import quti",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:4888,Availability,error,errors,4888,"minimisation. References; ----------; 1. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=Non",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:4898,Availability,error,errors,4898,"minimisation. References; ----------; 1. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=Non",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:6308,Availability,error,error,6308,"nsure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the ``drift + ctrl_amp[j]*ctrls[j]``. The control pulse is an ``[n_ts, n_ctrls]`` array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; The underlying dynamics generator of the system can provide list (of; length ``num_tslots``) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time depe",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:6725,Availability,error,error,6725,"ound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the ``drift + ctrl_amp[j]*ctrls[j]``. The control pulse is an ``[n_ts, n_ctrls]`` array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; The underlying dynamics generator of the system can provide list (of; length ``num_tslots``) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initial : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total ti",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:6745,Availability,error,error,6745,"r=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the ``drift + ctrl_amp[j]*ctrls[j]``. The control pulse is an ``[n_ts, n_ctrls]`` array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; The underlying dynamics generator of the system can provide list (of; length ``num_tslots``) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initial : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:8301,Availability,error,error,8301,"ial : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are derived from it. ``None`` implies that timeslot; durations will be equal and calculated as ``evo_time/num_tslots``. amp_lbound : float or list of floats; Lower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_ubound : float or list of floats; Upper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A `",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:8368,Availability,error,error,8368,"tity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are derived from it. ``None`` implies that timeslot; durations will be equal and calculated as ``evo_time/num_tslots``. amp_lbound : float or list of floats; Lower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_ubound : float or list of floats; Upper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:9388,Availability,error,error,9388,"en the; fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error. Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; ``scipy.optimize methods``. Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. - GRAPE - Default ``optim_method`` is ``FMIN_L_BFGS_B``; - CRAB - Default ``optim_method`` is ``FMIN``. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the ``scipy.optimize.minimize``; method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the d",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:11125,Availability,error,error,11125,"etric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are ``UNIT``, ``GEN_MAT``, ``SYMPL`` (see :obj:`~Dynamics`; classes for details). dyn_params : dict; Parameters for the :obj:`~Dynamics` object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_type : string; Propagator type i.e. the method used to calculate the propagators and; propagator gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT. DEF will use the default for the specific; ``dyn_type`` (see :obj:`~PropagatorComputer` classes for details). prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific ``dyn_type`` (See :obj:`~FidelityComputer` classes for; details). fid_params : dict; Parameters for the :obj:`~FidelityComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. phase_option : string; Deprecated. Pass in ``fid_params`` instead. fid_err_scale_factor : float; Deprecated. Use ``scale_factor`` key in ``fid_params`` instead. tslot_type : string; Method for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works. (See :obj:`~TimeslotComputer`; classes for details.). tslot_params : dict; Parameters for the :obj:`~TimeslotComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. amp_update_mode : string; ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:11145,Availability,error,error,11145,"etric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are ``UNIT``, ``GEN_MAT``, ``SYMPL`` (see :obj:`~Dynamics`; classes for details). dyn_params : dict; Parameters for the :obj:`~Dynamics` object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_type : string; Propagator type i.e. the method used to calculate the propagators and; propagator gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT. DEF will use the default for the specific; ``dyn_type`` (see :obj:`~PropagatorComputer` classes for details). prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific ``dyn_type`` (See :obj:`~FidelityComputer` classes for; details). fid_params : dict; Parameters for the :obj:`~FidelityComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. phase_option : string; Deprecated. Pass in ``fid_params`` instead. fid_err_scale_factor : float; Deprecated. Use ``scale_factor`` key in ``fid_params`` instead. tslot_type : string; Method for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works. (See :obj:`~TimeslotComputer`; classes for details.). tslot_params : dict; Parameters for the :obj:`~TimeslotComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. amp_update_mode : string; ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:14410,Availability,error,error,14410,"bute name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:19737,Availability,error,error,19737," not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; ``H_d + ctrl_amp[j]*H_c[j]`` The control pulse is an ``[n_ts, n_ctrls]``; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is ``1 - fidelity``. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system can provide; list (of length ``num_",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:20410,Availability,error,error,20410,"m_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; ``H_d + ctrl_amp[j]*H_c[j]`` The control pulse is an ``[n_ts, n_ctrls]``; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is ``1 - fidelity``. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system can provide; list (of length ``num_tslots``) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent control generators. U_0 : Qobj; Starting point for the evolution. Typically the identity matrix. U_targ : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau arra",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:20577,Availability,error,error,20577,"lse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; ``H_d + ctrl_amp[j]*H_c[j]`` The control pulse is an ``[n_ts, n_ctrls]``; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is ``1 - fidelity``. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system can provide; list (of length ``num_tslots``) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent control generators. U_0 : Qobj; Starting point for the evolution. Typically the identity matrix. U_targ : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are derived from it. ``None`` implies",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:22026,Availability,error,error,22026,"U_0 : Qobj; Starting point for the evolution. Typically the identity matrix. U_targ : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are derived from it. ``None`` implies that timeslot; durations will be equal and calculated as ``evo_time/num_tslots``. amp_lbound : float or list of floats; Lower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_ubound : float or list of floats; Upper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A `",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:22093,Availability,error,error,22093,"tity matrix. U_targ : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are derived from it. ``None`` implies that timeslot; durations will be equal and calculated as ``evo_time/num_tslots``. amp_lbound : float or list of floats; Lower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_ubound : float or list of floats; Upper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:23113,Availability,error,error,23113,"rad : float; Minimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; scipy.optimize methods Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying; ``DEF`` will given algorithm-dependent result:. - GRAPE - Default ``optim_method`` is FMIN_L_BFGS_B; - CRAB - Default ``optim_method`` is FMIN. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the; ``termination_conditions`` matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; ``scipy.optimize.minimize`` method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:27466,Availability,error,error,27466,"ame value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils` in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to ``None`` will suppress the output; of files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """""". # parameters are checked in create pulse optimiser. # The deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_factor'] = accuracy_factor; else:; method_params = {'accuracy_factor':accuracy_factor}; _param_deprecation(; ""The '",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:30600,Availability,error,error,30600,"s,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type,; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext,; gen_stats=gen_stats). [docs]def opt_pulse_crab(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0,; optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE',; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:31079,Availability,error,error,31079,"; optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE',; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:31099,Availability,error,error,31099,"; optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE',; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:32651,Availability,error,error,32651,"l : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are dervived from it.; ``None`` implies that timeslot durations will be equal and calculated; as ``evo_time/num_tslots``. amp_lbound : float or list of floats; Lower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_ubound : float or list of floats; Upper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:32718,Availability,error,error,32718,"ty matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are dervived from it.; ``None`` implies that timeslot durations will be equal and calculated; as ``evo_time/num_tslots``. amp_lbound : float or list of floats; Lower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_ubound : float or list of floats; Upper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:34419,Availability,error,error,34419," is overridden by alg_params; (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. Note that where there is an attribute; of the :obj:`~Optimizer` object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_type : string; Propagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see :obj:`~PropagatorComputer` classes for details). prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default;",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:35267,Availability,error,error,35267,"timize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_type : string; Propagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see :obj:`~PropagatorComputer` classes for details). prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific dyn_type. (See :obj:`~FidelityComputer` classes for; details). fid_params : dict; Parameters for the :obj:`~FidelityComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_type : string; Method for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC UPDATE_ALL is the; only one that currently works. (See :obj:`~TimeslotComputer` classes; for details). tslot_params : dict; Parameters for the :obj:`~TimeslotComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. guess_pulse_type : string, default None; Type / shape of pulse(s) used modulate the control amplitudes.; Options include: RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN. guess_pulse_par",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:35287,Availability,error,error,35287,"timize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_type : string; Propagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see :obj:`~PropagatorComputer` classes for details). prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific dyn_type. (See :obj:`~FidelityComputer` classes for; details). fid_params : dict; Parameters for the :obj:`~FidelityComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_type : string; Method for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC UPDATE_ALL is the; only one that currently works. (See :obj:`~TimeslotComputer` classes; for details). tslot_params : dict; Parameters for the :obj:`~TimeslotComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. guess_pulse_type : string, default None; Type / shape of pulse(s) used modulate the control amplitudes.; Options include: RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN. guess_pulse_par",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:38360,Availability,error,error,38360,"ame value pairs. They applied after the; object is created. log_level : integer; level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to ``None`` will suppress the output; of files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs': num_coeffs,; 'init_coeff_scaling': init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type:; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and; not 'scaling' in guess_pulse_params):; gue",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:41145,Availability,error,error,41145,",; tslot_type=tslot_type, tslot_params=tslot_params,; init_pulse_type=guess_pulse_type,; init_pulse_params=guess_pulse_params,; ramping_pulse_type=ramping_pulse_type,; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext, gen_stats=gen_stats). [docs]def opt_pulse_crab_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0,; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE',; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; ``H_d + ctrl_amp[j]*H_c[j]`` The control pulse is an ``[n_ts, n_ctrls]``; array of piecewise amplitudes. The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonia",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:41890,Availability,error,error,41890,"_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE',; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; ``H_d + ctrl_amp[j]*H_c[j]`` The control pulse is an ``[n_ts, n_ctrls]``; array of piecewise amplitudes. The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0 : Qobj; Starting point for the evolution. Typically the identity matrix. U_targ : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given i",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:41910,Availability,error,error,41910,"E',; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; ``H_d + ctrl_amp[j]*H_c[j]`` The control pulse is an ``[n_ts, n_ctrls]``; array of piecewise amplitudes. The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0 : Qobj; Starting point for the evolution. Typically the identity matrix. U_targ : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_tim",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:43459,Availability,error,error,43459,"U_0 : Qobj; Starting point for the evolution. Typically the identity matrix. U_targ : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are derived from it. ``None`` implies that timeslot; durations will be equal and calculated as ``evo_time/num_tslots``. amp_lbound : float or list of floats; Lower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_ubound : float or list of floats; Upper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; ``alg_params`` (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the per",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:43526,Availability,error,error,43526,"tity matrix. U_targ : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are derived from it. ``None`` implies that timeslot; durations will be equal and calculated as ``evo_time/num_tslots``. amp_lbound : float or list of floats; Lower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_ubound : float or list of floats; Upper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; ``alg_params`` (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, wh",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:45248,Availability,error,error,45248,"; ``alg_params`` (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by ``alg_params`` (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; ``scipy.optimize.minimize`` could be used. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~Dynamics` object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_params : dict; Parameters for the :obj:`~FidelityComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_type : string; Method for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works. (See :obj:`~TimeslotComp",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:48698,Availability,error,error,48698," name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs':num_coeffs,; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type:; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and; not 'scaling' in guess_pulse_params)",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:53311,Availability,error,error,53311,"al : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are dervived from it. ``None`` implies that timeslot; durations will be equal and calculated as ``evo_time/num_tslots``. amp_lbound : float or list of floats; Lower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_ubound : float or list of floats; Upper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_method : string; a scip",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:53378,Availability,error,error,53378,"ity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are dervived from it. ``None`` implies that timeslot; durations will be equal and calculated as ``evo_time/num_tslots``. amp_lbound : float or list of floats; Lower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_ubound : float or list of floats; Upper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pu",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:54391,Availability,error,error,54391,"value. mim_grad : float; Minimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:56012,Availability,error,error,56012,"rr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. phase_option : string; Deprecated. Pass in fid_params instead. fid_err_scale_factor : float; Deprecated. Use scale_factor key in fid_params instead. tslot_type : string; Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. amp_update_mode : string; Deprecated. Use tslot_type instead. init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control ampl",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:56032,Availability,error,error,56032,"rr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. phase_option : string; Deprecated. Pass in fid_params instead. fid_err_scale_factor : float; Deprecated. Use scale_factor key in fid_params instead. tslot_type : string; Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. amp_update_mode : string; Deprecated. Use tslot_type instead. init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control ampl",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:61451,Availability,error,errors,61451,"e:; if isinstance(fid_params, dict):; if not 'phase_option' in fid_params:; fid_params['phase_option'] = phase_option; else:; fid_params = {'phase_option':phase_option}; _param_deprecation(; ""The 'phase_option' parameter is deprecated. ""; ""Use 'phase_option' in fid_params instead""). # fid_err_scale_factor; if not fid_err_scale_factor is None:; if isinstance(fid_params, dict):; if not 'fid_err_scale_factor' in fid_params:; fid_params['scale_factor'] = fid_err_scale_factor; else:; fid_params = {'scale_factor':fid_err_scale_factor}; _param_deprecation(; ""The 'fid_err_scale_factor' parameter is deprecated. ""; ""Use 'scale_factor' in fid_params instead""). # amp_update_mode; if not amp_update_mode is None:; amp_update_mode_up = _upper_safe(amp_update_mode); if amp_update_mode_up == 'ALL':; tslot_type = 'UPDATE_ALL'; else:; tslot_type = amp_update_mode; _param_deprecation(; ""The 'amp_update_mode' parameter is deprecated. ""; ""Use 'tslot_type' instead""). # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_lev",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:62029,Availability,error,errors,62029,"ameter is deprecated. ""; ""Use 'scale_factor' in fid_params instead""). # amp_update_mode; if not amp_update_mode is None:; amp_update_mode_up = _upper_safe(amp_update_mode); if amp_update_mode_up == 'ALL':; tslot_type = 'UPDATE_ALL'; else:; tslot_type = amp_update_mode; _param_deprecation(; ""The 'amp_update_mode' parameter is deprecated. ""; ""Use 'tslot_type' instead""). # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True. # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:62708,Availability,error,errors,62708,"ulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True. # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); elif prop_type == 'AUG_MAT':; if not isinstance(dyn.prop_computer, propcomp.PropCompAugMat):; dyn.prop_computer = propcomp.PropCompAugMat(dyn); elif prop_type == 'FRECHET':; if not isinstance(dyn.prop_computer, propcomp.PropCompFrechet):; dyn.prop_computer = propcomp.PropCompFrechet(dyn); else:; raise errors.UsageError(""No opti",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:63667,Availability,error,errors,63667,"; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True. # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); elif prop_type == 'AUG_MAT':; if not isinstance(dyn.prop_computer, propcomp.PropCompAugMat):; dyn.prop_computer = propcomp.PropCompAugMat(dyn); elif prop_type == 'FRECHET':; if not isinstance(dyn.prop_computer, propcomp.PropCompFrechet):; dyn.prop_computer = propcomp.PropCompFrechet(dyn); else:; raise errors.UsageError(""No option for prop_type: "" + prop_type); dyn.prop_computer.apply_params(prop_params). # Create the FidelityComputer instance; # The default will be typically be the best option; # Note: the FidCompTraceDiffApprox is a subclass of FidCompTraceDiff; # so need to check this type first; fid_type_up = _upper_safe(fid_type); if fid_type_up == 'DEF' or fid_type_up is None or fid_type_up == '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.f",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:64590,Availability,error,errors,64590,"ropcomp.PropCompFrechet):; dyn.prop_computer = propcomp.PropCompFrechet(dyn); else:; raise errors.UsageError(""No option for prop_type: "" + prop_type); dyn.prop_computer.apply_params(prop_params). # Create the FidelityComputer instance; # The default will be typically be the best option; # Note: the FidCompTraceDiffApprox is a subclass of FidCompTraceDiff; # so need to check this type first; fid_type_up = _upper_safe(fid_type); if fid_type_up == 'DEF' or fid_type_up is None or fid_type_up == '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params). # Currently the only working option for tslot computer is; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params). # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # C",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:64987,Availability,error,errors,64987,"pTraceDiff; # so need to check this type first; fid_type_up = _upper_safe(fid_type); if fid_type_up == 'DEF' or fid_type_up is None or fid_type_up == '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params). # Currently the only working option for tslot computer is; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params). # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:65394,Availability,error,errors,65394,"raceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params). # Currently the only working option for tslot computer is; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params). # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_u",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:66765,Availability,error,errors,66765,"e:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; n_ctrls = dyn.num_ctrls. ramping_pgen = None; if ramping_pulse_type:; ramping_pgen = pulsegen.create_pulse_gen(; pulse_type=ramping_pulse_type, dyn=dyn,; pulse_params=ramping_pulse_params); if alg_up == 'CRAB':; # Create a pulse generator for each ctrl; crab_pulse_params = None; num_coeffs = None; init_coeff_scaling = None; if isinstance(alg_params, dict):; num_coeffs = alg_params.get('num_coeffs'); init_coeff_scaling = alg_params.get('init_coeff_scaling'); if 'crab_pulse_params' in alg_params:; crab_pulse_params = alg_params.get('crab_pulse_params'). guess_pulse_type = init_pulse_",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:2373,Deployability,configurat,configuration,2373,"OT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:17886,Deployability,configurat,configuration,17886,"ams,; optim_method=optim_method, method_params=method_params,; dyn_type=dyn_type, dyn_params=dyn_params,; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type,; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics. dyn.init_timeslots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]). if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(). # Initialise the starting amplitudes; dyn.initialize_controls(init_amps). if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amp",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:51691,Deployability,configurat,configuration,51691,"t_file_ext, gen_stats=gen_stats). [docs]def create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed configuration is; required before running the optmisation algorthim, or the algorithm will be; run many times, for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; The underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initial : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:69944,Deployability,update,updated,69944,"generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params). lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub. if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action. if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]. else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__); return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:3538,Energy Efficiency,reduce,reduces,3538," time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logg",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:5178,Integrability,message,message,5178,"o, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_fil",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:5266,Integrability,message,message,5266,"o, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_fil",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:5354,Integrability,message,message,5354,"o, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:7032,Integrability,depend,dependent,7032,"fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the ``drift + ctrl_amp[j]*ctrls[j]``. The control pulse is an ``[n_ts, n_ctrls]`` array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; The underlying dynamics generator of the system can provide list (of; length ``num_tslots``) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initial : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are derived from it. ``None`` implies that timeslot; durations will be equal and calculated as ``evo_time/num_tslots``. amp_lbound : float or list o",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:7257,Integrability,depend,dependent,7257,"):; """"""; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the ``drift + ctrl_amp[j]*ctrls[j]``. The control pulse is an ``[n_ts, n_ctrls]`` array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; The underlying dynamics generator of the system can provide list (of; length ``num_tslots``) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initial : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are derived from it. ``None`` implies that timeslot; durations will be equal and calculated as ``evo_time/num_tslots``. amp_lbound : float or list of floats; Lower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_ubound : float or list of floats; Upper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bound",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:9644,Integrability,depend,dependent,9644,"f the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error. Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; ``scipy.optimize methods``. Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. - GRAPE - Default ``optim_method`` is ``FMIN_L_BFGS_B``; - CRAB - Default ``optim_method`` is ``FMIN``. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the ``scipy.optimize.minimize``; method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are ``UNIT``, ``GEN_MAT``, ``SYMPL`` (see :obj:`~Dynamics`; classes for details). dyn_params : dict; Parameters for the :obj:`~Dynamics` object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_type : st",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:19849,Integrability,wrap,wrapper,19849,"ile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; ``H_d + ctrl_amp[j]*H_c[j]`` The control pulse is an ``[n_ts, n_ctrls]``; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is ``1 - fidelity``. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system can provide; list (of length ``num_tslots``) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:20770,Integrability,depend,dependent,20770,"e a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; ``H_d + ctrl_amp[j]*H_c[j]`` The control pulse is an ``[n_ts, n_ctrls]``; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is ``1 - fidelity``. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system can provide; list (of length ``num_tslots``) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent control generators. U_0 : Qobj; Starting point for the evolution. Typically the identity matrix. U_targ : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are derived from it. ``None`` implies that timeslot; durations will be equal and calculated as ``evo_time/num_tslots``. amp_lbound : float or list of floats",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:20986,Integrability,depend,dependent,20986,"mat; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; ``H_d + ctrl_amp[j]*H_c[j]`` The control pulse is an ``[n_ts, n_ctrls]``; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is ``1 - fidelity``. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system can provide; list (of length ``num_tslots``) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent control generators. U_0 : Qobj; Starting point for the evolution. Typically the identity matrix. U_targ : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are derived from it. ``None`` implies that timeslot; durations will be equal and calculated as ``evo_time/num_tslots``. amp_lbound : float or list of floats; Lower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_ubound : float or list of floats; Upper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds fo",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:23373,Integrability,depend,dependent,23373,"of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; scipy.optimize methods Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying; ``DEF`` will given algorithm-dependent result:. - GRAPE - Default ``optim_method`` is FMIN_L_BFGS_B; - CRAB - Default ``optim_method`` is FMIN. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the; ``termination_conditions`` matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; ``scipy.optimize.minimize`` method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~Dynamics` object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_pa",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:31381,Integrability,depend,dependent,31381,"e=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE',; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are dervived from it.; ``None`` implies that timeslot durations will be equal and calculated; as ``evo_time/num_tslots``. amp_lbound : float or list of",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:31605,Integrability,depend,dependent,31605,"trol pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are dervived from it.; ``None`` implies that timeslot durations will be equal and calculated; as ``evo_time/num_tslots``. amp_lbound : float or list of floats; Lower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_ubound : float or list of floats; Upper boundaries for the control amplitudes. Can be a scalar value; applied",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:41257,Integrability,wrap,wrapper,41257,"=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext, gen_stats=gen_stats). [docs]def opt_pulse_crab_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0,; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE',; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; ``H_d + ctrl_amp[j]*H_c[j]`` The control pulse is an ``[n_ts, n_ctrls]``; array of piecewise amplitudes. The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; A list of control Hamiltonians. These are scaled",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:42203,Integrability,depend,dependent,42203,"ity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; ``H_d + ctrl_amp[j]*H_c[j]`` The control pulse is an ``[n_ts, n_ctrls]``; array of piecewise amplitudes. The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0 : Qobj; Starting point for the evolution. Typically the identity matrix. U_targ : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are derived from it. ``None`` implies that timeslot; durations will be equal and calculated as ``evo_time/num_tslots``. amp_lbound : float or list of floats; Lower bounda",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:42419,Integrability,depend,dependent,42419,"dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; ``H_d + ctrl_amp[j]*H_c[j]`` The control pulse is an ``[n_ts, n_ctrls]``; array of piecewise amplitudes. The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0 : Qobj; Starting point for the evolution. Typically the identity matrix. U_targ : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are derived from it. ``None`` implies that timeslot; durations will be equal and calculated as ``evo_time/num_tslots``. amp_lbound : float or list of floats; Lower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_ubound : float or list of floats; Upper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds fo",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:52041,Integrability,depend,dependent,52041,"im_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed configuration is; required before running the optmisation algorthim, or the algorithm will be; run many times, for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; The underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initial : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are dervived from it. ``None`` implies that timeslot; durations will be equal and calculated as ``evo_time/num_tslots``. amp_lbound : float or list of",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:52266,Integrability,depend,dependent,52266,"EF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed configuration is; required before running the optmisation algorthim, or the algorithm will be; run many times, for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; The underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initial : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are dervived from it. ``None`` implies that timeslot; durations will be equal and calculated as ``evo_time/num_tslots``. amp_lbound : float or list of floats; Lower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_ubound : float or list of floats; Upper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of boun",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:54621,Integrability,depend,dependent,54621,"r; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propa",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:68983,Integrability,message,message,68983," guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params). lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub. if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action. if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]. else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__); return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ;",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:2373,Modifiability,config,configuration,2373,"OT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:2991,Modifiability,variab,variables,2991,"F THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal con",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:3573,Modifiability,variab,variables,3573," time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logg",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:3660,Modifiability,variab,variables,3660," time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logg",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:3740,Modifiability,variab,variables,3740,"antum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.co",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:17886,Modifiability,config,configuration,17886,"ams,; optim_method=optim_method, method_params=method_params,; dyn_type=dyn_type, dyn_params=dyn_params,; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type,; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics. dyn.init_timeslots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]). if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(). # Initialise the starting amplitudes; dyn.initialize_controls(init_amps). if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amp",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:30886,Modifiability,variab,variables,30886,"rift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0,; optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE',; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies th",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:33825,Modifiability,variab,variable,33825,"hm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. Note that where there is an attribute; of the :obj:`~Optimizer` object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_type : string; Propagator type i.e. the method ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:34359,Modifiability,variab,variable,34359," is overridden by alg_params; (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. Note that where there is an attribute; of the :obj:`~Optimizer` object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_type : string; Propagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see :obj:`~PropagatorComputer` classes for details). prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default;",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:41697,Modifiability,variab,variables,41697,"ms=None, optim_method='fmin', method_params=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE',; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; ``H_d + ctrl_amp[j]*H_c[j]`` The control pulse is an ``[n_ts, n_ctrls]``; array of piecewise amplitudes. The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0 : Qobj; Starting point for the evolution. Typically the identity matrix. U_targ : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies tha",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:44646,Modifiability,variab,variable,44646,"time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; ``alg_params`` (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by ``alg_params`` (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; ``scipy.optimize.minimize`` could be used. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~Dynamics` object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_para",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:45188,Modifiability,variab,variable,45188,"; ``alg_params`` (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by ``alg_params`` (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; ``scipy.optimize.minimize`` could be used. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~Dynamics` object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_params : dict; Parameters for the :obj:`~FidelityComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_type : string; Method for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works. (See :obj:`~TimeslotComp",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:51691,Modifiability,config,configuration,51691,"t_file_ext, gen_stats=gen_stats). [docs]def create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed configuration is; required before running the optmisation algorthim, or the algorithm will be; run many times, for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; The underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initial : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:69391,Modifiability,config,config,69391,"generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params). lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub. if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action. if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]. else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__); return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:2923,Performance,optimiz,optimize,2923,"F THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal con",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:4413,Performance,optimiz,optimization,4413," algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:4806,Performance,optimiz,optimizer,4806,"plicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_facto",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:4819,Performance,optimiz,optimizer,4819,"plicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_facto",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:9299,Performance,optimiz,optimize,9299,"ror target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error. Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; ``scipy.optimize methods``. Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. - GRAPE - Default ``optim_method`` is ``FMIN_L_BFGS_B``; - CRAB - Default ``optim_method`` is ``FMIN``. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the ``scipy.optimize.minimize``; method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. dyn_type : string; Dynamics type,",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:9501,Performance,optimiz,optimize,9501,"falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error. Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; ``scipy.optimize methods``. Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. - GRAPE - Default ``optim_method`` is ``FMIN_L_BFGS_B``; - CRAB - Default ``optim_method`` is ``FMIN``. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the ``scipy.optimize.minimize``; method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are ``UNIT``, ``GEN_MAT``, ``SYMPL`` (see :obj:`~Dynamics`; classes for details). dyn_params : dict; Parameters for the :obj:`~Dynamics` objec",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:10050,Performance,optimiz,optimize,10050,"ame and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error. Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; ``scipy.optimize methods``. Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. - GRAPE - Default ``optim_method`` is ``FMIN_L_BFGS_B``; - CRAB - Default ``optim_method`` is ``FMIN``. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the ``scipy.optimize.minimize``; method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are ``UNIT``, ``GEN_MAT``, ``SYMPL`` (see :obj:`~Dynamics`; classes for details). dyn_params : dict; Parameters for the :obj:`~Dynamics` object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_type : string; Propagator type i.e. the method used to calculate the propagators and; propagator gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT. DEF will use the default for the specific; ``dyn_type`` (see :obj:`~PropagatorComputer` classes for details). prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. T",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:23024,Performance,optimiz,optimize,23024,"ror target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; scipy.optimize methods Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying; ``DEF`` will given algorithm-dependent result:. - GRAPE - Default ``optim_method`` is FMIN_L_BFGS_B; - CRAB - Default ``optim_method`` is FMIN. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the; ``termination_conditions`` matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; ``scipy.optimize.minimize`` method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. phase_option : string; Determines",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:23223,Performance,optimiz,optimize,23223,"terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; scipy.optimize methods Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying; ``DEF`` will given algorithm-dependent result:. - GRAPE - Default ``optim_method`` is FMIN_L_BFGS_B; - CRAB - Default ``optim_method`` is FMIN. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the; ``termination_conditions`` matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; ``scipy.optimize.minimize`` method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~Dynamics` object. The key value pairs are; assumed ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:23776,Performance,optimiz,optimize,23776,"me and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; scipy.optimize methods Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying; ``DEF`` will given algorithm-dependent result:. - GRAPE - Default ``optim_method`` is FMIN_L_BFGS_B; - CRAB - Default ``optim_method`` is FMIN. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the; ``termination_conditions`` matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; ``scipy.optimize.minimize`` method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~Dynamics` object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_params : dict; Parameters for the :obj:`~FidelityComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_type : string; Method for computing the dynamics genera",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:33631,Performance,perform,performane,33631,"timisation will terminate when the; fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. Note that where there is an attribute; of the :obj:`~Optimizer` object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object. The key val",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:33966,Performance,optimiz,optimize,33966,"algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. Note that where there is an attribute; of the :obj:`~Optimizer` object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_type : string; Propagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the defau",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:34278,Performance,optimiz,optimize,34278,"loat; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. Note that where there is an attribute; of the :obj:`~Optimizer` object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_type : string; Propagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see :obj:`~PropagatorComputer` classes for details). prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_type : string; Fidelity error (and fidel",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:44447,Performance,perform,performance,44447,"n will terminate when the; fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; ``alg_params`` (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by ``alg_params`` (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; ``scipy.optimize.minimize`` could be used. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Paramet",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:44789,Performance,optimiz,optimize,44789,"bove. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; ``alg_params`` (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by ``alg_params`` (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; ``scipy.optimize.minimize`` could be used. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~Dynamics` object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied aft",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:45107,Performance,optimiz,optimize,45107,"e factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; ``alg_params`` (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by ``alg_params`` (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; ``scipy.optimize.minimize`` could be used. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~Dynamics` object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_params : dict; Parameters for the :obj:`~FidelityComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_type : string; Method for computing the dynamics generators, propagators and evolution; in the timeslots",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:54304,Performance,optimiz,optimize,54304,"ty error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:54489,Performance,optimiz,optimize,54489,"lue, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:55006,Performance,optimiz,optimize,55006,"s : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string; Fidelity",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:59125,Performance,optimiz,optimizer,59125,"t; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:59198,Performance,optimiz,optimizer,59198,"ute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_factor'] = ac",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:65126,Performance,optimiz,optimizer,65126,"_up == '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params). # Currently the only working option for tslot computer is; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params). # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_t",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:65242,Performance,optimiz,optimizer,65242,"uter, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params). # Currently the only working option for tslot computer is; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params). # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. optim.apply_method_params(method_params). if gen_stats:; # Create a stats",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:65342,Performance,optimiz,optimizer,65342,"e_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params). # Currently the only working option for tslot computer is; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params). # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; #",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:65548,Performance,optimiz,optimize,65548,"omp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params). # Currently the only working option for tslot computer is; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params). # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; d",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:65650,Performance,optimiz,optimizer,65650,"""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params). # Currently the only working option for tslot computer is; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params). # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.targ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:65700,Performance,optimiz,optimizer,65700,"ams). # Currently the only working option for tslot computer is; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params). # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:66356,Performance,perform,performance,66356,"m_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; n_ctrls = dyn.num_ctrls. ramping_pgen = None; if ramping_pulse_type:; ramping_pgen = pulsegen.create_pulse_gen(; pulse_type=ramping_pulse_type, dyn=dyn,; pulse_params=ramping_pulse_params)",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:69437,Performance,optimiz,optimizer,69437,"generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params). lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub. if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action. if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]. else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__); return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:2841,Security,access,accessible,2841," CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it use",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:14209,Security,access,accessible,14209,"ed in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr'",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:27265,Security,access,accessible,27265,"n CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils` in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to ``None`` will suppress the output; of files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """""". # parameters are checked in create pulse optimiser. # The deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(method_params, dict):; if ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:38167,Security,access,accessible,38167,"CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to ``None`` will suppress the output; of files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs': num_coeffs,; 'init_coeff_scaling': init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:48497,Security,access,accessible,48497," in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs':num_coeffs,; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:58768,Security,access,accessible,58768,"dded; to any initial / guess pulses generated. ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:58970,Security,access,accessed,58970,"ulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _par",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:59073,Security,access,accessed,59073,"ng_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""). # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:4585,Testability,log,logging,4585,"fining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=Non",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:4594,Testability,log,logger,4594,"fining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=Non",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:4603,Testability,log,logging,4603,"fining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=Non",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:6199,Testability,log,logging,6199,"recation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the ``drift + ctrl_amp[j]*ctrls[j]``. The control pulse is an ``[n_ts, n_ctrls]`` array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; The underlying dynamics generator of the system can provide list (of; length ``num_tslots``) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; A list of control dynamics generators. These are scaled by the",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:13485,Testability,log,logger,13485,"lse_params : dict; Parameters for the initial / guess pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses. By default; initial pulses are generated with amplitudes in the range (-1.0, 1.0).; These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added to any; initial / guess pulses generated. ramping_pulse_type : string; Type of pulse used to modulate the control pulse. It's intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statisti",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:14490,Testability,log,logging,14490,"he logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_factor'] = accuracy_factor; else:; method_params = {'accuracy_factor':accuracy_f",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:14519,Testability,log,logger,14519,"tes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_factor'] = accuracy_factor; else:; method_params = {'accuracy_factor':accuracy_factor}; _param_deprecation(; ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:14554,Testability,log,logger,14554,"ls`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_factor'] = accuracy_factor; else:; method_params = {'accuracy_factor':accuracy_factor}; _param_deprecation(; ""The 'accuracy_factor' parameter",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:17857,Testability,log,logging,17857,"l_time=max_wall_time,; alg=alg, alg_params=alg_params, optim_params=optim_params,; optim_method=optim_method, method_params=method_params,; dyn_type=dyn_type, dyn_params=dyn_params,; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type,; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics. dyn.init_timeslots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]). if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(). # Initialise the starting amplitudes; dyn.initialize_controls(init_amps). if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:18412,Testability,log,logger,18412,"timeslots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]). if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(). # Initialise the starting amplitudes; dyn.initialize_controls(init_amps). if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:18593,Testability,log,logging,18593," = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(). # Initialise the starting amplitudes; dyn.initialize_controls(init_amps). if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:18608,Testability,log,logger,18608,"gen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(). # Initialise the starting amplitudes; dyn.initialize_controls(init_amps). if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_para",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:18892,Testability,log,logging,18892," ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:18907,Testability,log,logger,18907,"_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:19628,Testability,log,logging,19628,"ng.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; ``H_d + ctrl_amp[j]*H_c[j]`` The control pulse is an ``[n_ts, n_ctrls]``; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is ``1 - fidelit",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:26535,Testability,log,logger,26535,"lse_params : dict; Parameters for the initial / guess pulse generator object. The key; value pairs are assumed to be attribute name value pairs. They applied; after the object is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses. By default; initial pulses are generated with amplitudes in the range (-1.0, 1.0).; These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added to any; initial / guess pulses generated. ramping_pulse_type : string; Type of pulse used to modulate the control pulse. It's intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils` in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to ``None`` will suppress the output; of files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, st",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:30491,Testability,log,logging,30491,"rams=method_params,; dyn_type='UNIT', dyn_params=dyn_params,; prop_params=prop_params, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type,; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext,; gen_stats=gen_stats). [docs]def opt_pulse_crab(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0,; optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE',; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:33864,Testability,test,tested,33864,"or the optimisation algorithm. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. Note that where there is an attribute; of the :obj:`~Optimizer` object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_type : string; Propagator type i.e. the method used to calculate the propagtors and; propagtor gradient ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:37435,Testability,log,logger,37435,"ey applied after the; object is created. guess_pulse_action : string, default 'MODULATE'; Determines how the guess pulse is applied to the pulse generated by the; basis expansion. Options are: MODULATE, ADD. pulse_scaling : float; Linear scale factor for generated guess pulses. By default initial; pulses are generated with amplitudes in the range (-1.0, 1.0). These; will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added to any; guess pulses generated. ramping_pulse_type : string; Type of pulse used to modulate the control pulse. It's intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to ``None`` will suppress the output; of files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statisti",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:38523,Testability,log,logging,38523," of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to ``None`` will suppress the output; of files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs': num_coeffs,; 'init_coeff_scaling': init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type:; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_acti",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:38552,Testability,log,logger,38552,"INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to ``None`` will suppress the output; of files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs': num_coeffs,; 'init_coeff_scaling': init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type:; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and; not 'p",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:38587,Testability,log,logger,38587,"INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to ``None`` will suppress the output; of files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs': num_coeffs,; 'init_coeff_scaling': init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type:; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and; not 'pulse_action' in guess_pulse_para",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:41036,Testability,log,logging,41036,"method_params,; dyn_type=dyn_type, dyn_params=dyn_params,; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; tslot_type=tslot_type, tslot_params=tslot_params,; init_pulse_type=guess_pulse_type,; init_pulse_params=guess_pulse_params,; ramping_pulse_type=ramping_pulse_type,; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext, gen_stats=gen_stats). [docs]def opt_pulse_crab_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0,; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE',; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; ``H_d + ctrl_amp[j]*H_c[j]`` The control pulse is an ``[n_ts, n_ctrls]``; array of piecewise amplitudes. The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:44685,Testability,test,tested,44685,"sation algorithm. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; ``alg_params`` (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by ``alg_params`` (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; ``scipy.optimize.minimize`` could be used. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~Dynamics` object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_params : dict; Parameters for the :obj:`~PropagatorComputer` ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:47769,Testability,log,logger,47769,"airs. They applied after the; object is created. guess_pulse_action : string, 'MODULATE'; Determines how the guess pulse is applied to the pulse generated by the; basis expansion. Options are: MODULATE, ADD. pulse_scaling : float; Linear scale factor for generated guess pulses. By default initial; pulses are generated with amplitudes in the range (-1.0, 1.0). These; will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added to any; guess pulses generated. ramping_pulse_type : string; Type of pulse used to modulate the control pulse. It's intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, stat",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:48862,Testability,log,logging,48862,"essaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs':num_coeffs,; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type:; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:48891,Testability,log,logger,48891,"SE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs':num_coeffs,; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type:; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and; not 'pul",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:48926,Testability,log,logger,48926," WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs':num_coeffs,; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type:; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and; not 'pulse_action' in guess_pulse_params",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:51455,Testability,log,logging,51455,"rams=fid_params,; tslot_type=tslot_type, tslot_params=tslot_params,; init_pulse_type=guess_pulse_type,; init_pulse_params=guess_pulse_params,; ramping_pulse_type=ramping_pulse_type,; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext, gen_stats=gen_stats). [docs]def create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed configuration is; required before running the optmisation algorthim, or the algorithm will be; run many times, for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; The underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initial : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate o",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:58296,Testability,log,logger,58296,"t_pulse_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated. ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._ch",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:62313,Testability,log,logging,62313,"ate_mode' parameter is deprecated. ""; ""Use 'tslot_type' instead""). # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True. # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompD",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:62342,Testability,log,logger,62342,"ecated. ""; ""Use 'tslot_type' instead""). # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True. # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer =",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:62377,Testability,log,logger,62377,"stead""). # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True. # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); eli",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:69346,Testability,log,logging,69346,"generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params). lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub. if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action. if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]. else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__); return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:69362,Testability,log,logger,69362,"generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params). lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub. if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action. if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]. else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__); return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:5094,Usability,simpl,simplefilter,5094,"o, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_fil",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:19840,Usability,simpl,simply,19840,"ile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; ``H_d + ctrl_amp[j]*H_c[j]`` The control pulse is an ``[n_ts, n_ctrls]``; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is ``1 - fidelity``. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system can provide; list (of length ``num_tslots``) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can ",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:41248,Usability,simpl,simply,41248,"=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext, gen_stats=gen_stats). [docs]def opt_pulse_crab_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0,; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE',; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; ``H_d + ctrl_amp[j]*H_c[j]`` The control pulse is an ``[n_ts, n_ctrls]``; array of piecewise amplitudes. The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; A list of control Hamiltonians. These are scaled",MatchSource.WIKI,docs/4.6/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:2353,Availability,redundant,redundant,2353," BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (el",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:4054,Availability,error,error,4054,"me for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute : float; Total wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating the propagators themselves. wall_time_onwd_prop_compute : float; Total wall (elasped) time computing combined onward propagation,; that is the time evolution from a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_compute : float; Total wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:2546,Deployability,configurat,configurations,2546,"CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_ti",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:2585,Deployability,update,updated,2585,"CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_ti",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:4859,Deployability,update,updated,4859,"ned onward propagation,; that is the time evolution from a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_compute : float; Total wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; sel",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:4945,Deployability,update,updates,4945,".; Excludes calculating the propagators themselves. wall_time_gradient_compute : float; Total wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; sel",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:5181,Deployability,update,update,5181,"adient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; self.num_fidelity_func_calls = 0; self.num_grad_func_calls = 0; self.num_tslot_recompute = 0; self.num_fidelity_computes = 0; self.num_grad_computes = 0; # Control amplitudes; self.num_ctrl_amp_updates = 0; self.mea",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:5394,Deployability,update,update,5394,"_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; self.num_fidelity_func_calls = 0; self.num_grad_func_calls = 0; self.num_tslot_recompute = 0; self.num_fidelity_computes = 0; self.num_grad_computes = 0; # Control amplitudes; self.num_ctrl_amp_updates = 0; self.mean_num_ctrl_amp_updates_per_iter = 0.0; self.num_timeslot_changes = 0; self.mean_num_timeslot_changes_per_update = 0.0; self.num_ctrl_amp_changes = 0; self.mean_num_ctrl_amp_changes_per_update = 0.0. [docs] def calculate(self):; """"",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:9107,Deployability,update,updates,9107,"(""Wall time computing forward propagation: "" +; self._format_datetime(self.wall_time_fwd_prop_compute, tot)); print(""Wall time computing onward propagation: "" +; self._format_datetime(self.wall_time_onwd_prop_compute, tot)); print(""Wall time computing gradient: "" +; self._format_datetime(self.wall_time_gradient_compute, tot)); print(""""). def report_func_calls(self):; print(""**** Iterations and function calls ****""); print(""Number of iterations: {}"".format(self.num_iter)); print(""Number of fidelity function calls: ""; ""{}"".format(self.num_fidelity_func_calls)); print(""Number of times fidelity is computed: ""; ""{}"".format(self.num_fidelity_computes)); print(""Number of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift an",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:9182,Deployability,update,updates,9182,"int(""Wall time computing onward propagation: "" +; self._format_datetime(self.wall_time_onwd_prop_compute, tot)); print(""Wall time computing gradient: "" +; self._format_datetime(self.wall_time_gradient_compute, tot)); print(""""). def report_func_calls(self):; print(""**** Iterations and function calls ****""); print(""Number of iterations: {}"".format(self.num_iter)); print(""Number of fidelity function calls: ""; ""{}"".format(self.num_fidelity_func_calls)); print(""Number of times fidelity is computed: ""; ""{}"".format(self.num_fidelity_computes)); print(""Number of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:9392,Deployability,update,update,9392,"gradient_compute, tot)); print(""""). def report_func_calls(self):; print(""**** Iterations and function calls ****""); print(""Number of iterations: {}"".format(self.num_iter)); print(""Number of fidelity function calls: ""; ""{}"".format(self.num_fidelity_func_calls)); print(""Number of times fidelity is computed: ""; ""{}"".format(self.num_fidelity_computes)); print(""Number of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:9591,Deployability,update,update,9591,"function calls: ""; ""{}"".format(self.num_fidelity_func_calls)); print(""Number of times fidelity is computed: ""; ""{}"".format(self.num_fidelity_computes)); print(""Number of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator com",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:9725,Deployability,configurat,configurations,9725,"of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total num",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:9781,Deployability,update,updated,9781,"of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total num",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:9909,Deployability,update,update,9909,"mat(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total number of steps (matrix product) computing forward propagation. mean_num_fwd_prop_step_computes_per_update : float; Mean average num",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:10253,Deployability,update,update,10253,"n: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total number of steps (matrix product) computing forward propagation. mean_num_fwd_prop_step_computes_per_update : float; Mean average number of steps computing forward propagation. mean_wall_time_fwd_prop_compute : float; Mean average time to compute forward propagation. num_onwd_prop_step_computes : integer; Total number of steps (matrix product) computing onward propagation. mean_num_onwd_prop_step_computes_per_update : float; Mean average number of steps computing onward",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:10579,Deployability,update,update,10579,"_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total number of steps (matrix product) computing forward propagation. mean_num_fwd_prop_step_computes_per_update : float; Mean average number of steps computing forward propagation. mean_wall_time_fwd_prop_compute : float; Mean average time to compute forward propagation. num_onwd_prop_step_computes : integer; Total number of steps (matrix product) computing onward propagation. mean_num_onwd_prop_step_computes_per_update : float; Mean average number of steps computing onward propagation. mean_wall_time_onwd_prop_compute; Mean average time to compute onward propagation; """""". def __init__(self):; self.reset(). def reset(self):; Stats.reset(self); # Dynamics generators (Hamiltonians); self.num_dyn_gen_computes = 0; self.mean_num_dyn_gen_computes_per_update = 0.0; self.mean_wall_time_dyn_gen_compute = 0.",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:13581,Deployability,update,update,13581,"_step_computes /; float(self.num_ctrl_amp_updates)). self.mean_wall_time_fwd_prop_compute = \; (self.wall_time_fwd_prop_compute /; float(self.num_fwd_prop_step_computes)). self.mean_num_onwd_prop_step_computes_per_update = \; (self.num_onwd_prop_step_computes /; float(self.num_ctrl_amp_updates)). self.mean_wall_time_onwd_prop_compute = \; (self.wall_time_onwd_prop_compute /; float(self.num_onwd_prop_step_computes)). def report(self):; """"""; Print a report of the stats to the console; """""". print(""\n------------------------------------""; ""\n---- Control optimisation stats ----""); self.report_timings(); self.report_func_calls(); self.report_amp_updates(); self.report_dyn_gen_comps(); self.report_fwd_prop(); self.report_onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:13966,Deployability,update,update,13966,"t(self.num_onwd_prop_step_computes)). def report(self):; """"""; Print a report of the stats to the console; """""". print(""\n------------------------------------""; ""\n---- Control optimisation stats ----""); self.report_timings(); self.report_func_calls(); self.report_amp_updates(); self.report_dyn_gen_comps(); self.report_fwd_prop(); self.report_onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute)). def report_onwd_prop(self):; print(""**** Onward Propagation ****""); print(""Total number of onward propagation step computations: ""; ""{}"".format(self.num_onwd_prop_step_computes)); print(""Mean number of onward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_onwd_prop_step_computes_per_update)); print(""Mean wall time to compute onward propagation ""; ""{",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:14376,Deployability,update,update,14376,"onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute)). def report_onwd_prop(self):; print(""**** Onward Propagation ****""); print(""Total number of onward propagation step computations: ""; ""{}"".format(self.num_onwd_prop_step_computes)); print(""Mean number of onward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_onwd_prop_step_computes_per_update)); print(""Mean wall time to compute onward propagation ""; ""{} s"".format(self.mean_wall_time_onwd_prop_compute)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:14807,Deployability,update,update,14807,"onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute)). def report_onwd_prop(self):; print(""**** Onward Propagation ****""); print(""Total number of onward propagation step computations: ""; ""{}"".format(self.num_onwd_prop_step_computes)); print(""Mean number of onward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_onwd_prop_step_computes_per_update)); print(""Mean wall time to compute onward propagation ""; ""{} s"".format(self.mean_wall_time_onwd_prop_compute)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:15180,Deployability,update,updated,15180,"onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute)). def report_onwd_prop(self):; print(""**** Onward Propagation ****""); print(""Total number of onward propagation step computations: ""; ""{}"".format(self.num_onwd_prop_step_computes)); print(""Mean number of onward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_onwd_prop_step_computes_per_update)); print(""Mean wall time to compute onward propagation ""; ""{} s"".format(self.mean_wall_time_onwd_prop_compute)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:2546,Modifiability,config,configurations,2546,"CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_ti",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:9725,Modifiability,config,configurations,9725,"of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total num",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:2353,Safety,redund,redundant,2353," BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (el",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:2878,Usability,simpl,simply,2878,"CT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute : float; Total wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating the propagators themselves. wall_time_onwd_prop_compute : float; Total wall (elasped) time computing combined onward propagation,; th",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:5507,Usability,clear,clear,5507,"ity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; self.num_fidelity_func_calls = 0; self.num_grad_func_calls = 0; self.num_tslot_recompute = 0; self.num_fidelity_computes = 0; self.num_grad_computes = 0; # Control amplitudes; self.num_ctrl_amp_updates = 0; self.mean_num_ctrl_amp_updates_per_iter = 0.0; self.num_timeslot_changes = 0; self.mean_num_timeslot_changes_per_update = 0.0; self.num_ctrl_amp_changes = 0; self.mean_num_ctrl_amp_changes_per_update = 0.0. [docs] def calculate(self):; """"""; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report; """"""; # If the optimation is still ru",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/stats.html:5520,Usability,clear,clear,5520,"nteger; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; self.num_fidelity_func_calls = 0; self.num_grad_func_calls = 0; self.num_tslot_recompute = 0; self.num_fidelity_computes = 0; self.num_grad_computes = 0; # Control amplitudes; self.num_ctrl_amp_updates = 0; self.mean_num_ctrl_amp_updates_per_iter = 0.0; self.num_timeslot_changes = 0; self.mean_num_timeslot_changes_per_update = 0.0; self.num_ctrl_amp_changes = 0; self.mean_num_ctrl_amp_changes_per_update = 0.0. [docs] def calculate(self):; """"""; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report; """"""; # If the optimation is still running then the o",MatchSource.WIKI,docs/4.6/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/stats.html
https://qutip.org/docs/4.6/modules/qutip/control/termcond.html:2818,Availability,error,error,2818,"ON) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(se",MatchSource.WIKI,docs/4.6/modules/qutip/control/termcond.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/termcond.html
https://qutip.org/docs/4.6/modules/qutip/control/termcond.html:4153,Deployability,update,updated,4153," # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(self):; self.fid_err_targ = 1e-5; self.fid_goal = None; self.max_wall_time = 60*60.0; self.min_gradient_norm = 1e-5; self.max_iterations = 1e10; self.max_fid_func_calls = 1e10. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/control/termcond.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/termcond.html
https://qutip.org/docs/4.6/modules/qutip/control/termcond.html:3485,Performance,optimiz,optimize,3485," # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(self):; self.fid_err_targ = 1e-5; self.fid_goal = None; self.max_wall_time = 60*60.0; self.min_gradient_norm = 1e-5; self.max_iterations = 1e10; self.max_fid_func_calls = 1e10. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/control/termcond.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/termcond.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:3647,Availability,error,errors,3647,"ypical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP sett",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:3657,Availability,error,errors,3657,"ypical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP sett",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:14229,Availability,mask,masks,14229,"inal; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts, dtype=bool); self.evo_init2t_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_init2t_recalc[0] = False; self.evo_t2targ_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_t2targ_recalc[-1] = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find firs",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:20411,Availability,error,errors,20411,"w.sum(); dyn.stats.wall_time_onwd_prop_compute += \; timeit.default_timer() - time_start. # Clear calc now flags; self.dyn_gen_calc_now[:] = False; self.prop_calc_now[:] = False; self.evo_init2t_calc_now[:] = False; self.evo_t2targ_calc_now[:] = False. def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value. Attempts to find a timeslot where the least number of propagator; calculations will be required.; Flags the associated evolution operators for calculation now; """"""; dyn = self.parent; n_ts = dyn.num_tslots; kBothEvoCurrent = -1; kFwdEvoCurrent = -1; kUse = -1; # If no specific timeslot set in config, then determine dynamically; if kUse < 0:; for k in range(n_ts):; # find first timeslot where both evo_init2t and; # evo_t2targ are current; if not self.evo_init2t_recalc[k]:; kFwdEvoCurrent = k; if not self.evo_t2targ_recalc[k]:; kBothEvoCurrent = k; break. if kBothEvoCurrent >= 0:; kUse = kBothEvoCurrent; elif kFwdEvoCurrent >= 0:; kUse = kFwdEvoCurrent; else:; raise errors.FunctionalError(""No timeslot found matching ""; ""criteria""). self.evo_init2t_calc_now[kUse] = True; self.evo_t2targ_calc_now[kUse] = True; return kUse. class EvoCompSummary(qtrldump.DumpSummaryItem):; """"""; A summary of the most recent time evolution computation; Used in stats calculations and for data dumping; ; Attributes; ----------; evo_dump_idx : int; Index of the linked :class:`dump.EvoCompDumpItem`; None if no linked item; ; iter_num : int; Iteration number of the pulse optimisation; None if evolution compute outside of a pulse optimisation; ; fid_func_call_num : int; Fidelity function call number of the pulse optimisation; None if evolution compute outside of a pulse optimisation; ; grad_func_call_num : int; Gradient function call number of the pulse optimisation; None if evolution compute outside of a pulse optimisation; ; num_amps_changed : int; Number of control timeslot amplitudes changed since previous; evolution ca",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:2444,Deployability,update,update,2444,"INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods ",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:2548,Deployability,update,updates,2548,"NDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj ",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:2578,Deployability,update,update,2578,"NDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj ",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:2810,Deployability,update,updated,2810,"; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, ",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:3209,Deployability,update,update,3209,"organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data tha",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:6828,Deployability,update,updated,6828,"def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gr",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:8122,Deployability,update,update,8122,"they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_r",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:12636,Deployability,update,updated,12636,"itarity_check_level:; dyn.check_unitarity(); ; if dyn.dump:; self.dump_current(). [docs] def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; _func_deprecation(""'get_timeslot_for_fidelity_calc' is deprecated. ""; ""Use '_get_timeslot_for_fidelity_calc'""); return self._get_timeslot_for_fidelity_calc. def _get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_recalc = None; self.dyn_gen_calc_now = None; self.prop_calc_now = None; self.evo_init2t_calc_now = None; self.evo_t2targ_calc_now = None; TimeslotComputer.reset(self); self.id_text = 'DYNAMIC'; self.apply_params(). def init_comp(self):; """"""; Initialise the flags; """"""; ####; # These maps are used to determine what needs to be updated; ####; # Note _recalc means the value needs updating at some point; # e.g. here no values have been set, except the initial and final; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:12651,Deployability,update,update,12651,"""""""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; _func_deprecation(""'get_timeslot_for_fidelity_calc' is deprecated. ""; ""Use '_get_timeslot_for_fidelity_calc'""); return self._get_timeslot_for_fidelity_calc. def _get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_recalc = None; self.dyn_gen_calc_now = None; self.prop_calc_now = None; self.evo_init2t_calc_now = None; self.evo_t2targ_calc_now = None; TimeslotComputer.reset(self); self.id_text = 'DYNAMIC'; self.apply_params(). def init_comp(self):; """"""; Initialise the flags; """"""; ####; # These maps are used to determine what needs to be updated; ####; # Note _recalc means the value needs updating at some point; # e.g. here no values have been set, except the initial and final; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts, dtype=bool); self.evo_init2t_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_init2t_recalc[0] = False; self.evo_t2targ_recalc = n",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:13139,Deployability,update,updated,13139,"imply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_recalc = None; self.dyn_gen_calc_now = None; self.prop_calc_now = None; self.evo_init2t_calc_now = None; self.evo_t2targ_calc_now = None; TimeslotComputer.reset(self); self.id_text = 'DYNAMIC'; self.apply_params(). def init_comp(self):; """"""; Initialise the flags; """"""; ####; # These maps are used to determine what needs to be updated; ####; # Note _recalc means the value needs updating at some point; # e.g. here no values have been set, except the initial and final; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts, dtype=bool); self.evo_init2t_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_init2t_recalc[0] = False; self.evo_t2targ_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_t2targ_recalc[-1] = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:14303,Deployability,update,update,14303,"inal; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts, dtype=bool); self.evo_init2t_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_init2t_recalc[0] = False; self.evo_t2targ_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_t2targ_recalc[-1] = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find firs",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:15254,Deployability,update,updated,15254," are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalcula",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:15781,Deployability,update,update,15781,"changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_ca",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:16710,Deployability,update,update,16710,"adients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_calc_now & \; self.evo_init2t_recalc; evo_t2targ_recomp_now = self.evo_t2targ_calc_now & \; self.evo_t2targ_recalc. # to recomupte evo_init2t, will need to start; # at a cell that has been computed; if np.any(evo_init2t_recomp_now):; for k in range(n_ts, 0, -1):; if evo_init2t_recomp_now[k] and self.evo_init2t_recalc[k-1]:; evo_init2t_recomp_now[k-1] = True. # for evo_t2targ, will also need to start; # at a cell that has been computed; if np.any(evo_t2targ_recomp_now):; for k in range(0, n_ts):; if evo_t2targ_recomp_now[k] and self.evo_t2targ_recalc[k+1]:; evo_t2targ_recomp_now[k+1] = True. # determine which dyn gen and prop need recalculating now in order to; # calculate the forwrd and onward evolutions; prop_recomp_now = (evo_init2t_recomp_now[1:]; | evo_t2targ_recomp_now[:-1]; | self.prop_calc_now[:]) & self.prop_recalc[:]; dyn_gen_recomp_now = (prop_recomp_now[:] | self.dyn_gen_calc_now[:]) \; & self.dyn_gen_r",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:23173,Deployability,update,updated,23173,"ed : int; Number of control timeslot amplitudes changed since previous; evolution calculation; ; num_timeslots_changed : int; Number of timeslots in which any amplitudes changed since previous; evolution calculation; ; wall_time_dyn_gen_compute : float; Time spent computing dynamics generators; (in seconds of elapsed time); ; wall_time_prop_compute : float; Time spent computing propagators (including and propagator gradients); (in seconds of elapsed time); ; wall_time_fwd_prop_compute : float; Time spent computing the forward evolution of the system; see :property:`dynamics.fwd_evo` ; (in seconds of elapsed time); ; wall_time_onwd_prop_compute : float; Time spent computing the 'backward' evolution of the system; see :property:`dynamics.onwd_evo` and :property:`dynamics.onto_evo`; (in seconds of elapsed time); """"""; ; min_col_width = 11; summary_property_names = (; ""idx"", ""evo_dump_idx"", ; ""iter_num"", ""fid_func_call_num"", ""grad_func_call_num"",; ""num_amps_changed"", ""num_timeslots_changed"",; ""wall_time_dyn_gen_compute"", ""wall_time_prop_compute"",; ""wall_time_fwd_prop_compute"", ""wall_time_onwd_prop_compute""); ; summary_property_fmt_type = (; 'd', 'd',; 'd', 'd', 'd',; 'd', 'd',; 'g', 'g', ; 'g', 'g'; ); ; summary_property_fmt_prec = (; 0, 0, ; 0, 0, 0,; 0, 0, ; 3, 3,; 3, 3; ); ; def __init__(self):; self.reset(); ; def reset(self):; qtrldump.DumpSummaryItem.reset(self); self.evo_dump_idx = None; self.iter_num = None; self.fid_func_call_num = None; self.grad_func_call_num = None; self.num_amps_changed = 0; self.num_timeslots_changed = 0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:3813,Integrability,message,message,3813,"ulations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init_",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:3901,Integrability,message,message,3901,"ulations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init_",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:3989,Integrability,message,message,3989,"t be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init__(self, dynamics, params=None):; from qutip.control.dynamics import Dynamics; if not isinstance(dynamics, Dynamics):; raise Ty",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:6642,Modifiability,config,config,6642,"if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # Tru",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:20032,Modifiability,config,config,20032,"mer(); # compute the onward propagation; R = range(n_ts-1, -1, -1); for k in R:; if evo_t2targ_recomp_now[k]:; dyn.evo_t2targ[k] = dyn.evo_t2targ[k+1].dot(dyn.prop[k]); self.evo_t2targ_recalc[k] = False; if dyn.stats is not None:; dyn.stats.num_onwd_prop_step_computes += \; evo_t2targ_recomp_now.sum(); dyn.stats.wall_time_onwd_prop_compute += \; timeit.default_timer() - time_start. # Clear calc now flags; self.dyn_gen_calc_now[:] = False; self.prop_calc_now[:] = False; self.evo_init2t_calc_now[:] = False; self.evo_t2targ_calc_now[:] = False. def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value. Attempts to find a timeslot where the least number of propagator; calculations will be required.; Flags the associated evolution operators for calculation now; """"""; dyn = self.parent; n_ts = dyn.num_tslots; kBothEvoCurrent = -1; kFwdEvoCurrent = -1; kUse = -1; # If no specific timeslot set in config, then determine dynamically; if kUse < 0:; for k in range(n_ts):; # find first timeslot where both evo_init2t and; # evo_t2targ are current; if not self.evo_init2t_recalc[k]:; kFwdEvoCurrent = k; if not self.evo_t2targ_recalc[k]:; kBothEvoCurrent = k; break. if kBothEvoCurrent >= 0:; kUse = kBothEvoCurrent; elif kFwdEvoCurrent >= 0:; kUse = kFwdEvoCurrent; else:; raise errors.FunctionalError(""No timeslot found matching ""; ""criteria""). self.evo_init2t_calc_now[kUse] = True; self.evo_t2targ_calc_now[kUse] = True; return kUse. class EvoCompSummary(qtrldump.DumpSummaryItem):; """"""; A summary of the most recent time evolution computation; Used in stats calculations and for data dumping; ; Attributes; ----------; evo_dump_idx : int; Index of the linked :class:`dump.EvoCompDumpItem`; None if no linked item; ; iter_num : int; Iteration number of the pulse optimisation; None if evolution compute outside of a pulse optimisation; ; fid_func_call_num : int; Fidelity function call number of the pulse optimisation; None if ",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:8781,Security,access,access,8781,"ity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:3712,Testability,log,logging,3712,"S in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:3751,Testability,log,logging,3751,"nUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the mo",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:3760,Testability,log,logger,3760,"nUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the mo",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:3769,Testability,log,logging,3769,"nUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the mo",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:4326,Testability,log,logger,4326," understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init__(self, dynamics, params=None):; from qutip.control.dynamics import Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:5869,Testability,log,logger,5869,"s or dump are set; """"""; def __init__(self, dynamics, params=None):; from qutip.control.dynamics import Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:5987,Testability,log,logger,5987," Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amp",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:6008,Testability,log,logger,6008," Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amp",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:6035,Testability,log,logger,6035,"nstantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, ",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:6585,Testability,log,logger,6585," are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = n",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:7836,Testability,log,logging,7836,"ed; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:7852,Testability,log,logger,7852,"(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:8061,Testability,log,logging,8061,"eeding recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs =",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:8077,Testability,log,logger,8077,"on; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_sum",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:9167,Testability,log,logging,9167,".num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:9183,Testability,log,logger,9183,"tes += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; time",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:9190,Testability,log,log,9190,"s.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_ti",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:9194,Testability,log,logging,9194,"s.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_ti",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:9874,Testability,log,logging,9874,"dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_timer() - time_start. if ecs: time_start = timeit.default_timer(); # compute the forward propagation; R = range(n_ts); for k in R:; if dyn.oper_dtype == Qobj:; dyn._fwd_evo[k+1] = dyn._prop[k]*dyn._fwd_evo[k]; else:; dyn._fwd_evo[k+1] = dyn._prop[k].dot(dyn._fwd_evo[k]). if ecs:; ecs.wall_time_fwd_prop_compute = \; timeit.default_timer() - time_start; time_start = timeit.default_timer(); # compute the onward propagation; if dyn.fid_computer.uses_onwd_evo:; dyn._onwd_evo[n_ts-1] = dyn._prop[n_ts-1]; R = range(n_ts-2, -1, -1); for k in R:; if dyn.oper_dtype == Qobj:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1]*dyn._prop[k]; else:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1].dot(dyn._",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:9898,Testability,log,logger,9898,"ne; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_timer() - time_start. if ecs: time_start = timeit.default_timer(); # compute the forward propagation; R = range(n_ts); for k in R:; if dyn.oper_dtype == Qobj:; dyn._fwd_evo[k+1] = dyn._prop[k]*dyn._fwd_evo[k]; else:; dyn._fwd_evo[k+1] = dyn._prop[k].dot(dyn._fwd_evo[k]). if ecs:; ecs.wall_time_fwd_prop_compute = \; timeit.default_timer() - time_start; time_start = timeit.default_timer(); # compute the onward propagation; if dyn.fid_computer.uses_onwd_evo:; dyn._onwd_evo[n_ts-1] = dyn._prop[n_ts-1]; R = range(n_ts-2, -1, -1); for k in R:; if dyn.oper_dtype == Qobj:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1]*dyn._prop[k]; else:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1].dot(dyn._prop[k]). if dyn.fid_c",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:9905,Testability,log,log,9905,"qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_timer() - time_start. if ecs: time_start = timeit.default_timer(); # compute the forward propagation; R = range(n_ts); for k in R:; if dyn.oper_dtype == Qobj:; dyn._fwd_evo[k+1] = dyn._prop[k]*dyn._fwd_evo[k]; else:; dyn._fwd_evo[k+1] = dyn._prop[k].dot(dyn._fwd_evo[k]). if ecs:; ecs.wall_time_fwd_prop_compute = \; timeit.default_timer() - time_start; time_start = timeit.default_timer(); # compute the onward propagation; if dyn.fid_computer.uses_onwd_evo:; dyn._onwd_evo[n_ts-1] = dyn._prop[n_ts-1]; R = range(n_ts-2, -1, -1); for k in R:; if dyn.oper_dtype == Qobj:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1]*dyn._prop[k]; else:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1].dot(dyn._prop[k]). if dyn.fid_computer.uses_onto",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:9909,Testability,log,logging,9909,"qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_timer() - time_start. if ecs: time_start = timeit.default_timer(); # compute the forward propagation; R = range(n_ts); for k in R:; if dyn.oper_dtype == Qobj:; dyn._fwd_evo[k+1] = dyn._prop[k]*dyn._fwd_evo[k]; else:; dyn._fwd_evo[k+1] = dyn._prop[k].dot(dyn._fwd_evo[k]). if ecs:; ecs.wall_time_fwd_prop_compute = \; timeit.default_timer() - time_start; time_start = timeit.default_timer(); # compute the onward propagation; if dyn.fid_computer.uses_onwd_evo:; dyn._onwd_evo[n_ts-1] = dyn._prop[n_ts-1]; R = range(n_ts-2, -1, -1); for k in R:; if dyn.oper_dtype == Qobj:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1]*dyn._prop[k]; else:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1].dot(dyn._prop[k]). if dyn.fid_computer.uses_onto",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:14703,Testability,log,logging,14703,".evo_t2targ_recalc[-1] = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fi",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:14727,Testability,log,logger,14727," = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients a",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:14734,Testability,log,log,14734,"alc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalcu",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:14738,Testability,log,logging,14738,"alc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalcu",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:15205,Testability,log,logging,15205,"that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_n",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:15221,Testability,log,logger,15221,"k (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:16522,Testability,log,logging,16522,".evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_calc_now & \; self.evo_init2t_recalc; evo_t2targ_recomp_now = self.evo_t2targ_calc_now & \; self.evo_t2targ_recalc. # to recomupte evo_init2t, will need to start; # at a cell that has been computed; if np.any(evo_init2t_recomp_now):; for k in range(n_ts, 0, -1):; if evo_init2t_recomp_now[k] and self.evo_init2t_recalc[k-1]:; evo_init2t_recomp_now[k-1] = True. # for evo_t2targ, will also need to start; # at a cell that has been computed; if np.any(evo_t2targ_recomp_now):; for k in range(0, n_ts):; if evo_t2targ_recomp_now[k] and self.evo_t2targ_recalc[k+1]:; evo_t2targ_recomp_now[k+1] = True. # determine which dyn gen and prop need recalculating now in order to; # calculate the forwrd and onward evolutions; prop_recomp_now =",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:16546,Testability,log,logger,16546,"st_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_calc_now & \; self.evo_init2t_recalc; evo_t2targ_recomp_now = self.evo_t2targ_calc_now & \; self.evo_t2targ_recalc. # to recomupte evo_init2t, will need to start; # at a cell that has been computed; if np.any(evo_init2t_recomp_now):; for k in range(n_ts, 0, -1):; if evo_init2t_recomp_now[k] and self.evo_init2t_recalc[k-1]:; evo_init2t_recomp_now[k-1] = True. # for evo_t2targ, will also need to start; # at a cell that has been computed; if np.any(evo_t2targ_recomp_now):; for k in range(0, n_ts):; if evo_t2targ_recomp_now[k] and self.evo_t2targ_recalc[k+1]:; evo_t2targ_recomp_now[k+1] = True. # determine which dyn gen and prop need recalculating now in order to; # calculate the forwrd and onward evolutions; prop_recomp_now = (evo_init2t_recomp_no",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:16553,Testability,log,log,16553," True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_calc_now & \; self.evo_init2t_recalc; evo_t2targ_recomp_now = self.evo_t2targ_calc_now & \; self.evo_t2targ_recalc. # to recomupte evo_init2t, will need to start; # at a cell that has been computed; if np.any(evo_init2t_recomp_now):; for k in range(n_ts, 0, -1):; if evo_init2t_recomp_now[k] and self.evo_init2t_recalc[k-1]:; evo_init2t_recomp_now[k-1] = True. # for evo_t2targ, will also need to start; # at a cell that has been computed; if np.any(evo_t2targ_recomp_now):; for k in range(0, n_ts):; if evo_t2targ_recomp_now[k] and self.evo_t2targ_recalc[k+1]:; evo_t2targ_recomp_now[k+1] = True. # determine which dyn gen and prop need recalculating now in order to; # calculate the forwrd and onward evolutions; prop_recomp_now = (evo_init2t_recomp_now[1:]; | evo_t2ta",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:16557,Testability,log,logging,16557," True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_calc_now & \; self.evo_init2t_recalc; evo_t2targ_recomp_now = self.evo_t2targ_calc_now & \; self.evo_t2targ_recalc. # to recomupte evo_init2t, will need to start; # at a cell that has been computed; if np.any(evo_init2t_recomp_now):; for k in range(n_ts, 0, -1):; if evo_init2t_recomp_now[k] and self.evo_init2t_recalc[k-1]:; evo_init2t_recomp_now[k-1] = True. # for evo_t2targ, will also need to start; # at a cell that has been computed; if np.any(evo_t2targ_recomp_now):; for k in range(0, n_ts):; if evo_t2targ_recomp_now[k] and self.evo_t2targ_recalc[k+1]:; evo_t2targ_recomp_now[k+1] = True. # determine which dyn gen and prop need recalculating now in order to; # calculate the forwrd and onward evolutions; prop_recomp_now = (evo_init2t_recomp_now[1:]; | evo_t2ta",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:11773,Usability,simpl,simply,11773,"[k]; else:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1].dot(dyn._prop[k]). if dyn.fid_computer.uses_onto_evo:; #R = range(n_ts-1, -1, -1); R = range(n_ts-1, -1, -1); for k in R:; if dyn.oper_dtype == Qobj:; dyn._onto_evo[k] = dyn._onto_evo[k+1]*dyn._prop[k]; else:; dyn._onto_evo[k] = dyn._onto_evo[k+1].dot(dyn._prop[k]). if ecs:; ecs.wall_time_onwd_prop_compute = \; timeit.default_timer() - time_start; ; if dyn.stats:; dyn.stats.wall_time_dyn_gen_compute += \; ecs.wall_time_dyn_gen_compute; dyn.stats.wall_time_prop_compute += \; ecs.wall_time_prop_compute; dyn.stats.wall_time_fwd_prop_compute += \; ecs.wall_time_fwd_prop_compute; dyn.stats.wall_time_onwd_prop_compute += \; ecs.wall_time_onwd_prop_compute; ; if dyn.unitarity_check_level:; dyn.check_unitarity(); ; if dyn.dump:; self.dump_current(). [docs] def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; _func_deprecation(""'get_timeslot_for_fidelity_calc' is deprecated. ""; ""Use '_get_timeslot_for_fidelity_calc'""); return self._get_timeslot_for_fidelity_calc. def _get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_re",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:12121,Usability,simpl,simply,12121,"cs:; ecs.wall_time_onwd_prop_compute = \; timeit.default_timer() - time_start; ; if dyn.stats:; dyn.stats.wall_time_dyn_gen_compute += \; ecs.wall_time_dyn_gen_compute; dyn.stats.wall_time_prop_compute += \; ecs.wall_time_prop_compute; dyn.stats.wall_time_fwd_prop_compute += \; ecs.wall_time_fwd_prop_compute; dyn.stats.wall_time_onwd_prop_compute += \; ecs.wall_time_onwd_prop_compute; ; if dyn.unitarity_check_level:; dyn.check_unitarity(); ; if dyn.dump:; self.dump_current(). [docs] def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; _func_deprecation(""'get_timeslot_for_fidelity_calc' is deprecated. ""; ""Use '_get_timeslot_for_fidelity_calc'""); return self._get_timeslot_for_fidelity_calc. def _get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_recalc = None; self.dyn_gen_calc_now = None; self.prop_calc_now = None; self.evo_init2t_calc_now = None; self.evo_t2targ_calc_now = None; TimeslotComputer.reset(self); self.id_text = 'DYNAMIC'; self.apply_params(). def init_comp(self):; """"""; Initialise the flags; """"""; ####; # These maps are used to determine what needs to",MatchSource.WIKI,docs/4.6/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:2486,Deployability,integrat,integrate,2486," ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides exact solvers for a system-bath setup using the; hierarchy equations of motion (HEOM).; """""". # Authors: Neill Lambert, Anubhav Vardhan, Alexander Pitchford; # Contact: nwlambert@gmail.com. import timeit; import numpy as np; #from scipy.special import factorial; import scipy.sparse as sp; import scipy.integrate; from copy import copy; from qutip import Qobj, qeye; from qutip.states import enr_state_dictionaries; from qutip.superoperator import liouvillian, spre, spost; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.solver import Options, Result, Stats; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.heom import cy_pad_csr; from qutip.cy.spmath import zcsr_kron; from qutip.fastsparse import fast_csr_matrix, fast_identity. [docs]class HEOMSolver(object):; """"""; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentia",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:7426,Deployability,integrat,integrate,7426,"lass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. - config; - integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:13424,Deployability,integrat,integrate,13424," L_he; N_he_interact += 1. he_state_neigh[k] = n_k. if n_excite <= N_c - 1:; # find the hierarchy element index of the neighbour after; # this element, for this Matsubara term; he_state_neigh[k] = n_k + 1; he_idx_neigh = he2idx[tuple(he_state_neigh)]. op = commQ; if renorm:; op = -1j*norm_plus[n_k, k]*op; else:; op = -1j*op. L_he = cy_pad_csr(op, N_he, N_he, he_idx, he_idx_neigh); L_helems += L_he; N_he_interact += 1. he_state_neigh[k] = n_k. if stats:; stats.add_timing('hierarchy contruct',; timeit.default_timer() - start_helem_constr,; ss_conf); stats.add_count('Num hierarchy elements', N_he, ss_conf); stats.add_count('Num he interactions', N_he_interact, ss_conf). # Setup Liouvillian; if stats:; start_louvillian = timeit.default_timer(). H_he = zcsr_kron(unit_helems, liouvillian(H_sys).data). L_helems += H_he. if stats:; stats.add_timing('Liouvillian contruct',; timeit.default_timer() - start_louvillian,; ss_conf). if stats: start_integ_conf = timeit.default_timer(). r = scipy.integrate.ode(cy_ode_rhs). r.set_f_params(L_helems.data, L_helems.indices, L_helems.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """"""",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:15498,Deployability,integrat,integrate,15498,".stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_integ, ss_run); if ss_run.total_time is None:; ss_run.total_time = time_now - start_run; else:; ss_run.total_time += time_now - start_run; stats.total_time = ss_conf.total_time + ss_run.total_time. return output. def _calc_matsubara_params(self):; """"""; Calculate the Matsubara coefficents and frequencies. Returns; -------; c, nu: both list(float). """"""; c = []; nu = []; lam0 = self.coup_strength; gam = self.cut_freq; hbar = self.planck; beta = 1.0/(self.boltzmann*self.temperature); N_m = self.N_exp. g = 2*np.pi / (beta*hbar); for k in range(N_m):; if k == 0:; nu.append(gam); c.append(lam0*gam*; (1.0/np.tan(gam*hbar*beta/2.0) - 1j) / hbar); else:; nu.append(k*g); c.append(4*lam0*gam*nu[k] /; ((nu[k]**2 - gam**2)*beta*hbar**2)). self.exp_coeff = c; self.exp_freq = nu; return c, nu. def _",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:15680,Deployability,integrat,integrate,15680,"meError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_integ, ss_run); if ss_run.total_time is None:; ss_run.total_time = time_now - start_run; else:; ss_run.total_time += time_now - start_run; stats.total_time = ss_conf.total_time + ss_run.total_time. return output. def _calc_matsubara_params(self):; """"""; Calculate the Matsubara coefficents and frequencies. Returns; -------; c, nu: both list(float). """"""; c = []; nu = []; lam0 = self.coup_strength; gam = self.cut_freq; hbar = self.planck; beta = 1.0/(self.boltzmann*self.temperature); N_m = self.N_exp. g = 2*np.pi / (beta*hbar); for k in range(N_m):; if k == 0:; nu.append(gam); c.append(lam0*gam*; (1.0/np.tan(gam*hbar*beta/2.0) - 1j) / hbar); else:; nu.append(k*g); c.append(4*lam0*gam*nu[k] /; ((nu[k]**2 - gam**2)*beta*hbar**2)). self.exp_coeff = c; self.exp_freq = nu; return c, nu. def _calc_renorm_factors(self):; """"""; Calculate the renormalisation factors. Returns; -------; norm_plus, norm_minus : array[N_c, N_m] of float; """"""; c = self.exp_coeff; N_m = self.N_exp; N_c = self.N_cu",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:18837,Deployability,update,updated,18837,"rm_minus. def _pad_csr(A, row_scale, col_scale, insertrow=0, insertcol=0):; """"""; Expand the input csr_matrix to a greater space as given by the scale.; Effectively inserting A into a larger matrix; zeros([A.shape[0]*row_scale, A.shape[1]*col_scale]; at the position [A.shape[0]*insertrow, A.shape[1]*insertcol]; The same could be achieved through using a kron with a matrix with; one element set to 1. However, this is more efficient; """""". # ajgpitch 2016-03-08:; # Clearly this is a very simple operation in dense matrices; # It seems strange that there is nothing equivalent in sparse however,; # after much searching most threads suggest directly addressing; # the underlying arrays, as done here.; # This certainly proved more efficient than other methods such as stacking; #TODO: Perhaps cythonize and move to spmatfuncs. if not isinstance(A, sp.csr_matrix):; raise TypeError(""First parameter must be a csr matrix""); nrowin = A.shape[0]; ncolin = A.shape[1]; nrowout = nrowin*row_scale; ncolout = ncolin*col_scale. A._shape = (nrowout, ncolout); if insertcol == 0:; pass; elif insertcol > 0 and insertcol < col_scale:; A.indices = A.indices + insertcol*ncolin; else:; raise ValueError(""insertcol must be >= 0 and < col_scale""). if insertrow == 0:; A.indptr = np.concatenate((A.indptr,; np.array([A.indptr[-1]]*(row_scale-1)*nrowin))); elif insertrow == row_scale-1:; A.indptr = np.concatenate((np.array([0]*(row_scale - 1)*nrowin),; A.indptr)); elif insertrow > 0 and insertrow < row_scale - 1:; A.indptr = np.concatenate((np.array([0]*insertrow*nrowin), A.indptr,; np.array([A.indptr[-1]]*(row_scale - insertrow - 1)*nrowin))); else:; raise ValueError(""insertrow must be >= 0 and < row_scale""). return A. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:4450,Energy Efficiency,reduce,reduced,4450,"he bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve). This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate. There are opportunities to develop a more general spectral density code. Attributes; ----------; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmann's constant. options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms; """"""; def __init__(self):; raise NotImplementedError(""This is a abstract class only. ""; ""Use a subclass, for example HSolverDL""). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; self.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_c",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:17362,Energy Efficiency,efficient,efficient,17362,"se:; nu.append(k*g); c.append(4*lam0*gam*nu[k] /; ((nu[k]**2 - gam**2)*beta*hbar**2)). self.exp_coeff = c; self.exp_freq = nu; return c, nu. def _calc_renorm_factors(self):; """"""; Calculate the renormalisation factors. Returns; -------; norm_plus, norm_minus : array[N_c, N_m] of float; """"""; c = self.exp_coeff; N_m = self.N_exp; N_c = self.N_cut. norm_plus = np.empty((N_c+1, N_m)); norm_minus = np.empty((N_c+1, N_m)); for k in range(N_m):; for n in range(N_c+1):; norm_plus[n, k] = np.sqrt(abs(c[k])*(n + 1)); norm_minus[n, k] = np.sqrt(float(n)/abs(c[k])). return norm_plus, norm_minus. def _pad_csr(A, row_scale, col_scale, insertrow=0, insertcol=0):; """"""; Expand the input csr_matrix to a greater space as given by the scale.; Effectively inserting A into a larger matrix; zeros([A.shape[0]*row_scale, A.shape[1]*col_scale]; at the position [A.shape[0]*insertrow, A.shape[1]*insertcol]; The same could be achieved through using a kron with a matrix with; one element set to 1. However, this is more efficient; """""". # ajgpitch 2016-03-08:; # Clearly this is a very simple operation in dense matrices; # It seems strange that there is nothing equivalent in sparse however,; # after much searching most threads suggest directly addressing; # the underlying arrays, as done here.; # This certainly proved more efficient than other methods such as stacking; #TODO: Perhaps cythonize and move to spmatfuncs. if not isinstance(A, sp.csr_matrix):; raise TypeError(""First parameter must be a csr matrix""); nrowin = A.shape[0]; ncolin = A.shape[1]; nrowout = nrowin*row_scale; ncolout = ncolin*col_scale. A._shape = (nrowout, ncolout); if insertcol == 0:; pass; elif insertcol > 0 and insertcol < col_scale:; A.indices = A.indices + insertcol*ncolin; else:; raise ValueError(""insertcol must be >= 0 and < col_scale""). if insertrow == 0:; A.indptr = np.concatenate((A.indptr,; np.array([A.indptr[-1]]*(row_scale-1)*nrowin))); elif insertrow == row_scale-1:; A.indptr = np.concatenate((np.array([0]*(row_sca",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:17669,Energy Efficiency,efficient,efficient,17669,"ut. norm_plus = np.empty((N_c+1, N_m)); norm_minus = np.empty((N_c+1, N_m)); for k in range(N_m):; for n in range(N_c+1):; norm_plus[n, k] = np.sqrt(abs(c[k])*(n + 1)); norm_minus[n, k] = np.sqrt(float(n)/abs(c[k])). return norm_plus, norm_minus. def _pad_csr(A, row_scale, col_scale, insertrow=0, insertcol=0):; """"""; Expand the input csr_matrix to a greater space as given by the scale.; Effectively inserting A into a larger matrix; zeros([A.shape[0]*row_scale, A.shape[1]*col_scale]; at the position [A.shape[0]*insertrow, A.shape[1]*insertcol]; The same could be achieved through using a kron with a matrix with; one element set to 1. However, this is more efficient; """""". # ajgpitch 2016-03-08:; # Clearly this is a very simple operation in dense matrices; # It seems strange that there is nothing equivalent in sparse however,; # after much searching most threads suggest directly addressing; # the underlying arrays, as done here.; # This certainly proved more efficient than other methods such as stacking; #TODO: Perhaps cythonize and move to spmatfuncs. if not isinstance(A, sp.csr_matrix):; raise TypeError(""First parameter must be a csr matrix""); nrowin = A.shape[0]; ncolin = A.shape[1]; nrowout = nrowin*row_scale; ncolout = ncolin*col_scale. A._shape = (nrowout, ncolout); if insertcol == 0:; pass; elif insertcol > 0 and insertcol < col_scale:; A.indices = A.indices + insertcol*ncolin; else:; raise ValueError(""insertcol must be >= 0 and < col_scale""). if insertrow == 0:; A.indptr = np.concatenate((A.indptr,; np.array([A.indptr[-1]]*(row_scale-1)*nrowin))); elif insertrow == row_scale-1:; A.indptr = np.concatenate((np.array([0]*(row_scale - 1)*nrowin),; A.indptr)); elif insertrow > 0 and insertrow < row_scale - 1:; A.indptr = np.concatenate((np.array([0]*insertrow*nrowin), A.indptr,; np.array([A.indptr[-1]]*(row_scale - insertrow - 1)*nrowin))); else:; raise ValueError(""insertrow must be >= 0 and < row_scale""). return A. © Copyright 2011 and later, P.D. Nation, J.R. Johans",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:2486,Integrability,integrat,integrate,2486," ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides exact solvers for a system-bath setup using the; hierarchy equations of motion (HEOM).; """""". # Authors: Neill Lambert, Anubhav Vardhan, Alexander Pitchford; # Contact: nwlambert@gmail.com. import timeit; import numpy as np; #from scipy.special import factorial; import scipy.sparse as sp; import scipy.integrate; from copy import copy; from qutip import Qobj, qeye; from qutip.states import enr_state_dictionaries; from qutip.superoperator import liouvillian, spre, spost; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.solver import Options, Result, Stats; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.heom import cy_pad_csr; from qutip.cy.spmath import zcsr_kron; from qutip.fastsparse import fast_csr_matrix, fast_identity. [docs]class HEOMSolver(object):; """"""; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentia",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:7426,Integrability,integrat,integrate,7426,"lass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. - config; - integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:7765,Integrability,depend,depend,7765,"elf.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. - config; - integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the config",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:13424,Integrability,integrat,integrate,13424," L_he; N_he_interact += 1. he_state_neigh[k] = n_k. if n_excite <= N_c - 1:; # find the hierarchy element index of the neighbour after; # this element, for this Matsubara term; he_state_neigh[k] = n_k + 1; he_idx_neigh = he2idx[tuple(he_state_neigh)]. op = commQ; if renorm:; op = -1j*norm_plus[n_k, k]*op; else:; op = -1j*op. L_he = cy_pad_csr(op, N_he, N_he, he_idx, he_idx_neigh); L_helems += L_he; N_he_interact += 1. he_state_neigh[k] = n_k. if stats:; stats.add_timing('hierarchy contruct',; timeit.default_timer() - start_helem_constr,; ss_conf); stats.add_count('Num hierarchy elements', N_he, ss_conf); stats.add_count('Num he interactions', N_he_interact, ss_conf). # Setup Liouvillian; if stats:; start_louvillian = timeit.default_timer(). H_he = zcsr_kron(unit_helems, liouvillian(H_sys).data). L_helems += H_he. if stats:; stats.add_timing('Liouvillian contruct',; timeit.default_timer() - start_louvillian,; ss_conf). if stats: start_integ_conf = timeit.default_timer(). r = scipy.integrate.ode(cy_ode_rhs). r.set_f_params(L_helems.data, L_helems.indices, L_helems.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """"""",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:15498,Integrability,integrat,integrate,15498,".stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_integ, ss_run); if ss_run.total_time is None:; ss_run.total_time = time_now - start_run; else:; ss_run.total_time += time_now - start_run; stats.total_time = ss_conf.total_time + ss_run.total_time. return output. def _calc_matsubara_params(self):; """"""; Calculate the Matsubara coefficents and frequencies. Returns; -------; c, nu: both list(float). """"""; c = []; nu = []; lam0 = self.coup_strength; gam = self.cut_freq; hbar = self.planck; beta = 1.0/(self.boltzmann*self.temperature); N_m = self.N_exp. g = 2*np.pi / (beta*hbar); for k in range(N_m):; if k == 0:; nu.append(gam); c.append(lam0*gam*; (1.0/np.tan(gam*hbar*beta/2.0) - 1j) / hbar); else:; nu.append(k*g); c.append(4*lam0*gam*nu[k] /; ((nu[k]**2 - gam**2)*beta*hbar**2)). self.exp_coeff = c; self.exp_freq = nu; return c, nu. def _",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:15680,Integrability,integrat,integrate,15680,"meError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_integ, ss_run); if ss_run.total_time is None:; ss_run.total_time = time_now - start_run; else:; ss_run.total_time += time_now - start_run; stats.total_time = ss_conf.total_time + ss_run.total_time. return output. def _calc_matsubara_params(self):; """"""; Calculate the Matsubara coefficents and frequencies. Returns; -------; c, nu: both list(float). """"""; c = []; nu = []; lam0 = self.coup_strength; gam = self.cut_freq; hbar = self.planck; beta = 1.0/(self.boltzmann*self.temperature); N_m = self.N_exp. g = 2*np.pi / (beta*hbar); for k in range(N_m):; if k == 0:; nu.append(gam); c.append(lam0*gam*; (1.0/np.tan(gam*hbar*beta/2.0) - 1j) / hbar); else:; nu.append(k*g); c.append(4*lam0*gam*nu[k] /; ((nu[k]**2 - gam**2)*beta*hbar**2)). self.exp_coeff = c; self.exp_freq = nu; return c, nu. def _calc_renorm_factors(self):; """"""; Calculate the renormalisation factors. Returns; -------; norm_plus, norm_minus : array[N_c, N_m] of float; """"""; c = self.exp_coeff; N_m = self.N_exp; N_c = self.N_cu",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:4147,Modifiability,coupling,coupling,4147,"duction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve). This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate. There are opportunities to develop a more general spectral density code. Attributes; ----------; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmann's constant. options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms; """"""; def __init__(self):; raise ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:5627,Modifiability,config,configured,5627,"ess_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms; """"""; def __init__(self):; raise NotImplementedError(""This is a abstract class only. ""; ""Use a subclass, for example HSolverDL""). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; self.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_cut = 10; self.N_exp = 2; self.N_he = 0. self.exp_coeff = None; self.exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters; ----------; options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:5658,Modifiability,config,configure,5658,"ner for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms; """"""; def __init__(self):; raise NotImplementedError(""This is a abstract class only. ""; ""Use a subclass, for example HSolverDL""). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; self.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_cut = 10; self.N_exp = 2; self.N_he = 0. self.exp_coeff = None; self.exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters; ----------; options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.bolt",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:7416,Modifiability,config,config,7416,"lass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. - config; - integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:7458,Modifiability,config,config,7458,"lass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. - config; - integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:8104,Modifiability,coupling,coupling,8104," Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. - config; - integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:8741,Modifiability,config,configure,8741,"nfinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cu",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:8764,Modifiability,config,configure,8764,"ies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:9121,Modifiability,config,configure,9121,"_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; N_temp",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:9329,Modifiability,config,configure,9329,"_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; N_temp",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:9480,Modifiability,config,configure,9480,"f progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; N_temp = 1; for i in H_sys.dims[0]:; N_temp *= i; sup_dim = N_temp**2; unit_sys = qeye(N_temp). # Use shorthands (mainly as in referenced PRL); lam0 = self.coup_strength; gam = self.cut_freq; N_c = self.N_cut; N_m = self.N_exp; Q = coup_op # Q as shorthand for coupling operator; beta = 1.0/(s",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:10005,Modifiability,config,config,10005,"reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; N_temp = 1; for i in H_sys.dims[0]:; N_temp *= i; sup_dim = N_temp**2; unit_sys = qeye(N_temp). # Use shorthands (mainly as in referenced PRL); lam0 = self.coup_strength; gam = self.cut_freq; N_c = self.N_cut; N_m = self.N_exp; Q = coup_op # Q as shorthand for coupling operator; beta = 1.0/(self.boltzmann*self.temperature). # Ntot is the total number of ancillary elements in the hierarchy; # Ntot = factorial(N_c + N_m) / (factorial(N_c)*factorial(N_m)); # Turns out to be the same as nstates from state_number_enumerate; N_he, he2idx, idx2he = enr_state_dictionaries([N_c + 1]*N_m , N_c). unit_helems = fast_identity(N_he); if self.bnd_cut_approx:; # the Tanimura boundary cut off operator; if stats:; stats.add_message('options', 'boundary cutoff",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:10065,Modifiability,config,config,10065,"f.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; N_temp = 1; for i in H_sys.dims[0]:; N_temp *= i; sup_dim = N_temp**2; unit_sys = qeye(N_temp). # Use shorthands (mainly as in referenced PRL); lam0 = self.coup_strength; gam = self.cut_freq; N_c = self.N_cut; N_m = self.N_exp; Q = coup_op # Q as shorthand for coupling operator; beta = 1.0/(self.boltzmann*self.temperature). # Ntot is the total number of ancillary elements in the hierarchy; # Ntot = factorial(N_c + N_m) / (factorial(N_c)*factorial(N_m)); # Turns out to be the same as nstates from state_number_enumerate; N_he, he2idx, idx2he = enr_state_dictionaries([N_c + 1]*N_m , N_c). unit_helems = fast_identity(N_he); if self.bnd_cut_approx:; # the Tanimura boundary cut off operator; if stats:; stats.add_message('options', 'boundary cutoff approx', ss_conf); op = -2*spre(Q)*s",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:10536,Modifiability,coupling,coupling,10536,"mperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; N_temp = 1; for i in H_sys.dims[0]:; N_temp *= i; sup_dim = N_temp**2; unit_sys = qeye(N_temp). # Use shorthands (mainly as in referenced PRL); lam0 = self.coup_strength; gam = self.cut_freq; N_c = self.N_cut; N_m = self.N_exp; Q = coup_op # Q as shorthand for coupling operator; beta = 1.0/(self.boltzmann*self.temperature). # Ntot is the total number of ancillary elements in the hierarchy; # Ntot = factorial(N_c + N_m) / (factorial(N_c)*factorial(N_m)); # Turns out to be the same as nstates from state_number_enumerate; N_he, he2idx, idx2he = enr_state_dictionaries([N_c + 1]*N_m , N_c). unit_helems = fast_identity(N_he); if self.bnd_cut_approx:; # the Tanimura boundary cut off operator; if stats:; stats.add_message('options', 'boundary cutoff approx', ss_conf); op = -2*spre(Q)*spost(Q.dag()) + spre(Q.dag()*Q) + spost(Q.dag()*Q). approx_factr = ((2*lam0 / (beta*gam*hbar)) - 1j*lam0) / hbar; for k in range(N_m):; approx_factr -= (c[k] / nu[k]); L_bnd = -approx_factr*op.data; L_helems = zcsr_kron(unit_helems, L_bnd); else:; L_helems = fast_csr_matrix(shape=(N_he*sup_dim, N_he*sup_dim)). # Build the hierarchy element interaction matrix; if stats: start_helem_constr = timeit.default_timer(). unit_sup = spre(unit_sys).data; spreQ = spre(Q).da",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:14310,Modifiability,evolve,evolves,14310,"contruct',; timeit.default_timer() - start_louvillian,; ss_conf). if stats: start_integ_conf = timeit.default_timer(). r = scipy.integrate.ode(cy_ode_rhs). r.set_f_params(L_helems.data, L_helems.indices, L_helems.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """""". start_run = timeit.default_timer(). sup_dim = self._sup_dim; stats = self.stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('in",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:14588,Modifiability,config,configured,14588,"=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """""". start_run = timeit.default_timer(). sup_dim = self._sup_dim; stats = self.stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); outp",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:14660,Modifiability,config,config,14660,"max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """""". start_run = timeit.default_timer(). sup_dim = self._sup_dim; stats = self.stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:14714,Modifiability,config,config,14714,"max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """""". start_run = timeit.default_timer(). sup_dim = self._sup_dim; stats = self.stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:3904,Performance,perform,performance,3904,"n; from qutip.fastsparse import fast_csr_matrix, fast_identity. [docs]class HEOMSolver(object):; """"""; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve). This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate. There are opportunities to develop a more general spectral density code. Attributes; ----------; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmann's constant. options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics a",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:4836,Performance,perform,performance,4836,"odel, and there; are some performance advantages to assuming this model where it is; appropriate. There are opportunities to develop a more general spectral density code. Attributes; ----------; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmann's constant. options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms; """"""; def __init__(self):; raise NotImplementedError(""This is a abstract class only. ""; ""Use a subclass, for example HSolverDL""). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; self.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_cut = 10; self.N_exp = 2; self.N_he = 0. self.exp_coeff = None; self.exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using th",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:6474,Performance,perform,performance,6474,".exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters; ----------; options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. - config; - integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; retur",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:6306,Usability,progress bar,progress bar,6306,"f.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_cut = 10; self.N_exp = 2; self.N_he = 0. self.exp_coeff = None; self.exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters; ----------; options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object s",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:6353,Usability,progress bar,progress bar,6353,"f.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_cut = 10; self.N_exp = 2; self.N_he = 0. self.exp_coeff = None; self.exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters; ----------; options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object s",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html:17427,Usability,simpl,simple,17427,"c_renorm_factors(self):; """"""; Calculate the renormalisation factors. Returns; -------; norm_plus, norm_minus : array[N_c, N_m] of float; """"""; c = self.exp_coeff; N_m = self.N_exp; N_c = self.N_cut. norm_plus = np.empty((N_c+1, N_m)); norm_minus = np.empty((N_c+1, N_m)); for k in range(N_m):; for n in range(N_c+1):; norm_plus[n, k] = np.sqrt(abs(c[k])*(n + 1)); norm_minus[n, k] = np.sqrt(float(n)/abs(c[k])). return norm_plus, norm_minus. def _pad_csr(A, row_scale, col_scale, insertrow=0, insertcol=0):; """"""; Expand the input csr_matrix to a greater space as given by the scale.; Effectively inserting A into a larger matrix; zeros([A.shape[0]*row_scale, A.shape[1]*col_scale]; at the position [A.shape[0]*insertrow, A.shape[1]*insertcol]; The same could be achieved through using a kron with a matrix with; one element set to 1. However, this is more efficient; """""". # ajgpitch 2016-03-08:; # Clearly this is a very simple operation in dense matrices; # It seems strange that there is nothing equivalent in sparse however,; # after much searching most threads suggest directly addressing; # the underlying arrays, as done here.; # This certainly proved more efficient than other methods such as stacking; #TODO: Perhaps cythonize and move to spmatfuncs. if not isinstance(A, sp.csr_matrix):; raise TypeError(""First parameter must be a csr matrix""); nrowin = A.shape[0]; ncolin = A.shape[1]; nrowout = nrowin*row_scale; ncolout = ncolin*col_scale. A._shape = (nrowout, ncolout); if insertcol == 0:; pass; elif insertcol > 0 and insertcol < col_scale:; A.indices = A.indices + insertcol*ncolin; else:; raise ValueError(""insertcol must be >= 0 and < col_scale""). if insertrow == 0:; A.indptr = np.concatenate((A.indptr,; np.array([A.indptr[-1]]*(row_scale-1)*nrowin))); elif insertrow == row_scale-1:; A.indptr = np.concatenate((np.array([0]*(row_scale - 1)*nrowin),; A.indptr)); elif insertrow > 0 and insertrow < row_scale - 1:; A.indptr = np.concatenate((np.array([0]*insertrow*nrowin), A.indptr,;",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:3572,Deployability,integrat,integrator,3572,"s MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_mat",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:3759,Deployability,integrat,integrator,3759," :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:3833,Deployability,integrat,integrator,3833,"iouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = in",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:3990,Deployability,integrat,integrator,3990,"ors. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; -------",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:4806,Deployability,integrat,integrator,4806,"or'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:4819,Deployability,integrat,integrator,4819,"or'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:5557,Deployability,integrat,integrator,5557,"(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; r""""""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:5573,Deployability,integrat,integrator,5573,"elf.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; r""""""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; qu",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:5793,Deployability,integrat,integrator,5793,"ons.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; r""""""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specifi",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:5809,Deployability,integrat,integrator,5809,"grator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; r""""""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; elemen",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:8033,Deployability,integrat,integrator,8033," generalized partial trace is performed; and a propagator for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : fl",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:8049,Deployability,integrat,integrator,8049,"for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:8629,Deployability,integrat,integrator,8629," []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; r""""""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; Lis",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:8645,Deployability,integrat,integrator,8645,"append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; r""""""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (noth",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:12241,Deployability,integrat,integrator,12241,"ouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:12318,Deployability,integrat,integrator,12318,"ouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:12351,Deployability,integrat,integrator,12351,"ouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:12570,Deployability,integrat,integrator,12570,"ouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:12702,Deployability,integrat,integrator,12702,"ouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:12976,Deployability,update,updated,12976,"ouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:5375,Energy Efficiency,reduce,reduced,5375,"ce(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; r""""""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of correspon",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:8826,Energy Efficiency,reduce,reduced,8826,"; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; r""""""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators.",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:3572,Integrability,integrat,integrator,3572,"s MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_mat",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:3759,Integrability,integrat,integrator,3759," :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:3833,Integrability,integrat,integrator,3833,"iouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = in",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:3990,Integrability,integrat,integrator,3990,"ors. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; -------",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:4806,Integrability,integrat,integrator,4806,"or'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:4819,Integrability,integrat,integrator,4819,"or'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:5557,Integrability,integrat,integrator,5557,"(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; r""""""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:5573,Integrability,integrat,integrator,5573,"elf.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; r""""""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; qu",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:5793,Integrability,integrat,integrator,5793,"ons.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; r""""""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specifi",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:5809,Integrability,integrat,integrator,5809,"grator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; r""""""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; elemen",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:8033,Integrability,integrat,integrator,8033," generalized partial trace is performed; and a propagator for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : fl",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:8049,Integrability,integrat,integrator,8049,"for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:8629,Integrability,integrat,integrator,8629," []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; r""""""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; Lis",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:8645,Integrability,integrat,integrator,8645,"append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; r""""""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (noth",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:12241,Integrability,integrat,integrator,12241,"ouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:12318,Integrability,integrat,integrator,12318,"ouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:12351,Integrability,integrat,integrator,12351,"ouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:12570,Integrability,integrat,integrator,12570,"ouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:12702,Integrability,integrat,integrator,12702,"ouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:2906,Modifiability,coupling,coupling,2906,"LUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver op",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:3062,Modifiability,coupling,coupling,3062,"#############################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:;",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:11647,Modifiability,coupling,coupling,11647,".dims = op.dims; for i in range(1, l):; h = qt.tensor(I, h); for i in range(l+1, k+1):; h = qt.tensor(h, I); return h. def _genptrace(E, k):; """"""; Perform a gneralized partial trace on a superoperator E, tracing out all; subsystems but one.; """"""; for l in range(k-1):; nsys = len(E.dims[0][0]); E = qt.tensor_contract(E, (0, 2*nsys+1), (nsys, 3*nsys+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [],",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:5252,Performance,perform,performed,5252," qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; r""""""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:7034,Performance,perform,performed,7034,"ute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, i",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:2361,Usability,feedback,feedback,2361,"TRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to a",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:2724,Usability,feedback,feedback,2724,"S (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagato",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:2924,Usability,feedback,feedback,2924,"LUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver op",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:3082,Usability,feedback,feedback,3082,"#############################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:;",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:3289,Usability,feedback,feedback,3289,"s module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinst",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:7368,Usability,feedback,feedback,7368,"_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:7560,Usability,feedback,feedback,7560,"qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blis",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html:8243,Deployability,update,updated,8243,"ut. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; r""""""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html:2984,Usability,learn,learningtimes,2984,"AGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module contains an implementation of the non-Markovian transfer tensor; method (TTM), introduced in [1]. [1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014); """""". import numpy as np. from qutip import (Options, spre, vector_to_operator, operator_to_vector,; ket2dm, isket); from qutip.solver import Result; from qutip.expect import expect_rho_vec. [docs]class TTMSolverOptions:; """"""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of tim",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html:3048,Usability,learn,learning,3048,"AGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module contains an implementation of the non-Markovian transfer tensor; method (TTM), introduced in [1]. [1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014); """""". import numpy as np. from qutip import (Options, spre, vector_to_operator, operator_to_vector,; ket2dm, isket); from qutip.solver import Result; from qutip.expect import expect_rho_vec. [docs]class TTMSolverOptions:; """"""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of tim",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html:3317,Usability,learn,learningtimes,3317,"sfer tensor; method (TTM), introduced in [1]. [1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014); """""". import numpy as np. from qutip import (Options, spre, vector_to_operator, operator_to_vector,; ket2dm, isket); from qutip.solver import Result; from qutip.expect import expect_rho_vec. [docs]class TTMSolverOptions:; """"""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html:3454,Usability,learn,learningtimes,3454,"ptions, spre, vector_to_operator, operator_to_vector,; ket2dm, isket); from qutip.solver import Result; from qutip.expect import expect_rho_vec. [docs]class TTMSolverOptions:; """"""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dict",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html:3470,Usability,learn,learningtimes,3470,"ptions, spre, vector_to_operator, operator_to_vector,; ket2dm, isket); from qutip.solver import Result; from qutip.expect import expect_rho_vec. [docs]class TTMSolverOptions:; """"""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dict",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html:3598,Usability,learn,learningtimes,3598,"""""""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; output: :class:`qutip.solver.Result`; An instance of the class :class:`",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html:4266,Usability,learn,learningtimes,4266,"times=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; output: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`.; """""". opt = TTMSolverOptions(dynmaps=dynmaps, times=times,; learningtimes=learningtimes, **kwargs). diff = None. if isket(rho0):; rho0 = ket2dm(rho0). output = Result(); e_sops_data = []. if callable(e_ops):; n_expt_op = 0; expt_callback = True. else:; try:; tmp = e_ops[:]; del tmp. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; opt.store_states = True. for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(len(times))); else:; output.expect.append(np.zeros(len(times), dtype=complex)); except TypeError:; raise TypeError(""Argument 'e_ops' s",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html:4731,Usability,learn,learningtimes,4731," precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; output: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`.; """""". opt = TTMSolverOptions(dynmaps=dynmaps, times=times,; learningtimes=learningtimes, **kwargs). diff = None. if isket(rho0):; rho0 = ket2dm(rho0). output = Result(); e_sops_data = []. if callable(e_ops):; n_expt_op = 0; expt_callback = True. else:; try:; tmp = e_ops[:]; del tmp. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; opt.store_states = True. for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(len(times))); else:; output.expect.append(np.zeros(len(times), dtype=complex)); except TypeError:; raise TypeError(""Argument 'e_ops' should be a callable or"" +; ""list-like.""). if tensors is None:; tensors, diff = _generatetensors(dynmaps, learningtimes, opt=opt). if rho0.isoper:; # vectorize density matrix; rho0vec = operator_to_vector(rho0); else:; # rho0 might be a super in which case we should not vectorize; rho0vec = rho0. K = len(tensors); states = [rho0vec]; for n in range(1, len(times)):; states.append(None); for k in ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html:4745,Usability,learn,learningtimes,4745," precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; output: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`.; """""". opt = TTMSolverOptions(dynmaps=dynmaps, times=times,; learningtimes=learningtimes, **kwargs). diff = None. if isket(rho0):; rho0 = ket2dm(rho0). output = Result(); e_sops_data = []. if callable(e_ops):; n_expt_op = 0; expt_callback = True. else:; try:; tmp = e_ops[:]; del tmp. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; opt.store_states = True. for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(len(times))); else:; output.expect.append(np.zeros(len(times), dtype=complex)); except TypeError:; raise TypeError(""Argument 'e_ops' should be a callable or"" +; ""list-like.""). if tensors is None:; tensors, diff = _generatetensors(dynmaps, learningtimes, opt=opt). if rho0.isoper:; # vectorize density matrix; rho0vec = operator_to_vector(rho0); else:; # rho0 might be a super in which case we should not vectorize; rho0vec = rho0. K = len(tensors); states = [rho0vec]; for n in range(1, len(times)):; states.append(None); for k in ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html:5431,Usability,learn,learningtimes,5431,"tional list of precomputed tensors :math:`T_k`. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; output: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`.; """""". opt = TTMSolverOptions(dynmaps=dynmaps, times=times,; learningtimes=learningtimes, **kwargs). diff = None. if isket(rho0):; rho0 = ket2dm(rho0). output = Result(); e_sops_data = []. if callable(e_ops):; n_expt_op = 0; expt_callback = True. else:; try:; tmp = e_ops[:]; del tmp. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; opt.store_states = True. for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(len(times))); else:; output.expect.append(np.zeros(len(times), dtype=complex)); except TypeError:; raise TypeError(""Argument 'e_ops' should be a callable or"" +; ""list-like.""). if tensors is None:; tensors, diff = _generatetensors(dynmaps, learningtimes, opt=opt). if rho0.isoper:; # vectorize density matrix; rho0vec = operator_to_vector(rho0); else:; # rho0 might be a super in which case we should not vectorize; rho0vec = rho0. K = len(tensors); states = [rho0vec]; for n in range(1, len(times)):; states.append(None); for k in range(n):; if n-k < K:; states[-1] += tensors[n-k]*states[k]; for i, r in enumerate(states):; if opt.store_states or expt_callback:; if r.type == 'operator-ket':; states[i] = vector_to_operator(r); else:; states[i] = r; if expt_callback:; # use callback method; e_ops(times[i], states[i]); for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 0); else:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 1). output.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; r",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html:6378,Usability,learn,learningtimes,6378,"ynmaps, learningtimes, opt=opt). if rho0.isoper:; # vectorize density matrix; rho0vec = operator_to_vector(rho0); else:; # rho0 might be a super in which case we should not vectorize; rho0vec = rho0. K = len(tensors); states = [rho0vec]; for n in range(1, len(times)):; states.append(None); for k in range(n):; if n-k < K:; states[-1] += tensors[n-k]*states[k]; for i, r in enumerate(states):; if opt.store_states or expt_callback:; if r.type == 'operator-ket':; states[i] = vector_to_operator(r); else:; states[i] = r; if expt_callback:; # use callback method; e_ops(times[i], states[i]); for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 0); else:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 1). output.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; r""""""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html:6709,Usability,learn,learningtimes,6709,"ne); for k in range(n):; if n-k < K:; states[-1] += tensors[n-k]*states[k]; for i, r in enumerate(states):; if opt.store_states or expt_callback:; if r.type == 'operator-ket':; states[i] = vector_to_operator(r); else:; states[i] = r; if expt_callback:; # use callback method; e_ops(times[i], states[i]); for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 0); else:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 1). output.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; r""""""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = k",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html:6797,Usability,learn,learningtimes,6797,"ack:; if r.type == 'operator-ket':; states[i] = vector_to_operator(r); else:; states[i] = r; if expt_callback:; # use callback method; e_ops(times[i], states[i]); for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 0); else:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 1). output.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; r""""""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html:7191,Usability,learn,learningtimes,7191,"ut.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; r""""""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html:7242,Usability,learn,learnintimes,7242,"ut.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; r""""""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html:7346,Usability,learn,learningtimes,7346,"ut. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; r""""""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html:7376,Usability,learn,learningtimes,7376,"ut. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; r""""""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html:7654,Usability,learn,learningtimes,7654,"ut. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; r""""""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html:7668,Usability,learn,learningtimes,7668,"ut. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; r""""""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html:52511,Availability,avail,available,52511,"); elif (n-self.N) == measurement.classical_store:; store_tag = n - measurement.targets[0]; col.append(r"" \qw \cwx[%d] "" % store_tag); else:; col.append(r"" \qw ""). col.append(r"" \qw ""); rows.append(col). input_states_quantum = [r""\lstick{\ket{"" + x + ""}}"" if x is not None; else """" for x in self.input_states[:self.N]]; input_states_classical = [r""\lstick{"" + x + ""}"" if x is not None; else """" for x in self.input_states[self.N:]]; input_states = input_states_quantum + input_states_classical. code = """"; n_iter = (reversed(range(self.N+self.num_cbits)) if self.reverse_states; else range(self.N+self.num_cbits)); for n in n_iter:; code += r"" & %s"" % input_states[n]; for m in range(len(ops)):; code += r"" & %s"" % rows[m][n]; code += r"" & \qw \\ "" + ""\n"". return code. # This slightly convoluted dance with the conversion formats is because; # image conversion has optional dependencies. We always want the `png` and; # `svg` methods to be available so that they are discoverable by the user,; # however if one is called without the required dependency, then they'll; # get a `RuntimeError` explaining the problem. We only want the IPython; # magic methods `_repr_xxx_` to be defined if we know that the image; # conversion is available, so the user doesn't get exceptions on display; # because IPython tried to do something behind their back. def _raw_png(self):; return _latex.image_from_latex(self.latex_code(), ""png""). if 'png' in _latex.CONVERTERS:; _repr_png_ = _raw_png. @property; def png(self):; return DisplayImage(self._raw_png(), embed=True). def _raw_svg(self):; return _latex.image_from_latex(self.latex_code(), ""svg""). if 'svg' in _latex.CONVERTERS:; _repr_svg_ = _raw_svg. @property; def svg(self):; return DisplaySVG(self._raw_svg()). def _to_qasm(self, qasm_out):; """"""; Pipe output of circuit object to QasmOutput object. Parameters; ----------; qasm_out: QasmOutput; object to store QASM output.; """""". qasm_out.output(""qreg q[{}];"".format(self.N)); if self.num_cbits:; qasm_out.outp",MatchSource.WIKI,docs/4.6/modules/qutip/qip/circuit.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html
https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html:52798,Availability,avail,available,52798,"r""\lstick{\ket{"" + x + ""}}"" if x is not None; else """" for x in self.input_states[:self.N]]; input_states_classical = [r""\lstick{"" + x + ""}"" if x is not None; else """" for x in self.input_states[self.N:]]; input_states = input_states_quantum + input_states_classical. code = """"; n_iter = (reversed(range(self.N+self.num_cbits)) if self.reverse_states; else range(self.N+self.num_cbits)); for n in n_iter:; code += r"" & %s"" % input_states[n]; for m in range(len(ops)):; code += r"" & %s"" % rows[m][n]; code += r"" & \qw \\ "" + ""\n"". return code. # This slightly convoluted dance with the conversion formats is because; # image conversion has optional dependencies. We always want the `png` and; # `svg` methods to be available so that they are discoverable by the user,; # however if one is called without the required dependency, then they'll; # get a `RuntimeError` explaining the problem. We only want the IPython; # magic methods `_repr_xxx_` to be defined if we know that the image; # conversion is available, so the user doesn't get exceptions on display; # because IPython tried to do something behind their back. def _raw_png(self):; return _latex.image_from_latex(self.latex_code(), ""png""). if 'png' in _latex.CONVERTERS:; _repr_png_ = _raw_png. @property; def png(self):; return DisplayImage(self._raw_png(), embed=True). def _raw_svg(self):; return _latex.image_from_latex(self.latex_code(), ""svg""). if 'svg' in _latex.CONVERTERS:; _repr_svg_ = _raw_svg. @property; def svg(self):; return DisplaySVG(self._raw_svg()). def _to_qasm(self, qasm_out):; """"""; Pipe output of circuit object to QasmOutput object. Parameters; ----------; qasm_out: QasmOutput; object to store QASM output.; """""". qasm_out.output(""qreg q[{}];"".format(self.N)); if self.num_cbits:; qasm_out.output(""creg c[{}];"".format(self.num_cbits)); qasm_out.output(n=1). for op in self.gates:; if ((not isinstance(op, Measurement)); and not qasm_out.is_defined(op.name)):; qasm_out._qasm_defns(op). for op in self.gates:; op._to_qasm(q",MatchSource.WIKI,docs/4.6/modules/qutip/qip/circuit.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html
https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html:63962,Availability,avail,available,63962,"babilities.append(probability); cbits_results.append(self.cbits). return CircuitResult(states, probabilities, cbits_results). [docs] def step(self):; '''; Return state after one step of circuit evolution; (gate or measurement). Returns; -------; state : ket or oper; state after one evolution step.; '''. op = self.ops[self.op_index]; if isinstance(op, Measurement):; self._apply_measurement(op); elif isinstance(op, tuple):; operation, U = op; apply_gate = all([self.cbits[i] for i; in operation.classical_controls]); if apply_gate:; if self.precompute_unitary:; U = expand_operator(U, self.qc.N,; operation.get_inds(self.qc.N)); self._evolve_state(U); else:; self._evolve_state(op). self.op_index += 1; return self.state. def _evolve_state(self, U):; '''; Applies unitary to state. Parameters; ----------; U: Qobj; unitary to be applied.; '''. if self.mode == ""state_vector_simulator"":; self._evolve_ket(U); elif self.mode == ""density_matrix_simulator"":; self._evolve_dm(U); else:; raise NotImplementedError(; ""mode {} is not available."".format(self.mode)). def _evolve_ket(self, U):; '''; Applies unitary to ket state. Parameters; ----------; U: Qobj; unitary to be applied.; '''. self.state = U * self.state. def _evolve_dm(self, U):; '''; Applies unitary to density matrix state. Parameters; ----------; U: Qobj; unitary to be applied.; '''. self.state = U * self.state * U.dag(). def _apply_measurement(self, operation):; '''; Applies measurement gate specified by operation to current state. Parameters; ----------; operation: :class:`.Measurement`; Measurement gate in a circuit object.; '''. states, probabilities = operation.measurement_comp_basis(self.state). if self.mode == ""state_vector_simulator"":; if self.measure_results:; i = int(self.measure_results[self.measure_ind]); self.measure_ind += 1; else:; probabilities = [p/sum(probabilities) for p in probabilities]; i = np.random.choice([0, 1], p=probabilities); self.probability *= probabilities[i]; self.state = states[i]; if operat",MatchSource.WIKI,docs/4.6/modules/qutip/qip/circuit.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html
https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html:65292,Availability,avail,available,65292,"(op). self.op_index += 1; return self.state. def _evolve_state(self, U):; '''; Applies unitary to state. Parameters; ----------; U: Qobj; unitary to be applied.; '''. if self.mode == ""state_vector_simulator"":; self._evolve_ket(U); elif self.mode == ""density_matrix_simulator"":; self._evolve_dm(U); else:; raise NotImplementedError(; ""mode {} is not available."".format(self.mode)). def _evolve_ket(self, U):; '''; Applies unitary to ket state. Parameters; ----------; U: Qobj; unitary to be applied.; '''. self.state = U * self.state. def _evolve_dm(self, U):; '''; Applies unitary to density matrix state. Parameters; ----------; U: Qobj; unitary to be applied.; '''. self.state = U * self.state * U.dag(). def _apply_measurement(self, operation):; '''; Applies measurement gate specified by operation to current state. Parameters; ----------; operation: :class:`.Measurement`; Measurement gate in a circuit object.; '''. states, probabilities = operation.measurement_comp_basis(self.state). if self.mode == ""state_vector_simulator"":; if self.measure_results:; i = int(self.measure_results[self.measure_ind]); self.measure_ind += 1; else:; probabilities = [p/sum(probabilities) for p in probabilities]; i = np.random.choice([0, 1], p=probabilities); self.probability *= probabilities[i]; self.state = states[i]; if operation.classical_store is not None:; self.cbits[operation.classical_store] = i. elif self.mode == ""density_matrix_simulator"":; states = list(filter(lambda x: x is not None, states)); probabilities = list(filter(lambda x: x != 0, probabilities)); self.state = sum(p * s for s, p in zip(states, probabilities)); else:; raise NotImplementedError(; ""mode {} is not available."".format(self.mode)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/circuit.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html
https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html:65512,Deployability,update,updated,65512,"(op). self.op_index += 1; return self.state. def _evolve_state(self, U):; '''; Applies unitary to state. Parameters; ----------; U: Qobj; unitary to be applied.; '''. if self.mode == ""state_vector_simulator"":; self._evolve_ket(U); elif self.mode == ""density_matrix_simulator"":; self._evolve_dm(U); else:; raise NotImplementedError(; ""mode {} is not available."".format(self.mode)). def _evolve_ket(self, U):; '''; Applies unitary to ket state. Parameters; ----------; U: Qobj; unitary to be applied.; '''. self.state = U * self.state. def _evolve_dm(self, U):; '''; Applies unitary to density matrix state. Parameters; ----------; U: Qobj; unitary to be applied.; '''. self.state = U * self.state * U.dag(). def _apply_measurement(self, operation):; '''; Applies measurement gate specified by operation to current state. Parameters; ----------; operation: :class:`.Measurement`; Measurement gate in a circuit object.; '''. states, probabilities = operation.measurement_comp_basis(self.state). if self.mode == ""state_vector_simulator"":; if self.measure_results:; i = int(self.measure_results[self.measure_ind]); self.measure_ind += 1; else:; probabilities = [p/sum(probabilities) for p in probabilities]; i = np.random.choice([0, 1], p=probabilities); self.probability *= probabilities[i]; self.state = states[i]; if operation.classical_store is not None:; self.cbits[operation.classical_store] = i. elif self.mode == ""density_matrix_simulator"":; states = list(filter(lambda x: x is not None, states)); probabilities = list(filter(lambda x: x != 0, probabilities)); self.state = sum(p * s for s, p in zip(states, probabilities)); else:; raise NotImplementedError(; ""mode {} is not available."".format(self.mode)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/circuit.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html
https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html:51565,Energy Efficiency,meter,meter,51565,"append(r"" \targ ""); elif gate.name == ""CT"":; col.append(r"" \targ ""); elif gate.name == ""TOFFOLI"":; col.append(r"" \targ ""); else:; col.append(r"" \gate{%s} "" %; _gate_label(gate.name, gate.arg_label)). elif gate.controls and n in gate.controls:; control_tag = (-1 if; self.reverse_states; else 1) * (gate.targets[0] - n); col.append(r"" \ctrl{%d} "" % control_tag). elif (gate.classical_controls and; (n - self.N) in gate.classical_controls):; control_tag = n - gate.targets[0]; col.append(r"" \ctrl{%d} "" % control_tag). elif (not gate.controls and not gate.targets):; # global gate; if ((self.reverse_states and n == self.N - 1) or; (not self.reverse_states and n == 0)):; col.append(r"" \multigate{%d}{%s} "" %; (self.N - 1,; _gate_label(gate.name,; gate.arg_label))); else:; col.append(r"" \ghost{%s} "" %; (_gate_label(gate.name,; gate.arg_label))); else:; col.append(r"" \qw ""). else:; measurement = op; col = []; for n in range(self.N+self.num_cbits):. if n in measurement.targets:; col.append(r"" \meter""); elif (n-self.N) == measurement.classical_store:; store_tag = n - measurement.targets[0]; col.append(r"" \qw \cwx[%d] "" % store_tag); else:; col.append(r"" \qw ""). col.append(r"" \qw ""); rows.append(col). input_states_quantum = [r""\lstick{\ket{"" + x + ""}}"" if x is not None; else """" for x in self.input_states[:self.N]]; input_states_classical = [r""\lstick{"" + x + ""}"" if x is not None; else """" for x in self.input_states[self.N:]]; input_states = input_states_quantum + input_states_classical. code = """"; n_iter = (reversed(range(self.N+self.num_cbits)) if self.reverse_states; else range(self.N+self.num_cbits)); for n in n_iter:; code += r"" & %s"" % input_states[n]; for m in range(len(ops)):; code += r"" & %s"" % rows[m][n]; code += r"" & \qw \\ "" + ""\n"". return code. # This slightly convoluted dance with the conversion formats is because; # image conversion has optional dependencies. We always want the `png` and; # `svg` methods to be available so that they are discoverable by the user,; # howe",MatchSource.WIKI,docs/4.6/modules/qutip/qip/circuit.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html
https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html:52445,Integrability,depend,dependencies,52445,"ate.arg_label))); else:; col.append(r"" \qw ""). else:; measurement = op; col = []; for n in range(self.N+self.num_cbits):. if n in measurement.targets:; col.append(r"" \meter""); elif (n-self.N) == measurement.classical_store:; store_tag = n - measurement.targets[0]; col.append(r"" \qw \cwx[%d] "" % store_tag); else:; col.append(r"" \qw ""). col.append(r"" \qw ""); rows.append(col). input_states_quantum = [r""\lstick{\ket{"" + x + ""}}"" if x is not None; else """" for x in self.input_states[:self.N]]; input_states_classical = [r""\lstick{"" + x + ""}"" if x is not None; else """" for x in self.input_states[self.N:]]; input_states = input_states_quantum + input_states_classical. code = """"; n_iter = (reversed(range(self.N+self.num_cbits)) if self.reverse_states; else range(self.N+self.num_cbits)); for n in n_iter:; code += r"" & %s"" % input_states[n]; for m in range(len(ops)):; code += r"" & %s"" % rows[m][n]; code += r"" & \qw \\ "" + ""\n"". return code. # This slightly convoluted dance with the conversion formats is because; # image conversion has optional dependencies. We always want the `png` and; # `svg` methods to be available so that they are discoverable by the user,; # however if one is called without the required dependency, then they'll; # get a `RuntimeError` explaining the problem. We only want the IPython; # magic methods `_repr_xxx_` to be defined if we know that the image; # conversion is available, so the user doesn't get exceptions on display; # because IPython tried to do something behind their back. def _raw_png(self):; return _latex.image_from_latex(self.latex_code(), ""png""). if 'png' in _latex.CONVERTERS:; _repr_png_ = _raw_png. @property; def png(self):; return DisplayImage(self._raw_png(), embed=True). def _raw_svg(self):; return _latex.image_from_latex(self.latex_code(), ""svg""). if 'svg' in _latex.CONVERTERS:; _repr_svg_ = _raw_svg. @property; def svg(self):; return DisplaySVG(self._raw_svg()). def _to_qasm(self, qasm_out):; """"""; Pipe output of circuit object to QasmOut",MatchSource.WIKI,docs/4.6/modules/qutip/qip/circuit.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html
https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html:52613,Integrability,depend,dependency,52613,"); elif (n-self.N) == measurement.classical_store:; store_tag = n - measurement.targets[0]; col.append(r"" \qw \cwx[%d] "" % store_tag); else:; col.append(r"" \qw ""). col.append(r"" \qw ""); rows.append(col). input_states_quantum = [r""\lstick{\ket{"" + x + ""}}"" if x is not None; else """" for x in self.input_states[:self.N]]; input_states_classical = [r""\lstick{"" + x + ""}"" if x is not None; else """" for x in self.input_states[self.N:]]; input_states = input_states_quantum + input_states_classical. code = """"; n_iter = (reversed(range(self.N+self.num_cbits)) if self.reverse_states; else range(self.N+self.num_cbits)); for n in n_iter:; code += r"" & %s"" % input_states[n]; for m in range(len(ops)):; code += r"" & %s"" % rows[m][n]; code += r"" & \qw \\ "" + ""\n"". return code. # This slightly convoluted dance with the conversion formats is because; # image conversion has optional dependencies. We always want the `png` and; # `svg` methods to be available so that they are discoverable by the user,; # however if one is called without the required dependency, then they'll; # get a `RuntimeError` explaining the problem. We only want the IPython; # magic methods `_repr_xxx_` to be defined if we know that the image; # conversion is available, so the user doesn't get exceptions on display; # because IPython tried to do something behind their back. def _raw_png(self):; return _latex.image_from_latex(self.latex_code(), ""png""). if 'png' in _latex.CONVERTERS:; _repr_png_ = _raw_png. @property; def png(self):; return DisplayImage(self._raw_png(), embed=True). def _raw_svg(self):; return _latex.image_from_latex(self.latex_code(), ""svg""). if 'svg' in _latex.CONVERTERS:; _repr_svg_ = _raw_svg. @property; def svg(self):; return DisplaySVG(self._raw_svg()). def _to_qasm(self, qasm_out):; """"""; Pipe output of circuit object to QasmOutput object. Parameters; ----------; qasm_out: QasmOutput; object to store QASM output.; """""". qasm_out.output(""qreg q[{}];"".format(self.N)); if self.num_cbits:; qasm_out.outp",MatchSource.WIKI,docs/4.6/modules/qutip/qip/circuit.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html
https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html:16582,Modifiability,variab,variable,16582,"interpreted to be; 2 ** len(classical_controls) - 1; (i.e. all classical controls are 1).; """""". if isinstance(gate, Gate):; name = gate.name; targets = gate.targets; controls = gate.controls; arg_value = gate.arg_value; arg_label = gate.arg_label; classical_controls = gate.classical_controls; control_value = gate.control_value. else:; name = gate. if index is None:; gate = Gate(name, targets=targets, controls=controls,; arg_value=arg_value, arg_label=arg_label,; classical_controls=classical_controls,; control_value=control_value); self.gates.append(gate). else:; for position in index:; num_mes = (sum(isinstance(op, Measurement) for op; in self.gates[:position])); gate = Gate(name, targets=targets, controls=controls,; arg_value=arg_value, arg_label=arg_label,; classical_controls=classical_controls,; control_value=control_value); self.gates.insert(position, gate). [docs] def add_1q_gate(self, name, start=0, end=None, qubits=None,; arg_value=None, arg_label=None,; classical_controls=None, control_value=None):; """"""; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters; ----------; name : string; Gate name.; start : int; Starting location of qubits.; end : int; Last qubit for the gate.; qubits : list; Specific qubits for applying gates.; arg_value : float; Argument value(phi).; arg_label : string; Label for gate representation.; """"""; if name not in [""RX"", ""RY"", ""RZ"", ""SNOT"", ""SQRTNOT"", ""PHASEGATE"",; ""X"", ""Y"", ""Z"", ""S"", ""T"", ""QASMU""]:; raise ValueError(""%s is not a single qubit gate"" % name). if qubits is not None:; for _, i in enumerate(qubits):; gate = Gate(name, targets=qubits[i], controls=None,; arg_value=arg_value, arg_label=arg_label,; classical_controls=classical_controls,; control_value=control_value); self.gates.append(gate). else:; if end is None:; end = self.N - 1; for i in range(start, end+1):; gate = Gate(name, targets=i, controls",MatchSource.WIKI,docs/4.6/modules/qutip/qip/circuit.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html
https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html:45885,Modifiability,variab,variable,45885,"rgets[0])); elif gate.name == ""CSIGN"":; self.U_list.append(csign(self.N,; gate.controls[0], gate.targets[0])); elif gate.name == ""BERKELEY"":; self.U_list.append(berkeley(self.N, gate.targets)); elif gate.name == ""SWAPalpha"":; self.U_list.append(swapalpha(gate.arg_value, self.N,; gate.targets)); elif gate.name == ""SWAP"":; self.U_list.append(swap(self.N, gate.targets)); elif gate.name == ""ISWAP"":; self.U_list.append(iswap(self.N, gate.targets)); elif gate.name == ""SQRTSWAP"":; self.U_list.append(sqrtswap(self.N, gate.targets)); elif gate.name == ""SQRTISWAP"":; self.U_list.append(sqrtiswap(self.N, gate.targets)); elif gate.name == ""FREDKIN"":; self.U_list.append(fredkin(self.N, gate.controls[0],; gate.targets)); elif gate.name == ""TOFFOLI"":; self.U_list.append(toffoli(self.N, gate.controls,; gate.targets[0])); elif gate.name == ""GLOBALPHASE"":; self.U_list.append(globalphase(gate.arg_value, self.N)); elif gate.name in self.user_gates:; if gate.controls is not None:; raise ValueError(""A user defined gate {} takes only ""; ""`targets` variable."".format(gate.name)); func_or_oper = self.user_gates[gate.name]; if inspect.isfunction(func_or_oper):; func = func_or_oper; para_num = len(inspect.getfullargspec(func)[0]); if para_num == 0:; oper = func(); elif para_num == 1:; oper = func(gate.arg_value); else:; raise ValueError(; ""gate function takes at most one parameters.""); elif isinstance(func_or_oper, Qobj):; oper = func_or_oper; else:; raise ValueError(""gate is neither function nor operator""); self.U_list.append(expand_operator(; oper, N=self.N, targets=gate.targets, dims=self.dims)); else:; raise NotImplementedError(; ""{} gate is an unknown gate."".format(gate.name)). return self.U_list. [docs] def propagators_no_expand(self):; """"""; Propagator matrix calculator for N qubits returning the individual; steps as unitary matrices operating from left to right. Returns; -------; U_list : list; Return list of unitary matrices for the qubit circuit. """"""; self.U_list = []. gates = filter(l",MatchSource.WIKI,docs/4.6/modules/qutip/qip/circuit.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html
https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html:49023,Modifiability,variab,variable,49023,"ist.append(controlled_gate(ry(gate.arg_value))); elif gate.name == ""CRZ"":; self.U_list.append(controlled_gate(rz(gate.arg_value))); elif gate.name == ""CPHASE"":; self.U_list.append(cphase(gate.arg_value)); elif gate.name == ""CNOT"":; self.U_list.append(cnot()); elif gate.name == ""CSIGN"":; self.U_list.append(csign()); elif gate.name == ""BERKELEY"":; self.U_list.append(berkeley()); elif gate.name == ""SWAPalpha"":; self.U_list.append(swapalpha(gate.arg_value)); elif gate.name == ""SWAP"":; self.U_list.append(swap()); elif gate.name == ""ISWAP"":; self.U_list.append(iswap()); elif gate.name == ""SQRTSWAP"":; self.U_list.append(sqrtswap()); elif gate.name == ""SQRTISWAP"":; self.U_list.append(sqrtiswap()); elif gate.name == ""FREDKIN"":; self.U_list.append(fredkin()); elif gate.name == ""TOFFOLI"":; self.U_list.append(toffoli()); elif gate.name == ""GLOBALPHASE"":; self.U_list.append(globalphase(gate.arg_value, n)); elif gate.name in self.user_gates:; if gate.controls is not None:; raise ValueError(""A user defined gate {} takes only ""; ""`targets` variable."".format(gate.name)); func_or_oper = self.user_gates[gate.name]; if inspect.isfunction(func_or_oper):; func = func_or_oper; para_num = len(inspect.getfullargspec(func)[0]); if para_num == 0:; oper = func(); elif para_num == 1:; oper = func(gate.arg_value); else:; raise ValueError(; ""gate function takes at most one parameters.""); elif isinstance(func_or_oper, Qobj):; oper = func_or_oper; else:; raise ValueError(""gate is neither function nor operator""); self.U_list.append(oper); else:; raise NotImplementedError(; ""{} gate is an unknown gate."".format(gate.name)). return self.U_list. def latex_code(self):; rows = []. ops = self.gates; col = []; for op in ops:; if isinstance(op, Gate):; gate = op; col = []; _swap_processing = False; for n in range(self.N+self.num_cbits):. if gate.targets and n in gate.targets:. if len(gate.targets) > 1:; if gate.name == ""SWAP"":; if _swap_processing:; col.append(r"" \qswap \qw""); continue; distance = abs(; gate",MatchSource.WIKI,docs/4.6/modules/qutip/qip/circuit.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html
https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html:59693,Modifiability,variab,variables,59693,"ement):; continue; else:; self.inds_list.append(gate.get_inds(self.qc.N)). for operation in self.qc.gates:; if isinstance(operation, Measurement):; if U_list_index > prev_index:; self.ops.append(self._compute_unitary(; self.U_list[prev_index:U_list_index],; self.inds_list[prev_index:U_list_index])); prev_index = U_list_index; self.ops.append(operation). elif isinstance(operation, Gate):; if operation.classical_controls:; if U_list_index > prev_index:; self.ops.append(; self._compute_unitary(; self.U_list[prev_index:U_list_index],; self.inds_list[prev_index:U_list_index])); prev_index = U_list_index; self.ops.append((operation, self.U_list[prev_index])); prev_index += 1; U_list_index += 1; else:; U_list_index += 1. if U_list_index > prev_index:; self.ops.append(self._compute_unitary(; self.U_list[prev_index:U_list_index],; self.inds_list[prev_index:U_list_index])); prev_index = U_list_index + 1; U_list_index = prev_index. [docs] def initialize(self, state=None, cbits=None, measure_results=None):; '''; Reset Simulator state variables to start a new run. Parameters; ----------; state: ket or oper; ket or density matrix. cbits: list of int, optional; initial value of classical bits. U_list: list of Qobj, optional; list of predefined unitaries corresponding to circuit. measure_results : tuple of ints, optional; optional specification of each measurement result to enable; post-selection. If specified, the measurement results are; set to the tuple of bits (sequentially) instead of being; chosen at random.; '''. if cbits and len(cbits) == self.qc.num_cbits:; self.cbits = cbits; elif self.qc.num_cbits > 0:; self.cbits = [0] * self.qc.num_cbits; else:; self.cbits = None. self.state = None. if state is not None:; if state.shape[0] != 2 ** self.qc.N:; raise ValueError(""dimension of state is incorrect""); if self.mode == ""density_matrix_simulator"" and state.isket:; self.state = ket2dm(state); else:; self.state = state. self.probability = 1; self.op_index = 0; self.measure_results ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/circuit.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html
https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html:2944,Usability,simpl,simple,2944,"EGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections.abc import Iterable; from itertools import product; import numbers. import warnings; import inspect. import numpy as np; from copy import deepcopy. from qutip.qip import circuit_latex as _latex; from qutip.qip.operations.gates import (rx, ry, rz, sqrtnot, snot, phasegate,; x_gate, y_gate, z_gate, cy_gate,; cz_gate, s_gate, t_gate, cs_gate,; qasmu_gate, ct_gate, cphase, cnot,; csign, berkeley, swapalpha, swap,; iswap, sqrtswap, sqrtiswap, fredkin,; toffoli, controlled_gate, globalphase,; expand_operator, gate_sequence_product); from qutip import tensor, basis, identity, ket2dm; from qutip.qobj import Qobj; from qutip.measurement import measurement_statistics. try:; from IPython.display import Image as DisplayImage, SVG as DisplaySVG; except ImportError:; # If IPython doesn't exist, then we set the nice display hooks to be simple; # pass-throughs.; def DisplayImage(data, *args, **kwargs):; return data. def DisplaySVG(data, *args, **kwargs):; return data. __all__ = ['Gate', 'QubitCircuit', 'Measurement',; 'CircuitResult', 'CircuitSimulator']. _single_qubit_gates = [""RX"", ""RY"", ""RZ"", ""SNOT"", ""SQRTNOT"", ""PHASEGATE"",; ""X"", ""Y"", ""Z"", ""S"", ""T"", ""QASMU""]; _para_gates = [""RX"", ""RY"", ""RZ"", ""CPHASE"", ""SWAPalpha"", ""PHASEGATE"",; ""GLOBALPHASE"", ""CRX"", ""CRY"", ""CRZ"", ""QASMU""]; _ctrl_gates = [""CNOT"", ""CSIGN"", ""CRX"", ""CRY"", ""CRZ"", ""CY"", ""CZ"",; ""CS"", ""CT"", ""CPHASE""]; _swap_like = [""SWAP"", ""ISWAP"", ""SQRTISWAP"", ""SQRTSWAP"", ""BERKELEY"",; ""SWAPalpha""]; _toffoli_like = [""TOFFOLI""]; _fredkin_like = [""FREDKIN""]. [docs]class Gate:; """"""; Representation of a quantum gate, with its required parametrs, and target; and control qubits. Parameters; ----------; name : string; Gate name.; targets : list or int; Gate targets.; controls : list or int; Gate controls.; arg_value : f",MatchSource.WIKI,docs/4.6/modules/qutip/qip/circuit.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html
https://qutip.org/docs/4.6/modules/qutip/qip/noise.html:3197,Availability,error,error,3197,"ic_noise). if device_noise:; return noisy_pulses + [systematic_noise]; else:; return noisy_pulses. [docs]class Noise(object):; """"""; The base class representing noise in a processor.; The noise object can be added to :class:`.Processor` and; contributes to evolution.; """"""; def __init__(self):; pass. [docs] def get_noisy_dynamics(self, dims, pulses, systematic_noise):; """"""; Return a pulses list added with noise and; the pulse independent noise in a dummy Pulse object. Parameters; ----------; dims: list, optional; The dimension of the components system, the default value is; [2,2...,2] for qubits system. pulses: list of :class:`.Pulse`; The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`; The dummy pulse with no ideal control element. Returns; -------; noisy_pulses: list of :class:`.Pulse`; Noisy pulses. systematic_noise: :class:`.Pulse`; The dummy pulse representing pulse independent noise.; """"""; raise NotImplementedError(; ""Subclass error needs a method""; ""`get_noisy_dynamics` to process the noise.""). def _apply_noise(self, pulses=None, systematic_noise=None, dims=None):; """"""; For backward compatibility, in case the method has no return value; or only return the pulse.; """"""; result = self.get_noisy_dynamics(; pulses=pulses, systematic_noise=systematic_noise, dims=dims); if result is None: # in-place change; pass; elif isinstance(result, tuple) and len(result) == 2:; pulses, systematic_noise = result; # only pulse; elif isinstance(result, list) and len(result) == len(pulses):; pulses = result; else:; raise TypeError(; ""Returned value of get_noisy_dynamics not understood.""); return pulses, systematic_noise. [docs]class DecoherenceNoise(Noise):; """"""; The decoherence noise in a processor. It generates lindblad noise; according to the given collapse operator `c_ops`. Parameters; ----------; c_ops: :class:`qutip.Qobj` or list; The Hamiltonian representing the dynamics of the noise.; targets: int or list, optional; The indices of q",MatchSource.WIKI,docs/4.6/modules/qutip/qip/noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/noise.html
https://qutip.org/docs/4.6/modules/qutip/qip/noise.html:8638,Availability,avail,available,8638,"1) != N or len(self.t2) != N:; raise ValueError(; ""Length of t1 or t2 does not match N, ""; ""len(t1)={}, len(t2)={}"".format(; len(self.t1), len(self.t2))). if self.targets is None:; targets = range(N); else:; targets = self.targets; for qu_ind in targets:; t1 = self.t1[qu_ind]; t2 = self.t2[qu_ind]; if t1 is not None:; op = 1/np.sqrt(t1) * destroy(dims[qu_ind]); systematic_noise.add_lindblad_noise(op, qu_ind, coeff=True); if t2 is not None:; # Keep the total dephasing ~ exp(-t/t2); if t1 is not None:; if 2*t1 < t2:; raise ValueError(; ""t1={}, t2={} does not fulfill ""; ""2*t1>t2"".format(t1, t2)); T2_eff = 1./(1./t2-1./2./t1); else:; T2_eff = t2; op = 1/np.sqrt(2*T2_eff) * 2 * num(dims[qu_ind]); systematic_noise.add_lindblad_noise(op, qu_ind, coeff=True); return pulses, systematic_noise. [docs]class ControlAmpNoise(Noise):; """"""; The noise in the amplitude of the control pulse. Parameters; ----------; coeff: list; A list of the coefficients for the control Hamiltonians.; For available choices, see :class:`qutip.QobjEvo`.; tlist: array_like, optional; A NumPy array specifies the time of each coefficient.; indices: list of int, optional; The indices of target pulse in the list of pulses.; Attributes; ----------; coeff: list; A list of the coefficients for the control Hamiltonians.; For available choices, see :class:`qutip.QobjEvo`.; tlist: array_like; A NumPy array specifies the time of each coefficient.; indices: list of int; The indices of target pulse in the list of pulses. """"""; def __init__(self, coeff, tlist=None, indices=None):; self.coeff = coeff; self.tlist = tlist; self.indices = indices. [docs] def get_noisy_dynamics(; self, dims=None, pulses=None, systematic_noise=None):; if pulses is None:; pulses = []; if self.indices is None:; indices = range(len(pulses)); else:; indices = self.indices; for i in indices:; pulse = pulses[i]; if isinstance(self.coeff, (int, float)):; coeff = pulse.coeff * self.coeff; else:; coeff = self.coeff; if self.tlist is None:; tlist = pul",MatchSource.WIKI,docs/4.6/modules/qutip/qip/noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/noise.html
https://qutip.org/docs/4.6/modules/qutip/qip/noise.html:8953,Availability,avail,available,8953,"ne:; op = 1/np.sqrt(t1) * destroy(dims[qu_ind]); systematic_noise.add_lindblad_noise(op, qu_ind, coeff=True); if t2 is not None:; # Keep the total dephasing ~ exp(-t/t2); if t1 is not None:; if 2*t1 < t2:; raise ValueError(; ""t1={}, t2={} does not fulfill ""; ""2*t1>t2"".format(t1, t2)); T2_eff = 1./(1./t2-1./2./t1); else:; T2_eff = t2; op = 1/np.sqrt(2*T2_eff) * 2 * num(dims[qu_ind]); systematic_noise.add_lindblad_noise(op, qu_ind, coeff=True); return pulses, systematic_noise. [docs]class ControlAmpNoise(Noise):; """"""; The noise in the amplitude of the control pulse. Parameters; ----------; coeff: list; A list of the coefficients for the control Hamiltonians.; For available choices, see :class:`qutip.QobjEvo`.; tlist: array_like, optional; A NumPy array specifies the time of each coefficient.; indices: list of int, optional; The indices of target pulse in the list of pulses.; Attributes; ----------; coeff: list; A list of the coefficients for the control Hamiltonians.; For available choices, see :class:`qutip.QobjEvo`.; tlist: array_like; A NumPy array specifies the time of each coefficient.; indices: list of int; The indices of target pulse in the list of pulses. """"""; def __init__(self, coeff, tlist=None, indices=None):; self.coeff = coeff; self.tlist = tlist; self.indices = indices. [docs] def get_noisy_dynamics(; self, dims=None, pulses=None, systematic_noise=None):; if pulses is None:; pulses = []; if self.indices is None:; indices = range(len(pulses)); else:; indices = self.indices; for i in indices:; pulse = pulses[i]; if isinstance(self.coeff, (int, float)):; coeff = pulse.coeff * self.coeff; else:; coeff = self.coeff; if self.tlist is None:; tlist = pulse.tlist; else:; tlist = self.tlist; pulses[i].add_coherent_noise(; pulse.qobj, pulse.targets, tlist, coeff); return pulses, systematic_noise. [docs]class RandomNoise(ControlAmpNoise):; """"""; Random noise in the amplitude of the control pulse. The arguments for; the random generator need to be given as key word arg",MatchSource.WIKI,docs/4.6/modules/qutip/qip/noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/noise.html
https://qutip.org/docs/4.6/modules/qutip/qip/noise.html:11813,Availability,error,error,11813," indices of target pulse in the list of pulses.; **kwargs:; Key word arguments for the random number generator. Attributes; ----------; dt: float, optional; The time interval between two random amplitude. The coefficients; of the noise are the same within this time range.; rand_gen: numpy.random, optional; A random generator in numpy.random, it has to take a ``size``; parameter.; indices: list of int; The indices of target pulse in the list of pulses.; **kwargs:; Key word arguments for the random number generator. Examples; --------; >>> gaussnoise = RandomNoise( \; dt=0.1, rand_gen=np.random.normal, loc=mean, scale=std) \; # doctest: +SKIP; """"""; def __init__(; self, dt, rand_gen, indices=None, **kwargs):; super(RandomNoise, self).__init__(coeff=None, tlist=None); self.rand_gen = rand_gen; self.kwargs = kwargs; if ""size"" in kwargs:; raise ValueError(""size is preditermined inside the noise object.""); self.dt = dt; self.indices = indices. [docs] def get_noisy_dynamics(; self, dims=None, pulses=None, systematic_noise=None):; if pulses is None:; pulses = []; if self.indices is None:; indices = range(len(pulses)); else:; indices = self.indices; t_max = -np.inf; t_min = np.inf; for pulse in pulses:; t_max = max(max(pulse.tlist), t_max); t_min = min(min(pulse.tlist), t_min); # create new tlist and random coeff; num_rand = int(np.floor((t_max - t_min) / self.dt)) + 1; tlist = (np.arange(0, self.dt*num_rand, self.dt)[:num_rand] + t_min); # [:num_rand] for round of error like 0.2*6=1.2000000000002. for i in indices:; pulse = pulses[i]; coeff = self.rand_gen(**self.kwargs, size=num_rand); pulses[i].add_coherent_noise(; pulse.qobj, pulse.targets, tlist, coeff); return pulses, systematic_noise. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/noise.html
https://qutip.org/docs/4.6/modules/qutip/qip/noise.html:12232,Deployability,update,updated,12232," indices of target pulse in the list of pulses.; **kwargs:; Key word arguments for the random number generator. Attributes; ----------; dt: float, optional; The time interval between two random amplitude. The coefficients; of the noise are the same within this time range.; rand_gen: numpy.random, optional; A random generator in numpy.random, it has to take a ``size``; parameter.; indices: list of int; The indices of target pulse in the list of pulses.; **kwargs:; Key word arguments for the random number generator. Examples; --------; >>> gaussnoise = RandomNoise( \; dt=0.1, rand_gen=np.random.normal, loc=mean, scale=std) \; # doctest: +SKIP; """"""; def __init__(; self, dt, rand_gen, indices=None, **kwargs):; super(RandomNoise, self).__init__(coeff=None, tlist=None); self.rand_gen = rand_gen; self.kwargs = kwargs; if ""size"" in kwargs:; raise ValueError(""size is preditermined inside the noise object.""); self.dt = dt; self.indices = indices. [docs] def get_noisy_dynamics(; self, dims=None, pulses=None, systematic_noise=None):; if pulses is None:; pulses = []; if self.indices is None:; indices = range(len(pulses)); else:; indices = self.indices; t_max = -np.inf; t_min = np.inf; for pulse in pulses:; t_max = max(max(pulse.tlist), t_max); t_min = min(min(pulse.tlist), t_min); # create new tlist and random coeff; num_rand = int(np.floor((t_max - t_min) / self.dt)) + 1; tlist = (np.arange(0, self.dt*num_rand, self.dt)[:num_rand] + t_min); # [:num_rand] for round of error like 0.2*6=1.2000000000002. for i in indices:; pulse = pulses[i]; coeff = self.rand_gen(**self.kwargs, size=num_rand); pulses[i].add_coherent_noise(; pulse.qobj, pulse.targets, tlist, coeff); return pulses, systematic_noise. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/noise.html
https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:17708,Availability,error,error,17708,"e_types_num.add(qu.args[""_step_func_coeff""]); except Exception:; pass; args.update(qu.args); if len(spline_types_num) > 1:; raise ValueError(""Cannot merge Qobjevo with different spline kinds.""). for i, qobjevo in enumerate(qobjevo_list):; if isinstance(qobjevo, Qobj):; qobjevo_list[i] = QobjEvo(qobjevo); qobjevo = qobjevo_list[i]; for j, ele in enumerate(qobjevo.ops):; if isinstance(ele.coeff, np.ndarray):; new_coeff = _fill_coeff(; ele.coeff, qobjevo.tlist, full_tlist, args); qobjevo_list[i].ops[j].coeff = new_coeff; qobjevo_list[i].tlist = full_tlist. qobjevo = sum(qobjevo_list); return qobjevo. def _fill_coeff(old_coeffs, old_tlist, full_tlist, args=None, tol=1.0e-10):; """"""; Make a step function coefficients compatible with a longer `tlist` by; filling the empty slot with the nearest left value. The returned `coeff` always have the same size as the `tlist`.; If `step_func`, the last element is 0.; """"""; if args is None:; args = {}; if ""_step_func_coeff"" in args and args[""_step_func_coeff""]:; if len(old_coeffs) == len(old_tlist) - 1:; old_coeffs = np.concatenate([old_coeffs, [0]]); new_n = len(full_tlist); old_ind = 0 # index for old coeffs and tlist; new_coeff = np.zeros(new_n); for new_ind in range(new_n):; t = full_tlist[new_ind]; if old_tlist[0] - t > tol:; new_coeff[new_ind] = 0.; continue; if t - old_tlist[-1] > tol:; new_coeff[new_ind] = 0.; continue; # tol is required because of the floating-point error; if old_tlist[old_ind+1] <= t + tol:; old_ind += 1; new_coeff[new_ind] = old_coeffs[old_ind]; else:; sp = CubicSpline(old_tlist, old_coeffs); new_coeff = sp(full_tlist); new_coeff *= (full_tlist <= old_tlist[-1]); new_coeff *= (full_tlist >= old_tlist[0]); return new_coeff. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:15953,Deployability,integrat,integrated,15953,"ng the ideal evolution and coherent noise.; c_ops: list of :class:`qutip.QobjEvo`; Always an empty list for Drift; """"""; return self.get_ideal_qobjevo(dims), []. def _find_common_tlist(qobjevo_list, tol=1.0e-10):; """"""; Find the common `tlist` of a list of :class:`qutip.QobjEvo`.; """"""; all_tlists = [qu.tlist for qu in qobjevo_list; if isinstance(qu, QobjEvo) and qu.tlist is not None]; if not all_tlists:; return None; full_tlist = np.unique(np.sort(np.hstack(all_tlists))); full_tlist = np.concatenate(; (full_tlist[:1], full_tlist[1:][np.diff(full_tlist) > tol])); return full_tlist. ########################################################################; # These functions are moved here from qutip.qip.device.processor.py; ########################################################################. def _merge_qobjevo(qobjevo_list, full_tlist=None):; """"""; Combine a list of `:class:qutip.QobjEvo` into one,; different tlist will be merged.; """"""; # TODO This method can be eventually integrated into QobjEvo, for; # which a more thorough test is required. # no qobjevo; if not qobjevo_list:; raise ValueError(""qobjevo_list is empty.""). if full_tlist is None:; full_tlist = _find_common_tlist(qobjevo_list); spline_types_num = set(); args = {}; for qu in qobjevo_list:; if isinstance(qu, QobjEvo):; try:; spline_types_num.add(qu.args[""_step_func_coeff""]); except Exception:; pass; args.update(qu.args); if len(spline_types_num) > 1:; raise ValueError(""Cannot merge Qobjevo with different spline kinds.""). for i, qobjevo in enumerate(qobjevo_list):; if isinstance(qobjevo, Qobj):; qobjevo_list[i] = QobjEvo(qobjevo); qobjevo = qobjevo_list[i]; for j, ele in enumerate(qobjevo.ops):; if isinstance(ele.coeff, np.ndarray):; new_coeff = _fill_coeff(; ele.coeff, qobjevo.tlist, full_tlist, args); qobjevo_list[i].ops[j].coeff = new_coeff; qobjevo_list[i].tlist = full_tlist. qobjevo = sum(qobjevo_list); return qobjevo. def _fill_coeff(old_coeffs, old_tlist, full_tlist, args=None, tol=1.0e-10):; """"""; Ma",MatchSource.WIKI,docs/4.6/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:16354,Deployability,update,update,16354,"all_tlists:; return None; full_tlist = np.unique(np.sort(np.hstack(all_tlists))); full_tlist = np.concatenate(; (full_tlist[:1], full_tlist[1:][np.diff(full_tlist) > tol])); return full_tlist. ########################################################################; # These functions are moved here from qutip.qip.device.processor.py; ########################################################################. def _merge_qobjevo(qobjevo_list, full_tlist=None):; """"""; Combine a list of `:class:qutip.QobjEvo` into one,; different tlist will be merged.; """"""; # TODO This method can be eventually integrated into QobjEvo, for; # which a more thorough test is required. # no qobjevo; if not qobjevo_list:; raise ValueError(""qobjevo_list is empty.""). if full_tlist is None:; full_tlist = _find_common_tlist(qobjevo_list); spline_types_num = set(); args = {}; for qu in qobjevo_list:; if isinstance(qu, QobjEvo):; try:; spline_types_num.add(qu.args[""_step_func_coeff""]); except Exception:; pass; args.update(qu.args); if len(spline_types_num) > 1:; raise ValueError(""Cannot merge Qobjevo with different spline kinds.""). for i, qobjevo in enumerate(qobjevo_list):; if isinstance(qobjevo, Qobj):; qobjevo_list[i] = QobjEvo(qobjevo); qobjevo = qobjevo_list[i]; for j, ele in enumerate(qobjevo.ops):; if isinstance(ele.coeff, np.ndarray):; new_coeff = _fill_coeff(; ele.coeff, qobjevo.tlist, full_tlist, args); qobjevo_list[i].ops[j].coeff = new_coeff; qobjevo_list[i].tlist = full_tlist. qobjevo = sum(qobjevo_list); return qobjevo. def _fill_coeff(old_coeffs, old_tlist, full_tlist, args=None, tol=1.0e-10):; """"""; Make a step function coefficients compatible with a longer `tlist` by; filling the empty slot with the nearest left value. The returned `coeff` always have the same size as the `tlist`.; If `step_func`, the last element is 0.; """"""; if args is None:; args = {}; if ""_step_func_coeff"" in args and args[""_step_func_coeff""]:; if len(old_coeffs) == len(old_tlist) - 1:; old_coeffs = np.concatenate([",MatchSource.WIKI,docs/4.6/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:18177,Deployability,update,updated,18177,"e_types_num.add(qu.args[""_step_func_coeff""]); except Exception:; pass; args.update(qu.args); if len(spline_types_num) > 1:; raise ValueError(""Cannot merge Qobjevo with different spline kinds.""). for i, qobjevo in enumerate(qobjevo_list):; if isinstance(qobjevo, Qobj):; qobjevo_list[i] = QobjEvo(qobjevo); qobjevo = qobjevo_list[i]; for j, ele in enumerate(qobjevo.ops):; if isinstance(ele.coeff, np.ndarray):; new_coeff = _fill_coeff(; ele.coeff, qobjevo.tlist, full_tlist, args); qobjevo_list[i].ops[j].coeff = new_coeff; qobjevo_list[i].tlist = full_tlist. qobjevo = sum(qobjevo_list); return qobjevo. def _fill_coeff(old_coeffs, old_tlist, full_tlist, args=None, tol=1.0e-10):; """"""; Make a step function coefficients compatible with a longer `tlist` by; filling the empty slot with the nearest left value. The returned `coeff` always have the same size as the `tlist`.; If `step_func`, the last element is 0.; """"""; if args is None:; args = {}; if ""_step_func_coeff"" in args and args[""_step_func_coeff""]:; if len(old_coeffs) == len(old_tlist) - 1:; old_coeffs = np.concatenate([old_coeffs, [0]]); new_n = len(full_tlist); old_ind = 0 # index for old coeffs and tlist; new_coeff = np.zeros(new_n); for new_ind in range(new_n):; t = full_tlist[new_ind]; if old_tlist[0] - t > tol:; new_coeff[new_ind] = 0.; continue; if t - old_tlist[-1] > tol:; new_coeff[new_ind] = 0.; continue; # tol is required because of the floating-point error; if old_tlist[old_ind+1] <= t + tol:; old_ind += 1; new_coeff[new_ind] = old_coeffs[old_ind]; else:; sp = CubicSpline(old_tlist, old_coeffs); new_coeff = sp(full_tlist); new_coeff *= (full_tlist <= old_tlist[-1]); new_coeff *= (full_tlist >= old_tlist[0]); return new_coeff. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:3938,Integrability,depend,dependent,3938,"ficient will be treated as a step function.; E.g. ``tlist=[0,1,2]`` and ``coeff=[3,2]``, means that the; coefficient is 3 in t=[0,1) and 2 in t=[2,3). It requires; ``len(coeff)=len(tlist)-1`` or ``len(coeff)=len(tlist)``, but; in the second case the last element of `coeff` has no effect. -""cubic"": Use cubic interpolation for the coefficient. It requires; ``len(coeff)=len(tlist)``; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; qobjevo: :class:`qutip.QobjEvo`; The `QobjEvo` representation of the evolution element.; """"""; try:; return self._get_qobjevo_helper(spline_kind, dims=dims); except Exception as err:; print(; ""The Evolution element went wrong was\n {}"".format(str(self))); raise(err). def __str__(self):; return str({""qobj"": self.qobj,; ""targets"": self.targets,; ""tlist"": self.tlist,; ""coeff"": self.coeff; }). [docs]class Pulse():; """"""; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; `qobj`, `targets`, `tlist` and `coeff`. See examples for different construction behavior. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the ideal pulse.; targets: list; target qubits of the ideal pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; `tlist` of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; `tlist` does not have to be equidistant, but must have the same length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind`.; coeff: array-like or bool, optional; Time-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to `",MatchSource.WIKI,docs/4.6/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:4531,Integrability,depend,dependent,4531,"n of the evolution element.; """"""; try:; return self._get_qobjevo_helper(spline_kind, dims=dims); except Exception as err:; print(; ""The Evolution element went wrong was\n {}"".format(str(self))); raise(err). def __str__(self):; return str({""qobj"": self.qobj,; ""targets"": self.targets,; ""tlist"": self.tlist,; ""coeff"": self.coeff; }). [docs]class Pulse():; """"""; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; `qobj`, `targets`, `tlist` and `coeff`. See examples for different construction behavior. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the ideal pulse.; targets: list; target qubits of the ideal pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; `tlist` of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; `tlist` does not have to be equidistant, but must have the same length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind`.; coeff: array-like or bool, optional; Time-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for the parameter `spline_kind`.; If a bool, the coefficient is a constant 1 or 0.; spline_kind: str, optional; Type of the coefficient interpolation:; ""step_func"" or ""cubic"". -""step_func"":; The coefficient will be treated as a step function.; E.g. ``tlist=[0,1,2]`` and ``coeff=[3,2]``, means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; ``len(coeff)=len(tlist)-1`` or ``len(coeff)=len(tlist)``, but; in the second case the last element of `coeff` has no effect. -""cubic"":; Use cubic interpolation for the coefficient. It requires; ``len(coeff)=len(tlist)``; label: str; ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:4779,Integrability,depend,dependent,4779,".qobj,; ""targets"": self.targets,; ""tlist"": self.tlist,; ""coeff"": self.coeff; }). [docs]class Pulse():; """"""; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; `qobj`, `targets`, `tlist` and `coeff`. See examples for different construction behavior. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the ideal pulse.; targets: list; target qubits of the ideal pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; `tlist` of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; `tlist` does not have to be equidistant, but must have the same length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind`.; coeff: array-like or bool, optional; Time-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for the parameter `spline_kind`.; If a bool, the coefficient is a constant 1 or 0.; spline_kind: str, optional; Type of the coefficient interpolation:; ""step_func"" or ""cubic"". -""step_func"":; The coefficient will be treated as a step function.; E.g. ``tlist=[0,1,2]`` and ``coeff=[3,2]``, means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; ``len(coeff)=len(tlist)-1`` or ``len(coeff)=len(tlist)``, but; in the second case the last element of `coeff` has no effect. -""cubic"":; Use cubic interpolation for the coefficient. It requires; ``len(coeff)=len(tlist)``; label: str; The label (name) of the pulse. Attributes; ----------; ideal_pulse: :class:`._EvoElement`; The ideal dynamic of the control pulse.; coherent_noise: list of :class:`._EvoElement`; The coherent noise caused by the control pulse. Each dynamic element is;",MatchSource.WIKI,docs/4.6/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:5813,Integrability,depend,dependent,5813,"ients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for the parameter `spline_kind`.; If a bool, the coefficient is a constant 1 or 0.; spline_kind: str, optional; Type of the coefficient interpolation:; ""step_func"" or ""cubic"". -""step_func"":; The coefficient will be treated as a step function.; E.g. ``tlist=[0,1,2]`` and ``coeff=[3,2]``, means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; ``len(coeff)=len(tlist)-1`` or ``len(coeff)=len(tlist)``, but; in the second case the last element of `coeff` has no effect. -""cubic"":; Use cubic interpolation for the coefficient. It requires; ``len(coeff)=len(tlist)``; label: str; The label (name) of the pulse. Attributes; ----------; ideal_pulse: :class:`._EvoElement`; The ideal dynamic of the control pulse.; coherent_noise: list of :class:`._EvoElement`; The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian.; lindblad_noise: list of :class:`._EvoElement`; The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation.; spline_kind: str; See parameter `spline_kind`.; label: str; See parameter `label`. Examples; --------; Create a pulse that is turned off. >>> Pulse(sigmaz(), 0) # doctest: +SKIP; >>> Pulse(sigmaz(), 0, None, None) # doctest: +SKIP. Create a time dependent pulse. >>> tlist = np.array([0., 1., 2., 4.]) # doctest: +SKIP; >>> coeff = np.array([0.5, 1.2, 0.8]) # doctest: +SKIP; >>> spline_kind = ""step_func"" # doctest: +SKIP; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=coeff, spline_kind=""step_func"") # doctest: +SKIP. Create a time independent pulse. >>> Pulse(sigmaz(), 0, coeff=True) # doctest: +SKIP. Create a constant pulse with time range. >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True) # doctest: +SKIP. Create an dummy Pulse (H=0). >>> Pulse(None, None) # do",MatchSource.WIKI,docs/4.6/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:5977,Integrability,depend,dependent,5977,", the coefficient is a constant 1 or 0.; spline_kind: str, optional; Type of the coefficient interpolation:; ""step_func"" or ""cubic"". -""step_func"":; The coefficient will be treated as a step function.; E.g. ``tlist=[0,1,2]`` and ``coeff=[3,2]``, means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; ``len(coeff)=len(tlist)-1`` or ``len(coeff)=len(tlist)``, but; in the second case the last element of `coeff` has no effect. -""cubic"":; Use cubic interpolation for the coefficient. It requires; ``len(coeff)=len(tlist)``; label: str; The label (name) of the pulse. Attributes; ----------; ideal_pulse: :class:`._EvoElement`; The ideal dynamic of the control pulse.; coherent_noise: list of :class:`._EvoElement`; The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian.; lindblad_noise: list of :class:`._EvoElement`; The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation.; spline_kind: str; See parameter `spline_kind`.; label: str; See parameter `label`. Examples; --------; Create a pulse that is turned off. >>> Pulse(sigmaz(), 0) # doctest: +SKIP; >>> Pulse(sigmaz(), 0, None, None) # doctest: +SKIP. Create a time dependent pulse. >>> tlist = np.array([0., 1., 2., 4.]) # doctest: +SKIP; >>> coeff = np.array([0.5, 1.2, 0.8]) # doctest: +SKIP; >>> spline_kind = ""step_func"" # doctest: +SKIP; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=coeff, spline_kind=""step_func"") # doctest: +SKIP. Create a time independent pulse. >>> Pulse(sigmaz(), 0, coeff=True) # doctest: +SKIP. Create a constant pulse with time range. >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True) # doctest: +SKIP. Create an dummy Pulse (H=0). >>> Pulse(None, None) # doctest: +SKIP. """"""; def __init__(self, qobj, targets, tlist=None, coeff=None,; spline_kind=None, label=""""):; self.spline_kind = spline_kind; self.ideal_pulse = _EvoElement(qobj, target",MatchSource.WIKI,docs/4.6/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:6278,Integrability,depend,dependent,6278,"[2,3). It requires; ``len(coeff)=len(tlist)-1`` or ``len(coeff)=len(tlist)``, but; in the second case the last element of `coeff` has no effect. -""cubic"":; Use cubic interpolation for the coefficient. It requires; ``len(coeff)=len(tlist)``; label: str; The label (name) of the pulse. Attributes; ----------; ideal_pulse: :class:`._EvoElement`; The ideal dynamic of the control pulse.; coherent_noise: list of :class:`._EvoElement`; The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian.; lindblad_noise: list of :class:`._EvoElement`; The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation.; spline_kind: str; See parameter `spline_kind`.; label: str; See parameter `label`. Examples; --------; Create a pulse that is turned off. >>> Pulse(sigmaz(), 0) # doctest: +SKIP; >>> Pulse(sigmaz(), 0, None, None) # doctest: +SKIP. Create a time dependent pulse. >>> tlist = np.array([0., 1., 2., 4.]) # doctest: +SKIP; >>> coeff = np.array([0.5, 1.2, 0.8]) # doctest: +SKIP; >>> spline_kind = ""step_func"" # doctest: +SKIP; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=coeff, spline_kind=""step_func"") # doctest: +SKIP. Create a time independent pulse. >>> Pulse(sigmaz(), 0, coeff=True) # doctest: +SKIP. Create a constant pulse with time range. >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True) # doctest: +SKIP. Create an dummy Pulse (H=0). >>> Pulse(None, None) # doctest: +SKIP. """"""; def __init__(self, qobj, targets, tlist=None, coeff=None,; spline_kind=None, label=""""):; self.spline_kind = spline_kind; self.ideal_pulse = _EvoElement(qobj, targets, tlist, coeff); self.coherent_noise = []; self.lindblad_noise = []; self.label = label. @property; def qobj(self):; """"""; See parameter `qobj`.; """"""; return self.ideal_pulse.qobj. @qobj.setter; def qobj(self, x):; self.ideal_pulse.qobj = x. @property; def targets(self):; """"""; See parameter `targets",MatchSource.WIKI,docs/4.6/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:7804,Integrability,depend,dependent,7804,"se(None, None) # doctest: +SKIP. """"""; def __init__(self, qobj, targets, tlist=None, coeff=None,; spline_kind=None, label=""""):; self.spline_kind = spline_kind; self.ideal_pulse = _EvoElement(qobj, targets, tlist, coeff); self.coherent_noise = []; self.lindblad_noise = []; self.label = label. @property; def qobj(self):; """"""; See parameter `qobj`.; """"""; return self.ideal_pulse.qobj. @qobj.setter; def qobj(self, x):; self.ideal_pulse.qobj = x. @property; def targets(self):; """"""; See parameter `targets`.; """"""; return self.ideal_pulse.targets. @targets.setter; def targets(self, x):; self.ideal_pulse.targets = x. @property; def tlist(self):; """"""; See parameter `tlist`; """"""; return self.ideal_pulse.tlist. @tlist.setter; def tlist(self, x):; self.ideal_pulse.tlist = x. @property; def coeff(self):; """"""; See parameter `coeff`.; """"""; return self.ideal_pulse.coeff. @coeff.setter; def coeff(self, x):; self.ideal_pulse.coeff = x. [docs] def add_coherent_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the pulse.; targets: list; target qubits of the pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind` of :class:`.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.coherent_noise.append(_EvoElement(qobj, targets, tlist, coeff)). def add_control_noise(self, qobj, targets, tlist=None, coeff=None):; self.add_coherent_noise(qobj, ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:8082,Integrability,depend,dependent,8082," @property; def qobj(self):; """"""; See parameter `qobj`.; """"""; return self.ideal_pulse.qobj. @qobj.setter; def qobj(self, x):; self.ideal_pulse.qobj = x. @property; def targets(self):; """"""; See parameter `targets`.; """"""; return self.ideal_pulse.targets. @targets.setter; def targets(self, x):; self.ideal_pulse.targets = x. @property; def tlist(self):; """"""; See parameter `tlist`; """"""; return self.ideal_pulse.tlist. @tlist.setter; def tlist(self, x):; self.ideal_pulse.tlist = x. @property; def coeff(self):; """"""; See parameter `coeff`.; """"""; return self.ideal_pulse.coeff. @coeff.setter; def coeff(self, x):; self.ideal_pulse.coeff = x. [docs] def add_coherent_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the pulse.; targets: list; target qubits of the pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind` of :class:`.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.coherent_noise.append(_EvoElement(qobj, targets, tlist, coeff)). def add_control_noise(self, qobj, targets, tlist=None, coeff=None):; self.add_coherent_noise(qobj, targets, tlist=tlist, coeff=coeff). [docs] def add_lindblad_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The collapse operator of the lindblad noise.; targets: li",MatchSource.WIKI,docs/4.6/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:8351,Integrability,depend,dependent,8351,"self, x):; self.ideal_pulse.targets = x. @property; def tlist(self):; """"""; See parameter `tlist`; """"""; return self.ideal_pulse.tlist. @tlist.setter; def tlist(self, x):; self.ideal_pulse.tlist = x. @property; def coeff(self):; """"""; See parameter `coeff`.; """"""; return self.ideal_pulse.coeff. @coeff.setter; def coeff(self, x):; self.ideal_pulse.coeff = x. [docs] def add_coherent_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the pulse.; targets: list; target qubits of the pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind` of :class:`.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.coherent_noise.append(_EvoElement(qobj, targets, tlist, coeff)). def add_control_noise(self, qobj, targets, tlist=None, coeff=None):; self.add_coherent_noise(qobj, targets, tlist=tlist, coeff=coeff). [docs] def add_lindblad_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The collapse operator of the lindblad noise.; targets: list; target qubits of the collapse operator; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element short",MatchSource.WIKI,docs/4.6/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:8911,Integrability,depend,dependent,8911,"s:'qutip.Qobj'; The Hamiltonian of the pulse.; targets: list; target qubits of the pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind` of :class:`.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.coherent_noise.append(_EvoElement(qobj, targets, tlist, coeff)). def add_control_noise(self, qobj, targets, tlist=None, coeff=None):; self.add_coherent_noise(qobj, targets, tlist=tlist, coeff=coeff). [docs] def add_lindblad_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The collapse operator of the lindblad noise.; targets: list; target qubits of the collapse operator; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`.; See documentation for; the parameter `spline_kind` of :class:`.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.lindblad_noise.append(_EvoElement(qobj, targets, tlist, coeff)). [docs] def get_ideal_qobj(self, dims):; """"""; Get the Hamiltonian of th",MatchSource.WIKI,docs/4.6/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:9219,Integrability,depend,dependent,9219,"nt shorter compared to `coeff`. See documentation for; the parameter `spline_kind` of :class:`.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.coherent_noise.append(_EvoElement(qobj, targets, tlist, coeff)). def add_control_noise(self, qobj, targets, tlist=None, coeff=None):; self.add_coherent_noise(qobj, targets, tlist=tlist, coeff=coeff). [docs] def add_lindblad_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The collapse operator of the lindblad noise.; targets: list; target qubits of the collapse operator; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`.; See documentation for; the parameter `spline_kind` of :class:`.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.lindblad_noise.append(_EvoElement(qobj, targets, tlist, coeff)). [docs] def get_ideal_qobj(self, dims):; """"""; Get the Hamiltonian of the ideal pulse. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; qobj: :class:`qutip.Qobj`; The Hamiltonian of the ideal pulse.; """"""; return self.ideal_pulse.get_qobj",MatchSource.WIKI,docs/4.6/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:9489,Integrability,depend,dependent,9489,"umentation for; the parameter `spline_kind` of :class:`.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.coherent_noise.append(_EvoElement(qobj, targets, tlist, coeff)). def add_control_noise(self, qobj, targets, tlist=None, coeff=None):; self.add_coherent_noise(qobj, targets, tlist=tlist, coeff=coeff). [docs] def add_lindblad_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The collapse operator of the lindblad noise.; targets: list; target qubits of the collapse operator; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`.; See documentation for; the parameter `spline_kind` of :class:`.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.lindblad_noise.append(_EvoElement(qobj, targets, tlist, coeff)). [docs] def get_ideal_qobj(self, dims):; """"""; Get the Hamiltonian of the ideal pulse. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; qobj: :class:`qutip.Qobj`; The Hamiltonian of the ideal pulse.; """"""; return self.ideal_pulse.get_qobj(dims). [docs] def get_ideal_qobjevo(self, dims):; """"""; Get a `QobjEvo` representation of the ideal evolution. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the compon",MatchSource.WIKI,docs/4.6/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:11204,Integrability,depend,dependent,11204,"dims). [docs] def get_ideal_qobjevo(self, dims):; """"""; Get a `QobjEvo` representation of the ideal evolution. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; ideal_evo: :class:`qutip.QobjEvo`; A `QobjEvo` representing the ideal evolution.; """"""; return self.ideal_pulse.get_qobjevo(self.spline_kind, dims). [docs] def get_noisy_qobjevo(self, dims):; """"""; Get the :obj:`.QobjEvo` representation of the noisy evolution. The; result can be used directly as input for the qutip solvers. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; noisy_evo: :class:`qutip.QobjEvo`; A ``QobjEvo`` representing the ideal evolution and coherent noise.; c_ops: list of :class:`qutip.QobjEvo`; A list of (time-dependent) lindbald operators.; """"""; ideal_qu = self.get_ideal_qobjevo(dims); noise_qu_list = [noise.get_qobjevo(self.spline_kind, dims); for noise in self.coherent_noise]; qu = _merge_qobjevo([ideal_qu] + noise_qu_list); c_ops = [noise.get_qobjevo(self.spline_kind, dims); for noise in self.lindblad_noise]; full_tlist = self.get_full_tlist(); qu = _merge_qobjevo([qu], full_tlist); for i, c_op in enumerate(c_ops):; c_ops[i] = _merge_qobjevo([c_op], full_tlist); return qu, c_ops. [docs] def get_full_tlist(self, tol=1.0e-10):; """"""; Return the full tlist of the pulses and noise. It means that if; different ``tlist`` are present, they will be merged to one with all; time points stored in a sorted array. Returns; -------; full_tlist: array-like 1d; The full time sequence for the noisy evolution.; """"""; # TODO add test; all_tlists = []; all_tlists.append(self.ideal_pulse.tlist); for pulse in self.coherent_noise:; all_tlists.append(pulse.tlist); for c_op in self.lindblad_noise:; all_tlists.append",MatchSource.WIKI,docs/4.6/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:15953,Integrability,integrat,integrated,15953,"ng the ideal evolution and coherent noise.; c_ops: list of :class:`qutip.QobjEvo`; Always an empty list for Drift; """"""; return self.get_ideal_qobjevo(dims), []. def _find_common_tlist(qobjevo_list, tol=1.0e-10):; """"""; Find the common `tlist` of a list of :class:`qutip.QobjEvo`.; """"""; all_tlists = [qu.tlist for qu in qobjevo_list; if isinstance(qu, QobjEvo) and qu.tlist is not None]; if not all_tlists:; return None; full_tlist = np.unique(np.sort(np.hstack(all_tlists))); full_tlist = np.concatenate(; (full_tlist[:1], full_tlist[1:][np.diff(full_tlist) > tol])); return full_tlist. ########################################################################; # These functions are moved here from qutip.qip.device.processor.py; ########################################################################. def _merge_qobjevo(qobjevo_list, full_tlist=None):; """"""; Combine a list of `:class:qutip.QobjEvo` into one,; different tlist will be merged.; """"""; # TODO This method can be eventually integrated into QobjEvo, for; # which a more thorough test is required. # no qobjevo; if not qobjevo_list:; raise ValueError(""qobjevo_list is empty.""). if full_tlist is None:; full_tlist = _find_common_tlist(qobjevo_list); spline_types_num = set(); args = {}; for qu in qobjevo_list:; if isinstance(qu, QobjEvo):; try:; spline_types_num.add(qu.args[""_step_func_coeff""]); except Exception:; pass; args.update(qu.args); if len(spline_types_num) > 1:; raise ValueError(""Cannot merge Qobjevo with different spline kinds.""). for i, qobjevo in enumerate(qobjevo_list):; if isinstance(qobjevo, Qobj):; qobjevo_list[i] = QobjEvo(qobjevo); qobjevo = qobjevo_list[i]; for j, ele in enumerate(qobjevo.ops):; if isinstance(ele.coeff, np.ndarray):; new_coeff = _fill_coeff(; ele.coeff, qobjevo.tlist, full_tlist, args); qobjevo_list[i].ops[j].coeff = new_coeff; qobjevo_list[i].tlist = full_tlist. qobjevo = sum(qobjevo_list); return qobjevo. def _fill_coeff(old_coeffs, old_tlist, full_tlist, args=None, tol=1.0e-10):; """"""; Ma",MatchSource.WIKI,docs/4.6/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:712,Modifiability,variab,variables,712,". qutip.qip.pulse — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.pulse. Source code for qutip.qip.pulse; import numpy as np; from scipy.interpolate import CubicSpline. from qutip.qobjevo import QobjEvo; from qutip.qobj import Qobj; from qutip.qip.operations import expand_operator; from qutip.operators import identity. __all__ = [""Pulse"", ""Drift""]. class _EvoElement():; """"""; The class object saving the information of one evolution element.; Each dynamic element is characterized by four variables:; `qobj`, `targets`, `tlist` and `coeff`. For documentation and use instruction of the attributes, please; refer to :class:`.Pulse`.; """"""; def __init__(self, qobj, targets, tlist=None, coeff=None):; self.qobj = qobj; self.targets = targets; self.tlist = tlist; self.coeff = coeff. def get_qobj(self, dims):; """"""; Get the `Qobj` representation of the element. If `qobj` is None,; a zero :class:`qutip.Qobj` with the corresponding dimension is; returned. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; qobj: :class:`qutip.Qobj`; The operator of this element.; """"""; if isinstance(dims, (int, np.integer)):; dims = [2] * dims; if self.qobj is None:; qobj = identity(dims[0]) * 0.; targets = 0; else:; qobj = self.qobj; targets = self.targets; return expand_operator(qobj, len(dims), targets, dims). def _get_qobjevo_helper(self, spline_kind, dims):; """"""; Please refer to `_Evoelement.get_qobjevo` for documentation.; """"""; mat = self.get_qobj(dims); if self.tlist is None and self.coeff is None:; qu = QobjEvo(mat) * 0.; elif isinstance(self.coeff, bool):; if self.coeff:; if self.tlist is None:; qu = QobjEvo(mat, tlist=self.tl",MatchSource.WIKI,docs/4.6/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:4156,Modifiability,variab,variables,4156," last element of `coeff` has no effect. -""cubic"": Use cubic interpolation for the coefficient. It requires; ``len(coeff)=len(tlist)``; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns; -------; qobjevo: :class:`qutip.QobjEvo`; The `QobjEvo` representation of the evolution element.; """"""; try:; return self._get_qobjevo_helper(spline_kind, dims=dims); except Exception as err:; print(; ""The Evolution element went wrong was\n {}"".format(str(self))); raise(err). def __str__(self):; return str({""qobj"": self.qobj,; ""targets"": self.targets,; ""tlist"": self.tlist,; ""coeff"": self.coeff; }). [docs]class Pulse():; """"""; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; `qobj`, `targets`, `tlist` and `coeff`. See examples for different construction behavior. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the ideal pulse.; targets: list; target qubits of the ideal pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; `tlist` of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; `tlist` does not have to be equidistant, but must have the same length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind`.; coeff: array-like or bool, optional; Time-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for the parameter `spline_kind`.; If a bool, the coefficient is a constant 1 or 0.; spline_kind: str, optional; Type of the coefficient interpolation:; ""step_func"" or ""cubic"". -""step_func"":; The coefficient will be treated ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:13428,Performance,tune,tuned,13428,"oncatenate(; (full_tlist[:1], full_tlist[1:][np.diff(full_tlist) > tol])); return full_tlist. [docs] def print_info(self):; """"""; Print the information of the pulse, including the ideal dynamics,; the coherent noise and the lindblad noise.; """"""; print(""-----------------------------------""; ""-----------------------------------""); if self.label is not None:; print(""Pulse label:"", self.label); print(""The pulse contains: {} coherent noise elements and {} ""; ""Lindblad noise elements."".format(; len(self.coherent_noise), len(self.lindblad_noise))); print(); print(""Ideal pulse:""); print(self.ideal_pulse); if self.coherent_noise:; print(); print(""Coherent noise:""); for ele in self.coherent_noise:; print(ele); if self.lindblad_noise:; print(); print(""Lindblad noise:""); for ele in self.lindblad_noise:; print(ele); print(""-----------------------------------""; ""-----------------------------------""). class Drift():; """"""; The time independent drift Hamiltonian. Usually its the intrinsic; evolution of the quantum system that can not be tuned. Parameters; ----------; qobj: :class:`qutip.Qobj` or list of :class:`qutip.Qobj`, optional; The drift Hamiltonians. Attributes; ----------; qobj: list of :class:`qutip.Qobj`; A list of the the drift Hamiltonians.; """"""; def __init__(self, qobj=None):; if qobj is None:; self.drift_hamiltonians = []; elif isinstance(qobj, list):; self.drift_hamiltonians = qobj; else:; self.drift_hamiltonians = [qobj]. def add_drift(self, qobj, targets):; """"""; Add a Hamiltonian to the drift. Parameters; ----------; qobj: :class:'qutip.Qobj'; The collapse operator of the lindblad noise.; targets: list; target qubits of the collapse operator; (or subquantum system of other dimensions).; """"""; self.drift_hamiltonians.append(_EvoElement(qobj, targets)). def get_ideal_qobjevo(self, dims):; """"""; Get the QobjEvo representation of the drift Hamiltonian. Parameters; ----------; dims: int or list; Dimension of the system.; If int, we assume it is the number of qubits in the s",MatchSource.WIKI,docs/4.6/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:12022,Testability,test,test,12022,"turns; -------; noisy_evo: :class:`qutip.QobjEvo`; A ``QobjEvo`` representing the ideal evolution and coherent noise.; c_ops: list of :class:`qutip.QobjEvo`; A list of (time-dependent) lindbald operators.; """"""; ideal_qu = self.get_ideal_qobjevo(dims); noise_qu_list = [noise.get_qobjevo(self.spline_kind, dims); for noise in self.coherent_noise]; qu = _merge_qobjevo([ideal_qu] + noise_qu_list); c_ops = [noise.get_qobjevo(self.spline_kind, dims); for noise in self.lindblad_noise]; full_tlist = self.get_full_tlist(); qu = _merge_qobjevo([qu], full_tlist); for i, c_op in enumerate(c_ops):; c_ops[i] = _merge_qobjevo([c_op], full_tlist); return qu, c_ops. [docs] def get_full_tlist(self, tol=1.0e-10):; """"""; Return the full tlist of the pulses and noise. It means that if; different ``tlist`` are present, they will be merged to one with all; time points stored in a sorted array. Returns; -------; full_tlist: array-like 1d; The full time sequence for the noisy evolution.; """"""; # TODO add test; all_tlists = []; all_tlists.append(self.ideal_pulse.tlist); for pulse in self.coherent_noise:; all_tlists.append(pulse.tlist); for c_op in self.lindblad_noise:; all_tlists.append(c_op.tlist); all_tlists = [tlist for tlist in all_tlists if tlist is not None]; if not all_tlists:; return None; full_tlist = np.unique(np.sort(np.hstack(all_tlists))); full_tlist = np.concatenate(; (full_tlist[:1], full_tlist[1:][np.diff(full_tlist) > tol])); return full_tlist. [docs] def print_info(self):; """"""; Print the information of the pulse, including the ideal dynamics,; the coherent noise and the lindblad noise.; """"""; print(""-----------------------------------""; ""-----------------------------------""); if self.label is not None:; print(""Pulse label:"", self.label); print(""The pulse contains: {} coherent noise elements and {} ""; ""Lindblad noise elements."".format(; len(self.coherent_noise), len(self.lindblad_noise))); print(); print(""Ideal pulse:""); print(self.ideal_pulse); if self.coherent_noise:; print();",MatchSource.WIKI,docs/4.6/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:16007,Testability,test,test,16007,"ng the ideal evolution and coherent noise.; c_ops: list of :class:`qutip.QobjEvo`; Always an empty list for Drift; """"""; return self.get_ideal_qobjevo(dims), []. def _find_common_tlist(qobjevo_list, tol=1.0e-10):; """"""; Find the common `tlist` of a list of :class:`qutip.QobjEvo`.; """"""; all_tlists = [qu.tlist for qu in qobjevo_list; if isinstance(qu, QobjEvo) and qu.tlist is not None]; if not all_tlists:; return None; full_tlist = np.unique(np.sort(np.hstack(all_tlists))); full_tlist = np.concatenate(; (full_tlist[:1], full_tlist[1:][np.diff(full_tlist) > tol])); return full_tlist. ########################################################################; # These functions are moved here from qutip.qip.device.processor.py; ########################################################################. def _merge_qobjevo(qobjevo_list, full_tlist=None):; """"""; Combine a list of `:class:qutip.QobjEvo` into one,; different tlist will be merged.; """"""; # TODO This method can be eventually integrated into QobjEvo, for; # which a more thorough test is required. # no qobjevo; if not qobjevo_list:; raise ValueError(""qobjevo_list is empty.""). if full_tlist is None:; full_tlist = _find_common_tlist(qobjevo_list); spline_types_num = set(); args = {}; for qu in qobjevo_list:; if isinstance(qu, QobjEvo):; try:; spline_types_num.add(qu.args[""_step_func_coeff""]); except Exception:; pass; args.update(qu.args); if len(spline_types_num) > 1:; raise ValueError(""Cannot merge Qobjevo with different spline kinds.""). for i, qobjevo in enumerate(qobjevo_list):; if isinstance(qobjevo, Qobj):; qobjevo_list[i] = QobjEvo(qobjevo); qobjevo = qobjevo_list[i]; for j, ele in enumerate(qobjevo.ops):; if isinstance(ele.coeff, np.ndarray):; new_coeff = _fill_coeff(; ele.coeff, qobjevo.tlist, full_tlist, args); qobjevo_list[i].ops[j].coeff = new_coeff; qobjevo_list[i].tlist = full_tlist. qobjevo = sum(qobjevo_list); return qobjevo. def _fill_coeff(old_coeffs, old_tlist, full_tlist, args=None, tol=1.0e-10):; """"""; Ma",MatchSource.WIKI,docs/4.6/modules/qutip/qip/pulse.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html
https://qutip.org/docs/4.6/modules/qutip/qip/qasm.html:27591,Deployability,update,updated,27591,"e_name_map:; return self.gate_name_map[gate_name]; else:; return None. def is_defined(self, gate_name):; '''; Check if QASM gate definition exists for QuTiP gate. Parameters; ----------; gate_name: str; QuTiP gate name.; '''. return gate_name in self.gate_name_map. def _qasm_output(self, qc):; '''; QASM output handler. Parameters; ----------; qc: :class:`.QubitCircuit`; circuit object to produce QASM output for.; '''. self._flush(). self.output(""// QASM 2.0 file generated by QuTiP"", 1). if self.version == ""2.0"":; self.output(""OPENQASM 2.0;""); else:; raise NotImplementedError(""QASM: Only OpenQASM 2.0 \; is currently supported.""). self.output('include ""qelib1.inc"";', 1). qc._to_qasm(self). return self.lines. [docs]def print_qasm(qc):; '''; Print QASM output of circuit object. Parameters; ----------; qc: :class:`.QubitCircuit`; circuit object to produce QASM output for.; '''. qasm_out = QasmOutput(""2.0""); lines = qasm_out._qasm_output(qc); for line in lines:; print(line). [docs]def circuit_to_qasm_str(qc):; '''; Return QASM output of circuit object as string. Parameters; ----------; qc: :class:`.QubitCircuit`; circuit object to produce QASM output for. Returns; -------; output: str; string corresponding to QASM output.; '''. qasm_out = QasmOutput(""2.0""); lines = qasm_out._qasm_output(qc); output = """"; for line in lines:; output += line + ""\n""; return output. [docs]def save_qasm(qc, file_loc):; '''; Save QASM output of circuit object to file. Parameters; ----------; qc: :class:`.QubitCircuit`; circuit object to produce QASM output for.; '''. qasm_out = QasmOutput(""2.0""); lines = qasm_out._qasm_output(qc); with open(file_loc, ""w"") as f:; for line in lines:; f.write(""{}\n"".format(line)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/qasm.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/qasm.html
https://qutip.org/docs/4.6/modules/qutip/qip/qasm.html:4406,Modifiability,variab,variables,4406,"ing for convenience; for c in ""[]()"":; line = line.replace(c, "" "" + c + "" ""); for c in ""{}"":; line = line.replace(c, "" ; "" + c + "" ; ""); line_commands = line.split("";""); line_commands = list(filter(lambda x: x != """", line_commands)). for command in line_commands:; tokens = _tokenize_line(command); processed_commands.append(tokens). return list(filter(lambda x: x != [], processed_commands)). def _gate_processor(command):; '''; Process tokens for a gate call statement separating them into args and regs.; Processes tokens from a ""gate call"" (e.g. rx(pi) q[0]) and returns the; tokens for the arguments and registers separately.; '''. gate_args = []; gate_regs = []; tokens = command[1:]; reg_start = 0. # extract arguments; if ""("" in tokens and "")"" in tokens:; bopen = tokens.index(""(""); bclose = tokens.index("")""); gate_args = tokens[bopen+1:bclose]; reg_start = bclose+1. # extract registers; gate_regs = tokens[reg_start:]. return gate_args, gate_regs. class QasmProcessor:; '''; Class which holds variables used in processing QASM code.; '''. def __init__(self, commands, mode=""qiskit"", version=""2.0""):; self.qubit_regs = {}; self.cbit_regs = {}; self.num_qubits = 0; self.num_cbits = 0; self.qasm_gates = {}; self.mode = mode; self.version = version; self.predefined_gates = set([""CX"", ""U""]). if self.mode == ""qiskit"":; self.qiskitgates = set([""u3"", ""u2"", ""u1"", ""cx"", ""id"", ""x"", ""y"",; ""z"", ""h"", ""s"", ""sdg"", ""t"", ""tdg"", ""rx"",; ""ry"", ""rz"", ""cz"", ""cy"", ""ch"", ""ccx"", ""crz"",; ""cu1"", ""cu3""]); self.predefined_gates = self.predefined_gates.union(self.qiskitgates). self.gate_names = deepcopy(self.predefined_gates); for gate in self.predefined_gates:; self.qasm_gates[gate] = QasmGate(""U"",; [""alpha"", ""beta"", ""gamma""],; [""q""]); self.commands = commands. def _process_includes(self):; '''; QASM allows for code to be specified in additional files with the; "".inc"" extension, especially to specify gate definitions in terms of; the built-in gates. Process into tokens all the; additional files and inse",MatchSource.WIKI,docs/4.6/modules/qutip/qip/qasm.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/qasm.html
https://qutip.org/docs/4.6/modules/qutip/qip/qasm.html:8923,Modifiability,variab,variables,8923,"] = list(range(self.num_cbits,; self.num_cbits + num_regs)); self.num_cbits += num_regs; else:; raise SyntaxError(""QASM: incorrect bracket formatting""); elif command[0] == ""reset"":; raise NotImplementedError((""QASM: reset functionality ""; ""is not supported."")); elif command[0] in [""barrier"", ""include""]:; continue; else:; unprocessed.append(num); continue. if open_bracket_mode:; raise SyntaxError(""QASM: incorrect bracket formatting""). self.commands = [self.commands[i] for i in unprocessed]. def _custom_gate(self, qc_temp, gate_call):; '''; Recursively process a custom-defined gate with specified arguments; to produce a dummy circuit with all the gates in the custom-defined; gate. Parameters; ----------. qc_temp: :class:`.QubitCircuit`; temporary circuit to process custom gate; gate_call: list of str; tokens corresponding to gate signature/call; '''. gate_name, args, regs = gate_call; gate = self.qasm_gates[gate_name]; args_map = {}; regs_map = {}. # maps variables to supplied arguments, registers; for i, arg in enumerate(gate.gate_args):; args_map[arg] = eval(str(args[i])); for i, reg in enumerate(gate.gate_regs):; regs_map[reg] = regs[i]; # process all the constituent gates with supplied arguments, registers; for call in gate.gates_inside:. # create function call for the constituent gate; name, com_args, com_regs = call. for arg, real_arg in args_map.items():; com_args = [command.replace(arg.strip(), str(real_arg)); for command in com_args]; for reg, real_reg in regs_map.items():; com_regs = [command.replace(reg.strip(), str(real_reg)); for command in com_regs]; com_args = [eval(arg) for arg in com_args]. if name in self.predefined_gates:; qc_temp.user_gates = _get_qiskit_gates(); com_regs = [int(reg) for reg in com_regs]; self._add_predefined_gates(qc_temp, name, com_regs, com_args); else:; self._custom_gate(qc_temp, [name, com_args, com_regs]). def _regs_processor(self, regs, reg_type):; '''; Process register tokens: map them to the :class:`.QubitCircuit` indices; ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/qasm.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/qasm.html
https://qutip.org/docs/4.6/modules/qutip/qip/qasm.html:21982,Modifiability,variab,variable,21982,"plementedError(""QASM: Only OpenQASM 2.0 \; is currently supported.""). if qasm_lines.pop(0) != ""OPENQASM 2.0;"":; raise SyntaxError(""QASM: File does not contain QASM 2.0 header""). qasm_obj = QasmProcessor(qasm_lines, mode=mode, version=version); qasm_obj.commands = _tokenize(qasm_obj.commands). qasm_obj._process_includes(). qasm_obj._initialize_pass(); qc = QubitCircuit(qasm_obj.num_qubits, num_cbits=qasm_obj.num_cbits). qasm_obj._final_pass(qc). return qc. _GATE_NAME_TO_QASM_NAME = {; ""QASMU"": ""U"",; ""RX"": ""rx"",; ""RY"": ""ry"",; ""RZ"": ""rz"",; ""SNOT"": ""h"",; ""X"": ""x"",; ""Y"": ""y"",; ""Z"": ""z"",; ""S"": ""s"",; ""T"": ""t"",; ""CRZ"": ""crz"",; ""CNOT"": ""cx"",; ""TOFFOLI"": ""ccx""; }. class QasmOutput():; """"""; Class for QASM export. Parameters; ----------; version: str, optional; OpenQASM version, currently must be ""2.0"" necessarily.; """""". def __init__(self, version=""2.0""):; self.version = version; self.lines = []; self.gate_name_map = deepcopy(_GATE_NAME_TO_QASM_NAME). def output(self, line="""", n=0):; '''; Pipe QASM output string to QasmOutput's lines variable. Parameters; ----------; line: str, optional; string to be appended to QASM output.; n: int, optional; number of blank lines to be appended to QASM output.; '''. if line:; self.lines.append(line); self.lines = self.lines + [""""] * n. def _flush(self):; '''; Resets QasmOutput variables.; '''. self.lines = []; self.gate_name_map = deepcopy(_GATE_NAME_TO_QASM_NAME). def _qasm_str(self, q_name, q_controls, q_targets, q_args):; '''; Returns QASM string for gate definition or gate application given; name, registers, arguments.; '''. if not q_controls:; q_controls = []; q_regs = q_controls + q_targets. if isinstance(q_targets[0], int):; q_regs = "","".join(['q[{}]'.format(reg) for reg in q_regs]); else:; q_regs = "","".join(q_regs). if q_args:; if isinstance(q_args, list):; q_args = "","".join([str(arg) for arg in q_args]); return ""{}({}) {};"".format(q_name, q_args, q_regs); else:; return ""{} {};"".format(q_name, q_regs). def _qasm_defn_from_resolved(sel",MatchSource.WIKI,docs/4.6/modules/qutip/qip/qasm.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/qasm.html
https://qutip.org/docs/4.6/modules/qutip/qip/qasm.html:22266,Modifiability,variab,variables,22266,"rocess_includes(). qasm_obj._initialize_pass(); qc = QubitCircuit(qasm_obj.num_qubits, num_cbits=qasm_obj.num_cbits). qasm_obj._final_pass(qc). return qc. _GATE_NAME_TO_QASM_NAME = {; ""QASMU"": ""U"",; ""RX"": ""rx"",; ""RY"": ""ry"",; ""RZ"": ""rz"",; ""SNOT"": ""h"",; ""X"": ""x"",; ""Y"": ""y"",; ""Z"": ""z"",; ""S"": ""s"",; ""T"": ""t"",; ""CRZ"": ""crz"",; ""CNOT"": ""cx"",; ""TOFFOLI"": ""ccx""; }. class QasmOutput():; """"""; Class for QASM export. Parameters; ----------; version: str, optional; OpenQASM version, currently must be ""2.0"" necessarily.; """""". def __init__(self, version=""2.0""):; self.version = version; self.lines = []; self.gate_name_map = deepcopy(_GATE_NAME_TO_QASM_NAME). def output(self, line="""", n=0):; '''; Pipe QASM output string to QasmOutput's lines variable. Parameters; ----------; line: str, optional; string to be appended to QASM output.; n: int, optional; number of blank lines to be appended to QASM output.; '''. if line:; self.lines.append(line); self.lines = self.lines + [""""] * n. def _flush(self):; '''; Resets QasmOutput variables.; '''. self.lines = []; self.gate_name_map = deepcopy(_GATE_NAME_TO_QASM_NAME). def _qasm_str(self, q_name, q_controls, q_targets, q_args):; '''; Returns QASM string for gate definition or gate application given; name, registers, arguments.; '''. if not q_controls:; q_controls = []; q_regs = q_controls + q_targets. if isinstance(q_targets[0], int):; q_regs = "","".join(['q[{}]'.format(reg) for reg in q_regs]); else:; q_regs = "","".join(q_regs). if q_args:; if isinstance(q_args, list):; q_args = "","".join([str(arg) for arg in q_args]); return ""{}({}) {};"".format(q_name, q_args, q_regs); else:; return ""{} {};"".format(q_name, q_regs). def _qasm_defn_from_resolved(self, curr_gate, gates_lst):; '''; Resolve QASM definition of QuTiP gate in terms of component gates. Parameters; ----------; curr_gate: :class:`.Gate`; QuTiP gate which needs to be resolved into component gates.; gates_lst: list of :class:`.Gate`; list of gate that constitute QASM definition of self.; '''. ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/qasm.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/qasm.html
https://qutip.org/docs/4.6/modules/qutip/qip/qubits.html:2900,Deployability,update,updated,2900,"# 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['qubit_states']. from qutip.tensor import tensor; from numpy import sqrt; from qutip.states import basis. [docs]def qubit_states(N=1, states=[0]):; """"""; Function to define initial state of the qubits. Parameters; ----------; N : Integer; Number of qubits in the register.; states : List; Initial state of each qubit. Returns; ----------; qstates : Qobj; List of qubits. """"""; state_list = []; for i in range(N):; if N > len(states) and i >= len(states):; state_list.append(0); else:; state_list.append(states[i]). return tensor([alpha * basis(2, 1) + sqrt(1 - alpha**2) * basis(2, 0); for alpha in state_list]). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/qubits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/qubits.html
https://qutip.org/docs/4.6/modules/qutip/qip/algorithms/qft.html:4685,Deployability,update,updated,4685,"(L); dims = [[2] * N, [2] * N]; return Qobj(1.0 / np.sqrt(N2) * L, dims=dims). [docs]def qft_steps(N=1, swapping=True):; """"""; Quantum Fourier Transform operator on N qubits returning the individual; steps as unitary matrices operating from left to right. Parameters; ----------; N: int; Number of qubits.; swap: boolean; Flag indicating sequence of swap gates to be applied at the end or not. Returns; -------; U_step_list: list of qobj; List of Hadamard and controlled rotation gates implementing QFT. """"""; if N < 1:; raise ValueError(""Minimum value of N can be 1""). U_step_list = []; if N == 1:; U_step_list.append(snot()); else:; for i in range(N):; for j in range(i):; U_step_list.append(cphase(np.pi / (2 ** (i - j)), N,; control=i, target=j)); U_step_list.append(snot(N, i)); if swapping:; for i in range(N // 2):; U_step_list.append(swap(N, [N - i - 1, i])). return U_step_list. [docs]def qft_gate_sequence(N=1, swapping=True):; """"""; Quantum Fourier Transform operator on N qubits returning the gate sequence. Parameters; ----------; N: int; Number of qubits.; swap: boolean; Flag indicating sequence of swap gates to be applied at the end or not. Returns; -------; qc: instance of QubitCircuit; Gate sequence of Hadamard and controlled rotation gates implementing; QFT.; """""". if N < 1:; raise ValueError(""Minimum value of N can be 1""). qc = QubitCircuit(N); if N == 1:; qc.add_gate(""SNOT"", targets=[0]); else:; for i in range(N):; for j in range(i):; qc.add_gate(""CPHASE"", targets=[j], controls=[i],; arg_label=r""{\pi/2^{%d}}"" % (i - j),; arg_value=np.pi / (2 ** (i - j))); qc.add_gate(""SNOT"", targets=[i]); if swapping:; for i in range(N // 2):; qc.add_gate(""SWAP"", targets=[N - i - 1, i]). return qc. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/algorithms/qft.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/algorithms/qft.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/cavityqedcompiler.html:3762,Deployability,update,update,3762,"l; A map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; ``(pulse_label, coeff)``, instead of ``(pulse_index, coeff)``.; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer ``pulse_index`` needs to be used; in the compiling routine saved under the attributes ``gate_compiler``. Attributes; ----------; N: int; The number of the component systems. params: dict; A Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc. pulse_dict: dict; A map between the pulse label and its index in the pulse list. gate_compiler: dict; The Python dictionary in the form of {gate_name: decompose_function}.; It saves the decomposition scheme for each gate.; """"""; def __init__(self, N, params, pulse_dict, global_phase=0.):; super(CavityQEDCompiler, self).__init__(; N=N, params=params, pulse_dict=pulse_dict); self.gate_compiler.update({; ""ISWAP"": self.iswap_compiler,; ""SQRTISWAP"": self.sqrtiswap_compiler,; ""RZ"": self.rz_compiler,; ""RX"": self.rx_compiler,; ""GLOBALPHASE"": self.globalphase_compiler; }); self.wq = np.sqrt(self.params[""eps""]**2 + self.params[""delta""]**2); self.Delta = self.wq - self.params[""w0""]; self.global_phase = global_phase. [docs] def rz_compiler(self, gate, args):; """"""; Compiler for the RZ gate; """"""; targets = gate.targets; g = self.params[""sz""][targets[0]]; coeff = np.sign(gate.arg_value) * g; tlist = abs(gate.arg_value) / (2 * g); pulse_info = [(""sz"" + str(targets[0]), coeff)]; return [Instruction(gate, tlist, pulse_info)]. [docs] def rx_compiler(self, gate, args):; """"""; Compiler for the RX gate; """"""; targets = gate.targets; g = self.params[""sx""][targets[0]]; coeff = np.sign(gate.arg_value) * g; tlist = abs(gate.arg_value) / (2 * g); pulse_info = [(""sx"" + str(targets[0]), coeff)]; return [Instruction(gate, tlist, pulse_info)]. [docs] def sqrtiswap_compiler(self, gate, args):; """"""; Compiler for the SQ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/cavityqedcompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/cavityqedcompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/cavityqedcompiler.html:7437,Deployability,update,updated,7437,"n(gate, tlist, pulse_info)]. # corrections; gate1 = Gate(""RZ"", [q1], None, arg_value=-np.pi/4); compiled_gate1 = self.rz_compiler(gate1, args); instruction_list += compiled_gate1; gate2 = Gate(""RZ"", [q2], None, arg_value=-np.pi/4); compiled_gate2 = self.rz_compiler(gate2, args); instruction_list += compiled_gate2; gate3 = Gate(""GLOBALPHASE"", None, None, arg_value=-np.pi/4); self.globalphase_compiler(gate3, args); return instruction_list. [docs] def iswap_compiler(self, gate, args):; """"""; Compiler for the ISWAP gate; """"""; q1, q2 = gate.targets; pulse_info = []; pulse_name = ""sz"" + str(q1); coeff = self.wq[q1] - self.params[""w0""]; pulse_info += [(pulse_name, coeff)]; pulse_name = ""sz"" + str(q2); coeff = self.wq[q2] - self.params[""w0""]; pulse_info += [(pulse_name, coeff)]; pulse_name = ""g"" + str(q1); coeff = self.params[""g""][q1]; pulse_info += [(pulse_name, coeff)]; pulse_name = ""g"" + str(q2); coeff = self.params[""g""][q2]; pulse_info += [(pulse_name, coeff)]. J = self.params[""g""][q1] * self.params[""g""][q2] * (; 1 / self.Delta[q1] + 1 / self.Delta[q2]) / 2; tlist = (4 * np.pi / abs(J)) / 4; instruction_list = [Instruction(gate, tlist, pulse_info)]. # corrections; gate1 = Gate(""RZ"", [q1], None, arg_value=-np.pi/2.); compiled_gate1 = self.rz_compiler(gate1, args); instruction_list += compiled_gate1; gate2 = Gate(""RZ"", [q2], None, arg_value=-np.pi/2); compiled_gate2 = self.rz_compiler(gate2, args); instruction_list += compiled_gate2; gate3 = Gate(""GLOBALPHASE"", None, None, arg_value=-np.pi/2); self.globalphase_compiler(gate3, args); return instruction_list. [docs] def globalphase_compiler(self, gate, args):; """"""; Compiler for the GLOBALPHASE gate; """"""; self.global_phase += gate.arg_value. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/cavityqedcompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/cavityqedcompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/cavityqedcompiler.html:3120,Integrability,rout,routine,3120,"##########################################; import numpy as np. from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.compiler import GateCompiler, Instruction. __all__ = ['CavityQEDCompiler']. [docs]class CavityQEDCompiler(GateCompiler):; """"""; Decompose a :class:`.QubitCircuit` into; the pulse sequence for the processor. Parameters; ----------; N: int; The number of qubits in the system. params: dict; A Python dictionary contains the name and the value of the parameters.; See :meth:`.DispersiveCavityQED.set_up_params` for the definition. global_phase: float, optional; Record of the global phase change and will be returned. pulse_dict: dict, optional; A map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; ``(pulse_label, coeff)``, instead of ``(pulse_index, coeff)``.; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer ``pulse_index`` needs to be used; in the compiling routine saved under the attributes ``gate_compiler``. Attributes; ----------; N: int; The number of the component systems. params: dict; A Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc. pulse_dict: dict; A map between the pulse label and its index in the pulse list. gate_compiler: dict; The Python dictionary in the form of {gate_name: decompose_function}.; It saves the decomposition scheme for each gate.; """"""; def __init__(self, N, params, pulse_dict, global_phase=0.):; super(CavityQEDCompiler, self).__init__(; N=N, params=params, pulse_dict=pulse_dict); self.gate_compiler.update({; ""ISWAP"": self.iswap_compiler,; ""SQRTISWAP"": self.sqrtiswap_compiler,; ""RZ"": self.rz_compiler,; ""RX"": self.rx_compiler,; ""GLOBALPHASE"": self.globalphase_compiler; }); self.wq = np.sqrt(self.params[""eps""]**2 + self.params[""delta""]**2); self.Delta = self.wq - self.params[""w0""]; self.global_phase = global_phase. [docs] def rz_compiler(se",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/cavityqedcompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/cavityqedcompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:3480,Deployability,continuous,continuous,3480,"sub-class and concatenate; the compiled pulses. Parameters; ----------; N: int; The number of the component systems. params: dict, optional; A Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optional; A map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; ``(pulse_label, coeff)``, instead of ``(pulse_index, coeff)``.; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer ``pulse_index`` needs to be used; in the compiling routine saved under the attributes ``gate_compiler``. Attributes; ----------; gate_compiler: dict; The Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dict; Arguments for individual compiling routines.; It adds more flexibility in customizing compiler.; """"""; def __init__(self, N, params=None, pulse_dict=None):; self.gate_compiler = {}; self.N = N; self.params = params if params is not None else {}; self.pulse_dict = pulse_dict if pulse_dict is not None else {}; self.gate_compiler = {""GLOBALPHASE"": self.globalphase_compiler}; self.args = {""params"": self.params}; self.global_phase = 0. [docs] def globalphase_compiler(self, gate, args):; """"""; Compiler for the GLOBALPHASE gate; """"""; pass. [docs] def compile(self, circuit, schedule_mode=None, args=None):; """"""; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters; ----------; circuit: :class:`.QubitCircuit` or list of; :class:`.Gate`; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in `gate_compiler`. s",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:5128,Deployability,update,update,5128,"):; """"""; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters; ----------; circuit: :class:`.QubitCircuit` or list of; :class:`.Gate`; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in `gate_compiler`. schedule_mode: str, optional; ``""ASAP""`` for ""as soon as possible"" or; ``""ALAP""`` for ""as late as possible"" or; ``False`` or ``None`` for no schedule.; Default is None. args: dict, optional; A dictionary of arguments used in a specific gate compiler; function. Returns; -------; tlist: array_like; A NumPy array specifies the time of each coefficient. coeffs: array_like; A 2d NumPy array of the shape ``(len(ctrls), len(tlist))``. Each; row corresponds to the control pulse sequence for; one Hamiltonian.; """"""; if isinstance(circuit, QubitCircuit):; gates = circuit.gates; else:; gates = circuit; if args is not None:; self.args.update(args); instruction_list = []. # compile gates; for gate in gates:; if gate.name not in self.gate_compiler:; raise ValueError(""Unsupported gate %s"" % gate.name); instruction = self.gate_compiler[gate.name](gate, self.args); if instruction is None:; continue # neglecting global phase gate; instruction_list += instruction; if not instruction_list:; return None, None; if self.pulse_dict:; num_controls = len(self.pulse_dict); else: # if pulse_dict is not given, compute the number of pulses; num_controls = 0; for instruction in instruction_list:; for pulse_index, _ in instruction.pulse_info:; num_controls = max(num_controls, pulse_index); num_controls += 1. # schedule; # scheduled_start_time:; # An ordered list of the start_time for each pulse,; # corresponding to gates in the instruction_list.; # instruction_list reordered according to the scheduled result; instruction_list, scheduled_start_time = \; self._schedule(instruction_list, schedule_mode). # An instruction can be composed from several differe",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:8338,Deployability,continuous,continuous,8338,"on in instruction_list[:-1]:; scheduled_start_time.append(; instruction.duration + scheduled_start_time[-1]); return instruction_list, scheduled_start_time. def _concatenate_pulses(; self, pulse_instructions, scheduled_start_time, num_controls):; """"""; Concatenate compiled pulses coefficients and tlist for each pulse.; If there is idling time, add zeros properly to prevent wrong spline.; """"""; # Concatenate tlist and coeffs for each control pulses; compiled_tlist = [[] for tmp in range(num_controls)]; compiled_coeffs = [[] for tmp in range(num_controls)]; for pulse_ind in range(num_controls):; last_pulse_time = 0.; for start_time, tlist, coeff in pulse_instructions[pulse_ind]:; # compute the gate time, step size and coeffs; # according to different pulse mode; gate_tlist, coeffs, step_size, pulse_mode = \; self._process_gate_pulse(start_time, tlist, coeff). if abs(last_pulse_time) < step_size * 1.0e-6: # if first pulse; compiled_tlist[pulse_ind].append([0.]) ; if pulse_mode == ""continuous"":; compiled_coeffs[pulse_ind].append([0.]); # for discrete pulse len(coeffs) = len(tlist) - 1. # If there is idling time between the last pulse and; # the current one, we need to add zeros in between.; if np.abs(start_time - last_pulse_time) > step_size * 1.0e-6:; idling_tlist = self._process_idling_tlist(; pulse_mode, start_time, last_pulse_time, step_size); compiled_tlist[pulse_ind].append(idling_tlist); compiled_coeffs[pulse_ind].append(np.zeros(len(idling_tlist))). # Add the gate time and coeffs to the list.; execution_time = gate_tlist + start_time; last_pulse_time = execution_time[-1]; compiled_tlist[pulse_ind].append(execution_time); compiled_coeffs[pulse_ind].append(coeffs). for i in range(num_controls):; if not compiled_coeffs[i]:; compiled_tlist[i] = None; compiled_coeffs[i] = None; else:; compiled_tlist[i] = np.concatenate(compiled_tlist[i]); compiled_coeffs[i] = np.concatenate(compiled_coeffs[i]); return compiled_tlist, compiled_coeffs. def _process_gate_pulse(; self, sta",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:9936,Deployability,continuous,continuous,9936," last_pulse_time = execution_time[-1]; compiled_tlist[pulse_ind].append(execution_time); compiled_coeffs[pulse_ind].append(coeffs). for i in range(num_controls):; if not compiled_coeffs[i]:; compiled_tlist[i] = None; compiled_coeffs[i] = None; else:; compiled_tlist[i] = np.concatenate(compiled_tlist[i]); compiled_coeffs[i] = np.concatenate(compiled_coeffs[i]); return compiled_tlist, compiled_coeffs. def _process_gate_pulse(; self, start_time, tlist, coeff):; # compute the gate time, step size and coeffs; # according to different pulse mode; if np.isscalar(tlist):; pulse_mode = ""discrete""; # a single constant rectanglar pulse, where; # tlist and coeff are just float numbers; step_size = tlist; coeff = np.array([coeff]); gate_tlist = np.array([tlist]); elif len(tlist) - 1 == len(coeff):; # discrete pulse; pulse_mode = ""discrete""; step_size = tlist[1] - tlist[0]; coeff = np.asarray(coeff); gate_tlist = np.asarray(tlist)[1:] # first t always 0 by def; elif len(tlist) == len(coeff):; # continuos pulse; pulse_mode = ""continuous""; step_size = tlist[1] - tlist[0]; coeff = np.asarray(coeff)[1:]; gate_tlist = np.asarray(tlist)[1:]; else:; raise ValueError(; ""The shape of the compiled pulse is not correct.""); return gate_tlist, coeff, step_size, pulse_mode. def _process_idling_tlist(; self, pulse_mode, start_time, last_pulse_time, step_size):; idling_tlist = []; if pulse_mode == ""continuous"":; # We add sufficient number of zeros at the begining; # and the end of the idling to prevent wrong cubic spline.; if start_time - last_pulse_time > 3 * step_size:; idling_tlist1 = np.linspace(; last_pulse_time + step_size/5,; last_pulse_time + step_size,; 5; ); idling_tlist2 = np.linspace(; start_time - step_size,; start_time,; 5; ); idling_tlist.extend([idling_tlist1, idling_tlist2]); else:; idling_tlist.append(; np.arange(; last_pulse_time + step_size,; start_time, step_size; ); ); elif pulse_mode == ""discrete"":; # idling until the start time; idling_tlist.append([start_time]); return n",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:10301,Deployability,continuous,continuous,10301,"ffs[i] = np.concatenate(compiled_coeffs[i]); return compiled_tlist, compiled_coeffs. def _process_gate_pulse(; self, start_time, tlist, coeff):; # compute the gate time, step size and coeffs; # according to different pulse mode; if np.isscalar(tlist):; pulse_mode = ""discrete""; # a single constant rectanglar pulse, where; # tlist and coeff are just float numbers; step_size = tlist; coeff = np.array([coeff]); gate_tlist = np.array([tlist]); elif len(tlist) - 1 == len(coeff):; # discrete pulse; pulse_mode = ""discrete""; step_size = tlist[1] - tlist[0]; coeff = np.asarray(coeff); gate_tlist = np.asarray(tlist)[1:] # first t always 0 by def; elif len(tlist) == len(coeff):; # continuos pulse; pulse_mode = ""continuous""; step_size = tlist[1] - tlist[0]; coeff = np.asarray(coeff)[1:]; gate_tlist = np.asarray(tlist)[1:]; else:; raise ValueError(; ""The shape of the compiled pulse is not correct.""); return gate_tlist, coeff, step_size, pulse_mode. def _process_idling_tlist(; self, pulse_mode, start_time, last_pulse_time, step_size):; idling_tlist = []; if pulse_mode == ""continuous"":; # We add sufficient number of zeros at the begining; # and the end of the idling to prevent wrong cubic spline.; if start_time - last_pulse_time > 3 * step_size:; idling_tlist1 = np.linspace(; last_pulse_time + step_size/5,; last_pulse_time + step_size,; 5; ); idling_tlist2 = np.linspace(; start_time - step_size,; start_time,; 5; ); idling_tlist.extend([idling_tlist1, idling_tlist2]); else:; idling_tlist.append(; np.arange(; last_pulse_time + step_size,; start_time, step_size; ); ); elif pulse_mode == ""discrete"":; # idling until the start time; idling_tlist.append([start_time]); return np.concatenate(idling_tlist). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:11126,Deployability,update,updated,11126,"ffs[i] = np.concatenate(compiled_coeffs[i]); return compiled_tlist, compiled_coeffs. def _process_gate_pulse(; self, start_time, tlist, coeff):; # compute the gate time, step size and coeffs; # according to different pulse mode; if np.isscalar(tlist):; pulse_mode = ""discrete""; # a single constant rectanglar pulse, where; # tlist and coeff are just float numbers; step_size = tlist; coeff = np.array([coeff]); gate_tlist = np.array([tlist]); elif len(tlist) - 1 == len(coeff):; # discrete pulse; pulse_mode = ""discrete""; step_size = tlist[1] - tlist[0]; coeff = np.asarray(coeff); gate_tlist = np.asarray(tlist)[1:] # first t always 0 by def; elif len(tlist) == len(coeff):; # continuos pulse; pulse_mode = ""continuous""; step_size = tlist[1] - tlist[0]; coeff = np.asarray(coeff)[1:]; gate_tlist = np.asarray(tlist)[1:]; else:; raise ValueError(; ""The shape of the compiled pulse is not correct.""); return gate_tlist, coeff, step_size, pulse_mode. def _process_idling_tlist(; self, pulse_mode, start_time, last_pulse_time, step_size):; idling_tlist = []; if pulse_mode == ""continuous"":; # We add sufficient number of zeros at the begining; # and the end of the idling to prevent wrong cubic spline.; if start_time - last_pulse_time > 3 * step_size:; idling_tlist1 = np.linspace(; last_pulse_time + step_size/5,; last_pulse_time + step_size,; 5; ); idling_tlist2 = np.linspace(; start_time - step_size,; start_time,; 5; ); idling_tlist.extend([idling_tlist1, idling_tlist2]); else:; idling_tlist.append(; np.arange(; last_pulse_time + step_size,; start_time, step_size; ); ); elif pulse_mode == ""discrete"":; # idling until the start time; idling_tlist.append([start_time]); return np.concatenate(idling_tlist). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:2199,Energy Efficiency,schedul,scheduler,2199,"e without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; import numpy as np; from .instruction import Instruction; from .scheduler import Scheduler; from ..circuit import QubitCircuit, Gate. __all__ = ['GateCompiler']. [docs]class GateCompiler(object):; """"""; Base class. It compiles a :class:`.QubitCircuit` into; the pulse sequence for the processor. The core member function; `compile` calls compiling method from the sub-class and concatenate; the compiled pulses. Parameters; ----------; N: int; The number of the component systems. params: dict, optional; A Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optional; A map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; ``(pulse_label, coeff)``, instead of ``(pulse_index, coeff)``.; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer ``pulse_index`` needs to be used; in the compiling rou",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:4639,Energy Efficiency,schedul,schedule,4639,"ompiling routines.; It adds more flexibility in customizing compiler.; """"""; def __init__(self, N, params=None, pulse_dict=None):; self.gate_compiler = {}; self.N = N; self.params = params if params is not None else {}; self.pulse_dict = pulse_dict if pulse_dict is not None else {}; self.gate_compiler = {""GLOBALPHASE"": self.globalphase_compiler}; self.args = {""params"": self.params}; self.global_phase = 0. [docs] def globalphase_compiler(self, gate, args):; """"""; Compiler for the GLOBALPHASE gate; """"""; pass. [docs] def compile(self, circuit, schedule_mode=None, args=None):; """"""; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters; ----------; circuit: :class:`.QubitCircuit` or list of; :class:`.Gate`; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in `gate_compiler`. schedule_mode: str, optional; ``""ASAP""`` for ""as soon as possible"" or; ``""ALAP""`` for ""as late as possible"" or; ``False`` or ``None`` for no schedule.; Default is None. args: dict, optional; A dictionary of arguments used in a specific gate compiler; function. Returns; -------; tlist: array_like; A NumPy array specifies the time of each coefficient. coeffs: array_like; A 2d NumPy array of the shape ``(len(ctrls), len(tlist))``. Each; row corresponds to the control pulse sequence for; one Hamiltonian.; """"""; if isinstance(circuit, QubitCircuit):; gates = circuit.gates; else:; gates = circuit; if args is not None:; self.args.update(args); instruction_list = []. # compile gates; for gate in gates:; if gate.name not in self.gate_compiler:; raise ValueError(""Unsupported gate %s"" % gate.name); instruction = self.gate_compiler[gate.name](gate, self.args); if instruction is None:; continue # neglecting global phase gate; instruction_list += instruction; if not instruction_list:; return None, None; if self.pulse_dict:; num_controls = len(self.pulse_dict); else: # if pu",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:5797,Energy Efficiency,schedul,schedule,5797,"like; A 2d NumPy array of the shape ``(len(ctrls), len(tlist))``. Each; row corresponds to the control pulse sequence for; one Hamiltonian.; """"""; if isinstance(circuit, QubitCircuit):; gates = circuit.gates; else:; gates = circuit; if args is not None:; self.args.update(args); instruction_list = []. # compile gates; for gate in gates:; if gate.name not in self.gate_compiler:; raise ValueError(""Unsupported gate %s"" % gate.name); instruction = self.gate_compiler[gate.name](gate, self.args); if instruction is None:; continue # neglecting global phase gate; instruction_list += instruction; if not instruction_list:; return None, None; if self.pulse_dict:; num_controls = len(self.pulse_dict); else: # if pulse_dict is not given, compute the number of pulses; num_controls = 0; for instruction in instruction_list:; for pulse_index, _ in instruction.pulse_info:; num_controls = max(num_controls, pulse_index); num_controls += 1. # schedule; # scheduled_start_time:; # An ordered list of the start_time for each pulse,; # corresponding to gates in the instruction_list.; # instruction_list reordered according to the scheduled result; instruction_list, scheduled_start_time = \; self._schedule(instruction_list, schedule_mode). # An instruction can be composed from several different pulse elements.; # We separate them an assign them to each pulse index.; pulse_instructions = [[] for tmp in range(num_controls)]; for instruction, start_time in \; zip(instruction_list, scheduled_start_time):; for pulse_name, coeff in instruction.pulse_info:; if self.pulse_dict:; try:; pulse_ind = self.pulse_dict[pulse_name]; except KeyError:; raise ValueError(; f""Pulse name {pulse_name} not found""; "" in pulse_dict.""); else:; pulse_ind = pulse_name; pulse_instructions[pulse_ind].append(; (start_time, instruction.tlist, coeff)). # concatenate pulses; compiled_tlist, compiled_coeffs = \; self._concatenate_pulses(; pulse_instructions, scheduled_start_time, num_controls); return compiled_tlist, compiled_coeff",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:5982,Energy Efficiency,schedul,scheduled,5982,"Hamiltonian.; """"""; if isinstance(circuit, QubitCircuit):; gates = circuit.gates; else:; gates = circuit; if args is not None:; self.args.update(args); instruction_list = []. # compile gates; for gate in gates:; if gate.name not in self.gate_compiler:; raise ValueError(""Unsupported gate %s"" % gate.name); instruction = self.gate_compiler[gate.name](gate, self.args); if instruction is None:; continue # neglecting global phase gate; instruction_list += instruction; if not instruction_list:; return None, None; if self.pulse_dict:; num_controls = len(self.pulse_dict); else: # if pulse_dict is not given, compute the number of pulses; num_controls = 0; for instruction in instruction_list:; for pulse_index, _ in instruction.pulse_info:; num_controls = max(num_controls, pulse_index); num_controls += 1. # schedule; # scheduled_start_time:; # An ordered list of the start_time for each pulse,; # corresponding to gates in the instruction_list.; # instruction_list reordered according to the scheduled result; instruction_list, scheduled_start_time = \; self._schedule(instruction_list, schedule_mode). # An instruction can be composed from several different pulse elements.; # We separate them an assign them to each pulse index.; pulse_instructions = [[] for tmp in range(num_controls)]; for instruction, start_time in \; zip(instruction_list, scheduled_start_time):; for pulse_name, coeff in instruction.pulse_info:; if self.pulse_dict:; try:; pulse_ind = self.pulse_dict[pulse_name]; except KeyError:; raise ValueError(; f""Pulse name {pulse_name} not found""; "" in pulse_dict.""); else:; pulse_ind = pulse_name; pulse_instructions[pulse_ind].append(; (start_time, instruction.tlist, coeff)). # concatenate pulses; compiled_tlist, compiled_coeffs = \; self._concatenate_pulses(; pulse_instructions, scheduled_start_time, num_controls); return compiled_tlist, compiled_coeffs. def _schedule(self, instruction_list, schedule_mode):; """"""; Schedule the instructions if required and ; reorder instruction_l",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:7033,Energy Efficiency,schedul,scheduler,7033,"eduled result; instruction_list, scheduled_start_time = \; self._schedule(instruction_list, schedule_mode). # An instruction can be composed from several different pulse elements.; # We separate them an assign them to each pulse index.; pulse_instructions = [[] for tmp in range(num_controls)]; for instruction, start_time in \; zip(instruction_list, scheduled_start_time):; for pulse_name, coeff in instruction.pulse_info:; if self.pulse_dict:; try:; pulse_ind = self.pulse_dict[pulse_name]; except KeyError:; raise ValueError(; f""Pulse name {pulse_name} not found""; "" in pulse_dict.""); else:; pulse_ind = pulse_name; pulse_instructions[pulse_ind].append(; (start_time, instruction.tlist, coeff)). # concatenate pulses; compiled_tlist, compiled_coeffs = \; self._concatenate_pulses(; pulse_instructions, scheduled_start_time, num_controls); return compiled_tlist, compiled_coeffs. def _schedule(self, instruction_list, schedule_mode):; """"""; Schedule the instructions if required and ; reorder instruction_list accordingly; """"""; if schedule_mode:; scheduler = Scheduler(schedule_mode); scheduled_start_time = scheduler.schedule(instruction_list); time_ordered_pos = np.argsort(scheduled_start_time); instruction_list = [instruction_list[i] for i in time_ordered_pos]; scheduled_start_time.sort(); else: # no scheduling; scheduled_start_time = [0.]; for instruction in instruction_list[:-1]:; scheduled_start_time.append(; instruction.duration + scheduled_start_time[-1]); return instruction_list, scheduled_start_time. def _concatenate_pulses(; self, pulse_instructions, scheduled_start_time, num_controls):; """"""; Concatenate compiled pulses coefficients and tlist for each pulse.; If there is idling time, add zeros properly to prevent wrong spline.; """"""; # Concatenate tlist and coeffs for each control pulses; compiled_tlist = [[] for tmp in range(num_controls)]; compiled_coeffs = [[] for tmp in range(num_controls)]; for pulse_ind in range(num_controls):; last_pulse_time = 0.; for start_time, t",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:7094,Energy Efficiency,schedul,scheduler,7094,"eduled result; instruction_list, scheduled_start_time = \; self._schedule(instruction_list, schedule_mode). # An instruction can be composed from several different pulse elements.; # We separate them an assign them to each pulse index.; pulse_instructions = [[] for tmp in range(num_controls)]; for instruction, start_time in \; zip(instruction_list, scheduled_start_time):; for pulse_name, coeff in instruction.pulse_info:; if self.pulse_dict:; try:; pulse_ind = self.pulse_dict[pulse_name]; except KeyError:; raise ValueError(; f""Pulse name {pulse_name} not found""; "" in pulse_dict.""); else:; pulse_ind = pulse_name; pulse_instructions[pulse_ind].append(; (start_time, instruction.tlist, coeff)). # concatenate pulses; compiled_tlist, compiled_coeffs = \; self._concatenate_pulses(; pulse_instructions, scheduled_start_time, num_controls); return compiled_tlist, compiled_coeffs. def _schedule(self, instruction_list, schedule_mode):; """"""; Schedule the instructions if required and ; reorder instruction_list accordingly; """"""; if schedule_mode:; scheduler = Scheduler(schedule_mode); scheduled_start_time = scheduler.schedule(instruction_list); time_ordered_pos = np.argsort(scheduled_start_time); instruction_list = [instruction_list[i] for i in time_ordered_pos]; scheduled_start_time.sort(); else: # no scheduling; scheduled_start_time = [0.]; for instruction in instruction_list[:-1]:; scheduled_start_time.append(; instruction.duration + scheduled_start_time[-1]); return instruction_list, scheduled_start_time. def _concatenate_pulses(; self, pulse_instructions, scheduled_start_time, num_controls):; """"""; Concatenate compiled pulses coefficients and tlist for each pulse.; If there is idling time, add zeros properly to prevent wrong spline.; """"""; # Concatenate tlist and coeffs for each control pulses; compiled_tlist = [[] for tmp in range(num_controls)]; compiled_coeffs = [[] for tmp in range(num_controls)]; for pulse_ind in range(num_controls):; last_pulse_time = 0.; for start_time, t",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:7104,Energy Efficiency,schedul,schedule,7104,"m several different pulse elements.; # We separate them an assign them to each pulse index.; pulse_instructions = [[] for tmp in range(num_controls)]; for instruction, start_time in \; zip(instruction_list, scheduled_start_time):; for pulse_name, coeff in instruction.pulse_info:; if self.pulse_dict:; try:; pulse_ind = self.pulse_dict[pulse_name]; except KeyError:; raise ValueError(; f""Pulse name {pulse_name} not found""; "" in pulse_dict.""); else:; pulse_ind = pulse_name; pulse_instructions[pulse_ind].append(; (start_time, instruction.tlist, coeff)). # concatenate pulses; compiled_tlist, compiled_coeffs = \; self._concatenate_pulses(; pulse_instructions, scheduled_start_time, num_controls); return compiled_tlist, compiled_coeffs. def _schedule(self, instruction_list, schedule_mode):; """"""; Schedule the instructions if required and ; reorder instruction_list accordingly; """"""; if schedule_mode:; scheduler = Scheduler(schedule_mode); scheduled_start_time = scheduler.schedule(instruction_list); time_ordered_pos = np.argsort(scheduled_start_time); instruction_list = [instruction_list[i] for i in time_ordered_pos]; scheduled_start_time.sort(); else: # no scheduling; scheduled_start_time = [0.]; for instruction in instruction_list[:-1]:; scheduled_start_time.append(; instruction.duration + scheduled_start_time[-1]); return instruction_list, scheduled_start_time. def _concatenate_pulses(; self, pulse_instructions, scheduled_start_time, num_controls):; """"""; Concatenate compiled pulses coefficients and tlist for each pulse.; If there is idling time, add zeros properly to prevent wrong spline.; """"""; # Concatenate tlist and coeffs for each control pulses; compiled_tlist = [[] for tmp in range(num_controls)]; compiled_coeffs = [[] for tmp in range(num_controls)]; for pulse_ind in range(num_controls):; last_pulse_time = 0.; for start_time, tlist, coeff in pulse_instructions[pulse_ind]:; # compute the gate time, step size and coeffs; # according to different pulse mode; gate_tlist, c",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:7293,Energy Efficiency,schedul,scheduling,7293,"_time in \; zip(instruction_list, scheduled_start_time):; for pulse_name, coeff in instruction.pulse_info:; if self.pulse_dict:; try:; pulse_ind = self.pulse_dict[pulse_name]; except KeyError:; raise ValueError(; f""Pulse name {pulse_name} not found""; "" in pulse_dict.""); else:; pulse_ind = pulse_name; pulse_instructions[pulse_ind].append(; (start_time, instruction.tlist, coeff)). # concatenate pulses; compiled_tlist, compiled_coeffs = \; self._concatenate_pulses(; pulse_instructions, scheduled_start_time, num_controls); return compiled_tlist, compiled_coeffs. def _schedule(self, instruction_list, schedule_mode):; """"""; Schedule the instructions if required and ; reorder instruction_list accordingly; """"""; if schedule_mode:; scheduler = Scheduler(schedule_mode); scheduled_start_time = scheduler.schedule(instruction_list); time_ordered_pos = np.argsort(scheduled_start_time); instruction_list = [instruction_list[i] for i in time_ordered_pos]; scheduled_start_time.sort(); else: # no scheduling; scheduled_start_time = [0.]; for instruction in instruction_list[:-1]:; scheduled_start_time.append(; instruction.duration + scheduled_start_time[-1]); return instruction_list, scheduled_start_time. def _concatenate_pulses(; self, pulse_instructions, scheduled_start_time, num_controls):; """"""; Concatenate compiled pulses coefficients and tlist for each pulse.; If there is idling time, add zeros properly to prevent wrong spline.; """"""; # Concatenate tlist and coeffs for each control pulses; compiled_tlist = [[] for tmp in range(num_controls)]; compiled_coeffs = [[] for tmp in range(num_controls)]; for pulse_ind in range(num_controls):; last_pulse_time = 0.; for start_time, tlist, coeff in pulse_instructions[pulse_ind]:; # compute the gate time, step size and coeffs; # according to different pulse mode; gate_tlist, coeffs, step_size, pulse_mode = \; self._process_gate_pulse(start_time, tlist, coeff). if abs(last_pulse_time) < step_size * 1.0e-6: # if first pulse; compiled_tlist[pulse_ind",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:3213,Integrability,rout,routine,3213,"scheduler import Scheduler; from ..circuit import QubitCircuit, Gate. __all__ = ['GateCompiler']. [docs]class GateCompiler(object):; """"""; Base class. It compiles a :class:`.QubitCircuit` into; the pulse sequence for the processor. The core member function; `compile` calls compiling method from the sub-class and concatenate; the compiled pulses. Parameters; ----------; N: int; The number of the component systems. params: dict, optional; A Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optional; A map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; ``(pulse_label, coeff)``, instead of ``(pulse_index, coeff)``.; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer ``pulse_index`` needs to be used; in the compiling routine saved under the attributes ``gate_compiler``. Attributes; ----------; gate_compiler: dict; The Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dict; Arguments for individual compiling routines.; It adds more flexibility in customizing compiler.; """"""; def __init__(self, N, params=None, pulse_dict=None):; self.gate_compiler = {}; self.N = N; self.params = params if params is not None else {}; self.pulse_dict = pulse_dict if pulse_dict is not None else {}; self.gate_compiler = {""GLOBALPHASE"": self.globalphase_compiler}; self.args = {""params"": self.params}; self.global_phase = 0. [docs] def globalphase_compiler(self, gate, args):; """"""; Compiler for the GLOBALPHASE gate; """"""; pass. [docs] def compile(self, circuit, schedule_mode=None, args=None):; """"""; Compile the the native gates into control pul",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:3405,Integrability,rout,routine,3405,"equence for the processor. The core member function; `compile` calls compiling method from the sub-class and concatenate; the compiled pulses. Parameters; ----------; N: int; The number of the component systems. params: dict, optional; A Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optional; A map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; ``(pulse_label, coeff)``, instead of ``(pulse_index, coeff)``.; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer ``pulse_index`` needs to be used; in the compiling routine saved under the attributes ``gate_compiler``. Attributes; ----------; gate_compiler: dict; The Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dict; Arguments for individual compiling routines.; It adds more flexibility in customizing compiler.; """"""; def __init__(self, N, params=None, pulse_dict=None):; self.gate_compiler = {}; self.N = N; self.params = params if params is not None else {}; self.pulse_dict = pulse_dict if pulse_dict is not None else {}; self.gate_compiler = {""GLOBALPHASE"": self.globalphase_compiler}; self.args = {""params"": self.params}; self.global_phase = 0. [docs] def globalphase_compiler(self, gate, args):; """"""; Compiler for the GLOBALPHASE gate; """"""; pass. [docs] def compile(self, circuit, schedule_mode=None, args=None):; """"""; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters; ----------; circuit: :class:`.QubitCircuit` or list of; :class:`.Gate`; A list of elementary gates that can ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:3581,Integrability,rout,routines,3581,"-------; N: int; The number of the component systems. params: dict, optional; A Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optional; A map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; ``(pulse_label, coeff)``, instead of ``(pulse_index, coeff)``.; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer ``pulse_index`` needs to be used; in the compiling routine saved under the attributes ``gate_compiler``. Attributes; ----------; gate_compiler: dict; The Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dict; Arguments for individual compiling routines.; It adds more flexibility in customizing compiler.; """"""; def __init__(self, N, params=None, pulse_dict=None):; self.gate_compiler = {}; self.N = N; self.params = params if params is not None else {}; self.pulse_dict = pulse_dict if pulse_dict is not None else {}; self.gate_compiler = {""GLOBALPHASE"": self.globalphase_compiler}; self.args = {""params"": self.params}; self.global_phase = 0. [docs] def globalphase_compiler(self, gate, args):; """"""; Compiler for the GLOBALPHASE gate; """"""; pass. [docs] def compile(self, circuit, schedule_mode=None, args=None):; """"""; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters; ----------; circuit: :class:`.QubitCircuit` or list of; :class:`.Gate`; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in `gate_compiler`. schedule_mode: str, optional; ``""ASAP""`` for ""as soon as possibl",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:10663,Modifiability,extend,extend,10663,"ffs[i] = np.concatenate(compiled_coeffs[i]); return compiled_tlist, compiled_coeffs. def _process_gate_pulse(; self, start_time, tlist, coeff):; # compute the gate time, step size and coeffs; # according to different pulse mode; if np.isscalar(tlist):; pulse_mode = ""discrete""; # a single constant rectanglar pulse, where; # tlist and coeff are just float numbers; step_size = tlist; coeff = np.array([coeff]); gate_tlist = np.array([tlist]); elif len(tlist) - 1 == len(coeff):; # discrete pulse; pulse_mode = ""discrete""; step_size = tlist[1] - tlist[0]; coeff = np.asarray(coeff); gate_tlist = np.asarray(tlist)[1:] # first t always 0 by def; elif len(tlist) == len(coeff):; # continuos pulse; pulse_mode = ""continuous""; step_size = tlist[1] - tlist[0]; coeff = np.asarray(coeff)[1:]; gate_tlist = np.asarray(tlist)[1:]; else:; raise ValueError(; ""The shape of the compiled pulse is not correct.""); return gate_tlist, coeff, step_size, pulse_mode. def _process_idling_tlist(; self, pulse_mode, start_time, last_pulse_time, step_size):; idling_tlist = []; if pulse_mode == ""continuous"":; # We add sufficient number of zeros at the begining; # and the end of the idling to prevent wrong cubic spline.; if start_time - last_pulse_time > 3 * step_size:; idling_tlist1 = np.linspace(; last_pulse_time + step_size/5,; last_pulse_time + step_size,; 5; ); idling_tlist2 = np.linspace(; start_time - step_size,; start_time,; 5; ); idling_tlist.extend([idling_tlist1, idling_tlist2]); else:; idling_tlist.append(; np.arange(; last_pulse_time + step_size,; start_time, step_size; ); ); elif pulse_mode == ""discrete"":; # idling until the start time; idling_tlist.append([start_time]); return np.concatenate(idling_tlist). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/instruction.html:4046,Deployability,update,updated,4046,"t deepcopy; import numpy as np. __all__ = ['Instruction']. [docs]class Instruction():; """"""; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters; ----------; gate: :class:`.Gate`; The quantum gate.; duration: list, optional; The execution time needed for the instruction.; tlist: array_like, optional; A list of time at which the time-dependent coefficients are; applied. See :class:`.Pulse` for detailed information`; pulse_info: list, optional; A list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes; ----------; targets: list, optional; The target qubits.; controls: list, optional; The control qubits.; used_qubits: set; Union of the control and target qubits.; """"""; def __init__(; self, gate, tlist=None,; pulse_info=(), duration=1):; self.gate = deepcopy(gate); self.used_qubits = set(); if self.targets is not None:; self.targets.sort() # Used when comparing the instructions; self.used_qubits |= set(self.targets); if self.controls is not None:; self.controls.sort(); self.used_qubits |= set(self.controls); self.tlist = tlist; if self.tlist is not None:; if np.isscalar(self.tlist):; self.duration = self.tlist; elif abs(self.tlist[0]) > 1.e-8:; raise ValueError(""Pulse time sequence must start from 0""); else:; self.duration = self.tlist[-1]; else:; self.duration = duration; self.pulse_info = pulse_info. @property; def name(self):; return self.gate.name. @property; def targets(self):; return self.gate.targets. @property; def controls(self):; return self.gate.controls. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/instruction.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/instruction.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/instruction.html:2583,Integrability,depend,dependent,2583,"RS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from copy import deepcopy; import numpy as np. __all__ = ['Instruction']. [docs]class Instruction():; """"""; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters; ----------; gate: :class:`.Gate`; The quantum gate.; duration: list, optional; The execution time needed for the instruction.; tlist: array_like, optional; A list of time at which the time-dependent coefficients are; applied. See :class:`.Pulse` for detailed information`; pulse_info: list, optional; A list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes; ----------; targets: list, optional; The target qubits.; controls: list, optional; The control qubits.; used_qubits: set; Union of the control and target qubits.; """"""; def __init__(; self, gate, tlist=None,; pulse_info=(), duration=1):; self.gate = deepcopy(gate); self.used_qubits = set(); if self.targets is not None:; self.targets.sort() # Used when comparing the instructions; self.used_qubits |= set(self.targets); if self.controls is not None:; self.controls.sort(); self.used_qubits |= set(self.controls); self.tlist = tlist; if self.tlist is not None:; if np.isscalar(self.tlist):; self.duration = self.tlist; elif abs(self.tlist[0]) > 1.e-8:; raise ValueError(""Pulse time sequence m",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/instruction.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/instruction.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:8349,Availability,avail,available,8349," in parallel.; In the case of gates schedule,; the result will be the gates cycle list. Parameters; ----------; priority: bool; If use distance to the start and end nodes; as a priority measure for the schedule problem.; apply_constraint: function; A Python function that determines; if to instruction can be executed in parallel.; E.g. if two gates apply to the same qubit, the function; returns False. Returns; -------; cycles_list: list; A list of cycles, where each cycle is a list of instructions; that can be executed in parallel.; constraint_dependency: set; A set of instruction pairs that are found conflicted; due to the hardware constraints.; Because of this, they are executed in different cycles.; This set is used to add this dependency to the graph; in another method.; """"""; # The method will destruct the graph, therefore we make a copy.; graph = deepcopy(self.nodes); cycles_list = []; available_nodes = list(self.start) # a list of available instructions; # pairs of instructions that are limited by hardware constraint; constraint_dependency = set(). while available_nodes:; if random:; shuffle(available_nodes); if priority:; available_nodes.sort(key=cmp_to_key(self._compare_priority)); current_cycle = []; if apply_constraint is None: # if no constraits; current_cycle = deepcopy(available_nodes); else: # check if constraits allow the parallelization; for node1 in available_nodes:; approval = True; for node2 in current_cycle:; if not apply_constraint(node1, node2, graph):; approval = False; # save the conflicted pairs of instructions; constraint_dependency.add((node2, node1)); if approval:; current_cycle.append(node1); # add this cycle to cycles_list; cycles_list.append(current_cycle). # update the list of available nodes; # remove the executed nodes from available_node; for node in current_cycle:; available_nodes.remove(node); # add new nodes to available_nodes; # if they have no other predecessors; for node in current_cycle:; for successor_ind in graph[node].succ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:9136,Availability,avail,available,9136,"d.; """"""; # The method will destruct the graph, therefore we make a copy.; graph = deepcopy(self.nodes); cycles_list = []; available_nodes = list(self.start) # a list of available instructions; # pairs of instructions that are limited by hardware constraint; constraint_dependency = set(). while available_nodes:; if random:; shuffle(available_nodes); if priority:; available_nodes.sort(key=cmp_to_key(self._compare_priority)); current_cycle = []; if apply_constraint is None: # if no constraits; current_cycle = deepcopy(available_nodes); else: # check if constraits allow the parallelization; for node1 in available_nodes:; approval = True; for node2 in current_cycle:; if not apply_constraint(node1, node2, graph):; approval = False; # save the conflicted pairs of instructions; constraint_dependency.add((node2, node1)); if approval:; current_cycle.append(node1); # add this cycle to cycles_list; cycles_list.append(current_cycle). # update the list of available nodes; # remove the executed nodes from available_node; for node in current_cycle:; available_nodes.remove(node); # add new nodes to available_nodes; # if they have no other predecessors; for node in current_cycle:; for successor_ind in graph[node].successors:; graph[successor_ind].predecessors.remove(node); if not graph[successor_ind].predecessors:; available_nodes.append(successor_ind); graph[node].successors = set(). return cycles_list, constraint_dependency. def compute_distance(self, cycles_list):; """"""; Compute the longest distance of each node; to the start and end nodes.; The weight for each dependency arrow is; the duration of the source instruction; (which should be 1 for gates schedule).; The method solves the longest path problem; by using the topological order in cycles_list.; It makes sure that by following the list,; the distance to the predecessors (successors) of; the source (target) node is always calculated; before the target (source) node. Parameters; ----------; cycles_list: list; A `cycles_list` ob",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:9117,Deployability,update,update,9117,"d.; """"""; # The method will destruct the graph, therefore we make a copy.; graph = deepcopy(self.nodes); cycles_list = []; available_nodes = list(self.start) # a list of available instructions; # pairs of instructions that are limited by hardware constraint; constraint_dependency = set(). while available_nodes:; if random:; shuffle(available_nodes); if priority:; available_nodes.sort(key=cmp_to_key(self._compare_priority)); current_cycle = []; if apply_constraint is None: # if no constraits; current_cycle = deepcopy(available_nodes); else: # check if constraits allow the parallelization; for node1 in available_nodes:; approval = True; for node2 in current_cycle:; if not apply_constraint(node1, node2, graph):; approval = False; # save the conflicted pairs of instructions; constraint_dependency.add((node2, node1)); if approval:; current_cycle.append(node1); # add this cycle to cycles_list; cycles_list.append(current_cycle). # update the list of available nodes; # remove the executed nodes from available_node; for node in current_cycle:; available_nodes.remove(node); # add new nodes to available_nodes; # if they have no other predecessors; for node in current_cycle:; for successor_ind in graph[node].successors:; graph[successor_ind].predecessors.remove(node); if not graph[successor_ind].predecessors:; available_nodes.append(successor_ind); graph[node].successors = set(). return cycles_list, constraint_dependency. def compute_distance(self, cycles_list):; """"""; Compute the longest distance of each node; to the start and end nodes.; The weight for each dependency arrow is; the duration of the source instruction; (which should be 1 for gates schedule).; The method solves the longest path problem; by using the topological order in cycles_list.; It makes sure that by following the list,; the distance to the predecessors (successors) of; the source (target) node is always calculated; before the target (source) node. Parameters; ----------; cycles_list: list; A `cycles_list` ob",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:21221,Deployability,update,updated,21221,"end(; instruction.distance_to_start - instruction.duration); elif self.method == ""ALAP"":; for instruction in instructions_graph.nodes:; instruction_start_time.append(; instructions_graph.longest_distance -; instruction.distance_to_start); return instruction_start_time. [docs] def commutation_rules(self, ind1, ind2, instructions):; """"""; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:. If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. `CNOT 0, 1` commute with `CNOT 0, 2`.; """"""; instruction1 = instructions[ind1]; instruction2 = instructions[ind2]; if instruction1.name != instruction2.name:; return False; if (instruction1.controls) and \; (instruction1.controls == instruction2.controls):; return True; elif instruction1.targets == instruction2.targets:; return True; else:; return False. [docs] def apply_constraint(self, ind1, ind2, instructions):; """"""; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters; ----------; ind1, ind2: int; indices of the two instructions; instructions: list; The instruction list; """"""; result = []; for constraint_function in self.constraint_functions:; result.append(constraint_function(ind1, ind2, instructions)); return all(result). def qubit_constraint(ind1, ind2, instructions):; """"""; Determine if two instructions have overlap in the used qubits.; """"""; if instructions[ind1].used_qubits & instructions[ind2].used_qubits:; return False; else:; return True. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:21,Energy Efficiency,schedul,scheduler,21,". qutip.qip.compiler.scheduler — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.compiler.scheduler. Source code for qutip.qip.compiler.scheduler; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:309,Energy Efficiency,schedul,scheduler,309,". qutip.qip.compiler.scheduler — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.compiler.scheduler. Source code for qutip.qip.compiler.scheduler; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:355,Energy Efficiency,schedul,scheduler,355,". qutip.qip.compiler.scheduler — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.compiler.scheduler. Source code for qutip.qip.compiler.scheduler; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:2583,Energy Efficiency,schedul,schedule,2583,"ENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections import deque; from copy import deepcopy; from functools import cmp_to_key; from random import shuffle. from ..circuit import QubitCircuit, Gate; from .instruction import Instruction. class InstructionsGraph():; """"""; A directed acyclic graph (DAG) representation; of the quantum instruction dependency.; An example is Fig3(b) in https://doi.org/10.1117/12.666419.; It contains methods of generating the instruction dependency graph,; a list-schedule algorithm to find the topological order; and the computation of the distance in the weighted graph; (circuit latency). It uses the `Instruction` object as a representation of node; and adds the following attributes to it:. predecessors, successors: dependency arrow of the DAG; distance_to_start, distance_to_end: longest distance to the start and end. Parameters; ----------; instructions: list; A list of instructions. Attributes; ----------; nodes: list; The input list of instruction with additional graph information.; start, end: list; List of indices of nodes connected to the start or end nodes.; """"""; def __init__(self, instructions):; instructions = deepcopy(instructions); self.nodes = []; for instruction in instructions:; if isinstance(instruction, Gate):; self.nodes.append(Instruction(instruction)); else:; self.nodes.append(instruction); for node in self.nodes:; if node.duration is None:; node.duration = 1; self.start = None; self.end = None. def generate_dependency_graph(self, commuting):; """"""; G",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:7170,Energy Efficiency,schedul,schedule,7170,"ions_cycles[cycle_ind1]:; for instruction_ind2 in instructions_cycles[cycle_ind1+1]:; self.nodes[instruction_ind1].successors.add(; instruction_ind2); self.nodes[instruction_ind2].predecessors.add(; instruction_ind1). # Find start and end nodes of the graph; start = []; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. def reverse_graph(self):; """"""; Reverse the graph.; The start node becomes the end node; Predecessors and successors of each node are exchanged.; """"""; for node in self.nodes:; node.predecessors, node.successors \; = node.successors, node.predecessors; try:; self.distance_to_start, self.distance_to_end = \; self.distance_to_end, self.distance_to_start; except AttributeError:; pass; self.start, self.end = self.end, self.start. def find_topological_order(; self, priority=True, apply_constraint=None, random=False):; """"""; A list-schedule algorithm, it; finds the topological order of the directed graph; under certain constraint and priority indicator.; The function returns a list of cycles,; where each cycle is a list of instructions; that can be executed in parallel.; In the case of gates schedule,; the result will be the gates cycle list. Parameters; ----------; priority: bool; If use distance to the start and end nodes; as a priority measure for the schedule problem.; apply_constraint: function; A Python function that determines; if to instruction can be executed in parallel.; E.g. if two gates apply to the same qubit, the function; returns False. Returns; -------; cycles_list: list; A list of cycles, where each cycle is a list of instructions; that can be executed in parallel.; constraint_dependency: set; A set of instruction pairs that are found conflicted; due to the hardware constraints.; Because of this, they are executed in different cycles.; This set is used to add this dependency to the graph; in another method",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:7435,Energy Efficiency,schedul,schedule,7435,"; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. def reverse_graph(self):; """"""; Reverse the graph.; The start node becomes the end node; Predecessors and successors of each node are exchanged.; """"""; for node in self.nodes:; node.predecessors, node.successors \; = node.successors, node.predecessors; try:; self.distance_to_start, self.distance_to_end = \; self.distance_to_end, self.distance_to_start; except AttributeError:; pass; self.start, self.end = self.end, self.start. def find_topological_order(; self, priority=True, apply_constraint=None, random=False):; """"""; A list-schedule algorithm, it; finds the topological order of the directed graph; under certain constraint and priority indicator.; The function returns a list of cycles,; where each cycle is a list of instructions; that can be executed in parallel.; In the case of gates schedule,; the result will be the gates cycle list. Parameters; ----------; priority: bool; If use distance to the start and end nodes; as a priority measure for the schedule problem.; apply_constraint: function; A Python function that determines; if to instruction can be executed in parallel.; E.g. if two gates apply to the same qubit, the function; returns False. Returns; -------; cycles_list: list; A list of cycles, where each cycle is a list of instructions; that can be executed in parallel.; constraint_dependency: set; A set of instruction pairs that are found conflicted; due to the hardware constraints.; Because of this, they are executed in different cycles.; This set is used to add this dependency to the graph; in another method.; """"""; # The method will destruct the graph, therefore we make a copy.; graph = deepcopy(self.nodes); cycles_list = []; available_nodes = list(self.start) # a list of available instructions; # pairs of instructions that are limited by hardware constraint; constraint_",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:7601,Energy Efficiency,schedul,schedule,7601,"; if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. def reverse_graph(self):; """"""; Reverse the graph.; The start node becomes the end node; Predecessors and successors of each node are exchanged.; """"""; for node in self.nodes:; node.predecessors, node.successors \; = node.successors, node.predecessors; try:; self.distance_to_start, self.distance_to_end = \; self.distance_to_end, self.distance_to_start; except AttributeError:; pass; self.start, self.end = self.end, self.start. def find_topological_order(; self, priority=True, apply_constraint=None, random=False):; """"""; A list-schedule algorithm, it; finds the topological order of the directed graph; under certain constraint and priority indicator.; The function returns a list of cycles,; where each cycle is a list of instructions; that can be executed in parallel.; In the case of gates schedule,; the result will be the gates cycle list. Parameters; ----------; priority: bool; If use distance to the start and end nodes; as a priority measure for the schedule problem.; apply_constraint: function; A Python function that determines; if to instruction can be executed in parallel.; E.g. if two gates apply to the same qubit, the function; returns False. Returns; -------; cycles_list: list; A list of cycles, where each cycle is a list of instructions; that can be executed in parallel.; constraint_dependency: set; A set of instruction pairs that are found conflicted; due to the hardware constraints.; Because of this, they are executed in different cycles.; This set is used to add this dependency to the graph; in another method.; """"""; # The method will destruct the graph, therefore we make a copy.; graph = deepcopy(self.nodes); cycles_list = []; available_nodes = list(self.start) # a list of available instructions; # pairs of instructions that are limited by hardware constraint; constraint_dependency = set(). while available_nodes:; if random:; shuffle(available_nodes); if priority:; availab",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:9842,Energy Efficiency,schedul,schedule,9842,"lable_nodes:; approval = True; for node2 in current_cycle:; if not apply_constraint(node1, node2, graph):; approval = False; # save the conflicted pairs of instructions; constraint_dependency.add((node2, node1)); if approval:; current_cycle.append(node1); # add this cycle to cycles_list; cycles_list.append(current_cycle). # update the list of available nodes; # remove the executed nodes from available_node; for node in current_cycle:; available_nodes.remove(node); # add new nodes to available_nodes; # if they have no other predecessors; for node in current_cycle:; for successor_ind in graph[node].successors:; graph[successor_ind].predecessors.remove(node); if not graph[successor_ind].predecessors:; available_nodes.append(successor_ind); graph[node].successors = set(). return cycles_list, constraint_dependency. def compute_distance(self, cycles_list):; """"""; Compute the longest distance of each node; to the start and end nodes.; The weight for each dependency arrow is; the duration of the source instruction; (which should be 1 for gates schedule).; The method solves the longest path problem; by using the topological order in cycles_list.; It makes sure that by following the list,; the distance to the predecessors (successors) of; the source (target) node is always calculated; before the target (source) node. Parameters; ----------; cycles_list: list; A `cycles_list` obtained by the method `find_topological_order`.; """"""; cycles_list = deepcopy(cycles_list). # distance to the start node; for cycle in cycles_list:; for ind in cycle:; if not self.nodes[ind].predecessors:; self.nodes[ind].distance_to_start = \; self.nodes[ind].duration; else:; self.nodes[ind].distance_to_start = max(; [; self.nodes[predecessor_ind].distance_to_start; for predecessor_ind; in self.nodes[ind].predecessors; ]; ) + self.nodes[ind].duration. # distance to the end node; cycles_list.reverse(); self.reverse_graph(); for cycle in cycles_list:; for ind in cycle:; if not self.nodes[ind].predecessors:;",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:12492,Energy Efficiency,schedul,scheduler,12492,"es[ind1].distance_to_end == \; self.nodes[ind2].distance_to_end:; # lower distance_to_start, higher priority; return self.nodes[ind1].distance_to_start - \; self.nodes[ind2].distance_to_start; else:; # higher distance_to_end, higher priority; return self.nodes[ind2].distance_to_end - \; self.nodes[ind1].distance_to_end. def add_constraint_dependency(self, constraint_dependency):; """"""; Add the dependency caused by hardware constraint to the graph. Parameters; ----------; constraint_dependency: list; `constraint_dependency` obtained by the method; `find_topological_order`.; """"""; for ind1, ind2 in constraint_dependency:; self.nodes[ind1].successors.add(ind2); self.nodes[ind2].predecessors.add(ind1). # Update the start and end nodes of the graph; start = []; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. [docs]class Scheduler():; """"""; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419. The scheduler includes two methods,; ""ASAP"", as soon as possible, and ""ALAP"", as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits. The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters; ----------; method: str; ""ASAP"" for as soon as possible.; ""ALAP"" for as late as possible.; constraint_functions: list, optional; A list of hardware constraint functions.; Default includes a function `qubit_contraint`,; i.e. one qubit cannot be used by two gates at the same time.; """"""; def __init__(self, method=""ALAP"", constraint_functions=None):; self.",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:12543,Energy Efficiency,schedul,schedules,12543,"r priority; return self.nodes[ind1].distance_to_start - \; self.nodes[ind2].distance_to_start; else:; # higher distance_to_end, higher priority; return self.nodes[ind2].distance_to_end - \; self.nodes[ind1].distance_to_end. def add_constraint_dependency(self, constraint_dependency):; """"""; Add the dependency caused by hardware constraint to the graph. Parameters; ----------; constraint_dependency: list; `constraint_dependency` obtained by the method; `find_topological_order`.; """"""; for ind1, ind2 in constraint_dependency:; self.nodes[ind1].successors.add(ind2); self.nodes[ind2].predecessors.add(ind1). # Update the start and end nodes of the graph; start = []; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. [docs]class Scheduler():; """"""; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419. The scheduler includes two methods,; ""ASAP"", as soon as possible, and ""ALAP"", as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits. The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters; ----------; method: str; ""ASAP"" for as soon as possible.; ""ALAP"" for as late as possible.; constraint_functions: list, optional; A list of hardware constraint functions.; Default includes a function `qubit_contraint`,; i.e. one qubit cannot be used by two gates at the same time.; """"""; def __init__(self, method=""ALAP"", constraint_functions=None):; self.method = method; if constraint_functions is None:; self.constraint_functions = [qubit_constraint]",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:12589,Energy Efficiency,reduce,reduce,12589,"r priority; return self.nodes[ind1].distance_to_start - \; self.nodes[ind2].distance_to_start; else:; # higher distance_to_end, higher priority; return self.nodes[ind2].distance_to_end - \; self.nodes[ind1].distance_to_end. def add_constraint_dependency(self, constraint_dependency):; """"""; Add the dependency caused by hardware constraint to the graph. Parameters; ----------; constraint_dependency: list; `constraint_dependency` obtained by the method; `find_topological_order`.; """"""; for ind1, ind2 in constraint_dependency:; self.nodes[ind1].successors.add(ind2); self.nodes[ind2].predecessors.add(ind1). # Update the start and end nodes of the graph; start = []; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. [docs]class Scheduler():; """"""; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419. The scheduler includes two methods,; ""ASAP"", as soon as possible, and ""ALAP"", as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits. The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters; ----------; method: str; ""ASAP"" for as soon as possible.; ""ALAP"" for as late as possible.; constraint_functions: list, optional; A list of hardware constraint functions.; Default includes a function `qubit_contraint`,; i.e. one qubit cannot be used by two gates at the same time.; """"""; def __init__(self, method=""ALAP"", constraint_functions=None):; self.method = method; if constraint_functions is None:; self.constraint_functions = [qubit_constraint]",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:12723,Energy Efficiency,schedul,scheduler,12723,"to_end - \; self.nodes[ind1].distance_to_end. def add_constraint_dependency(self, constraint_dependency):; """"""; Add the dependency caused by hardware constraint to the graph. Parameters; ----------; constraint_dependency: list; `constraint_dependency` obtained by the method; `find_topological_order`.; """"""; for ind1, ind2 in constraint_dependency:; self.nodes[ind1].successors.add(ind2); self.nodes[ind2].predecessors.add(ind1). # Update the start and end nodes of the graph; start = []; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. [docs]class Scheduler():; """"""; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419. The scheduler includes two methods,; ""ASAP"", as soon as possible, and ""ALAP"", as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits. The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters; ----------; method: str; ""ASAP"" for as soon as possible.; ""ALAP"" for as late as possible.; constraint_functions: list, optional; A list of hardware constraint functions.; Default includes a function `qubit_contraint`,; i.e. one qubit cannot be used by two gates at the same time.; """"""; def __init__(self, method=""ALAP"", constraint_functions=None):; self.method = method; if constraint_functions is None:; self.constraint_functions = [qubit_constraint]; else:; return constraint_functions. [docs] def schedule(self, circuit, gates_schedule=False,; return_cycles_list=False, random_shuffle=False,; repeat_num=0):; """"""; Schedule a `Q",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:12916,Energy Efficiency,schedul,scheduler,12916,"onstraint_dependency: list; `constraint_dependency` obtained by the method; `find_topological_order`.; """"""; for ind1, ind2 in constraint_dependency:; self.nodes[ind1].successors.add(ind2); self.nodes[ind2].predecessors.add(ind1). # Update the start and end nodes of the graph; start = []; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. [docs]class Scheduler():; """"""; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419. The scheduler includes two methods,; ""ASAP"", as soon as possible, and ""ALAP"", as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits. The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters; ----------; method: str; ""ASAP"" for as soon as possible.; ""ALAP"" for as late as possible.; constraint_functions: list, optional; A list of hardware constraint functions.; Default includes a function `qubit_contraint`,; i.e. one qubit cannot be used by two gates at the same time.; """"""; def __init__(self, method=""ALAP"", constraint_functions=None):; self.method = method; if constraint_functions is None:; self.constraint_functions = [qubit_constraint]; else:; return constraint_functions. [docs] def schedule(self, circuit, gates_schedule=False,; return_cycles_list=False, random_shuffle=False,; repeat_num=0):; """"""; Schedule a `QubitCircuit`,; a list of `Gates` or a list of `Instruction`.; For pulse schedule, the execution time for each `Instruction`; is given in its `duration` attributes. The scheduler first generates a qua",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:12940,Energy Efficiency,schedul,schedule,12940,"onstraint_dependency: list; `constraint_dependency` obtained by the method; `find_topological_order`.; """"""; for ind1, ind2 in constraint_dependency:; self.nodes[ind1].successors.add(ind2); self.nodes[ind2].predecessors.add(ind1). # Update the start and end nodes of the graph; start = []; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. [docs]class Scheduler():; """"""; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419. The scheduler includes two methods,; ""ASAP"", as soon as possible, and ""ALAP"", as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits. The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters; ----------; method: str; ""ASAP"" for as soon as possible.; ""ALAP"" for as late as possible.; constraint_functions: list, optional; A list of hardware constraint functions.; Default includes a function `qubit_contraint`,; i.e. one qubit cannot be used by two gates at the same time.; """"""; def __init__(self, method=""ALAP"", constraint_functions=None):; self.method = method; if constraint_functions is None:; self.constraint_functions = [qubit_constraint]; else:; return constraint_functions. [docs] def schedule(self, circuit, gates_schedule=False,; return_cycles_list=False, random_shuffle=False,; repeat_num=0):; """"""; Schedule a `QubitCircuit`,; a list of `Gates` or a list of `Instruction`.; For pulse schedule, the execution time for each `Instruction`; is given in its `duration` attributes. The scheduler first generates a qua",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:12999,Energy Efficiency,reduce,reduce,12999,"onstraint_dependency: list; `constraint_dependency` obtained by the method; `find_topological_order`.; """"""; for ind1, ind2 in constraint_dependency:; self.nodes[ind1].successors.add(ind2); self.nodes[ind2].predecessors.add(ind1). # Update the start and end nodes of the graph; start = []; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. [docs]class Scheduler():; """"""; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419. The scheduler includes two methods,; ""ASAP"", as soon as possible, and ""ALAP"", as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits. The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters; ----------; method: str; ""ASAP"" for as soon as possible.; ""ALAP"" for as late as possible.; constraint_functions: list, optional; A list of hardware constraint functions.; Default includes a function `qubit_contraint`,; i.e. one qubit cannot be used by two gates at the same time.; """"""; def __init__(self, method=""ALAP"", constraint_functions=None):; self.method = method; if constraint_functions is None:; self.constraint_functions = [qubit_constraint]; else:; return constraint_functions. [docs] def schedule(self, circuit, gates_schedule=False,; return_cycles_list=False, random_shuffle=False,; repeat_num=0):; """"""; Schedule a `QubitCircuit`,; a list of `Gates` or a list of `Instruction`.; For pulse schedule, the execution time for each `Instruction`; is given in its `duration` attributes. The scheduler first generates a qua",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:13638,Energy Efficiency,schedul,schedule,13638,"duler includes two methods,; ""ASAP"", as soon as possible, and ""ALAP"", as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits. The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters; ----------; method: str; ""ASAP"" for as soon as possible.; ""ALAP"" for as late as possible.; constraint_functions: list, optional; A list of hardware constraint functions.; Default includes a function `qubit_contraint`,; i.e. one qubit cannot be used by two gates at the same time.; """"""; def __init__(self, method=""ALAP"", constraint_functions=None):; self.method = method; if constraint_functions is None:; self.constraint_functions = [qubit_constraint]; else:; return constraint_functions. [docs] def schedule(self, circuit, gates_schedule=False,; return_cycles_list=False, random_shuffle=False,; repeat_num=0):; """"""; Schedule a `QubitCircuit`,; a list of `Gates` or a list of `Instruction`.; For pulse schedule, the execution time for each `Instruction`; is given in its `duration` attributes. The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:13840,Energy Efficiency,schedul,schedule,13840,"f the finite lifetime of qubits. The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters; ----------; method: str; ""ASAP"" for as soon as possible.; ""ALAP"" for as late as possible.; constraint_functions: list, optional; A list of hardware constraint functions.; Default includes a function `qubit_contraint`,; i.e. one qubit cannot be used by two gates at the same time.; """"""; def __init__(self, method=""ALAP"", constraint_functions=None):; self.method = method; if constraint_functions is None:; self.constraint_functions = [qubit_constraint]; else:; return constraint_functions. [docs] def schedule(self, circuit, gates_schedule=False,; return_cycles_list=False, random_shuffle=False,; repeat_num=0):; """"""; Schedule a `QubitCircuit`,; a list of `Gates` or a list of `Instruction`.; For pulse schedule, the execution time for each `Instruction`; is given in its `duration` attributes. The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions. For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:13936,Energy Efficiency,schedul,scheduler,13936,"he gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters; ----------; method: str; ""ASAP"" for as soon as possible.; ""ALAP"" for as late as possible.; constraint_functions: list, optional; A list of hardware constraint functions.; Default includes a function `qubit_contraint`,; i.e. one qubit cannot be used by two gates at the same time.; """"""; def __init__(self, method=""ALAP"", constraint_functions=None):; self.method = method; if constraint_functions is None:; self.constraint_functions = [qubit_constraint]; else:; return constraint_functions. [docs] def schedule(self, circuit, gates_schedule=False,; return_cycles_list=False, random_shuffle=False,; repeat_num=0):; """"""; Schedule a `QubitCircuit`,; a list of `Gates` or a list of `Instruction`.; For pulse schedule, the execution time for each `Instruction`; is given in its `duration` attributes. The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions. For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distanc",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:14635,Energy Efficiency,schedul,schedule,14635,"ule=False,; return_cycles_list=False, random_shuffle=False,; repeat_num=0):; """"""; Schedule a `QubitCircuit`,; a list of `Gates` or a list of `Instruction`.; For pulse schedule, the execution time for each `Instruction`; is given in its `duration` attributes. The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions. For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters; ----------; circuit: QubitCircuit or list; For gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute `duration`; that indicates the execution time of this instruction.; gates_schedule: bool, optional; `True`, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input `circuit` is a `QubitCircuit`,; it will be assigned to `True` automatically.; Otherwise, the default is `False`.; return_cycles_list: bool, optional; If `True`, t",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:14757,Energy Efficiency,schedul,schedule,14757,"ates` or a list of `Instruction`.; For pulse schedule, the execution time for each `Instruction`; is given in its `duration` attributes. The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions. For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters; ----------; circuit: QubitCircuit or list; For gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute `duration`; that indicates the execution time of this instruction.; gates_schedule: bool, optional; `True`, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input `circuit` is a `QubitCircuit`,; it will be assigned to `True` automatically.; Otherwise, the default is `False`.; return_cycles_list: bool, optional; If `True`, the method returns the `cycles_list`,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:15131,Energy Efficiency,schedul,schedule,15131,"; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions. For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters; ----------; circuit: QubitCircuit or list; For gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute `duration`; that indicates the execution time of this instruction.; gates_schedule: bool, optional; `True`, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input `circuit` is a `QubitCircuit`,; it will be assigned to `True` automatically.; Otherwise, the default is `False`.; return_cycles_list: bool, optional; If `True`, the method returns the `cycles_list`,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule.; random_shuffle: bool, optional; If the commuting gates are randomly scuffled to explore; larger search space.; repeat_num: int, optional; Repeat the scheduling several times and use the best result.; Used together with ``random_shuffle=Ture``.",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:15208,Energy Efficiency,schedul,schedule,15208,"; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions. For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters; ----------; circuit: QubitCircuit or list; For gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute `duration`; that indicates the execution time of this instruction.; gates_schedule: bool, optional; `True`, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input `circuit` is a `QubitCircuit`,; it will be assigned to `True` automatically.; Otherwise, the default is `False`.; return_cycles_list: bool, optional; If `True`, the method returns the `cycles_list`,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule.; random_shuffle: bool, optional; If the commuting gates are randomly scuffled to explore; larger search space.; repeat_num: int, optional; Repeat the scheduling several times and use the best result.; Used together with ``random_shuffle=Ture``. Returns; -------; gate_cycle_indices or instruction_start_time: list; The cycle indices for each gate or; the start time for each instruction.",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:15408,Energy Efficiency,schedul,schedule,15408,"ruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions. For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters; ----------; circuit: QubitCircuit or list; For gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute `duration`; that indicates the execution time of this instruction.; gates_schedule: bool, optional; `True`, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input `circuit` is a `QubitCircuit`,; it will be assigned to `True` automatically.; Otherwise, the default is `False`.; return_cycles_list: bool, optional; If `True`, the method returns the `cycles_list`,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule.; random_shuffle: bool, optional; If the commuting gates are randomly scuffled to explore; larger search space.; repeat_num: int, optional; Repeat the scheduling several times and use the best result.; Used together with ``random_shuffle=Ture``. Returns; -------; gate_cycle_indices or instruction_start_time: list; The cycle indices for each gate or; the start time for each instruction. Examples; --------; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:15487,Energy Efficiency,schedul,schedule,15487,"y measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions. For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters; ----------; circuit: QubitCircuit or list; For gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute `duration`; that indicates the execution time of this instruction.; gates_schedule: bool, optional; `True`, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input `circuit` is a `QubitCircuit`,; it will be assigned to `True` automatically.; Otherwise, the default is `False`.; return_cycles_list: bool, optional; If `True`, the method returns the `cycles_list`,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule.; random_shuffle: bool, optional; If the commuting gates are randomly scuffled to explore; larger search space.; repeat_num: int, optional; Repeat the scheduling several times and use the best result.; Used together with ``random_shuffle=Ture``. Returns; -------; gate_cycle_indices or instruction_start_time: list; The cycle indices for each gate or; the start time for each instruction. Examples; --------; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:15877,Energy Efficiency,schedul,schedule,15877,"nal dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters; ----------; circuit: QubitCircuit or list; For gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute `duration`; that indicates the execution time of this instruction.; gates_schedule: bool, optional; `True`, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input `circuit` is a `QubitCircuit`,; it will be assigned to `True` automatically.; Otherwise, the default is `False`.; return_cycles_list: bool, optional; If `True`, the method returns the `cycles_list`,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule.; random_shuffle: bool, optional; If the commuting gates are randomly scuffled to explore; larger search space.; repeat_num: int, optional; Repeat the scheduling several times and use the best result.; Used together with ``random_shuffle=Ture``. Returns; -------; gate_cycle_indices or instruction_start_time: list; The cycle indices for each gate or; the start time for each instruction. Examples; --------; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle in",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:16037,Energy Efficiency,schedul,scheduling,16037,"time of each instruction. Parameters; ----------; circuit: QubitCircuit or list; For gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute `duration`; that indicates the execution time of this instruction.; gates_schedule: bool, optional; `True`, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input `circuit` is a `QubitCircuit`,; it will be assigned to `True` automatically.; Otherwise, the default is `False`.; return_cycles_list: bool, optional; If `True`, the method returns the `cycles_list`,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule.; random_shuffle: bool, optional; If the commuting gates are randomly scuffled to explore; larger search space.; repeat_num: int, optional; Repeat the scheduling several times and use the best result.; Used together with ``random_shuffle=Ture``. Returns; -------; gate_cycle_indices or instruction_start_time: list; The cycle indices for each gate or; the start time for each instruction. Examples; --------; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; ``[gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]``; Notice that gate3 and gate4 commut",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:16362,Energy Efficiency,schedul,scheduler,16362,"only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input `circuit` is a `QubitCircuit`,; it will be assigned to `True` automatically.; Otherwise, the default is `False`.; return_cycles_list: bool, optional; If `True`, the method returns the `cycles_list`,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule.; random_shuffle: bool, optional; If the commuting gates are randomly scuffled to explore; larger search space.; repeat_num: int, optional; Repeat the scheduling several times and use the best result.; Used together with ``random_shuffle=Ture``. Returns; -------; gate_cycle_indices or instruction_start_time: list; The cycle indices for each gate or; the start time for each instruction. Examples; --------; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; ``[gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]``; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles.; """"""; circuit = deepcopy(circuit); if repeat_num > 0:; random_shuffle = True; result = [0]; max_length = 4294967296; for i in range(repeat_num):; gate_cycle_indices = self.schedule(; circuit, gates_schedule=gates_schedule,; return_cycles_list=return_cycles_list,; random_shuffl",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:16727,Energy Efficiency,schedul,scheduler,16727," 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule.; random_shuffle: bool, optional; If the commuting gates are randomly scuffled to explore; larger search space.; repeat_num: int, optional; Repeat the scheduling several times and use the best result.; Used together with ``random_shuffle=Ture``. Returns; -------; gate_cycle_indices or instruction_start_time: list; The cycle indices for each gate or; the start time for each instruction. Examples; --------; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; ``[gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]``; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles.; """"""; circuit = deepcopy(circuit); if repeat_num > 0:; random_shuffle = True; result = [0]; max_length = 4294967296; for i in range(repeat_num):; gate_cycle_indices = self.schedule(; circuit, gates_schedule=gates_schedule,; return_cycles_list=return_cycles_list,; random_shuffle=random_shuffle, repeat_num=0); current_length = max(gate_cycle_indices); if current_length < max_length:; result = gate_cycle_indices; max_length = current_length; return result. if isinstance(circuit, QubitCircuit):; gates = circuit.gates; else:; gates = circuit. # Generate the quantum operations dependency graph.; instructio",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:16762,Energy Efficiency,schedul,scheduler,16762," 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule.; random_shuffle: bool, optional; If the commuting gates are randomly scuffled to explore; larger search space.; repeat_num: int, optional; Repeat the scheduling several times and use the best result.; Used together with ``random_shuffle=Ture``. Returns; -------; gate_cycle_indices or instruction_start_time: list; The cycle indices for each gate or; the start time for each instruction. Examples; --------; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; ``[gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]``; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles.; """"""; circuit = deepcopy(circuit); if repeat_num > 0:; random_shuffle = True; result = [0]; max_length = 4294967296; for i in range(repeat_num):; gate_cycle_indices = self.schedule(; circuit, gates_schedule=gates_schedule,; return_cycles_list=return_cycles_list,; random_shuffle=random_shuffle, repeat_num=0); current_length = max(gate_cycle_indices); if current_length < max_length:; result = gate_cycle_indices; max_length = current_length; return result. if isinstance(circuit, QubitCircuit):; gates = circuit.gates; else:; gates = circuit. # Generate the quantum operations dependency graph.; instructio",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:16772,Energy Efficiency,schedul,schedule,16772,"he second cycle contains gates1 and gates3.; It is only usefull for gates schedule.; random_shuffle: bool, optional; If the commuting gates are randomly scuffled to explore; larger search space.; repeat_num: int, optional; Repeat the scheduling several times and use the best result.; Used together with ``random_shuffle=Ture``. Returns; -------; gate_cycle_indices or instruction_start_time: list; The cycle indices for each gate or; the start time for each instruction. Examples; --------; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; ``[gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]``; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles.; """"""; circuit = deepcopy(circuit); if repeat_num > 0:; random_shuffle = True; result = [0]; max_length = 4294967296; for i in range(repeat_num):; gate_cycle_indices = self.schedule(; circuit, gates_schedule=gates_schedule,; return_cycles_list=return_cycles_list,; random_shuffle=random_shuffle, repeat_num=0); current_length = max(gate_cycle_indices); if current_length < max_length:; result = gate_cycle_indices; max_length = current_length; return result. if isinstance(circuit, QubitCircuit):; gates = circuit.gates; else:; gates = circuit. # Generate the quantum operations dependency graph.; instructions_graph = InstructionsGraph(gates); instructions_graph.generate_dependency",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:17092,Energy Efficiency,reduce,reduce,17092,"at_num: int, optional; Repeat the scheduling several times and use the best result.; Used together with ``random_shuffle=Ture``. Returns; -------; gate_cycle_indices or instruction_start_time: list; The cycle indices for each gate or; the start time for each instruction. Examples; --------; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; ``[gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]``; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles.; """"""; circuit = deepcopy(circuit); if repeat_num > 0:; random_shuffle = True; result = [0]; max_length = 4294967296; for i in range(repeat_num):; gate_cycle_indices = self.schedule(; circuit, gates_schedule=gates_schedule,; return_cycles_list=return_cycles_list,; random_shuffle=random_shuffle, repeat_num=0); current_length = max(gate_cycle_indices); if current_length < max_length:; result = gate_cycle_indices; max_length = current_length; return result. if isinstance(circuit, QubitCircuit):; gates = circuit.gates; else:; gates = circuit. # Generate the quantum operations dependency graph.; instructions_graph = InstructionsGraph(gates); instructions_graph.generate_dependency_graph(; commuting=self.commutation_rules); if self.method == ""ALAP"":; instructions_graph.reverse_graph(). # Schedule without hardware constraints, then; # use this cycles_list to compute the distance",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:17293,Energy Efficiency,schedul,schedule,17293,"d_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; ``[gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]``; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles.; """"""; circuit = deepcopy(circuit); if repeat_num > 0:; random_shuffle = True; result = [0]; max_length = 4294967296; for i in range(repeat_num):; gate_cycle_indices = self.schedule(; circuit, gates_schedule=gates_schedule,; return_cycles_list=return_cycles_list,; random_shuffle=random_shuffle, repeat_num=0); current_length = max(gate_cycle_indices); if current_length < max_length:; result = gate_cycle_indices; max_length = current_length; return result. if isinstance(circuit, QubitCircuit):; gates = circuit.gates; else:; gates = circuit. # Generate the quantum operations dependency graph.; instructions_graph = InstructionsGraph(gates); instructions_graph.generate_dependency_graph(; commuting=self.commutation_rules); if self.method == ""ALAP"":; instructions_graph.reverse_graph(). # Schedule without hardware constraints, then; # use this cycles_list to compute the distance.; cycles_list, _ = instructions_graph.find_topological_order(; priority=False, apply_constraint=None, random=random_shuffle); instructions_graph.compute_distance(cycles_list=cycles_list). # Schedule again with priority and hardware constraint.; cycles_list, constraint_dependency = \; instructions_graph.find_topological_order(; priority=True, apply_constraint=self.apply_constraint,; random=random_shuffle). # If we only need gates",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:18437,Energy Efficiency,schedul,schedule,18437,"h = max(gate_cycle_indices); if current_length < max_length:; result = gate_cycle_indices; max_length = current_length; return result. if isinstance(circuit, QubitCircuit):; gates = circuit.gates; else:; gates = circuit. # Generate the quantum operations dependency graph.; instructions_graph = InstructionsGraph(gates); instructions_graph.generate_dependency_graph(; commuting=self.commutation_rules); if self.method == ""ALAP"":; instructions_graph.reverse_graph(). # Schedule without hardware constraints, then; # use this cycles_list to compute the distance.; cycles_list, _ = instructions_graph.find_topological_order(; priority=False, apply_constraint=None, random=random_shuffle); instructions_graph.compute_distance(cycles_list=cycles_list). # Schedule again with priority and hardware constraint.; cycles_list, constraint_dependency = \; instructions_graph.find_topological_order(; priority=True, apply_constraint=self.apply_constraint,; random=random_shuffle). # If we only need gates schedule, we can output the result here.; if gates_schedule or return_cycles_list:; if self.method == ""ALAP"":; cycles_list.reverse(); if return_cycles_list:; return cycles_list; gate_cycles_indices = [0] * len(gates); for cycle_ind, cycle in enumerate(cycles_list):; for instruction_ind in cycle:; gate_cycles_indices[instruction_ind] = cycle_ind; return gate_cycles_indices. # For pulse schedule,; # we add the hardware dependency to the graph; # and compute the longest distance to the start node again.; # The longest distance to the start node determines; # the start time of each pulse.; instructions_graph.add_constraint_dependency(constraint_dependency); instructions_graph.compute_distance(cycles_list=cycles_list). # Output pulse schedule result.; instruction_start_time = []; if self.method == ""ASAP"":; for instruction in instructions_graph.nodes:; instruction_start_time.append(; instruction.distance_to_start - instruction.duration); elif self.method == ""ALAP"":; for instruction in instructions_g",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:18825,Energy Efficiency,schedul,schedule,18825,"tructions_graph.reverse_graph(). # Schedule without hardware constraints, then; # use this cycles_list to compute the distance.; cycles_list, _ = instructions_graph.find_topological_order(; priority=False, apply_constraint=None, random=random_shuffle); instructions_graph.compute_distance(cycles_list=cycles_list). # Schedule again with priority and hardware constraint.; cycles_list, constraint_dependency = \; instructions_graph.find_topological_order(; priority=True, apply_constraint=self.apply_constraint,; random=random_shuffle). # If we only need gates schedule, we can output the result here.; if gates_schedule or return_cycles_list:; if self.method == ""ALAP"":; cycles_list.reverse(); if return_cycles_list:; return cycles_list; gate_cycles_indices = [0] * len(gates); for cycle_ind, cycle in enumerate(cycles_list):; for instruction_ind in cycle:; gate_cycles_indices[instruction_ind] = cycle_ind; return gate_cycles_indices. # For pulse schedule,; # we add the hardware dependency to the graph; # and compute the longest distance to the start node again.; # The longest distance to the start node determines; # the start time of each pulse.; instructions_graph.add_constraint_dependency(constraint_dependency); instructions_graph.compute_distance(cycles_list=cycles_list). # Output pulse schedule result.; instruction_start_time = []; if self.method == ""ASAP"":; for instruction in instructions_graph.nodes:; instruction_start_time.append(; instruction.distance_to_start - instruction.duration); elif self.method == ""ALAP"":; for instruction in instructions_graph.nodes:; instruction_start_time.append(; instructions_graph.longest_distance -; instruction.distance_to_start); return instruction_start_time. [docs] def commutation_rules(self, ind1, ind2, instructions):; """"""; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:. If the two gates do not have the same n",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:19176,Energy Efficiency,schedul,schedule,19176,"t=cycles_list). # Schedule again with priority and hardware constraint.; cycles_list, constraint_dependency = \; instructions_graph.find_topological_order(; priority=True, apply_constraint=self.apply_constraint,; random=random_shuffle). # If we only need gates schedule, we can output the result here.; if gates_schedule or return_cycles_list:; if self.method == ""ALAP"":; cycles_list.reverse(); if return_cycles_list:; return cycles_list; gate_cycles_indices = [0] * len(gates); for cycle_ind, cycle in enumerate(cycles_list):; for instruction_ind in cycle:; gate_cycles_indices[instruction_ind] = cycle_ind; return gate_cycles_indices. # For pulse schedule,; # we add the hardware dependency to the graph; # and compute the longest distance to the start node again.; # The longest distance to the start node determines; # the start time of each pulse.; instructions_graph.add_constraint_dependency(constraint_dependency); instructions_graph.compute_distance(cycles_list=cycles_list). # Output pulse schedule result.; instruction_start_time = []; if self.method == ""ASAP"":; for instruction in instructions_graph.nodes:; instruction_start_time.append(; instruction.distance_to_start - instruction.duration); elif self.method == ""ALAP"":; for instruction in instructions_graph.nodes:; instruction_start_time.append(; instructions_graph.longest_distance -; instruction.distance_to_start); return instruction_start_time. [docs] def commutation_rules(self, ind1, ind2, instructions):; """"""; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:. If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. `CNOT 0, 1` commute with `CNOT 0, 2`.; """"""; instruction1 = instructions[ind1]; instruction2 = instructions[ind2]; if instruction1.name != instructio",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:2433,Integrability,depend,dependency,2433,"G, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections import deque; from copy import deepcopy; from functools import cmp_to_key; from random import shuffle. from ..circuit import QubitCircuit, Gate; from .instruction import Instruction. class InstructionsGraph():; """"""; A directed acyclic graph (DAG) representation; of the quantum instruction dependency.; An example is Fig3(b) in https://doi.org/10.1117/12.666419.; It contains methods of generating the instruction dependency graph,; a list-schedule algorithm to find the topological order; and the computation of the distance in the weighted graph; (circuit latency). It uses the `Instruction` object as a representation of node; and adds the following attributes to it:. predecessors, successors: dependency arrow of the DAG; distance_to_start, distance_to_end: longest distance to the start and end. Parameters; ----------; instructions: list; A list of instructions. Attributes; ----------; nodes: list; The input list of instruction with additional graph information.; start, end: list; List of indices of nodes connected to the start or end nodes.; """"""; def __init__(self, instructions):; instructions = deepcopy(instructions); self.nodes = []; for instruction in instructions:; if isinstance(instruction, Gate):; self.nodes.append(Instr",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:2557,Integrability,depend,dependency,2557,"ENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections import deque; from copy import deepcopy; from functools import cmp_to_key; from random import shuffle. from ..circuit import QubitCircuit, Gate; from .instruction import Instruction. class InstructionsGraph():; """"""; A directed acyclic graph (DAG) representation; of the quantum instruction dependency.; An example is Fig3(b) in https://doi.org/10.1117/12.666419.; It contains methods of generating the instruction dependency graph,; a list-schedule algorithm to find the topological order; and the computation of the distance in the weighted graph; (circuit latency). It uses the `Instruction` object as a representation of node; and adds the following attributes to it:. predecessors, successors: dependency arrow of the DAG; distance_to_start, distance_to_end: longest distance to the start and end. Parameters; ----------; instructions: list; A list of instructions. Attributes; ----------; nodes: list; The input list of instruction with additional graph information.; start, end: list; List of indices of nodes connected to the start or end nodes.; """"""; def __init__(self, instructions):; instructions = deepcopy(instructions); self.nodes = []; for instruction in instructions:; if isinstance(instruction, Gate):; self.nodes.append(Instruction(instruction)); else:; self.nodes.append(instruction); for node in self.nodes:; if node.duration is None:; node.duration = 1; self.start = None; self.end = None. def generate_dependency_graph(self, commuting):; """"""; G",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:2841,Integrability,depend,dependency,2841," LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections import deque; from copy import deepcopy; from functools import cmp_to_key; from random import shuffle. from ..circuit import QubitCircuit, Gate; from .instruction import Instruction. class InstructionsGraph():; """"""; A directed acyclic graph (DAG) representation; of the quantum instruction dependency.; An example is Fig3(b) in https://doi.org/10.1117/12.666419.; It contains methods of generating the instruction dependency graph,; a list-schedule algorithm to find the topological order; and the computation of the distance in the weighted graph; (circuit latency). It uses the `Instruction` object as a representation of node; and adds the following attributes to it:. predecessors, successors: dependency arrow of the DAG; distance_to_start, distance_to_end: longest distance to the start and end. Parameters; ----------; instructions: list; A list of instructions. Attributes; ----------; nodes: list; The input list of instruction with additional graph information.; start, end: list; List of indices of nodes connected to the start or end nodes.; """"""; def __init__(self, instructions):; instructions = deepcopy(instructions); self.nodes = []; for instruction in instructions:; if isinstance(instruction, Gate):; self.nodes.append(Instruction(instruction)); else:; self.nodes.append(instruction); for node in self.nodes:; if node.duration is None:; node.duration = 1; self.start = None; self.end = None. def generate_dependency_graph(self, commuting):; """"""; Generate the instruction dependency graph.; It modifies the class attribute `nodes`, where each element (node); is an `Instruction`.; The graph is represented by attributes `predecessors` and; `successors`, each a set of indices; pointing to the position of the target nod",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:3632,Integrability,depend,dependency,3632,"m to find the topological order; and the computation of the distance in the weighted graph; (circuit latency). It uses the `Instruction` object as a representation of node; and adds the following attributes to it:. predecessors, successors: dependency arrow of the DAG; distance_to_start, distance_to_end: longest distance to the start and end. Parameters; ----------; instructions: list; A list of instructions. Attributes; ----------; nodes: list; The input list of instruction with additional graph information.; start, end: list; List of indices of nodes connected to the start or end nodes.; """"""; def __init__(self, instructions):; instructions = deepcopy(instructions); self.nodes = []; for instruction in instructions:; if isinstance(instruction, Gate):; self.nodes.append(Instruction(instruction)); else:; self.nodes.append(instruction); for node in self.nodes:; if node.duration is None:; node.duration = 1; self.start = None; self.end = None. def generate_dependency_graph(self, commuting):; """"""; Generate the instruction dependency graph.; It modifies the class attribute `nodes`, where each element (node); is an `Instruction`.; The graph is represented by attributes `predecessors` and; `successors`, each a set of indices; pointing to the position of the target node in the nodes list. The graph preserves the mobility of the gates,; i.e. if two gates commute with each other,; such as ``CNOT 2, 3`` and ``CNOT 2, 1``,; there should be no dependency arrow between them.; Because of this, the generated graph does not consider; the hardware constraints,; e.g. two commuting gates addressing the same qubits; cannot be executed at the same time.; A dependency arrow between Instruction 1 and instruction 2; means that they do not commute.; However, the converse does not hold because we do not need; gate1->gate3 if we already have gate1->gate2->gate3. Parameters; ----------; commuting: function; A Python function that determines if two gates commute,; given that their used qubits overl",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:4053,Integrability,depend,dependency,4053,"ibutes; ----------; nodes: list; The input list of instruction with additional graph information.; start, end: list; List of indices of nodes connected to the start or end nodes.; """"""; def __init__(self, instructions):; instructions = deepcopy(instructions); self.nodes = []; for instruction in instructions:; if isinstance(instruction, Gate):; self.nodes.append(Instruction(instruction)); else:; self.nodes.append(instruction); for node in self.nodes:; if node.duration is None:; node.duration = 1; self.start = None; self.end = None. def generate_dependency_graph(self, commuting):; """"""; Generate the instruction dependency graph.; It modifies the class attribute `nodes`, where each element (node); is an `Instruction`.; The graph is represented by attributes `predecessors` and; `successors`, each a set of indices; pointing to the position of the target node in the nodes list. The graph preserves the mobility of the gates,; i.e. if two gates commute with each other,; such as ``CNOT 2, 3`` and ``CNOT 2, 1``,; there should be no dependency arrow between them.; Because of this, the generated graph does not consider; the hardware constraints,; e.g. two commuting gates addressing the same qubits; cannot be executed at the same time.; A dependency arrow between Instruction 1 and instruction 2; means that they do not commute.; However, the converse does not hold because we do not need; gate1->gate3 if we already have gate1->gate2->gate3. Parameters; ----------; commuting: function; A Python function that determines if two gates commute,; given that their used qubits overlap.; """"""; # initialize the graph; for node in self.nodes:; node.predecessors = set(); node.successors = set(). num_qubits = max(set().union(; *[instruction.used_qubits for instruction in self.nodes])) + 1; qubits_instructions_dependency = [[set()] for i in range(num_qubits)]; # qubits_instructions_dependency:; # instruction dependency for each qubits, a nested list of level 3.; # E.g. [; # [{1, }],; # [{0, 1}, {2,",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:4261,Integrability,depend,dependency,4261,"ction in instructions:; if isinstance(instruction, Gate):; self.nodes.append(Instruction(instruction)); else:; self.nodes.append(instruction); for node in self.nodes:; if node.duration is None:; node.duration = 1; self.start = None; self.end = None. def generate_dependency_graph(self, commuting):; """"""; Generate the instruction dependency graph.; It modifies the class attribute `nodes`, where each element (node); is an `Instruction`.; The graph is represented by attributes `predecessors` and; `successors`, each a set of indices; pointing to the position of the target node in the nodes list. The graph preserves the mobility of the gates,; i.e. if two gates commute with each other,; such as ``CNOT 2, 3`` and ``CNOT 2, 1``,; there should be no dependency arrow between them.; Because of this, the generated graph does not consider; the hardware constraints,; e.g. two commuting gates addressing the same qubits; cannot be executed at the same time.; A dependency arrow between Instruction 1 and instruction 2; means that they do not commute.; However, the converse does not hold because we do not need; gate1->gate3 if we already have gate1->gate2->gate3. Parameters; ----------; commuting: function; A Python function that determines if two gates commute,; given that their used qubits overlap.; """"""; # initialize the graph; for node in self.nodes:; node.predecessors = set(); node.successors = set(). num_qubits = max(set().union(; *[instruction.used_qubits for instruction in self.nodes])) + 1; qubits_instructions_dependency = [[set()] for i in range(num_qubits)]; # qubits_instructions_dependency:; # instruction dependency for each qubits, a nested list of level 3.; # E.g. [; # [{1, }],; # [{0, 1}, {2, }],; # [{0, }]; # ]; # means that; # Gate0 acts on qubit 1 and 2, gate1 act on qubit0 and qubit1,; # but gate0 and gate1 cummute with each other.; # Therefore, there is not dependency between gate0 and gate1;; # Gate 2 acts on qubit1 and must be executed after gate0 and gate1.; # Henc",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:4927,Integrability,depend,dependency,4927,"e nodes list. The graph preserves the mobility of the gates,; i.e. if two gates commute with each other,; such as ``CNOT 2, 3`` and ``CNOT 2, 1``,; there should be no dependency arrow between them.; Because of this, the generated graph does not consider; the hardware constraints,; e.g. two commuting gates addressing the same qubits; cannot be executed at the same time.; A dependency arrow between Instruction 1 and instruction 2; means that they do not commute.; However, the converse does not hold because we do not need; gate1->gate3 if we already have gate1->gate2->gate3. Parameters; ----------; commuting: function; A Python function that determines if two gates commute,; given that their used qubits overlap.; """"""; # initialize the graph; for node in self.nodes:; node.predecessors = set(); node.successors = set(). num_qubits = max(set().union(; *[instruction.used_qubits for instruction in self.nodes])) + 1; qubits_instructions_dependency = [[set()] for i in range(num_qubits)]; # qubits_instructions_dependency:; # instruction dependency for each qubits, a nested list of level 3.; # E.g. [; # [{1, }],; # [{0, 1}, {2, }],; # [{0, }]; # ]; # means that; # Gate0 acts on qubit 1 and 2, gate1 act on qubit0 and qubit1,; # but gate0 and gate1 cummute with each other.; # Therefore, there is not dependency between gate0 and gate1;; # Gate 2 acts on qubit1 and must be executed after gate0 and gate1.; # Hence, gate2 will depends on gate0 and gate1. # Generate instruction dependency for each qubit; for current_ind, instruction in enumerate(self.nodes):; for qubit in instruction.used_qubits:; # For each used qubit, find the last dependency gate set.; # If the current gate commute with all of them,; # add it to the list.; # Otherwise,; # append a new set with the current gate to the list.; dependent = False; for dependent_ind in qubits_instructions_dependency[qubit][-1]:; if not commuting(current_ind, dependent_ind, self.nodes):; dependent = True; if not dependent:; qubits_instructi",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:5192,Integrability,depend,dependency,5192," executed at the same time.; A dependency arrow between Instruction 1 and instruction 2; means that they do not commute.; However, the converse does not hold because we do not need; gate1->gate3 if we already have gate1->gate2->gate3. Parameters; ----------; commuting: function; A Python function that determines if two gates commute,; given that their used qubits overlap.; """"""; # initialize the graph; for node in self.nodes:; node.predecessors = set(); node.successors = set(). num_qubits = max(set().union(; *[instruction.used_qubits for instruction in self.nodes])) + 1; qubits_instructions_dependency = [[set()] for i in range(num_qubits)]; # qubits_instructions_dependency:; # instruction dependency for each qubits, a nested list of level 3.; # E.g. [; # [{1, }],; # [{0, 1}, {2, }],; # [{0, }]; # ]; # means that; # Gate0 acts on qubit 1 and 2, gate1 act on qubit0 and qubit1,; # but gate0 and gate1 cummute with each other.; # Therefore, there is not dependency between gate0 and gate1;; # Gate 2 acts on qubit1 and must be executed after gate0 and gate1.; # Hence, gate2 will depends on gate0 and gate1. # Generate instruction dependency for each qubit; for current_ind, instruction in enumerate(self.nodes):; for qubit in instruction.used_qubits:; # For each used qubit, find the last dependency gate set.; # If the current gate commute with all of them,; # add it to the list.; # Otherwise,; # append a new set with the current gate to the list.; dependent = False; for dependent_ind in qubits_instructions_dependency[qubit][-1]:; if not commuting(current_ind, dependent_ind, self.nodes):; dependent = True; if not dependent:; qubits_instructions_dependency[qubit][-1].add(current_ind); else:; qubits_instructions_dependency[qubit].append({current_ind}). # Generate the dependency graph; for instructions_cycles in qubits_instructions_dependency:; for cycle_ind1 in range(len(instructions_cycles) - 1):; for instruction_ind1 in instructions_cycles[cycle_ind1]:; for instruction_ind2 in ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:5318,Integrability,depend,depends,5318,"eans that they do not commute.; However, the converse does not hold because we do not need; gate1->gate3 if we already have gate1->gate2->gate3. Parameters; ----------; commuting: function; A Python function that determines if two gates commute,; given that their used qubits overlap.; """"""; # initialize the graph; for node in self.nodes:; node.predecessors = set(); node.successors = set(). num_qubits = max(set().union(; *[instruction.used_qubits for instruction in self.nodes])) + 1; qubits_instructions_dependency = [[set()] for i in range(num_qubits)]; # qubits_instructions_dependency:; # instruction dependency for each qubits, a nested list of level 3.; # E.g. [; # [{1, }],; # [{0, 1}, {2, }],; # [{0, }]; # ]; # means that; # Gate0 acts on qubit 1 and 2, gate1 act on qubit0 and qubit1,; # but gate0 and gate1 cummute with each other.; # Therefore, there is not dependency between gate0 and gate1;; # Gate 2 acts on qubit1 and must be executed after gate0 and gate1.; # Hence, gate2 will depends on gate0 and gate1. # Generate instruction dependency for each qubit; for current_ind, instruction in enumerate(self.nodes):; for qubit in instruction.used_qubits:; # For each used qubit, find the last dependency gate set.; # If the current gate commute with all of them,; # add it to the list.; # Otherwise,; # append a new set with the current gate to the list.; dependent = False; for dependent_ind in qubits_instructions_dependency[qubit][-1]:; if not commuting(current_ind, dependent_ind, self.nodes):; dependent = True; if not dependent:; qubits_instructions_dependency[qubit][-1].add(current_ind); else:; qubits_instructions_dependency[qubit].append({current_ind}). # Generate the dependency graph; for instructions_cycles in qubits_instructions_dependency:; for cycle_ind1 in range(len(instructions_cycles) - 1):; for instruction_ind1 in instructions_cycles[cycle_ind1]:; for instruction_ind2 in instructions_cycles[cycle_ind1+1]:; self.nodes[instruction_ind1].successors.add(; instructi",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:5369,Integrability,depend,dependency,5369,"e we do not need; gate1->gate3 if we already have gate1->gate2->gate3. Parameters; ----------; commuting: function; A Python function that determines if two gates commute,; given that their used qubits overlap.; """"""; # initialize the graph; for node in self.nodes:; node.predecessors = set(); node.successors = set(). num_qubits = max(set().union(; *[instruction.used_qubits for instruction in self.nodes])) + 1; qubits_instructions_dependency = [[set()] for i in range(num_qubits)]; # qubits_instructions_dependency:; # instruction dependency for each qubits, a nested list of level 3.; # E.g. [; # [{1, }],; # [{0, 1}, {2, }],; # [{0, }]; # ]; # means that; # Gate0 acts on qubit 1 and 2, gate1 act on qubit0 and qubit1,; # but gate0 and gate1 cummute with each other.; # Therefore, there is not dependency between gate0 and gate1;; # Gate 2 acts on qubit1 and must be executed after gate0 and gate1.; # Hence, gate2 will depends on gate0 and gate1. # Generate instruction dependency for each qubit; for current_ind, instruction in enumerate(self.nodes):; for qubit in instruction.used_qubits:; # For each used qubit, find the last dependency gate set.; # If the current gate commute with all of them,; # add it to the list.; # Otherwise,; # append a new set with the current gate to the list.; dependent = False; for dependent_ind in qubits_instructions_dependency[qubit][-1]:; if not commuting(current_ind, dependent_ind, self.nodes):; dependent = True; if not dependent:; qubits_instructions_dependency[qubit][-1].add(current_ind); else:; qubits_instructions_dependency[qubit].append({current_ind}). # Generate the dependency graph; for instructions_cycles in qubits_instructions_dependency:; for cycle_ind1 in range(len(instructions_cycles) - 1):; for instruction_ind1 in instructions_cycles[cycle_ind1]:; for instruction_ind2 in instructions_cycles[cycle_ind1+1]:; self.nodes[instruction_ind1].successors.add(; instruction_ind2); self.nodes[instruction_ind2].predecessors.add(; instruction_ind",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:5528,Integrability,depend,dependency,5528,"Python function that determines if two gates commute,; given that their used qubits overlap.; """"""; # initialize the graph; for node in self.nodes:; node.predecessors = set(); node.successors = set(). num_qubits = max(set().union(; *[instruction.used_qubits for instruction in self.nodes])) + 1; qubits_instructions_dependency = [[set()] for i in range(num_qubits)]; # qubits_instructions_dependency:; # instruction dependency for each qubits, a nested list of level 3.; # E.g. [; # [{1, }],; # [{0, 1}, {2, }],; # [{0, }]; # ]; # means that; # Gate0 acts on qubit 1 and 2, gate1 act on qubit0 and qubit1,; # but gate0 and gate1 cummute with each other.; # Therefore, there is not dependency between gate0 and gate1;; # Gate 2 acts on qubit1 and must be executed after gate0 and gate1.; # Hence, gate2 will depends on gate0 and gate1. # Generate instruction dependency for each qubit; for current_ind, instruction in enumerate(self.nodes):; for qubit in instruction.used_qubits:; # For each used qubit, find the last dependency gate set.; # If the current gate commute with all of them,; # add it to the list.; # Otherwise,; # append a new set with the current gate to the list.; dependent = False; for dependent_ind in qubits_instructions_dependency[qubit][-1]:; if not commuting(current_ind, dependent_ind, self.nodes):; dependent = True; if not dependent:; qubits_instructions_dependency[qubit][-1].add(current_ind); else:; qubits_instructions_dependency[qubit].append({current_ind}). # Generate the dependency graph; for instructions_cycles in qubits_instructions_dependency:; for cycle_ind1 in range(len(instructions_cycles) - 1):; for instruction_ind1 in instructions_cycles[cycle_ind1]:; for instruction_ind2 in instructions_cycles[cycle_ind1+1]:; self.nodes[instruction_ind1].successors.add(; instruction_ind2); self.nodes[instruction_ind2].predecessors.add(; instruction_ind1). # Find start and end nodes of the graph; start = []; end = []; for i, instruction in enumerate(self.nodes):; if not",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:5691,Integrability,depend,dependent,5691,"used_qubits for instruction in self.nodes])) + 1; qubits_instructions_dependency = [[set()] for i in range(num_qubits)]; # qubits_instructions_dependency:; # instruction dependency for each qubits, a nested list of level 3.; # E.g. [; # [{1, }],; # [{0, 1}, {2, }],; # [{0, }]; # ]; # means that; # Gate0 acts on qubit 1 and 2, gate1 act on qubit0 and qubit1,; # but gate0 and gate1 cummute with each other.; # Therefore, there is not dependency between gate0 and gate1;; # Gate 2 acts on qubit1 and must be executed after gate0 and gate1.; # Hence, gate2 will depends on gate0 and gate1. # Generate instruction dependency for each qubit; for current_ind, instruction in enumerate(self.nodes):; for qubit in instruction.used_qubits:; # For each used qubit, find the last dependency gate set.; # If the current gate commute with all of them,; # add it to the list.; # Otherwise,; # append a new set with the current gate to the list.; dependent = False; for dependent_ind in qubits_instructions_dependency[qubit][-1]:; if not commuting(current_ind, dependent_ind, self.nodes):; dependent = True; if not dependent:; qubits_instructions_dependency[qubit][-1].add(current_ind); else:; qubits_instructions_dependency[qubit].append({current_ind}). # Generate the dependency graph; for instructions_cycles in qubits_instructions_dependency:; for cycle_ind1 in range(len(instructions_cycles) - 1):; for instruction_ind1 in instructions_cycles[cycle_ind1]:; for instruction_ind2 in instructions_cycles[cycle_ind1+1]:; self.nodes[instruction_ind1].successors.add(; instruction_ind2); self.nodes[instruction_ind2].predecessors.add(; instruction_ind1). # Find start and end nodes of the graph; start = []; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. def reverse_graph(self):; """"""; Reverse the graph.; The start node becomes the end node; Predecessors and successors ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:5834,Integrability,depend,dependent,5834,"ubits)]; # qubits_instructions_dependency:; # instruction dependency for each qubits, a nested list of level 3.; # E.g. [; # [{1, }],; # [{0, 1}, {2, }],; # [{0, }]; # ]; # means that; # Gate0 acts on qubit 1 and 2, gate1 act on qubit0 and qubit1,; # but gate0 and gate1 cummute with each other.; # Therefore, there is not dependency between gate0 and gate1;; # Gate 2 acts on qubit1 and must be executed after gate0 and gate1.; # Hence, gate2 will depends on gate0 and gate1. # Generate instruction dependency for each qubit; for current_ind, instruction in enumerate(self.nodes):; for qubit in instruction.used_qubits:; # For each used qubit, find the last dependency gate set.; # If the current gate commute with all of them,; # add it to the list.; # Otherwise,; # append a new set with the current gate to the list.; dependent = False; for dependent_ind in qubits_instructions_dependency[qubit][-1]:; if not commuting(current_ind, dependent_ind, self.nodes):; dependent = True; if not dependent:; qubits_instructions_dependency[qubit][-1].add(current_ind); else:; qubits_instructions_dependency[qubit].append({current_ind}). # Generate the dependency graph; for instructions_cycles in qubits_instructions_dependency:; for cycle_ind1 in range(len(instructions_cycles) - 1):; for instruction_ind1 in instructions_cycles[cycle_ind1]:; for instruction_ind2 in instructions_cycles[cycle_ind1+1]:; self.nodes[instruction_ind1].successors.add(; instruction_ind2); self.nodes[instruction_ind2].predecessors.add(; instruction_ind1). # Find start and end nodes of the graph; start = []; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. def reverse_graph(self):; """"""; Reverse the graph.; The start node becomes the end node; Predecessors and successors of each node are exchanged.; """"""; for node in self.nodes:; node.predecessors, node.successors \; = node.successo",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:5859,Integrability,depend,dependent,5859,"ubits)]; # qubits_instructions_dependency:; # instruction dependency for each qubits, a nested list of level 3.; # E.g. [; # [{1, }],; # [{0, 1}, {2, }],; # [{0, }]; # ]; # means that; # Gate0 acts on qubit 1 and 2, gate1 act on qubit0 and qubit1,; # but gate0 and gate1 cummute with each other.; # Therefore, there is not dependency between gate0 and gate1;; # Gate 2 acts on qubit1 and must be executed after gate0 and gate1.; # Hence, gate2 will depends on gate0 and gate1. # Generate instruction dependency for each qubit; for current_ind, instruction in enumerate(self.nodes):; for qubit in instruction.used_qubits:; # For each used qubit, find the last dependency gate set.; # If the current gate commute with all of them,; # add it to the list.; # Otherwise,; # append a new set with the current gate to the list.; dependent = False; for dependent_ind in qubits_instructions_dependency[qubit][-1]:; if not commuting(current_ind, dependent_ind, self.nodes):; dependent = True; if not dependent:; qubits_instructions_dependency[qubit][-1].add(current_ind); else:; qubits_instructions_dependency[qubit].append({current_ind}). # Generate the dependency graph; for instructions_cycles in qubits_instructions_dependency:; for cycle_ind1 in range(len(instructions_cycles) - 1):; for instruction_ind1 in instructions_cycles[cycle_ind1]:; for instruction_ind2 in instructions_cycles[cycle_ind1+1]:; self.nodes[instruction_ind1].successors.add(; instruction_ind2); self.nodes[instruction_ind2].predecessors.add(; instruction_ind1). # Find start and end nodes of the graph; start = []; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. def reverse_graph(self):; """"""; Reverse the graph.; The start node becomes the end node; Predecessors and successors of each node are exchanged.; """"""; for node in self.nodes:; node.predecessors, node.successors \; = node.successo",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:6014,Integrability,depend,dependency,6014,"gate1 cummute with each other.; # Therefore, there is not dependency between gate0 and gate1;; # Gate 2 acts on qubit1 and must be executed after gate0 and gate1.; # Hence, gate2 will depends on gate0 and gate1. # Generate instruction dependency for each qubit; for current_ind, instruction in enumerate(self.nodes):; for qubit in instruction.used_qubits:; # For each used qubit, find the last dependency gate set.; # If the current gate commute with all of them,; # add it to the list.; # Otherwise,; # append a new set with the current gate to the list.; dependent = False; for dependent_ind in qubits_instructions_dependency[qubit][-1]:; if not commuting(current_ind, dependent_ind, self.nodes):; dependent = True; if not dependent:; qubits_instructions_dependency[qubit][-1].add(current_ind); else:; qubits_instructions_dependency[qubit].append({current_ind}). # Generate the dependency graph; for instructions_cycles in qubits_instructions_dependency:; for cycle_ind1 in range(len(instructions_cycles) - 1):; for instruction_ind1 in instructions_cycles[cycle_ind1]:; for instruction_ind2 in instructions_cycles[cycle_ind1+1]:; self.nodes[instruction_ind1].successors.add(; instruction_ind2); self.nodes[instruction_ind2].predecessors.add(; instruction_ind1). # Find start and end nodes of the graph; start = []; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. def reverse_graph(self):; """"""; Reverse the graph.; The start node becomes the end node; Predecessors and successors of each node are exchanged.; """"""; for node in self.nodes:; node.predecessors, node.successors \; = node.successors, node.predecessors; try:; self.distance_to_start, self.distance_to_end = \; self.distance_to_end, self.distance_to_start; except AttributeError:; pass; self.start, self.end = self.end, self.start. def find_topological_order(; self, priority=True, apply_constraint",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:8139,Integrability,depend,dependency,8139,"dom=False):; """"""; A list-schedule algorithm, it; finds the topological order of the directed graph; under certain constraint and priority indicator.; The function returns a list of cycles,; where each cycle is a list of instructions; that can be executed in parallel.; In the case of gates schedule,; the result will be the gates cycle list. Parameters; ----------; priority: bool; If use distance to the start and end nodes; as a priority measure for the schedule problem.; apply_constraint: function; A Python function that determines; if to instruction can be executed in parallel.; E.g. if two gates apply to the same qubit, the function; returns False. Returns; -------; cycles_list: list; A list of cycles, where each cycle is a list of instructions; that can be executed in parallel.; constraint_dependency: set; A set of instruction pairs that are found conflicted; due to the hardware constraints.; Because of this, they are executed in different cycles.; This set is used to add this dependency to the graph; in another method.; """"""; # The method will destruct the graph, therefore we make a copy.; graph = deepcopy(self.nodes); cycles_list = []; available_nodes = list(self.start) # a list of available instructions; # pairs of instructions that are limited by hardware constraint; constraint_dependency = set(). while available_nodes:; if random:; shuffle(available_nodes); if priority:; available_nodes.sort(key=cmp_to_key(self._compare_priority)); current_cycle = []; if apply_constraint is None: # if no constraits; current_cycle = deepcopy(available_nodes); else: # check if constraits allow the parallelization; for node1 in available_nodes:; approval = True; for node2 in current_cycle:; if not apply_constraint(node1, node2, graph):; approval = False; # save the conflicted pairs of instructions; constraint_dependency.add((node2, node1)); if approval:; current_cycle.append(node1); # add this cycle to cycles_list; cycles_list.append(current_cycle). # update the list of available",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:9752,Integrability,depend,dependency,9752,"lable_nodes:; approval = True; for node2 in current_cycle:; if not apply_constraint(node1, node2, graph):; approval = False; # save the conflicted pairs of instructions; constraint_dependency.add((node2, node1)); if approval:; current_cycle.append(node1); # add this cycle to cycles_list; cycles_list.append(current_cycle). # update the list of available nodes; # remove the executed nodes from available_node; for node in current_cycle:; available_nodes.remove(node); # add new nodes to available_nodes; # if they have no other predecessors; for node in current_cycle:; for successor_ind in graph[node].successors:; graph[successor_ind].predecessors.remove(node); if not graph[successor_ind].predecessors:; available_nodes.append(successor_ind); graph[node].successors = set(). return cycles_list, constraint_dependency. def compute_distance(self, cycles_list):; """"""; Compute the longest distance of each node; to the start and end nodes.; The weight for each dependency arrow is; the duration of the source instruction; (which should be 1 for gates schedule).; The method solves the longest path problem; by using the topological order in cycles_list.; It makes sure that by following the list,; the distance to the predecessors (successors) of; the source (target) node is always calculated; before the target (source) node. Parameters; ----------; cycles_list: list; A `cycles_list` obtained by the method `find_topological_order`.; """"""; cycles_list = deepcopy(cycles_list). # distance to the start node; for cycle in cycles_list:; for ind in cycle:; if not self.nodes[ind].predecessors:; self.nodes[ind].distance_to_start = \; self.nodes[ind].duration; else:; self.nodes[ind].distance_to_start = max(; [; self.nodes[predecessor_ind].distance_to_start; for predecessor_ind; in self.nodes[ind].predecessors; ]; ) + self.nodes[ind].duration. # distance to the end node; cycles_list.reverse(); self.reverse_graph(); for cycle in cycles_list:; for ind in cycle:; if not self.nodes[ind].predecessors:;",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:11887,Integrability,depend,dependency,11887,"istance_to_end = max(; [; self.nodes[predecessor_ind].distance_to_end; for predecessor_ind; in self.nodes[ind].predecessors; ]; ) + self.nodes[ind].duration; self.longest_distance = max(; [self.nodes[i].distance_to_end for i in self.end]); self.reverse_graph(). def _compare_priority(self, ind1, ind2):; """"""; The node with longer `distance_to_end` has higher priority.; If it is the same for the two nodes,; the node with shorter `distance_to_start` has higher priority.; If node1 has higher priority, the method returns a negative value. Parameters; ----------; ind1, ind2: int; Indices of nodes.; """"""; if self.nodes[ind1].distance_to_end == \; self.nodes[ind2].distance_to_end:; # lower distance_to_start, higher priority; return self.nodes[ind1].distance_to_start - \; self.nodes[ind2].distance_to_start; else:; # higher distance_to_end, higher priority; return self.nodes[ind2].distance_to_end - \; self.nodes[ind1].distance_to_end. def add_constraint_dependency(self, constraint_dependency):; """"""; Add the dependency caused by hardware constraint to the graph. Parameters; ----------; constraint_dependency: list; `constraint_dependency` obtained by the method; `find_topological_order`.; """"""; for ind1, ind2 in constraint_dependency:; self.nodes[ind1].successors.add(ind2); self.nodes[ind2].predecessors.add(ind1). # Update the start and end nodes of the graph; start = []; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. [docs]class Scheduler():; """"""; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419. The scheduler includes two methods,; ""ASAP"", as soon as possible, and ""ALAP"", as late as possible.; The later is commonly used in quantum computation; because",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:13978,Integrability,depend,dependency,13978,"he gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters; ----------; method: str; ""ASAP"" for as soon as possible.; ""ALAP"" for as late as possible.; constraint_functions: list, optional; A list of hardware constraint functions.; Default includes a function `qubit_contraint`,; i.e. one qubit cannot be used by two gates at the same time.; """"""; def __init__(self, method=""ALAP"", constraint_functions=None):; self.method = method; if constraint_functions is None:; self.constraint_functions = [qubit_constraint]; else:; return constraint_functions. [docs] def schedule(self, circuit, gates_schedule=False,; return_cycles_list=False, random_shuffle=False,; repeat_num=0):; """"""; Schedule a `QubitCircuit`,; a list of `Gates` or a list of `Instruction`.; For pulse schedule, the execution time for each `Instruction`; is given in its `duration` attributes. The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions. For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distanc",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:14162,Integrability,depend,dependent,14162,"on as possible.; ""ALAP"" for as late as possible.; constraint_functions: list, optional; A list of hardware constraint functions.; Default includes a function `qubit_contraint`,; i.e. one qubit cannot be used by two gates at the same time.; """"""; def __init__(self, method=""ALAP"", constraint_functions=None):; self.method = method; if constraint_functions is None:; self.constraint_functions = [qubit_constraint]; else:; return constraint_functions. [docs] def schedule(self, circuit, gates_schedule=False,; return_cycles_list=False, random_shuffle=False,; repeat_num=0):; """"""; Schedule a `QubitCircuit`,; a list of `Gates` or a list of `Instruction`.; For pulse schedule, the execution time for each `Instruction`; is given in its `duration` attributes. The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions. For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters; ----------; circuit: QubitCircuit or list; For gate schedule,; it should be a QubitCircuit or a list",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:14327,Integrability,depend,dependency,14327,"bit cannot be used by two gates at the same time.; """"""; def __init__(self, method=""ALAP"", constraint_functions=None):; self.method = method; if constraint_functions is None:; self.constraint_functions = [qubit_constraint]; else:; return constraint_functions. [docs] def schedule(self, circuit, gates_schedule=False,; return_cycles_list=False, random_shuffle=False,; repeat_num=0):; """"""; Schedule a `QubitCircuit`,; a list of `Gates` or a list of `Instruction`.; For pulse schedule, the execution time for each `Instruction`; is given in its `duration` attributes. The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions. For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters; ----------; circuit: QubitCircuit or list; For gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute `duration`; that indicates the execution time of this instruction.; gates_schedule:",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:14870,Integrability,depend,dependency,14870," attributes. The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions. For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters; ----------; circuit: QubitCircuit or list; For gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute `duration`; that indicates the execution time of this instruction.; gates_schedule: bool, optional; `True`, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input `circuit` is a `QubitCircuit`,; it will be assigned to `True` automatically.; Otherwise, the default is `False`.; return_cycles_list: bool, optional; If `True`, the method returns the `cycles_list`,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule.; random_shuffle: bool, optional;",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:17699,Integrability,depend,dependency,17699,"te(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; ``[gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]``; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles.; """"""; circuit = deepcopy(circuit); if repeat_num > 0:; random_shuffle = True; result = [0]; max_length = 4294967296; for i in range(repeat_num):; gate_cycle_indices = self.schedule(; circuit, gates_schedule=gates_schedule,; return_cycles_list=return_cycles_list,; random_shuffle=random_shuffle, repeat_num=0); current_length = max(gate_cycle_indices); if current_length < max_length:; result = gate_cycle_indices; max_length = current_length; return result. if isinstance(circuit, QubitCircuit):; gates = circuit.gates; else:; gates = circuit. # Generate the quantum operations dependency graph.; instructions_graph = InstructionsGraph(gates); instructions_graph.generate_dependency_graph(; commuting=self.commutation_rules); if self.method == ""ALAP"":; instructions_graph.reverse_graph(). # Schedule without hardware constraints, then; # use this cycles_list to compute the distance.; cycles_list, _ = instructions_graph.find_topological_order(; priority=False, apply_constraint=None, random=random_shuffle); instructions_graph.compute_distance(cycles_list=cycles_list). # Schedule again with priority and hardware constraint.; cycles_list, constraint_dependency = \; instructions_graph.find_topological_order(; priority=True, apply_constraint=self.apply_constraint,; random=random_shuffle). # If we only need gates schedule, we can output the result here.; if gates_schedule or return_cycles_list:; if self.method == ""ALAP"":; cycles_list.reverse(); if return_cycles_list:; return cycles_list; gate_cycles_indices = [0] * len(gates); for cycle_ind, cycle in enumerate(c",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:18858,Integrability,depend,dependency,18858,"tructions_graph.reverse_graph(). # Schedule without hardware constraints, then; # use this cycles_list to compute the distance.; cycles_list, _ = instructions_graph.find_topological_order(; priority=False, apply_constraint=None, random=random_shuffle); instructions_graph.compute_distance(cycles_list=cycles_list). # Schedule again with priority and hardware constraint.; cycles_list, constraint_dependency = \; instructions_graph.find_topological_order(; priority=True, apply_constraint=self.apply_constraint,; random=random_shuffle). # If we only need gates schedule, we can output the result here.; if gates_schedule or return_cycles_list:; if self.method == ""ALAP"":; cycles_list.reverse(); if return_cycles_list:; return cycles_list; gate_cycles_indices = [0] * len(gates); for cycle_ind, cycle in enumerate(cycles_list):; for instruction_ind in cycle:; gate_cycles_indices[instruction_ind] = cycle_ind; return gate_cycles_indices. # For pulse schedule,; # we add the hardware dependency to the graph; # and compute the longest distance to the start node again.; # The longest distance to the start node determines; # the start time of each pulse.; instructions_graph.add_constraint_dependency(constraint_dependency); instructions_graph.compute_distance(cycles_list=cycles_list). # Output pulse schedule result.; instruction_start_time = []; if self.method == ""ASAP"":; for instruction in instructions_graph.nodes:; instruction_start_time.append(; instruction.distance_to_start - instruction.duration); elif self.method == ""ALAP"":; for instruction in instructions_graph.nodes:; instruction_start_time.append(; instructions_graph.longest_distance -; instruction.distance_to_start); return instruction_start_time. [docs] def commutation_rules(self, ind1, ind2, instructions):; """"""; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:. If the two gates do not have the same n",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:2701,Performance,latency,latency,2701,"ENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections import deque; from copy import deepcopy; from functools import cmp_to_key; from random import shuffle. from ..circuit import QubitCircuit, Gate; from .instruction import Instruction. class InstructionsGraph():; """"""; A directed acyclic graph (DAG) representation; of the quantum instruction dependency.; An example is Fig3(b) in https://doi.org/10.1117/12.666419.; It contains methods of generating the instruction dependency graph,; a list-schedule algorithm to find the topological order; and the computation of the distance in the weighted graph; (circuit latency). It uses the `Instruction` object as a representation of node; and adds the following attributes to it:. predecessors, successors: dependency arrow of the DAG; distance_to_start, distance_to_end: longest distance to the start and end. Parameters; ----------; instructions: list; A list of instructions. Attributes; ----------; nodes: list; The input list of instruction with additional graph information.; start, end: list; List of indices of nodes connected to the start or end nodes.; """"""; def __init__(self, instructions):; instructions = deepcopy(instructions); self.nodes = []; for instruction in instructions:; if isinstance(instruction, Gate):; self.nodes.append(Instruction(instruction)); else:; self.nodes.append(instruction); for node in self.nodes:; if node.duration is None:; node.duration = 1; self.start = None; self.end = None. def generate_dependency_graph(self, commuting):; """"""; G",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:13062,Performance,optimiz,optimized,13062," for ind1, ind2 in constraint_dependency:; self.nodes[ind1].successors.add(ind2); self.nodes[ind2].predecessors.add(ind1). # Update the start and end nodes of the graph; start = []; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. [docs]class Scheduler():; """"""; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419. The scheduler includes two methods,; ""ASAP"", as soon as possible, and ""ALAP"", as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits. The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters; ----------; method: str; ""ASAP"" for as soon as possible.; ""ALAP"" for as late as possible.; constraint_functions: list, optional; A list of hardware constraint functions.; Default includes a function `qubit_contraint`,; i.e. one qubit cannot be used by two gates at the same time.; """"""; def __init__(self, method=""ALAP"", constraint_functions=None):; self.method = method; if constraint_functions is None:; self.constraint_functions = [qubit_constraint]; else:; return constraint_functions. [docs] def schedule(self, circuit, gates_schedule=False,; return_cycles_list=False, random_shuffle=False,; repeat_num=0):; """"""; Schedule a `QubitCircuit`,; a list of `Gates` or a list of `Instruction`.; For pulse schedule, the execution time for each `Instruction`; is given in its `duration` attributes. The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some oth",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/scheduler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/spinchaincompiler.html:3949,Deployability,update,update,3949,"ad of ``(pulse_index, coeff)``.; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer ``pulse_index`` needs to be used; in the compiling routine saved under the attributes ``gate_compiler``. Attributes; ----------; N: int; The number of the component systems. params: dict; A Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc. pulse_dict: dict; A map between the pulse label and its index in the pulse list. gate_compiler: dict; The Python dictionary in the form of {gate_name: decompose_function}.; It saves the decomposition scheme for each gate. setup: string; ""linear"" or ""circular"" for two sub-classes. global_phase: bool; Record of the global phase change and will be returned.; """"""; def __init__(self, N, params, pulse_dict, setup=""linear"", global_phase=0.):; super(SpinChainCompiler, self).__init__(; N=N, params=params, pulse_dict=pulse_dict); self.gate_compiler.update({; ""ISWAP"": self.iswap_compiler,; ""SQRTISWAP"": self.sqrtiswap_compiler,; ""RZ"": self.rz_compiler,; ""RX"": self.rx_compiler,; ""GLOBALPHASE"": self.globalphase_compiler; }); self.global_phase = global_phase. [docs] def rz_compiler(self, gate, args):; """"""; Compiler for the RZ gate; """"""; targets = gate.targets; g = self.params[""sz""][targets[0]]; coeff = np.sign(gate.arg_value) * g; tlist = abs(gate.arg_value) / (2 * g); pulse_info = [(""sz"" + str(targets[0]), coeff)]; return [Instruction(gate, tlist, pulse_info)]. [docs] def rx_compiler(self, gate, args):; """"""; Compiler for the RX gate; """"""; targets = gate.targets; g = self.params[""sx""][targets[0]]; coeff = np.sign(gate.arg_value) * g; tlist = abs(gate.arg_value) / (2 * g); pulse_info = [(""sx"" + str(targets[0]), coeff)]; return [Instruction(gate, tlist, pulse_info)]. [docs] def iswap_compiler(self, gate, args):; """"""; Compiler for the ISWAP gate; """"""; targets = gate.targets; q1, q2 = min(targets), max(targets); g = self.params[""sxsy""][q1]; coeff = -",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/spinchaincompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/spinchaincompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/spinchaincompiler.html:5923,Deployability,update,updated,5923,"er,; ""RZ"": self.rz_compiler,; ""RX"": self.rx_compiler,; ""GLOBALPHASE"": self.globalphase_compiler; }); self.global_phase = global_phase. [docs] def rz_compiler(self, gate, args):; """"""; Compiler for the RZ gate; """"""; targets = gate.targets; g = self.params[""sz""][targets[0]]; coeff = np.sign(gate.arg_value) * g; tlist = abs(gate.arg_value) / (2 * g); pulse_info = [(""sz"" + str(targets[0]), coeff)]; return [Instruction(gate, tlist, pulse_info)]. [docs] def rx_compiler(self, gate, args):; """"""; Compiler for the RX gate; """"""; targets = gate.targets; g = self.params[""sx""][targets[0]]; coeff = np.sign(gate.arg_value) * g; tlist = abs(gate.arg_value) / (2 * g); pulse_info = [(""sx"" + str(targets[0]), coeff)]; return [Instruction(gate, tlist, pulse_info)]. [docs] def iswap_compiler(self, gate, args):; """"""; Compiler for the ISWAP gate; """"""; targets = gate.targets; q1, q2 = min(targets), max(targets); g = self.params[""sxsy""][q1]; coeff = -g; tlist = np.pi / (4 * g); if self.N != 2 and q1 == 0 and q2 == self.N - 1:; pulse_name = ""g"" + str(q2); else:; pulse_name = ""g"" + str(q1); pulse_info = [(pulse_name, coeff)]; return [Instruction(gate, tlist, pulse_info)]. [docs] def sqrtiswap_compiler(self, gate, args):; """"""; Compiler for the SQRTISWAP gate; """"""; targets = gate.targets; q1, q2 = min(targets), max(targets); g = self.params[""sxsy""][q1]; coeff = -g; tlist = np.pi / (8 * g); if self.N != 2 and q1 == 0 and q2 == self.N - 1:; pulse_name = ""g"" + str(q2); else:; pulse_name = ""g"" + str(q1); pulse_info = [(pulse_name, coeff)]; return [Instruction(gate, tlist, pulse_info)]. [docs] def globalphase_compiler(self, gate, args):; """"""; Compiler for the GLOBALPHASE gate; """"""; self.global_phase += gate.arg_value. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/spinchaincompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/spinchaincompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/compiler/spinchaincompiler.html:3156,Integrability,rout,routine,3156,"######; import numpy as np. from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.compiler import GateCompiler, Instruction. __all__ = ['SpinChainCompiler']. [docs]class SpinChainCompiler(GateCompiler):; """"""; Compile a :class:`.QubitCircuit` into; the pulse sequence for the processor. Parameters; ----------; N: int; The number of qubits in the system. params: dict; A Python dictionary contains the name and the value of the parameters.; See :meth:`.SpinChain.set_up_params` for the definition. setup: string; ""linear"" or ""circular"" for two sub-classes. global_phase: bool; Record of the global phase change and will be returned. pulse_dict: dict, optional; A map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; ``(pulse_label, coeff)``, instead of ``(pulse_index, coeff)``.; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer ``pulse_index`` needs to be used; in the compiling routine saved under the attributes ``gate_compiler``. Attributes; ----------; N: int; The number of the component systems. params: dict; A Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc. pulse_dict: dict; A map between the pulse label and its index in the pulse list. gate_compiler: dict; The Python dictionary in the form of {gate_name: decompose_function}.; It saves the decomposition scheme for each gate. setup: string; ""linear"" or ""circular"" for two sub-classes. global_phase: bool; Record of the global phase change and will be returned.; """"""; def __init__(self, N, params, pulse_dict, setup=""linear"", global_phase=0.):; super(SpinChainCompiler, self).__init__(; N=N, params=params, pulse_dict=pulse_dict); self.gate_compiler.update({; ""ISWAP"": self.iswap_compiler,; ""SQRTISWAP"": self.sqrtiswap_compiler,; ""RZ"": self.rz_compiler,; ""RX"": self.rx_compiler,; ""GLOBALPHASE"": self.globalphase_compiler; }); self.global_phase ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/compiler/spinchaincompiler.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/spinchaincompiler.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html:2886,Availability,avail,available,2886,"EGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; import warnings; from copy import deepcopy. import numpy as np. from qutip.operators import tensor, identity, destroy, sigmax, sigmaz; from qutip.states import basis; from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.device.processor import Processor; from qutip.qip.device.modelprocessor import ModelProcessor; from qutip.qip.operations import expand_operator; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.qip.pulse import Pulse; from qutip.qip.compiler.gatecompiler import GateCompiler; from qutip.qip.compiler import CavityQEDCompiler. __all__ = ['DispersiveCavityQED']. [docs]class DispersiveCavityQED(ModelProcessor):; """"""; The processor based on the physical implementation of; a dispersive cavity QED system.; The available Hamiltonian of the system is predefined.; For a given pulse amplitude matrix, the processor can; calculate the state evolution under the given control pulse,; either analytically or numerically.; (Only additional attributes are documented here, for others please; refer to the parent class :class:`.ModelProcessor`). Parameters; ----------; N: int; The number of qubits in the system. correct_global_phase: float, optional; Save the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. num_levels: int, optional; The number of energy levels in the resonator. deltamax: int or list, optional; The coefficients of sigma-x for each of the qubits in the system. epsmax: int or list, optional; The coefficients of sigma-z for each of the qubits in the system. w0: int, optional; The base frequency of the resonator. eps: int or list, optional; The epsilon for each of the qubits in the system. delta: int or list, optional; The epsilon for each of the qubit",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/cavityqed.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html:10821,Deployability,update,updated,10821,"n) for n in range(self.N)]]). [docs] def optimize_circuit(self, qc):; """"""; Take a quantum circuit/algorithm and convert it into the; optimal form/basis for the desired physical system. Parameters; ----------; qc: :class:`.QubitCircuit`; Takes the quantum circuit to be implemented. Returns; -------; qc: :class:`.QubitCircuit`; The circuit representation with elementary gates; that can be implemented in this model.; """"""; self.qc0 = qc; self.qc1 = self.qc0.resolve_gates(; basis=[""SQRTISWAP"", ""ISWAP"", ""RX"", ""RZ""]); return self.qc1. [docs] def eliminate_auxillary_modes(self, U):; """"""; Eliminate the auxillary modes like the cavity modes in cqed.; """"""; psi_proj = tensor(; [basis(self.num_levels, 0)] +; [identity(2) for n in range(self.N)]); return psi_proj.dag() * U * psi_proj. [docs] def load_circuit(; self, qc, schedule_mode=""ASAP"", compiler=None):; """"""; Decompose a :class:`.QubitCircuit` in to the control; amplitude generating the corresponding evolution. Parameters; ----------; qc: :class:`.QubitCircuit`; Takes the quantum circuit to be implemented. Returns; -------; tlist: array_like; A NumPy array specifies the time of each coefficient. coeffs: array_like; A 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian.; """"""; gates = self.optimize_circuit(qc).gates; if compiler is None:; compiler = CavityQEDCompiler(; self.N, self._params,; pulse_dict=deepcopy(self.pulse_dict),; global_phase=0.); tlist, coeffs = compiler.compile(; gates, schedule_mode=schedule_mode); self.global_phase = compiler.global_phase; self.coeffs = coeffs; for i in range(len(coeffs)):; self.pulses[i].tlist = tlist[i]; return tlist, self.coeffs. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/cavityqed.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html:3483,Energy Efficiency,energy,energy,3483,"rt expand_operator; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.qip.pulse import Pulse; from qutip.qip.compiler.gatecompiler import GateCompiler; from qutip.qip.compiler import CavityQEDCompiler. __all__ = ['DispersiveCavityQED']. [docs]class DispersiveCavityQED(ModelProcessor):; """"""; The processor based on the physical implementation of; a dispersive cavity QED system.; The available Hamiltonian of the system is predefined.; For a given pulse amplitude matrix, the processor can; calculate the state evolution under the given control pulse,; either analytically or numerically.; (Only additional attributes are documented here, for others please; refer to the parent class :class:`.ModelProcessor`). Parameters; ----------; N: int; The number of qubits in the system. correct_global_phase: float, optional; Save the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. num_levels: int, optional; The number of energy levels in the resonator. deltamax: int or list, optional; The coefficients of sigma-x for each of the qubits in the system. epsmax: int or list, optional; The coefficients of sigma-z for each of the qubits in the system. w0: int, optional; The base frequency of the resonator. eps: int or list, optional; The epsilon for each of the qubits in the system. delta: int or list, optional; The epsilon for each of the qubits in the system. g: int or list, optional; The interaction strength for each of the qubit with the resonator. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. Attributes; ----------; sx_ops: list; A list of sigmax Hamiltonians for each qubit. sz_ops: list; A list of sigmaz Hamiltonians for each qubit. cavityqubit_ops: list; A list of interacting Hamiltonians be",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/cavityqed.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html:6914,Energy Efficiency,energy,energy,6914,"lf.pulses.append(; Pulse(sigmaz(), [m+1], spline_kind=self.spline_kind)); self.pulse_dict[""sz"" + str(m)] = index; index += 1; # coupling terms; a = tensor(; [destroy(self.num_levels)] +; [identity(2) for n in range(N)]); for n in range(N):; sm = tensor([identity(self.num_levels)] +; [destroy(2) if m == n else identity(2); for m in range(N)]); self.pulses.append(; Pulse(a.dag() * sm + a * sm.dag(),; list(range(N+1)), spline_kind=self.spline_kind)); self.pulse_dict[""g"" + str(n)] = index; index += 1. [docs] def set_up_params(; self, N, num_levels, deltamax,; epsmax, w0, wq, eps, delta, g):; """"""; Save the parameters in the attribute `params` and check the validity.; The keys of `params` including ""sx"", ""sz"", ""w0"", ""eps"", ""delta""; and ""g"", each; mapped to a list for parameters corresponding to each qubits.; For coupling strength ""g"", list element i is the interaction; between qubits i and i+1. Parameters; ----------; N: int; The number of qubits in the system. num_levels: int; The number of energy levels in the resonator. deltamax: list; The coefficients of sigma-x for each of the qubits in the system. epsmax: list; The coefficients of sigma-z for each of the qubits in the system. wo: int; The base frequency of the resonator. wq: list; The frequency of the qubits. eps: list; The epsilon for each of the qubits in the system. delta: list; The delta for each of the qubits in the system. g: list; The interaction strength for each of the qubit with the resonator. Notes; -----; All parameters will be multiplied by 2*pi for simplicity; """"""; sx_para = 2 * np.pi * self.to_array(deltamax, N); self._params[""sx""] = sx_para; sz_para = 2 * np.pi * self.to_array(epsmax, N); self._params[""sz""] = sz_para; w0 = 2 * np.pi * w0; self._params[""w0""] = w0; eps = 2 * np.pi * self.to_array(eps, N); self._params[""eps""] = eps; delta = 2 * np.pi * self.to_array(delta, N); self._params[""delta""] = delta; g = 2 * np.pi * self.to_array(g, N); self._params[""g""] = g. # computed; self.wq = np.sqrt(eps**2 +",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/cavityqed.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html:6041,Modifiability,coupling,coupling,6041,"=0.01, t1=None, t2=None):; super(DispersiveCavityQED, self).__init__(; N, correct_global_phase=correct_global_phase,; t1=t1, t2=t2); self.correct_global_phase = correct_global_phase; self.spline_kind = ""step_func""; self.num_levels = num_levels; self._params = {}; self.set_up_params(; N=N, num_levels=num_levels, deltamax=deltamax,; epsmax=epsmax, w0=w0, wq=wq, eps=eps,; delta=delta, g=g); self.set_up_ops(N); self.dims = [num_levels] + [2] * N. [docs] def set_up_ops(self, N):; """"""; Generate the Hamiltonians for the spinchain model and save them in the; attribute `ctrls`. Parameters; ----------; N: int; The number of qubits in the system.; """"""; self.pulse_dict = {}; index = 0; # single qubit terms; for m in range(N):; self.pulses.append(; Pulse(sigmax(), [m+1], spline_kind=self.spline_kind)); self.pulse_dict[""sx"" + str(m)] = index; index += 1; for m in range(N):; self.pulses.append(; Pulse(sigmaz(), [m+1], spline_kind=self.spline_kind)); self.pulse_dict[""sz"" + str(m)] = index; index += 1; # coupling terms; a = tensor(; [destroy(self.num_levels)] +; [identity(2) for n in range(N)]); for n in range(N):; sm = tensor([identity(self.num_levels)] +; [destroy(2) if m == n else identity(2); for m in range(N)]); self.pulses.append(; Pulse(a.dag() * sm + a * sm.dag(),; list(range(N+1)), spline_kind=self.spline_kind)); self.pulse_dict[""g"" + str(n)] = index; index += 1. [docs] def set_up_params(; self, N, num_levels, deltamax,; epsmax, w0, wq, eps, delta, g):; """"""; Save the parameters in the attribute `params` and check the validity.; The keys of `params` including ""sx"", ""sz"", ""w0"", ""eps"", ""delta""; and ""g"", each; mapped to a list for parameters corresponding to each qubits.; For coupling strength ""g"", list element i is the interaction; between qubits i and i+1. Parameters; ----------; N: int; The number of qubits in the system. num_levels: int; The number of energy levels in the resonator. deltamax: list; The coefficients of sigma-x for each of the qubits in the system. epsmax: li",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/cavityqed.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html:6731,Modifiability,coupling,coupling,6731,"ulses.append(; Pulse(sigmax(), [m+1], spline_kind=self.spline_kind)); self.pulse_dict[""sx"" + str(m)] = index; index += 1; for m in range(N):; self.pulses.append(; Pulse(sigmaz(), [m+1], spline_kind=self.spline_kind)); self.pulse_dict[""sz"" + str(m)] = index; index += 1; # coupling terms; a = tensor(; [destroy(self.num_levels)] +; [identity(2) for n in range(N)]); for n in range(N):; sm = tensor([identity(self.num_levels)] +; [destroy(2) if m == n else identity(2); for m in range(N)]); self.pulses.append(; Pulse(a.dag() * sm + a * sm.dag(),; list(range(N+1)), spline_kind=self.spline_kind)); self.pulse_dict[""g"" + str(n)] = index; index += 1. [docs] def set_up_params(; self, N, num_levels, deltamax,; epsmax, w0, wq, eps, delta, g):; """"""; Save the parameters in the attribute `params` and check the validity.; The keys of `params` including ""sx"", ""sz"", ""w0"", ""eps"", ""delta""; and ""g"", each; mapped to a list for parameters corresponding to each qubits.; For coupling strength ""g"", list element i is the interaction; between qubits i and i+1. Parameters; ----------; N: int; The number of qubits in the system. num_levels: int; The number of energy levels in the resonator. deltamax: list; The coefficients of sigma-x for each of the qubits in the system. epsmax: list; The coefficients of sigma-z for each of the qubits in the system. wo: int; The base frequency of the resonator. wq: list; The frequency of the qubits. eps: list; The epsilon for each of the qubits in the system. delta: list; The delta for each of the qubits in the system. g: list; The interaction strength for each of the qubit with the resonator. Notes; -----; All parameters will be multiplied by 2*pi for simplicity; """"""; sx_para = 2 * np.pi * self.to_array(deltamax, N); self._params[""sx""] = sx_para; sz_para = 2 * np.pi * self.to_array(epsmax, N); self._params[""sz""] = sz_para; w0 = 2 * np.pi * w0; self._params[""w0""] = w0; eps = 2 * np.pi * self.to_array(eps, N); self._params[""eps""] = eps; delta = 2 * np.pi * self.to_ar",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/cavityqed.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html:7977,Testability,test,tests,7977,"of sigma-x for each of the qubits in the system. epsmax: list; The coefficients of sigma-z for each of the qubits in the system. wo: int; The base frequency of the resonator. wq: list; The frequency of the qubits. eps: list; The epsilon for each of the qubits in the system. delta: list; The delta for each of the qubits in the system. g: list; The interaction strength for each of the qubit with the resonator. Notes; -----; All parameters will be multiplied by 2*pi for simplicity; """"""; sx_para = 2 * np.pi * self.to_array(deltamax, N); self._params[""sx""] = sx_para; sz_para = 2 * np.pi * self.to_array(epsmax, N); self._params[""sz""] = sz_para; w0 = 2 * np.pi * w0; self._params[""w0""] = w0; eps = 2 * np.pi * self.to_array(eps, N); self._params[""eps""] = eps; delta = 2 * np.pi * self.to_array(delta, N); self._params[""delta""] = delta; g = 2 * np.pi * self.to_array(g, N); self._params[""g""] = g. # computed; self.wq = np.sqrt(eps**2 + delta**2); self.Delta = self.wq - w0. # rwa/dispersive regime tests; if any(g / (w0 - self.wq) > 0.05):; warnings.warn(""Not in the dispersive regime""). if any((w0 - self.wq)/(w0 + self.wq) > 0.05):; warnings.warn(; ""The rotating-wave approximation might not be valid.""). @property; def sx_ops(self):; return self.ctrls[0: self.N]. @property; def sz_ops(self):; return self.ctrls[self.N: 2*self.N]. @property; def cavityqubit_ops(self):; return self.ctrls[2*self.N: 3*self.N]. @property; def sx_u(self):; return self.coeffs[: self.N]. @property; def sz_u(self):; return self.coeffs[self.N: 2*self.N]. @property; def g_u(self):; return self.coeffs[2*self.N: 3*self.N]. [docs] def get_operators_labels(self):; """"""; Get the labels for each Hamiltonian.; It is used in the method``plot_pulses``.; It is a 2-d nested list, in the plot,; a different color will be used for each sublist.; """"""; return ([[r""$\sigma_x^%d$"" % n for n in range(self.N)],; [r""$\sigma_z^%d$"" % n for n in range(self.N)],; [r""$g_{%d}$"" % (n) for n in range(self.N)]]). [docs] def optimize_circuit",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/cavityqed.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html:7451,Usability,simpl,simplicity,7451,"ams(; self, N, num_levels, deltamax,; epsmax, w0, wq, eps, delta, g):; """"""; Save the parameters in the attribute `params` and check the validity.; The keys of `params` including ""sx"", ""sz"", ""w0"", ""eps"", ""delta""; and ""g"", each; mapped to a list for parameters corresponding to each qubits.; For coupling strength ""g"", list element i is the interaction; between qubits i and i+1. Parameters; ----------; N: int; The number of qubits in the system. num_levels: int; The number of energy levels in the resonator. deltamax: list; The coefficients of sigma-x for each of the qubits in the system. epsmax: list; The coefficients of sigma-z for each of the qubits in the system. wo: int; The base frequency of the resonator. wq: list; The frequency of the qubits. eps: list; The epsilon for each of the qubits in the system. delta: list; The delta for each of the qubits in the system. g: list; The interaction strength for each of the qubit with the resonator. Notes; -----; All parameters will be multiplied by 2*pi for simplicity; """"""; sx_para = 2 * np.pi * self.to_array(deltamax, N); self._params[""sx""] = sx_para; sz_para = 2 * np.pi * self.to_array(epsmax, N); self._params[""sz""] = sz_para; w0 = 2 * np.pi * w0; self._params[""w0""] = w0; eps = 2 * np.pi * self.to_array(eps, N); self._params[""eps""] = eps; delta = 2 * np.pi * self.to_array(delta, N); self._params[""delta""] = delta; g = 2 * np.pi * self.to_array(g, N); self._params[""g""] = g. # computed; self.wq = np.sqrt(eps**2 + delta**2); self.Delta = self.wq - w0. # rwa/dispersive regime tests; if any(g / (w0 - self.wq) > 0.05):; warnings.warn(""Not in the dispersive regime""). if any((w0 - self.wq)/(w0 + self.wq) > 0.05):; warnings.warn(; ""The rotating-wave approximation might not be valid.""). @property; def sx_ops(self):; return self.ctrls[0: self.N]. @property; def sz_ops(self):; return self.ctrls[self.N: 2*self.N]. @property; def cavityqubit_ops(self):; return self.ctrls[2*self.N: 3*self.N]. @property; def sx_u(self):; return self.coeffs[",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/cavityqed.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/modelprocessor.html:2663,Availability,avail,available,2663,"T NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections.abc import Iterable; import numbers. import numpy as np. from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.qip.operations.gates import globalphase; from qutip.tensor import tensor; from qutip.mesolve import mesolve; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device.processor import Processor. __all__ = ['ModelProcessor']. [docs]class ModelProcessor(Processor):; """"""; The base class for a circuit processor simulating a physical device,; e.g cavityQED, spinchain.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It cannot be used alone, please refer to the sub-classes.; (Only additional attributes are documented here, for others please; refer to the parent class :class:`.Processor`). Parameters; ----------; N: int; The number of component systems. correct_global_phase: boolean, optional; If true, the analytical solution will track the global phase. It; has no effect on the numerical solution. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. Attributes; ----------; params: dict; A Python dictionary contains the name and the value of the parameters; in the physical realization, such as laser frequency, detuning etc. correct_global_phase: float; Save the g",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/modelprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/modelprocessor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/modelprocessor.html:7093,Deployability,update,updated,7093,"ation. qc: :class:`.QubitCircuit`, optional; A quantum circuit. If given, it first calls the ``load_circuit``; and then calculate the evolution. states: :class:`qutip.Qobj`, optional; Old API, same as init_state. **kwargs; Keyword arguments for the qutip solver. Returns; -------; evo_result: :class:`qutip.Result`; If ``analytical`` is False, an instance of the class; :class:`qutip.Result` will be returned. If ``analytical`` is True, a list of matrices representation; is returned.; """"""; if qc is not None:; self.load_circuit(qc); return super(ModelProcessor, self).run_state(; init_state=init_state, analytical=analytical,; states=states, **kwargs). [docs] def get_ops_and_u(self):; """"""; Get the labels for each Hamiltonian. Returns; -------; ctrls: list; The list of Hamiltonians; coeffs: array_like; The transposed pulse matrix; """"""; return (self.ctrls, self.get_full_coeffs().T). [docs] def pulse_matrix(self, dt=0.01):; """"""; Generates the pulse matrix for the desired physical system. Returns; -------; t, u, labels:; Returns the total time and label for every operation.; """"""; ctrls = self.ctrls; coeffs = self.get_full_coeffs().T. # FIXME This might becomes a problem if new tlist other than; # int the default pulses are added.; tlist = self.get_full_tlist(); dt_list = tlist[1:] - tlist[:-1]; t_tot = tlist[-1]; num_step = int(np.ceil(t_tot / dt)). t = np.linspace(0, t_tot, num_step); u = np.zeros((len(ctrls), num_step)). t_start = 0; for n in range(len(dt_list)):; t_idx_len = int(np.floor(dt_list[n] / dt)); mm = 0; for m in range(len(ctrls)):; u[mm, t_start:(t_start + t_idx_len)] = (np.ones(t_idx_len) *; coeffs[n, m]); mm += 1; t_start += t_idx_len. return t, u, self.get_operators_labels(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/modelprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/modelprocessor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/modelprocessor.html:4432,Usability,simpl,simplicity,4432," a float for all qubits. Attributes; ----------; params: dict; A Python dictionary contains the name and the value of the parameters; in the physical realization, such as laser frequency, detuning etc. correct_global_phase: float; Save the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution.; """"""; def __init__(self, N, correct_global_phase=True, t1=None, t2=None):; super(ModelProcessor, self).__init__(N, t1=t1, t2=t2); self.correct_global_phase = correct_global_phase; self.global_phase = 0.; self._params = {}. [docs] def to_array(self, params, N):; """"""; Transfer a parameter to an array.; """"""; if isinstance(params, numbers.Real):; return np.asarray([params] * N); elif isinstance(params, Iterable):; return np.asarray(params). [docs] def set_up_params(self):; """"""; Save the parameters in the attribute `params` and check the validity.; (Defined in subclasses). Notes; -----; All parameters will be multiplied by 2*pi for simplicity; """"""; raise NotImplementedError(""Parameters should be defined in subclass.""). @property; def params(self):; return self._params. @params.setter; def params(self, par):; self._params = par. [docs] def run_state(self, init_state=None, analytical=False, qc=None,; states=None, **kwargs):; """"""; If `analytical` is False, use :func:`qutip.mesolve` to; calculate the time of the state evolution; and return the result. Other arguments of mesolve can be; given as keyword arguments.; If `analytical` is True, calculate the propagator; with matrix exponentiation and return a list of matrices. Parameters; ----------; init_state: Qobj; Initial density matrix or state vector (ket). analytical: boolean; If True, calculate the evolution with matrices exponentiation. qc: :class:`.QubitCircuit`, optional; A quantum circuit. If given, it first calls the ``load_circuit``; and then calculate the evolution. states: :class:`qutip.Qobj`, optional; Old API, same as init_state. **kwargs; Keyword arguments for the q",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/modelprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/modelprocessor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html:2688,Availability,avail,available,2688,"AL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections.abc import Iterable; import warnings; import numbers. import numpy as np. from qutip.qobj import Qobj; import qutip.control.pulseoptim as cpo; from qutip.operators import identity; from qutip.tensor import tensor; from qutip.mesolve import mesolve; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device.processor import Processor; from qutip.qip.operations.gates import gate_sequence_product. __all__ = ['OptPulseProcessor']. [docs]class OptPulseProcessor(Processor):; """"""; A processor, which takes the Hamiltonian available; as dynamic generators, calls the; `qutip.control.optimize_pulse_unitary` function; to find an optimized pulse sequence for the desired quantum circuit.; The processor can simulate the evolution under the given; control pulses using :func:`qutip.mesolve`.; (For attributes documentation, please; refer to the parent class :class:`.Processor`). Parameters; ----------; N: int; The number of component systems. drift: `:class:`qutip.Qobj`; The drift Hamiltonian. The size must match the whole quantum system. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. dims: list; The dimension of each component system.; Default value is a; qubit system of ``dim=[2,2,2,...,2]``; """"""; def __init__(self, N, drift=None, t1=None, t2=None, dims=None):; super(OptPulseProcessor, s",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html:5550,Availability,toler,tolerance,5550,"gmax()]); # num_tslots and evo_time are two keyword arguments; tlist, coeffs = processor.load_circuit(; qc, num_tslots=num_tslots, evo_time=evo_time). Different parameters for different gates:. .. code-block:: python. qc = QubitCircuit(N=2); qc.add_gate(""SNOT"", 0); qc.add_gate(""SWAP"", targets=[0, 1]); qc.add_gate('CNOT', controls=1, targets=[0]). processor = OptPulseProcessor(N=2, drift=tensor([sigmaz()]*2)); processor.add_control(sigmax(), cyclic_permutation=True); processor.add_control(sigmay(), cyclic_permutation=True); processor.add_control(tensor([sigmay(), sigmay()])); setting_args = {""SNOT"": {""num_tslots"": 10, ""evo_time"": 1},; ""SWAP"": {""num_tslots"": 30, ""evo_time"": 3},; ""CNOT"": {""num_tslots"": 30, ""evo_time"": 3}}; tlist, coeffs = processor.load_circuit(qc,; setting_args=setting_args,; merge_gates=False). Parameters; ----------; qc: :class:`.QubitCircuit` or list of Qobj; The quantum circuit to be translated. min_fid_err: float, optional; The minimal fidelity tolerance, if the fidelity error of any; gate decomposition is higher, a warning will be given.; Default is infinite. merge_gates: boolean, optimal; If True, merge all gate/Qobj into one Qobj and then; find the optimal pulses for this unitary matrix. If False,; find the optimal pulses for each gate/Qobj. setting_args: dict, optional; Only considered if merge_gates is False.; It is a dictionary containing keyword arguments; for different gates. E.g.: ::. setting_args = {""SNOT"": {""num_tslots"": 10, ""evo_time"": 1},; ""SWAP"": {""num_tslots"": 30, ""evo_time"": 3},; ""CNOT"": {""num_tslots"": 30, ""evo_time"": 3}}. verbose: boolean, optional; If true, the information for each decomposed gate; will be shown. Default is False. **kwargs; keyword arguments for `qutip.control.optimize_pulse_unitary`. Returns; -------; tlist: array_like; A NumPy array specifies the time of each coefficient. coeffs: array_like; A 2d NumPy array of the shape (len(ctrls), len(tlist)-1). Each; row corresponds to the control pulse sequence for; one Ha",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html:5577,Availability,error,error,5577,"gmax()]); # num_tslots and evo_time are two keyword arguments; tlist, coeffs = processor.load_circuit(; qc, num_tslots=num_tslots, evo_time=evo_time). Different parameters for different gates:. .. code-block:: python. qc = QubitCircuit(N=2); qc.add_gate(""SNOT"", 0); qc.add_gate(""SWAP"", targets=[0, 1]); qc.add_gate('CNOT', controls=1, targets=[0]). processor = OptPulseProcessor(N=2, drift=tensor([sigmaz()]*2)); processor.add_control(sigmax(), cyclic_permutation=True); processor.add_control(sigmay(), cyclic_permutation=True); processor.add_control(tensor([sigmay(), sigmay()])); setting_args = {""SNOT"": {""num_tslots"": 10, ""evo_time"": 1},; ""SWAP"": {""num_tslots"": 30, ""evo_time"": 3},; ""CNOT"": {""num_tslots"": 30, ""evo_time"": 3}}; tlist, coeffs = processor.load_circuit(qc,; setting_args=setting_args,; merge_gates=False). Parameters; ----------; qc: :class:`.QubitCircuit` or list of Qobj; The quantum circuit to be translated. min_fid_err: float, optional; The minimal fidelity tolerance, if the fidelity error of any; gate decomposition is higher, a warning will be given.; Default is infinite. merge_gates: boolean, optimal; If True, merge all gate/Qobj into one Qobj and then; find the optimal pulses for this unitary matrix. If False,; find the optimal pulses for each gate/Qobj. setting_args: dict, optional; Only considered if merge_gates is False.; It is a dictionary containing keyword arguments; for different gates. E.g.: ::. setting_args = {""SNOT"": {""num_tslots"": 10, ""evo_time"": 1},; ""SWAP"": {""num_tslots"": 30, ""evo_time"": 3},; ""CNOT"": {""num_tslots"": 30, ""evo_time"": 3}}. verbose: boolean, optional; If true, the information for each decomposed gate; will be shown. Default is False. **kwargs; keyword arguments for `qutip.control.optimize_pulse_unitary`. Returns; -------; tlist: array_like; A NumPy array specifies the time of each coefficient. coeffs: array_like; A 2d NumPy array of the shape (len(ctrls), len(tlist)-1). Each; row corresponds to the control pulse sequence for; one Ha",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html:7844,Availability,error,error,7844,", Iterable):; props = qc; gates = None # using list of Qobj, no gates name; else:; raise ValueError(; ""qc should be a ""; ""QubitCircuit or a list of Qobj""); if merge_gates: # merge all gates/Qobj into one Qobj; props = [gate_sequence_product(props)]; gates = None. time_record = [] # a list for all the gates; coeff_record = []; last_time = 0. # used in concatenation of tlist; for prop_ind, U_targ in enumerate(props):; U_0 = identity(U_targ.dims[0]). # If qc is a QubitCircuit and setting_args is not empty,; # we update the kwargs for each gate.; # keyword arguments in setting_arg have priority; if gates is not None and setting_args:; kwargs.update(setting_args[gates[prop_ind]]). full_drift_ham = self.drift.get_ideal_qobjevo(self.dims).cte; full_ctrls_hams = [pulse.get_ideal_qobj(self.dims); for pulse in self.pulses]; result = cpo.optimize_pulse_unitary(; full_drift_ham, full_ctrls_hams, U_0, U_targ, **kwargs). if result.fid_err > min_fid_err:; warnings.warn(; ""The fidelity error of gate {} is higher ""; ""than required limit. Use verbose=True to see""; ""the more detailed information."".format(prop_ind)). time_record.append(result.time[1:] + last_time); last_time += result.time[-1]; coeff_record.append(result.final_amps.T). if verbose:; print(""********** Gate {} **********"".format(prop_ind)); print(""Final fidelity error {}"".format(result.fid_err)); print(""Final gradient normal {}"".format(; result.grad_norm_final)); print(""Terminated due to {}"".format(result.termination_reason)); print(""Number of iterations {}"".format(result.num_iter)). tlist = np.hstack([[0.]] + time_record); for i in range(len(self.pulses)):; self.pulses[i].tlist = tlist; coeffs = np.vstack([np.hstack(coeff_record)]); self.coeffs = coeffs. return tlist, coeffs. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html:8187,Availability,error,error,8187," using list of Qobj, no gates name; else:; raise ValueError(; ""qc should be a ""; ""QubitCircuit or a list of Qobj""); if merge_gates: # merge all gates/Qobj into one Qobj; props = [gate_sequence_product(props)]; gates = None. time_record = [] # a list for all the gates; coeff_record = []; last_time = 0. # used in concatenation of tlist; for prop_ind, U_targ in enumerate(props):; U_0 = identity(U_targ.dims[0]). # If qc is a QubitCircuit and setting_args is not empty,; # we update the kwargs for each gate.; # keyword arguments in setting_arg have priority; if gates is not None and setting_args:; kwargs.update(setting_args[gates[prop_ind]]). full_drift_ham = self.drift.get_ideal_qobjevo(self.dims).cte; full_ctrls_hams = [pulse.get_ideal_qobj(self.dims); for pulse in self.pulses]; result = cpo.optimize_pulse_unitary(; full_drift_ham, full_ctrls_hams, U_0, U_targ, **kwargs). if result.fid_err > min_fid_err:; warnings.warn(; ""The fidelity error of gate {} is higher ""; ""than required limit. Use verbose=True to see""; ""the more detailed information."".format(prop_ind)). time_record.append(result.time[1:] + last_time); last_time += result.time[-1]; coeff_record.append(result.final_amps.T). if verbose:; print(""********** Gate {} **********"".format(prop_ind)); print(""Final fidelity error {}"".format(result.fid_err)); print(""Final gradient normal {}"".format(; result.grad_norm_final)); print(""Terminated due to {}"".format(result.termination_reason)); print(""Number of iterations {}"".format(result.num_iter)). tlist = np.hstack([[0.]] + time_record); for i in range(len(self.pulses)):; self.pulses[i].tlist = tlist; coeffs = np.vstack([np.hstack(coeff_record)]); self.coeffs = coeffs. return tlist, coeffs. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html:7374,Deployability,update,update,7374,"tlist: array_like; A NumPy array specifies the time of each coefficient. coeffs: array_like; A 2d NumPy array of the shape (len(ctrls), len(tlist)-1). Each; row corresponds to the control pulse sequence for; one Hamiltonian. Notes; -----; ``len(tlist) - 1 = coeffs.shape[1]`` since tlist gives the beginning; and the end of the pulses.; """"""; if setting_args is None:; setting_args = {}; if isinstance(qc, QubitCircuit):; props = qc.propagators(); gates = [g.name for g in qc.gates]; elif isinstance(qc, Iterable):; props = qc; gates = None # using list of Qobj, no gates name; else:; raise ValueError(; ""qc should be a ""; ""QubitCircuit or a list of Qobj""); if merge_gates: # merge all gates/Qobj into one Qobj; props = [gate_sequence_product(props)]; gates = None. time_record = [] # a list for all the gates; coeff_record = []; last_time = 0. # used in concatenation of tlist; for prop_ind, U_targ in enumerate(props):; U_0 = identity(U_targ.dims[0]). # If qc is a QubitCircuit and setting_args is not empty,; # we update the kwargs for each gate.; # keyword arguments in setting_arg have priority; if gates is not None and setting_args:; kwargs.update(setting_args[gates[prop_ind]]). full_drift_ham = self.drift.get_ideal_qobjevo(self.dims).cte; full_ctrls_hams = [pulse.get_ideal_qobj(self.dims); for pulse in self.pulses]; result = cpo.optimize_pulse_unitary(; full_drift_ham, full_ctrls_hams, U_0, U_targ, **kwargs). if result.fid_err > min_fid_err:; warnings.warn(; ""The fidelity error of gate {} is higher ""; ""than required limit. Use verbose=True to see""; ""the more detailed information."".format(prop_ind)). time_record.append(result.time[1:] + last_time); last_time += result.time[-1]; coeff_record.append(result.final_amps.T). if verbose:; print(""********** Gate {} **********"".format(prop_ind)); print(""Final fidelity error {}"".format(result.fid_err)); print(""Final gradient normal {}"".format(; result.grad_norm_final)); print(""Terminated due to {}"".format(result.termination_reason)); pri",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html:7505,Deployability,update,update,7505,"sponds to the control pulse sequence for; one Hamiltonian. Notes; -----; ``len(tlist) - 1 = coeffs.shape[1]`` since tlist gives the beginning; and the end of the pulses.; """"""; if setting_args is None:; setting_args = {}; if isinstance(qc, QubitCircuit):; props = qc.propagators(); gates = [g.name for g in qc.gates]; elif isinstance(qc, Iterable):; props = qc; gates = None # using list of Qobj, no gates name; else:; raise ValueError(; ""qc should be a ""; ""QubitCircuit or a list of Qobj""); if merge_gates: # merge all gates/Qobj into one Qobj; props = [gate_sequence_product(props)]; gates = None. time_record = [] # a list for all the gates; coeff_record = []; last_time = 0. # used in concatenation of tlist; for prop_ind, U_targ in enumerate(props):; U_0 = identity(U_targ.dims[0]). # If qc is a QubitCircuit and setting_args is not empty,; # we update the kwargs for each gate.; # keyword arguments in setting_arg have priority; if gates is not None and setting_args:; kwargs.update(setting_args[gates[prop_ind]]). full_drift_ham = self.drift.get_ideal_qobjevo(self.dims).cte; full_ctrls_hams = [pulse.get_ideal_qobj(self.dims); for pulse in self.pulses]; result = cpo.optimize_pulse_unitary(; full_drift_ham, full_ctrls_hams, U_0, U_targ, **kwargs). if result.fid_err > min_fid_err:; warnings.warn(; ""The fidelity error of gate {} is higher ""; ""than required limit. Use verbose=True to see""; ""the more detailed information."".format(prop_ind)). time_record.append(result.time[1:] + last_time); last_time += result.time[-1]; coeff_record.append(result.final_amps.T). if verbose:; print(""********** Gate {} **********"".format(prop_ind)); print(""Final fidelity error {}"".format(result.fid_err)); print(""Final gradient normal {}"".format(; result.grad_norm_final)); print(""Terminated due to {}"".format(result.termination_reason)); print(""Number of iterations {}"".format(result.num_iter)). tlist = np.hstack([[0.]] + time_record); for i in range(len(self.pulses)):; self.pulses[i].tlist = tlist; coeff",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html:8798,Deployability,update,updated,8798," using list of Qobj, no gates name; else:; raise ValueError(; ""qc should be a ""; ""QubitCircuit or a list of Qobj""); if merge_gates: # merge all gates/Qobj into one Qobj; props = [gate_sequence_product(props)]; gates = None. time_record = [] # a list for all the gates; coeff_record = []; last_time = 0. # used in concatenation of tlist; for prop_ind, U_targ in enumerate(props):; U_0 = identity(U_targ.dims[0]). # If qc is a QubitCircuit and setting_args is not empty,; # we update the kwargs for each gate.; # keyword arguments in setting_arg have priority; if gates is not None and setting_args:; kwargs.update(setting_args[gates[prop_ind]]). full_drift_ham = self.drift.get_ideal_qobjevo(self.dims).cte; full_ctrls_hams = [pulse.get_ideal_qobj(self.dims); for pulse in self.pulses]; result = cpo.optimize_pulse_unitary(; full_drift_ham, full_ctrls_hams, U_0, U_targ, **kwargs). if result.fid_err > min_fid_err:; warnings.warn(; ""The fidelity error of gate {} is higher ""; ""than required limit. Use verbose=True to see""; ""the more detailed information."".format(prop_ind)). time_record.append(result.time[1:] + last_time); last_time += result.time[-1]; coeff_record.append(result.final_amps.T). if verbose:; print(""********** Gate {} **********"".format(prop_ind)); print(""Final fidelity error {}"".format(result.fid_err)); print(""Final gradient normal {}"".format(; result.grad_norm_final)); print(""Terminated due to {}"".format(result.termination_reason)); print(""Number of iterations {}"".format(result.num_iter)). tlist = np.hstack([[0.]] + time_record); for i in range(len(self.pulses)):; self.pulses[i].tlist = tlist; coeffs = np.vstack([np.hstack(coeff_record)]); self.coeffs = coeffs. return tlist, coeffs. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html:2793,Performance,optimiz,optimized,2793,"SINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections.abc import Iterable; import warnings; import numbers. import numpy as np. from qutip.qobj import Qobj; import qutip.control.pulseoptim as cpo; from qutip.operators import identity; from qutip.tensor import tensor; from qutip.mesolve import mesolve; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device.processor import Processor; from qutip.qip.operations.gates import gate_sequence_product. __all__ = ['OptPulseProcessor']. [docs]class OptPulseProcessor(Processor):; """"""; A processor, which takes the Hamiltonian available; as dynamic generators, calls the; `qutip.control.optimize_pulse_unitary` function; to find an optimized pulse sequence for the desired quantum circuit.; The processor can simulate the evolution under the given; control pulses using :func:`qutip.mesolve`.; (For attributes documentation, please; refer to the parent class :class:`.Processor`). Parameters; ----------; N: int; The number of component systems. drift: `:class:`qutip.Qobj`; The drift Hamiltonian. The size must match the whole quantum system. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. dims: list; The dimension of each component system.; Default value is a; qubit system of ``dim=[2,2,2,...,2]``; """"""; def __init__(self, N, drift=None, t1=None, t2=None, dims=None):; super(OptPulseProcessor, self).__init__(; N, t1=t1, t2=t2, dims=dims); if drift is not None:; self.add_drift(drift, list(range(N))); self.spline_kind = ""ste",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html:2939,Availability,avail,available,2939,"OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections.abc import Iterable; import warnings; from copy import deepcopy. import numpy as np; from scipy.interpolate import CubicSpline. from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.operators import identity; from qutip.qip.operations.gates import expand_operator, globalphase; from qutip.tensor import tensor; from qutip.mesolve import mesolve; from qutip.mcsolve import mcsolve; from qutip.qip.circuit import QubitCircuit; from qutip.qip.noise import (; Noise, RelaxationNoise, DecoherenceNoise,; ControlAmpNoise, RandomNoise, process_noise); from qutip.qip.pulse import Pulse, Drift, _merge_qobjevo, _fill_coeff. __all__ = ['Processor']. [docs]class Processor(object):; """"""; A simulator of a quantum device based on the QuTiP solver; :func:`qutip.mesolve`. It is defined by the available driving Hamiltonian; and the decoherence time for each component systems. The processor can; simulate the evolution under the given control pulses. Noisy evolution is; supported by :class:`.Noise` and can be added to the processor. Parameters; ----------; N: int; The number of component systems. t1: list or float, optional; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float, optional; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. dims: list, optional; The dimension of each component system.; Default value is a; qubit system of ``dim=[2,2,2,...,2]``. spline_kind: str, optional; Type of the coefficient interpolation. Default is ""step_func""; Note that they have different requirement for the length of ``coeff``. - ""step_func"":; The coefficient will be treated as a step function. E.g.; ``tlist=[0,1,2]`` and ``coeff=[3,2]``, means that the coefficient is; 3 in t=[0,1) and 2 i",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html:8823,Deployability,continuous,continuous,8823,"f.pulse_dict[pulse_name]]; except (KeyError):; raise KeyError(; ""Pulse name {} undefined. ""; ""Please define it in the attribute ""; ""`pulse_dict`."".format(pulse_name)); elif isinstance(pulse_name, int):; return self.pulses[pulse_name]; else:; raise TypeError(; ""pulse_name is either a string or an integer, not ""; ""{}"".format(type(pulse_name)); ). @property; def ctrls(self):; """"""; A list of Hamiltonians of all pulses.; """"""; result = []; for pulse in self.pulses:; result.append(pulse.get_ideal_qobj(self.dims)); return result. @property; def coeffs(self):; """"""; A list of the coefficients for all control pulses.; """"""; if not self.pulses:; return None; coeffs_list = [pulse.coeff for pulse in self.pulses]; return coeffs_list. @coeffs.setter; def coeffs(self, coeffs_list):; for i, coeff in enumerate(coeffs_list):; self.pulses[i].coeff = coeff. @property; def pulse_mode(self):; if self.spline_kind == ""step_func"":; return ""discrete""; elif self.spline_kind == ""cubic"":; return ""continuous""; else:; raise ValueError(; ""Saved spline_kind not understood.""). @pulse_mode.setter; def pulse_mode(self, mode):; if mode == ""discrete"":; spline_kind = ""step_func""; elif mode == ""continuous"":; spline_kind = ""cubic""; else:; raise ValueError(; ""Pulse mode must be either discrete or continuous.""). self.spline_kind = spline_kind; for pulse in self.pulses:; pulse.spline_kind = spline_kind. [docs] def get_full_tlist(self, tol=1.0e-10):; """"""; Return the full tlist of the ideal pulses.; If different pulses have different time steps,; it will collect all the time steps in a sorted array. Returns; -------; full_tlist: array-like 1d; The full time sequence for the ideal evolution.; """"""; full_tlist = [pulse.tlist; for pulse in self.pulses if pulse.tlist is not None]; if not full_tlist:; return None; full_tlist = np.unique(np.sort(np.hstack(full_tlist))); # account for inaccuracy in float-point number; full_tlist = np.concatenate(; (full_tlist[:1], full_tlist[1:][np.diff(full_tlist) > tol])); return full_t",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html:9014,Deployability,continuous,continuous,9014,"nstance(pulse_name, int):; return self.pulses[pulse_name]; else:; raise TypeError(; ""pulse_name is either a string or an integer, not ""; ""{}"".format(type(pulse_name)); ). @property; def ctrls(self):; """"""; A list of Hamiltonians of all pulses.; """"""; result = []; for pulse in self.pulses:; result.append(pulse.get_ideal_qobj(self.dims)); return result. @property; def coeffs(self):; """"""; A list of the coefficients for all control pulses.; """"""; if not self.pulses:; return None; coeffs_list = [pulse.coeff for pulse in self.pulses]; return coeffs_list. @coeffs.setter; def coeffs(self, coeffs_list):; for i, coeff in enumerate(coeffs_list):; self.pulses[i].coeff = coeff. @property; def pulse_mode(self):; if self.spline_kind == ""step_func"":; return ""discrete""; elif self.spline_kind == ""cubic"":; return ""continuous""; else:; raise ValueError(; ""Saved spline_kind not understood.""). @pulse_mode.setter; def pulse_mode(self, mode):; if mode == ""discrete"":; spline_kind = ""step_func""; elif mode == ""continuous"":; spline_kind = ""cubic""; else:; raise ValueError(; ""Pulse mode must be either discrete or continuous.""). self.spline_kind = spline_kind; for pulse in self.pulses:; pulse.spline_kind = spline_kind. [docs] def get_full_tlist(self, tol=1.0e-10):; """"""; Return the full tlist of the ideal pulses.; If different pulses have different time steps,; it will collect all the time steps in a sorted array. Returns; -------; full_tlist: array-like 1d; The full time sequence for the ideal evolution.; """"""; full_tlist = [pulse.tlist; for pulse in self.pulses if pulse.tlist is not None]; if not full_tlist:; return None; full_tlist = np.unique(np.sort(np.hstack(full_tlist))); # account for inaccuracy in float-point number; full_tlist = np.concatenate(; (full_tlist[:1], full_tlist[1:][np.diff(full_tlist) > tol])); return full_tlist. [docs] def get_full_coeffs(self, full_tlist=None):; """"""; Return the full coefficients in a 2d matrix form.; Each row corresponds to one pulse. If the `tlist` are; differen",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html:9116,Deployability,continuous,continuous,9116,"nstance(pulse_name, int):; return self.pulses[pulse_name]; else:; raise TypeError(; ""pulse_name is either a string or an integer, not ""; ""{}"".format(type(pulse_name)); ). @property; def ctrls(self):; """"""; A list of Hamiltonians of all pulses.; """"""; result = []; for pulse in self.pulses:; result.append(pulse.get_ideal_qobj(self.dims)); return result. @property; def coeffs(self):; """"""; A list of the coefficients for all control pulses.; """"""; if not self.pulses:; return None; coeffs_list = [pulse.coeff for pulse in self.pulses]; return coeffs_list. @coeffs.setter; def coeffs(self, coeffs_list):; for i, coeff in enumerate(coeffs_list):; self.pulses[i].coeff = coeff. @property; def pulse_mode(self):; if self.spline_kind == ""step_func"":; return ""discrete""; elif self.spline_kind == ""cubic"":; return ""continuous""; else:; raise ValueError(; ""Saved spline_kind not understood.""). @pulse_mode.setter; def pulse_mode(self, mode):; if mode == ""discrete"":; spline_kind = ""step_func""; elif mode == ""continuous"":; spline_kind = ""cubic""; else:; raise ValueError(; ""Pulse mode must be either discrete or continuous.""). self.spline_kind = spline_kind; for pulse in self.pulses:; pulse.spline_kind = spline_kind. [docs] def get_full_tlist(self, tol=1.0e-10):; """"""; Return the full tlist of the ideal pulses.; If different pulses have different time steps,; it will collect all the time steps in a sorted array. Returns; -------; full_tlist: array-like 1d; The full time sequence for the ideal evolution.; """"""; full_tlist = [pulse.tlist; for pulse in self.pulses if pulse.tlist is not None]; if not full_tlist:; return None; full_tlist = np.unique(np.sort(np.hstack(full_tlist))); # account for inaccuracy in float-point number; full_tlist = np.concatenate(; (full_tlist[:1], full_tlist[1:][np.diff(full_tlist) > tol])); return full_tlist. [docs] def get_full_coeffs(self, full_tlist=None):; """"""; Return the full coefficients in a 2d matrix form.; Each row corresponds to one pulse. If the `tlist` are; differen",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html:17267,Deployability,update,update,17267,"d `get_noisy_pulses` and create the `QobjEvo`; from it. Parameters; ----------; args: dict, optional; Arguments for :class:`qutip.QobjEvo`; noisy: bool, optional; If noise are included. Default is False. Returns; -------; qobjevo: :class:`qutip.QobjEvo`; The :class:`qutip.QobjEvo` representation of the unitary evolution.; c_ops: list of :class:`qutip.QobjEvo`; A list of lindblad operators is also returned. if ``noisy==Flase``,; it is always an empty list.; """"""; # TODO test it for non array-like coeff; # check validity; self._is_pulses_valid(). if args is None:; args = {}; else:; args = args; # set step function. if not noisy:; dynamics = self.pulses; else:; dynamics = self.get_noisy_pulses(; device_noise=True, drift=True). qu_list = []; c_ops = []; for pulse in dynamics:; if noisy:; qu, new_c_ops = pulse.get_noisy_qobjevo(dims=self.dims); c_ops += new_c_ops; else:; qu = pulse.get_ideal_qobjevo(dims=self.dims); qu_list.append(qu). final_qu = _merge_qobjevo(qu_list); final_qu.args.update(args). # bring all c_ops to the same tlist, won't need it in QuTiP 5; full_tlist = self.get_full_tlist(); temp = []; for c_op in c_ops:; temp.append(_merge_qobjevo([c_op], full_tlist)); c_ops = temp. if noisy:; return final_qu, c_ops; else:; return final_qu, []. [docs] def run_analytically(self, init_state=None, qc=None):; """"""; Simulate the state evolution under the given `qutip.QubitCircuit`; with matrice exponentiation. It will calculate the propagator; with matrix exponentiation and return a list of :class:`qutip.Qobj`.; This method won't include noise or collpase. Parameters; ----------; qc: :class:`.QubitCircuit`, optional; Takes the quantum circuit to be implemented. If not given, use; the quantum circuit saved in the processor by ``load_circuit``. init_state: :class:`qutip.Qobj`, optional; The initial state of the qubits in the register. Returns; -------; U_list: list; A list of propagators obtained for the physical implementation.; """"""; if init_state is not None:; U_list = [ini",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html:23689,Deployability,update,update,23689,"t_pulses(; self, title=None, figsize=(12, 6), dpi=None,; show_axis=False, rescale_pulse_coeffs=True,; num_steps=1000):; """"""; Plot the ideal pulse coefficients. Parameters; ----------; title: str, optional; Title for the plot. figsize: tuple, optional; The size of the figure. dpi: int, optional; The dpi of the figure. show_axis: bool, optional; If the axis are shown. rescale_pulse_coeffs: bool, optional; Rescale the hight of each pulses. num_steps: int, optional; Number of time steps in the plot. Returns; -------; fig: matplotlib.figure.Figure; The `Figure` object for the plot. ax: matplotlib.axes._subplots.AxesSubplot; The axes for the plot. Notes; -----; ``plot_pulses`` only works for array_like coefficients; """"""; import matplotlib.pyplot as plt; import matplotlib.gridspec as gridspec; color_list = plt.rcParams['axes.prop_cycle'].by_key()['color']. # create a axis for each pulse; fig = plt.figure(figsize=figsize, dpi=dpi); grids = gridspec.GridSpec(len(self.pulses), 1); grids.update(wspace=0., hspace=0.). tlist = np.linspace(0., self.get_full_tlist()[-1], num_steps); dt = tlist[1] - tlist[0]. # make sure coeffs start and end with zero, for ax.fill; tlist = np.hstack(([-dt*1.e-20], tlist, [tlist[-1] + dt*1.e-20])); coeffs = []; for pulse in self.pulses:; coeffs.append(_pulse_interpolate(pulse, tlist)). pulse_ind = 0; axis = []; for i, label_group in enumerate(self.get_operators_labels()):; for j, label in enumerate(label_group):; grid = grids[pulse_ind]; ax = plt.subplot(grid); axis.append(ax); ax.fill(tlist, coeffs[pulse_ind], color_list[i], alpha=0.7); ax.plot(tlist, coeffs[pulse_ind], color_list[i]); if rescale_pulse_coeffs:; ymax = np.max(np.abs(coeffs[pulse_ind])) * 1.1; else:; ymax = np.max(np.abs(coeffs)) * 1.1; if ymax != 0.:; ax.set_ylim((-ymax, ymax)). # disable frame and ticks; if not show_axis:; ax.set_xticks([]); ax.spines['bottom'].set_visible(False); ax.spines['top'].set_visible(False); ax.spines['right'].set_visible(False); ax.spines['left'].set_visi",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html:25765,Deployability,update,updated,25765,"list = np.hstack(([-dt*1.e-20], tlist, [tlist[-1] + dt*1.e-20])); coeffs = []; for pulse in self.pulses:; coeffs.append(_pulse_interpolate(pulse, tlist)). pulse_ind = 0; axis = []; for i, label_group in enumerate(self.get_operators_labels()):; for j, label in enumerate(label_group):; grid = grids[pulse_ind]; ax = plt.subplot(grid); axis.append(ax); ax.fill(tlist, coeffs[pulse_ind], color_list[i], alpha=0.7); ax.plot(tlist, coeffs[pulse_ind], color_list[i]); if rescale_pulse_coeffs:; ymax = np.max(np.abs(coeffs[pulse_ind])) * 1.1; else:; ymax = np.max(np.abs(coeffs)) * 1.1; if ymax != 0.:; ax.set_ylim((-ymax, ymax)). # disable frame and ticks; if not show_axis:; ax.set_xticks([]); ax.spines['bottom'].set_visible(False); ax.spines['top'].set_visible(False); ax.spines['right'].set_visible(False); ax.spines['left'].set_visible(False); ax.set_yticks([]); ax.set_ylabel(label, rotation=0); pulse_ind += 1; if i == 0 and j == 0 and title is not None:; ax.set_title(title); fig.tight_layout(); return fig, axis. def _pulse_interpolate(pulse, tlist):; """"""; A function that calls Scipy interpolation routine. Used for plotting.; """"""; if pulse.tlist is None and pulse.coeff is None:; coeff = np.zeros(len(tlist)); return coeff; if isinstance(pulse.coeff, bool):; if pulse.coeff:; coeff = np.ones(len(tlist)); else:; coeff = np.zeros(len(tlist)); return coeff; coeff = pulse.coeff; if len(coeff) == len(pulse.tlist)-1: # for discrete pulse; coeff = np.concatenate([coeff, [0]]). from scipy import interpolate; if pulse.spline_kind == ""step_func"":; kind = ""previous""; else:; kind = ""cubic""; inter = interpolate.interp1d(; pulse.tlist, coeff, kind=kind,; bounds_error=False, fill_value=0.0); return inter(tlist). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html:11430,Integrability,depend,dependent,11430,"); if full_tlist is None:; full_tlist = self.get_full_tlist(); coeffs_list = []; for pulse in self.pulses:; if pulse.tlist is None and pulse.coeff is None:; coeffs_list.append(np.zeros(len(full_tlist))); continue; if not isinstance(pulse.coeff, (bool, np.ndarray)):; raise ValueError(; ""get_full_coeffs only works for ""; ""NumPy array or bool coeff.""); if isinstance(pulse.coeff, bool):; if pulse.coeff:; coeffs_list.append(np.ones(len(full_tlist))); else:; coeffs_list.append(np.zeros(len(full_tlist))); continue; if self.spline_kind == ""step_func"":; arg = {""_step_func_coeff"": True}; coeffs_list.append(; _fill_coeff(pulse.coeff, pulse.tlist, full_tlist, arg)); elif self.spline_kind == ""cubic"":; coeffs_list.append(; _fill_coeff(pulse.coeff, pulse.tlist, full_tlist, {})); else:; raise ValueError(""Unknown spline kind.""); return np.array(coeffs_list). [docs] def set_all_tlist(self, tlist):; """"""; Set the same `tlist` for all the pulses. Parameters; ----------; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied. See :class:`.Pulse` for detailed information`; """"""; if isinstance(tlist, list) and len(tlist) == len(self.pulses):; for i, pulse in enumerate(self.pulses):; pulse.tlist = tlist[i]; else:; for pulse in self.pulses:; pulse.tlist = tlist. [docs] def add_pulse(self, pulse):; """"""; Add a new pulse to the device. Parameters; ----------; pulse: :class:`.Pulse`; `Pulse` object to be added.; """"""; if isinstance(pulse, Pulse):; if pulse.spline_kind is None:; pulse.spline_kind = self.spline_kind; self.pulses.append(pulse); else:; raise ValueError(""Invalid input, pulse must be a Pulse object""). [docs] def remove_pulse(self, indices=None, label=None):; """"""; Remove the control pulse with given indices. Parameters; ----------; indices: int or list of int; The indices of the control Hamiltonians to be removed.; label: str; The label of the pulse; """"""; if indices is not None:; if not isinstance(indices, Iterable):; indices = [indices]; indices",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html:24968,Integrability,rout,routine,24968,"list = np.hstack(([-dt*1.e-20], tlist, [tlist[-1] + dt*1.e-20])); coeffs = []; for pulse in self.pulses:; coeffs.append(_pulse_interpolate(pulse, tlist)). pulse_ind = 0; axis = []; for i, label_group in enumerate(self.get_operators_labels()):; for j, label in enumerate(label_group):; grid = grids[pulse_ind]; ax = plt.subplot(grid); axis.append(ax); ax.fill(tlist, coeffs[pulse_ind], color_list[i], alpha=0.7); ax.plot(tlist, coeffs[pulse_ind], color_list[i]); if rescale_pulse_coeffs:; ymax = np.max(np.abs(coeffs[pulse_ind])) * 1.1; else:; ymax = np.max(np.abs(coeffs)) * 1.1; if ymax != 0.:; ax.set_ylim((-ymax, ymax)). # disable frame and ticks; if not show_axis:; ax.set_xticks([]); ax.spines['bottom'].set_visible(False); ax.spines['top'].set_visible(False); ax.spines['right'].set_visible(False); ax.spines['left'].set_visible(False); ax.set_yticks([]); ax.set_ylabel(label, rotation=0); pulse_ind += 1; if i == 0 and j == 0 and title is not None:; ax.set_title(title); fig.tight_layout(); return fig, axis. def _pulse_interpolate(pulse, tlist):; """"""; A function that calls Scipy interpolation routine. Used for plotting.; """"""; if pulse.tlist is None and pulse.coeff is None:; coeff = np.zeros(len(tlist)); return coeff; if isinstance(pulse.coeff, bool):; if pulse.coeff:; coeff = np.ones(len(tlist)); else:; coeff = np.zeros(len(tlist)); return coeff; coeff = pulse.coeff; if len(coeff) == len(pulse.tlist)-1: # for discrete pulse; coeff = np.concatenate([coeff, [0]]). from scipy import interpolate; if pulse.spline_kind == ""step_func"":; kind = ""previous""; else:; kind = ""cubic""; inter = interpolate.interp1d(; pulse.tlist, coeff, kind=kind,; bounds_error=False, fill_value=0.0); return inter(tlist). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html:14977,Performance,load,loadtxt,14977,"_name, inctime=True):; """"""; Save a file with the control amplitudes in each timeslot. Parameters; ----------; file_name: string; Name of the file. inctime: bool, optional; True if the time list should be included in the first column.; """"""; self._is_pulses_valid(); coeffs = np.array(self.get_full_coeffs()); if inctime:; shp = coeffs.T.shape; data = np.empty((shp[0], shp[1] + 1), dtype=np.float64); data[:, 0] = self.get_full_tlist(); data[:, 1:] = coeffs.T; else:; data = coeffs.T. np.savetxt(file_name, data, delimiter='\t', fmt='%1.16f'). [docs] def read_coeff(self, file_name, inctime=True):; """"""; Read the control amplitudes matrix and time list; saved in the file by `save_amp`. Parameters; ----------; file_name: string; Name of the file. inctime: bool, optional; True if the time list in included in the first column. Returns; -------; tlist: array_like; The time list read from the file. coeffs: array_like; The pulse matrix read from the file.; """"""; data = np.loadtxt(file_name, delimiter='\t'); if not inctime:; self.coeffs = data.T; return self.coeffs; else:; tlist = data[:, 0]; self.set_all_tlist(tlist); self.coeffs = data[:, 1:].T; return self.get_full_tlist, self.coeffs. [docs] def get_noisy_pulses(self, device_noise=False, drift=False):; """"""; It takes the pulses defined in the `Processor` and; adds noise according to `Processor.noise`. It does not modify the; pulses saved in `Processor.pulses` but returns a new list.; The length of the new list of noisy pulses might be longer; because of drift Hamiltonian and device noise. They will be; added to the end of the pulses list. Parameters; ----------; device_noise: bool, optional; If true, include pulse independent noise such as single qubit; Relaxation. Default is False.; drift: bool, optional; If true, include drift Hamiltonians. Default is False. Returns; -------; noisy_pulses: list of :class:`.Pulse`; A list of noisy pulses.; """"""; pulses = deepcopy(self.pulses); noisy_pulses = process_noise(; pulses, self.noise, sel",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html:10316,Testability,test,tests,10316,"ses.; If different pulses have different time steps,; it will collect all the time steps in a sorted array. Returns; -------; full_tlist: array-like 1d; The full time sequence for the ideal evolution.; """"""; full_tlist = [pulse.tlist; for pulse in self.pulses if pulse.tlist is not None]; if not full_tlist:; return None; full_tlist = np.unique(np.sort(np.hstack(full_tlist))); # account for inaccuracy in float-point number; full_tlist = np.concatenate(; (full_tlist[:1], full_tlist[1:][np.diff(full_tlist) > tol])); return full_tlist. [docs] def get_full_coeffs(self, full_tlist=None):; """"""; Return the full coefficients in a 2d matrix form.; Each row corresponds to one pulse. If the `tlist` are; different for different pulses, the length of each row; will be same as the `full_tlist` (see method; `get_full_tlist`). Interpolation is used for; adding the missing coefficient according to `spline_kind`. Returns; -------; coeffs: array-like 2d; The coefficients for all ideal pulses.; """"""; # TODO add tests; self._is_pulses_valid(); if not self.pulses:; return np.array((0, 0), dtype=float); if full_tlist is None:; full_tlist = self.get_full_tlist(); coeffs_list = []; for pulse in self.pulses:; if pulse.tlist is None and pulse.coeff is None:; coeffs_list.append(np.zeros(len(full_tlist))); continue; if not isinstance(pulse.coeff, (bool, np.ndarray)):; raise ValueError(; ""get_full_coeffs only works for ""; ""NumPy array or bool coeff.""); if isinstance(pulse.coeff, bool):; if pulse.coeff:; coeffs_list.append(np.ones(len(full_tlist))); else:; coeffs_list.append(np.zeros(len(full_tlist))); continue; if self.spline_kind == ""step_func"":; arg = {""_step_func_coeff"": True}; coeffs_list.append(; _fill_coeff(pulse.coeff, pulse.tlist, full_tlist, arg)); elif self.spline_kind == ""cubic"":; coeffs_list.append(; _fill_coeff(pulse.coeff, pulse.tlist, full_tlist, {})); else:; raise ValueError(""Unknown spline kind.""); return np.array(coeffs_list). [docs] def set_all_tlist(self, tlist):; """"""; Set the sa",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html:16746,Testability,test,test,16746," optional; If true, include drift Hamiltonians. Default is False. Returns; -------; noisy_pulses: list of :class:`.Pulse`; A list of noisy pulses.; """"""; pulses = deepcopy(self.pulses); noisy_pulses = process_noise(; pulses, self.noise, self.dims, t1=self.t1, t2=self.t2,; device_noise=device_noise); if drift:; noisy_pulses += [self.drift]; return noisy_pulses. [docs] def get_qobjevo(self, args=None, noisy=False):; """"""; Create a :class:`qutip.QobjEvo` representation of the evolution.; It calls the method `get_noisy_pulses` and create the `QobjEvo`; from it. Parameters; ----------; args: dict, optional; Arguments for :class:`qutip.QobjEvo`; noisy: bool, optional; If noise are included. Default is False. Returns; -------; qobjevo: :class:`qutip.QobjEvo`; The :class:`qutip.QobjEvo` representation of the unitary evolution.; c_ops: list of :class:`qutip.QobjEvo`; A list of lindblad operators is also returned. if ``noisy==Flase``,; it is always an empty list.; """"""; # TODO test it for non array-like coeff; # check validity; self._is_pulses_valid(). if args is None:; args = {}; else:; args = args; # set step function. if not noisy:; dynamics = self.pulses; else:; dynamics = self.get_noisy_pulses(; device_noise=True, drift=True). qu_list = []; c_ops = []; for pulse in dynamics:; if noisy:; qu, new_c_ops = pulse.get_noisy_qobjevo(dims=self.dims); c_ops += new_c_ops; else:; qu = pulse.get_ideal_qobjevo(dims=self.dims); qu_list.append(qu). final_qu = _merge_qobjevo(qu_list); final_qu.args.update(args). # bring all c_ops to the same tlist, won't need it in QuTiP 5; full_tlist = self.get_full_tlist(); temp = []; for c_op in c_ops:; temp.append(_merge_qobjevo([c_op], full_tlist)); c_ops = temp. if noisy:; return final_qu, c_ops; else:; return final_qu, []. [docs] def run_analytically(self, init_state=None, qc=None):; """"""; Simulate the state evolution under the given `qutip.QubitCircuit`; with matrice exponentiation. It will calculate the propagator; with matrix exponentiation and ret",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html:2657,Availability,avail,available,2657,"LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from copy import deepcopy. import numpy as np. from qutip.operators import sigmax, sigmay, sigmaz; from qutip.tensor import tensor; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device.modelprocessor import ModelProcessor; from qutip.qip.pulse import Pulse; from qutip.qip.compiler.spinchaincompiler import SpinChainCompiler. __all__ = ['SpinChain', 'LinearSpinChain', 'CircularSpinChain']. [docs]class SpinChain(ModelProcessor):; """"""; The processor based on the physical implementation of; a spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It is a base class and should not be used directly, please; refer the the subclasses :class:`qutip.qip.device.LinearSpinChain` and; :class:`qutip.qip.device.CircularSpinChain`.; (Only additional attributes are documented here, for others please; refer to the parent class :class:`.ModelProcessor`). Parameters; ----------; N: int; The number of qubits in the system. correct_global_phase: float; Save the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or list; The delta for each of the qubits in the system. sz: int or list; The epsilon for each of the qubits in the system. sxsy: int or list; The interaction strength for each of the qubit pair in the system. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/spinchain.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html:13823,Availability,avail,available,13823,"e.targets[1]) % N]); else:; qc_t.add_gate(gate.name,; [(end + gate.targets[0]) % N,; (end + gate.targets[1]) % N]); j = j + 1. else:; qc_t.add_gate(gate.name, gate.targets, gate.controls,; gate.arg_value, gate.arg_label). return qc_t. [docs] def eliminate_auxillary_modes(self, U):; return U. [docs] def optimize_circuit(self, qc):; """"""; Take a quantum circuit/algorithm and convert it into the; optimal form/basis for the desired physical system. Parameters; ----------; qc: :class:`.QubitCircuit`; Takes the quantum circuit to be implemented. Returns; -------; qc: :class:`.QubitCircuit`; The circuit representation with elementary gates; that can be implemented in this model.; """"""; self.qc0 = qc; self.qc1 = self.adjacent_gates(self.qc0); self.qc2 = self.qc1.resolve_gates(; basis=[""SQRTISWAP"", ""ISWAP"", ""RX"", ""RZ""]); return self.qc2. [docs]class LinearSpinChain(SpinChain):; """"""; A processor based on the physical implementation of; a linear spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters; ----------; N: int; The number of qubits in the system. correct_global_phase: float; Save the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or list; The delta for each of the qubits in the system. sz: int or list; The epsilon for each of the qubits in the system. sxsy: int or list; The interaction strength for each of the qubit pair in the system. t1: list or float, optional; Characterize the decoherence of amplitude damping for; each qubit. t2: list of float, optional; Characterize the decoherence of dephasing for; each qubit.; """"""; def __init__(self, N, correct_global_phase=True,; sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None):. super(LinearSpinChain, self).__init__(; N, correct_global_phase=correct_global_phase,; sx=sx, sz=sz, sxsy=sxsy, t1=t1, t2=t2); self.set_u",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/spinchain.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html:16221,Availability,avail,available,16221,".ctrls[2*self.N: 3*self.N-1]. @property; def sxsy_u(self):; return self.coeffs[2*self.N: 3*self.N-1]. [docs] def load_circuit(; self, qc, schedule_mode=""ASAP"", compiler=None):; return super(LinearSpinChain, self).load_circuit(; qc, ""linear"", schedule_mode=schedule_mode, compiler=compiler). [docs] def get_operators_labels(self):; """"""; Get the labels for each Hamiltonian.; It is used in the method``plot_pulses``.; It is a 2-d nested list, in the plot,; a different color will be used for each sublist.; """"""; return ([[r""$\sigma_x^%d$"" % n for n in range(self.N)],; [r""$\sigma_z^%d$"" % n for n in range(self.N)],; [r""$\sigma_x^%d\sigma_x^{%d} + \sigma_y^%d\sigma_y^{%d}$""; % (n, n + 1, n, n + 1) for n in range(self.N - 1)],; ]). [docs] def adjacent_gates(self, qc):; return super(LinearSpinChain, self).adjacent_gates(qc, ""linear""). [docs]class CircularSpinChain(SpinChain):; """"""; A processor based on the physical implementation of; a circular spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters; ----------; N: int; The number of qubits in the system. correct_global_phase: float; Save the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or list; The delta for each of the qubits in the system. sz: int or list; The epsilon for each of the qubits in the system. sxsy: int or list; The interaction strength for each of the qubit pair in the system. t1: list or float, optional; Characterize the decoherence of amplitude damping for; each qubit. t2: list of float, optional; Characterize the decoherence of dephasing for; each qubit.; """"""; def __init__(self, N, correct_global_phase=True,; sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None):; if N <= 1:; raise ValueError(; ""Circuit spin chain must have at least 2 qubits. ""; ""The number of qubits is increased to 2.""); super(Circ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/spinchain.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html:19022,Deployability,update,updated,19022," ValueError(; ""Circuit spin chain must have at least 2 qubits. ""; ""The number of qubits is increased to 2.""); super(CircularSpinChain, self).__init__(; N, correct_global_phase=correct_global_phase,; sx=sx, sz=sz, sxsy=sxsy, t1=t1, t2=t2); self.set_up_params(sx=sx, sz=sz, sxsy=sxsy); self.set_up_ops(N). [docs] def set_up_ops(self, N):; super(CircularSpinChain, self).set_up_ops(N); operator = tensor([sigmax(), sigmax()]) + tensor([sigmay(), sigmay()]); self.pulses.append(; Pulse(operator, [N-1, 0], spline_kind=self.spline_kind)); self.pulse_dict[""g"" + str(N-1)] = len(self.pulses) - 1. [docs] def set_up_params(self, sx, sz, sxsy):; # Doc same as in the parent class; super(CircularSpinChain, self).set_up_params(sx, sz); sxsy_para = 2 * np.pi * self.to_array(sxsy, self.N); self._params[""sxsy""] = sxsy_para. @property; def sxsy_ops(self):; return self.ctrls[2*self.N: 3*self.N]. @property; def sxsy_u(self):; return self.coeffs[2*self.N: 3*self.N]. [docs] def load_circuit(; self, qc, schedule_mode=""ASAP"", compiler=None):; return super(CircularSpinChain, self).load_circuit(; qc, ""circular"", schedule_mode=schedule_mode, compiler=compiler). [docs] def get_operators_labels(self):; """"""; Get the labels for each Hamiltonian.; It is used in the method``plot_pulses``.; It is a 2-d nested list, in the plot,; a different color will be used for each sublist.; """"""; return ([[r""$\sigma_x^%d$"" % n for n in range(self.N)],; [r""$\sigma_z^%d$"" % n for n in range(self.N)],; [r""$\sigma_x^%d\sigma_x^{%d} + \sigma_y^%d\sigma_y^{%d}$""; % (n, (n + 1) % self.N, n, (n + 1) % self.N); for n in range(self.N)]]). [docs] def adjacent_gates(self, qc):; return super(CircularSpinChain, self).adjacent_gates(qc, ""circular""). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/spinchain.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html:5764,Modifiability,coupling,coupling,5764," the spinchain model and save them in the; attribute `ctrls`. Parameters; ----------; N: int; The number of qubits in the system.; """"""; self.pulse_dict = {}; index = 0; # sx_ops; for m in range(N):; self.pulses.append(; Pulse(sigmax(), m, spline_kind=self.spline_kind)); self.pulse_dict[""sx"" + str(m)] = index; index += 1; # sz_ops; for m in range(N):; self.pulses.append(; Pulse(sigmaz(), m, spline_kind=self.spline_kind)); self.pulse_dict[""sz"" + str(m)] = index; index += 1; # sxsy_ops; operator = tensor([sigmax(), sigmax()]) + tensor([sigmay(), sigmay()]); for n in range(N - 1):; self.pulses.append(; Pulse(operator, [n, n+1], spline_kind=self.spline_kind)); self.pulse_dict[""g"" + str(n)] = index; index += 1. [docs] def set_up_params(self, sx, sz):; """"""; Save the parameters in the attribute `params` and check the validity.; The keys of `params` including ""sx"", ""sz"", and ""sxsy"", each; mapped to a list for parameters corresponding to each qubits.; For coupling strength ""sxsy"", list element i is the interaction; between qubits i and i+1. Parameters; ----------; sx: float or list; The coefficient of sigmax in the model. sz: flaot or list; The coefficient of sigmaz in the model. Notes; -----; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity; """"""; sx_para = 2 * np.pi * self.to_array(sx, self.N); self._params[""sx""] = sx_para; sz_para = 2 * np.pi * self.to_array(sz, self.N); self._params[""sz""] = sz_para. @property; def sx_ops(self):; return self.ctrls[: self.N]. @property; def sz_ops(self):; return self.ctrls[self.N: 2*self.N]. @property; def sxsy_ops(self):; return self.ctrls[2*self.N:]. @property; def sx_u(self):; return self.coeffs[: self.N]. @property; def sz_u(self):; return self.coeffs[self.N: 2*self.N]. @property; def sxsy_u(self):; return self.coeffs[2*self.N:]. [docs] def load_circuit(; self, qc, setup, schedule_mode=""ASAP"", compiler=None):; """"""; Decompose a :class:`.QubitCircuit` in to the control; amplitu",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/spinchain.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html
https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html:6108,Usability,simpl,simplicity,6108,"(m)] = index; index += 1; # sz_ops; for m in range(N):; self.pulses.append(; Pulse(sigmaz(), m, spline_kind=self.spline_kind)); self.pulse_dict[""sz"" + str(m)] = index; index += 1; # sxsy_ops; operator = tensor([sigmax(), sigmax()]) + tensor([sigmay(), sigmay()]); for n in range(N - 1):; self.pulses.append(; Pulse(operator, [n, n+1], spline_kind=self.spline_kind)); self.pulse_dict[""g"" + str(n)] = index; index += 1. [docs] def set_up_params(self, sx, sz):; """"""; Save the parameters in the attribute `params` and check the validity.; The keys of `params` including ""sx"", ""sz"", and ""sxsy"", each; mapped to a list for parameters corresponding to each qubits.; For coupling strength ""sxsy"", list element i is the interaction; between qubits i and i+1. Parameters; ----------; sx: float or list; The coefficient of sigmax in the model. sz: flaot or list; The coefficient of sigmaz in the model. Notes; -----; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity; """"""; sx_para = 2 * np.pi * self.to_array(sx, self.N); self._params[""sx""] = sx_para; sz_para = 2 * np.pi * self.to_array(sz, self.N); self._params[""sz""] = sz_para. @property; def sx_ops(self):; return self.ctrls[: self.N]. @property; def sz_ops(self):; return self.ctrls[self.N: 2*self.N]. @property; def sxsy_ops(self):; return self.ctrls[2*self.N:]. @property; def sx_u(self):; return self.coeffs[: self.N]. @property; def sz_u(self):; return self.coeffs[self.N: 2*self.N]. @property; def sxsy_u(self):; return self.coeffs[2*self.N:]. [docs] def load_circuit(; self, qc, setup, schedule_mode=""ASAP"", compiler=None):; """"""; Decompose a :class:`.QubitCircuit` in to the control; amplitude generating the corresponding evolution. Parameters; ----------; qc: :class:`.QubitCircuit`; Takes the quantum circuit to be implemented. setup: string; ""linear"" or ""circular"" for two sub-classes. Returns; -------; tlist: array_like; A NumPy array specifies the time of each coefficient. coeffs:",MatchSource.WIKI,docs/4.6/modules/qutip/qip/device/spinchain.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html
https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html:42383,Deployability,update,updated,42383," list of integer for the dimension of each composite system.; E.g ``[2, 2, 2, 2, 2]`` for 5 qubits system. If None, qubits system; will be the default option.; cyclic_permutation : boolean, optional; Expand for all cyclic permutation of the targets.; E.g. if ``N=3`` and `oper` is a 2-qubit operator,; the result will be a list of three operators,; each acting on qubits 0 and 1, 1 and 2, 2 and 0. Returns; -------; expanded_oper : :class:`qutip.Qobj`; The expanded qubits operator acting on a system with N qubits. Notes; -----; This is equivalent to gate_expand_1toN, gate_expand_2toN,; gate_expand_3toN in ``qutip.qip.gate.py``, but works for any dimension.; """"""; if dims is None:; dims = [2] * N; targets = _targets_to_list(targets, oper=oper, N=N); _check_qubits_oper(oper, dims=dims, targets=targets). # Call expand_operator for all cyclic permutation of the targets.; if cyclic_permutation:; oper_list = []; for i in range(N):; new_targets = np.mod(np.array(targets)+i, N); oper_list.append(; expand_operator(oper, N=N, targets=new_targets, dims=dims)); return oper_list. # Generate the correct order for qubits permutation,; # eg. if N = 5, targets = [3,0], the order is [1,2,3,0,4].; # If the operator is cnot,; # this order means that the 3rd qubit controls the 0th qubit.; new_order = [0] * N; for i, t in enumerate(targets):; new_order[t] = i; # allocate the rest qutbits (not targets) to the empty; # position in new_order; rest_pos = [q for q in list(range(N)) if q not in targets]; rest_qubits = list(range(len(targets), N)); for i, ind in enumerate(rest_pos):; new_order[ind] = rest_qubits[i]; id_list = [identity(dims[i]) for i in rest_pos]; return tensor([oper] + id_list).permute(new_order). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/operations/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html
https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html:2243,Energy Efficiency,reduce,reduce,2243,"cific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; import numbers; from collections.abc import Iterable; from itertools import product, chain; from functools import partial, reduce; from operator import mul. import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.operators import identity, qeye, sigmax, sigmay, sigmaz; from qutip.tensor import tensor; from qutip.states import fock_dm. __all__ = ['rx', 'ry', 'rz', 'sqrtnot', 'snot', 'phasegate', 'qrot',; 'x_gate', 'y_gate', 'z_gate', 'cy_gate', 'cz_gate', 's_gate',; 't_gate', 'qasmu_gate', 'cs_gate', 'ct_gate', 'cphase', 'cnot',; 'csign', 'berkeley', 'swapalpha', 'swap', 'iswap', 'sqrtswap',; 'sqrtiswap', 'fredkin', 'molmer_sorensen',; 'toffoli', 'rotation', 'controlled_gate',; 'globalphase', 'hadamard_transform', 'gate_sequence_product',; 'gate_expand_1toN', 'gate_expand_2toN', 'gate_expand_3toN',; 'qubit_clifford_group', 'expand_operator']. #; # Single Qubit Gates; #. def x_gate(N=None, target=0):; """"""Pauli-X gate or sigmax operator. Returns; -------; result : :class:`qutip.Qobj`; Quantum object for operator describing; a single-qubit rotation thr",MatchSource.WIKI,docs/4.6/modules/qutip/qip/operations/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html
https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html:26926,Energy Efficiency,reduce,reduce,26926,"""""""; Calculate the overall unitary matrix for a given list of unitary operations; that are still of original dimension. Parameters; ----------; U_list : list of Qobj; List of gates(unitaries) implementing the quantum circuit. ind_list : list of list of int; List of qubit indices corresponding to each gate in tensor_list. Returns; -------; U_overall : qobj; Unitary matrix corresponding to U_list. overall_inds : list of int; List of qubit indices on which U_overall applies. Examples; --------. First, we get some imports out of the way,. >>> from qutip.qip.operations.gates import _gate_sequence_product; >>> from qutip.qip.operations.gates import x_gate, y_gate, toffoli, z_gate. Suppose we have a circuit with gates X, Y, Z, TOFFOLI; applied on qubit indices 0, 1, 2 and [0, 1, 3] respectively. >>> tensor_lst = [x_gate(), y_gate(), z_gate(), toffoli()]; >>> overall_inds = [[0], [1], [2], [0, 1, 3]]. Then, we can use _gate_sequence_product to produce a single unitary; obtained by multiplying unitaries in the list using heuristic methods; to reduce the size of matrices being multiplied. >>> U_list, overall_inds = _gate_sequence_product(tensor_lst, overall_inds); """""". num_qubits = len(set(chain(*ind_list))); sorted_inds = sorted(set(_flatten(ind_list))); ind_list = [[sorted_inds.index(ind) for ind in inds] for inds in ind_list]. U_overall = 1; overall_inds = []. for i, (U, inds) in enumerate(zip(U_list, ind_list)):. # when the tensor_list covers the full dimension of the circuit, we; # expand the tensor_list to a unitary and call _gate_sequence_product; # recursively on the rest of the U_list.; if len(overall_inds) == 1 and len(overall_inds[0]) == num_qubits:; U_overall, overall_inds = _expand_overall(tensor_list, overall_inds); U_left, rem_inds = _gate_sequence_product(U_list[i:],; ind_list[i:]); U_left = expand_operator(U_left, num_qubits, rem_inds); return U_left * U_overall, [sorted_inds[ind] for ind in overall_inds]. # special case for first unitary in the list; if U_ove",MatchSource.WIKI,docs/4.6/modules/qutip/qip/operations/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html
https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html:30011,Energy Efficiency,power,powers,30011,"rall; else:; U_overall = U_overall * U. return U_overall. [docs]def gate_sequence_product(U_list, left_to_right=True,; inds_list=None, expand=False):; """"""; Calculate the overall unitary matrix for a given list of unitary operations. Parameters; ----------; U_list: list; List of gates implementing the quantum circuit. left_to_right: Boolean, optional; Check if multiplication is to be done from left to right. inds_list: list of list of int, optional; If expand=True, list of qubit indices corresponding to U_list; to which each unitary is applied. expand: Boolean, optional; Check if the list of unitaries need to be expanded to full dimension. Returns; -------; U_overall : qobj; Unitary matrix corresponding to U_list. overall_inds : list of int, optional; List of qubit indices on which U_overall applies.; """""". if expand:; return _gate_sequence_product(U_list, inds_list); else:; return _gate_sequence_product_with_expansion(U_list, left_to_right). def _powers(op, N):; """"""; Generator that yields powers of an operator `op`,; through to `N`.; """"""; acc = qeye(op.dims[0]); yield acc. for _ in range(N - 1):; acc *= op; yield acc. def qubit_clifford_group(N=None, target=0):; """"""; Generates the Clifford group on a single qubit,; using the presentation of the group given by Ross and Selinger; (http://www.mathstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/operations/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html
https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html:31116,Energy Efficiency,reduce,reduce,31116,"c. def qubit_clifford_group(N=None, target=0):; """"""; Generates the Clifford group on a single qubit,; using the presentation of the group given by Ross and Selinger; (http://www.mathstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2),; _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if targ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/operations/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html
https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html:31198,Energy Efficiency,reduce,reduce,31198,"it,; using the presentation of the group given by Ross and Selinger; (http://www.mathstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2),; _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if target >= N:; raise ValueError(""target must be integer < integer N""). return tensor([identity(2)] * (t",MatchSource.WIKI,docs/4.6/modules/qutip/qip/operations/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html
https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html:31344,Energy Efficiency,reduce,reduce,31344,"stat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2),; _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if target >= N:; raise ValueError(""target must be integer < integer N""). return tensor([identity(2)] * (target) + [U] +; [identity(2)] * (N - target - 1)). [docs]def gate_expand_2toN(U, N, c",MatchSource.WIKI,docs/4.6/modules/qutip/qip/operations/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html
https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html:31493,Energy Efficiency,reduce,reduce,31493,"Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2),; _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if target >= N:; raise ValueError(""target must be integer < integer N""). return tensor([identity(2)] * (target) + [U] +; [identity(2)] * (N - target - 1)). [docs]def gate_expand_2toN(U, N, control=None, target=None, targets=None):; """"""; Create a Qobj representing a two-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; T",MatchSource.WIKI,docs/4.6/modules/qutip/qip/operations/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html
https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html:41842,Energy Efficiency,allocate,allocate,41842," list of integer for the dimension of each composite system.; E.g ``[2, 2, 2, 2, 2]`` for 5 qubits system. If None, qubits system; will be the default option.; cyclic_permutation : boolean, optional; Expand for all cyclic permutation of the targets.; E.g. if ``N=3`` and `oper` is a 2-qubit operator,; the result will be a list of three operators,; each acting on qubits 0 and 1, 1 and 2, 2 and 0. Returns; -------; expanded_oper : :class:`qutip.Qobj`; The expanded qubits operator acting on a system with N qubits. Notes; -----; This is equivalent to gate_expand_1toN, gate_expand_2toN,; gate_expand_3toN in ``qutip.qip.gate.py``, but works for any dimension.; """"""; if dims is None:; dims = [2] * N; targets = _targets_to_list(targets, oper=oper, N=N); _check_qubits_oper(oper, dims=dims, targets=targets). # Call expand_operator for all cyclic permutation of the targets.; if cyclic_permutation:; oper_list = []; for i in range(N):; new_targets = np.mod(np.array(targets)+i, N); oper_list.append(; expand_operator(oper, N=N, targets=new_targets, dims=dims)); return oper_list. # Generate the correct order for qubits permutation,; # eg. if N = 5, targets = [3,0], the order is [1,2,3,0,4].; # If the operator is cnot,; # this order means that the 3rd qubit controls the 0th qubit.; new_order = [0] * N; for i, t in enumerate(targets):; new_order[t] = i; # allocate the rest qutbits (not targets) to the empty; # position in new_order; rest_pos = [q for q in list(range(N)) if q not in targets]; rest_qubits = list(range(len(targets), N)); for i, ind in enumerate(rest_pos):; new_order[ind] = rest_qubits[i]; id_list = [identity(dims[i]) for i in rest_pos]; return tensor([oper] + id_list).permute(new_order). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qip/operations/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html
https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html:24231,Testability,test,testing,24231,"ensor_list_revised: list of Qobj; List of gates (unitaries) acting on disjoint qubits incorporating U. overall_inds_revised: list of list of int; List of qubit indices corresponding to each gate in tensor_list_revised. Examples; --------. First, we get some imports out of the way,. >>> from qutip.qip.operations.gates import _mult_sublists; >>> from qutip.qip.operations.gates import x_gate, y_gate, toffoli, z_gate. Suppose we have a unitary list of already processed gates,; X, Y, Z applied on qubit indices 0, 1, 2 respectively and; encounter a new TOFFOLI gate on qubit indices (0, 1, 3). >>> tensor_list = [x_gate(), y_gate(), z_gate()]; >>> overall_inds = [[0], [1], [2]]; >>> U = toffoli(); >>> U_inds = [0, 1, 3]. Then, we can use _mult_sublists to produce a new list of unitaries by; multiplying TOFFOLI (and expanding) only on the qubit indices involving; TOFFOLI gate (and any multiplied gates). >>> U_list, overall_inds = _mult_sublists(tensor_list, overall_inds, U, U_inds); >>> np.testing.assert_allclose(U_list[0]) == z_gate()); >>> toffoli_xy = toffoli() * tensor(x_gate(), y_gate(), identity(2)); >>> np.testing.assert_allclose(U_list[1]), toffoli_xy); >>> overall_inds = [[2], [0, 1, 3]]; """""". tensor_sublist = []; inds_sublist = []. tensor_list_revised = []; overall_inds_revised = []. for sub_inds, sub_U in zip(overall_inds, tensor_list):; if len(set(sub_inds).intersection(inds)) > 0:; tensor_sublist.append(sub_U); inds_sublist.append(sub_inds); else:; overall_inds_revised.append(sub_inds); tensor_list_revised.append(sub_U). inds_sublist = _flatten(inds_sublist); U_sublist = tensor(tensor_sublist). revised_inds = list(set(inds_sublist).union(set(inds))); N = len(revised_inds). sorted_positions = sorted(range(N), key=lambda key: revised_inds[key]); ind_map = {ind: pos for ind, pos in zip(revised_inds, sorted_positions)}. U_sublist = expand_operator(U_sublist, N,; [ind_map[ind] for ind in inds_sublist]); U = expand_operator(U, N, [ind_map[ind] for ind in inds]). U_sub",MatchSource.WIKI,docs/4.6/modules/qutip/qip/operations/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html
https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html:24357,Testability,test,testing,24357,"ist of list of int; List of qubit indices corresponding to each gate in tensor_list_revised. Examples; --------. First, we get some imports out of the way,. >>> from qutip.qip.operations.gates import _mult_sublists; >>> from qutip.qip.operations.gates import x_gate, y_gate, toffoli, z_gate. Suppose we have a unitary list of already processed gates,; X, Y, Z applied on qubit indices 0, 1, 2 respectively and; encounter a new TOFFOLI gate on qubit indices (0, 1, 3). >>> tensor_list = [x_gate(), y_gate(), z_gate()]; >>> overall_inds = [[0], [1], [2]]; >>> U = toffoli(); >>> U_inds = [0, 1, 3]. Then, we can use _mult_sublists to produce a new list of unitaries by; multiplying TOFFOLI (and expanding) only on the qubit indices involving; TOFFOLI gate (and any multiplied gates). >>> U_list, overall_inds = _mult_sublists(tensor_list, overall_inds, U, U_inds); >>> np.testing.assert_allclose(U_list[0]) == z_gate()); >>> toffoli_xy = toffoli() * tensor(x_gate(), y_gate(), identity(2)); >>> np.testing.assert_allclose(U_list[1]), toffoli_xy); >>> overall_inds = [[2], [0, 1, 3]]; """""". tensor_sublist = []; inds_sublist = []. tensor_list_revised = []; overall_inds_revised = []. for sub_inds, sub_U in zip(overall_inds, tensor_list):; if len(set(sub_inds).intersection(inds)) > 0:; tensor_sublist.append(sub_U); inds_sublist.append(sub_inds); else:; overall_inds_revised.append(sub_inds); tensor_list_revised.append(sub_U). inds_sublist = _flatten(inds_sublist); U_sublist = tensor(tensor_sublist). revised_inds = list(set(inds_sublist).union(set(inds))); N = len(revised_inds). sorted_positions = sorted(range(N), key=lambda key: revised_inds[key]); ind_map = {ind: pos for ind, pos in zip(revised_inds, sorted_positions)}. U_sublist = expand_operator(U_sublist, N,; [ind_map[ind] for ind in inds_sublist]); U = expand_operator(U, N, [ind_map[ind] for ind in inds]). U_sublist = U * U_sublist; inds_sublist = revised_inds. overall_inds_revised.append(inds_sublist); tensor_list_revised.append(U_sub",MatchSource.WIKI,docs/4.6/modules/qutip/qip/operations/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html
https://qutip.org/docs/4.7/apidoc/apidoc.html:2132,Deployability,update,updated,2132,"Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; API documentation. API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; QobjEvo; eseries; Bloch sphere; Distributions; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; One-Dimensional Lattice; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Quantum Objects; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations; Operators and Superoperator Dimensions. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Measurement; Measurement of quantum states. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Krylov Subspace Solver; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Lattice; Lattice Properties; Topology. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms; Circuit. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; Semidefinite Programming; IPython Notebook Tools; Miscellaneous. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/apidoc/apidoc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/apidoc.html
https://qutip.org/docs/4.7/apidoc/apidoc.html:1530,Integrability,depend,dependent,1530,"Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; API documentation. API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; QobjEvo; eseries; Bloch sphere; Distributions; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; One-Dimensional Lattice; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Quantum Objects; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations; Operators and Superoperator Dimensions. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Measurement; Measurement of quantum states. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Krylov Subspace Solver; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Lattice; Lattice Properties; Topology. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms; Circuit. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; Semidefinite Programming; IPython Notebook Tools; Miscellaneous. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/apidoc/apidoc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/apidoc.html
https://qutip.org/docs/4.7/apidoc/classes.html:6347,Availability,toler,tolerance,6347,"erators is Hermitian,; otherwise complex values are returned. dnorm(B=None)[source]¶; Calculates the diamond norm, or the diamond distance to another; operator. Parameters. Bqutip.Qobj or NoneIf B is not None, the diamond distance d(A, B) = dnorm(A - B); between this operator and B is returned instead of the diamond; norm. Returns. dfloatEither the diamond norm of this operator, or the diamond distance; from this operator to B. dual_chan()[source]¶; Dual channel of quantum object representing a completely positive; map. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000, phase_fix=None)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). phase_fixint, NoneIf not None, set the phase of each kets so that ket[phase_fix,0]; is real posi",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:7139,Availability,toler,tolerance,7139,"es ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000, phase_fix=None)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). phase_fixint, NoneIf not None, set the phase of each kets so that ket[phase_fix,0]; is real positive. Returns. eigvalsarrayArray of eigenvalues for operator. eigvecsarrayArray of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, nor",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:9195,Availability,avail,available,9195,"s only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, ‘sin(w * t)’]]. is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters. qobj_listlistA nested list of Qobj instances and corresponding time-dependent; coefficients. tfloatThe time for which to evaluate the time-dependent Qobj instance. argsdictionaryA dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns. outputqutip.QobjA Qobj instance that represents the value of qobj_list at time t. expm(method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters. methodstr {‘dense’, ‘sparse’}Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns. operqutip.QobjExponentiated quantum operator. Raises. TypeErrorQuantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeeze",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:10658,Availability,toler,tolerance,10658,"w Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. Notes; It is slightly more computationally efficient to use a ket; v",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:12270,Availability,toler,tolerance,12270,"square. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. Notes; It is slightly more computationally efficient to use a ket; vector for the ‘bra’ input. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters. normstrWhich norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’. sparseboolUse sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tolfloatTolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used); for trace norm. Returns. normfloatThe requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(other)[source]¶; Overlap between two state vectors or two operators.; Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters. otherqutip.QobjQuantum object for a state vector of type ‘ket’, ‘bra’ or density; matrix. Returns. overlapcomplexComplex valued overlap. Raises. TypeErrorCan only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> w",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:15119,Availability,toler,tolerance,15119,"ity of a quantum object. Returns. state_purityfloatReturns the purity of a quantum object.; For a pure state, the purity is 1.; For a mixed state of dimension d, 1/d<=purity<1. sinm()[source]¶; Sine of a quantum operator.; Operator must be square. Returns. operqutip.QobjMatrix sine of operator. Raises. TypeErrorQuantum object is not square. Notes; Uses the Q.expm() method. sqrtm(sparse=False, tol=0, maxiter=100000)[source]¶; Sqrt of a quantum operator.; Operator must be square. Parameters. sparseboolUse sparse eigenvalue/vector solver. tolfloatTolerance used by sparse solver (0 = machine precision). maxiterintMaximum number of iterations used by sparse solver. Returns. operqutip.QobjMatrix square root of operator. Raises. TypeErrorQuantum object is not square. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. tidyup(atol=None)[source]¶; Removes small elements from the quantum object. Parameters. atolfloatAbsolute tolerance used by tidyup. Default is set; via qutip global settings parameters. Returns. operqutip.QobjQuantum object with small elements removed. tr()[source]¶; Trace of a quantum object. Returns. tracefloatReturns the trace of the quantum object. trans()[source]¶; Transposed operator. Returns. operqutip.QobjTranspose of input operator. transform(inpt, inverse=False, sparse=True)[source]¶; Basis transform defined by input array.; Input array can be a matrix defining the transformation,; or a list of kets that defines the new basis. Parameters. inptarray_likeA matrix or list of kets defining the transformation. inverseboolWhether to return inverse transformation. sparseboolUse sparse matrices when possible. Can be slower. Returns. operqutip.QobjOperator in new basis. Notes; This function is still in development. trunc_neg(method='clip')[source]¶; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:20015,Availability,avail,available,20015," be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; args = {""_step_func_coeff"": True}. Examples of array-format usage are:; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; QobjEvo that contains different tlist values, however.; Passing arguments; args is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string.; There are some “magic” names that can be specified, whose objects will be; overwritten when used within sesolve, mesolve and; mcsolve. This allows access to the solvers’ internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. ""state"": the current state as a Qobj; ""state_vec"": the current state as a column-stacked 1D np.ndarray; ""state_mat"": the current state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers. Replace <n> with; an integer literal, e.g. ""expect_op_0"". This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole o",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:45112,Availability,avail,available,45112,"stem density matrix) and the ADOs must be; in the same order as in .ados.labels. tlistlistAn ordered list of times at which to return the value of the state. e_opsQobj / callable / list / dict / None, optionalA list or dictionary of operators as Qobj and/or callable; functions (they can be mixed) or a single operator or callable; function. For an operator op, the result will be computed; using (state * op).tr() and the state at each time t. For; callable functions, f, the result is computed using; f(t, ado_state). The values are stored in expect on; (see the return section below). ado_init: bool, default FalseIndicates if initial condition is just the system state, or a; numpy array including all ADOs. ado_return: bool, default TrueWhether to also return as output the full state of all ADOs. Returns. qutip.solver.ResultThe results of the simulation run, with the following attributes:. times: the times t (i.e. the tlist).; states: the system state at each time t (only available; if e_ops was None or if the solver option; store_states was set to True).; ado_states: the full ADO state at each time (only available; if ado_return was set to True). Each element is an; instance of HierarchyADOsState. .; The state of a particular ADO may be extracted from; result.ado_states[i] by calling extract.; expect: the value of each e_ops at time t (only; available if e_ops were given). If e_ops was passed; as a dictionary, then expect will be a dictionary with; the same keys as e_ops and values giving the list of; outcomes for the corresponding key. steady_state(use_mkl=True, mkl_max_iter_refine=100, mkl_weighted_matching=False)[source]¶; Compute the steady state of the system. Parameters. use_mklbool, default=FalseWhether to use mkl or not. If mkl is not installed or if; this is false, use the scipy splu solver instead. mkl_max_iter_refineintSpecifies the the maximum number of iterative refinement steps that; the MKL PARDISO solver performs.; For a complete description, see iparm(8",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:45248,Availability,avail,available,45248,"s at which to return the value of the state. e_opsQobj / callable / list / dict / None, optionalA list or dictionary of operators as Qobj and/or callable; functions (they can be mixed) or a single operator or callable; function. For an operator op, the result will be computed; using (state * op).tr() and the state at each time t. For; callable functions, f, the result is computed using; f(t, ado_state). The values are stored in expect on; (see the return section below). ado_init: bool, default FalseIndicates if initial condition is just the system state, or a; numpy array including all ADOs. ado_return: bool, default TrueWhether to also return as output the full state of all ADOs. Returns. qutip.solver.ResultThe results of the simulation run, with the following attributes:. times: the times t (i.e. the tlist).; states: the system state at each time t (only available; if e_ops was None or if the solver option; store_states was set to True).; ado_states: the full ADO state at each time (only available; if ado_return was set to True). Each element is an; instance of HierarchyADOsState. .; The state of a particular ADO may be extracted from; result.ado_states[i] by calling extract.; expect: the value of each e_ops at time t (only; available if e_ops were given). If e_ops was passed; as a dictionary, then expect will be a dictionary with; the same keys as e_ops and values giving the list of; outcomes for the corresponding key. steady_state(use_mkl=True, mkl_max_iter_refine=100, mkl_weighted_matching=False)[source]¶; Compute the steady state of the system. Parameters. use_mklbool, default=FalseWhether to use mkl or not. If mkl is not installed or if; this is false, use the scipy splu solver instead. mkl_max_iter_refineintSpecifies the the maximum number of iterative refinement steps that; the MKL PARDISO solver performs.; For a complete description, see iparm(8) in; http://cali2.unilim.fr/intel-xe/mkl/mklman/GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF.htm. mkl_weighted_matc",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:45490,Availability,avail,available,45490,"perator op, the result will be computed; using (state * op).tr() and the state at each time t. For; callable functions, f, the result is computed using; f(t, ado_state). The values are stored in expect on; (see the return section below). ado_init: bool, default FalseIndicates if initial condition is just the system state, or a; numpy array including all ADOs. ado_return: bool, default TrueWhether to also return as output the full state of all ADOs. Returns. qutip.solver.ResultThe results of the simulation run, with the following attributes:. times: the times t (i.e. the tlist).; states: the system state at each time t (only available; if e_ops was None or if the solver option; store_states was set to True).; ado_states: the full ADO state at each time (only available; if ado_return was set to True). Each element is an; instance of HierarchyADOsState. .; The state of a particular ADO may be extracted from; result.ado_states[i] by calling extract.; expect: the value of each e_ops at time t (only; available if e_ops were given). If e_ops was passed; as a dictionary, then expect will be a dictionary with; the same keys as e_ops and values giving the list of; outcomes for the corresponding key. steady_state(use_mkl=True, mkl_max_iter_refine=100, mkl_weighted_matching=False)[source]¶; Compute the steady state of the system. Parameters. use_mklbool, default=FalseWhether to use mkl or not. If mkl is not installed or if; this is false, use the scipy splu solver instead. mkl_max_iter_refineintSpecifies the the maximum number of iterative refinement steps that; the MKL PARDISO solver performs.; For a complete description, see iparm(8) in; http://cali2.unilim.fr/intel-xe/mkl/mklman/GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF.htm. mkl_weighted_matchingboolMKL PARDISO can use a maximum weighted matching algorithm to; permute large elements close the diagonal. This strategy adds an; additional level of reliability to the factorization methods.; For a complete description, see iparm(",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:46399,Availability,reliab,reliability,46399,"; result.ado_states[i] by calling extract.; expect: the value of each e_ops at time t (only; available if e_ops were given). If e_ops was passed; as a dictionary, then expect will be a dictionary with; the same keys as e_ops and values giving the list of; outcomes for the corresponding key. steady_state(use_mkl=True, mkl_max_iter_refine=100, mkl_weighted_matching=False)[source]¶; Compute the steady state of the system. Parameters. use_mklbool, default=FalseWhether to use mkl or not. If mkl is not installed or if; this is false, use the scipy splu solver instead. mkl_max_iter_refineintSpecifies the the maximum number of iterative refinement steps that; the MKL PARDISO solver performs.; For a complete description, see iparm(8) in; http://cali2.unilim.fr/intel-xe/mkl/mklman/GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF.htm. mkl_weighted_matchingboolMKL PARDISO can use a maximum weighted matching algorithm to; permute large elements close the diagonal. This strategy adds an; additional level of reliability to the factorization methods.; For a complete description, see iparm(13) in; http://cali2.unilim.fr/intel-xe/mkl/mklman/GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF.htm. Returns. steady_stateQobjThe steady state density matrix of the system. steady_adosHierarchyADOsStateThe steady state of the full ADO hierarchy. A particular ADO may be; extracted from the full state by calling extract. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, bnd_cut_approx=False, options=None, progress_bar=None, combine=True)[source]¶; A helper class for creating an HEOMSolver that is backwards; compatible with the HSolverDL provided in qutip.nonmarkov.heom; in QuTiP 4.6 and below.; See HEOMSolver and DrudeLorentzBath for more; descriptions of the underlying solver and bath construction.; An exact copy of the QuTiP 4.6 HSolverDL is provided in; qutip.nonmarkov.dlheom_solver for cases where the functionality of; the older solver is required. The older solver will be",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:51346,Availability,avail,available,51346,"nent) to determine the k of the corresponding exponent with; the opposite sign (i.e. “-” or “+”). dimint or NoneThe dimension (i.e. maximum number of excitations for this exponent).; Usually 2 for fermionic exponents or None (i.e. unlimited) for; bosonic exponents. QQobjThe coupling operator for this excitation mode. vkcomplexThe frequency of the exponent of the excitation term. ckcomplexThe coefficient of the excitation term. ck2optional, complexFor exponents of type “RI” this is the coefficient of the term in the; imaginary expansion (and ck is the coefficient in the real; expansion). sigma_bar_k_offsetoptional, intFor exponents of type “+” this gives the offset (within the list of; exponents within the bath) of the corresponding “-” bath exponent.; For exponents of type “-” it gives the offset of the corresponding; “+” exponent. tagoptional, str, tuple or any other objectA label for the exponent (often the name of the bath). It; defaults to None. Attributes. All of the parameters are available as attributes. types¶; alias of qutip.nonmarkov.bofin_baths.ExponentType. class Bath(exponents)[source]¶; Represents a list of bath expansion exponents. Parameters. exponentslist of BathExponentThe exponents of the correlation function describing the bath. Attributes. All of the parameters are available as attributes. class BosonicBath(Q, ck_real, vk_real, ck_imag, vk_imag, combine=True, tag=None)[source]¶; A helper class for constructing a bosonic bath from the expansion; coefficients and frequencies for the real and imaginary parts of; the bath correlation function.; If the correlation functions C(t) is split into real and imaginary; parts:; C(t) = C_real(t) + i * C_imag(t). then:; C_real(t) = sum(ck_real * exp(- vk_real * t)); C_imag(t) = sum(ck_imag * exp(- vk_imag * t)). Defines the coefficients ck and the frequencies vk.; Note that the ck and vk may be complex, even through C_real(t); and C_imag(t) (i.e. the sum) is real. Parameters. QQobjThe coupling operator for the ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:51651,Availability,avail,available,51651,"itation mode. vkcomplexThe frequency of the exponent of the excitation term. ckcomplexThe coefficient of the excitation term. ck2optional, complexFor exponents of type “RI” this is the coefficient of the term in the; imaginary expansion (and ck is the coefficient in the real; expansion). sigma_bar_k_offsetoptional, intFor exponents of type “+” this gives the offset (within the list of; exponents within the bath) of the corresponding “-” bath exponent.; For exponents of type “-” it gives the offset of the corresponding; “+” exponent. tagoptional, str, tuple or any other objectA label for the exponent (often the name of the bath). It; defaults to None. Attributes. All of the parameters are available as attributes. types¶; alias of qutip.nonmarkov.bofin_baths.ExponentType. class Bath(exponents)[source]¶; Represents a list of bath expansion exponents. Parameters. exponentslist of BathExponentThe exponents of the correlation function describing the bath. Attributes. All of the parameters are available as attributes. class BosonicBath(Q, ck_real, vk_real, ck_imag, vk_imag, combine=True, tag=None)[source]¶; A helper class for constructing a bosonic bath from the expansion; coefficients and frequencies for the real and imaginary parts of; the bath correlation function.; If the correlation functions C(t) is split into real and imaginary; parts:; C(t) = C_real(t) + i * C_imag(t). then:; C_real(t) = sum(ck_real * exp(- vk_real * t)); C_imag(t) = sum(ck_imag * exp(- vk_imag * t)). Defines the coefficients ck and the frequencies vk.; Note that the ck and vk may be complex, even through C_real(t); and C_imag(t) (i.e. the sum) is real. Parameters. QQobjThe coupling operator for the bath. ck_reallist of complexThe coefficients of the expansion terms for the real part of the; correlation function. The corresponding frequencies are passed as; vk_real. vk_reallist of complexThe frequencies (exponents) of the expansion terms for the real part of; the correlation function. The correspond",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:53908,Availability,toler,tolerance,53908," terms for the imaginary; part of the correlation function. The corresponding ceofficients are; passed as ck_imag. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. classmethod combine(exponents, rtol=1e-05, atol=1e-07)[source]¶; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present.; Exponents with the same frequency are only combined if they share the; same coupling operator .Q.; Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters. exponentslist of BathExponentThe list of exponents to combine. rtolfloat, default 1e-5The relative tolerance to use to when comparing frequencies and; coupling operators. atolfloat, default 1e-7The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns. list of BathExponentThe new reduced list of exponents. class DrudeLorentzBath(Q, lam, gamma, T, Nk, combine=True, tag=None)[source]¶; A helper class for constructing a Drude-Lorentz bosonic bath from the; bath parameters (see parameters below). Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an e",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:54016,Availability,toler,tolerance,54016,"_imag. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. classmethod combine(exponents, rtol=1e-05, atol=1e-07)[source]¶; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present.; Exponents with the same frequency are only combined if they share the; same coupling operator .Q.; Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters. exponentslist of BathExponentThe list of exponents to combine. rtolfloat, default 1e-5The relative tolerance to use to when comparing frequencies and; coupling operators. atolfloat, default 1e-7The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns. list of BathExponentThe new reduced list of exponents. class DrudeLorentzBath(Q, lam, gamma, T, Nk, combine=True, tag=None)[source]¶; A helper class for constructing a Drude-Lorentz bosonic bath from the; bath parameters (see parameters below). Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. terminator()[source]¶; Return the Matsubara terminator for the bath and the calculated; app",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:67883,Availability,avail,available,67883,"neThe next label. prev(label, k)[source]¶; Return the ADO label with one fewer excitation in the k’th; exponent dimension or None if the label has no exciations in the; k’th exponent. Parameters. labeltupleThe ADO label to remove the excitation from. kintThe exponent to remove the excitation from. Returns. tuple or NoneThe previous label. class HierarchyADOsState(rho, ados, ado_state)[source]¶; Provides convenient access to the full hierarchy ADO state at a particular; point in time, t. Parameters. rhoQobjThe current state of the system (i.e. the 0th component of the; hierarchy). adosHierarchyADOsThe description of the hierarchy. ado_statenumpy.arrayThe full state of the hierarchy. Attributes. rhoQobjThe system state. In addition, all of the attributes of the hierarchy description,; i.e. ``HierarchyADOs``, are provided directly on this class for; convenience. E.g. one can access ``.labels``, or ``.exponents`` or; call ``.idx(label)`` directly.; See :class:`HierarchyADOs` for a full list of the available attributes; and methods. extract(idx_or_label)[source]¶; Extract a Qobj representing specified ADO from a full representation of; the ADO states. Parameters. idxint or labelThe index of the ADO to extract. If an ADO label, e.g.; (0, 1, 0, ...) is supplied instead, then the ADO; is extracted by label instead. Returns. QobjA Qobj representing the state of the specified ADO. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:78626,Availability,toler,tolerance,78626,"d. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results¶. class ExpectOps(e_ops=[], super_=False)[source]¶; Contain and compute expectation values. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, steady_state_average=False, seeds=None, normalize_output=True, use_openmp=None, openmp_threads=None)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes. atolfloat {1e-8}Absolute tolerance. rtolfloat {1e-6}Relative tolerance. methodstr {‘adams’,’bdf’}Integration method. orderint {12}Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nstepsint {2500}Max. number of internal steps/call. first_stepfloat {0}Size of initial step (0 = automatic). min_stepfloat {0}Minimum step size (0 = automatic). max_stepfloat {0}Maximum step size (0 = automatic). tidybool {True,False}Tidyup Hamiltonian and initial state by removing small terms. num_cpusintNumber of cpus used by mcsolver (default = # of cpus). norm_tolfloatTolerance used when finding wavefunction norm in mcsolve. norm_stepsintMax. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_statesbool {False}Average states values over trajectories in stochastic solvers. average_expectbool {True}Average expectation values over trajectories for stochastic solvers. mc_corr_epsfloat {1e-10}Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when usi",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:78662,Availability,toler,tolerance,78662,"c solver options. Solver Options and Results¶. class ExpectOps(e_ops=[], super_=False)[source]¶; Contain and compute expectation values. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, steady_state_average=False, seeds=None, normalize_output=True, use_openmp=None, openmp_threads=None)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes. atolfloat {1e-8}Absolute tolerance. rtolfloat {1e-6}Relative tolerance. methodstr {‘adams’,’bdf’}Integration method. orderint {12}Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nstepsint {2500}Max. number of internal steps/call. first_stepfloat {0}Size of initial step (0 = automatic). min_stepfloat {0}Minimum step size (0 = automatic). max_stepfloat {0}Maximum step size (0 = automatic). tidybool {True,False}Tidyup Hamiltonian and initial state by removing small terms. num_cpusintNumber of cpus used by mcsolver (default = # of cpus). norm_tolfloatTolerance used when finding wavefunction norm in mcsolve. norm_stepsintMax. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_statesbool {False}Average states values over trajectories in stochastic solvers. average_expectbool {True}Average expectation values over trajectories for stochastic solvers. mc_corr_epsfloat {1e-10}Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve. ntrajint {500}Number of ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:79574,Availability,error,errors,79574,"options in evolution solvers. Attributes. atolfloat {1e-8}Absolute tolerance. rtolfloat {1e-6}Relative tolerance. methodstr {‘adams’,’bdf’}Integration method. orderint {12}Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nstepsint {2500}Max. number of internal steps/call. first_stepfloat {0}Size of initial step (0 = automatic). min_stepfloat {0}Minimum step size (0 = automatic). max_stepfloat {0}Maximum step size (0 = automatic). tidybool {True,False}Tidyup Hamiltonian and initial state by removing small terms. num_cpusintNumber of cpus used by mcsolver (default = # of cpus). norm_tolfloatTolerance used when finding wavefunction norm in mcsolve. norm_stepsintMax. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_statesbool {False}Average states values over trajectories in stochastic solvers. average_expectbool {True}Average expectation values over trajectories for stochastic solvers. mc_corr_epsfloat {1e-10}Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve. ntrajint {500}Number of trajectories in stochastic solvers. openmp_threadsintNumber of OPENMP threads to use. Default is number of cpu cores. rhs_reusebool {False,True}Reuse Hamiltonian data. rhs_with_statebool {False,True}Whether or not to include the state in the Hamiltonian function; callback signature. rhs_filenamestrName for compiled Cython file. seedsndarrayArray containing random number seeds for mcsolver. store_final_statebool {False, True}Whether or not to store the final state of the evolution in the; result class. store_statesbool {False, True}Whether or not to store the state vectors or density matrices in the; result class, even if expectation values operators are given. If no; expectation are provided, then states are stored by default and this; option has no effect. use_openmpbool {True, False}Use OPENMP for sparse matrix vector multiplication. Default; None means auto check. class Result[source]¶; Cla",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:88606,Availability,toler,tolerance,88606,"ues. m_opslist of qutip.QobjList of operators representing the measurement operators. The expected; format is a nested list with one measurement operator for each; stochastic increament, for each stochastic collapse operator. argsdictDictionary of parameters for time dependent systems. tolfloatTolerance of the solver for implicit methods. ntrajintNumber of trajectors. nsubstepsintNumber of sub steps between each time-spep given in times. dW_factorsarrayArray of length len(sc_ops), containing scaling factors for each; measurement operator in m_ops. solverstringName of the solver method to use for solving the stochastic; equations. Valid values are:. order 1/2 algorithms: ‘euler-maruyama’, ‘pc-euler’, ‘pc-euler-imp’; order 1 algorithms: ‘milstein’, ‘platen’, ‘milstein-imp’, ‘rouchon’; order 3/2 algorithms: ‘taylor1.5’, ‘taylor1.5-imp’, ‘explicit1.5’; order 2 algorithms: ‘taylor2.0’. See the documentation of stochastic_solvers; for a description of the solvers. Implicit methods can adjust; tolerance via the kw ‘tol’. Default is {‘tol’: 1e-6}. methodstring (‘homodyne’, ‘heterodyne’)The name of the type of measurement process that give rise to the; stochastic equation to solve. store_all_expectbool (default False)Whether or not to store the e_ops expect values for all paths. store_measurementbool (default False)Whether or not to store the measurement results in the; qutip.solver.Result instance returned by the solver. noiseint, or 1D array of int, or 4D array of float; int : seed of the noise; 1D array : length = ntraj, seeds for each trajectories.; 4D array : (ntraj, len(times), nsubsteps, len(sc_ops)*[1|2]).; Vector for the noise, the len of the last dimensions is doubled for; solvers of order 1.5. This corresponds to results.noise. noiseDepthintNumber of terms kept of the truncated series used to create the; noise used by taylor2.0 solver. normalizebool(default True for (photo)ssesolve, False for (photo)smesolve); Whether or not to normalize the wave function during th",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:89668,Availability,error,errors,89668,"‘tol’: 1e-6}. methodstring (‘homodyne’, ‘heterodyne’)The name of the type of measurement process that give rise to the; stochastic equation to solve. store_all_expectbool (default False)Whether or not to store the e_ops expect values for all paths. store_measurementbool (default False)Whether or not to store the measurement results in the; qutip.solver.Result instance returned by the solver. noiseint, or 1D array of int, or 4D array of float; int : seed of the noise; 1D array : length = ntraj, seeds for each trajectories.; 4D array : (ntraj, len(times), nsubsteps, len(sc_ops)*[1|2]).; Vector for the noise, the len of the last dimensions is doubled for; solvers of order 1.5. This corresponds to results.noise. noiseDepthintNumber of terms kept of the truncated series used to create the; noise used by taylor2.0 solver. normalizebool(default True for (photo)ssesolve, False for (photo)smesolve); Whether or not to normalize the wave function during the evolution.; Normalizing density matrices introduce numerical errors. optionsqutip.solver.OptionsGeneric solver options. Only options.average_states and; options.store_states are used. map_func: functionA map function or managing the calls to single-trajactory solvers. map_kwargs: dictionaryOptional keyword arguments to the map_func function function. progress_barqutip.ui.BaseProgressBarOptional progress bar class instance. Permutational Invariance¶. class Dicke(N, hamiltonian=None, emission=0.0, dephasing=0.0, pumping=0.0, collective_emission=0.0, collective_dephasing=0.0, collective_pumping=0.0)[source]¶; The Dicke class which builds the Lindbladian and Liouvillian matrix. Parameters. N: intThe number of two-level systems. hamiltonianqutip.QobjA Hamiltonian in the Dicke basis.; The matrix dimensions are (nds, nds),; with nds being the number of Dicke states.; The Hamiltonian can be built with the operators; given by the jspin functions. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:120327,Availability,avail,available,120327," measurement result to enable; post-selection. If specified, the measurement results are; set to the tuple of bits (sequentially) instead of being; chosen at random. Returns. result: CircuitResultReturn a CircuitResult object containing; output state and probability. run_statistics(state, cbits=None)[source]¶; Calculate all the possible outputs of a circuit; (varied by measurement gates). Parameters. stateketstate to be observed on specified by density matrix. cbitsList of ints, optionalinitialization of the classical bits. Returns. result: CircuitResultReturn a CircuitResult object containing; output states and and their probabilities. step()[source]¶; Return state after one step of circuit evolution; (gate or measurement). Returns. stateket or operstate after one evolution step. class Processor(N, t1=None, t2=None, dims=None, spline_kind='step_func')[source]¶; A simulator of a quantum device based on the QuTiP solver; qutip.mesolve. It is defined by the available driving Hamiltonian; and the decoherence time for each component systems. The processor can; simulate the evolution under the given control pulses. Noisy evolution is; supported by Noise and can be added to the processor. Parameters. N: intThe number of component systems. t1: list or float, optionalCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of float, optionalCharacterize the decoherence of dephasing for; each qubit. A list of size N or a float for all qubits. dims: list, optionalThe dimension of each component system.; Default value is a; qubit system of dim=[2,2,2,...,2]. spline_kind: str, optionalType of the coefficient interpolation. Default is “step_func”; Note that they have different requirement for the length of coeff. “step_func”:; The coefficient will be treated as a step function. E.g.; tlist=[0,1,2] and coeff=[3,2], means that the coefficient is; 3 in t=[0,1) and 2 in t=[2,3). It requires; len(coeff)=len(tlist)-1 or len",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:129710,Availability,avail,available,129710,"nsity matrix or state vector (ket). analytical: boolIf True, calculate the evolution with matrices exponentiation. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. solver: str“mesolve” or “mcsolve”. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.solver.ResultIf analytical is False, an instance of the class; qutip.solver.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)[source]¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)[source]¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. class OptPulseProcessor(N, drift=None, t1=None, t2=None, dims=None)[source]¶; A processor, which takes the Hamiltonian available; as dynamic generators, calls the; qutip.control.optimize_pulse_unitary function; to find an optimized pulse sequence for the desired quantum circuit.; The processor can simulate the evolution under the given; control pulses using qutip.mesolve.; (For attributes documentation, please; refer to the parent class Processor). Parameters. N: intThe number of component systems. drift: `:class:`qutip.Qobj`The drift Hamiltonian. The size must match the whole quantum system. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence of dephasing for; each qubit. A list of size N or a float for all qubits. dims: listThe dimension of each component system.; Default value is a; qubit system of dim=[2,2,2,...,2]. add_control(qobj, targets=None, cyclic_permutation=False, label=None)¶; Add a control Hamiltonian to the processor. It creates a ne",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:134655,Availability,toler,tolerance,134655,"rs. args: dict, optionalArguments for qutip.QobjEvo. noisy: bool, optionalIf noise are included. Default is False. Returns. qobjevo: qutip.QobjEvoThe qutip.QobjEvo representation of the unitary evolution. c_ops: list of qutip.QobjEvoA list of lindblad operators is also returned. if noisy==Flase,; it is always an empty list. load_circuit(qc, min_fid_err=inf, merge_gates=True, setting_args=None, verbose=False, **kwargs)[source]¶; Find the pulses realizing a given; QubitCircuit using; qutip.control.optimize_pulse_unitary. Further parameter for; for qutip.control.optimize_pulse_unitary needs to be given as; keyword arguments. By default, it first merge all the gates; into one unitary and then find the control pulses for it.; It can be turned off and one can set different parameters; for different gates. See examples for details. Parameters. qc: :class:`.QubitCircuit` or list of QobjThe quantum circuit to be translated. min_fid_err: float, optionalThe minimal fidelity tolerance, if the fidelity error of any; gate decomposition is higher, a warning will be given.; Default is infinite. merge_gates: boolean, optimalIf True, merge all gate/Qobj into one Qobj and then; find the optimal pulses for this unitary matrix. If False,; find the optimal pulses for each gate/Qobj. setting_args: dict, optionalOnly considered if merge_gates is False.; It is a dictionary containing keyword arguments; for different gates.; E.g.:; setting_args = {""SNOT"": {""num_tslots"": 10, ""evo_time"": 1},; ""SWAP"": {""num_tslots"": 30, ""evo_time"": 3},; ""CNOT"": {""num_tslots"": 30, ""evo_time"": 3}}. verbose: boolean, optionalIf true, the information for each decomposed gate; will be shown. Default is False. **kwargskeyword arguments for qutip.control.optimize_pulse_unitary. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)-1). Each; row corresponds to the control pulse sequence for; one Hamiltonian. Notes; len(tlis",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:134682,Availability,error,error,134682,"rs. args: dict, optionalArguments for qutip.QobjEvo. noisy: bool, optionalIf noise are included. Default is False. Returns. qobjevo: qutip.QobjEvoThe qutip.QobjEvo representation of the unitary evolution. c_ops: list of qutip.QobjEvoA list of lindblad operators is also returned. if noisy==Flase,; it is always an empty list. load_circuit(qc, min_fid_err=inf, merge_gates=True, setting_args=None, verbose=False, **kwargs)[source]¶; Find the pulses realizing a given; QubitCircuit using; qutip.control.optimize_pulse_unitary. Further parameter for; for qutip.control.optimize_pulse_unitary needs to be given as; keyword arguments. By default, it first merge all the gates; into one unitary and then find the control pulses for it.; It can be turned off and one can set different parameters; for different gates. See examples for details. Parameters. qc: :class:`.QubitCircuit` or list of QobjThe quantum circuit to be translated. min_fid_err: float, optionalThe minimal fidelity tolerance, if the fidelity error of any; gate decomposition is higher, a warning will be given.; Default is infinite. merge_gates: boolean, optimalIf True, merge all gate/Qobj into one Qobj and then; find the optimal pulses for this unitary matrix. If False,; find the optimal pulses for each gate/Qobj. setting_args: dict, optionalOnly considered if merge_gates is False.; It is a dictionary containing keyword arguments; for different gates.; E.g.:; setting_args = {""SNOT"": {""num_tslots"": 10, ""evo_time"": 1},; ""SWAP"": {""num_tslots"": 30, ""evo_time"": 3},; ""CNOT"": {""num_tslots"": 30, ""evo_time"": 3}}. verbose: boolean, optionalIf true, the information for each decomposed gate; will be shown. Default is False. **kwargskeyword arguments for qutip.control.optimize_pulse_unitary. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)-1). Each; row corresponds to the control pulse sequence for; one Hamiltonian. Notes; len(tlis",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:140534,Availability,avail,available,140534,"onentiation. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. solver: str“mesolve” or “mcsolve”. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.solver.ResultIf analytical is False, an instance of the class; qutip.solver.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. class ModelProcessor(N, correct_global_phase=True, t1=None, t2=None)[source]¶; The base class for a circuit processor simulating a physical device,; e.g cavityQED, spinchain.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It cannot be used alone, please refer to the sub-classes.; (Only additional attributes are documented here, for others please; refer to the parent class Processor). Parameters. N: intThe number of component systems. correct_global_phase: boolean, optionalIf true, the analytical solution will track the global phase. It; has no effect on the numerical solution. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence of dephasing for; each qubit. A list of size N or a float for all qubits. Attributes. params: dictA Python dictionary contains the name and the value of the parameters; in the physical realization, such as laser frequency, detuning etc. correct_global_phase: floatSave the global phase, the analytical solution; will track t",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:149568,Availability,avail,available,149568,"nstance of the class; qutip.solver.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_params()[source]¶; Save the parameters in the attribute params and check the validity.; (Defined in subclasses); Notes; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)[source]¶; Transfer a parameter to an array. class SpinChain(N, correct_global_phase, sx, sz, sxsy, t1, t2)[source]¶; The processor based on the physical implementation of; a spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It is a base class and should not be used directly, please; refer the the subclasses qutip.qip.device.LinearSpinChain and; qutip.qip.device.CircularSpinChain.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe epsilon for each of the qubits in the system. sxsy: int or listThe interaction strength for each of the qubit pair in the system. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:160985,Availability,avail,available,160985,"p_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class LinearSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the physical implementation of; a linear spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe epsilon for each of the qubits in the system. sxsy: int or listThe interaction strength for each of the qubit pair in the system. t1: list or float, optionalCharacterize the decoherence of amplitude damping for; each qubit. t2: list of float, optionalCharacterize the decoherence of dephasing for; each qubit. add_control(qobj, targets=None, cyclic_permutation=False, label=None)¶; Add a control Hamiltonian to the processor. It creates a new; Pulse; object for the device that is turned off; (tlist = None, coeff = None). To activate the pulse, one; can set its tlist and coe",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:171441,Availability,avail,available,171441,"ource]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class CircularSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the physical implementation of; a circular spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe epsilon for each of the qubits in the system. sxsy: int or listThe interaction strength for each of the qubit pair in the system. t1: list or float, optionalCharacterize the decoherence of amplitude damping for; each qubit. t2: list of float, optionalCharacterize the decoherence of dephasing for; each qubit. add_control(qobj, targets=None, cyclic_permutation=False, label=None)¶; Add a control Hamiltonian to the processor. It creates a new; Pulse; object for the device that is turned off; (tlist = None, coeff = None). To activate the pulse, one; can set its tlist and coe",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:181956,Availability,avail,available,181956,"and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class DispersiveCavityQED(N, correct_global_phase=True, num_levels=10, deltamax=1.0, epsmax=9.5, w0=10.0, wq=None, eps=9.5, delta=0.0, g=0.01, t1=None, t2=None)[source]¶; The processor based on the physical implementation of; a dispersive cavity QED system.; The available Hamiltonian of the system is predefined.; For a given pulse amplitude matrix, the processor can; calculate the state evolution under the given control pulse,; either analytically or numerically.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_phase: float, optionalSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. num_levels: int, optionalThe number of energy levels in the resonator. deltamax: int or list, optionalThe coefficients of sigma-x for each of the qubits in the system. epsmax: int or list, optionalThe coefficients of sigma-z for each of the qubits in the system. w0: int, optionalThe base frequency of the resonator. eps: int or list, optionalThe epsilon for each of the qubits in the system. delta: int or list, optionalThe epsilon for each of the qubits in the system. g: int or list, optio",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:197234,Availability,avail,available,197234,"rize the decoherence of amplitude damping for; each qubit. t2: float or listCharacterize the decoherence of dephasing for; each qubit. targets: int or listThe indices of qubits that are acted on. get_noisy_dynamics(dims=None, pulses=None, systematic_noise=None)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dummy Pulse object. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits system. pulses: list of :class:`.Pulse`The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`The dummy pulse with no ideal control element. Returns. noisy_pulses: list of PulseNoisy pulses. systematic_noise: PulseThe dummy pulse representing pulse independent noise. class ControlAmpNoise(coeff, tlist=None, indices=None)[source]¶; The noise in the amplitude of the control pulse. Parameters. coeff: listA list of the coefficients for the control Hamiltonians.; For available choices, see qutip.QobjEvo. tlist: array_like, optionalA NumPy array specifies the time of each coefficient. indices: list of int, optionalThe indices of target pulse in the list of pulses. Attributes; ———-; coeff: listA list of the coefficients for the control Hamiltonians.; For available choices, see qutip.QobjEvo. tlist: array_likeA NumPy array specifies the time of each coefficient. indices: list of intThe indices of target pulse in the list of pulses. get_noisy_dynamics(dims=None, pulses=None, systematic_noise=None)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dummy Pulse object. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits system. pulses: list of :class:`.Pulse`The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`The dummy pulse with no ideal control element. Returns. noisy_pulses: list of PulseNoisy pulses. systematic_noise: PulseT",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:197525,Availability,avail,available,197525,"t added with noise and; the pulse independent noise in a dummy Pulse object. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits system. pulses: list of :class:`.Pulse`The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`The dummy pulse with no ideal control element. Returns. noisy_pulses: list of PulseNoisy pulses. systematic_noise: PulseThe dummy pulse representing pulse independent noise. class ControlAmpNoise(coeff, tlist=None, indices=None)[source]¶; The noise in the amplitude of the control pulse. Parameters. coeff: listA list of the coefficients for the control Hamiltonians.; For available choices, see qutip.QobjEvo. tlist: array_like, optionalA NumPy array specifies the time of each coefficient. indices: list of int, optionalThe indices of target pulse in the list of pulses. Attributes; ———-; coeff: listA list of the coefficients for the control Hamiltonians.; For available choices, see qutip.QobjEvo. tlist: array_likeA NumPy array specifies the time of each coefficient. indices: list of intThe indices of target pulse in the list of pulses. get_noisy_dynamics(dims=None, pulses=None, systematic_noise=None)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dummy Pulse object. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits system. pulses: list of :class:`.Pulse`The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`The dummy pulse with no ideal control element. Returns. noisy_pulses: list of PulseNoisy pulses. systematic_noise: PulseThe dummy pulse representing pulse independent noise. class RandomNoise(dt, rand_gen, indices=None, **kwargs)[source]¶; Random noise in the amplitude of the control pulse. The arguments for; the random generator need to be given as key word arguments. Parameters. dt: float, optionalThe time ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:220870,Availability,error,error,220870,"log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_paramsDictionaryOptions for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_gradboolIf set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:224753,Availability,error,error,224753,"an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:225131,Availability,error,error,225131,"uring the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; Thi",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:225308,Availability,error,error,225308,"f they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimi",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:226556,Availability,error,error,226556,"ed as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algor",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:227738,Availability,error,error,227738,"l time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m ar",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:229094,Availability,error,error,229094,"ns; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses t",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:230287,Availability,error,error,230287,"f the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fid",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:230850,Availability,error,error,230850," None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It wil",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:231300,Availability,error,error,231300,"ptim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. Attributes. iter_numintIteration number of the pulse optimisation. fid_func_call_numintFidelity function call number of the pulse optimisation. grad_func_call_numintGradient function call number of the pulse optimisation. fid_errfloatFidelity error",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:232390,Availability,error,error,232390,"s which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. Attributes. iter_numintIteration number of the pulse optimisation. fid_func_call_numintFidelity function call number of the pulse optimisation. grad_func_call_numintGradient function call number of the pulse optimisation. fid_errfloatFidelity error. grad_normfloatfidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_timefloatTime spent computing the pulse optimisation so far; (in seconds of elapsed time). class TerminationConditions[source]¶; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes. fid_err_targfloatTarget fidelity error. fid_goalfloatgoal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_timefloat# maximum time for optimisation (seconds). min_gradient_normfloatMinimum normalised gradient after which optimisation will terminate. max_iterationsintegerMaximum iterations of the optimisation algorithm. max_fid_func_callsintegerMaximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.;",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:232879,Availability,error,error,232879,"It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. Attributes. iter_numintIteration number of the pulse optimisation. fid_func_call_numintFidelity function call number of the pulse optimisation. grad_func_call_numintGradient function call number of the pulse optimisation. fid_errfloatFidelity error. grad_normfloatfidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_timefloatTime spent computing the pulse optimisation so far; (in seconds of elapsed time). class TerminationConditions[source]¶; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes. fid_err_targfloatTarget fidelity error. fid_goalfloatgoal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_timefloat# maximum time for optimisation (seconds). min_gradient_normfloatMinimum normalised gradient after which optimisation will terminate. max_iterationsintegerMaximum iterations of the optimisation algorithm. max_fid_func_callsintegerMaximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. Attribut",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:234042,Availability,error,error,234042,"onds). min_gradient_normfloatMinimum normalised gradient after which optimisation will terminate. max_iterationsintegerMaximum iterations of the optimisation algorithm. max_fid_func_callsintegerMaximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. Attributes. termination_reasonstringDescription of the reason for terminating the optimisation. fidelityfloatfinal (normalised) fidelity that was achieved. initial_fid_errfloatfidelity error before optimisation starting. fid_errfloatfinal fidelity error that was achieved. goal_achievedbooleanTrue is the fidely error achieved was below the target. grad_norm_finalfloatFinal value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reachedfloatTrue if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exceededbooleanTrue if the iteration limit was reached. max_fid_func_exceededbooleanTrue if the fidelity function call limit was reached. wall_timefloattime elapsed during the optimisation. wall_time_limit_exceededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:234105,Availability,error,error,234105,"ter which optimisation will terminate. max_iterationsintegerMaximum iterations of the optimisation algorithm. max_fid_func_callsintegerMaximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. Attributes. termination_reasonstringDescription of the reason for terminating the optimisation. fidelityfloatfinal (normalised) fidelity that was achieved. initial_fid_errfloatfidelity error before optimisation starting. fid_errfloatfinal fidelity error that was achieved. goal_achievedbooleanTrue is the fidely error achieved was below the target. grad_norm_finalfloatFinal value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reachedfloatTrue if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exceededbooleanTrue if the iteration limit was reached. max_fid_func_exceededbooleanTrue if the fidelity function call limit was reached. wall_timefloattime elapsed during the optimisation. wall_time_limit_exceededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the end of the optimisation. evo_full_finalQobjThe evolution o",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:234169,Availability,error,error,234169,"mum iterations of the optimisation algorithm. max_fid_func_callsintegerMaximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. Attributes. termination_reasonstringDescription of the reason for terminating the optimisation. fidelityfloatfinal (normalised) fidelity that was achieved. initial_fid_errfloatfidelity error before optimisation starting. fid_errfloatfinal fidelity error that was achieved. goal_achievedbooleanTrue is the fidely error achieved was below the target. grad_norm_finalfloatFinal value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reachedfloatTrue if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exceededbooleanTrue if the iteration limit was reached. max_fid_func_exceededbooleanTrue if the fidelity function call limit was reached. wall_timefloattime elapsed during the optimisation. wall_time_limit_exceededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the end of the optimisation. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initia",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:234294,Availability,error,error,234294,"alls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. Attributes. termination_reasonstringDescription of the reason for terminating the optimisation. fidelityfloatfinal (normalised) fidelity that was achieved. initial_fid_errfloatfidelity error before optimisation starting. fid_errfloatfinal fidelity error that was achieved. goal_achievedbooleanTrue is the fidely error achieved was below the target. grad_norm_finalfloatFinal value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reachedfloatTrue if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exceededbooleanTrue if the iteration limit was reached. max_fid_func_exceededbooleanTrue if the fidelity function call limit was reached. wall_timefloattime elapsed during the optimisation. wall_time_limit_exceededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the end of the optimisation. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initialQobjThe evolution operator from t=0 to t=T based on the initial amps. statsStatsObject con",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:237282,Availability,error,error,237282,"es of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:237305,Availability,error,error,237305,"es of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:253143,Availability,error,error,253143,"hat the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evobooleanflag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evoboolean; flag to specify whether the onto_evo evolution operator(see Dynamics) is used by the FidelityComputer. fid_errfloatLast computed value of the fidelity error. fidelityfloatLast computed value of the normalised fidelity. fidelity_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of floatLast computed values for the fidelity error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[so",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:253447,Availability,error,error,253447,"tion,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evobooleanflag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evoboolean; flag to specify whether the onto_evo evolution operator(see Dynamics) is used by the FidelityComputer. fid_errfloatLast computed value of the fidelity error. fidelityfloatLast computed value of the normalised fidelity. fidelity_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of floatLast computed values for the fidelity error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelit",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:253560,Availability,error,error,253560," file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evobooleanflag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evoboolean; flag to specify whether the onto_evo evolution operator(see Dynamics) is used by the FidelityComputer. fid_errfloatLast computed value of the fidelity error. fidelityfloatLast computed value of the normalised fidelity. fidelity_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of floatLast computed values for the fidelity error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:254429,Availability,error,error,254429,"ues for the fidelity error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. c",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:254761,Availability,error,error,254761,"itudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the a",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:255757,Availability,error,error,255757,"putes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:255861,Availability,error,error,255861,"der). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:257612,Availability,error,error,257612,"f the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:257692,Availability,error,error,257692,"f the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:258170,Availability,error,error,258170,"ent_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configurati",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:258261,Availability,error,error,258261,"data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses th",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:258514,Availability,error,error,258514," - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control ampli",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:258709,Availability,error,error,258709,"as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned a",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:258813,Availability,error,error,258813,"ance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:273289,Availability,error,error,273289,"ll_time_optim_startfloatStart time for the optimisation. wall_time_optim_endfloatEnd time for the optimisation. wall_time_optimfloatTime elasped during the optimisation. wall_time_dyn_gen_computefloatTotal wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_computefloatTotal wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_computefloatTotal wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating the propagators themselves. wall_time_onwd_prop_computefloatTotal wall (elasped) time computing combined onward propagation,; that is the time evolution from a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_computefloatTotal wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_callsintegerNumber of calls to fidelity function by the optimisation algorithm. num_grad_func_callsintegerNumber of calls to gradient function by the optimisation algorithm. num_tslot_recomputeintegerNumber of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computesintegerNumber of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computesintegerNumber of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updatesintegerNumber of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iterfloatMean number of control amplitude updates per iteration. num_timeslot_changesintegerNumber of times the amplitudes of a any control in a timeslot",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:276878,Availability,error,error,276878,"limiter for the summary file.; default is a space. data_sepstrdelimiter for the data files (arrays saved to file).; default is a space. summary_filestrFile path for summary file.; Automatically generated. Can be set specifically. create_dump_dir()[source]¶; Checks dump directory exists, creates it if not. property level¶; The level of data dumping that will occur. SUMMARYA summary will be recorded. FULLAll possible dumping. CUSTOMSome customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of qutip.control.optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:19911,Deployability,update,updated,19911," The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; args = {""_step_func_coeff"": True}. Examples of array-format usage are:; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; QobjEvo that contains different tlist values, however.; Passing arguments; args is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string.; There are some “magic” names that can be specified, whose objects will be; overwritten when used within sesolve, mesolve and; mcsolve. This allows access to the solvers’ internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. ""state"": the current state as a Qobj; ""state_vec"": the current state as a column-stacked 1D np.ndarray; ""state_mat"": the current state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers. Replace <n> with; an integer literal, e.g. ""expect_op_0"". This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first paramete",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:45899,Deployability,install,installed,45899,"ll ADOs. Returns. qutip.solver.ResultThe results of the simulation run, with the following attributes:. times: the times t (i.e. the tlist).; states: the system state at each time t (only available; if e_ops was None or if the solver option; store_states was set to True).; ado_states: the full ADO state at each time (only available; if ado_return was set to True). Each element is an; instance of HierarchyADOsState. .; The state of a particular ADO may be extracted from; result.ado_states[i] by calling extract.; expect: the value of each e_ops at time t (only; available if e_ops were given). If e_ops was passed; as a dictionary, then expect will be a dictionary with; the same keys as e_ops and values giving the list of; outcomes for the corresponding key. steady_state(use_mkl=True, mkl_max_iter_refine=100, mkl_weighted_matching=False)[source]¶; Compute the steady state of the system. Parameters. use_mklbool, default=FalseWhether to use mkl or not. If mkl is not installed or if; this is false, use the scipy splu solver instead. mkl_max_iter_refineintSpecifies the the maximum number of iterative refinement steps that; the MKL PARDISO solver performs.; For a complete description, see iparm(8) in; http://cali2.unilim.fr/intel-xe/mkl/mklman/GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF.htm. mkl_weighted_matchingboolMKL PARDISO can use a maximum weighted matching algorithm to; permute large elements close the diagonal. This strategy adds an; additional level of reliability to the factorization methods.; For a complete description, see iparm(13) in; http://cali2.unilim.fr/intel-xe/mkl/mklman/GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF.htm. Returns. steady_stateQobjThe steady state density matrix of the system. steady_adosHierarchyADOsStateThe steady state of the full ADO hierarchy. A particular ADO may be; extracted from the full state by calling extract. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, bnd_cut_approx=False, options=None, progres",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:72874,Deployability,integrat,integrate,72874,"=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; C",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:73010,Deployability,integrat,integrator,73010,"bed in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., l",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:73923,Deployability,integrat,integratorstr,73923,"yCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse o",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:74099,Deployability,integrat,integrator,74099,"e simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). Returns. : complexexpectation",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:74173,Deployability,integrat,integrator,74173,"ed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). Returns. : complexexpectation value of field correlation function. outfieldpropagato",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:78740,Deployability,integrat,integrator,78740,"]¶; Contain and compute expectation values. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, steady_state_average=False, seeds=None, normalize_output=True, use_openmp=None, openmp_threads=None)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes. atolfloat {1e-8}Absolute tolerance. rtolfloat {1e-6}Relative tolerance. methodstr {‘adams’,’bdf’}Integration method. orderint {12}Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nstepsint {2500}Max. number of internal steps/call. first_stepfloat {0}Size of initial step (0 = automatic). min_stepfloat {0}Minimum step size (0 = automatic). max_stepfloat {0}Maximum step size (0 = automatic). tidybool {True,False}Tidyup Hamiltonian and initial state by removing small terms. num_cpusintNumber of cpus used by mcsolver (default = # of cpus). norm_tolfloatTolerance used when finding wavefunction norm in mcsolve. norm_stepsintMax. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_statesbool {False}Average states values over trajectories in stochastic solvers. average_expectbool {True}Average expectation values over trajectories for stochastic solvers. mc_corr_epsfloat {1e-10}Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve. ntrajint {500}Number of trajectories in stochastic solvers. openmp_threadsintNumber of OPENMP threads to use. Default",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:93075,Deployability,integrat,integrate,93075,"pled basis.; default: (nds, nds). c_ops()[source]¶; Build collapse operators in the full Hilbert space 2^N. Returns. c_ops_list: listThe list with the collapse operators in the 2^N Hilbert space. coefficient_matrix()[source]¶; Build coefficient matrix for ODE for a diagonal problem. Returns. M: ndarrayThe matrix M of the coefficients for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis. lindbladian()[source]¶; Build the Lindbladian superoperator of the dissipative dynamics. Returns. lindbladianqutip.QobjThe Lindbladian matrix as a qutip.Qobj. liouvillian()[source]¶; Build the total Liouvillian using the Dicke basis. Returns. liouvqutip.QobjThe Liouvillian matrix for the system. pisolve(initial_state, tlist, options=None)[source]¶; Solve for diagonal Hamiltonians and initial states faster. Parameters. initial_statequtip.QobjAn initial state specified as a density matrix of; qutip.Qbj type. tlist: ndarrayA 1D numpy array of list of timesteps to integrate. optionsqutip.solver.OptionsThe options for the solver. Returns. result: listA dictionary of the type qutip.solver.Result which holds the; results of the evolution. class Pim(N, emission=0.0, dephasing=0, pumping=0, collective_emission=0, collective_pumping=0, collective_dephasing=0)[source]¶; The Permutation Invariant Matrix class.; Initialize the class with the parameters for generating a Permutation; Invariant matrix which evolves a given diagonal initial state p as:. dp/dt = Mp. Parameters. N: intThe number of two-level systems. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: floatLocal dephasing coefficient.; default: 0.0. pumping: floatIncoherent pumping coefficient.; default: 0.0. collective_emission: floatCollective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: floatCollective pumping coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coeff",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:107584,Deployability,update,update,107584," 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. figmatplotlib Figure instanceIf given, use this figure instance for the visualization,. axmatplotlib Axes instanceIf given, render the visualization using this axis instance. figsizetupleSize of the new Figure instance, if one needs to be created. colorbar: BoolWhether or not the colorbar (in 2D visualization) should be used. cmap: matplotlib colormap instanceIf given, use this colormap for 2D visualizations. stylestringType of visualization: ‘colormap’ (default) or ‘surface’. Returns. fig, axtupleA tuple of matplotlib figure and axes instances. class WignerDistribution(rho=None, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. class QDistribution(rho=None, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. update(state)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(psi)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(rho)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[- 5, 5], steps=250)[source]¶. update(psi)[source]¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[- 5, 5], steps=250)[source]¶. update(rho)[source]¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(*args, **kwargs)[source]¶; Representation of a quantum gate, with its required parameters, and target; and control qubits. Parameters. namestringGate name. targetslist or intGate targets. controlslist o",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:108085,Deployability,update,update,108085,"map for 2D visualizations. stylestringType of visualization: ‘colormap’ (default) or ‘surface’. Returns. fig, axtupleA tuple of matplotlib figure and axes instances. class WignerDistribution(rho=None, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. class QDistribution(rho=None, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. update(state)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(psi)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(rho)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[- 5, 5], steps=250)[source]¶. update(psi)[source]¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[- 5, 5], steps=250)[source]¶. update(rho)[source]¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(*args, **kwargs)[source]¶; Representation of a quantum gate, with its required parameters, and target; and control qubits. Parameters. namestringGate name. targetslist or intGate targets. controlslist or intGate controls. arg_valuefloatArgument value(phi). arg_labelstringLabel for gate representation. classical_controlsint or list of int, optionalindices of classical bits to control gate on. control_valueint, optionalvalue of classical bits to control on, the classical controls are; interpreted as an integer with lowest bit being the first one.; If not specified, then the value is interpreted to be; 2 ** len(classical_controls) - 1 (i.e. all classical controls are 1). cl",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:108285,Deployability,update,update,108285," 5], [- 5, 5]], steps=250)[source]¶. class QDistribution(rho=None, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. update(state)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(psi)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(rho)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[- 5, 5], steps=250)[source]¶. update(psi)[source]¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[- 5, 5], steps=250)[source]¶. update(rho)[source]¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(*args, **kwargs)[source]¶; Representation of a quantum gate, with its required parameters, and target; and control qubits. Parameters. namestringGate name. targetslist or intGate targets. controlslist or intGate controls. arg_valuefloatArgument value(phi). arg_labelstringLabel for gate representation. classical_controlsint or list of int, optionalindices of classical bits to control gate on. control_valueint, optionalvalue of classical bits to control on, the classical controls are; interpreted as an integer with lowest bit being the first one.; If not specified, then the value is interpreted to be; 2 ** len(classical_controls) - 1 (i.e. all classical controls are 1). class Measurement(name, targets=None, index=None, classical_store=None)[source]¶; Representation of a quantum measurement, with its required parameters,; and target qubits. Parameters. namestringMeasurement name. tar",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:207311,Deployability,continuous,continuous,207311,"nction; compile calls compiling method from the sub-class and concatenate; the compiled pulses. Parameters. N: intThe number of the component systems. params: dict, optionalA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; (pulse_label, coeff), instead of (pulse_index, coeff).; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. gate_compiler: dictThe Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dictArguments for individual compiling routines.; It adds more flexibility in customizing compiler. compile(circuit, schedule_mode=None, args=None)[source]¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_com",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:219706,Deployability,configurat,configuration,219706,"hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. targets: list, optionalThe target qubits. controls: list, optionalThe control qubits. used_qubits: setUnion of the control and target qubits. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:222252,Deployability,configurat,configuration,222252,"rapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpqutip.control.dump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file i",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:225073,Deployability,update,update,225073,"uring the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; Thi",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:225671,Deployability,update,update,225671,"c_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:226198,Deployability,configurat,configuration,226198,"get, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:228972,Deployability,configurat,configuration,228972,"l minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which inclu",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:230592,Deployability,configurat,configuration,230592,"ablished implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall t",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:237091,Deployability,update,updated,237091,"ultiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:245322,Deployability,configurat,configuration,245322,"ion operators (Qobj) from the initial to the given; timeslot. get_ctrl_dyn_gen(j)[source]¶; Get the dynamics generator for the control; Not implemented in the base class. Choose a subclass. get_drift_dim()[source]¶; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N. get_dyn_gen(k)[source]¶; Get the combined dynamics generator for the timeslot; Not implemented in the base class. Choose a subclass. get_num_ctrls()[source]¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. init_timeslots()[source]¶; Generate the timeslot duration array ‘tau’ based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array ‘time’ based on the tau values. initialize_controls(amps, init_tslots=True)[source]¶; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated. property num_ctrls¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. property onto_evo¶; List of evolution operators (Qobj) from the initial to the given; timeslot. property onwd_evo¶; List of evolution operators (Qobj) from the initial to the given; timeslot. property phase_application¶; scalar(string), default=’preop’; Determines how the phase is applied to the dynamics generators. ‘preop’ : P = expm(phase*dyn_gen); ‘postop’ : P = expm(dyn_gen*phase); ‘custom’ : Customised phase application. The ‘custom’ option assumes that the _apply_phase method has been; set to a custom function. Type; phase_application. property prop¶; List of propagators (Qobj) for each timeslot. property prop_grad¶; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs()[source]¶; Reset ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:248706,Deployability,configurat,configuration,248706,"amics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes. drift_hamQobjThis is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_hamList of QobjThese are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. HList of QobjThe combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls. check_unitarity()[source]¶; Checks whether all propagators are unitary; For propagators found not to be unitary, the potential underlying; causes are investigated. initialize_controls(amplitudes, init_tslots=True)[source]¶; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated. property num_ctrls¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. class DynamicsSymplectic(optimconfig, params=None)[source]¶; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes. omegaarray[drift_dyn_gen.shape]matrix used in the calculation of propagators (time evolution); with symplectic systems. property dyn_gen_phase¶; The phasing operator for the symplectic group generators; usually refered to as Omega; By default this is applied as ‘postop’ dyn_gen*-Omega; If phase_application is ‘preop’ it is applied as Omega*dyn_gen. class PropagatorComputer(dynamics, params=None)[source]¶; Base for all Propagator Computer classes; that are used to calculate the propagators,; and a",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:250971,Deployability,configurat,configuration,250971,"cation. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:251247,Deployability,configurat,configuration,251247,"iet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attribute",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:251440,Deployability,configurat,configuration,251440,"es whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; a",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:251807,Deployability,configurat,configuration,251807,"ey value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See SU",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:254566,Deployability,configurat,configuration,254566," fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradie",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:254625,Deployability,configurat,configuration,254625," to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_c",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:255987,Deployability,update,updates,255987,"der). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:256448,Deployability,configurat,configuration,256448,"culates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phas",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:257312,Deployability,configurat,configuration,257312,"tion uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:258939,Deployability,update,updates,258939,"ance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:259058,Deployability,configurat,configuration,259058,"erik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelinteg",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:259165,Deployability,configurat,configuration,259165,"ated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:259761,Deployability,configurat,configuration,259761,"ormalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summaryEvoCompSummaryA summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:261236,Deployability,update,updated,261236,"g_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summaryEvoCompSummaryA summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dump_current()[source]¶; Store a copy of the current time evolution. class TSlotCompUpdateAll(dynamics, params=None)[source]¶; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated. compare_amps(new_amps)[source]¶; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed. get_timeslot_for_fidelity_calc()[source]¶; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot. recompute_evolution()[source]¶; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary. class PulseGen(dyn=None, params=None)[source]¶; Pulse generator; Base class for all Pulse generators; The object can optionally be instantiated with a Dynamics object,; in which case the timeslots and amplitude scaling and offset; are copied from that.; Otherwise the class can be used independently by setting:; tau (array of timeslot durations); or; num_tslot",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:271843,Deployability,configurat,configurations,271843,"om the optimisation method; Typically this will be the basis coefficients. class PulseGenCrabFourier(dyn=None, num_coeffs=None, params=None)[source]¶; Generates a pulse using the Fourier basis functions, i.e. sin and cos. Attributes. freqsfloat array[num_coeffs]Frequencies for the basis functions. randomize_freqsboolIf True (default) the some random offset is applied to the frequencies. gen_pulse(coeffs=None)[source]¶; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters. coeffsfloat array[num_coeffs, num_basis_funcs]The basis coefficient values; If given this overides the default and sets the attribute; of the same name. init_freqs()[source]¶; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset. init_pulse(num_coeffs=None)[source]¶; Set the initial freq and coefficient values. reset()[source]¶; reset attributes to default values. class Stats[source]¶; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes. dyn_gen_namestringText used in some report functions.; Makes sense to set it to ‘Hamiltonian’ when using unitary dynamics; Default is simply ‘dynamics generator’. num_iterintegerNumber of iterations of the optimisation algorithm. wall_time_optim_startfloatStart time for the optimisation. wall_time_optim_endfloatEnd time for the optimisation. wall_time_optimfloatTime elasped during the optimisation. wall_time_dyn_gen_computefloatTotal wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_computefloatTotal wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_computefloatTotal wall (elasped) time com",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:271882,Deployability,update,updated,271882,"om the optimisation method; Typically this will be the basis coefficients. class PulseGenCrabFourier(dyn=None, num_coeffs=None, params=None)[source]¶; Generates a pulse using the Fourier basis functions, i.e. sin and cos. Attributes. freqsfloat array[num_coeffs]Frequencies for the basis functions. randomize_freqsboolIf True (default) the some random offset is applied to the frequencies. gen_pulse(coeffs=None)[source]¶; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters. coeffsfloat array[num_coeffs, num_basis_funcs]The basis coefficient values; If given this overides the default and sets the attribute; of the same name. init_freqs()[source]¶; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset. init_pulse(num_coeffs=None)[source]¶; Set the initial freq and coefficient values. reset()[source]¶; reset attributes to default values. class Stats[source]¶; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes. dyn_gen_namestringText used in some report functions.; Makes sense to set it to ‘Hamiltonian’ when using unitary dynamics; Default is simply ‘dynamics generator’. num_iterintegerNumber of iterations of the optimisation algorithm. wall_time_optim_startfloatStart time for the optimisation. wall_time_optim_endfloatEnd time for the optimisation. wall_time_optimfloatTime elasped during the optimisation. wall_time_dyn_gen_computefloatTotal wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_computefloatTotal wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_computefloatTotal wall (elasped) time com",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:274064,Deployability,update,updated,274064,"ll (elasped) time computing combined onward propagation,; that is the time evolution from a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_computefloatTotal wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_callsintegerNumber of calls to fidelity function by the optimisation algorithm. num_grad_func_callsintegerNumber of calls to gradient function by the optimisation algorithm. num_tslot_recomputeintegerNumber of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computesintegerNumber of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computesintegerNumber of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updatesintegerNumber of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iterfloatMean number of control amplitude updates per iteration. num_timeslot_changesintegerNumber of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_updatefloatMean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changesintegerNumber of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_updatefloatMean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes. parentsome control object (Dynamics or Optimizer)aka the host. Object that generates the data that is dumped and is; hos",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:274145,Deployability,update,updates,274145,om a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_computefloatTotal wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_callsintegerNumber of calls to fidelity function by the optimisation algorithm. num_grad_func_callsintegerNumber of calls to gradient function by the optimisation algorithm. num_tslot_recomputeintegerNumber of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computesintegerNumber of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computesintegerNumber of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updatesintegerNumber of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iterfloatMean number of control amplitude updates per iteration. num_timeslot_changesintegerNumber of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_updatefloatMean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changesintegerNumber of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_updatefloatMean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes. parentsome control object (Dynamics or Optimizer)aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dirstrdirectory where files (if any) will be written out; t,MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:274371,Deployability,update,update,274371,ating the propagator gradients (in exact gradient; methods). num_fidelity_func_callsintegerNumber of calls to fidelity function by the optimisation algorithm. num_grad_func_callsintegerNumber of calls to gradient function by the optimisation algorithm. num_tslot_recomputeintegerNumber of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computesintegerNumber of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computesintegerNumber of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updatesintegerNumber of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iterfloatMean number of control amplitude updates per iteration. num_timeslot_changesintegerNumber of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_updatefloatMean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changesintegerNumber of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_updatefloatMean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes. parentsome control object (Dynamics or Optimizer)aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dirstrdirectory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. levelstri,MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:274574,Deployability,update,update,274574,gradient function by the optimisation algorithm. num_tslot_recomputeintegerNumber of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computesintegerNumber of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computesintegerNumber of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updatesintegerNumber of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iterfloatMean number of control amplitude updates per iteration. num_timeslot_changesintegerNumber of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_updatefloatMean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changesintegerNumber of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_updatefloatMean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes. parentsome control object (Dynamics or Optimizer)aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dirstrdirectory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. levelstringThe level of data dumping that will occur. write_to_fileboolWhen set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by th,MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:280474,Deployability,update,updated,280474,"olIf True forward evolution operators are dumped. dump_onwd_evoboolIf True onward evolution operators are dumped. dump_onto_evoboolIf True onto (or backward) evolution operators are dumped. evo_dumpslist of EvoCompDumpItemA new dump item is appended at each recomputation of the evolution.; That is if any of the calculation objects are to be dumped. add_evo_comp_summary(dump_item_idx=None)[source]¶; add copy of current evo comp summary. add_evo_dump()[source]¶; Add dump of current time evolution generating objects. property dump_all¶; True if all of the calculation objects are to be dumped. property dump_any¶; True if any of the calculation objects are to be dumped. writeout(f=None)[source]¶; Write all the dump items and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated in; the dump_dir. If a filehandle is specified then it must be a byte; mode file as numpy.savetxt is used, and requires this. class DumpItem[source]¶; An item in a dump list. class EvoCompDumpItem(dump)[source]¶; A copy of all objects generated to calculate one time evolution. Note the; attributes are only set if the corresponding DynamicsDump; dump_* attribute is set. writeout(f=None)[source]¶; write all the objects out to files. Parameters. ffilename or filehandleIf specified then all object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DumpSummaryItem[source]¶; A summary of the most recent iteration. Abstract class only. Attributes. idxintIndex in the summary list in which this is stored. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:11624,Energy Efficiency,efficient,efficient,11624,"solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. Notes; It is slightly more computationally efficient to use a ket; vector for the ‘bra’ input. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters. normstrWhich norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’. sparseboolUse sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tolfloatTolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used); for trace norm. Returns. normfloatThe requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(other)[source]¶; Overlap between ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:13167,Energy Efficiency,efficient,efficient,13167,"(if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used); for trace norm. Returns. normfloatThe requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(other)[source]¶; Overlap between two state vectors or two operators.; Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters. otherqutip.QobjQuantum object for a state vector of type ‘ket’, ‘bra’ or density; matrix. Returns. overlapcomplexComplex valued overlap. Raises. TypeErrorCan only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> with both vectors expressed as kets. permute(order)[source]¶; Permutes a composite quantum object. Parameters. orderlist/arrayList specifying new tensor order. Returns. Pqutip.QobjPermuted quantum object. proj()[source]¶; Form the projector from a given ket or bra vector. Parameters. Qqutip.QobjInput bra or ket vector. Returns. Pqutip.QobjProjection operator. ptrace(sel, sparse=None)[source]¶; Partial trace of the quantum object. Parameters. selint/listAn int or list of components to keep after partial trace.; The order is unimportant; no transposition will be done and the; spaces will remain in the same order in the output. Returns. operqutip.QobjQuantum object representing partial trace with selected components; remaining. Notes; This function is identical to the qutip.qobj.ptrace function; that has been deprecated. purity()[source]¶; Calculate purity of a quantum object. Returns. state_purityfloatReturns the purity of a quant",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:25291,Energy Efficiency,reduce,reduce,25291,"s to new values. compile(code=False, matched=False, dense=False, omp=0)[source]¶; Create an associated Cython object for faster usage. This function is; called automatically by the solvers. Parameters. codebool, default FalseReturn the code string generated by compilation of any strings. matchedbool, default FalseIf True, the underlying sparse matrices used to represent each; element of the type will have their structures unified. This may; include adding explicit zeros to sparse matrices, but can be faster; in some cases due to not having to deal with repeated structural; mismatches. densebool, default FalseWhether to swap to using dense matrices to back the data. ompint, optionalThe number of OpenMP threads to use when doing matrix; multiplications, if QuTiP was compiled with OpenMP. Returns. compiled_strstr(Only if code was set to True). The code-generated string of; compiled calling code. compress()[source]¶; Merge together elements that share the same time-dependence, to reduce; the number of matrix multiplications and additions that need to be done; to evaluate this object.; Modifies the object inplace. conj()[source]¶; Return the matrix elementwise conjugation. copy()[source]¶; Return a copy of this object. dag()[source]¶; Return the matrix conjugate-transpose (dagger). expect(t, state, herm=False)[source]¶; Calculate the expectation value of this operator on the given; (time-independent) state at a particular time.; This is more efficient than expect(QobjEvo(t), state). Parameters. tfloatThe time to evaluate this operator at. stateQobj or np.ndarrayThe state to take the expectation value around. hermbool, default FalseWhether this operator and the state are both Hermitian. If True,; only the real part of the result will be returned. See also. expectGeneral-purpose expectation values. mul_mat(t, mat)[source]¶; Multiply this object evaluated at time t by a matrix (from the; right). Parameters. tfloatThe time to evaluate this object at. matQobj or np.ndarrayThe ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:25761,Energy Efficiency,efficient,efficient,25761," to sparse matrices, but can be faster; in some cases due to not having to deal with repeated structural; mismatches. densebool, default FalseWhether to swap to using dense matrices to back the data. ompint, optionalThe number of OpenMP threads to use when doing matrix; multiplications, if QuTiP was compiled with OpenMP. Returns. compiled_strstr(Only if code was set to True). The code-generated string of; compiled calling code. compress()[source]¶; Merge together elements that share the same time-dependence, to reduce; the number of matrix multiplications and additions that need to be done; to evaluate this object.; Modifies the object inplace. conj()[source]¶; Return the matrix elementwise conjugation. copy()[source]¶; Return a copy of this object. dag()[source]¶; Return the matrix conjugate-transpose (dagger). expect(t, state, herm=False)[source]¶; Calculate the expectation value of this operator on the given; (time-independent) state at a particular time.; This is more efficient than expect(QobjEvo(t), state). Parameters. tfloatThe time to evaluate this operator at. stateQobj or np.ndarrayThe state to take the expectation value around. hermbool, default FalseWhether this operator and the state are both Hermitian. If True,; only the real part of the result will be returned. See also. expectGeneral-purpose expectation values. mul_mat(t, mat)[source]¶; Multiply this object evaluated at time t by a matrix (from the; right). Parameters. tfloatThe time to evaluate this object at. matQobj or np.ndarrayThe matrix that is multiplied by this object. Returns. mat: Qobj or np.ndarrayThe matrix result in the same type as the input. mul_vec(t, vec)[source]¶; Multiply this object evaluated at time t by a vector. Parameters. tfloatThe time to evaluate this object at. vecQobj or np.ndarrayThe state-vector to multiply this object by. Returns. vec: Qobj or np.ndarrayThe vector result in the same type as the input. permute(order)[source]¶; Permute the tensor structure of the underly",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:40794,Energy Efficiency,efficient,efficient,40794,"= 1024)[source]¶; Class-based method of calculating the Husimi-Q function of many different; quantum states at fixed phase-space points 0.5*g* (xvec + i*yvec).; This class has slightly higher first-usage costs than qfunc, but; subsequent operations will be several times faster. However, it can require; quite a lot of memory. Call the created object as a function to retrieve; the Husimi-Q function. Parameters. xvec, yvecarray_likex- and y-coordinates at which to calculate the Husimi-Q function. gfloat, default sqrt(2)Scaling factor for a = 0.5 * g * (x + iy). The value of g is; related to the value of hbar in the commutation relation; \([x,\,y] = i\hbar\) via \(\hbar=2/g^2\), so the default; corresponds to \(\hbar=1\). memoryreal, default 1024Size in MB that may be used internally as workspace. This class will; raise MemoryError if subsequently passed a state of sufficiently; large dimension that this bound would be exceeded. In those cases, use; qfunc with precompute_memory=None instead to force using; the slower, more memory-efficient algorithm. See also. qfunca single function version, which will involve computing several quantities multiple times in order to use less memory. Examples; Initialise the class for a square set of coordinates, with some states we; want to investigate.; >>> xvec = np.linspace(-2, 2, 101); >>> states = [qutip.rand_dm(10) for _ in [None]*10]; >>> qfunc = qutip.QFunc(xvec, xvec). Now we can calculate the Husimi-Q function over each of the states more; efficiently with:; >>> husimiq = np.array([qfunc(state) for state in states]). Cubic Spline¶. class Cubic_Spline(a, b, y, alpha=0, beta=0)[source]¶; Calculates coefficients for a cubic spline; interpolation of a given data set.; This function assumes that the data is sampled; uniformly over a given interval. Parameters. afloatLower bound of the interval. bfloatUpper bound of the interval. yndarrayFunction values at interval points. alphafloatSecond-order derivative at a. Default is 0. betaflo",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:41255,Energy Efficiency,efficient,efficiently,41255,"mi-Q function. gfloat, default sqrt(2)Scaling factor for a = 0.5 * g * (x + iy). The value of g is; related to the value of hbar in the commutation relation; \([x,\,y] = i\hbar\) via \(\hbar=2/g^2\), so the default; corresponds to \(\hbar=1\). memoryreal, default 1024Size in MB that may be used internally as workspace. This class will; raise MemoryError if subsequently passed a state of sufficiently; large dimension that this bound would be exceeded. In those cases, use; qfunc with precompute_memory=None instead to force using; the slower, more memory-efficient algorithm. See also. qfunca single function version, which will involve computing several quantities multiple times in order to use less memory. Examples; Initialise the class for a square set of coordinates, with some states we; want to investigate.; >>> xvec = np.linspace(-2, 2, 101); >>> states = [qutip.rand_dm(10) for _ in [None]*10]; >>> qfunc = qutip.QFunc(xvec, xvec). Now we can calculate the Husimi-Q function over each of the states more; efficiently with:; >>> husimiq = np.array([qfunc(state) for state in states]). Cubic Spline¶. class Cubic_Spline(a, b, y, alpha=0, beta=0)[source]¶; Calculates coefficients for a cubic spline; interpolation of a given data set.; This function assumes that the data is sampled; uniformly over a given interval. Parameters. afloatLower bound of the interval. bfloatUpper bound of the interval. yndarrayFunction values at interval points. alphafloatSecond-order derivative at a. Default is 0. betafloatSecond-order derivative at b. Default is 0. Notes; This object can be called like a normal function with a; single or array of input points at which to evaluate; the interplating function.; Habermann & Kindermann, “Multidimensional Spline Interpolation:; Theory and Applications”, Comput Econ 30, 153 (2007). Attributes. afloatLower bound of the interval. bfloatUpper bound of the interval. coeffsndarrayArray of coeffcients defining cubic spline. Non-Markovian Solvers¶. class HEOM",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:54125,Energy Efficiency,reduce,reduced,54125,"coupling; operator). See combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. classmethod combine(exponents, rtol=1e-05, atol=1e-07)[source]¶; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present.; Exponents with the same frequency are only combined if they share the; same coupling operator .Q.; Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters. exponentslist of BathExponentThe list of exponents to combine. rtolfloat, default 1e-5The relative tolerance to use to when comparing frequencies and; coupling operators. atolfloat, default 1e-7The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns. list of BathExponentThe new reduced list of exponents. class DrudeLorentzBath(Q, lam, gamma, T, Nk, combine=True, tag=None)[source]¶; A helper class for constructing a Drude-Lorentz bosonic bath from the; bath parameters (see parameters below). Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. terminator()[source]¶; Return the Matsubara terminator for the bath and the calculated; approximation discrepancy. Returns. delta: floatThe approximation discrepancy. That is, the di",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:76757,Energy Efficiency,reduce,reduced,76757,"e specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results¶. class ExpectOps(e_ops=[], super_=False)[source]¶; Contai",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:76823,Energy Efficiency,reduce,reduced,76823,"tem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results¶. class ExpectOps(e_ops=[], super_=False)[source]¶; Contain and compute expectation values. class Options(atol=1e-08, rtol=1",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:102765,Energy Efficiency,energy,energy,102765,"an of the lattice. display_lattice()[source]¶; Produces a graphic portraying the lattice symbolically with a unit cell; marked in it. Returns. inter_TQobjThe coefficient of $psi_{i,N}^{dagger}psi_{0,i+1}$, i.e. the; coupling between the two boundary sites of the two unit cells i and; i+1. display_unit_cell(label_on=False)[source]¶; Produces a graphic displaying the unit cell features with labels on if; defined by user. Also returns a dict of Qobj’s corresponding to the; labeled elements on the display. Returns. HcelldictHcell[i][j] is the Hamiltonian segment for $H_{i,j}$ labeled on the; graphic. distribute_operator(op)[source]¶; A function that returns an operator matrix that applies op to all the; cells in the 1d lattice. Parameters; op (qutip.Qobj) – Qobj representing the operator to be applied at all cells. Returns. op_Hqutip.QobjQuantum object representing the operator with op applied at all; cells. get_dispersion(knpoints=0)[source]¶; Returns dispersion relationship for the lattice with the specified; number of unit cells with a k array and a band energy array. Returns. knxanp.arrayknxA[j][0] is the jth good Quantum number k. val_knsnp.arrayval_kns[j][:] is the array of band energies of the jth band good at; all the good Quantum numbers of k. k()[source]¶; Returns the crystal momentum operator. All degrees of freedom has the; cell number at their correspondig entry in the position operator. Returns. Qobj(ks)qutip.QobjThe crystal momentum operator in units of 1/a. L is the number; of unit cells, a is the length of a unit cell which is always taken; to be 1. operator_at_cells(op, cells)[source]¶; A function that returns an operator matrix that applies op to specific; cells specified in the cells list. Parameters. opqutip.QobjQobj representing the operator to be applied at certain cells. cells: list of intThe cells at which the operator op is to be applied. Returns. Qobj(op_H)QobjQuantum object representing the operator with op applied at; the specified cells. op",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:105854,Energy Efficiency,reduce,reduced,105854,"try in the position operator. Returns. Qobj(xs)qutip.QobjThe position operator. Distribution functions¶. class Distribution(data=None, xvecs=[], xlabels=[])[source]¶; A class for representation spatial distribution functions.; The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far).; It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters. dataarray_likeData for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecslistList of arrays that spans the space for each coordinate. xlabelslistList of labels for each coordinate. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; marginal distribution. Returns. dDistributionsA new instances of Distribution that describes the marginal; distribution. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; projected distribution. Returns. dDistributionsA new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. figmatplotlib Figure instanceIf given, use this figure instance for the visualization,. axmatplotlib ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:106254,Energy Efficiency,reduce,reduced-dimensionality,106254,"ented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters. dataarray_likeData for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecslistList of arrays that spans the space for each coordinate. xlabelslistList of labels for each coordinate. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; marginal distribution. Returns. dDistributionsA new instances of Distribution that describes the marginal; distribution. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; projected distribution. Returns. dDistributionsA new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. figmatplotlib Figure instanceIf given, use this figure instance for the visualization,. axmatplotlib Axes instanceIf given, render the visualization using this axis instance. figsizetupleSize of the new Figure instance, if one needs to be created. colorbar: BoolWhether or not the colorbar (in 2D visualization) should be used. cmap: matplotlib colormap instanceIf given, use this colormap for 2D visualizations. stylestringType of visualization: ‘colormap’ (default) or ‘surface’. Returns. fig, axtu",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:182525,Energy Efficiency,energy,energy,182525,"es; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class DispersiveCavityQED(N, correct_global_phase=True, num_levels=10, deltamax=1.0, epsmax=9.5, w0=10.0, wq=None, eps=9.5, delta=0.0, g=0.01, t1=None, t2=None)[source]¶; The processor based on the physical implementation of; a dispersive cavity QED system.; The available Hamiltonian of the system is predefined.; For a given pulse amplitude matrix, the processor can; calculate the state evolution under the given control pulse,; either analytically or numerically.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_phase: float, optionalSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. num_levels: int, optionalThe number of energy levels in the resonator. deltamax: int or list, optionalThe coefficients of sigma-x for each of the qubits in the system. epsmax: int or list, optionalThe coefficients of sigma-z for each of the qubits in the system. w0: int, optionalThe base frequency of the resonator. eps: int or list, optionalThe epsilon for each of the qubits in the system. delta: int or list, optionalThe epsilon for each of the qubits in the system. g: int or list, optionalThe interaction strength for each of the qubit with the resonator. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence of dephasing for; each qubit. A list of size N or a float for all qubits. Attributes. sx_ops: listA list of sigmax Hamiltonians for each qubit. sz_ops: listA list of sigmaz Hamiltonians for each qubit. cavityqubit_ops: listA list of interacting Hamiltonians between cavity and each qubit. sx_u: arra",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:192730,Energy Efficiency,energy,energy,192730,"ol amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(N, num_levels, deltamax, epsmax, w0, wq, eps, delta, g)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, “w0”, “eps”, “delta”; and “g”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “g”, list element i is the interaction; between qubits i and i+1. Parameters. N: intThe number of qubits in the system. num_levels: intThe number of energy levels in the resonator. deltamax: listThe coefficients of sigma-x for each of the qubits in the system. epsmax: listThe coefficients of sigma-z for each of the qubits in the system. wo: intThe base frequency of the resonator. wq: listThe frequency of the qubits. eps: listThe epsilon for each of the qubits in the system. delta: listThe delta for each of the qubits in the system. g: listThe interaction strength for each of the qubit with the resonator. Notes; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class Noise[source]¶; The base class representing noise in a processor.; The noise object can be added to Processor and; contributes to evolution. get_noisy_dynamics(dims, pulses, systematic_noise)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dummy Pulse object. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:207969,Energy Efficiency,schedul,schedule,207969,"ber of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. gate_compiler: dictThe Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dictArguments for individual compiling routines.; It adds more flexibility in customizing compiler. compile(circuit, schedule_mode=None, args=None)[source]¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. class CavityQEDCompiler(N, params, pulse_dict, global_phase=0.0)[source]¶; Decompose a QubitCircuit into; the pulse sequence for the processor. Parameters. N: intThe number of qubits in the system. params: dictA Python dictionary contains the name and the value of the parameters.; See DispersiveCavityQED.set_up_params for the definition. global_phase: float, optionalRecord of the global phase change and will be returned. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If g",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:210111,Energy Efficiency,schedul,schedule,210111," match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. N: intThe number of the component systems. params: dictA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc. pulse_dict: dictA map between the pulse label and its index in the pulse list. gate_compiler: dictThe Python dictionary in the form of {gate_name: decompose_function}.; It saves the decomposition scheme for each gate. compile(circuit, schedule_mode=None, args=None)¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate; Notes; This version of sqrtiswap_compiler has very low fidelity, please use; iswap. class SpinChainCompiler(N, params, pulse_dict, setup='linear', global_phase=0.0)[source]¶; Compile a QubitCircuit into; the pulse sequence for the processor. Parameters. N: in",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:212778,Energy Efficiency,schedul,schedule,212778,"aved under the attributes gate_compiler. Attributes. N: intThe number of the component systems. params: dictA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc. pulse_dict: dictA map between the pulse label and its index in the pulse list. gate_compiler: dictThe Python dictionary in the form of {gate_name: decompose_function}.; It saves the decomposition scheme for each gate. setup: string“linear” or “circular” for two sub-classes. global_phase: boolRecord of the global phase change and will be returned. compile(circuit, schedule_mode=None, args=None)¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:213545,Energy Efficiency,schedul,scheduler,213545," A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware cons",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:213596,Energy Efficiency,schedul,schedules,213596,"te_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two inst",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:213642,Energy Efficiency,reduce,reduce,213642,"te_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two inst",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:213777,Energy Efficiency,schedul,scheduler,213777,"ionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Sinc",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:213971,Energy Efficiency,schedul,scheduler,213971,"pe (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are th",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:213995,Energy Efficiency,schedul,schedule,213995,"pe (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are th",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:214054,Energy Efficiency,reduce,reduce,214054,"pe (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are th",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:215148,Energy Efficiency,schedul,schedule,215148,"“ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commute with CNOT 0, 2. schedule(circuit, gates_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instruct",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:215339,Energy Efficiency,schedul,schedule,215339,"ubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commute with CNOT 0, 2. schedule(circuit, gates_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:215432,Energy Efficiency,schedul,scheduler,215432,"e]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commute with CNOT 0, 2. schedule(circuit, gates_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distan",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:216131,Energy Efficiency,schedul,schedule,216131,"es_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:216254,Energy Efficiency,schedul,schedule,216254," of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gat",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:216614,Energy Efficiency,schedul,schedule,216614,"; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_s",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:216691,Energy Efficiency,schedul,schedule,216691,"e of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit impo",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:216884,Energy Efficiency,schedul,schedule,216884," time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_g",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:216963,Energy Efficiency,schedul,schedule,216963,"is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:217338,Energy Efficiency,schedul,schedule,217338,"ch instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:217492,Energy Efficiency,schedul,scheduling,217492,"istance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:217792,Energy Efficiency,schedul,scheduler,217792,"ction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list,",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:218157,Energy Efficiency,schedul,scheduler,218157,"cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, ar",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:218192,Energy Efficiency,schedul,scheduler,218192,"cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, ar",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:218202,Energy Efficiency,schedul,schedule,218202,"ains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. target",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:218518,Energy Efficiency,reduce,reduce,218518,"re; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. targets: list, optionalThe target qubits. controls: list, optionalThe control qubits. used_qubits: setUnion of the control and target qubits. Optimal control¶. class Optimizer(config, dyn, params=None)[so",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:222652,Energy Efficiency,reduce,reduce,222652,"floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpqutip.control.dump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dirstringBasically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summaryOptimIterSummarySummary of the most recent iteration.; Note this is only set if dummping is on. apply_method_par",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:236861,Energy Efficiency,reduce,reduce,236861,"at is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory s",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:251768,Energy Efficiency,efficient,efficient,251768," This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_nor",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:8371,Integrability,depend,dependent,8371,"sarrayArray of eigenvalues for operator. eigvecsarrayArray of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, ‘sin(w * t)’]]. is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters. qobj_listlistA nested list of Qobj instances and corresponding time-dependent; coefficients. tfloatThe time for which to evaluate the time-dependent Qobj instance. argsdictionaryA dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns. outputqutip.QobjA Qobj instance that represents the value of qobj_list at time t. expm(method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters. methodstr {‘dense’, ‘sparse’}Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns. operqutip.Q",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:8693,Integrability,depend,dependent,8693,"(states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, ‘sin(w * t)’]]. is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters. qobj_listlistA nested list of Qobj instances and corresponding time-dependent; coefficients. tfloatThe time for which to evaluate the time-dependent Qobj instance. argsdictionaryA dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns. outputqutip.QobjA Qobj instance that represents the value of qobj_list at time t. expm(method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters. methodstr {‘dense’, ‘sparse’}Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns. operqutip.QobjExponentiated quantum operator. Raises. TypeErrorQuantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:8764,Integrability,depend,dependent,8764,"in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, ‘sin(w * t)’]]. is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters. qobj_listlistA nested list of Qobj instances and corresponding time-dependent; coefficients. tfloatThe time for which to evaluate the time-dependent Qobj instance. argsdictionaryA dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns. outputqutip.QobjA Qobj instance that represents the value of qobj_list at time t. expm(method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters. methodstr {‘dense’, ‘sparse’}Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns. operqutip.QobjExponentiated quantum operator. Raises. TypeErrorQuantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or s",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:8869,Integrability,depend,dependent,8869,"e removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, ‘sin(w * t)’]]. is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters. qobj_listlistA nested list of Qobj instances and corresponding time-dependent; coefficients. tfloatThe time for which to evaluate the time-dependent Qobj instance. argsdictionaryA dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns. outputqutip.QobjA Qobj instance that represents the value of qobj_list at time t. expm(method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters. methodstr {‘dense’, ‘sparse’}Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns. operqutip.QobjExponentiated quantum operator. Raises. TypeErrorQuantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:17108,Integrability,depend,dependent,17108,"lues; of this instance, then renormalizing to obtain a valid density; operator. Parameters. methodstrAlgorithm to use to remove negative eigenvalues. “clip”; simply discards negative eigenvalues, then renormalizes.; “sgs” uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns. operqutip.QobjA valid density operator. unit(inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj; instances, each of which may have an associated scalar time dependence.; The list is summed to produce the final result. In other words, if an; instance of this class is \(Q(t)\), then it is constructed from a set; of constant:obj:~qutip.Qobj \(\{Q_k\}\) and time-dependent scalars; \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj,; then that term is assumed to be constant. The next section contains more; detail on the allowed forms of the constants, and gives several examples; for how to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature m",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:17390,Integrability,depend,dependence,17390,"to find the; positive operator that is nearest in the Shatten 2-norm. Returns. operqutip.QobjA valid density operator. unit(inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj; instances, each of which may have an associated scalar time dependence.; The list is summed to produce the final result. In other words, if an; instance of this class is \(Q(t)\), then it is constructed from a set; of constant:obj:~qutip.Qobj \(\{Q_k\}\) and time-dependent scalars; \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj,; then that term is assumed to be constant. The next section contains more; detail on the allowed forms of the constants, and gives several examples; for how to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffient",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:17594,Integrability,depend,dependent,17594,"rm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj; instances, each of which may have an associated scalar time dependence.; The list is summed to produce the final result. In other words, if an; instance of this class is \(Q(t)\), then it is constructed from a set; of constant:obj:~qutip.Qobj \(\{Q_k\}\) and time-dependent scalars; \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj,; then that term is assumed to be constant. The next section contains more; detail on the allowed forms of the constants, and gives several examples; for how to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:17911,Integrability,depend,dependence,17911,"t in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj; instances, each of which may have an associated scalar time dependence.; The list is summed to produce the final result. In other words, if an; instance of this class is \(Q(t)\), then it is constructed from a set; of constant:obj:~qutip.Qobj \(\{Q_k\}\) and time-dependent scalars; \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj,; then that term is assumed to be constant. The next section contains more; detail on the allowed forms of the constants, and gives several examples; for how to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype np.float64 or; np.complex128. A list of times (np.float64) at which the; coeffients must be given as tlist. The coeffients array must have the; same length as the tlist. Th",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:17983,Integrability,depend,dependent,17983,"t in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj; instances, each of which may have an associated scalar time dependence.; The list is summed to produce the final result. In other words, if an; instance of this class is \(Q(t)\), then it is constructed from a set; of constant:obj:~qutip.Qobj \(\{Q_k\}\) and time-dependent scalars; \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj,; then that term is assumed to be constant. The next section contains more; detail on the allowed forms of the constants, and gives several examples; for how to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype np.float64 or; np.complex128. A list of times (np.float64) at which the; coeffients must be given as tlist. The coeffients array must have the; same length as the tlist. Th",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:20400,Integrability,depend,depending,20400,"not possible to create a single; QobjEvo that contains different tlist values, however.; Passing arguments; args is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string.; There are some “magic” names that can be specified, whose objects will be; overwritten when used within sesolve, mesolve and; mcsolve. This allows access to the solvers’ internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. ""state"": the current state as a Qobj; ""state_vec"": the current state as a column-stacked 1D np.ndarray; ""state_mat"": the current state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers. Replace <n> with; an integer literal, e.g. ""expect_op_0"". This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole object. The time_dependence can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the Qobj instead; of the 2-element list. argsdict, optionalMapping of {str: object}, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous secti",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:20795,Integrability,depend,dependent,20795,"when used within sesolve, mesolve and; mcsolve. This allows access to the solvers’ internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. ""state"": the current state as a Qobj; ""state_vec"": the current state as a column-stacked 1D np.ndarray; ""state_mat"": the current state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers. Replace <n> with; an integer literal, e.g. ""expect_op_0"". This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole object. The time_dependence can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the Qobj instead; of the 2-element list. argsdict, optionalMapping of {str: object}, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the “magic”; names used to access solver internals. tlistarray_like, optionalList of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in Q_object is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes. cteQobjConstant part of",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:21137,Integrability,depend,dependence,21137,"t state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers. Replace <n> with; an integer literal, e.g. ""expect_op_0"". This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole object. The time_dependence can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the Qobj instead; of the 2-element list. argsdict, optionalMapping of {str: object}, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the “magic”; names used to access solver internals. tlistarray_like, optionalList of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in Q_object is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes. cteQobjConstant part of the QobjEvo. opslist of EvoElementInternal representation of the time-dependence structure of the; elements. argsdictThe current value of the args dictionary passed into the; constructor. dynamics_argslistNames of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of tim",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:21611,Integrability,depend,dependences,21611,"at, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole object. The time_dependence can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the Qobj instead; of the 2-element list. argsdict, optionalMapping of {str: object}, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the “magic”; names used to access solver internals. tlistarray_like, optionalList of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in Q_object is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes. cteQobjConstant part of the QobjEvo. opslist of EvoElementInternal representation of the time-dependence structure of the; elements. argsdictThe current value of the args dictionary passed into the; constructor. dynamics_argslistNames of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of times at which the numpy-array coefficients are applied. compiledstrA string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obtain a list of all the coefficients at a particular; time. coeff_fileslistRuntime created files to delete with the instance. dummy_cteboolIs self.cte an empty Qobj. constboolIndicate",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:21869,Integrability,depend,dependence,21869,"e format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole object. The time_dependence can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the Qobj instead; of the 2-element list. argsdict, optionalMapping of {str: object}, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the “magic”; names used to access solver internals. tlistarray_like, optionalList of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in Q_object is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes. cteQobjConstant part of the QobjEvo. opslist of EvoElementInternal representation of the time-dependence structure of the; elements. argsdictThe current value of the args dictionary passed into the; constructor. dynamics_argslistNames of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of times at which the numpy-array coefficients are applied. compiledstrA string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obtain a list of all the coefficients at a particular; time. coeff_fileslistRuntime created files to delete with the instance. dummy_cteboolIs self.cte an empty Qobj. constboolIndicates if quantum object is constant. type{“cte”, “string”, “func”, “array”, “spline”, “mixed_callable”, “mixed_compilable”}Information about the type of coefficients used in the entire object. num_objintNumber of Qobj in the QobjEvo. use_cythonbool",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:23076,Integrability,depend,dependent,23076,"vers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of times at which the numpy-array coefficients are applied. compiledstrA string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obtain a list of all the coefficients at a particular; time. coeff_fileslistRuntime created files to delete with the instance. dummy_cteboolIs self.cte an empty Qobj. constboolIndicates if quantum object is constant. type{“cte”, “string”, “func”, “array”, “spline”, “mixed_callable”, “mixed_compilable”}Information about the type of coefficients used in the entire object. num_objintNumber of Qobj in the QobjEvo. use_cythonboolFlag to compile string to Cython or Python. safePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used lik",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:23351,Integrability,depend,dependent,23351,"piled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obtain a list of all the coefficients at a particular; time. coeff_fileslistRuntime created files to delete with the instance. dummy_cteboolIs self.cte an empty Qobj. constboolIndicates if quantum object is constant. type{“cte”, “string”, “func”, “array”, “spline”, “mixed_callable”, “mixed_compilable”}Information about the type of coefficients used in the entire object. num_objintNumber of Qobj in the QobjEvo. use_cythonboolFlag to compile string to Cython or Python. safePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations f'(t) = f(g(t)) create a; mismatch between the array and the associated time list. arguments(new_args)[source]¶; Update the scoped variables that were passed as args to new values. compile(code=F",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:23631,Integrability,depend,dependent,23631,"t. type{“cte”, “string”, “func”, “array”, “spline”, “mixed_callable”, “mixed_compilable”}Information about the type of coefficients used in the entire object. num_objintNumber of Qobj in the QobjEvo. use_cythonboolFlag to compile string to Cython or Python. safePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations f'(t) = f(g(t)) create a; mismatch between the array and the associated time list. arguments(new_args)[source]¶; Update the scoped variables that were passed as args to new values. compile(code=False, matched=False, dense=False, omp=0)[source]¶; Create an associated Cython object for faster usage. This function is; called automatically by the solvers. Parameters. codebool, default FalseReturn the code string generated by compilation of any strings. matchedbool, default FalseIf True, the underlying sparse ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:23832,Integrability,wrap,wrap,23832,"ber of Qobj in the QobjEvo. use_cythonboolFlag to compile string to Cython or Python. safePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations f'(t) = f(g(t)) create a; mismatch between the array and the associated time list. arguments(new_args)[source]¶; Update the scoped variables that were passed as args to new values. compile(code=False, matched=False, dense=False, omp=0)[source]¶; Create an associated Cython object for faster usage. This function is; called automatically by the solvers. Parameters. codebool, default FalseReturn the code string generated by compilation of any strings. matchedbool, default FalseIf True, the underlying sparse matrices used to represent each; element of the type will have their structures unified. This may; include adding explicit zeros to sparse matrices, but can be faster; in ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:23854,Integrability,depend,dependences,23854,"ber of Qobj in the QobjEvo. use_cythonboolFlag to compile string to Cython or Python. safePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations f'(t) = f(g(t)) create a; mismatch between the array and the associated time list. arguments(new_args)[source]¶; Update the scoped variables that were passed as args to new values. compile(code=False, matched=False, dense=False, omp=0)[source]¶; Create an associated Cython object for faster usage. This function is; called automatically by the solvers. Parameters. codebool, default FalseReturn the code string generated by compilation of any strings. matchedbool, default FalseIf True, the underlying sparse matrices used to represent each; element of the type will have their structures unified. This may; include adding explicit zeros to sparse matrices, but can be faster; in ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:23884,Integrability,depend,dependence,23884,"fePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations f'(t) = f(g(t)) create a; mismatch between the array and the associated time list. arguments(new_args)[source]¶; Update the scoped variables that were passed as args to new values. compile(code=False, matched=False, dense=False, omp=0)[source]¶; Create an associated Cython object for faster usage. This function is; called automatically by the solvers. Parameters. codebool, default FalseReturn the code string generated by compilation of any strings. matchedbool, default FalseIf True, the underlying sparse matrices used to represent each; element of the type will have their structures unified. This may; include adding explicit zeros to sparse matrices, but can be faster; in some cases due to not having to deal with repeated structural; mismatches. densebool, def",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:25276,Integrability,depend,dependence,25276,"s to new values. compile(code=False, matched=False, dense=False, omp=0)[source]¶; Create an associated Cython object for faster usage. This function is; called automatically by the solvers. Parameters. codebool, default FalseReturn the code string generated by compilation of any strings. matchedbool, default FalseIf True, the underlying sparse matrices used to represent each; element of the type will have their structures unified. This may; include adding explicit zeros to sparse matrices, but can be faster; in some cases due to not having to deal with repeated structural; mismatches. densebool, default FalseWhether to swap to using dense matrices to back the data. ompint, optionalThe number of OpenMP threads to use when doing matrix; multiplications, if QuTiP was compiled with OpenMP. Returns. compiled_strstr(Only if code was set to True). The code-generated string of; compiled calling code. compress()[source]¶; Merge together elements that share the same time-dependence, to reduce; the number of matrix multiplications and additions that need to be done; to evaluate this object.; Modifies the object inplace. conj()[source]¶; Return the matrix elementwise conjugation. copy()[source]¶; Return a copy of this object. dag()[source]¶; Return the matrix conjugate-transpose (dagger). expect(t, state, herm=False)[source]¶; Calculate the expectation value of this operator on the given; (time-independent) state at a particular time.; This is more efficient than expect(QobjEvo(t), state). Parameters. tfloatThe time to evaluate this operator at. stateQobj or np.ndarrayThe state to take the expectation value around. hermbool, default FalseWhether this operator and the state are both Hermitian. If True,; only the real part of the result will be returned. See also. expectGeneral-purpose expectation values. mul_mat(t, mat)[source]¶; Multiply this object evaluated at time t by a matrix (from the; right). Parameters. tfloatThe time to evaluate this object at. matQobj or np.ndarrayThe ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:27263,Integrability,depend,dependent,27263,"right). Parameters. tfloatThe time to evaluate this object at. matQobj or np.ndarrayThe matrix that is multiplied by this object. Returns. mat: Qobj or np.ndarrayThe matrix result in the same type as the input. mul_vec(t, vec)[source]¶; Multiply this object evaluated at time t by a vector. Parameters. tfloatThe time to evaluate this object at. vecQobj or np.ndarrayThe state-vector to multiply this object by. Returns. vec: Qobj or np.ndarrayThe vector result in the same type as the input. permute(order)[source]¶; Permute the tensor structure of the underlying matrices into a new; format. See also. Qobj.permutethe same operation on constant quantum objects. tidyup(atol=None)[source]¶; Removes small elements from this quantum object inplace. to_list()[source]¶; Return this operator in the list-like form used to initialised it, like; can be passed to mesolve. trans()[source]¶; Return the matrix transpose. eseries¶. class eseries(q=None, s=array([], dtype=float64))[source]¶; Class representation of an exponential-series expansion of; time-dependent quantum objects. Deprecated since version 4.6.0: eseries will be removed in QuTiP 5.; Please use QobjEvo for general time-dependence. Attributes. amplndarrayArray of amplitudes for exponential series. ratesndarrayArray of rates for exponential series. dimslistDimensions of exponential series components. shapelistShape corresponding to exponential series components. Methods. value(tlist); Evaluate an exponential series at the times listed in tlist. spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup(); Returns a tidier version of the exponential series. spec(wlist)[source]¶; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters. wlistarray_likeArray/list of frequenies. Returns. val_listndarrayValues of exponential series at frequencies in wlist. tidyup(*args)[source]¶; Returns a tidier version of exponential series. value(tlist)[source]¶; Evaluates an exponen",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:27395,Integrability,depend,dependence,27395,"trix result in the same type as the input. mul_vec(t, vec)[source]¶; Multiply this object evaluated at time t by a vector. Parameters. tfloatThe time to evaluate this object at. vecQobj or np.ndarrayThe state-vector to multiply this object by. Returns. vec: Qobj or np.ndarrayThe vector result in the same type as the input. permute(order)[source]¶; Permute the tensor structure of the underlying matrices into a new; format. See also. Qobj.permutethe same operation on constant quantum objects. tidyup(atol=None)[source]¶; Removes small elements from this quantum object inplace. to_list()[source]¶; Return this operator in the list-like form used to initialised it, like; can be passed to mesolve. trans()[source]¶; Return the matrix transpose. eseries¶. class eseries(q=None, s=array([], dtype=float64))[source]¶; Class representation of an exponential-series expansion of; time-dependent quantum objects. Deprecated since version 4.6.0: eseries will be removed in QuTiP 5.; Please use QobjEvo for general time-dependence. Attributes. amplndarrayArray of amplitudes for exponential series. ratesndarrayArray of rates for exponential series. dimslistDimensions of exponential series components. shapelistShape corresponding to exponential series components. Methods. value(tlist); Evaluate an exponential series at the times listed in tlist. spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup(); Returns a tidier version of the exponential series. spec(wlist)[source]¶; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters. wlistarray_likeArray/list of frequenies. Returns. val_listndarrayValues of exponential series at frequencies in wlist. tidyup(*args)[source]¶; Returns a tidier version of exponential series. value(tlist)[source]¶; Evaluates an exponential series at the times listed in tlist. Parameters. tlistndarrayTimes at which to evaluate exponential series. Returns. val_listndarrayValues of exponential at times i",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:47522,Integrability,depend,dependent,47522,"-xe/mkl/mklman/GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF.htm. Returns. steady_stateQobjThe steady state density matrix of the system. steady_adosHierarchyADOsStateThe steady state of the full ADO hierarchy. A particular ADO may be; extracted from the full state by calling extract. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, bnd_cut_approx=False, options=None, progress_bar=None, combine=True)[source]¶; A helper class for creating an HEOMSolver that is backwards; compatible with the HSolverDL provided in qutip.nonmarkov.heom; in QuTiP 4.6 and below.; See HEOMSolver and DrudeLorentzBath for more; descriptions of the underlying solver and bath construction.; An exact copy of the QuTiP 4.6 HSolverDL is provided in; qutip.nonmarkov.dlheom_solver for cases where the functionality of; the older solver is required. The older solver will be completely; removed in QuTiP 5. Note; Unlike the version of HSolverDL in QuTiP 4.6, this solver; supports supplying a time-dependent or Liouvillian H_sys. Note; For compatibility with HSolverDL in QuTiP 4.6 and below, the; parameter N_exp specifying the number of exponents to keep in; the expansion of the bath correlation function is one more than; the equivalent Nk used in the DrudeLorentzBath. I.e.,; Nk = N_exp - 1. The Nk parameter in the; DrudeLorentzBath does not count the zeroeth exponent in; order to better match common usage in the literature. Note; The stats and renorm arguments accepted in QuTiP 4.6 and below; are no longer supported. Parameters. H_sysQobj or QobjEvo or listThe system Hamiltonian or Liouvillian. See HEOMSolver for; a complete description. coup_opQobjOperator describing the coupling between system and bath.; See parameter Q in BosonicBath for a complete description. coup_strengthfloatCoupling strength. Referred to as lam in DrudeLorentzBath. temperaturefloatBath temperature. Referred to as T in DrudeLorentzBath. N_cutintThe maximum depth of the hierarchy. See max_depth in; HE",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:68661,Integrability,depend,depend,68661,"directly on this class for; convenience. E.g. one can access ``.labels``, or ``.exponents`` or; call ``.idx(label)`` directly.; See :class:`HierarchyADOs` for a full list of the available attributes; and methods. extract(idx_or_label)[source]¶; Extract a Qobj representing specified ADO from a full representation of; the ADO states. Parameters. idxint or labelThe index of the ADO to extract. If an ADO label, e.g.; (0, 1, 0, ...) is supplied instead, then the ADO; is extracted by label instead. Returns. QobjA Qobj representing the state of the specified ADO. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject s",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:72874,Integrability,integrat,integrate,72874,"=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; C",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:73010,Integrability,integrat,integrator,73010,"bed in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., l",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:73923,Integrability,integrat,integratorstr,73923,"yCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse o",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:74099,Integrability,integrat,integrator,74099,"e simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). Returns. : complexexpectation",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:74173,Integrability,integrat,integrator,74173,"ed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). Returns. : complexexpectation value of field correlation function. outfieldpropagato",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:78740,Integrability,integrat,integrator,78740,"]¶; Contain and compute expectation values. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, steady_state_average=False, seeds=None, normalize_output=True, use_openmp=None, openmp_threads=None)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes. atolfloat {1e-8}Absolute tolerance. rtolfloat {1e-6}Relative tolerance. methodstr {‘adams’,’bdf’}Integration method. orderint {12}Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nstepsint {2500}Max. number of internal steps/call. first_stepfloat {0}Size of initial step (0 = automatic). min_stepfloat {0}Minimum step size (0 = automatic). max_stepfloat {0}Maximum step size (0 = automatic). tidybool {True,False}Tidyup Hamiltonian and initial state by removing small terms. num_cpusintNumber of cpus used by mcsolver (default = # of cpus). norm_tolfloatTolerance used when finding wavefunction norm in mcsolve. norm_stepsintMax. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_statesbool {False}Average states values over trajectories in stochastic solvers. average_expectbool {True}Average expectation values over trajectories for stochastic solvers. mc_corr_epsfloat {1e-10}Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve. ntrajint {500}Number of trajectories in stochastic solvers. openmp_threadsintNumber of OPENMP threads to use. Default",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:82996,Integrability,message,message,82996,"ection called ‘main’ is created. Attributes. sectionsOrderedDict of _StatsSectionThese are the sections that are created automatically on instantiation; or added using add_section. headerstringSome text that will be used as the heading in the report; By default there is None. total_timefloatTime in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. sectionstring or _StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:83132,Integrability,message,message,83132," add_section. headerstringSome text that will be used as the heading in the report; By default there is None. total_timefloatTime in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. sectionstring or _StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will res",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:83223,Integrability,message,messages,83223,"e in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. sectionstring or _StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `cla",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:83326,Integrability,message,message,83326," that total timing percentages will be reported. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. sectionstring or _StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:83359,Integrability,message,message,83359," that total timing percentages will be reported. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. sectionstring or _StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:83503,Integrability,message,message,83503,"in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. sectionstring or _StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the default (first) section will be used. clear()[source]¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper n",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:84414,Integrability,message,messages,84414,"h this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the default (first) section will be used. clear()[source]¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)[source]¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters. outputstreamfile or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters. valuefloatTime in seconds to complete the solver section. sectionstring or classSection which to set the total_time for; If None given, the total_time for complete solve is set. class",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:84560,Integrability,message,messages,84560,"given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the default (first) section will be used. clear()[source]¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)[source]¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters. outputstreamfile or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters. valuefloatTime in seconds to complete the solver section. sectionstring or classSection which to set the total_time for; If None given, the total_time for complete solve is set. class StochasticSolverOptions(me, H=None, c_ops=[], sc_ops=[], state0=None, e_ops=[], m_ops=None, store_all_expect=False, st",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:84699,Integrability,message,messages,84699,"on_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the default (first) section will be used. clear()[source]¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)[source]¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters. outputstreamfile or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters. valuefloatTime in seconds to complete the solver section. sectionstring or classSection which to set the total_time for; If None given, the total_time for complete solve is set. class StochasticSolverOptions(me, H=None, c_ops=[], sc_ops=[], state0=None, e_ops=[], m_ops=None, store_all_expect=False, store_measurement=False, dW_factors=None, solver=None, method='homodyne', normalize=None, times=None, nsubsteps=1, ntraj=1, tol=None, generate_noise=None, noise=None, progress_bar=None, map_func=None, map_kwargs=None, args={}, options=N",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:86456,Integrability,depend,dependent,86456,"=[], state0=None, e_ops=[], m_ops=None, store_all_expect=False, store_measurement=False, dW_factors=None, solver=None, method='homodyne', normalize=None, times=None, nsubsteps=1, ntraj=1, tol=None, generate_noise=None, noise=None, progress_bar=None, map_func=None, map_kwargs=None, args={}, options=None, noiseDepth=20)[source]¶; Class of options for stochastic solvers such as; qutip.stochastic.ssesolve, qutip.stochastic.smesolve, etc.; The stochastic solvers qutip.stochastic.general_stochastic,; qutip.stochastic.ssesolve, qutip.stochastic.smesolve,; qutip.stochastic.photocurrent_sesolve and; qutip.stochastic.photocurrent_mesolve; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class.; Within the attribute list, a time_dependent_object is either. Qobj: a constant term; 2-element list of [Qobj, time_dependence]: a time-dependent term; where the Qobj will be multiplied by the time-dependent scalar. For more details on all allowed time-dependent objects, see the; documentation for QobjEvo. Attributes. Htime_dependent_object or list of time_dependent_objectSystem Hamiltonian in standard time-dependent list format. This is the; same as the argument that (e.g.) mesolve takes.; If this is a list of elements, they are summed. state0qutip.QobjInitial state vector (ket) or density matrix. timesarray_like of floatList of times for \(t\). Must be uniformly spaced. c_opslist of time_dependent_objectList of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_opslist of time_dependent_objectList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:86518,Integrability,depend,dependent,86518,"=[], state0=None, e_ops=[], m_ops=None, store_all_expect=False, store_measurement=False, dW_factors=None, solver=None, method='homodyne', normalize=None, times=None, nsubsteps=1, ntraj=1, tol=None, generate_noise=None, noise=None, progress_bar=None, map_func=None, map_kwargs=None, args={}, options=None, noiseDepth=20)[source]¶; Class of options for stochastic solvers such as; qutip.stochastic.ssesolve, qutip.stochastic.smesolve, etc.; The stochastic solvers qutip.stochastic.general_stochastic,; qutip.stochastic.ssesolve, qutip.stochastic.smesolve,; qutip.stochastic.photocurrent_sesolve and; qutip.stochastic.photocurrent_mesolve; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class.; Within the attribute list, a time_dependent_object is either. Qobj: a constant term; 2-element list of [Qobj, time_dependence]: a time-dependent term; where the Qobj will be multiplied by the time-dependent scalar. For more details on all allowed time-dependent objects, see the; documentation for QobjEvo. Attributes. Htime_dependent_object or list of time_dependent_objectSystem Hamiltonian in standard time-dependent list format. This is the; same as the argument that (e.g.) mesolve takes.; If this is a list of elements, they are summed. state0qutip.QobjInitial state vector (ket) or density matrix. timesarray_like of floatList of times for \(t\). Must be uniformly spaced. c_opslist of time_dependent_objectList of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_opslist of time_dependent_objectList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:86573,Integrability,depend,dependent,86573,"od='homodyne', normalize=None, times=None, nsubsteps=1, ntraj=1, tol=None, generate_noise=None, noise=None, progress_bar=None, map_func=None, map_kwargs=None, args={}, options=None, noiseDepth=20)[source]¶; Class of options for stochastic solvers such as; qutip.stochastic.ssesolve, qutip.stochastic.smesolve, etc.; The stochastic solvers qutip.stochastic.general_stochastic,; qutip.stochastic.ssesolve, qutip.stochastic.smesolve,; qutip.stochastic.photocurrent_sesolve and; qutip.stochastic.photocurrent_mesolve; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class.; Within the attribute list, a time_dependent_object is either. Qobj: a constant term; 2-element list of [Qobj, time_dependence]: a time-dependent term; where the Qobj will be multiplied by the time-dependent scalar. For more details on all allowed time-dependent objects, see the; documentation for QobjEvo. Attributes. Htime_dependent_object or list of time_dependent_objectSystem Hamiltonian in standard time-dependent list format. This is the; same as the argument that (e.g.) mesolve takes.; If this is a list of elements, they are summed. state0qutip.QobjInitial state vector (ket) or density matrix. timesarray_like of floatList of times for \(t\). Must be uniformly spaced. c_opslist of time_dependent_objectList of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_opslist of time_dependent_objectList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of the list is a separate operator, like; c_ops. e_opslist of qutip.QobjSingle operator or list of operators for which to ev",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:86731,Integrability,depend,dependent,86731,"s_bar=None, map_func=None, map_kwargs=None, args={}, options=None, noiseDepth=20)[source]¶; Class of options for stochastic solvers such as; qutip.stochastic.ssesolve, qutip.stochastic.smesolve, etc.; The stochastic solvers qutip.stochastic.general_stochastic,; qutip.stochastic.ssesolve, qutip.stochastic.smesolve,; qutip.stochastic.photocurrent_sesolve and; qutip.stochastic.photocurrent_mesolve; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class.; Within the attribute list, a time_dependent_object is either. Qobj: a constant term; 2-element list of [Qobj, time_dependence]: a time-dependent term; where the Qobj will be multiplied by the time-dependent scalar. For more details on all allowed time-dependent objects, see the; documentation for QobjEvo. Attributes. Htime_dependent_object or list of time_dependent_objectSystem Hamiltonian in standard time-dependent list format. This is the; same as the argument that (e.g.) mesolve takes.; If this is a list of elements, they are summed. state0qutip.QobjInitial state vector (ket) or density matrix. timesarray_like of floatList of times for \(t\). Must be uniformly spaced. c_opslist of time_dependent_objectList of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_opslist of time_dependent_objectList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of the list is a separate operator, like; c_ops. e_opslist of qutip.QobjSingle operator or list of operators for which to evaluate; expectation values. m_opslist of qutip.QobjList of operators representing the measurement operators. The ex",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:87872,Integrability,depend,dependent,87872,"med. state0qutip.QobjInitial state vector (ket) or density matrix. timesarray_like of floatList of times for \(t\). Must be uniformly spaced. c_opslist of time_dependent_objectList of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_opslist of time_dependent_objectList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of the list is a separate operator, like; c_ops. e_opslist of qutip.QobjSingle operator or list of operators for which to evaluate; expectation values. m_opslist of qutip.QobjList of operators representing the measurement operators. The expected; format is a nested list with one measurement operator for each; stochastic increament, for each stochastic collapse operator. argsdictDictionary of parameters for time dependent systems. tolfloatTolerance of the solver for implicit methods. ntrajintNumber of trajectors. nsubstepsintNumber of sub steps between each time-spep given in times. dW_factorsarrayArray of length len(sc_ops), containing scaling factors for each; measurement operator in m_ops. solverstringName of the solver method to use for solving the stochastic; equations. Valid values are:. order 1/2 algorithms: ‘euler-maruyama’, ‘pc-euler’, ‘pc-euler-imp’; order 1 algorithms: ‘milstein’, ‘platen’, ‘milstein-imp’, ‘rouchon’; order 3/2 algorithms: ‘taylor1.5’, ‘taylor1.5-imp’, ‘explicit1.5’; order 2 algorithms: ‘taylor2.0’. See the documentation of stochastic_solvers; for a description of the solvers. Implicit methods can adjust; tolerance via the kw ‘tol’. Default is {‘tol’: 1e-6}. methodstring (‘homodyne’, ‘heterodyne’)The name of the type of measurement process that give rise to the; stochastic equation to solve. store_all_expectbool (default False)Whether or not to store the ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:93075,Integrability,integrat,integrate,93075,"pled basis.; default: (nds, nds). c_ops()[source]¶; Build collapse operators in the full Hilbert space 2^N. Returns. c_ops_list: listThe list with the collapse operators in the 2^N Hilbert space. coefficient_matrix()[source]¶; Build coefficient matrix for ODE for a diagonal problem. Returns. M: ndarrayThe matrix M of the coefficients for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis. lindbladian()[source]¶; Build the Lindbladian superoperator of the dissipative dynamics. Returns. lindbladianqutip.QobjThe Lindbladian matrix as a qutip.Qobj. liouvillian()[source]¶; Build the total Liouvillian using the Dicke basis. Returns. liouvqutip.QobjThe Liouvillian matrix for the system. pisolve(initial_state, tlist, options=None)[source]¶; Solve for diagonal Hamiltonians and initial states faster. Parameters. initial_statequtip.QobjAn initial state specified as a density matrix of; qutip.Qbj type. tlist: ndarrayA 1D numpy array of list of timesteps to integrate. optionsqutip.solver.OptionsThe options for the solver. Returns. result: listA dictionary of the type qutip.solver.Result which holds the; results of the evolution. class Pim(N, emission=0.0, dephasing=0, pumping=0, collective_emission=0, collective_pumping=0, collective_dephasing=0)[source]¶; The Permutation Invariant Matrix class.; Initialize the class with the parameters for generating a Permutation; Invariant matrix which evolves a given diagonal initial state p as:. dp/dt = Mp. Parameters. N: intThe number of two-level systems. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: floatLocal dephasing coefficient.; default: 0.0. pumping: floatIncoherent pumping coefficient.; default: 0.0. collective_emission: floatCollective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: floatCollective pumping coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coeff",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:106666,Integrability,depend,depending,106666,"st of arrays that spans the space for each coordinate. xlabelslistList of labels for each coordinate. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; marginal distribution. Returns. dDistributionsA new instances of Distribution that describes the marginal; distribution. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; projected distribution. Returns. dDistributionsA new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. figmatplotlib Figure instanceIf given, use this figure instance for the visualization,. axmatplotlib Axes instanceIf given, render the visualization using this axis instance. figsizetupleSize of the new Figure instance, if one needs to be created. colorbar: BoolWhether or not the colorbar (in 2D visualization) should be used. cmap: matplotlib colormap instanceIf given, use this colormap for 2D visualizations. stylestringType of visualization: ‘colormap’ (default) or ‘surface’. Returns. fig, axtupleA tuple of matplotlib figure and axes instances. class WignerDistribution(rho=None, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. class QDistribution(rho=None, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. update(state)[source]",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:129517,Integrability,depend,dependent,129517,"s True, calculate the propagator; with matrix exponentiation and return a list of matrices.; Noise will be neglected in this option. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: boolIf True, calculate the evolution with matrices exponentiation. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. solver: str“mesolve” or “mcsolve”. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.solver.ResultIf analytical is False, an instance of the class; qutip.solver.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)[source]¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)[source]¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. class OptPulseProcessor(N, drift=None, t1=None, t2=None, dims=None)[source]¶; A processor, which takes the Hamiltonian available; as dynamic generators, calls the; qutip.control.optimize_pulse_unitary function; to find an optimized pulse sequence for the desired quantum circuit.; The processor can simulate the evolution under the given; control pulses using qutip.mesolve.; (For attributes documentation, please; refer to the parent class Processor). Parameters. N: intThe number of component systems. drift: `:class:`qutip.Qobj`The drift Hamiltonian. The size must match the whole quantum system. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence of dephasing for; each qubit. A list of size N or a float for all qubits. dims: listThe dimension of each component system.; Default value i",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:140280,Integrability,depend,dependent,140280," If analytical is True, calculate the propagator; with matrix exponentiation and return a list of matrices.; Noise will be neglected in this option. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: boolIf True, calculate the evolution with matrices exponentiation. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. solver: str“mesolve” or “mcsolve”. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.solver.ResultIf analytical is False, an instance of the class; qutip.solver.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. class ModelProcessor(N, correct_global_phase=True, t1=None, t2=None)[source]¶; The base class for a circuit processor simulating a physical device,; e.g cavityQED, spinchain.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It cannot be used alone, please refer to the sub-classes.; (Only additional attributes are documented here, for others please; refer to the parent class Processor). Parameters. N: intThe number of component systems. correct_global_phase: boolean, optionalIf true, the analytical solution will track the global phase. It; has no effect on the numerical solution. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence of dephasing for; each qubit. A list",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:149084,Integrability,depend,dependent,149084,"ix exponentiation and return a list of matrices. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: booleanIf True, calculate the evolution with matrices exponentiation. qc: :class:`.QubitCircuit`, optionalA quantum circuit. If given, it first calls the load_circuit; and then calculate the evolution. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.solver.ResultIf analytical is False, an instance of the class; qutip.solver.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_params()[source]¶; Save the parameters in the attribute params and check the validity.; (Defined in subclasses); Notes; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)[source]¶; Transfer a parameter to an array. class SpinChain(N, correct_global_phase, sx, sz, sxsy, t1, t2)[source]¶; The processor based on the physical implementation of; a spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It is a base class and should not be used directly, please; refer the the subclasses qutip.qip.device.LinearSpinChain and; qutip.qip.device.CircularSpinChain.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_ph",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:159928,Integrability,depend,dependent,159928,"ix exponentiation and return a list of matrices. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: booleanIf True, calculate the evolution with matrices exponentiation. qc: :class:`.QubitCircuit`, optionalA quantum circuit. If given, it first calls the load_circuit; and then calculate the evolution. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.solver.ResultIf analytical is False, an instance of the class; qutip.solver.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class LinearSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:170374,Integrability,depend,dependent,170374,"ix exponentiation and return a list of matrices. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: booleanIf True, calculate the evolution with matrices exponentiation. qc: :class:`.QubitCircuit`, optionalA quantum circuit. If given, it first calls the load_circuit; and then calculate the evolution. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.solver.ResultIf analytical is False, an instance of the class; qutip.solver.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class CircularSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor base",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:180830,Integrability,depend,dependent,180830,"ix exponentiation and return a list of matrices. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: booleanIf True, calculate the evolution with matrices exponentiation. qc: :class:`.QubitCircuit`, optionalA quantum circuit. If given, it first calls the load_circuit; and then calculate the evolution. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.solver.ResultIf analytical is False, an instance of the class; qutip.solver.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class DispersiveCavityQED(N, correct_global_phase=True, num_levels=10, deltamax=1.0, epsmax=9.5, w0=10.0, wq=None, eps=9.5, d",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:192028,Integrability,depend,dependent,192028,"ix exponentiation and return a list of matrices. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: booleanIf True, calculate the evolution with matrices exponentiation. qc: :class:`.QubitCircuit`, optionalA quantum circuit. If given, it first calls the load_circuit; and then calculate the evolution. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.solver.ResultIf analytical is False, an instance of the class; qutip.solver.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(N, num_levels, deltamax, epsmax, w0, wq, eps, delta, g)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, “w0”, “eps”, “delta”; and “g”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “g”, list element i is the interaction; between qubits i and i+1. Parameters. N: intThe number of qubits in the system. num_levels: intThe number of energy levels in the resonator. deltamax: listThe coefficients of sigma-x for each of the qubits in the system. epsmax: listThe coefficients of sigma-z for each of the qubits in the system. wo: intThe base frequency of the resonator. wq: listThe frequency of the qubits. eps: listThe ep",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:200148,Integrability,depend,dependent,200148,"tween two random amplitude. The coefficients; of the noise are the same within this time range. rand_gen: numpy.random, optionalA random generator in numpy.random, it has to take a size; parameter. indices: list of intThe indices of target pulse in the list of pulses. **kwargs:Key word arguments for the random number generator. get_noisy_dynamics(dims=None, pulses=None, systematic_noise=None)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dummy Pulse object. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits system. pulses: list of :class:`.Pulse`The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`The dummy pulse with no ideal control element. Returns. noisy_pulses: list of PulseNoisy pulses. systematic_noise: PulseThe dummy pulse representing pulse independent noise. class Pulse(qobj, targets, tlist=None, coeff=None, spline_kind=None, label='')[source]¶; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; qobj, targets, tlist and coeff.; See examples for different construction behavior. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the ideal pulse. targets: listtarget qubits of the ideal pulse; (or subquantum system of other dimensions). tlist: array-like, optionaltlist of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; tlist does not have to be equidistant, but must have the same length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind. coeff: array-like or bool, optionalTime-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to tlist.; ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:200712,Integrability,depend,dependent,200712,"ulses: list of :class:`.Pulse`The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`The dummy pulse with no ideal control element. Returns. noisy_pulses: list of PulseNoisy pulses. systematic_noise: PulseThe dummy pulse representing pulse independent noise. class Pulse(qobj, targets, tlist=None, coeff=None, spline_kind=None, label='')[source]¶; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; qobj, targets, tlist and coeff.; See examples for different construction behavior. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the ideal pulse. targets: listtarget qubits of the ideal pulse; (or subquantum system of other dimensions). tlist: array-like, optionaltlist of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; tlist does not have to be equidistant, but must have the same length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind. coeff: array-like or bool, optionalTime-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for the parameter spline_kind.; If a bool, the coefficient is a constant 1 or 0. spline_kind: str, optionalType of the coefficient interpolation:; “step_func” or “cubic”.; -“step_func”:; The coefficient will be treated as a step function.; E.g. tlist=[0,1,2] and coeff=[3,2], means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; len(coeff)=len(tlist)-1 or len(coeff)=len(tlist), but; in the second case the last element of coeff has no effect.; -“cubic”:; Use cubic interpolation for the coefficient. It requires; len(coeff)=len(tlist). label: strThe label (name) of the pulse. Example",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:200951,Integrability,depend,dependent,200951,"seThe dummy pulse representing pulse independent noise. class Pulse(qobj, targets, tlist=None, coeff=None, spline_kind=None, label='')[source]¶; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; qobj, targets, tlist and coeff.; See examples for different construction behavior. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the ideal pulse. targets: listtarget qubits of the ideal pulse; (or subquantum system of other dimensions). tlist: array-like, optionaltlist of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; tlist does not have to be equidistant, but must have the same length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind. coeff: array-like or bool, optionalTime-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for the parameter spline_kind.; If a bool, the coefficient is a constant 1 or 0. spline_kind: str, optionalType of the coefficient interpolation:; “step_func” or “cubic”.; -“step_func”:; The coefficient will be treated as a step function.; E.g. tlist=[0,1,2] and coeff=[3,2], means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; len(coeff)=len(tlist)-1 or len(coeff)=len(tlist), but; in the second case the last element of coeff has no effect.; -“cubic”:; Use cubic interpolation for the coefficient. It requires; len(coeff)=len(tlist). label: strThe label (name) of the pulse. Examples; Create a pulse that is turned off; >>> Pulse(sigmaz(), 0) ; >>> Pulse(sigmaz(), 0, None, None) . Create a time dependent pulse; >>> tlist = np.array([0., 1., 2., 4.]) ; >>> coeff = np.array([0.5, 1.2, 0.8]) ; >>> spline_kind = ""step_func"" ; ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:201826,Integrability,depend,dependent,201826,"shorter compared to coeff. See documentation for; the parameter spline_kind. coeff: array-like or bool, optionalTime-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for the parameter spline_kind.; If a bool, the coefficient is a constant 1 or 0. spline_kind: str, optionalType of the coefficient interpolation:; “step_func” or “cubic”.; -“step_func”:; The coefficient will be treated as a step function.; E.g. tlist=[0,1,2] and coeff=[3,2], means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; len(coeff)=len(tlist)-1 or len(coeff)=len(tlist), but; in the second case the last element of coeff has no effect.; -“cubic”:; Use cubic interpolation for the coefficient. It requires; len(coeff)=len(tlist). label: strThe label (name) of the pulse. Examples; Create a pulse that is turned off; >>> Pulse(sigmaz(), 0) ; >>> Pulse(sigmaz(), 0, None, None) . Create a time dependent pulse; >>> tlist = np.array([0., 1., 2., 4.]) ; >>> coeff = np.array([0.5, 1.2, 0.8]) ; >>> spline_kind = ""step_func"" ; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=coeff, spline_kind=""step_func"") . Create a time independent pulse; >>> Pulse(sigmaz(), 0, coeff=True) . Create a constant pulse with time range; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True) . Create an dummy Pulse (H=0); >>> Pulse(None, None) . Attributes. ideal_pulse: :class:`._EvoElement`The ideal dynamic of the control pulse. coherent_noise: list of :class:`._EvoElement`The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian. lindblad_noise: list of :class:`._EvoElement`The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(qobj, targets, tlist=None, coeff=None)[source]¶",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:202480,Integrability,depend,dependent,202480,"ff)=len(tlist)-1 or len(coeff)=len(tlist), but; in the second case the last element of coeff has no effect.; -“cubic”:; Use cubic interpolation for the coefficient. It requires; len(coeff)=len(tlist). label: strThe label (name) of the pulse. Examples; Create a pulse that is turned off; >>> Pulse(sigmaz(), 0) ; >>> Pulse(sigmaz(), 0, None, None) . Create a time dependent pulse; >>> tlist = np.array([0., 1., 2., 4.]) ; >>> coeff = np.array([0.5, 1.2, 0.8]) ; >>> spline_kind = ""step_func"" ; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=coeff, spline_kind=""step_func"") . Create a time independent pulse; >>> Pulse(sigmaz(), 0, coeff=True) . Create a constant pulse with time range; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True) . Create an dummy Pulse (H=0); >>> Pulse(None, None) . Attributes. ideal_pulse: :class:`._EvoElement`The ideal dynamic of the control pulse. coherent_noise: list of :class:`._EvoElement`The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian. lindblad_noise: list of :class:`._EvoElement`The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the pulse. targets: listtarget qubits of the pulse; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element l",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:202641,Integrability,depend,dependent,202641,"en(coeff)=len(tlist). label: strThe label (name) of the pulse. Examples; Create a pulse that is turned off; >>> Pulse(sigmaz(), 0) ; >>> Pulse(sigmaz(), 0, None, None) . Create a time dependent pulse; >>> tlist = np.array([0., 1., 2., 4.]) ; >>> coeff = np.array([0.5, 1.2, 0.8]) ; >>> spline_kind = ""step_func"" ; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=coeff, spline_kind=""step_func"") . Create a time independent pulse; >>> Pulse(sigmaz(), 0, coeff=True) . Create a constant pulse with time range; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True) . Create an dummy Pulse (H=0); >>> Pulse(None, None) . Attributes. ideal_pulse: :class:`._EvoElement`The ideal dynamic of the control pulse. coherent_noise: list of :class:`._EvoElement`The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian. lindblad_noise: list of :class:`._EvoElement`The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the pulse. targets: listtarget qubits of the pulse; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. add_lindblad_noise(qobj, targets, tlist=None,",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:202853,Integrability,depend,dependent,202853,"nt pulse; >>> tlist = np.array([0., 1., 2., 4.]) ; >>> coeff = np.array([0.5, 1.2, 0.8]) ; >>> spline_kind = ""step_func"" ; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=coeff, spline_kind=""step_func"") . Create a time independent pulse; >>> Pulse(sigmaz(), 0, coeff=True) . Create a constant pulse with time range; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True) . Create an dummy Pulse (H=0); >>> Pulse(None, None) . Attributes. ideal_pulse: :class:`._EvoElement`The ideal dynamic of the control pulse. coherent_noise: list of :class:`._EvoElement`The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian. lindblad_noise: list of :class:`._EvoElement`The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the pulse. targets: listtarget qubits of the pulse; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. add_lindblad_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The collapse operator of the lindblad noise. targets: listtarget ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:203111,Integrability,depend,dependent,203111,") . Create a constant pulse with time range; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True) . Create an dummy Pulse (H=0); >>> Pulse(None, None) . Attributes. ideal_pulse: :class:`._EvoElement`The ideal dynamic of the control pulse. coherent_noise: list of :class:`._EvoElement`The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian. lindblad_noise: list of :class:`._EvoElement`The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the pulse. targets: listtarget qubits of the pulse; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. add_lindblad_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The collapse operator of the lindblad noise. targets: listtarget qubits of the collapse operator; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element short",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:203361,Integrability,depend,dependent,203361,"s:`._EvoElement`The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian. lindblad_noise: list of :class:`._EvoElement`The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the pulse. targets: listtarget qubits of the pulse; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. add_lindblad_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The collapse operator of the lindblad noise. targets: listtarget qubits of the collapse operator; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff.; See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documenta",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:203682,Integrability,depend,dependent,203682,"erator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the pulse. targets: listtarget qubits of the pulse; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. add_lindblad_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The collapse operator of the lindblad noise. targets: listtarget qubits of the collapse operator; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff.; See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. property coeff¶; See parameter coeff. get_full_tlist(tol=1e-10)[source]¶; Return the full tlist of the pulses and noise. It means that if; different tlist are present, they will be merged to one with all; t",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:203970,Integrability,depend,dependent,203970,"e pulse. targets: listtarget qubits of the pulse; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. add_lindblad_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The collapse operator of the lindblad noise. targets: listtarget qubits of the collapse operator; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff.; See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. property coeff¶; See parameter coeff. get_full_tlist(tol=1e-10)[source]¶; Return the full tlist of the pulses and noise. It means that if; different tlist are present, they will be merged to one with all; time points stored in a sorted array. Returns. full_tlist: array-like 1dThe full time sequence for the noisy evolution. get_ideal_qobj(dims)[source]¶; Get the Hamiltonian of the ideal pulse. Parameters. dims: int or listDimension of the system.; If int, we assume it is the number of qubits in t",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:204221,Integrability,depend,dependent,204221,"r one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. add_lindblad_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The collapse operator of the lindblad noise. targets: listtarget qubits of the collapse operator; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff.; See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. property coeff¶; See parameter coeff. get_full_tlist(tol=1e-10)[source]¶; Return the full tlist of the pulses and noise. It means that if; different tlist are present, they will be merged to one with all; time points stored in a sorted array. Returns. full_tlist: array-like 1dThe full time sequence for the noisy evolution. get_ideal_qobj(dims)[source]¶; Get the Hamiltonian of the ideal pulse. Parameters. dims: int or listDimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns. qobj: qutip.QobjThe Hamiltonian of the ideal pulse. get_ideal_qobjevo(dims)[source]¶; Get a QobjEvo representation of the ideal evolution. Parameters. dims: int or listDimension of the sys",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:205886,Integrability,depend,dependent,205886,"ion of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns. qobj: qutip.QobjThe Hamiltonian of the ideal pulse. get_ideal_qobjevo(dims)[source]¶; Get a QobjEvo representation of the ideal evolution. Parameters. dims: int or listDimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns. ideal_evo: qutip.QobjEvoA QobjEvo representing the ideal evolution. get_noisy_qobjevo(dims)[source]¶; Get the QobjEvo representation of the noisy evolution. The; result can be used directly as input for the qutip solvers. Parameters. dims: int or listDimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns. noisy_evo: qutip.QobjEvoA QobjEvo representing the ideal evolution and coherent noise. c_ops: list of qutip.QobjEvoA list of (time-dependent) lindbald operators. print_info()[source]¶; Print the information of the pulse, including the ideal dynamics,; the coherent noise and the lindblad noise. property qobj¶; See parameter qobj. property targets¶; See parameter targets. property tlist¶; See parameter tlist. class GateCompiler(N, params=None, pulse_dict=None)[source]¶; Base class. It compiles a QubitCircuit into; the pulse sequence for the processor. The core member function; compile calls compiling method from the sub-class and concatenate; the compiled pulses. Parameters. N: intThe number of the component systems. params: dict, optionalA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; (pulse_label, coeff), instead of (pulse_in",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:207062,Integrability,rout,routine,207062,". property qobj¶; See parameter qobj. property targets¶; See parameter targets. property tlist¶; See parameter tlist. class GateCompiler(N, params=None, pulse_dict=None)[source]¶; Base class. It compiles a QubitCircuit into; the pulse sequence for the processor. The core member function; compile calls compiling method from the sub-class and concatenate; the compiled pulses. Parameters. N: intThe number of the component systems. params: dict, optionalA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; (pulse_label, coeff), instead of (pulse_index, coeff).; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. gate_compiler: dictThe Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dictArguments for individual compiling routines.; It adds more flexibility in customizing compiler. compile(circuit, schedule_mode=None, args=None)[source]¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used i",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:207236,Integrability,rout,routine,207236,"lass. It compiles a QubitCircuit into; the pulse sequence for the processor. The core member function; compile calls compiling method from the sub-class and concatenate; the compiled pulses. Parameters. N: intThe number of the component systems. params: dict, optionalA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; (pulse_label, coeff), instead of (pulse_index, coeff).; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. gate_compiler: dictThe Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dictArguments for individual compiling routines.; It adds more flexibility in customizing compiler. compile(circuit, schedule_mode=None, args=None)[source]¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tli",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:207410,Integrability,rout,routines,207410,"concatenate; the compiled pulses. Parameters. N: intThe number of the component systems. params: dict, optionalA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; (pulse_label, coeff), instead of (pulse_index, coeff).; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. gate_compiler: dictThe Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dictArguments for individual compiling routines.; It adds more flexibility in customizing compiler. compile(circuit, schedule_mode=None, args=None)[source]¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate.",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:209175,Integrability,rout,routine,209175,"ient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. class CavityQEDCompiler(N, params, pulse_dict, global_phase=0.0)[source]¶; Decompose a QubitCircuit into; the pulse sequence for the processor. Parameters. N: intThe number of qubits in the system. params: dictA Python dictionary contains the name and the value of the parameters.; See DispersiveCavityQED.set_up_params for the definition. global_phase: float, optionalRecord of the global phase change and will be returned. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; (pulse_label, coeff), instead of (pulse_index, coeff).; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. N: intThe number of the component systems. params: dictA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc. pulse_dict: dictA map between the pulse label and its index in the pulse list. gate_compiler: dictThe Python dictionary in the form of {gate_name: decompose_function}.; It saves the decomposition scheme for each gate. compile(circuit, schedule_mode=None, args=None)¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA d",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:211711,Integrability,rout,routine,211711,"mpiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate; Notes; This version of sqrtiswap_compiler has very low fidelity, please use; iswap. class SpinChainCompiler(N, params, pulse_dict, setup='linear', global_phase=0.0)[source]¶; Compile a QubitCircuit into; the pulse sequence for the processor. Parameters. N: intThe number of qubits in the system. params: dictA Python dictionary contains the name and the value of the parameters.; See SpinChain.set_up_params for the definition. setup: string“linear” or “circular” for two sub-classes. global_phase: boolRecord of the global phase change and will be returned. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; (pulse_label, coeff), instead of (pulse_index, coeff).; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. N: intThe number of the component systems. params: dictA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc. pulse_dict: dictA map between the pulse label and its index in the pulse list. gate_compiler: dictThe Python dictionary in the form of {gate_name: decompose_function}.; It saves the decomposition scheme for each gate. setup: string“linear” or “circular” for two sub-classes. global_phase: boolRecord of the global phase change and will be returned. compile(circuit, schedule_mode=None, args=None)¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:215474,Integrability,depend,dependency,215474,"e]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commute with CNOT 0, 2. schedule(circuit, gates_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distan",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:215658,Integrability,depend,dependent,215658,"nstruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commute with CNOT 0, 2. schedule(circuit, gates_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate obje",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:215823,Integrability,depend,dependency,215823,"universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commute with CNOT 0, 2. schedule(circuit, gates_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalT",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:216367,Integrability,depend,dependency,216367,"ttributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly sc",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:218944,Integrability,depend,dependent,218944,"1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. targets: list, optionalThe target qubits. controls: list, optionalThe control qubits. used_qubits: setUnion of the control and target qubits. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.loggin",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:220702,Integrability,message,message,220702," instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_paramsDictionaryOptions for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_gradboolIf set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a s",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:226464,Integrability,wrap,wrapper,226464,"ation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object,",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:228007,Integrability,wrap,wrapper,228007,"all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:229463,Integrability,wrap,wrapper,229463,"thm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:230787,Integrability,wrap,wrapper,230787,"tions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter ter",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:231212,Integrability,wrap,wrapper,231212,"ied; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. Attributes. iter_numintIteration n",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:247002,Integrability,message,message,247002,"on assumes that the _apply_phase method has been; set to a custom function. Type; phase_application. property prop¶; List of propagators (Qobj) for each timeslot. property prop_grad¶; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs()[source]¶; Reset the dyn_shape, dyn_dims and time_depend_drift attribs. save_amps(file_name=None, times=None, amps=None, verbose=False)[source]¶; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters. file_namestringName of the file; If None given the def_amps_fname attribuite will be used. timesList type (or string)List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If ‘exclude’ then times will not be saved in the file, just; the amplitudes. ampsArray[num_tslots, num_ctrls]Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verboseBooleanIf True then an info message will be logged. unitarity_check()[source]¶; Checks whether all propagators are unitary. update_ctrl_amps(new_amps)[source]¶; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer. class DynamicsGenMat(optimconfig, params=None)[source]¶; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Lindbladian. class DynamicsUnitary(optimconfig, params=None)[source]¶; This is the subclass to use for systems with dynamics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes. drift_hamQobjThis is the drift Hamiltonian ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:274858,Integrability,depend,depends,274858,grad_computesintegerNumber of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updatesintegerNumber of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iterfloatMean number of control amplitude updates per iteration. num_timeslot_changesintegerNumber of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_updatefloatMean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changesintegerNumber of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_updatefloatMean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes. parentsome control object (Dynamics or Optimizer)aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dirstrdirectory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. levelstringThe level of data dumping that will occur. write_to_fileboolWhen set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based on its dump_to_file attrib. dump_file_extstrDefault file extension for any file names that are auto generated. fname_basestrFirst part of any auto generated file names.; This is usually overridden in the subclass. dump_summaryboolIf True a summary is recorded each time a new item is added to the; the dump.; Default is True. ,MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:24267,Modifiability,variab,variables,24267,"None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations f'(t) = f(g(t)) create a; mismatch between the array and the associated time list. arguments(new_args)[source]¶; Update the scoped variables that were passed as args to new values. compile(code=False, matched=False, dense=False, omp=0)[source]¶; Create an associated Cython object for faster usage. This function is; called automatically by the solvers. Parameters. codebool, default FalseReturn the code string generated by compilation of any strings. matchedbool, default FalseIf True, the underlying sparse matrices used to represent each; element of the type will have their structures unified. This may; include adding explicit zeros to sparse matrices, but can be faster; in some cases due to not having to deal with repeated structural; mismatches. densebool, default FalseWhether to swap to using dense matrices to back the data. ompint, optionalThe number of OpenMP threads to use when doing matrix; multiplications, if QuTiP was compiled with OpenMP. Returns. compiled_strstr(Only if code was set to True). The code-generated string of; compiled calling code. compress()[source]¶; Merge together elements that share the s",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:42732,Modifiability,coupling,coupling,42732,"rval points. alphafloatSecond-order derivative at a. Default is 0. betafloatSecond-order derivative at b. Default is 0. Notes; This object can be called like a normal function with a; single or array of input points at which to evaluate; the interplating function.; Habermann & Kindermann, “Multidimensional Spline Interpolation:; Theory and Applications”, Comput Econ 30, 153 (2007). Attributes. afloatLower bound of the interval. bfloatUpper bound of the interval. coeffsndarrayArray of coeffcients defining cubic spline. Non-Markovian Solvers¶. class HEOMSolver(H_sys, bath, max_depth, options=None, progress_bar=None)[source]¶; HEOM solver that supports multiple baths.; The baths must be all either bosonic or fermionic baths. Parameters. H_sysQObj, QobjEvo or a listThe system Hamiltonian or Liouvillian specified as either a; Qobj, a QobjEvo, or a list of elements; that may be converted to a QobjEvo. bathBath or list of BathA Bath containing the exponents of the expansion of the; bath correlation funcion and their associated coefficients; and coupling operators, or a list of baths.; If multiple baths are given, they must all be either fermionic; or bosonic baths. max_depthintThe maximum depth of the heirarchy (i.e. the maximum number of bath; exponent “excitations” to retain). optionsqutip.solver.OptionsGeneric solver options. If set to None the default options will be; used. progress_barNone, True or BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the solver. If True, an instance of; TextProgressBar is used instead. Attributes. adosHierarchyADOsThe description of the hierarchy constructed from the given bath; and maximum depth. run(rho0, tlist, e_ops=None, ado_init=False, ado_return=False)[source]¶; Solve for the time evolution of the system. Parameters. rho0Qobj or HierarchyADOsState or numpy.arrayInitial state (Qobj density matrix) of the system; if ado_init is False.; If ado_init is True, then rho0 should be an;",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:48210,Modifiability,coupling,coupling,48210,"truction.; An exact copy of the QuTiP 4.6 HSolverDL is provided in; qutip.nonmarkov.dlheom_solver for cases where the functionality of; the older solver is required. The older solver will be completely; removed in QuTiP 5. Note; Unlike the version of HSolverDL in QuTiP 4.6, this solver; supports supplying a time-dependent or Liouvillian H_sys. Note; For compatibility with HSolverDL in QuTiP 4.6 and below, the; parameter N_exp specifying the number of exponents to keep in; the expansion of the bath correlation function is one more than; the equivalent Nk used in the DrudeLorentzBath. I.e.,; Nk = N_exp - 1. The Nk parameter in the; DrudeLorentzBath does not count the zeroeth exponent in; order to better match common usage in the literature. Note; The stats and renorm arguments accepted in QuTiP 4.6 and below; are no longer supported. Parameters. H_sysQobj or QobjEvo or listThe system Hamiltonian or Liouvillian. See HEOMSolver for; a complete description. coup_opQobjOperator describing the coupling between system and bath.; See parameter Q in BosonicBath for a complete description. coup_strengthfloatCoupling strength. Referred to as lam in DrudeLorentzBath. temperaturefloatBath temperature. Referred to as T in DrudeLorentzBath. N_cutintThe maximum depth of the hierarchy. See max_depth in; HEOMSolver for a full description. N_expintNumber of exponential terms used to approximate the bath correlation; functions. The equivalent Nk in DrudeLorentzBath is one; less than N_exp (see note above). cut_freqfloatBath spectral density cutoff frequency. Referred to as gamma in; DrudeLorentzBath. bnd_cut_approxboolUse boundary cut off approximation. If true, the Matsubara; terminator is added to the system Liouvillian (and H_sys is; promoted to a Liouvillian if it was a Hamiltonian). optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_barNone, True or BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:49391,Modifiability,coupling,coupling,49391," in DrudeLorentzBath. temperaturefloatBath temperature. Referred to as T in DrudeLorentzBath. N_cutintThe maximum depth of the hierarchy. See max_depth in; HEOMSolver for a full description. N_expintNumber of exponential terms used to approximate the bath correlation; functions. The equivalent Nk in DrudeLorentzBath is one; less than N_exp (see note above). cut_freqfloatBath spectral density cutoff frequency. Referred to as gamma in; DrudeLorentzBath. bnd_cut_approxboolUse boundary cut off approximation. If true, the Matsubara; terminator is added to the system Liouvillian (and H_sys is; promoted to a Liouvillian if it was a Hamiltonian). optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_barNone, True or BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the solver. If True, an instance of; TextProgressBar is used instead. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. class BathExponent(type, dim, Q, ck, vk, ck2=None, sigma_bar_k_offset=None, tag=None)[source]¶; Represents a single exponent (naively, an excitation mode) within the; decomposition of the correlation functions of a bath. Parameters. type{“R”, “I”, “RI”, “+”, “-“} or BathExponent.ExponentTypeThe type of bath exponent.; “R” and “I” are bosonic bath exponents that appear in the real and; imaginary parts of the correlation expansion.; “RI” is combined bosonic bath exponent that appears in both the real; and imaginary parts of the correlation expansion. The combined exponent; has a single vk. The ck is the coefficient in the real; expansion and ck2 is the coefficient in the imaginary expansion.; “+” and “-” are fermionic bath exponents. These fermionic bath; exponents must specify sigma_bar_k_offset which specifies; the amount to add to k (the exponent index within the bath of this; exponent) to determ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:50619,Modifiability,coupling,coupling,50619,"e correlation functions of a bath. Parameters. type{“R”, “I”, “RI”, “+”, “-“} or BathExponent.ExponentTypeThe type of bath exponent.; “R” and “I” are bosonic bath exponents that appear in the real and; imaginary parts of the correlation expansion.; “RI” is combined bosonic bath exponent that appears in both the real; and imaginary parts of the correlation expansion. The combined exponent; has a single vk. The ck is the coefficient in the real; expansion and ck2 is the coefficient in the imaginary expansion.; “+” and “-” are fermionic bath exponents. These fermionic bath; exponents must specify sigma_bar_k_offset which specifies; the amount to add to k (the exponent index within the bath of this; exponent) to determine the k of the corresponding exponent with; the opposite sign (i.e. “-” or “+”). dimint or NoneThe dimension (i.e. maximum number of excitations for this exponent).; Usually 2 for fermionic exponents or None (i.e. unlimited) for; bosonic exponents. QQobjThe coupling operator for this excitation mode. vkcomplexThe frequency of the exponent of the excitation term. ckcomplexThe coefficient of the excitation term. ck2optional, complexFor exponents of type “RI” this is the coefficient of the term in the; imaginary expansion (and ck is the coefficient in the real; expansion). sigma_bar_k_offsetoptional, intFor exponents of type “+” this gives the offset (within the list of; exponents within the bath) of the corresponding “-” bath exponent.; For exponents of type “-” it gives the offset of the corresponding; “+” exponent. tagoptional, str, tuple or any other objectA label for the exponent (often the name of the bath). It; defaults to None. Attributes. All of the parameters are available as attributes. types¶; alias of qutip.nonmarkov.bofin_baths.ExponentType. class Bath(exponents)[source]¶; Represents a list of bath expansion exponents. Parameters. exponentslist of BathExponentThe exponents of the correlation function describing the bath. Attributes. All of the ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:52319,Modifiability,coupling,coupling,52319,"e parameters are available as attributes. types¶; alias of qutip.nonmarkov.bofin_baths.ExponentType. class Bath(exponents)[source]¶; Represents a list of bath expansion exponents. Parameters. exponentslist of BathExponentThe exponents of the correlation function describing the bath. Attributes. All of the parameters are available as attributes. class BosonicBath(Q, ck_real, vk_real, ck_imag, vk_imag, combine=True, tag=None)[source]¶; A helper class for constructing a bosonic bath from the expansion; coefficients and frequencies for the real and imaginary parts of; the bath correlation function.; If the correlation functions C(t) is split into real and imaginary; parts:; C(t) = C_real(t) + i * C_imag(t). then:; C_real(t) = sum(ck_real * exp(- vk_real * t)); C_imag(t) = sum(ck_imag * exp(- vk_imag * t)). Defines the coefficients ck and the frequencies vk.; Note that the ck and vk may be complex, even through C_real(t); and C_imag(t) (i.e. the sum) is real. Parameters. QQobjThe coupling operator for the bath. ck_reallist of complexThe coefficients of the expansion terms for the real part of the; correlation function. The corresponding frequencies are passed as; vk_real. vk_reallist of complexThe frequencies (exponents) of the expansion terms for the real part of; the correlation function. The corresponding ceofficients are passed as; ck_real. ck_imaglist of complexThe coefficients of the expansion terms in the imaginary part of the; correlation function. The corresponding frequencies are passed as; vk_imag. vk_imaglist of complexThe frequencies (exponents) of the expansion terms for the imaginary; part of the correlation function. The corresponding ceofficients are; passed as ck_imag. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identi",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:53123,Modifiability,coupling,coupling,53123,"t)); C_imag(t) = sum(ck_imag * exp(- vk_imag * t)). Defines the coefficients ck and the frequencies vk.; Note that the ck and vk may be complex, even through C_real(t); and C_imag(t) (i.e. the sum) is real. Parameters. QQobjThe coupling operator for the bath. ck_reallist of complexThe coefficients of the expansion terms for the real part of the; correlation function. The corresponding frequencies are passed as; vk_real. vk_reallist of complexThe frequencies (exponents) of the expansion terms for the real part of; the correlation function. The corresponding ceofficients are passed as; ck_real. ck_imaglist of complexThe coefficients of the expansion terms in the imaginary part of the; correlation function. The corresponding frequencies are passed as; vk_imag. vk_imaglist of complexThe frequencies (exponents) of the expansion terms for the imaginary; part of the correlation function. The corresponding ceofficients are; passed as ck_imag. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. classmethod combine(exponents, rtol=1e-05, atol=1e-07)[source]¶; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present.; Exponents with the same frequency are only combined if they share the; same coupling operator .Q.; Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters. exponentslist of BathExponentThe list of exponents to combine. rtolfloat, default 1e-5The relative tolerance to use to when comparing frequencies and; coupling operators. atolfloat, default 1e-7The absolute tolerance to use to when comparing frequencies and; coupling operators. Ret",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:53614,Modifiability,coupling,coupling,53614,"rms for the real part of; the correlation function. The corresponding ceofficients are passed as; ck_real. ck_imaglist of complexThe coefficients of the expansion terms in the imaginary part of the; correlation function. The corresponding frequencies are passed as; vk_imag. vk_imaglist of complexThe frequencies (exponents) of the expansion terms for the imaginary; part of the correlation function. The corresponding ceofficients are; passed as ck_imag. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. classmethod combine(exponents, rtol=1e-05, atol=1e-07)[source]¶; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present.; Exponents with the same frequency are only combined if they share the; same coupling operator .Q.; Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters. exponentslist of BathExponentThe list of exponents to combine. rtolfloat, default 1e-5The relative tolerance to use to when comparing frequencies and; coupling operators. atolfloat, default 1e-7The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns. list of BathExponentThe new reduced list of exponents. class DrudeLorentzBath(Q, lam, gamma, T, Nk, combine=True, tag=None)[source]¶; A helper class for constructing a Drude-Lorentz bosonic bath from the; bath parameters (see parameters below). Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath corre",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:53960,Modifiability,coupling,coupling,53960," terms for the imaginary; part of the correlation function. The corresponding ceofficients are; passed as ck_imag. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. classmethod combine(exponents, rtol=1e-05, atol=1e-07)[source]¶; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present.; Exponents with the same frequency are only combined if they share the; same coupling operator .Q.; Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters. exponentslist of BathExponentThe list of exponents to combine. rtolfloat, default 1e-5The relative tolerance to use to when comparing frequencies and; coupling operators. atolfloat, default 1e-7The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns. list of BathExponentThe new reduced list of exponents. class DrudeLorentzBath(Q, lam, gamma, T, Nk, combine=True, tag=None)[source]¶; A helper class for constructing a Drude-Lorentz bosonic bath from the; bath parameters (see parameters below). Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an e",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:54068,Modifiability,coupling,coupling,54068,"_imag. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. classmethod combine(exponents, rtol=1e-05, atol=1e-07)[source]¶; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present.; Exponents with the same frequency are only combined if they share the; same coupling operator .Q.; Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters. exponentslist of BathExponentThe list of exponents to combine. rtolfloat, default 1e-5The relative tolerance to use to when comparing frequencies and; coupling operators. atolfloat, default 1e-7The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns. list of BathExponentThe new reduced list of exponents. class DrudeLorentzBath(Q, lam, gamma, T, Nk, combine=True, tag=None)[source]¶; A helper class for constructing a Drude-Lorentz bosonic bath from the; bath parameters (see parameters below). Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. terminator()[source]¶; Return the Matsubara terminator for the bath and the calculated; app",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:54383,Modifiability,coupling,coupling,54383,"e(exponents, rtol=1e-05, atol=1e-07)[source]¶; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present.; Exponents with the same frequency are only combined if they share the; same coupling operator .Q.; Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters. exponentslist of BathExponentThe list of exponents to combine. rtolfloat, default 1e-5The relative tolerance to use to when comparing frequencies and; coupling operators. atolfloat, default 1e-7The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns. list of BathExponentThe new reduced list of exponents. class DrudeLorentzBath(Q, lam, gamma, T, Nk, combine=True, tag=None)[source]¶; A helper class for constructing a Drude-Lorentz bosonic bath from the; bath parameters (see parameters below). Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. terminator()[source]¶; Return the Matsubara terminator for the bath and the calculated; approximation discrepancy. Returns. delta: floatThe approximation discrepancy. That is, the difference between the; true correlation function of the Drude-Lorentz bath and the sum of; the Nk exponential terms is approximately 2 * delta *; dirac(t), where dirac(t) denotes the Dirac delta function. terminatorQobjThe Matsubara terminator – i.e. a liouvilli",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:54687,Modifiability,coupling,coupling,54687," exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters. exponentslist of BathExponentThe list of exponents to combine. rtolfloat, default 1e-5The relative tolerance to use to when comparing frequencies and; coupling operators. atolfloat, default 1e-7The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns. list of BathExponentThe new reduced list of exponents. class DrudeLorentzBath(Q, lam, gamma, T, Nk, combine=True, tag=None)[source]¶; A helper class for constructing a Drude-Lorentz bosonic bath from the; bath parameters (see parameters below). Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. terminator()[source]¶; Return the Matsubara terminator for the bath and the calculated; approximation discrepancy. Returns. delta: floatThe approximation discrepancy. That is, the difference between the; true correlation function of the Drude-Lorentz bath and the sum of; the Nk exponential terms is approximately 2 * delta *; dirac(t), where dirac(t) denotes the Dirac delta function. terminatorQobjThe Matsubara terminator – i.e. a liouvillian term representing; the contribution to the system-bath dynamics of all exponential; expansion terms beyond Nk. It should be used by adding it to; the system liouvillian (i.e. liouvillian(H_sys)). class DrudeLorentzPadeBath(Q, lam, gamma, T, Nk, combine=True, tag=None",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:56420,Modifiability,coupling,coupling,56420,"on to the system-bath dynamics of all exponential; expansion terms beyond Nk. It should be used by adding it to; the system liouvillian (i.e. liouvillian(H_sys)). class DrudeLorentzPadeBath(Q, lam, gamma, T, Nk, combine=True, tag=None)[source]¶; A helper class for constructing a Padé expansion for a Drude-Lorentz; bosonic bath from the bath parameters (see parameters below).; A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant).; The application of the Padé method to spectrum decompoisitions is described; in “Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems” [1].; The implementation here follows the approach in the paper.; [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466; This is an alternative to the DrudeLorentzBath which constructs; a simpler exponential expansion. Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. TfloatBath temperature. NkintNumber of Padé exponentials terms used to approximate the bath; correlation functions. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. terminator()[source]¶; Return the Padé terminator for the bath and the calculated; approximation discrepancy. Returns. delta: floatThe approximation discrepancy. That is, the difference between the; true correlation function of the Drude-Lorentz bath and the sum of; the Nk exponential terms is approximately 2 * delta *; dirac(t), where dirac(t) denotes the Dirac delta function. terminatorQobjThe Padé terminator – i.e. a liouvillian t",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:56730,Modifiability,coupling,coupling,56730," a Padé expansion for a Drude-Lorentz; bosonic bath from the bath parameters (see parameters below).; A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant).; The application of the Padé method to spectrum decompoisitions is described; in “Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems” [1].; The implementation here follows the approach in the paper.; [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466; This is an alternative to the DrudeLorentzBath which constructs; a simpler exponential expansion. Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. TfloatBath temperature. NkintNumber of Padé exponentials terms used to approximate the bath; correlation functions. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. terminator()[source]¶; Return the Padé terminator for the bath and the calculated; approximation discrepancy. Returns. delta: floatThe approximation discrepancy. That is, the difference between the; true correlation function of the Drude-Lorentz bath and the sum of; the Nk exponential terms is approximately 2 * delta *; dirac(t), where dirac(t) denotes the Dirac delta function. terminatorQobjThe Padé terminator – i.e. a liouvillian term representing; the contribution to the system-bath dynamics of all exponential; expansion terms beyond Nk. It should be used by adding it to; the system liouvillian (i.e. liouvillian(H_sys)). class UnderDampedBath(Q, lam, gamma, w0, T, Nk, combine=True, tag=None)[source]¶;",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:57851,Modifiability,coupling,coupling,57851,"exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. terminator()[source]¶; Return the Padé terminator for the bath and the calculated; approximation discrepancy. Returns. delta: floatThe approximation discrepancy. That is, the difference between the; true correlation function of the Drude-Lorentz bath and the sum of; the Nk exponential terms is approximately 2 * delta *; dirac(t), where dirac(t) denotes the Dirac delta function. terminatorQobjThe Padé terminator – i.e. a liouvillian term representing; the contribution to the system-bath dynamics of all exponential; expansion terms beyond Nk. It should be used by adding it to; the system liouvillian (i.e. liouvillian(H_sys)). class UnderDampedBath(Q, lam, gamma, w0, T, Nk, combine=True, tag=None)[source]¶; A helper class for constructing an under-damped bosonic bath from the; bath parameters (see parameters below). Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. w0floatBath spectral density resonance frequency. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. class FermionicBath(Q, ck_plus, vk_plus, ck_minus, vk_minus, tag=None)[source]¶; A helper class for constructing a fermionic bath from the expansion; coefficients and frequencies for the + and - modes of; the bath correlation function.; There must be the same number of + and - modes and their; coefficients must be specified in the same order so that ck_plus[i],; vk_plus[i] are the plus coef",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:58205,Modifiability,coupling,coupling,58205,"tween the; true correlation function of the Drude-Lorentz bath and the sum of; the Nk exponential terms is approximately 2 * delta *; dirac(t), where dirac(t) denotes the Dirac delta function. terminatorQobjThe Padé terminator – i.e. a liouvillian term representing; the contribution to the system-bath dynamics of all exponential; expansion terms beyond Nk. It should be used by adding it to; the system liouvillian (i.e. liouvillian(H_sys)). class UnderDampedBath(Q, lam, gamma, w0, T, Nk, combine=True, tag=None)[source]¶; A helper class for constructing an under-damped bosonic bath from the; bath parameters (see parameters below). Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. w0floatBath spectral density resonance frequency. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. class FermionicBath(Q, ck_plus, vk_plus, ck_minus, vk_minus, tag=None)[source]¶; A helper class for constructing a fermionic bath from the expansion; coefficients and frequencies for the + and - modes of; the bath correlation function.; There must be the same number of + and - modes and their; coefficients must be specified in the same order so that ck_plus[i],; vk_plus[i] are the plus coefficient and frequency corresponding; to the minus mode ck_minus[i], vk_minus[i].; In the fermionic case the order in which excitations are created or; destroyed is important, resulting in two different correlation functions; labelled C_plus(t) and C_plus(t):; C_plus(t) = sum(ck_plus * exp(- vk_plus * t)); C_minus(t) = ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:59309,Modifiability,coupling,coupling,59309,"he bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. class FermionicBath(Q, ck_plus, vk_plus, ck_minus, vk_minus, tag=None)[source]¶; A helper class for constructing a fermionic bath from the expansion; coefficients and frequencies for the + and - modes of; the bath correlation function.; There must be the same number of + and - modes and their; coefficients must be specified in the same order so that ck_plus[i],; vk_plus[i] are the plus coefficient and frequency corresponding; to the minus mode ck_minus[i], vk_minus[i].; In the fermionic case the order in which excitations are created or; destroyed is important, resulting in two different correlation functions; labelled C_plus(t) and C_plus(t):; C_plus(t) = sum(ck_plus * exp(- vk_plus * t)); C_minus(t) = sum(ck_minus * exp(- vk_minus * t)). where the expansions above define the coeffiients ck and the; frequencies vk. Parameters. QQobjThe coupling operator for the bath. ck_pluslist of complexThe coefficients of the expansion terms for the + part of the; correlation function. The corresponding frequencies are passed as; vk_plus. vk_pluslist of complexThe frequencies (exponents) of the expansion terms for the + part; of the correlation function. The corresponding ceofficients are passed; as ck_plus. ck_minuslist of complexThe coefficients of the expansion terms for the - part of the; correlation function. The corresponding frequencies are passed as; vk_minus. vk_minuslist of complexThe frequencies (exponents) of the expansion terms for the - part; of the correlation function. The corresponding ceofficients are passed; as ck_minus. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. class LorentzianBath(Q, gamma, w, mu, T, Nk, tag=None)[source]¶; A helper class for constructing a Lorentzian ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:60628,Modifiability,coupling,coupling,60628,"sponding ceofficients are passed; as ck_plus. ck_minuslist of complexThe coefficients of the expansion terms for the - part of the; correlation function. The corresponding frequencies are passed as; vk_minus. vk_minuslist of complexThe frequencies (exponents) of the expansion terms for the - part; of the correlation function. The corresponding ceofficients are passed; as ck_minus. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. class LorentzianBath(Q, gamma, w, mu, T, Nk, tag=None)[source]¶; A helper class for constructing a Lorentzian fermionic bath from the; bath parameters (see parameters below). Note; This Matsubara expansion used in this bath converges very slowly; and Nk > 20 may be required to get good convergence. The; Padé expansion used by LorentzianPadeBath converges much; more quickly. Parameters. QQobjOperator describing the coupling between system and bath. gammafloatThe coupling strength between the system and the bath. wfloatThe width of the environment. mufloatThe chemical potential of the bath. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. class LorentzianPadeBath(Q, gamma, w, mu, T, Nk, tag=None)[source]¶; A helper class for constructing a Padé expansion for Lorentzian fermionic; bath from the bath parameters (see parameters below).; A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant).; The application of the Padé method to spectrum decompoisitions is described; in “Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:60676,Modifiability,coupling,coupling,60676,"mplexThe coefficients of the expansion terms for the - part of the; correlation function. The corresponding frequencies are passed as; vk_minus. vk_minuslist of complexThe frequencies (exponents) of the expansion terms for the - part; of the correlation function. The corresponding ceofficients are passed; as ck_minus. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. class LorentzianBath(Q, gamma, w, mu, T, Nk, tag=None)[source]¶; A helper class for constructing a Lorentzian fermionic bath from the; bath parameters (see parameters below). Note; This Matsubara expansion used in this bath converges very slowly; and Nk > 20 may be required to get good convergence. The; Padé expansion used by LorentzianPadeBath converges much; more quickly. Parameters. QQobjOperator describing the coupling between system and bath. gammafloatThe coupling strength between the system and the bath. wfloatThe width of the environment. mufloatThe chemical potential of the bath. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. class LorentzianPadeBath(Q, gamma, w, mu, T, Nk, tag=None)[source]¶; A helper class for constructing a Padé expansion for Lorentzian fermionic; bath from the bath parameters (see parameters below).; A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant).; The application of the Padé method to spectrum decompoisitions is described; in “Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems” [1].; The implementation here follows the",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:61987,Modifiability,coupling,coupling,61987,"s (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. class LorentzianPadeBath(Q, gamma, w, mu, T, Nk, tag=None)[source]¶; A helper class for constructing a Padé expansion for Lorentzian fermionic; bath from the bath parameters (see parameters below).; A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant).; The application of the Padé method to spectrum decompoisitions is described; in “Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems” [1].; The implementation here follows the approach in the paper.; [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466; This is an alternative to the LorentzianBath which constructs; a simpler exponential expansion that converges much more slowly in; this particular case. Parameters. QQobjOperator describing the coupling between system and bath. gammafloatThe coupling strength between the system and the bath. wfloatThe width of the environment. mufloatThe chemical potential of the bath. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. class HierarchyADOs(exponents, max_depth)[source]¶; A description of ADOs (auxilliary density operators) with the; hierarchical equations of motion.; The list of ADOs is constructed from a list of bath exponents; (corresponding to one or more baths). Each ADO is referred to by a label; that lists the number of “excitations” of each bath exponent. The; level of a label within the hierarchy is the sum of the “excitations”; within the label.; For example the label (0, 0, ..., 0) represents the density matrix; of th",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:62035,Modifiability,coupling,coupling,62035,"can be set to help identify which; bath an exponent is from. class LorentzianPadeBath(Q, gamma, w, mu, T, Nk, tag=None)[source]¶; A helper class for constructing a Padé expansion for Lorentzian fermionic; bath from the bath parameters (see parameters below).; A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant).; The application of the Padé method to spectrum decompoisitions is described; in “Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems” [1].; The implementation here follows the approach in the paper.; [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466; This is an alternative to the LorentzianBath which constructs; a simpler exponential expansion that converges much more slowly in; this particular case. Parameters. QQobjOperator describing the coupling between system and bath. gammafloatThe coupling strength between the system and the bath. wfloatThe width of the environment. mufloatThe chemical potential of the bath. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. class HierarchyADOs(exponents, max_depth)[source]¶; A description of ADOs (auxilliary density operators) with the; hierarchical equations of motion.; The list of ADOs is constructed from a list of bath exponents; (corresponding to one or more baths). Each ADO is referred to by a label; that lists the number of “excitations” of each bath exponent. The; level of a label within the hierarchy is the sum of the “excitations”; within the label.; For example the label (0, 0, ..., 0) represents the density matrix; of the system being solved and is the only 0th level label.; The labe",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:68978,Modifiability,coupling,coupling,68978," a full representation of; the ADO states. Parameters. idxint or labelThe index of the ADO to extract. If an ADO label, e.g.; (0, 1, 0, ...) is supplied instead, then the ADO; is extracted by label instead. Returns. QobjA Qobj representing the state of the specified ADO. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class HEOMSolver[source]¶; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/Ph",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:69114,Modifiability,config,configure,69114,"ified ADO. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class HEOMSolver[source]¶; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:69316,Modifiability,config,configure,69316,"ified ADO. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class HEOMSolver[source]¶; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:69654,Modifiability,evolve,evolves,69654," exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class HEOMSolver[source]¶; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been d",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:70906,Modifiability,coupling,coupling,70906,"this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes. H_sysQobjSystem Hamiltonian. coup_opQobjOperator describing the coupling between system and bath. coup_strengthfloatCoupling strength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmann’s constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=N",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:71800,Modifiability,config,configure,71800,"g strength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmann’s constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class MemoryCascade(H_",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:72866,Modifiability,config,config,72866,"=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; C",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:73305,Modifiability,coupling,coupling,73305,", or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Co",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:73438,Modifiability,coupling,coupling,73438," to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dag",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:93515,Modifiability,evolve,evolves,93515,"n the Dicke basis. lindbladian()[source]¶; Build the Lindbladian superoperator of the dissipative dynamics. Returns. lindbladianqutip.QobjThe Lindbladian matrix as a qutip.Qobj. liouvillian()[source]¶; Build the total Liouvillian using the Dicke basis. Returns. liouvqutip.QobjThe Liouvillian matrix for the system. pisolve(initial_state, tlist, options=None)[source]¶; Solve for diagonal Hamiltonians and initial states faster. Parameters. initial_statequtip.QobjAn initial state specified as a density matrix of; qutip.Qbj type. tlist: ndarrayA 1D numpy array of list of timesteps to integrate. optionsqutip.solver.OptionsThe options for the solver. Returns. result: listA dictionary of the type qutip.solver.Result which holds the; results of the evolution. class Pim(N, emission=0.0, dephasing=0, pumping=0, collective_emission=0, collective_pumping=0, collective_dephasing=0)[source]¶; The Permutation Invariant Matrix class.; Initialize the class with the parameters for generating a Permutation; Invariant matrix which evolves a given diagonal initial state p as:. dp/dt = Mp. Parameters. N: intThe number of two-level systems. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: floatLocal dephasing coefficient.; default: 0.0. pumping: floatIncoherent pumping coefficient.; default: 0.0. collective_emission: floatCollective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: floatCollective pumping coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coefficient.; default: 0.0. Attributes. N: intThe number of two-level systems. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: floatLocal dephasing coefficient.; default: 0.0. pumping: floatIncoherent pumping coefficient.; default: 0.0. collective_emission: floatCollective (superradiant) emmission coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coefficient.;",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:97994,Modifiability,coupling,coupling,97994," be checked. Returns. taus: dictA dictionary of key, val as {tau: value} consisting of the valid; taus for this row and column of the Dicke space element. One-Dimensional Lattice¶. class Lattice1d(num_cell=10, boundary='periodic', cell_num_site=1, cell_site_dof=[1], Hamiltonian_of_cell=None, inter_hop=None)[source]¶; A class for representing a 1d crystal.; The Lattice1d class can be defined with any specific unit cells and a; specified number of unit cells in the crystal. It can return dispersion; relationship, position operators, Hamiltonian in the position represention; etc. Parameters. num_cellintThe number of cells in the crystal. boundarystrSpecification of the type of boundary the crystal is defined with. cell_num_siteintThe number of sites in the unit cell. cell_site_doflist of int/ intThe tensor structure of the degrees of freedom at each site of a unit; cell. Hamiltonian_of_cellqutip.QobjThe Hamiltonian of the unit cell. inter_hopqutip.Qobj / list of QobjThe coupling between the unit cell at i and at (i+unit vector). Attributes. num_cellintThe number of unit cells in the crystal. cell_num_siteintThe nuber of sites in a unit cell. length_for_siteintThe length of the dimension per site of a unit cell. cell_tensor_configlist of intThe tensor structure of the cell in the form; [cell_num_site,cell_site_dof[:][0] ]. lattice_tensor_configlist of intThe tensor structure of the crystal in the; form [num_cell,cell_num_site,cell_site_dof[:][0]]. length_of_unit_cellintThe length of the dimension for a unit cell. period_bnd_cond_xint1 indicates “periodic” and 0 indicates “hardwall” boundary condition. inter_vec_listlist of listThe list of list of coefficients of inter unitcell vectors’ components; along Cartesian uit vectors. lattice_vectors_listlist of listThe list of list of coefficients of lattice basis vectors’ components; along Cartesian unit vectors. H_intraqutip.QobjThe Qobj storing the Hamiltonian of the unnit cell. H_inter_listlist of Qobj/ qutip.QobjThe list o",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:99014,Modifiability,coupling,coupling,99014,"and at (i+unit vector). Attributes. num_cellintThe number of unit cells in the crystal. cell_num_siteintThe nuber of sites in a unit cell. length_for_siteintThe length of the dimension per site of a unit cell. cell_tensor_configlist of intThe tensor structure of the cell in the form; [cell_num_site,cell_site_dof[:][0] ]. lattice_tensor_configlist of intThe tensor structure of the crystal in the; form [num_cell,cell_num_site,cell_site_dof[:][0]]. length_of_unit_cellintThe length of the dimension for a unit cell. period_bnd_cond_xint1 indicates “periodic” and 0 indicates “hardwall” boundary condition. inter_vec_listlist of listThe list of list of coefficients of inter unitcell vectors’ components; along Cartesian uit vectors. lattice_vectors_listlist of listThe list of list of coefficients of lattice basis vectors’ components; along Cartesian unit vectors. H_intraqutip.QobjThe Qobj storing the Hamiltonian of the unnit cell. H_inter_listlist of Qobj/ qutip.QobjThe list of coupling terms between unit cells of the lattice. is_realboolIndicates if the Hamiltonian is real or not. Hamiltonian()[source]¶; Returns the lattice Hamiltonian for the instance of Lattice1d. Returns. Qobj(Hamil)qutip.Qobjoper type Quantum object representing the lattice Hamiltonian. basis(cell, site, dof_ind)[source]¶; Returns a single particle wavefunction ket with the particle localized; at a specified dof at a specified site of a specified cell. Parameters. cell (int) – The cell at which the particle is to be localized.; site (int) – The site of the cell at which the particle is to be localized.; dof_ind (int/ list of int) – The index of the degrees of freedom with which the sigle particle; is to be localized. Returns. vec_iqutip.Qobjket type Quantum object representing the localized particle. bloch_wave_functions()[source]¶; Returns eigenvectors ($psi_n(k)$) of the Hamiltonian in a; numpy.ndarray for translationally symmetric lattices with periodic; boundary condition. \begin{eqnarray}; |\psi_n(k",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:101911,Modifiability,coupling,coupling,101911,"od quantum number k. cell_periodic_parts()[source]¶; Returns eigenvectors of the bulk Hamiltonian, i.e. the cell periodic; part($u_n(k)$) of the Bloch wavefunctios in a numpy.ndarray for; translationally symmetric lattices with periodic boundary condition. \begin{eqnarray}; |\psi_n(k) \rangle = |k \rangle \otimes | u_{n}(k) \rangle \\; | u_{n}(k) \rangle = a_n(k)|a\rangle + b_n(k)|b\rangle \\; \end{eqnarray}Please see section 1.2 of Asbóth, J. K., Oroszlány, L., & Pályi, A.; (2016). A short course on topological insulators. Lecture notes in; physics, 919 for a review. Returns. knxanp.arrayknxA[j][0] is the jth good Quantum number k. vec_knsnp.ndarray of Qobj’svec_kns[j] is the Oobj of type ket that holds an eigenvector of the; bulk Hamiltonian of the lattice. display_lattice()[source]¶; Produces a graphic portraying the lattice symbolically with a unit cell; marked in it. Returns. inter_TQobjThe coefficient of $psi_{i,N}^{dagger}psi_{0,i+1}$, i.e. the; coupling between the two boundary sites of the two unit cells i and; i+1. display_unit_cell(label_on=False)[source]¶; Produces a graphic displaying the unit cell features with labels on if; defined by user. Also returns a dict of Qobj’s corresponding to the; labeled elements on the display. Returns. HcelldictHcell[i][j] is the Hamiltonian segment for $H_{i,j}$ labeled on the; graphic. distribute_operator(op)[source]¶; A function that returns an operator matrix that applies op to all the; cells in the 1d lattice. Parameters; op (qutip.Qobj) – Qobj representing the operator to be applied at all cells. Returns. op_Hqutip.QobjQuantum object representing the operator with op applied at all; cells. get_dispersion(knpoints=0)[source]¶; Returns dispersion relationship for the lattice with the specified; number of unit cells with a k array and a band energy array. Returns. knxanp.arrayknxA[j][0] is the jth good Quantum number k. val_knsnp.arrayval_kns[j][:] is the array of band energies of the jth band good at; all the good Qua",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:111153,Modifiability,variab,variable,111153,"cified by the index. class QubitCircuit(N, input_states=None, output_states=None, reverse_states=True, user_gates=None, dims=None, num_cbits=0)[source]¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. Parameters. NintNumber of qubits in the system. user_gatesdictDefine a dictionary of the custom gates. See examples for detail. input_stateslistA list of string such as 0,’+’, “A”, “Y”. Only used for latex. dimslistA list of integer for the dimension of each composite system.; e.g [2,2,2,2,2] for 5 qubits system. If None, qubits system; will be the default option. num_cbitsintNumber of classical bits in the system. Examples; >>> def user_gate():; ... mat = np.array([[1., 0],; ... [0., 1.j]]); ... return Qobj(mat, dims=[[2], [2]]); >>> qubit_circuit = QubitCircuit(2, user_gates={""T"":user_gate}); >>> qubit_circuit.add_gate(""T"", targets=[0]). add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None, classical_controls=None, control_value=None)[source]¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters. namestringGate name. startintStarting location of qubits. endintLast qubit for the gate. qubitslistSpecific qubits for applying gates. arg_valuefloatArgument value(phi). arg_labelstringLabel for gate representation. add_circuit(qc, start=0, overwrite_user_gates=False)[source]¶; Adds a block of a qubit circuit to the main circuit.; Globalphase gates are not added. Parameters. qcQubitCircuitThe circuit block to be added to the main circuit. startintThe qubit on which the first gate is applied. add_gate(gate, targets=None, controls=None, arg_value=None, arg_label=None, index=None, classical_controls=None, control_value=None)[source]¶; Adds a gate with specified parameters to the circuit. Parameters. gate: string or :class:`.Gate`Gate name. If gate is an instance of Gate, parameters are; ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:118587,Modifiability,variab,variables,118587,"t(final_states, probabilities, cbits=None)[source]¶. get_cbits(index=None)[source]¶; Return list of classical bit outputs corresponding to the results. Parameters. index: intIndicates i-th output, probability pair to be returned. Returns. cbits: list of int or list of list of intlist of classical bit outputs. get_final_states(index=None)[source]¶; Return list of output states. Parameters. index: intIndicates i-th state to be returned. Returns. final_states: Qobj or list of Qobj.List of output kets or density matrices. get_probabilities(index=None)[source]¶; Return list of probabilities corresponding to the output states. Parameters. index: intIndicates i-th probability to be returned. Returns. probabilities: float or list of floatProbabilities associated with each output state. class CircuitSimulator(qc, state=None, cbits=None, U_list=None, measure_results=None, mode='state_vector_simulator', precompute_unitary=False)[source]¶. initialize(state=None, cbits=None, measure_results=None)[source]¶; Reset Simulator state variables to start a new run. Parameters. state: ket or operket or density matrix. cbits: list of int, optionalinitial value of classical bits. U_list: list of Qobj, optionallist of predefined unitaries corresponding to circuit. measure_resultstuple of ints, optionaloptional specification of each measurement result to enable; post-selection. If specified, the measurement results are; set to the tuple of bits (sequentially) instead of being; chosen at random. run(state, cbits=None, measure_results=None)[source]¶; Calculate the result of one instance of circuit run. Parameters. stateket or operstate vector or density matrix input. cbitsList of ints, optionalinitialization of the classical bits. measure_resultstuple of ints, optionaloptional specification of each measurement result to enable; post-selection. If specified, the measurement results are; set to the tuple of bits (sequentially) instead of being; chosen at random. Returns. result: CircuitResultRetu",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:160396,Modifiability,coupling,coupling,160396,"tance of the class; qutip.solver.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class LinearSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the physical implementation of; a linear spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe epsil",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:170848,Modifiability,coupling,coupling,170848,"of the class; qutip.solver.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class CircularSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the physical implementation of; a circular spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe e",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:181304,Modifiability,coupling,coupling,181304,"of the class; qutip.solver.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class DispersiveCavityQED(N, correct_global_phase=True, num_levels=10, deltamax=1.0, epsmax=9.5, w0=10.0, wq=None, eps=9.5, delta=0.0, g=0.01, t1=None, t2=None)[source]¶; The processor based on the physical implementation of; a dispersive cavity QED system.; The available Hamiltonian of the system is predefined.; For a given pulse amplitude matrix, the processor can; calculate the state evolution under the given control pulse,; either analytically or numerically.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_ph",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:192563,Modifiability,coupling,coupling,192563,"lytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(N, num_levels, deltamax, epsmax, w0, wq, eps, delta, g)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, “w0”, “eps”, “delta”; and “g”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “g”, list element i is the interaction; between qubits i and i+1. Parameters. N: intThe number of qubits in the system. num_levels: intThe number of energy levels in the resonator. deltamax: listThe coefficients of sigma-x for each of the qubits in the system. epsmax: listThe coefficients of sigma-z for each of the qubits in the system. wo: intThe base frequency of the resonator. wq: listThe frequency of the qubits. eps: listThe epsilon for each of the qubits in the system. delta: listThe delta for each of the qubits in the system. g: listThe interaction strength for each of the qubit with the resonator. Notes; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class Noise[source]¶; The base class representing noise in a processor.; The noise object can be added to Processor and; contributes to evolution. get_noisy_dynamics(dims, pulses, systematic_noise)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dumm",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:200366,Modifiability,variab,variables,200366,"s:Key word arguments for the random number generator. get_noisy_dynamics(dims=None, pulses=None, systematic_noise=None)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dummy Pulse object. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits system. pulses: list of :class:`.Pulse`The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`The dummy pulse with no ideal control element. Returns. noisy_pulses: list of PulseNoisy pulses. systematic_noise: PulseThe dummy pulse representing pulse independent noise. class Pulse(qobj, targets, tlist=None, coeff=None, spline_kind=None, label='')[source]¶; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; qobj, targets, tlist and coeff.; See examples for different construction behavior. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the ideal pulse. targets: listtarget qubits of the ideal pulse; (or subquantum system of other dimensions). tlist: array-like, optionaltlist of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; tlist does not have to be equidistant, but must have the same length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind. coeff: array-like or bool, optionalTime-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for the parameter spline_kind.; If a bool, the coefficient is a constant 1 or 0. spline_kind: str, optionalType of the coefficient interpolation:; “step_func” or “cubic”.; -“step_func”:; The coefficient will be treated as a step function.; E.g. tlist=[0,1,2] ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:219403,Modifiability,config,config,219403,"Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. targets: list, optionalThe target qubits. controls: list, optionalThe control qubits. used_qubits: setUnion of the control and target qubits. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgo",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:219706,Modifiability,config,configuration,219706,"hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. targets: list, optionalThe target qubits. controls: list, optionalThe control qubits. used_qubits: setUnion of the control and target qubits. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:222218,Modifiability,config,configOptimConfig,222218,"rapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpqutip.control.dump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file i",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:222252,Modifiability,config,configuration,222252,"rapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpqutip.control.dump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file i",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:224938,Modifiability,variab,variable,224938,"imize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is t",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:225342,Modifiability,variab,variables,225342,"f they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimi",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:225496,Modifiability,variab,variables,225496,"lt); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default fu",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:225536,Modifiability,variab,variable,225536,"dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:226198,Modifiability,config,configuration,226198,"get, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:227530,Modifiability,config,config,227530,"spect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; th",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:228363,Modifiability,config,config,228363," in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:228524,Modifiability,variab,variable,228524,", dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:228972,Modifiability,config,configuration,228972,"l minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which inclu",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:230027,Modifiability,config,config,230027,"mplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:230592,Modifiability,config,configuration,230592,"ablished implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall t",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:230631,Modifiability,config,config,230631,"SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation wil",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:245322,Modifiability,config,configuration,245322,"ion operators (Qobj) from the initial to the given; timeslot. get_ctrl_dyn_gen(j)[source]¶; Get the dynamics generator for the control; Not implemented in the base class. Choose a subclass. get_drift_dim()[source]¶; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N. get_dyn_gen(k)[source]¶; Get the combined dynamics generator for the timeslot; Not implemented in the base class. Choose a subclass. get_num_ctrls()[source]¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. init_timeslots()[source]¶; Generate the timeslot duration array ‘tau’ based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array ‘time’ based on the tau values. initialize_controls(amps, init_tslots=True)[source]¶; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated. property num_ctrls¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. property onto_evo¶; List of evolution operators (Qobj) from the initial to the given; timeslot. property onwd_evo¶; List of evolution operators (Qobj) from the initial to the given; timeslot. property phase_application¶; scalar(string), default=’preop’; Determines how the phase is applied to the dynamics generators. ‘preop’ : P = expm(phase*dyn_gen); ‘postop’ : P = expm(dyn_gen*phase); ‘custom’ : Customised phase application. The ‘custom’ option assumes that the _apply_phase method has been; set to a custom function. Type; phase_application. property prop¶; List of propagators (Qobj) for each timeslot. property prop_grad¶; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs()[source]¶; Reset ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:248706,Modifiability,config,configuration,248706,"amics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes. drift_hamQobjThis is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_hamList of QobjThese are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. HList of QobjThe combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls. check_unitarity()[source]¶; Checks whether all propagators are unitary; For propagators found not to be unitary, the potential underlying; causes are investigated. initialize_controls(amplitudes, init_tslots=True)[source]¶; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated. property num_ctrls¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. class DynamicsSymplectic(optimconfig, params=None)[source]¶; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes. omegaarray[drift_dyn_gen.shape]matrix used in the calculation of propagators (time evolution); with symplectic systems. property dyn_gen_phase¶; The phasing operator for the symplectic group generators; usually refered to as Omega; By default this is applied as ‘postop’ dyn_gen*-Omega; If phase_application is ‘preop’ it is applied as Omega*dyn_gen. class PropagatorComputer(dynamics, params=None)[source]¶; Base for all Propagator Computer classes; that are used to calculate the propagators,; and a",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:250971,Modifiability,config,configuration,250971,"cation. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:251247,Modifiability,config,configuration,251247,"iet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attribute",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:251440,Modifiability,config,configuration,251440,"es whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; a",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:251807,Modifiability,config,configuration,251807,"ey value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See SU",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:254566,Modifiability,config,configuration,254566," fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradie",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:254625,Modifiability,config,configuration,254625," to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_c",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:256210,Modifiability,config,config,256210,"fore it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:256448,Modifiability,config,configuration,256448,"culates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phas",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:257312,Modifiability,config,configuration,257312,"tion uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:259058,Modifiability,config,configuration,259058,"erik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelinteg",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:259165,Modifiability,config,configuration,259165,"ated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:259761,Modifiability,config,configuration,259761,"ormalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summaryEvoCompSummaryA summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:271843,Modifiability,config,configurations,271843,"om the optimisation method; Typically this will be the basis coefficients. class PulseGenCrabFourier(dyn=None, num_coeffs=None, params=None)[source]¶; Generates a pulse using the Fourier basis functions, i.e. sin and cos. Attributes. freqsfloat array[num_coeffs]Frequencies for the basis functions. randomize_freqsboolIf True (default) the some random offset is applied to the frequencies. gen_pulse(coeffs=None)[source]¶; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters. coeffsfloat array[num_coeffs, num_basis_funcs]The basis coefficient values; If given this overides the default and sets the attribute; of the same name. init_freqs()[source]¶; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset. init_pulse(num_coeffs=None)[source]¶; Set the initial freq and coefficient values. reset()[source]¶; reset attributes to default values. class Stats[source]¶; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes. dyn_gen_namestringText used in some report functions.; Makes sense to set it to ‘Hamiltonian’ when using unitary dynamics; Default is simply ‘dynamics generator’. num_iterintegerNumber of iterations of the optimisation algorithm. wall_time_optim_startfloatStart time for the optimisation. wall_time_optim_endfloatEnd time for the optimisation. wall_time_optimfloatTime elasped during the optimisation. wall_time_dyn_gen_computefloatTotal wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_computefloatTotal wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_computefloatTotal wall (elasped) time com",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:275421,Modifiability,config,configured,275421,"ged. mean_num_ctrl_amp_changes_per_updatefloatMean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes. parentsome control object (Dynamics or Optimizer)aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dirstrdirectory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. levelstringThe level of data dumping that will occur. write_to_fileboolWhen set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based on its dump_to_file attrib. dump_file_extstrDefault file extension for any file names that are auto generated. fname_basestrFirst part of any auto generated file names.; This is usually overridden in the subclass. dump_summaryboolIf True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sepstrdelimiter for the summary file.; default is a space. data_sepstrdelimiter for the data files (arrays saved to file).; default is a space. summary_filestrFile path for summary file.; Automatically generated. Can be set specifically. create_dump_dir()[source]¶; Checks dump directory exists, creates it if not. property level¶; The level of data dumping that will occur. SUMMARYA summary will be recorded. FULLAll possible dumping. CUSTOMSome customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dum",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:4158,Performance,perform,performing,4158,"rator. dual_chan(); Dual channel of quantum object representing a CP map. eigenenergies(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object. eigenstates(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object. expm(); Matrix exponential of quantum object. full(order=’C’); Returns dense array of quantum object data attribute. groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum object. inv(); Return a Qobj corresponding to the matrix inverse of the operator. matrix_element(bra, ket); Returns the matrix element of operator between bra and ket vectors. norm(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator. permute(order); Returns composite qobj with indices reordered. proj(); Computes the projector for a ket or bra vector. ptrace(sel); Returns quantum object for selected dimensions after performing partial trace. sinm(); Sine of quantum object. sqrtm(); Matrix square root of quantum object. tidyup(atol=1e-12); Removes small elements from quantum object. tr(); Trace of quantum object. trans(); Transpose of quantum object. transform(inpt, inverse=False); Performs a basis transformation defined by inpt matrix. trunc_neg(method=’clip’); Removes negative eigenvalues and returns a new Qobj that is a valid density operator. unit(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. check_herm()[source]¶; Check if the quantum object is hermitian. Returns. ishermboolReturns the new value of isherm property. check_isunitary()[source]¶; Checks whether qobj is a unitary matrix. conj()[source]¶; Conjugate operator of quantum object. copy()[source]¶; Create identical copy. cosm()[source]¶; Cosine of a quantum operator.; Operator must be square. Returns. operqutip.QobjMatrix cosine of operator. Raises. TypeErrorQuantum object is not ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:6412,Performance,perform,performed,6412,"e)[source]¶; Calculates the diamond norm, or the diamond distance to another; operator. Parameters. Bqutip.Qobj or NoneIf B is not None, the diamond distance d(A, B) = dnorm(A - B); between this operator and B is returned instead of the diamond; norm. Returns. dfloatEither the diamond norm of this operator, or the diamond distance; from this operator to B. dual_chan()[source]¶; Dual channel of quantum object representing a completely positive; map. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000, phase_fix=None)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). phase_fixint, NoneIf not None, set the phase of each kets so that ket[phase_fix,0]; is real positive. Returns. eigvalsarrayArray of eigenvalues for operator. eigvecsarra",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:7204,Performance,perform,performed,7204,"lues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000, phase_fix=None)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). phase_fixint, NoneIf not None, set the phase of each kets so that ket[phase_fix,0]; is real positive. Returns. eigvalsarrayArray of eigenvalues for operator. eigvecsarrayArray of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:10723,Performance,perform,performed,10723,"represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. Notes; It is slightly more computationally efficient to use a ket; vector for the ‘bra’ input. norm(norm=None, sparse=False, tol=0, maxiter=1",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:12335,Performance,perform,performed,12335,"e matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. Notes; It is slightly more computationally efficient to use a ket; vector for the ‘bra’ input. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters. normstrWhich norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’. sparseboolUse sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tolfloatTolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used); for trace norm. Returns. normfloatThe requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(other)[source]¶; Overlap between two state vectors or two operators.; Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters. otherqutip.QobjQuantum object for a state vector of type ‘ket’, ‘bra’ or density; matrix. Returns. overlapcomplexComplex valued overlap. Raises. TypeErrorCan only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> with both vectors expressed as kets. permute(order)[source]¶; Permutes a composite",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:16865,Performance,perform,performed,16865,"perqutip.QobjOperator in new basis. Notes; This function is still in development. trunc_neg(method='clip')[source]¶; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters. methodstrAlgorithm to use to remove negative eigenvalues. “clip”; simply discards negative eigenvalues, then renormalizes.; “sgs” uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns. operqutip.QobjA valid density operator. unit(inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj; instances, each of which may have an associated scalar time dependence.; The list is summed to produce the final result. In other words, if an; instance of this class is \(Q(t)\), then it is constructed from a set; of constant:obj:~qutip.Qobj \(\{Q_k\}\) and time-dependent scalars; \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj,; then that term is assumed to be constant. The next section contains more; detail on the allowed forms of the constants, and gives several examples",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:46080,Performance,perform,performs,46080," times: the times t (i.e. the tlist).; states: the system state at each time t (only available; if e_ops was None or if the solver option; store_states was set to True).; ado_states: the full ADO state at each time (only available; if ado_return was set to True). Each element is an; instance of HierarchyADOsState. .; The state of a particular ADO may be extracted from; result.ado_states[i] by calling extract.; expect: the value of each e_ops at time t (only; available if e_ops were given). If e_ops was passed; as a dictionary, then expect will be a dictionary with; the same keys as e_ops and values giving the list of; outcomes for the corresponding key. steady_state(use_mkl=True, mkl_max_iter_refine=100, mkl_weighted_matching=False)[source]¶; Compute the steady state of the system. Parameters. use_mklbool, default=FalseWhether to use mkl or not. If mkl is not installed or if; this is false, use the scipy splu solver instead. mkl_max_iter_refineintSpecifies the the maximum number of iterative refinement steps that; the MKL PARDISO solver performs.; For a complete description, see iparm(8) in; http://cali2.unilim.fr/intel-xe/mkl/mklman/GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF.htm. mkl_weighted_matchingboolMKL PARDISO can use a maximum weighted matching algorithm to; permute large elements close the diagonal. This strategy adds an; additional level of reliability to the factorization methods.; For a complete description, see iparm(13) in; http://cali2.unilim.fr/intel-xe/mkl/mklman/GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF.htm. Returns. steady_stateQobjThe steady state density matrix of the system. steady_adosHierarchyADOsStateThe steady state of the full ADO hierarchy. A particular ADO may be; extracted from the full state by calling extract. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, bnd_cut_approx=False, options=None, progress_bar=None, combine=True)[source]¶; A helper class for creating an HEOMSolver that is backwards; compa",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:70684,Performance,perform,performance,70684," resultsqutip.solver.ResultObject storing all results from the simulation. class HEOMSolver[source]¶; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes. H_sysQobjSystem Hamiltonian. coup_opQobjOperator describing the coupling between system and bath. coup_strengthfloatCoupling strength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmann’s constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflis",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:71535,Performance,perform,performance,71535," density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes. H_sysQobjSystem Hamiltonian. coup_opQobjOperator describing the coupling between system and bath. coup_strengthfloatCoupling strength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmann’s constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:72580,Performance,perform,performance,72580,"overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are cou",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:76157,Performance,perform,performed,76157,"gator(blist, tlist, tau, c1=None, c2=None, notrace=False)[source]¶; Compute propagator for computing output field expectation values; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Tra",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:76641,Performance,perform,performed,76641,"oattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:81536,Performance,perform,performance,81536,"auto check. class Result[source]¶; Class for storing simulation results from any of the dynamics solvers. Attributes. solverstrWhich solver was used [e.g., ‘mesolve’, ‘mcsolve’, ‘brmesolve’, …]. timeslist/arrayTimes at which simulation data was collected. expectlist/arrayExpectation values (if requested) for simulation. statesarrayState of the simulation (density matrix or ket) evaluated at times. num_expectintNumber of expectation value operators in simulation. num_collapseintNumber of collapse operators in simualation. ntrajint/listNumber of trajectories (for stochastic solvers). A list indicates; that averaging of expectation values was done over a subset of total; number of trajectories. col_timeslistTimes at which state collpase occurred. Only for Monte Carlo solver. col_whichlistWhich collapse operator was responsible for each collapse in; col_times. Only for Monte Carlo solver. class SolverConfiguration[source]¶. class Stats(section_names=None)[source]¶; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section ‘main’. Parameters. section_nameslistlist of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the section; If no names are given then one section called ‘main’ is created. Attributes. sectionsOrderedDict of _StatsSectionThese are the sections that are created automatically on instantiation; or added using add_section. headerstringSome text that will be used as the heading in the report; By default there is None. total_timefloatTime in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:129813,Performance,optimiz,optimized,129813,"optionalOld API, same as init_state. solver: str“mesolve” or “mcsolve”. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.solver.ResultIf analytical is False, an instance of the class; qutip.solver.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)[source]¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)[source]¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. class OptPulseProcessor(N, drift=None, t1=None, t2=None, dims=None)[source]¶; A processor, which takes the Hamiltonian available; as dynamic generators, calls the; qutip.control.optimize_pulse_unitary function; to find an optimized pulse sequence for the desired quantum circuit.; The processor can simulate the evolution under the given; control pulses using qutip.mesolve.; (For attributes documentation, please; refer to the parent class Processor). Parameters. N: intThe number of component systems. drift: `:class:`qutip.Qobj`The drift Hamiltonian. The size must match the whole quantum system. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence of dephasing for; each qubit. A list of size N or a float for all qubits. dims: listThe dimension of each component system.; Default value is a; qubit system of dim=[2,2,2,...,2]. add_control(qobj, targets=None, cyclic_permutation=False, label=None)¶; Add a control Hamiltonian to the processor. It creates a new; Pulse; object for the device that is turned off; (tlist = None, coeff = None). To activate the pulse, one; can set its tlist and coeff. Param",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:214117,Performance,optimiz,optimized,214117,"lphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commu",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:220722,Performance,optimiz,optimize,220722,"s; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_paramsDictionaryOptions for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_gradboolIf set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:220783,Performance,optimiz,optimize,220783,") system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_paramsDictionaryOptions for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_gradboolIf set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:222597,Performance,perform,performance,222597,"floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpqutip.control.dump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dirstringBasically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summaryOptimIterSummarySummary of the most recent iteration.; Note this is only set if dummping is on. apply_method_par",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:223929,Performance,optimiz,optimize,223929," a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dirstringBasically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summaryOptimIterSummarySummary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(params=None)[source]¶; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the curre",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:226486,Performance,optimiz,optimize,226486,"t the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason fo",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:228030,Performance,optimiz,optimize,228030,"een tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Opti",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:228699,Performance,optimiz,optimize,228699,"mplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and detail",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:229486,Performance,optimiz,optimize,229486,"_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:230132,Performance,optimiz,optimize,230132," is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_opti",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:230741,Performance,optimiz,optimize,230741,"rm_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function v",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:231234,Performance,optimiz,optimize,231234,"imization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. Attributes. iter_numintIteration number of the pulse optimisation. fid_func_call_numintFidel",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:233514,Performance,optimiz,optimize,233514,"efloatTime spent computing the pulse optimisation so far; (in seconds of elapsed time). class TerminationConditions[source]¶; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes. fid_err_targfloatTarget fidelity error. fid_goalfloatgoal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_timefloat# maximum time for optimisation (seconds). min_gradient_normfloatMinimum normalised gradient after which optimisation will terminate. max_iterationsintegerMaximum iterations of the optimisation algorithm. max_fid_func_callsintegerMaximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. Attributes. termination_reasonstringDescription of the reason for terminating the optimisation. fidelityfloatfinal (normalised) fidelity that was achieved. initial_fid_errfloatfidelity error before optimisation starting. fid_errfloatfinal fidelity error that was achieved. goal_achievedbooleanTrue is the fidely error achieved was below the target. grad_norm_finalfloatFinal value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reachedfloatTrue if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exc",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:235307,Performance,optimiz,optimizerOptimizerInstance,235307,"if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exceededbooleanTrue if the iteration limit was reached. max_fid_func_exceededbooleanTrue if the fidelity function call limit was reached. wall_timefloattime elapsed during the optimisation. wall_time_limit_exceededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the end of the optimisation. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initialQobjThe evolution operator from t=0 to t=T based on the initial amps. statsStatsObject contaning the stats for the run (if any collected). optimizerOptimizerInstance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENS",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:236088,Performance,perform,performance,236088,"n. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initialQobjThe evolution operator from t=0 to t=T based on the initial amps. statsStatsObject contaning the stats for the run (if any collected). optimizerOptimizerInstance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propaga",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:236806,Performance,perform,performance,236806,"at is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory s",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:238044,Performance,perform,perform,238044,"mputerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, o",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:238094,Performance,perform,perform,238094,"mputerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, o",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:238587,Performance,cache,cache,238587,"ng Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslotsintegerNumber of timeslots (aka timeslices). num_ctrlsintegercalculate the of controls from the length of the control list. evo_timefloatTotal time for the evolution. tauarray[num_tslots] of floatDuration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:238840,Performance,cache,cached,238840,"d by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslotsintegerNumber of timeslots (aka timeslices). num_ctrlsintegercalculate the of controls from the length of the control list. evo_timefloatTotal time for the evolution. tauarray[num_tslots] of floatDuration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equal size time slices. timearray[num_tslots+1] of floatCumulative time for the evolution, that is the time at the start; of each time slice. drift_dyn_genQobj or list of QobjDrift or system dynamics generator (Hamiltonian); Matrix defining the underlying dynamics of the system; Can also be a list of Qobj (length num_tslo",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:255921,Performance,cache,cached,255921,"der). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:256364,Performance,cache,cached,256364,"litude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any config",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:258873,Performance,cache,cached,258873,"ance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:276726,Performance,optimiz,optimizer,276726,"den in the subclass. dump_summaryboolIf True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sepstrdelimiter for the summary file.; default is a space. data_sepstrdelimiter for the data files (arrays saved to file).; default is a space. summary_filestrFile path for summary file.; Automatically generated. Can be set specifically. create_dump_dir()[source]¶; Checks dump directory exists, creates it if not. property level¶; The level of data dumping that will occur. SUMMARYA summary will be recorded. FULLAll possible dumping. CUSTOMSome customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of qutip.control.optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilenam",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:277238,Performance,optimiz,optimizer,277238,"ng that will occur. SUMMARYA summary will be recorded. FULLAll possible dumping. CUSTOMSome customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of qutip.control.optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_summarylist of tslotcomp.Evo",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:10382,Safety,safe,safe,10382,"erator. Raises. TypeErrorQuantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwic",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:10761,Safety,safe,safebool,10761,"ably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. Notes; It is slightly more computationally efficient to use a ket; vector for the ‘bra’ input. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:22903,Safety,safe,safePickleboolFlag,22903,"lue of the args dictionary passed into the; constructor. dynamics_argslistNames of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of times at which the numpy-array coefficients are applied. compiledstrA string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obtain a list of all the coefficients at a particular; time. coeff_fileslistRuntime created files to delete with the instance. dummy_cteboolIs self.cte an empty Qobj. constboolIndicates if quantum object is constant. type{“cte”, “string”, “func”, “array”, “spline”, “mixed_callable”, “mixed_compilable”}Information about the type of coefficients used in the entire object. num_objintNumber of Qobj in the QobjEvo. use_cythonboolFlag to compile string to Cython or Python. safePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:19857,Security,access,access,19857," The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; args = {""_step_func_coeff"": True}. Examples of array-format usage are:; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; QobjEvo that contains different tlist values, however.; Passing arguments; args is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string.; There are some “magic” names that can be specified, whose objects will be; overwritten when used within sesolve, mesolve and; mcsolve. This allows access to the solvers’ internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. ""state"": the current state as a Qobj; ""state_vec"": the current state as a column-stacked 1D np.ndarray; ""state_mat"": the current state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers. Replace <n> with; an integer literal, e.g. ""expect_op_0"". This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first paramete",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:21457,Security,access,access,21457,"operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole object. The time_dependence can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the Qobj instead; of the 2-element list. argsdict, optionalMapping of {str: object}, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the “magic”; names used to access solver internals. tlistarray_like, optionalList of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in Q_object is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes. cteQobjConstant part of the QobjEvo. opslist of EvoElementInternal representation of the time-dependence structure of the; elements. argsdictThe current value of the args dictionary passed into the; constructor. dynamics_argslistNames of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of times at which the numpy-array coefficients are applied. compiledstrA string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obta",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:67292,Security,access,access,67292,"e. label) match the given filters or level. idx(label)[source]¶; Return the index of the ADO label within the list of labels,; i.e. within self.labels. Parameters. labeltupleThe label to look up. Returns. intThe index of the label within the list of ADO labels. next(label, k)[source]¶; Return the ADO label with one more excitation in the k’th exponent; dimension or None if adding the excitation would exceed the; dimension or maximum depth of the hierarchy. Parameters. labeltupleThe ADO label to add an excitation to. kintThe exponent to add the excitation to. Returns. tuple or NoneThe next label. prev(label, k)[source]¶; Return the ADO label with one fewer excitation in the k’th; exponent dimension or None if the label has no exciations in the; k’th exponent. Parameters. labeltupleThe ADO label to remove the excitation from. kintThe exponent to remove the excitation from. Returns. tuple or NoneThe previous label. class HierarchyADOsState(rho, ados, ado_state)[source]¶; Provides convenient access to the full hierarchy ADO state at a particular; point in time, t. Parameters. rhoQobjThe current state of the system (i.e. the 0th component of the; hierarchy). adosHierarchyADOsThe description of the hierarchy. ado_statenumpy.arrayThe full state of the hierarchy. Attributes. rhoQobjThe system state. In addition, all of the attributes of the hierarchy description,; i.e. ``HierarchyADOs``, are provided directly on this class for; convenience. E.g. one can access ``.labels``, or ``.exponents`` or; call ``.idx(label)`` directly.; See :class:`HierarchyADOs` for a full list of the available attributes; and methods. extract(idx_or_label)[source]¶; Extract a Qobj representing specified ADO from a full representation of; the ADO states. Parameters. idxint or labelThe index of the ADO to extract. If an ADO label, e.g.; (0, 1, 0, ...) is supplied instead, then the ADO; is extracted by label instead. Returns. QobjA Qobj representing the state of the specified ADO. class HSolverDL(H_sys,",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:67759,Security,access,access,67759,"s. labeltupleThe ADO label to add an excitation to. kintThe exponent to add the excitation to. Returns. tuple or NoneThe next label. prev(label, k)[source]¶; Return the ADO label with one fewer excitation in the k’th; exponent dimension or None if the label has no exciations in the; k’th exponent. Parameters. labeltupleThe ADO label to remove the excitation from. kintThe exponent to remove the excitation from. Returns. tuple or NoneThe previous label. class HierarchyADOsState(rho, ados, ado_state)[source]¶; Provides convenient access to the full hierarchy ADO state at a particular; point in time, t. Parameters. rhoQobjThe current state of the system (i.e. the 0th component of the; hierarchy). adosHierarchyADOsThe description of the hierarchy. ado_statenumpy.arrayThe full state of the hierarchy. Attributes. rhoQobjThe system state. In addition, all of the attributes of the hierarchy description,; i.e. ``HierarchyADOs``, are provided directly on this class for; convenience. E.g. one can access ``.labels``, or ``.exponents`` or; call ``.idx(label)`` directly.; See :class:`HierarchyADOs` for a full list of the available attributes; and methods. extract(idx_or_label)[source]¶; Extract a Qobj representing specified ADO from a full representation of; the ADO states. Parameters. idxint or labelThe index of the ADO to extract. If an ADO label, e.g.; (0, 1, 0, ...) is supplied instead, then the ADO; is extracted by label instead. Returns. QobjA Qobj representing the state of the specified ADO. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For prac",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:235683,Security,access,access,235683,"ededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the end of the optimisation. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initialQobjThe evolution operator from t=0 to t=T based on the initial amps. statsStatsObject contaning the stats for the run (if any collected). optimizerOptimizerInstance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exis",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:18453,Testability,log,log,18453," \(Q(t)\), then it is constructed from a set; of constant:obj:~qutip.Qobj \(\{Q_k\}\) and time-dependent scalars; \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj,; then that term is assumed to be constant. The next section contains more; detail on the allowed forms of the constants, and gives several examples; for how to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype np.float64 or; np.complex128. A list of times (np.float64) at which the; coeffients must be given as tlist. The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; args = {""_step_func_coeff"": True}. Examples of array-format usage are:; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; QobjEvo that contains different tlist values, however.;",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:19272,Testability,log,logspace,19272,"1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype np.float64 or; np.complex128. A list of times (np.float64) at which the; coeffients must be given as tlist. The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; args = {""_step_func_coeff"": True}. Examples of array-format usage are:; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; QobjEvo that contains different tlist values, however.; Passing arguments; args is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string.; There are some “magic” names that can be specified, whose objects will be; overwritten when used within sesolve, mesolve and; mcsolve. This allows access to the solvers’ internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. ""state"": the current state as a Qobj; ""state_vec"": the current state as a column-stacked 1D np.ndarray; ""state_mat"": the current state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers.",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:219885,Testability,log,logger,219885," for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. targets: list, optionalThe target qubits. controls: list, optionalThe control qubits. used_qubits: setUnion of the control and target qubits. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fi",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:224503,Testability,log,logs,224503,"setting a path. iter_summaryOptimIterSummarySummary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(params=None)[source]¶; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimise",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:224681,Testability,log,logs,224681,"all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:227038,Testability,test,tested,227038,"ource]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to t",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:236233,Testability,log,logger,236233," based on the initial amps. statsStatsObject contaning the stats for the run (if any collected). optimizerOptimizerInstance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_com",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:247018,Testability,log,logged,247018,"on assumes that the _apply_phase method has been; set to a custom function. Type; phase_application. property prop¶; List of propagators (Qobj) for each timeslot. property prop_grad¶; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs()[source]¶; Reset the dyn_shape, dyn_dims and time_depend_drift attribs. save_amps(file_name=None, times=None, amps=None, verbose=False)[source]¶; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters. file_namestringName of the file; If None given the def_amps_fname attribuite will be used. timesList type (or string)List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If ‘exclude’ then times will not be saved in the file, just; the amplitudes. ampsArray[num_tslots, num_ctrls]Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verboseBooleanIf True then an info message will be logged. unitarity_check()[source]¶; Checks whether all propagators are unitary. update_ctrl_amps(new_amps)[source]¶; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer. class DynamicsGenMat(optimconfig, params=None)[source]¶; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Lindbladian. class DynamicsUnitary(optimconfig, params=None)[source]¶; This is the subclass to use for systems with dynamics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes. drift_hamQobjThis is the drift Hamiltonian ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:250037,Testability,log,logger,250037,"his is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes. omegaarray[drift_dyn_gen.shape]matrix used in the calculation of propagators (time evolution); with symplectic systems. property dyn_gen_phase¶; The phasing operator for the symplectic group generators; usually refered to as Omega; By default this is applied as ‘postop’ dyn_gen*-Omega; If phase_application is ‘preop’ it is applied as Omega*dyn_gen. class PropagatorComputer(dynamics, params=None)[source]¶; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:250084,Testability,log,logging,250084,"hape]matrix used in the calculation of propagators (time evolution); with symplectic systems. property dyn_gen_phase¶; The phasing operator for the symplectic group generators; usually refered to as Omega; By default this is applied as ‘postop’ dyn_gen*-Omega; If phase_application is ‘preop’ it is applied as Omega*dyn_gen. class PropagatorComputer(dynamics, params=None)[source]¶; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:252212,Testability,log,logger,252212,"d; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evobooleanflag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evoboolean; flag to specify whether the onto_evo evolution operator(see Dynamics) is used by the FidelityComputer. fid_errfloatLast computed value of the fidelity error. fidelityfloatLast computed value of the ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:260104,Testability,log,logger,260104,"namics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summaryEvoCompSummaryA summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dump_current()[source]¶; Store a copy of the current time evolution. class TSlotCompUpdateA",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:263394,Testability,log,logger,263394,"e if given). scalingfloatlinear scaling applied to the pulse; (copied from Dynamics.initial_ctrl_scaling if given). offsetfloatlinear offset applied to the pulse; (copied from Dynamics.initial_ctrl_offset if given). tauarray[num_tslots] of floatDuration of each timeslot; (copied from Dynamics if given). lboundfloatLower boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is -Inf. uboundfloatUpper boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is Inf. periodicbooleanTrue if the pulse generator produces periodic pulses. randombooleanTrue if the pulse generator produces random pulses. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value. gen_pulse()[source]¶; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass. init_pulse()[source]¶; Initialise the pulse parameters. reset()[source]¶; reset attributes to default values. class PulseGenRandom(dyn=None, params=None)[source]¶; Generates random pulses as simply random values for each timeslot. gen",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:277489,Testability,log,log,277489,"ly is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of qutip.control.optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_summarylist of tslotcomp.EvoCompSummarySummary items are appended if dump_summary is True; at each recomputation of the evolution. dump_ampsboolIf True control amplitudes are dumped. dump_dyn_genboolIf True the dynamics generators (Hamiltonians) are dumped. d",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:277551,Testability,log,log,277551,"ontainer for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of qutip.control.optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_summarylist of tslotcomp.EvoCompSummarySummary items are appended if dump_summary is True; at each recomputation of the evolution. dump_ampsboolIf True control amplitudes are dumped. dump_dyn_genboolIf True the dynamics generators (Hamiltonians) are dumped. dump_propboolIf True propagators are dumped. dump_prop_gradboolIf T",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:277628,Testability,log,log,277628,"ptimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of qutip.control.optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_summarylist of tslotcomp.EvoCompSummarySummary items are appended if dump_summary is True; at each recomputation of the evolution. dump_ampsboolIf True control amplitudes are dumped. dump_dyn_genboolIf True the dynamics generators (Hamiltonians) are dumped. dump_propboolIf True propagators are dumped. dump_prop_gradboolIf True propagator gradients are dumped. dump_fwd_evoboolIf True forward e",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:277674,Testability,log,logs,277674,"to the iter_summary. iter_summarylist of qutip.control.optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_summarylist of tslotcomp.EvoCompSummarySummary items are appended if dump_summary is True; at each recomputation of the evolution. dump_ampsboolIf True control amplitudes are dumped. dump_dyn_genboolIf True the dynamics generators (Hamiltonians) are dumped. dump_propboolIf True propagators are dumped. dump_prop_gradboolIf True propagator gradients are dumped. dump_fwd_evoboolIf True forward evolution operators are dumped. dump_onwd_evoboolIf True onward evolution oper",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:16237,Usability,simpl,simply,16237,"oved. tr()[source]¶; Trace of a quantum object. Returns. tracefloatReturns the trace of the quantum object. trans()[source]¶; Transposed operator. Returns. operqutip.QobjTranspose of input operator. transform(inpt, inverse=False, sparse=True)[source]¶; Basis transform defined by input array.; Input array can be a matrix defining the transformation,; or a list of kets that defines the new basis. Parameters. inptarray_likeA matrix or list of kets defining the transformation. inverseboolWhether to return inverse transformation. sparseboolUse sparse matrices when possible. Can be slower. Returns. operqutip.QobjOperator in new basis. Notes; This function is still in development. trunc_neg(method='clip')[source]¶; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters. methodstrAlgorithm to use to remove negative eigenvalues. “clip”; simply discards negative eigenvalues, then renormalizes.; “sgs” uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns. operqutip.QobjA valid density operator. unit(inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number;",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:18620,Usability,simpl,simple,18620,"If a scalar \(f_k(t)\) is not passed with a given Qobj,; then that term is assumed to be constant. The next section contains more; detail on the allowed forms of the constants, and gives several examples; for how to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype np.float64 or; np.complex128. A list of times (np.float64) at which the; coeffients must be given as tlist. The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; args = {""_step_func_coeff"": True}. Examples of array-format usage are:; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; QobjEvo that contains different tlist values, however.; Passing arguments; args is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; su",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:33982,Usability,clear,clear,33982,"sphere. Parameters. pointsarray_likeCollection of data points. meth{‘s’, ‘m’, ‘l’}Type of points to plot, use ‘m’ for multicolored, ‘l’ for points; connected with a line. alphafloat, default=1.Transparency value for the vectors. Values between 0 and 1. .. note::When using meth=l in QuTiP 4.6, the line transparency defaulted; to 0.75 and there was no way to alter it.; When the alpha parameter was added in QuTiP 4.7, the default; became alpha=1.0 for values of meth. add_states(state, kind='vector', alpha=1.0)[source]¶; Add a state vector Qobj to Bloch sphere. Parameters. stateQobjInput state vector. kind{‘vector’, ‘point’}Type of object to plot. alphafloat, default=1.Transparency value for the vectors. Values between 0 and 1. add_vectors(vectors, alpha=1.0)[source]¶; Add a list of vectors to Bloch sphere. Parameters. vectorsarray_likeArray with vectors of unit length or smaller. alphafloat, default=1.Transparency value for the vectors. Values between 0 and 1. clear()[source]¶; Resets Bloch sphere data sets to empty. make_sphere()[source]¶; Plots Bloch sphere and data sets. render()[source]¶; Render the Bloch sphere and its data sets in on given figure and axes. save(name=None, format='png', dirc=None, dpin=None)[source]¶; Saves Bloch sphere to file of type format in directory dirc. Parameters. namestrName of saved image. Must include path and format as well.; i.e. ‘/Users/Paul/Desktop/bloch.png’; This overrides the ‘format’ and ‘dirc’ arguments. formatstrFormat of output image. dircstrDirectory for output images. Defaults to current working directory. dpinintResolution in dots per inch. Returns. File containing plot of Bloch sphere. set_label_convention(convention)[source]¶; Set x, y and z labels according to one of conventions. Parameters. conventionstringOne of the following:. “original”; “xyz”; “sx sy sz”; “01”; “polarization jones”; “polarization jones letters”; see also: https://en.wikipedia.org/wiki/Jones_calculus; “polarization stokes”; see also: https://en.wik",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:35469,Usability,simpl,simplest,35469,"uments. formatstrFormat of output image. dircstrDirectory for output images. Defaults to current working directory. dpinintResolution in dots per inch. Returns. File containing plot of Bloch sphere. set_label_convention(convention)[source]¶; Set x, y and z labels according to one of conventions. Parameters. conventionstringOne of the following:. “original”; “xyz”; “sx sy sz”; “01”; “polarization jones”; “polarization jones letters”; see also: https://en.wikipedia.org/wiki/Jones_calculus; “polarization stokes”; see also: https://en.wikipedia.org/wiki/Stokes_parameters. show()[source]¶; Display Bloch sphere and corresponding data sets.; Notes; When using inline plotting in Jupyter notebooks, any figure created; in a notebook cell is displayed after the cell executes. Thus if you; create a figure yourself and use it create a Bloch sphere with; b = Bloch(..., fig=fig) and then call b.show() in the same; cell, then the figure will be displayed twice. If you do create your; own figure, the simplest solution to this is to not call .show(); in the cell you create the figure in. vector_mutation¶; Sets the width of the vectors arrowhead. vector_style¶; Style of Bloch vectors, default = ‘-|>’ (or ‘simple’). vector_width¶; Width of Bloch vectors, default = 5. class Bloch3d(fig=None)[source]¶; Class for plotting data on a 3D Bloch sphere using mayavi.; Valid data can be either points, vectors, or qobj objects; corresponding to state vectors or density matrices. for; a two-state system (or subsystem).; Notes; The use of mayavi for 3D rendering of the Bloch sphere comes with; a few limitations: I) You can not embed a Bloch3d figure into a; matplotlib window. II) The use of LaTex is not supported by the; mayavi rendering engine. Therefore all labels must be defined using; standard text. Of course you can post-process the generated figures; later to add LaTeX using other software if needed. Attributes. figinstance {None}User supplied Matplotlib Figure instance for plotting Bloch sph",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:35676,Usability,simpl,simple,35676,"t of Bloch sphere. set_label_convention(convention)[source]¶; Set x, y and z labels according to one of conventions. Parameters. conventionstringOne of the following:. “original”; “xyz”; “sx sy sz”; “01”; “polarization jones”; “polarization jones letters”; see also: https://en.wikipedia.org/wiki/Jones_calculus; “polarization stokes”; see also: https://en.wikipedia.org/wiki/Stokes_parameters. show()[source]¶; Display Bloch sphere and corresponding data sets.; Notes; When using inline plotting in Jupyter notebooks, any figure created; in a notebook cell is displayed after the cell executes. Thus if you; create a figure yourself and use it create a Bloch sphere with; b = Bloch(..., fig=fig) and then call b.show() in the same; cell, then the figure will be displayed twice. If you do create your; own figure, the simplest solution to this is to not call .show(); in the cell you create the figure in. vector_mutation¶; Sets the width of the vectors arrowhead. vector_style¶; Style of Bloch vectors, default = ‘-|>’ (or ‘simple’). vector_width¶; Width of Bloch vectors, default = 5. class Bloch3d(fig=None)[source]¶; Class for plotting data on a 3D Bloch sphere using mayavi.; Valid data can be either points, vectors, or qobj objects; corresponding to state vectors or density matrices. for; a two-state system (or subsystem).; Notes; The use of mayavi for 3D rendering of the Bloch sphere comes with; a few limitations: I) You can not embed a Bloch3d figure into a; matplotlib window. II) The use of LaTex is not supported by the; mayavi rendering engine. Therefore all labels must be defined using; standard text. Of course you can post-process the generated figures; later to add LaTeX using other software if needed. Attributes. figinstance {None}User supplied Matplotlib Figure instance for plotting Bloch sphere. font_colorstr {‘black’}Color of font used for Bloch sphere labels. font_scalefloat {0.08}Scale for font used for Bloch sphere labels. framebool {True}Draw frame for Bloch sphe",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:38906,Usability,clear,clear,38906,". zlabellist {['|0>', '|1>']}List of strings corresponding to +z and -z axes labels, respectively. zlposlist {[1.07,-1.07]}Positions of +z and -z labels respectively. add_points(points, meth='s', alpha=1.0)[source]¶; Add a list of data points to bloch sphere. Parameters. pointsarray/listCollection of data points. methstr {‘s’,’m’}Type of points to plot, use ‘m’ for multicolored. alphafloat, default=1.Transparency value for the vectors. Values between 0 and 1. add_states(state, kind='vector', alpha=1.0)[source]¶; Add a state vector Qobj to Bloch sphere. Parameters. stateqobjInput state vector. kindstr {‘vector’,’point’}Type of object to plot. alphafloat, default=1.Transparency value for the vectors. Values between 0 and 1. add_vectors(vectors, alpha=1.0)[source]¶; Add a list of vectors to Bloch sphere. Parameters. vectorsarray/listArray with vectors of unit length or smaller. alphafloat, default=1.Transparency value for the vectors. Values between 0 and 1. clear()[source]¶; Resets the Bloch sphere data sets to empty. make_sphere()[source]¶; Plots Bloch sphere and data sets. plot_points()[source]¶; Plots points on the Bloch sphere. plot_vectors()[source]¶; Plots vectors on the Bloch sphere. save(name=None, format='png', dirc=None)[source]¶; Saves Bloch sphere to file of type format in directory dirc. Parameters. namestrName of saved image. Must include path and format as well.; i.e. ‘/Users/Paul/Desktop/bloch.png’; This overrides the ‘format’ and ‘dirc’ arguments. formatstrFormat of output image. Default is ‘png’. dircstrDirectory for output images. Defaults to current working directory. Returns. File containing plot of Bloch sphere. show()[source]¶; Display the Bloch sphere and corresponding data sets. Distributions¶. class QFunc(xvec, yvec, g: float = 1.4142135623730951, memory: float = 1024)[source]¶; Class-based method of calculating the Husimi-Q function of many different; quantum states at fixed phase-space points 0.5*g* (xvec + i*yvec).; This class has slightly",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:56348,Usability,simpl,simpler,56348,"n. terminatorQobjThe Matsubara terminator – i.e. a liouvillian term representing; the contribution to the system-bath dynamics of all exponential; expansion terms beyond Nk. It should be used by adding it to; the system liouvillian (i.e. liouvillian(H_sys)). class DrudeLorentzPadeBath(Q, lam, gamma, T, Nk, combine=True, tag=None)[source]¶; A helper class for constructing a Padé expansion for a Drude-Lorentz; bosonic bath from the bath parameters (see parameters below).; A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant).; The application of the Padé method to spectrum decompoisitions is described; in “Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems” [1].; The implementation here follows the approach in the paper.; [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466; This is an alternative to the DrudeLorentzBath which constructs; a simpler exponential expansion. Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. TfloatBath temperature. NkintNumber of Padé exponentials terms used to approximate the bath; correlation functions. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. terminator()[source]¶; Return the Padé terminator for the bath and the calculated; approximation discrepancy. Returns. delta: floatThe approximation discrepancy. That is, the difference between the; true correlation function of the Drude-Lorentz bath and the sum of; the Nk exponential terms is approximately 2 * delta *; dirac(t), where di",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:61858,Usability,simpl,simpler,61858,"sed to approximate the bath correlation; functions. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. class LorentzianPadeBath(Q, gamma, w, mu, T, Nk, tag=None)[source]¶; A helper class for constructing a Padé expansion for Lorentzian fermionic; bath from the bath parameters (see parameters below).; A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant).; The application of the Padé method to spectrum decompoisitions is described; in “Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems” [1].; The implementation here follows the approach in the paper.; [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466; This is an alternative to the LorentzianBath which constructs; a simpler exponential expansion that converges much more slowly in; this particular case. Parameters. QQobjOperator describing the coupling between system and bath. gammafloatThe coupling strength between the system and the bath. wfloatThe width of the environment. mufloatThe chemical potential of the bath. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. class HierarchyADOs(exponents, max_depth)[source]¶; A description of ADOs (auxilliary density operators) with the; hierarchical equations of motion.; The list of ADOs is constructed from a list of bath exponents; (corresponding to one or more baths). Each ADO is referred to by a label; that lists the number of “excitations” of each bath exponent. The; level of a label within the hierarchy i",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:72414,Usability,progress bar,progress bar,72414," thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:72461,Usability,progress bar,progress bar,72461," thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:73172,Usability,feedback,feedback,73172,"bed in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., l",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:73323,Usability,feedback,feedback,73323,", or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Co",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:73458,Usability,feedback,feedback,73458," to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dag",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:73663,Usability,feedback,feedback,73663,"If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_o",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:77076,Usability,learn,learningtimes,77076,"where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results¶. class ExpectOps(e_ops=[], super_=False)[source]¶; Contain and compute expectation values. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:77477,Usability,learn,learning,77477," is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results¶. class ExpectOps(e_ops=[], super_=False)[source]¶; Contain and compute expectation values. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, steady_state_average=False, seeds=None, normalize_output=True, use_openmp=None, openmp_threads=None)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after cr",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:84370,Usability,clear,clear,84370,"h this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the default (first) section will be used. clear()[source]¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)[source]¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters. outputstreamfile or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters. valuefloatTime in seconds to complete the solver section. sectionstring or classSection which to set the total_time for; If None given, the total_time for complete solve is set. class",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:90005,Usability,progress bar,progress bar,90005," instance returned by the solver. noiseint, or 1D array of int, or 4D array of float; int : seed of the noise; 1D array : length = ntraj, seeds for each trajectories.; 4D array : (ntraj, len(times), nsubsteps, len(sc_ops)*[1|2]).; Vector for the noise, the len of the last dimensions is doubled for; solvers of order 1.5. This corresponds to results.noise. noiseDepthintNumber of terms kept of the truncated series used to create the; noise used by taylor2.0 solver. normalizebool(default True for (photo)ssesolve, False for (photo)smesolve); Whether or not to normalize the wave function during the evolution.; Normalizing density matrices introduce numerical errors. optionsqutip.solver.OptionsGeneric solver options. Only options.average_states and; options.store_states are used. map_func: functionA map function or managing the calls to single-trajactory solvers. map_kwargs: dictionaryOptional keyword arguments to the map_func function function. progress_barqutip.ui.BaseProgressBarOptional progress bar class instance. Permutational Invariance¶. class Dicke(N, hamiltonian=None, emission=0.0, dephasing=0.0, pumping=0.0, collective_emission=0.0, collective_dephasing=0.0, collective_pumping=0.0)[source]¶; The Dicke class which builds the Lindbladian and Liouvillian matrix. Parameters. N: intThe number of two-level systems. hamiltonianqutip.QobjA Hamiltonian in the Dicke basis.; The matrix dimensions are (nds, nds),; with nds being the number of Dicke states.; The Hamiltonian can be built with the operators; given by the jspin functions. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: floatLocal dephasing coefficient.; default: 0.0. pumping: floatIncoherent pumping coefficient.; default: 0.0. collective_emission: floatCollective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: floatCollective pumping coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coefficient.; default: 0.",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:95412,Usability,simpl,simple,95412,"lective (superradiant) emmission coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coefficient.; default: 0.0. collective_pumping: floatCollective pumping coefficient.; default: 0.0. M: dictA nested dictionary of the structure {row: {col: val}} which holds; non zero elements of the matrix M. calculate_j_m(dicke_row, dicke_col)[source]¶; Get the value of j and m for the particular Dicke space element. Parameters. dicke_row, dicke_col: intThe row and column from the Dicke space matrix. Returns. j, m: floatThe j and m values. calculate_k(dicke_row, dicke_col)[source]¶; Get k value from the current row and column element in the Dicke space. Parameters. dicke_row, dicke_col: intThe row and column from the Dicke space matrix. Returns; ——-; k: intThe row index for the matrix M for given Dicke space; element. coefficient_matrix()[source]¶; Generate the matrix M governing the dynamics for diagonal cases.; If the initial density matrix and the Hamiltonian is diagonal, the; evolution of the system is given by the simple ODE: dp/dt = Mp. isdicke(dicke_row, dicke_col)[source]¶; Check if an element in a matrix is a valid element in the Dicke space.; Dicke row: j value index. Dicke column: m value index.; The function returns True if the element exists in the Dicke space and; False otherwise. Parameters. dicke_row, dicke_colintIndex of the element in Dicke space which needs to be checked. solve(rho0, tlist, options=None)[source]¶; Solve the ODE for the evolution of diagonal states and Hamiltonians. tau1(j, m)[source]¶; Calculate coefficient matrix element relative to (j, m, m). tau2(j, m)[source]¶; Calculate coefficient matrix element relative to (j, m+1, m+1). tau3(j, m)[source]¶; Calculate coefficient matrix element relative to (j+1, m+1, m+1). tau4(j, m)[source]¶; Calculate coefficient matrix element relative to (j-1, m+1, m+1). tau5(j, m)[source]¶; Calculate coefficient matrix element relative to (j+1, m, m). tau6(j, m)[source]¶; Calculate coefficient ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:149331,Usability,simpl,simplicity,149331,"rcuit`, optionalA quantum circuit. If given, it first calls the load_circuit; and then calculate the evolution. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.solver.ResultIf analytical is False, an instance of the class; qutip.solver.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_params()[source]¶; Save the parameters in the attribute params and check the validity.; (Defined in subclasses); Notes; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)[source]¶; Transfer a parameter to an array. class SpinChain(N, correct_global_phase, sx, sz, sxsy, t1, t2)[source]¶; The processor based on the physical implementation of; a spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It is a base class and should not be used directly, please; refer the the subclasses qutip.qip.device.LinearSpinChain and; qutip.qip.device.CircularSpinChain.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe epsilon for",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:160717,Usability,simpl,simplicity,160717," the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class LinearSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the physical implementation of; a linear spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe epsilon for each of the qubits in the system. sxsy: int or listThe interaction strength for each of the qubit pair in the system. t1: list or float, optionalCharacterize the decoherence of amplitude damping for; each qubit. t2: list of float, optionalCharacterize the ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:171169,Usability,simpl,simplicity,171169,"ile. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class CircularSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the physical implementation of; a circular spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe epsilon for each of the qubits in the system. sxsy: int or listThe interaction strength for each of the qubit pair in the system. t1: list or float, optionalCharacterize the decoherence of amplitude damping for; each qubit. t2: list of float, optionalCharacterize ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:181625,Usability,simpl,simplicity,181625,"ile. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class DispersiveCavityQED(N, correct_global_phase=True, num_levels=10, deltamax=1.0, epsmax=9.5, w0=10.0, wq=None, eps=9.5, delta=0.0, g=0.01, t1=None, t2=None)[source]¶; The processor based on the physical implementation of; a dispersive cavity QED system.; The available Hamiltonian of the system is predefined.; For a given pulse amplitude matrix, the processor can; calculate the state evolution under the given control pulse,; either analytically or numerically.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_phase: float, optionalSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. num_levels: int, optionalThe number of energy levels in the resonator. deltamax: int or list, optionalThe coefficients of",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:193246,Usability,simpl,simplicity,193246,"s. N: intThe number of qubits in the system. set_up_params(N, num_levels, deltamax, epsmax, w0, wq, eps, delta, g)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, “w0”, “eps”, “delta”; and “g”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “g”, list element i is the interaction; between qubits i and i+1. Parameters. N: intThe number of qubits in the system. num_levels: intThe number of energy levels in the resonator. deltamax: listThe coefficients of sigma-x for each of the qubits in the system. epsmax: listThe coefficients of sigma-z for each of the qubits in the system. wo: intThe base frequency of the resonator. wq: listThe frequency of the qubits. eps: listThe epsilon for each of the qubits in the system. delta: listThe delta for each of the qubits in the system. g: listThe interaction strength for each of the qubit with the resonator. Notes; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class Noise[source]¶; The base class representing noise in a processor.; The noise object can be added to Processor and; contributes to evolution. get_noisy_dynamics(dims, pulses, systematic_noise)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dummy Pulse object. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits system. pulses: list of :class:`.Pulse`The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`The dummy pulse with no ideal control element. Returns. noisy_pulses: list of PulseNoisy pulses. systematic_noise: PulseThe dummy pulse representing pulse independent noise. class DecoherenceNoise(c_ops, targets=None, coeff=None, tlist=None, all_qubits=False)[source]¶; The decoherence noise in a processor. It generates lindblad noise; according to the given",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:251109,Usability,simpl,simply,251109,"qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynam",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:254112,Usability,clear,clear,254112,"ty error. fidelityfloatLast computed value of the normalised fidelity. fidelity_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of floatLast computed values for the fidelity error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it i",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:254130,Usability,clear,clear,254130,"ty error. fidelityfloatLast computed value of the normalised fidelity. fidelity_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of floatLast computed values for the fidelity error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it i",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:254649,Usability,clear,clear,254649," to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_c",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:255367,Usability,clear,clear,255367,"rmalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in t",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:255385,Usability,clear,clear,255385,"rmalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in t",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:257336,Usability,clear,clear,257336,"tion uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:259189,Usability,clear,clear,259189,"ated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:259785,Usability,clear,clear,259785,"ormalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summaryEvoCompSummaryA summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a ",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:261594,Usability,simpl,simply,261594,"t to None if neither stats or dump are set. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dump_current()[source]¶; Store a copy of the current time evolution. class TSlotCompUpdateAll(dynamics, params=None)[source]¶; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated. compare_amps(new_amps)[source]¶; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed. get_timeslot_for_fidelity_calc()[source]¶; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot. recompute_evolution()[source]¶; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary. class PulseGen(dyn=None, params=None)[source]¶; Pulse generator; Base class for all Pulse generators; The object can optionally be instantiated with a Dynamics object,; in which case the timeslots and amplitude scaling and offset; are copied from that.; Otherwise the class can be used independently by setting:; tau (array of timeslot durations); or; num_tslots and pulse_time for equally spaced timeslots. Attributes. num_tslotsintegerNumber of timeslots, aka timeslices; (copied from Dynamics if given). pulse_timefloattotal duration of the pulse; (copied from Dynamics.evo_time if given). scalingfloatlinear scaling applied to the pulse; (copied from Dynamics.initial_ctrl_scaling if given). offsetfloatlinear offset applied to the pulse; (copied from Dynamics.initial_ctrl_offset if given). tauarray[num",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:264329,Usability,simpl,simply,264329,"e generator produces random pulses. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value. gen_pulse()[source]¶; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass. init_pulse()[source]¶; Initialise the pulse parameters. reset()[source]¶; reset attributes to default values. class PulseGenRandom(dyn=None, params=None)[source]¶; Generates random pulses as simply random values for each timeslot. gen_pulse()[source]¶; Generate a pulse of random values between 1 and -1; Values are scaled using the scaling property; and shifted using the offset property; Returns the pulse as an array of vales for each timeslot. reset()[source]¶; reset attributes to default values. class PulseGenZero(dyn=None, params=None)[source]¶; Generates a flat pulse. gen_pulse()[source]¶; Generate a pulse with the same value in every timeslot.; The value will be zero, unless the offset is not zero,; in which case it will be the offset. class PulseGenLinear(dyn=None, params=None)[source]¶; Generates linear pulses. Attributes. gradientfloatGradient of the line.; Note this is calculated from the start_val and end_val if these; are given. start_valfloatStart point of the line. That is the starting amplitude. end_valfloatEnd point of the line.; That is the amplitude at the start of the last timeslot. gen_pulse(gradient=None, start_val=None, end_val=None",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/classes.html:272158,Usability,simpl,simply,272158,"ons. randomize_freqsboolIf True (default) the some random offset is applied to the frequencies. gen_pulse(coeffs=None)[source]¶; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters. coeffsfloat array[num_coeffs, num_basis_funcs]The basis coefficient values; If given this overides the default and sets the attribute; of the same name. init_freqs()[source]¶; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset. init_pulse(num_coeffs=None)[source]¶; Set the initial freq and coefficient values. reset()[source]¶; reset attributes to default values. class Stats[source]¶; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes. dyn_gen_namestringText used in some report functions.; Makes sense to set it to ‘Hamiltonian’ when using unitary dynamics; Default is simply ‘dynamics generator’. num_iterintegerNumber of iterations of the optimisation algorithm. wall_time_optim_startfloatStart time for the optimisation. wall_time_optim_endfloatEnd time for the optimisation. wall_time_optimfloatTime elasped during the optimisation. wall_time_dyn_gen_computefloatTotal wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_computefloatTotal wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_computefloatTotal wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating the propagators themselves. wall_time_onwd_prop_computefloatTotal wall (elasped) time computing combined onward propagation,; that is the time evolution from a specific",MatchSource.WIKI,docs/4.7/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html
https://qutip.org/docs/4.7/apidoc/functions.html:3889,Availability,down,down,3889,": dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]; [0.]; [0.]; [0.]]. bell_state(state='00')[source]¶; Returns the selected Bell state:. \[\begin{split}\begin{aligned}; \lvert B_{00}\rangle &=; \frac1{\sqrt2}(\lvert00\rangle+\lvert11\rangle)\\; \lvert B_{01}\rangle &=; \frac1{\sqrt2}(\lvert00\rangle-\lvert11\rangle)\\; \lvert B_{10}\rangle &=; \frac1{\sqrt2}(\lvert01\rangle+\lvert10\rangle)\\; \lvert B_{11}\rangle &=; \frac1{\sqrt2}(\lvert01\rangle-\lvert10\rangle)\\; \end{aligned}\end{split}\]. Returns. Bell_stateqobjBell state. bra(seq, dim=2)[source]¶; Produces a multiparticle bra state for a list or string,; where each element stands for state of the respective particle. Parameters. seqstr / list of ints or charactersEach element defines state of the respective particle.; (e.g. [1,1,0,1] or a string “1101”).; For qubits it is also possible to use the following conventions:. ‘g’/’e’ (ground and excited state); ‘u’/’d’ (spin up and down); ‘H’/’V’ (horizontal and vertical polarization). Note: for dimension > 9 you need to use a list. dimint (default: 2) / list of intsSpace dimension for each particle:; int if there are the same, list if they are different. Returns. braqobj. Examples; >>> bra(""10"") ; Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra; Qobj data =; [[ 0. 0. 1. 0.]]. >>> bra(""Hue"") ; Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra; Qobj data =; [[ 0. 1. 0. 0. 0. 0. 0. 0.]]. >>> bra(""12"", 3) ; Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 1. 0. 0. 0.]]. >>> bra(""31"", [5, 2]) ; Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]]. coherent(N, alpha, offset=0, method=None)[source]¶; Generates a coherent state with eigenvalue alpha.; Constructed using displacement operator on vacuum state. Parameters. NintNumber of Fock states in Hilbert space",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:12696,Availability,down,down,12696,"gth. offsetint or list of ints, optional (default 0 for all dimensions)The lowest number state that is included in the finite number state; representation of the state in the relevant dimension. Returns. dmqobjDensity matrix representation of Fock state. Examples; >>> fock_dm(3,1) ; Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 0.+0.j]]. ghz_state(N=3)[source]¶; Returns the N-qubit GHZ-state. Parameters. Nint (default=3)Number of qubits in state. Returns. GqobjN-qubit GHZ-state. ket(seq, dim=2)[source]¶; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters. seqstr / list of ints or charactersEach element defines state of the respective particle.; (e.g. [1,1,0,1] or a string “1101”).; For qubits it is also possible to use the following conventions:; - ‘g’/’e’ (ground and excited state); - ‘u’/’d’ (spin up and down); - ‘H’/’V’ (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dimint (default: 2) / list of intsSpace dimension for each particle:; int if there are the same, list if they are different. Returns. ketqobj. Examples; >>> ket(""10"") ; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 1.]; [ 0.]]. >>> ket(""Hue"") ; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3) ; Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]) ; Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]. ket2dm(Q)[source]¶; Takes input ket or bra vector and returns density matrix; formed by outer ",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:33270,Availability,toler,tolerance,33270,"class, for representing quantum states and; operators, and related functions. dag(A)[source]¶; Adjont operator (dagger) of a quantum object. Parameters. Aqutip.QobjInput quantum object. Returns. operqutip.QobjAdjoint of input operator. Notes; This function is for legacy compatibility only. It is recommended to use; the dag() Qobj method. dims(inpt)[source]¶; Returns the dims attribute of a quantum object. Parameters. inptqutip.QobjInput quantum object. Returns. dimslistA list of the quantum objects dimensions. Notes; This function is for legacy compatibility only. Using the Qobj.dims; attribute is recommended. isbra(Q)[source]¶; Determines if given quantum object is a bra-vector. Parameters. Qqutip.QobjQuantum object. Returns. isbraboolTrue if Qobj is bra-vector, False otherwise. Notes; This function is for legacy compatibility only. Using the Qobj.isbra; attribute is recommended.; Examples; >>> psi = basis(5,2); >>> isket(psi); False. isequal(A, B, tol=None)[source]¶; Determines if two qobj objects are equal to within given tolerance. Parameters. Aqutip.QobjQobj one. Bqutip.QobjQobj two. tolfloatTolerence for equality to be valid. Returns. isequalboolTrue if qobjs are equal, False otherwise. Notes; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. isherm(Q)[source]¶; Determines if given operator is Hermitian. Parameters. Qqutip.QobjQuantum object. Returns. ishermboolTrue if operator is Hermitian, False otherwise. Notes; This function is for legacy compatibility only. Using the Qobj.isherm; attribute is recommended.; Examples; >>> a = destroy(4); >>> isherm(a); False. isket(Q)[source]¶; Determines if given quantum object is a ket-vector. Parameters. Qqutip.QobjQuantum object. Returns. isketboolTrue if qobj is ket-vector, False otherwise. Notes; This function is for legacy compatibility only. Using the Qobj.isket; attribute is recommended.; Examples; >>> psi = basis(5,2); >>> is",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:37043,Availability,error,error,37043," a quantum object. Parameters. inptqutip.QobjInput quantum object. Returns. shapelistA list of the quantum objects shape. Notes; This function is for legacy compatibility only. Using the Qobj.shape; attribute is recommended. Random Operators and States¶; This module is a collection of random state and operator generators.; The sparsity of the ouput Qobj’s is controlled by varing the; density parameter. rand_dm(N, density=0.75, pure=False, dims=None, seed=None)[source]¶; Creates a random NxN density matrix. Parameters. Nint, ndarray, listIf int, then shape of output operator. If list/ndarray then eigenvalues; of generated density matrix. densityfloatDensity between [0,1] of output density matrix. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. seedintSeed for the random number generator. Returns. operqobjNxN density matrix quantum operator. Notes; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that \(Tr(\rho)=1\). rand_dm_ginibre(N=2, rank=None, dims=None, seed=None)[source]¶; Returns a Ginibre random density operator of dimension; dim and rank rank by using the algorithm of; [BCSZ08]. If rank is None, a full-rank; (Hilbert-Schmidt ensemble) random density operator will be; returned. Parameters. NintDimension of the density operator to be returned. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. rankint or NoneRank of the sampled density operator. If None, a full-rank; density operator is generated. Returns. rhoQobjAn N × N density operator sampled from the Ginibre; or Hilbert-Schmidt distribution. rand_dm_hs(N=2, dims=None, seed=None)[source]¶; Returns a Hilbert-Schmidt random density operator of dimension; dim and rank rank by using the algorithm of; [BCSZ08]. Parameters. NintDimension of the density operator to be returned. dimslistDimensions of quantum object. Used for specifyin",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:50758,Availability,error,errors,50758,"senting a quantum map to a list of quantum objects,; each representing an operator in the Kraus decomposition of the given map. Parameters. q_operQobjSuperoperator to be converted to Kraus representation. If; q_oper is type=""oper"", then it is taken to act by conjugation,; such that to_kraus(A) == to_kraus(sprepost(A, A.dag())) == [A]. tolFloatOptional threshold parameter for eigenvalues/Kraus ops to be discarded.; The default is to=1e-9. Returns. kraus_opslist of QobjA list of quantum objects, each representing a Kraus operator in the; decomposition of q_oper. Raises. TypeError: if the given quantum object is not a map, or cannot bedecomposed into Kraus operators. to_stinespring(q_oper)[source]¶; Converts a Qobj representing a quantum map $Lambda$ to a pair of partial isometries; $A$ and $B$ such that $Lambda(X) = Tr_2(A X B^dagger)$ for all inputs $X$, where; the partial trace is taken over a a new index on the output dimensions of $A$ and $B$.; For completely positive inputs, $A$ will always equal $B$ up to precision errors. Parameters. q_operQobjSuperoperator to be converted to a Stinespring pair. Returns. A, BQobjQuantum objects representing each of the Stinespring matrices for the input Qobj. to_super(q_oper)[source]¶; Converts a Qobj representing a quantum map to the supermatrix (Liouville); representation. Parameters. q_operQobjSuperoperator to be converted to supermatrix representation. If; q_oper is type=""oper"", then it is taken to act by conjugation,; such that to_super(A) == sprepost(A, A.dag()). Returns. superopQobjA quantum object representing the same map as q_oper, such that; superop.superrep == ""super"". Raises. TypeErrorIf the given quantum object is not a map, or cannot be converted; to supermatrix representation. Operators and Superoperator Dimensions¶; Internal use module for manipulating dims specifications. collapse_dims_oper(dims)[source]¶; Given the dimensions specifications for a ket-, bra- or oper-type; Qobj, returns a dimensions specificatio",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:55044,Availability,down,down,55044,". Parameters. dimslistDimensions specification for a Qobj. Returns. permlistA list such that data[flatten(dims)[idx]] gives the; index of the tensor data corresponding to the idx``th; dimension of ``dims. dims_to_tensor_shape(dims)[source]¶; Given the dims of a Qobj instance, returns the shape of the; corresponding tensor. This helps, for instance, resolve the; column-stacking convention for superoperators. Parameters. dimslistDimensions specification for a Qobj. Returns. tensor_shapetupleNumPy shape of the corresponding tensor. enumerate_flat(l)[source]¶; Labels the indices at which scalars occur in a flattened list.; Given a list containing a mix of scalars and lists,; returns a list of the same structure, where each scalar; has been replaced by an index into the flattened list.; Examples; >>> print(enumerate_flat([[[10], [20, 30]], 40])) ; [[[0], [1, 2]], 3]. flatten(l)[source]¶; Flattens a list of lists to the first level.; Given a list containing a mix of scalars and lists,; flattens down to a list of the scalars within the original; list.; Examples; >>> flatten([[[0], 1], 2]) ; [0, 1, 2]. is_scalar(dims)[source]¶; Returns True if a dims specification is effectively; a scalar (has dimension 1). unflatten(l, idxs)[source]¶; Unflattens a list by a given structure.; Given a list of scalars and a deep list of indices; as produced by flatten, returns an “unflattened”; form of the list. This perfectly inverts flatten.; Examples; >>> l = [[[10, 20, 30], [40, 50, 60]], [[70, 80, 90], [100, 110, 120]]] ; >>> idxs = enumerate_flat(l) ; >>> unflatten(flatten(l), idxs) == l ; True. Functions acting on states and operators¶. Expectation Values¶. expect(oper, state)[source]¶; Calculates the expectation value for operator(s) and state(s). Parameters. operqobj/array-likeA single or a list or operators for expectation value. stateqobj/array-likeA single or a list of quantum states or density matrices. Returns. exptfloat/complex/array-likeExpectation value. real if oper is Hermi",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
https://qutip.org/docs/4.7/apidoc/functions.html:58374,Availability,mask,mask,58374,"ct. tensor(*args)[source]¶; Calculates the tensor product of input operators. Parameters. argsarray_likelist or array of quantum objects for tensor product. Returns. objqobjA composite quantum object. Examples; >>> tensor([sigmax(), sigmax()]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; https://en.wikipedia.org/wiki/",MatchSource.WIKI,docs/4.7/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html
