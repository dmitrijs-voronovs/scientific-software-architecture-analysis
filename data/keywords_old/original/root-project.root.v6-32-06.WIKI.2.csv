id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/doc/master/civetweb_8c_source.html:484248,Integrability,protocol,protocol,484248,,MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:484697,Integrability,protocol,protocols,484697,"359alpn_select_cb(SSL *ssl,; 16360 const unsigned char **out,; 16361 unsigned char *outlen,; 16362 const unsigned char *in,; 16363 unsigned int inlen,; 16364 void *arg); 16365{; 16366 struct mg_domain_context *dom_ctx = (struct mg_domain_context *)arg;; 16367 unsigned int i, j, enable_http2 = 0;; 16368 const char **alpn_proto_order = alpn_proto_order_http1;; 16369 ; 16370 struct mg_workerTLS *tls =; 16371 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 16372 ; 16373 (void)ssl;; 16374 ; 16375 if (tls == NULL) {; 16376 /* Need to store protocol in Thread Local Storage */; 16377 /* If there is no Thread Local Storage, don't use ALPN */; 16378 return SSL_TLSEXT_ERR_NOACK;; 16379 }; 16380 ; 16381#if defined(USE_HTTP2); 16382 enable_http2 = (0 == strcmp(dom_ctx->config[ENABLE_HTTP2], ""yes""));; 16383 if (enable_http2) {; 16384 alpn_proto_order = alpn_proto_order_http2;; 16385 }; 16386#endif; 16387 ; 16388 for (j = 0; alpn_proto_order[j] != NULL; j++) {; 16389 /* check all accepted protocols in this order */; 16390 const char *alpn_proto = alpn_proto_order[j];; 16391 /* search input for matching protocol */; 16392 for (i = 0; i < inlen; i++) {; 16393 if (!memcmp(in + i, alpn_proto, (unsigned char)alpn_proto[0])) {; 16394 *out = in + i + 1;; 16395 *outlen = in[i];; 16396 tls->alpn_proto = alpn_proto;; 16397 return SSL_TLSEXT_ERR_OK;; 16398 }; 16399 }; 16400 }; 16401 ; 16402 /* Nothing found */; 16403 return SSL_TLSEXT_ERR_NOACK;; 16404}; 16405 ; 16406 ; 16407static int; 16408next_protos_advertised_cb(SSL *ssl,; 16409 const unsigned char **data,; 16410 unsigned int *len,; 16411 void *arg); 16412{; 16413 struct mg_domain_context *dom_ctx = (struct mg_domain_context *)arg;; 16414 *data = (const unsigned char *)alpn_proto_list;; 16415 *len = (unsigned int)strlen((const char *)data);; 16416 ; 16417 (void)ssl;; 16418 (void)dom_ctx;; 16419 ; 16420 return SSL_TLSEXT_ERR_OK;; 16421}; 16422 ; 16423 ; 16424static int; 16425init_alpn(struct mg_context *phys_ctx, struct mg_domain_c",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:484813,Integrability,protocol,protocol,484813,"har *in,; 16363 unsigned int inlen,; 16364 void *arg); 16365{; 16366 struct mg_domain_context *dom_ctx = (struct mg_domain_context *)arg;; 16367 unsigned int i, j, enable_http2 = 0;; 16368 const char **alpn_proto_order = alpn_proto_order_http1;; 16369 ; 16370 struct mg_workerTLS *tls =; 16371 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 16372 ; 16373 (void)ssl;; 16374 ; 16375 if (tls == NULL) {; 16376 /* Need to store protocol in Thread Local Storage */; 16377 /* If there is no Thread Local Storage, don't use ALPN */; 16378 return SSL_TLSEXT_ERR_NOACK;; 16379 }; 16380 ; 16381#if defined(USE_HTTP2); 16382 enable_http2 = (0 == strcmp(dom_ctx->config[ENABLE_HTTP2], ""yes""));; 16383 if (enable_http2) {; 16384 alpn_proto_order = alpn_proto_order_http2;; 16385 }; 16386#endif; 16387 ; 16388 for (j = 0; alpn_proto_order[j] != NULL; j++) {; 16389 /* check all accepted protocols in this order */; 16390 const char *alpn_proto = alpn_proto_order[j];; 16391 /* search input for matching protocol */; 16392 for (i = 0; i < inlen; i++) {; 16393 if (!memcmp(in + i, alpn_proto, (unsigned char)alpn_proto[0])) {; 16394 *out = in + i + 1;; 16395 *outlen = in[i];; 16396 tls->alpn_proto = alpn_proto;; 16397 return SSL_TLSEXT_ERR_OK;; 16398 }; 16399 }; 16400 }; 16401 ; 16402 /* Nothing found */; 16403 return SSL_TLSEXT_ERR_NOACK;; 16404}; 16405 ; 16406 ; 16407static int; 16408next_protos_advertised_cb(SSL *ssl,; 16409 const unsigned char **data,; 16410 unsigned int *len,; 16411 void *arg); 16412{; 16413 struct mg_domain_context *dom_ctx = (struct mg_domain_context *)arg;; 16414 *data = (const unsigned char *)alpn_proto_list;; 16415 *len = (unsigned int)strlen((const char *)data);; 16416 ; 16417 (void)ssl;; 16418 (void)dom_ctx;; 16419 ; 16420 return SSL_TLSEXT_ERR_OK;; 16421}; 16422 ; 16423 ; 16424static int; 16425init_alpn(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx); 16426{; 16427 unsigned int alpn_len = (unsigned int)strlen((char *)alpn_proto_list);; 16428 int re",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:506002,Integrability,message,message,506002," GCC diagnostic ignored ""-Wconversion""; 17006#endif; 17007 /* Data type of linger structure elements may differ,; 17008 * so we don't know what cast we need here.; 17009 * Disable type conversion warnings. */; 17010 ; 17011 linger.l_linger = (linger_timeout + 999) / 1000;; 17012 ; 17013#if defined(GCC_DIAGNOSTIC); 17014#pragma GCC diagnostic pop; 17015#endif; 17016#if defined(_MSC_VER); 17017#pragma warning(pop); 17018#endif; 17019 ; 17020 } else {; 17021 linger.l_onoff = 0;; 17022 linger.l_linger = 0;; 17023 }; 17024 ; 17025 if (linger_timeout < -1) {; 17026 /* Default: don't configure any linger */; 17027 } else if (getsockopt(conn->client.sock,; 17028 SOL_SOCKET,; 17029 SO_ERROR,; 17030#if defined(_WIN32) /* WinSock uses different data type here */; 17031 (char *)&error_code,; 17032#else; 17033 &error_code,; 17034#endif; 17035 &opt_len); 17036 != 0) {; 17037 /* Cannot determine if socket is already closed. This should; 17038 * not occur and never did in a test. Log an error message; 17039 * and continue. */; 17040 mg_cry_internal(conn,; 17041 ""%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s"",; 17042 __func__,; 17043 strerror(ERRNO));; 17044#if defined(_WIN32); 17045 } else if (error_code == WSAECONNRESET) {; 17046#else; 17047 } else if (error_code == ECONNRESET) {; 17048#endif; 17049 /* Socket already closed by client/peer, close socket without linger; 17050 */; 17051 } else {; 17052 ; 17053 /* Set linger timeout */; 17054 if (setsockopt(conn->client.sock,; 17055 SOL_SOCKET,; 17056 SO_LINGER,; 17057 (char *)&linger,; 17058 sizeof(linger)); 17059 != 0) {; 17060 mg_cry_internal(; 17061 conn,; 17062 ""%s: setsockopt(SOL_SOCKET SO_LINGER(%i,%i)) failed: %s"",; 17063 __func__,; 17064 linger.l_onoff,; 17065 linger.l_linger,; 17066 strerror(ERRNO));; 17067 }; 17068 }; 17069 ; 17070 /* Now we know that our FIN is ACK-ed, safe to close */; 17071 closesocket(conn->client.sock);; 17072 conn->client.sock = INVALID_SOCKET;; 17073}; 17074#endif; 17075 ; 17076 ; 17077static void; ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:518115,Integrability,protocol,protocol,518115,"s, 0, sizeof(opts));; 17433 opts.host = host;; 17434 opts.port = port;; 17435 return mg_connect_client_impl(&opts,; 17436 use_ssl,; 17437 error_buffer,; 17438 error_buffer_size);; 17439}; 17440 ; 17441 ; 17442#if defined(MG_EXPERIMENTAL_INTERFACES); 17443struct mg_connection *; 17444mg_connect_client2(const char *host,; 17445 const char *protocol,; 17446 int port,; 17447 const char *path,; 17448 struct mg_init_data *init,; 17449 struct mg_error_data *error); 17450{; 17451 int is_ssl, is_ws;; 17452 /* void *user_data = (init != NULL) ? init->user_data : NULL; -- TODO */; 17453 ; 17454 if (error != NULL) {; 17455 error->code = 0;; 17456 if (error->text_buffer_size > 0) {; 17457 *error->text = 0;; 17458 }; 17459 }; 17460 ; 17461 if ((host == NULL) || (protocol == NULL)) {; 17462 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17463 mg_snprintf(NULL,; 17464 NULL, /* No truncation check for error buffers */; 17465 error->text,; 17466 error->text_buffer_size,; 17467 ""%s"",; 17468 ""Invalid parameters"");; 17469 }; 17470 return NULL;; 17471 }; 17472 ; 17473 /* check all known protocolls */; 17474 if (!mg_strcasecmp(protocol, ""http"")) {; 17475 is_ssl = 0;; 17476 is_ws = 0;; 17477 } else if (!mg_strcasecmp(protocol, ""https"")) {; 17478 is_ssl = 1;; 17479 is_ws = 0;; 17480#if defined(USE_WEBSOCKET); 17481 } else if (!mg_strcasecmp(protocol, ""ws"")) {; 17482 is_ssl = 0;; 17483 is_ws = 1;; 17484 } else if (!mg_strcasecmp(protocol, ""wss"")) {; 17485 is_ssl = 1;; 17486 is_ws = 1;; 17487#endif; 17488 } else {; 17489 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17490 mg_snprintf(NULL,; 17491 NULL, /* No truncation check for error buffers */; 17492 error->text,; 17493 error->text_buffer_size,; 17494 ""Protocol %s not supported"",; 17495 protocol);; 17496 }; 17497 return NULL;; 17498 }; 17499 ; 17500 /* TODO: The current implementation here just calls the old; 17501 * implementations, without using any new options. This is just a first; 17502 * step to test the new interf",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:518534,Integrability,protocol,protocol,518534,"s, 0, sizeof(opts));; 17433 opts.host = host;; 17434 opts.port = port;; 17435 return mg_connect_client_impl(&opts,; 17436 use_ssl,; 17437 error_buffer,; 17438 error_buffer_size);; 17439}; 17440 ; 17441 ; 17442#if defined(MG_EXPERIMENTAL_INTERFACES); 17443struct mg_connection *; 17444mg_connect_client2(const char *host,; 17445 const char *protocol,; 17446 int port,; 17447 const char *path,; 17448 struct mg_init_data *init,; 17449 struct mg_error_data *error); 17450{; 17451 int is_ssl, is_ws;; 17452 /* void *user_data = (init != NULL) ? init->user_data : NULL; -- TODO */; 17453 ; 17454 if (error != NULL) {; 17455 error->code = 0;; 17456 if (error->text_buffer_size > 0) {; 17457 *error->text = 0;; 17458 }; 17459 }; 17460 ; 17461 if ((host == NULL) || (protocol == NULL)) {; 17462 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17463 mg_snprintf(NULL,; 17464 NULL, /* No truncation check for error buffers */; 17465 error->text,; 17466 error->text_buffer_size,; 17467 ""%s"",; 17468 ""Invalid parameters"");; 17469 }; 17470 return NULL;; 17471 }; 17472 ; 17473 /* check all known protocolls */; 17474 if (!mg_strcasecmp(protocol, ""http"")) {; 17475 is_ssl = 0;; 17476 is_ws = 0;; 17477 } else if (!mg_strcasecmp(protocol, ""https"")) {; 17478 is_ssl = 1;; 17479 is_ws = 0;; 17480#if defined(USE_WEBSOCKET); 17481 } else if (!mg_strcasecmp(protocol, ""ws"")) {; 17482 is_ssl = 0;; 17483 is_ws = 1;; 17484 } else if (!mg_strcasecmp(protocol, ""wss"")) {; 17485 is_ssl = 1;; 17486 is_ws = 1;; 17487#endif; 17488 } else {; 17489 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17490 mg_snprintf(NULL,; 17491 NULL, /* No truncation check for error buffers */; 17492 error->text,; 17493 error->text_buffer_size,; 17494 ""Protocol %s not supported"",; 17495 protocol);; 17496 }; 17497 return NULL;; 17498 }; 17499 ; 17500 /* TODO: The current implementation here just calls the old; 17501 * implementations, without using any new options. This is just a first; 17502 * step to test the new interf",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:518867,Integrability,protocol,protocolls,518867,"s, 0, sizeof(opts));; 17433 opts.host = host;; 17434 opts.port = port;; 17435 return mg_connect_client_impl(&opts,; 17436 use_ssl,; 17437 error_buffer,; 17438 error_buffer_size);; 17439}; 17440 ; 17441 ; 17442#if defined(MG_EXPERIMENTAL_INTERFACES); 17443struct mg_connection *; 17444mg_connect_client2(const char *host,; 17445 const char *protocol,; 17446 int port,; 17447 const char *path,; 17448 struct mg_init_data *init,; 17449 struct mg_error_data *error); 17450{; 17451 int is_ssl, is_ws;; 17452 /* void *user_data = (init != NULL) ? init->user_data : NULL; -- TODO */; 17453 ; 17454 if (error != NULL) {; 17455 error->code = 0;; 17456 if (error->text_buffer_size > 0) {; 17457 *error->text = 0;; 17458 }; 17459 }; 17460 ; 17461 if ((host == NULL) || (protocol == NULL)) {; 17462 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17463 mg_snprintf(NULL,; 17464 NULL, /* No truncation check for error buffers */; 17465 error->text,; 17466 error->text_buffer_size,; 17467 ""%s"",; 17468 ""Invalid parameters"");; 17469 }; 17470 return NULL;; 17471 }; 17472 ; 17473 /* check all known protocolls */; 17474 if (!mg_strcasecmp(protocol, ""http"")) {; 17475 is_ssl = 0;; 17476 is_ws = 0;; 17477 } else if (!mg_strcasecmp(protocol, ""https"")) {; 17478 is_ssl = 1;; 17479 is_ws = 0;; 17480#if defined(USE_WEBSOCKET); 17481 } else if (!mg_strcasecmp(protocol, ""ws"")) {; 17482 is_ssl = 0;; 17483 is_ws = 1;; 17484 } else if (!mg_strcasecmp(protocol, ""wss"")) {; 17485 is_ssl = 1;; 17486 is_ws = 1;; 17487#endif; 17488 } else {; 17489 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17490 mg_snprintf(NULL,; 17491 NULL, /* No truncation check for error buffers */; 17492 error->text,; 17493 error->text_buffer_size,; 17494 ""Protocol %s not supported"",; 17495 protocol);; 17496 }; 17497 return NULL;; 17498 }; 17499 ; 17500 /* TODO: The current implementation here just calls the old; 17501 * implementations, without using any new options. This is just a first; 17502 * step to test the new interf",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:518907,Integrability,protocol,protocol,518907,"s, 0, sizeof(opts));; 17433 opts.host = host;; 17434 opts.port = port;; 17435 return mg_connect_client_impl(&opts,; 17436 use_ssl,; 17437 error_buffer,; 17438 error_buffer_size);; 17439}; 17440 ; 17441 ; 17442#if defined(MG_EXPERIMENTAL_INTERFACES); 17443struct mg_connection *; 17444mg_connect_client2(const char *host,; 17445 const char *protocol,; 17446 int port,; 17447 const char *path,; 17448 struct mg_init_data *init,; 17449 struct mg_error_data *error); 17450{; 17451 int is_ssl, is_ws;; 17452 /* void *user_data = (init != NULL) ? init->user_data : NULL; -- TODO */; 17453 ; 17454 if (error != NULL) {; 17455 error->code = 0;; 17456 if (error->text_buffer_size > 0) {; 17457 *error->text = 0;; 17458 }; 17459 }; 17460 ; 17461 if ((host == NULL) || (protocol == NULL)) {; 17462 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17463 mg_snprintf(NULL,; 17464 NULL, /* No truncation check for error buffers */; 17465 error->text,; 17466 error->text_buffer_size,; 17467 ""%s"",; 17468 ""Invalid parameters"");; 17469 }; 17470 return NULL;; 17471 }; 17472 ; 17473 /* check all known protocolls */; 17474 if (!mg_strcasecmp(protocol, ""http"")) {; 17475 is_ssl = 0;; 17476 is_ws = 0;; 17477 } else if (!mg_strcasecmp(protocol, ""https"")) {; 17478 is_ssl = 1;; 17479 is_ws = 0;; 17480#if defined(USE_WEBSOCKET); 17481 } else if (!mg_strcasecmp(protocol, ""ws"")) {; 17482 is_ssl = 0;; 17483 is_ws = 1;; 17484 } else if (!mg_strcasecmp(protocol, ""wss"")) {; 17485 is_ssl = 1;; 17486 is_ws = 1;; 17487#endif; 17488 } else {; 17489 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17490 mg_snprintf(NULL,; 17491 NULL, /* No truncation check for error buffers */; 17492 error->text,; 17493 error->text_buffer_size,; 17494 ""Protocol %s not supported"",; 17495 protocol);; 17496 }; 17497 return NULL;; 17498 }; 17499 ; 17500 /* TODO: The current implementation here just calls the old; 17501 * implementations, without using any new options. This is just a first; 17502 * step to test the new interf",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:518998,Integrability,protocol,protocol,518998,"s, 0, sizeof(opts));; 17433 opts.host = host;; 17434 opts.port = port;; 17435 return mg_connect_client_impl(&opts,; 17436 use_ssl,; 17437 error_buffer,; 17438 error_buffer_size);; 17439}; 17440 ; 17441 ; 17442#if defined(MG_EXPERIMENTAL_INTERFACES); 17443struct mg_connection *; 17444mg_connect_client2(const char *host,; 17445 const char *protocol,; 17446 int port,; 17447 const char *path,; 17448 struct mg_init_data *init,; 17449 struct mg_error_data *error); 17450{; 17451 int is_ssl, is_ws;; 17452 /* void *user_data = (init != NULL) ? init->user_data : NULL; -- TODO */; 17453 ; 17454 if (error != NULL) {; 17455 error->code = 0;; 17456 if (error->text_buffer_size > 0) {; 17457 *error->text = 0;; 17458 }; 17459 }; 17460 ; 17461 if ((host == NULL) || (protocol == NULL)) {; 17462 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17463 mg_snprintf(NULL,; 17464 NULL, /* No truncation check for error buffers */; 17465 error->text,; 17466 error->text_buffer_size,; 17467 ""%s"",; 17468 ""Invalid parameters"");; 17469 }; 17470 return NULL;; 17471 }; 17472 ; 17473 /* check all known protocolls */; 17474 if (!mg_strcasecmp(protocol, ""http"")) {; 17475 is_ssl = 0;; 17476 is_ws = 0;; 17477 } else if (!mg_strcasecmp(protocol, ""https"")) {; 17478 is_ssl = 1;; 17479 is_ws = 0;; 17480#if defined(USE_WEBSOCKET); 17481 } else if (!mg_strcasecmp(protocol, ""ws"")) {; 17482 is_ssl = 0;; 17483 is_ws = 1;; 17484 } else if (!mg_strcasecmp(protocol, ""wss"")) {; 17485 is_ssl = 1;; 17486 is_ws = 1;; 17487#endif; 17488 } else {; 17489 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17490 mg_snprintf(NULL,; 17491 NULL, /* No truncation check for error buffers */; 17492 error->text,; 17493 error->text_buffer_size,; 17494 ""Protocol %s not supported"",; 17495 protocol);; 17496 }; 17497 return NULL;; 17498 }; 17499 ; 17500 /* TODO: The current implementation here just calls the old; 17501 * implementations, without using any new options. This is just a first; 17502 * step to test the new interf",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:519123,Integrability,protocol,protocol,519123,"s, 0, sizeof(opts));; 17433 opts.host = host;; 17434 opts.port = port;; 17435 return mg_connect_client_impl(&opts,; 17436 use_ssl,; 17437 error_buffer,; 17438 error_buffer_size);; 17439}; 17440 ; 17441 ; 17442#if defined(MG_EXPERIMENTAL_INTERFACES); 17443struct mg_connection *; 17444mg_connect_client2(const char *host,; 17445 const char *protocol,; 17446 int port,; 17447 const char *path,; 17448 struct mg_init_data *init,; 17449 struct mg_error_data *error); 17450{; 17451 int is_ssl, is_ws;; 17452 /* void *user_data = (init != NULL) ? init->user_data : NULL; -- TODO */; 17453 ; 17454 if (error != NULL) {; 17455 error->code = 0;; 17456 if (error->text_buffer_size > 0) {; 17457 *error->text = 0;; 17458 }; 17459 }; 17460 ; 17461 if ((host == NULL) || (protocol == NULL)) {; 17462 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17463 mg_snprintf(NULL,; 17464 NULL, /* No truncation check for error buffers */; 17465 error->text,; 17466 error->text_buffer_size,; 17467 ""%s"",; 17468 ""Invalid parameters"");; 17469 }; 17470 return NULL;; 17471 }; 17472 ; 17473 /* check all known protocolls */; 17474 if (!mg_strcasecmp(protocol, ""http"")) {; 17475 is_ssl = 0;; 17476 is_ws = 0;; 17477 } else if (!mg_strcasecmp(protocol, ""https"")) {; 17478 is_ssl = 1;; 17479 is_ws = 0;; 17480#if defined(USE_WEBSOCKET); 17481 } else if (!mg_strcasecmp(protocol, ""ws"")) {; 17482 is_ssl = 0;; 17483 is_ws = 1;; 17484 } else if (!mg_strcasecmp(protocol, ""wss"")) {; 17485 is_ssl = 1;; 17486 is_ws = 1;; 17487#endif; 17488 } else {; 17489 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17490 mg_snprintf(NULL,; 17491 NULL, /* No truncation check for error buffers */; 17492 error->text,; 17493 error->text_buffer_size,; 17494 ""Protocol %s not supported"",; 17495 protocol);; 17496 }; 17497 return NULL;; 17498 }; 17499 ; 17500 /* TODO: The current implementation here just calls the old; 17501 * implementations, without using any new options. This is just a first; 17502 * step to test the new interf",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:519212,Integrability,protocol,protocol,519212,"s, 0, sizeof(opts));; 17433 opts.host = host;; 17434 opts.port = port;; 17435 return mg_connect_client_impl(&opts,; 17436 use_ssl,; 17437 error_buffer,; 17438 error_buffer_size);; 17439}; 17440 ; 17441 ; 17442#if defined(MG_EXPERIMENTAL_INTERFACES); 17443struct mg_connection *; 17444mg_connect_client2(const char *host,; 17445 const char *protocol,; 17446 int port,; 17447 const char *path,; 17448 struct mg_init_data *init,; 17449 struct mg_error_data *error); 17450{; 17451 int is_ssl, is_ws;; 17452 /* void *user_data = (init != NULL) ? init->user_data : NULL; -- TODO */; 17453 ; 17454 if (error != NULL) {; 17455 error->code = 0;; 17456 if (error->text_buffer_size > 0) {; 17457 *error->text = 0;; 17458 }; 17459 }; 17460 ; 17461 if ((host == NULL) || (protocol == NULL)) {; 17462 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17463 mg_snprintf(NULL,; 17464 NULL, /* No truncation check for error buffers */; 17465 error->text,; 17466 error->text_buffer_size,; 17467 ""%s"",; 17468 ""Invalid parameters"");; 17469 }; 17470 return NULL;; 17471 }; 17472 ; 17473 /* check all known protocolls */; 17474 if (!mg_strcasecmp(protocol, ""http"")) {; 17475 is_ssl = 0;; 17476 is_ws = 0;; 17477 } else if (!mg_strcasecmp(protocol, ""https"")) {; 17478 is_ssl = 1;; 17479 is_ws = 0;; 17480#if defined(USE_WEBSOCKET); 17481 } else if (!mg_strcasecmp(protocol, ""ws"")) {; 17482 is_ssl = 0;; 17483 is_ws = 1;; 17484 } else if (!mg_strcasecmp(protocol, ""wss"")) {; 17485 is_ssl = 1;; 17486 is_ws = 1;; 17487#endif; 17488 } else {; 17489 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17490 mg_snprintf(NULL,; 17491 NULL, /* No truncation check for error buffers */; 17492 error->text,; 17493 error->text_buffer_size,; 17494 ""Protocol %s not supported"",; 17495 protocol);; 17496 }; 17497 return NULL;; 17498 }; 17499 ; 17500 /* TODO: The current implementation here just calls the old; 17501 * implementations, without using any new options. This is just a first; 17502 * step to test the new interf",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:519538,Integrability,protocol,protocol,519538,"s, 0, sizeof(opts));; 17433 opts.host = host;; 17434 opts.port = port;; 17435 return mg_connect_client_impl(&opts,; 17436 use_ssl,; 17437 error_buffer,; 17438 error_buffer_size);; 17439}; 17440 ; 17441 ; 17442#if defined(MG_EXPERIMENTAL_INTERFACES); 17443struct mg_connection *; 17444mg_connect_client2(const char *host,; 17445 const char *protocol,; 17446 int port,; 17447 const char *path,; 17448 struct mg_init_data *init,; 17449 struct mg_error_data *error); 17450{; 17451 int is_ssl, is_ws;; 17452 /* void *user_data = (init != NULL) ? init->user_data : NULL; -- TODO */; 17453 ; 17454 if (error != NULL) {; 17455 error->code = 0;; 17456 if (error->text_buffer_size > 0) {; 17457 *error->text = 0;; 17458 }; 17459 }; 17460 ; 17461 if ((host == NULL) || (protocol == NULL)) {; 17462 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17463 mg_snprintf(NULL,; 17464 NULL, /* No truncation check for error buffers */; 17465 error->text,; 17466 error->text_buffer_size,; 17467 ""%s"",; 17468 ""Invalid parameters"");; 17469 }; 17470 return NULL;; 17471 }; 17472 ; 17473 /* check all known protocolls */; 17474 if (!mg_strcasecmp(protocol, ""http"")) {; 17475 is_ssl = 0;; 17476 is_ws = 0;; 17477 } else if (!mg_strcasecmp(protocol, ""https"")) {; 17478 is_ssl = 1;; 17479 is_ws = 0;; 17480#if defined(USE_WEBSOCKET); 17481 } else if (!mg_strcasecmp(protocol, ""ws"")) {; 17482 is_ssl = 0;; 17483 is_ws = 1;; 17484 } else if (!mg_strcasecmp(protocol, ""wss"")) {; 17485 is_ssl = 1;; 17486 is_ws = 1;; 17487#endif; 17488 } else {; 17489 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17490 mg_snprintf(NULL,; 17491 NULL, /* No truncation check for error buffers */; 17492 error->text,; 17493 error->text_buffer_size,; 17494 ""Protocol %s not supported"",; 17495 protocol);; 17496 }; 17497 return NULL;; 17498 }; 17499 ; 17500 /* TODO: The current implementation here just calls the old; 17501 * implementations, without using any new options. This is just a first; 17502 * step to test the new interf",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:519770,Integrability,interface,interfaces,519770,"e,; 17467 ""%s"",; 17468 ""Invalid parameters"");; 17469 }; 17470 return NULL;; 17471 }; 17472 ; 17473 /* check all known protocolls */; 17474 if (!mg_strcasecmp(protocol, ""http"")) {; 17475 is_ssl = 0;; 17476 is_ws = 0;; 17477 } else if (!mg_strcasecmp(protocol, ""https"")) {; 17478 is_ssl = 1;; 17479 is_ws = 0;; 17480#if defined(USE_WEBSOCKET); 17481 } else if (!mg_strcasecmp(protocol, ""ws"")) {; 17482 is_ssl = 0;; 17483 is_ws = 1;; 17484 } else if (!mg_strcasecmp(protocol, ""wss"")) {; 17485 is_ssl = 1;; 17486 is_ws = 1;; 17487#endif; 17488 } else {; 17489 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17490 mg_snprintf(NULL,; 17491 NULL, /* No truncation check for error buffers */; 17492 error->text,; 17493 error->text_buffer_size,; 17494 ""Protocol %s not supported"",; 17495 protocol);; 17496 }; 17497 return NULL;; 17498 }; 17499 ; 17500 /* TODO: The current implementation here just calls the old; 17501 * implementations, without using any new options. This is just a first; 17502 * step to test the new interfaces. */; 17503#if defined(USE_WEBSOCKET); 17504 if (is_ws) {; 17505 /* TODO: implement all options */; 17506 return mg_connect_websocket_client(; 17507 host,; 17508 port,; 17509 is_ssl,; 17510 ((error != NULL) ? error->text : NULL),; 17511 ((error != NULL) ? error->text_buffer_size : 0),; 17512 (path ? path : """"),; 17513 NULL /* TODO: origin */,; 17514 experimental_websocket_client_data_wrapper,; 17515 experimental_websocket_client_close_wrapper,; 17516 (void *)init->callbacks);; 17517 }; 17518#endif; 17519 ; 17520 /* TODO: all additional options */; 17521 struct mg_client_options opts;; 17522 memset(&opts, 0, sizeof(opts));; 17523 opts.host = host;; 17524 opts.port = port;; 17525 return mg_connect_client_impl(&opts,; 17526 is_ssl,; 17527 ((error != NULL) ? error->text : NULL),; 17528 ((error != NULL) ? error->text_buffer_size; 17529 : 0));; 17530}; 17531#endif; 17532 ; 17533 ; 17534static const struct {; 17535 const char *proto;; 17536 size_t proto_len;; 175",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:521576,Integrability,protocol,protocol,521576,"rror != NULL) ? error->text : NULL),; 17528 ((error != NULL) ? error->text_buffer_size; 17529 : 0));; 17530}; 17531#endif; 17532 ; 17533 ; 17534static const struct {; 17535 const char *proto;; 17536 size_t proto_len;; 17537 unsigned default_port;; 17538} abs_uri_protocols[] = {{""http://"", 7, 80},; 17539 {""https://"", 8, 443},; 17540 {""ws://"", 5, 80},; 17541 {""wss://"", 6, 443},; 17542 {NULL, 0, 0}};; 17543 ; 17544 ; 17545/* Check if the uri is valid.; 17546 * return 0 for invalid uri,; 17547 * return 1 for *,; 17548 * return 2 for relative uri,; 17549 * return 3 for absolute uri without port,; 17550 * return 4 for absolute uri with port */; 17551static int; 17552get_uri_type(const char *uri); 17553{; 17554 int i;; 17555 const char *hostend, *portbegin;; 17556 char *portend;; 17557 unsigned long port;; 17558 ; 17559 /* According to the HTTP standard; 17560 * http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2; 17561 * URI can be an asterisk (*) or should start with slash (relative uri),; 17562 * or it should start with the protocol (absolute uri). */; 17563 if ((uri[0] == '*') && (uri[1] == '\0')) {; 17564 /* asterisk */; 17565 return 1;; 17566 }; 17567 ; 17568 /* Valid URIs according to RFC 3986; 17569 * (https://www.ietf.org/rfc/rfc3986.txt); 17570 * must only contain reserved characters :/?#[]@!$&'()*+,;=; 17571 * and unreserved characters A-Z a-z 0-9 and -._~; 17572 * and % encoded symbols.; 17573 */; 17574 for (i = 0; uri[i] != 0; i++) {; 17575 if (uri[i] < 33) {; 17576 /* control characters and spaces are invalid */; 17577 return 0;; 17578 }; 17579 /* Allow everything else here (See #894) */; 17580 }; 17581 ; 17582 /* A relative uri starts with a / character */; 17583 if (uri[0] == '/') {; 17584 /* relative uri */; 17585 return 2;; 17586 }; 17587 ; 17588 /* It could be an absolute uri: */; 17589 /* This function only checks if the uri is valid, not if it is; 17590 * addressing the current server. So civetweb can also be used; 17591 * as a proxy server.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:524715,Integrability,protocol,protocol,524715,"egin;; 17632 char *portend;; 17633 ; 17634 auth_domain_check_enabled =; 17635 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK], ""yes"");; 17636 ; 17637 /* DNS is case insensitive, so use case insensitive string compare here; 17638 */; 17639 for (i = 0; abs_uri_protocols[i].proto != NULL; i++) {; 17640 if (mg_strncasecmp(uri,; 17641 abs_uri_protocols[i].proto,; 17642 abs_uri_protocols[i].proto_len); 17643 == 0) {; 17644 ; 17645 hostbegin = uri + abs_uri_protocols[i].proto_len;; 17646 hostend = strchr(hostbegin, '/');; 17647 if (!hostend) {; 17648 return 0;; 17649 }; 17650 portbegin = strchr(hostbegin, ':');; 17651 if ((!portbegin) || (portbegin > hostend)) {; 17652 port = abs_uri_protocols[i].default_port;; 17653 request_domain_len = (size_t)(hostend - hostbegin);; 17654 } else {; 17655 port = strtoul(portbegin + 1, &portend, 10);; 17656 if ((portend != hostend) || (port <= 0); 17657 || !is_valid_port(port)) {; 17658 return 0;; 17659 }; 17660 request_domain_len = (size_t)(portbegin - hostbegin);; 17661 }; 17662 /* protocol found, port set */; 17663 break;; 17664 }; 17665 }; 17666 ; 17667 if (!port) {; 17668 /* port remains 0 if the protocol is not found */; 17669 return 0;; 17670 }; 17671 ; 17672 /* Check if the request is directed to a different server. */; 17673 /* First check if the port is the same. */; 17674 if (ntohs(USA_IN_PORT_UNSAFE(&conn->client.lsa)) != port) {; 17675 /* Request is directed to a different port */; 17676 return 0;; 17677 }; 17678 ; 17679 /* Finally check if the server corresponds to the authentication; 17680 * domain of the server (the server domain).; 17681 * Allow full matches (like http://mydomain.com/path/file.ext), and; 17682 * allow subdomain matches (like http://www.mydomain.com/path/file.ext),; 17683 * but do not allow substrings (like; 17684 * http://notmydomain.com/path/file.ext; 17685 * or http://mydomain.com.fake/path/file.ext).; 17686 */; 17687 if (auth_domain_check_enabled) {; 17688 server_domain = conn->dom_ctx->",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:524835,Integrability,protocol,protocol,524835,"egin;; 17632 char *portend;; 17633 ; 17634 auth_domain_check_enabled =; 17635 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK], ""yes"");; 17636 ; 17637 /* DNS is case insensitive, so use case insensitive string compare here; 17638 */; 17639 for (i = 0; abs_uri_protocols[i].proto != NULL; i++) {; 17640 if (mg_strncasecmp(uri,; 17641 abs_uri_protocols[i].proto,; 17642 abs_uri_protocols[i].proto_len); 17643 == 0) {; 17644 ; 17645 hostbegin = uri + abs_uri_protocols[i].proto_len;; 17646 hostend = strchr(hostbegin, '/');; 17647 if (!hostend) {; 17648 return 0;; 17649 }; 17650 portbegin = strchr(hostbegin, ':');; 17651 if ((!portbegin) || (portbegin > hostend)) {; 17652 port = abs_uri_protocols[i].default_port;; 17653 request_domain_len = (size_t)(hostend - hostbegin);; 17654 } else {; 17655 port = strtoul(portbegin + 1, &portend, 10);; 17656 if ((portend != hostend) || (port <= 0); 17657 || !is_valid_port(port)) {; 17658 return 0;; 17659 }; 17660 request_domain_len = (size_t)(portbegin - hostbegin);; 17661 }; 17662 /* protocol found, port set */; 17663 break;; 17664 }; 17665 }; 17666 ; 17667 if (!port) {; 17668 /* port remains 0 if the protocol is not found */; 17669 return 0;; 17670 }; 17671 ; 17672 /* Check if the request is directed to a different server. */; 17673 /* First check if the port is the same. */; 17674 if (ntohs(USA_IN_PORT_UNSAFE(&conn->client.lsa)) != port) {; 17675 /* Request is directed to a different port */; 17676 return 0;; 17677 }; 17678 ; 17679 /* Finally check if the server corresponds to the authentication; 17680 * domain of the server (the server domain).; 17681 * Allow full matches (like http://mydomain.com/path/file.ext), and; 17682 * allow subdomain matches (like http://www.mydomain.com/path/file.ext),; 17683 * but do not allow substrings (like; 17684 * http://notmydomain.com/path/file.ext; 17685 * or http://mydomain.com.fake/path/file.ext).; 17686 */; 17687 if (auth_domain_check_enabled) {; 17688 server_domain = conn->dom_ctx->",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:527887,Integrability,message,message,527887,,MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:528435,Integrability,message,message,528435,"time(CLOCK_MONOTONIC, &(conn->req_time));; 17749 ; 17750 conn->request_len =; 17751 read_message(NULL, conn, conn->buf, conn->buf_size, &conn->data_len);; 17752 DEBUG_ASSERT(conn->request_len < 0 || conn->data_len >= conn->request_len);; 17753 if ((conn->request_len >= 0) && (conn->data_len < conn->request_len)) {; 17754 mg_snprintf(conn,; 17755 NULL, /* No truncation check for ebuf */; 17756 ebuf,; 17757 ebuf_len,; 17758 ""%s"",; 17759 ""Invalid message size"");; 17760 *err = 500;; 17761 return 0;; 17762 }; 17763 ; 17764 if ((conn->request_len == 0) && (conn->data_len == conn->buf_size)) {; 17765 mg_snprintf(conn,; 17766 NULL, /* No truncation check for ebuf */; 17767 ebuf,; 17768 ebuf_len,; 17769 ""%s"",; 17770 ""Message too large"");; 17771 *err = 413;; 17772 return 0;; 17773 }; 17774 ; 17775 if (conn->request_len <= 0) {; 17776 if (conn->data_len > 0) {; 17777 mg_snprintf(conn,; 17778 NULL, /* No truncation check for ebuf */; 17779 ebuf,; 17780 ebuf_len,; 17781 ""%s"",; 17782 ""Malformed message"");; 17783 *err = 400;; 17784 } else {; 17785 /* Server did not recv anything -> just close the connection */; 17786 conn->must_close = 1;; 17787 mg_snprintf(conn,; 17788 NULL, /* No truncation check for ebuf */; 17789 ebuf,; 17790 ebuf_len,; 17791 ""%s"",; 17792 ""No data received"");; 17793 *err = 0;; 17794 }; 17795 return 0;; 17796 }; 17797 return 1;; 17798}; 17799 ; 17800 ; 17801static int; 17802get_request(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err); 17803{; 17804 const char *cl;; 17805 ; 17806 conn->connection_type =; 17807 CONNECTION_TYPE_REQUEST; /* request (valid of not) */; 17808 ; 17809 if (!get_message(conn, ebuf, ebuf_len, err)) {; 17810 return 0;; 17811 }; 17812 ; 17813 if (parse_http_request(conn->buf, conn->buf_size, &conn->request_info); 17814 <= 0) {; 17815 mg_snprintf(conn,; 17816 NULL, /* No truncation check for ebuf */; 17817 ebuf,; 17818 ebuf_len,; 17819 ""%s"",; 17820 ""Bad request"");; 17821 *err = 400;; 17822 return 0;; 17823 }; 17824 ; 17825 ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:539909,Integrability,message,message,539909," *user_data); 18164{; 18165 struct mg_connection *conn = NULL;; 18166 ; 18167#if defined(USE_WEBSOCKET); 18168 struct websocket_client_thread_data *thread_data;; 18169 static const char *magic = ""x3JJHMbDL1EzLkh9GBhXDw=="";; 18170 ; 18171 const char *host = client_options->host;; 18172 int i;; 18173 ; 18174#if defined(__clang__); 18175#pragma clang diagnostic push; 18176#pragma clang diagnostic ignored ""-Wformat-nonliteral""; 18177#endif; 18178 ; 18179 /* Establish the client connection and request upgrade */; 18180 conn = mg_connect_client_impl(client_options,; 18181 use_ssl,; 18182 error_buffer,; 18183 error_buffer_size);; 18184 ; 18185 /* Connection object will be null if something goes wrong */; 18186 if (conn == NULL) {; 18187 /* error_buffer should be already filled ... */; 18188 if (!error_buffer[0]) {; 18189 /* ... if not add an error message */; 18190 mg_snprintf(conn,; 18191 NULL, /* No truncation check for ebuf */; 18192 error_buffer,; 18193 error_buffer_size,; 18194 ""Unexpected error"");; 18195 }; 18196 return NULL;; 18197 }; 18198 ; 18199 if (origin != NULL) {; 18200 if (extensions != NULL) {; 18201 i = mg_printf(conn,; 18202 ""GET %s HTTP/1.1\r\n""; 18203 ""Host: %s\r\n""; 18204 ""Upgrade: websocket\r\n""; 18205 ""Connection: Upgrade\r\n""; 18206 ""Sec-WebSocket-Key: %s\r\n""; 18207 ""Sec-WebSocket-Version: 13\r\n""; 18208 ""Sec-WebSocket-Extensions: %s\r\n""; 18209 ""Origin: %s\r\n""; 18210 ""\r\n"",; 18211 path,; 18212 host,; 18213 magic,; 18214 extensions,; 18215 origin);; 18216 } else {; 18217 i = mg_printf(conn,; 18218 ""GET %s HTTP/1.1\r\n""; 18219 ""Host: %s\r\n""; 18220 ""Upgrade: websocket\r\n""; 18221 ""Connection: Upgrade\r\n""; 18222 ""Sec-WebSocket-Key: %s\r\n""; 18223 ""Sec-WebSocket-Version: 13\r\n""; 18224 ""Origin: %s\r\n""; 18225 ""\r\n"",; 18226 path,; 18227 host,; 18228 magic,; 18229 origin);; 18230 }; 18231 } else {; 18232 ; 18233 if (extensions != NULL) {; 18234 i = mg_printf(conn,; 18235 ""GET %s HTTP/1.1\r\n""; 18236 ""Host: %s\r\n""; 18237 ""Upgrade: websocket\r\n""; 182",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:542368,Integrability,protocol,protocol,542368,"Upgrade: websocket\r\n""; 18252 ""Connection: Upgrade\r\n""; 18253 ""Sec-WebSocket-Key: %s\r\n""; 18254 ""Sec-WebSocket-Version: 13\r\n""; 18255 ""\r\n"",; 18256 path,; 18257 host,; 18258 magic);; 18259 }; 18260 }; 18261 if (i <= 0) {; 18262 mg_snprintf(conn,; 18263 NULL, /* No truncation check for ebuf */; 18264 error_buffer,; 18265 error_buffer_size,; 18266 ""%s"",; 18267 ""Error sending request"");; 18268 mg_close_connection(conn);; 18269 return NULL;; 18270 }; 18271 ; 18272 conn->data_len = 0;; 18273 if (!get_response(conn, error_buffer, error_buffer_size, &i)) {; 18274 mg_close_connection(conn);; 18275 return NULL;; 18276 }; 18277 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18278 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18279 ; 18280#if defined(__clang__); 18281#pragma clang diagnostic pop; 18282#endif; 18283 ; 18284 if (conn->response_info.status_code != 101) {; 18285 /* We sent an ""upgrade"" request. For a correct websocket; 18286 * protocol handshake, we expect a ""101 Continue"" response.; 18287 * Otherwise it is a protocol violation. Maybe the HTTP; 18288 * Server does not know websockets. */; 18289 if (!*error_buffer) {; 18290 /* set an error, if not yet set */; 18291 mg_snprintf(conn,; 18292 NULL, /* No truncation check for ebuf */; 18293 error_buffer,; 18294 error_buffer_size,; 18295 ""Unexpected server reply"");; 18296 }; 18297 ; 18298 DEBUG_TRACE(""Websocket client connect error: %s\r\n"", error_buffer);; 18299 mg_close_connection(conn);; 18300 return NULL;; 18301 }; 18302 ; 18303 thread_data = (struct websocket_client_thread_data *)mg_calloc_ctx(; 18304 1, sizeof(struct websocket_client_thread_data), conn->phys_ctx);; 18305 if (!thread_data) {; 18306 DEBUG_TRACE(""%s\r\n"", ""Out of memory"");; 18307 mg_close_connection(conn);; 18308 return NULL;; 18309 }; 18310 ; 18311 thread_data->conn = conn;; 18312 thread_data->data_handler = data_func;; 18313 thread_data->close_handler = close_func;; 18314 thread_data->callback_data = us",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:542452,Integrability,protocol,protocol,542452,"-WebSocket-Key: %s\r\n""; 18254 ""Sec-WebSocket-Version: 13\r\n""; 18255 ""\r\n"",; 18256 path,; 18257 host,; 18258 magic);; 18259 }; 18260 }; 18261 if (i <= 0) {; 18262 mg_snprintf(conn,; 18263 NULL, /* No truncation check for ebuf */; 18264 error_buffer,; 18265 error_buffer_size,; 18266 ""%s"",; 18267 ""Error sending request"");; 18268 mg_close_connection(conn);; 18269 return NULL;; 18270 }; 18271 ; 18272 conn->data_len = 0;; 18273 if (!get_response(conn, error_buffer, error_buffer_size, &i)) {; 18274 mg_close_connection(conn);; 18275 return NULL;; 18276 }; 18277 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18278 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18279 ; 18280#if defined(__clang__); 18281#pragma clang diagnostic pop; 18282#endif; 18283 ; 18284 if (conn->response_info.status_code != 101) {; 18285 /* We sent an ""upgrade"" request. For a correct websocket; 18286 * protocol handshake, we expect a ""101 Continue"" response.; 18287 * Otherwise it is a protocol violation. Maybe the HTTP; 18288 * Server does not know websockets. */; 18289 if (!*error_buffer) {; 18290 /* set an error, if not yet set */; 18291 mg_snprintf(conn,; 18292 NULL, /* No truncation check for ebuf */; 18293 error_buffer,; 18294 error_buffer_size,; 18295 ""Unexpected server reply"");; 18296 }; 18297 ; 18298 DEBUG_TRACE(""Websocket client connect error: %s\r\n"", error_buffer);; 18299 mg_close_connection(conn);; 18300 return NULL;; 18301 }; 18302 ; 18303 thread_data = (struct websocket_client_thread_data *)mg_calloc_ctx(; 18304 1, sizeof(struct websocket_client_thread_data), conn->phys_ctx);; 18305 if (!thread_data) {; 18306 DEBUG_TRACE(""%s\r\n"", ""Out of memory"");; 18307 mg_close_connection(conn);; 18308 return NULL;; 18309 }; 18310 ; 18311 thread_data->conn = conn;; 18312 thread_data->data_handler = data_func;; 18313 thread_data->close_handler = close_func;; 18314 thread_data->callback_data = user_data;; 18315 ; 18316 conn->phys_ctx->worker_threadids =; 18317 (pt",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:550325,Integrability,message,message,550325," char ebuf[100];; 18521 const char *hostend;; 18522 int reqerr, uri_type;; 18523 ; 18524#if defined(USE_SERVER_STATS); 18525 ptrdiff_t mcon = mg_atomic_inc(&(conn->phys_ctx->active_connections));; 18526 mg_atomic_add(&(conn->phys_ctx->total_connections), 1);; 18527 mg_atomic_max(&(conn->phys_ctx->max_active_connections), mcon);; 18528#endif; 18529 ; 18530 DEBUG_TRACE(""Start processing connection from %s"",; 18531 conn->request_info.remote_addr);; 18532 ; 18533 /* Loop over multiple requests sent using the same connection; 18534 * (while ""keep alive""). */; 18535 do {; 18536 DEBUG_TRACE(""calling get_request (%i times for this connection)"",; 18537 conn->handled_requests + 1);; 18538 ; 18539#if defined(USE_SERVER_STATS); 18540 conn->conn_state = 3; /* ready */; 18541#endif; 18542 ; 18543 if (!get_request(conn, ebuf, sizeof(ebuf), &reqerr)) {; 18544 /* The request sent by the client could not be understood by; 18545 * the server, or it was incomplete or a timeout. Send an; 18546 * error message and close the connection. */; 18547 if (reqerr > 0) {; 18548 DEBUG_ASSERT(ebuf[0] != '\0');; 18549 mg_send_http_error(conn, reqerr, ""%s"", ebuf);; 18550 }; 18551 ; 18552 } else if (strcmp(ri->http_version, ""1.0""); 18553 && strcmp(ri->http_version, ""1.1"")) {; 18554 /* HTTP/2 is not allowed here */; 18555 mg_snprintf(conn,; 18556 NULL, /* No truncation check for ebuf */; 18557 ebuf,; 18558 sizeof(ebuf),; 18559 ""Bad HTTP version: [%s]"",; 18560 ri->http_version);; 18561 mg_send_http_error(conn, 505, ""%s"", ebuf);; 18562 }; 18563 ; 18564 if (ebuf[0] == '\0') {; 18565 uri_type = get_uri_type(conn->request_info.request_uri);; 18566 switch (uri_type) {; 18567 case 1:; 18568 /* Asterisk */; 18569 conn->request_info.local_uri_raw = 0;; 18570 /* TODO: Deal with '*'. */; 18571 break;; 18572 case 2:; 18573 /* relative uri */; 18574 conn->request_info.local_uri_raw =; 18575 conn->request_info.request_uri;; 18576 break;; 18577 case 3:; 18578 case 4:; 18579 /* absolute uri (with/without port) */; 185",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:552062,Integrability,protocol,protocol,552062,"eal with '*'. */; 18571 break;; 18572 case 2:; 18573 /* relative uri */; 18574 conn->request_info.local_uri_raw =; 18575 conn->request_info.request_uri;; 18576 break;; 18577 case 3:; 18578 case 4:; 18579 /* absolute uri (with/without port) */; 18580 hostend = get_rel_url_at_current_server(; 18581 conn->request_info.request_uri, conn);; 18582 if (hostend) {; 18583 conn->request_info.local_uri_raw = hostend;; 18584 } else {; 18585 conn->request_info.local_uri_raw = NULL;; 18586 }; 18587 break;; 18588 default:; 18589 mg_snprintf(conn,; 18590 NULL, /* No truncation check for ebuf */; 18591 ebuf,; 18592 sizeof(ebuf),; 18593 ""Invalid URI"");; 18594 mg_send_http_error(conn, 400, ""%s"", ebuf);; 18595 conn->request_info.local_uri_raw = NULL;; 18596 break;; 18597 }; 18598 conn->request_info.local_uri =; 18599 (char *)conn->request_info.local_uri_raw;; 18600 }; 18601 ; 18602 if (ebuf[0] != '\0') {; 18603 conn->protocol_type = -1;; 18604 ; 18605 } else {; 18606 /* HTTP/1 allows protocol upgrade */; 18607 conn->protocol_type = should_switch_to_protocol(conn);; 18608 ; 18609 if (conn->protocol_type == PROTOCOL_TYPE_HTTP2) {; 18610 /* This will occur, if a HTTP/1.1 request should be upgraded; 18611 * to HTTP/2 - but not if HTTP/2 is negotiated using ALPN.; 18612 * Since most (all?) major browsers only support HTTP/2 using; 18613 * ALPN, this is hard to test and very low priority.; 18614 * Deactivate it (at least for now).; 18615 */; 18616 conn->protocol_type = PROTOCOL_TYPE_HTTP1;; 18617 }; 18618 }; 18619 ; 18620 DEBUG_TRACE(""http: %s, error: %s"",; 18621 (ri->http_version ? ri->http_version : ""none""),; 18622 (ebuf[0] ? ebuf : ""none""));; 18623 ; 18624 if (ebuf[0] == '\0') {; 18625 if (conn->request_info.local_uri) {; 18626 ; 18627 /* handle request to local server */; 18628 handle_request_stat_log(conn);; 18629 ; 18630 } else {; 18631 /* TODO: handle non-local request (PROXY) */; 18632 conn->must_close = 1;; 18633 }; 18634 } else {; 18635 conn->must_close = 1;; 18636 }; 18637 ; 18638 ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:563026,Integrability,protocol,protocol,563026,"ation that might be; 18891 * of interest to anyone observing a server status. */; 18892 conn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->phys_ctx);; 18893 if (conn->buf == NULL) {; 18894 mg_cry_ctx_internal(; 18895 ctx,; 18896 ""Out of memory: Cannot allocate buffer for worker %i"",; 18897 thread_index);; 18898 return;; 18899 }; 18900 conn->buf_size = (int)ctx->max_request_size;; 18901 ; 18902 conn->dom_ctx = &(ctx->dd); /* Use default domain and default host */; 18903 ; 18904 conn->tls_user_ptr = tls.user_ptr; /* store ptr for quick access */; 18905 ; 18906 conn->request_info.user_data = ctx->user_data;; 18907 /* Allocate a mutex for this connection to allow communication both; 18908 * within the request handler and from elsewhere in the application; 18909 */; 18910 if (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {; 18911 mg_free(conn->buf);; 18912 mg_cry_ctx_internal(ctx, ""%s"", ""Cannot create mutex"");; 18913 return;; 18914 }; 18915 ; 18916#if defined(USE_SERVER_STATS); 18917 conn->conn_state = 1; /* not consumed */; 18918#endif; 18919 ; 18920 /* Call consume_socket() even when ctx->stop_flag > 0, to let it; 18921 * signal sq_empty condvar to wake up the master waiting in; 18922 * produce_socket() */; 18923 while (consume_socket(ctx, &conn->client, thread_index)) {; 18924 ; 18925 /* New connections must start with new protocol negotiation */; 18926 tls.alpn_proto = NULL;; 18927 ; 18928#if defined(USE_SERVER_STATS); 18929 conn->conn_close_time = 0;; 18930#endif; 18931 conn->conn_birth_time = time(NULL);; 18932 ; 18933 /* Fill in IP, port info early so even if SSL setup below fails,; 18934 * error handler would have the corresponding info.; 18935 * Thanks to Johannes Winkelmann for the patch.; 18936 */; 18937 conn->request_info.remote_port =; 18938 ntohs(USA_IN_PORT_UNSAFE(&conn->client.rsa));; 18939 ; 18940 conn->request_info.server_port =; 18941 ntohs(USA_IN_PORT_UNSAFE(&conn->client.lsa));; 18942 ; 18943 sockaddr_to_string(conn->request",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:586299,Integrability,synchroniz,synchronization,586299,"9639 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19640 mg_snprintf(NULL,; 19641 NULL, /* No truncation check for error buffers */; 19642 error->text,; 19643 error->text_buffer_size,; 19644 ""%s"",; 19645 ""Library uninitialized"");; 19646 }; 19647 return NULL;; 19648 }; 19649 ; 19650 /* Allocate context and initialize reasonable general case defaults. */; 19651 if ((ctx = (struct mg_context *)mg_calloc(1, sizeof(*ctx))) == NULL) {; 19652 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19653 mg_snprintf(NULL,; 19654 NULL, /* No truncation check for error buffers */; 19655 error->text,; 19656 error->text_buffer_size,; 19657 ""%s"",; 19658 ""Out of memory"");; 19659 }; 19660 return NULL;; 19661 }; 19662 ; 19663 /* Random number generator will initialize at the first call */; 19664 ctx->dd.auth_nonce_mask =; 19665 (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);; 19666 ; 19667 /* Save started thread index to reuse in other external API calls; 19668 * For the sake of thread synchronization all non-civetweb threads; 19669 * can be considered as single external thread */; 19670 ctx->starter_thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);; 19671 tls.is_master = -1; /* Thread calling mg_start */; 19672 tls.thread_idx = ctx->starter_thread_idx;; 19673#if defined(_WIN32); 19674 tls.pthread_cond_helper_mutex = NULL;; 19675#endif; 19676 pthread_setspecific(sTlsKey, &tls);; 19677 ; 19678 ok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));; 19679#if !defined(ALTERNATIVE_QUEUE); 19680 ok &= (0 == pthread_cond_init(&ctx->sq_empty, NULL));; 19681 ok &= (0 == pthread_cond_init(&ctx->sq_full, NULL));; 19682 ctx->sq_blocked = 0;; 19683#endif; 19684 ok &= (0 == pthread_mutex_init(&ctx->nonce_mutex, &pthread_mutex_attr));; 19685#if defined(USE_LUA); 19686 ok &= (0 == pthread_mutex_init(&ctx->lua_bg_mutex, &pthread_mutex_attr));; 19687#endif; 19688 if (!ok) {; 19689 const char *err_msg =; 19690 ""Cannot initialize thread synchronization obje",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:587273,Integrability,synchroniz,synchronization,587273,"9659 }; 19660 return NULL;; 19661 }; 19662 ; 19663 /* Random number generator will initialize at the first call */; 19664 ctx->dd.auth_nonce_mask =; 19665 (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);; 19666 ; 19667 /* Save started thread index to reuse in other external API calls; 19668 * For the sake of thread synchronization all non-civetweb threads; 19669 * can be considered as single external thread */; 19670 ctx->starter_thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);; 19671 tls.is_master = -1; /* Thread calling mg_start */; 19672 tls.thread_idx = ctx->starter_thread_idx;; 19673#if defined(_WIN32); 19674 tls.pthread_cond_helper_mutex = NULL;; 19675#endif; 19676 pthread_setspecific(sTlsKey, &tls);; 19677 ; 19678 ok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));; 19679#if !defined(ALTERNATIVE_QUEUE); 19680 ok &= (0 == pthread_cond_init(&ctx->sq_empty, NULL));; 19681 ok &= (0 == pthread_cond_init(&ctx->sq_full, NULL));; 19682 ctx->sq_blocked = 0;; 19683#endif; 19684 ok &= (0 == pthread_mutex_init(&ctx->nonce_mutex, &pthread_mutex_attr));; 19685#if defined(USE_LUA); 19686 ok &= (0 == pthread_mutex_init(&ctx->lua_bg_mutex, &pthread_mutex_attr));; 19687#endif; 19688 if (!ok) {; 19689 const char *err_msg =; 19690 ""Cannot initialize thread synchronization objects"";; 19691 /* Fatal error - abort start. However, this situation should never; 19692 * occur in practice. */; 19693 ; 19694 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19695 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19696 mg_snprintf(NULL,; 19697 NULL, /* No truncation check for error buffers */; 19698 error->text,; 19699 error->text_buffer_size,; 19700 ""%s"",; 19701 err_msg);; 19702 }; 19703 ; 19704 mg_free(ctx);; 19705 pthread_setspecific(sTlsKey, NULL);; 19706 return NULL;; 19707 }; 19708 ; 19709 if ((init != NULL) && (init->callbacks != NULL)) {; 19710 /* Set all callbacks except exit_context. */; 19711 ctx->callbacks = *init->callbacks;; 19712 exit_callba",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:596501,Integrability,depend,depending,596501,"r, opt_vec.len) == 0); 19922 break;; 19923 }; 19924 lua_rawset(state, -3);; 19925 lua_pop(state, 1);; 19926 }; 19927 ; 19928 /* Call script */; 19929 state = mg_lua_context_script_run(state,; 19930 ctx->dd.config[LUA_BACKGROUND_SCRIPT],; 19931 ctx,; 19932 ebuf,; 19933 sizeof(ebuf));; 19934 if (!state) {; 19935 mg_cry_ctx_internal(ctx,; 19936 ""lua_background_script start error: %s"",; 19937 ebuf);; 19938 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19939 mg_snprintf(NULL,; 19940 NULL, /* No truncation check for error buffers */; 19941 error->text,; 19942 error->text_buffer_size,; 19943 ""Error in script %s: %s"",; 19944 config_options[DOCUMENT_ROOT].name,; 19945 ebuf);; 19946 }; 19947 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19948 ; 19949 free_context(ctx);; 19950 pthread_setspecific(sTlsKey, NULL);; 19951 return NULL;; 19952 }; 19953 ; 19954 /* state remains valid */; 19955 ctx->lua_background_state = (void *)state;; 19956 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19957 ; 19958 } else {; 19959 ctx->lua_background_state = 0;; 19960 }; 19961#endif; 19962 ; 19963 /* Step by step initialization of ctx - depending on build options */; 19964#if !defined(NO_FILESYSTEMS); 19965 if (!set_gpass_option(ctx, NULL)) {; 19966 const char *err_msg = ""Invalid global password file"";; 19967 /* Fatal error - abort start. */; 19968 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19969 ; 19970 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19971 mg_snprintf(NULL,; 19972 NULL, /* No truncation check for error buffers */; 19973 error->text,; 19974 error->text_buffer_size,; 19975 ""%s"",; 19976 err_msg);; 19977 }; 19978 free_context(ctx);; 19979 pthread_setspecific(sTlsKey, NULL);; 19980 return NULL;; 19981 }; 19982#endif; 19983 ; 19984#if defined(USE_MBEDTLS); 19985 if (!mg_sslctx_init(ctx, NULL)) {; 19986 const char *err_msg = ""Error initializing SSL context"";; 19987 /* Fatal error - abort start. */; 19988 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19989 ; 19990 if ((error !=",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:632766,Integrability,protocol,protocol,632766,"= &(conn->request_info);; 21172 ; 21173#if defined(USE_SERVER_STATS); 21174 state = conn->conn_state;; 21175 ; 21176 /* State as string */; 21177 switch (state) {; 21178 case 0:; 21179 state_str = ""undefined"";; 21180 break;; 21181 case 1:; 21182 state_str = ""not used"";; 21183 break;; 21184 case 2:; 21185 state_str = ""init"";; 21186 break;; 21187 case 3:; 21188 state_str = ""ready"";; 21189 break;; 21190 case 4:; 21191 state_str = ""processing"";; 21192 break;; 21193 case 5:; 21194 state_str = ""processed"";; 21195 break;; 21196 case 6:; 21197 state_str = ""to close"";; 21198 break;; 21199 case 7:; 21200 state_str = ""closing"";; 21201 break;; 21202 case 8:; 21203 state_str = ""closed"";; 21204 break;; 21205 case 9:; 21206 state_str = ""done"";; 21207 break;; 21208 }; 21209#endif; 21210 ; 21211 /* Connection info */; 21212 if ((state >= 3) && (state < 9)) {; 21213 mg_snprintf(NULL,; 21214 NULL,; 21215 block,; 21216 sizeof(block),; 21217 ""%s\""connection\"" : {%s""; 21218 ""\""remote\"" : {%s""; 21219 ""\""protocol\"" : \""%s\"",%s""; 21220 ""\""addr\"" : \""%s\"",%s""; 21221 ""\""port\"" : %u%s""; 21222 ""},%s""; 21223 ""\""handled_requests\"" : %u%s""; 21224 ""}"",; 21225 eol,; 21226 eol,; 21227 eol,; 21228 get_proto_name(conn),; 21229 eol,; 21230 ri->remote_addr,; 21231 eol,; 21232 ri->remote_port,; 21233 eol,; 21234 eol,; 21235 conn->handled_requests,; 21236 eol);; 21237 connection_info_length += mg_str_append(&buffer, end, block);; 21238 }; 21239 ; 21240 /* Request info */; 21241 if ((state >= 4) && (state < 6)) {; 21242 mg_snprintf(NULL,; 21243 NULL,; 21244 block,; 21245 sizeof(block),; 21246 ""%s%s\""request_info\"" : {%s""; 21247 ""\""method\"" : \""%s\"",%s""; 21248 ""\""uri\"" : \""%s\"",%s""; 21249 ""\""query\"" : %s%s%s%s""; 21250 ""}"",; 21251 (connection_info_length > 1 ? "","" : """"),; 21252 eol,; 21253 eol,; 21254 ri->request_method,; 21255 eol,; 21256 ri->request_uri,; 21257 eol,; 21258 ri->query_string ? ""\"""" : """",; 21259 ri->query_string ? ri->query_string : ""null"",; 21260 ri->query_string ? ""\"""" : """",; 21261 eol);; 212",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:700548,Integrability,message,message,700548,"sedsize_t bufusedDefinition civetweb.c:10960; cgi_environment::varusedsize_t varusedDefinition civetweb.c:10964; cgi_environment::connstruct mg_connection * connDefinition civetweb.c:10956; cgi_environment::buflensize_t buflenDefinition civetweb.c:10959; cgi_environment::varlensize_t varlenDefinition civetweb.c:10963; deDefinition civetweb.c:2540; de::file_namechar * file_nameDefinition civetweb.c:2542; de::connstruct mg_connection * connDefinition civetweb.c:2541; de::filestruct mg_file_stat fileDefinition civetweb.c:2543; dir_scan_dataDefinition civetweb.c:9576; dir_scan_data::num_entriessize_t num_entriesDefinition civetweb.c:9578; dir_scan_data::entriesstruct de * entriesDefinition civetweb.c:9577; dir_scan_data::arr_sizesize_t arr_sizeDefinition civetweb.c:9579; md5_state_sDefinition md5.inl:54; mg_callbacksDefinition civetweb.h:218; mg_callbacks::init_sslint(* init_ssl)(void *ssl_ctx, void *user_data)Definition civetweb.h:254; mg_callbacks::log_messageint(* log_message)(const struct mg_connection *, const char *message)Definition civetweb.h:240; mg_callbacks::init_threadvoid *(* init_thread)(const struct mg_context *ctx, int thread_type)Definition civetweb.h:393; mg_callbacks::end_requestvoid(* end_request)(const struct mg_connection *, int reply_status_code)Definition civetweb.h:236; mg_callbacks::init_connectionint(* init_connection)(const struct mg_connection *conn, void **conn_data)Definition civetweb.h:417; mg_callbacks::connection_closevoid(* connection_close)(const struct mg_connection *)Definition civetweb.h:320; mg_callbacks::http_errorint(* http_error)(struct mg_connection *conn, int status, const char *errmsg)Definition civetweb.h:359; mg_callbacks::exit_contextvoid(* exit_context)(const struct mg_context *ctx)Definition civetweb.h:372; mg_callbacks::init_ssl_domainint(* init_ssl_domain)(const char *server_domain, void *ssl_ctx, void *user_data)Definition civetweb.h:265; mg_callbacks::external_ssl_ctxint(* external_ssl_ctx)(void **ssl_ctx, void *user",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:701871,Integrability,message,message,701871,"::init_connectionint(* init_connection)(const struct mg_connection *conn, void **conn_data)Definition civetweb.h:417; mg_callbacks::connection_closevoid(* connection_close)(const struct mg_connection *)Definition civetweb.h:320; mg_callbacks::http_errorint(* http_error)(struct mg_connection *conn, int status, const char *errmsg)Definition civetweb.h:359; mg_callbacks::exit_contextvoid(* exit_context)(const struct mg_context *ctx)Definition civetweb.h:372; mg_callbacks::init_ssl_domainint(* init_ssl_domain)(const char *server_domain, void *ssl_ctx, void *user_data)Definition civetweb.h:265; mg_callbacks::external_ssl_ctxint(* external_ssl_ctx)(void **ssl_ctx, void *user_data)Definition civetweb.h:278; mg_callbacks::exit_threadvoid(* exit_thread)(const struct mg_context *ctx, int thread_type, void *thread_pointer)Definition civetweb.h:400; mg_callbacks::begin_requestint(* begin_request)(struct mg_connection *)Definition civetweb.h:233; mg_callbacks::log_accessint(* log_access)(const struct mg_connection *, const char *message)Definition civetweb.h:244; mg_callbacks::init_contextvoid(* init_context)(const struct mg_context *ctx)Definition civetweb.h:367; mg_callbacks::connection_closedvoid(* connection_closed)(const struct mg_connection *)Definition civetweb.h:330; mg_callbacks::external_ssl_ctx_domainint(* external_ssl_ctx_domain)(const char *server_domain, void **ssl_ctx, void *user_data)Definition civetweb.h:290; mg_client_certDefinition civetweb.h:206; mg_client_cert::issuerconst char * issuerDefinition civetweb.h:209; mg_client_cert::fingerconst char * fingerDefinition civetweb.h:211; mg_client_cert::peer_certvoid * peer_certDefinition civetweb.h:207; mg_client_cert::subjectconst char * subjectDefinition civetweb.h:208; mg_client_cert::serialconst char * serialDefinition civetweb.h:210; mg_client_optionsDefinition civetweb.h:1433; mg_client_options::host_nameconst char * host_nameDefinition civetweb.h:1438; mg_client_options::client_certconst char * client_certDefi",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:713167,Integrability,protocol,protocolint,713167,tion civetweb.h:152; mg_request_info::acceptedWebSocketSubprotocolconst char * acceptedWebSocketSubprotocolDefinition civetweb.h:184; mg_request_info::remote_userconst char * remote_userDefinition civetweb.h:164; mg_request_info::remote_portint remote_portDefinition civetweb.h:170; mg_request_info::is_sslint is_sslDefinition civetweb.h:173; mg_request_info::num_headersint num_headersDefinition civetweb.h:178; mg_response_infoDefinition civetweb.h:191; mg_response_info::http_headersstruct mg_header http_headers[(64)]Definition civetweb.h:200; mg_response_info::content_lengthlong long content_lengthDefinition civetweb.h:196; mg_response_info::http_versionconst char * http_versionDefinition civetweb.h:194; mg_response_info::num_headersint num_headersDefinition civetweb.h:199; mg_response_info::status_codeint status_codeDefinition civetweb.h:192; mg_response_info::status_textconst char * status_textDefinition civetweb.h:193; mg_server_portDefinition civetweb.h:712; mg_server_port::protocolint protocolDefinition civetweb.h:713; mg_server_port::is_redirectint is_redirectDefinition civetweb.h:716; mg_server_port::portint portDefinition civetweb.h:714; mg_server_port::is_sslint is_sslDefinition civetweb.h:715; mg_websocket_subprotocolsDefinition civetweb.h:562; mg_websocket_subprotocols::subprotocolsconst char ** subprotocolsDefinition civetweb.h:564; mg_websocket_subprotocols::nb_subprotocolsint nb_subprotocolsDefinition civetweb.h:563; mg_workerTLSDefinition civetweb.c:1579; mg_workerTLS::user_ptrvoid * user_ptrDefinition civetweb.c:1582; mg_workerTLS::alpn_protoconst char * alpn_protoDefinition civetweb.c:1587; mg_workerTLS::is_masterint is_masterDefinition civetweb.c:1580; mg_workerTLS::thread_idxunsigned long thread_idxDefinition civetweb.c:1581; passwdDefinition TWinNTSystem.h:38; passwd::pw_gidint pw_gidDefinition TWinNTSystem.h:42; passwd::pw_uidint pw_uidDefinition TWinNTSystem.h:41; process_control_dataDefinition civetweb.c:11237; process_control_data::referencespt,MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:713179,Integrability,protocol,protocolDefinition,713179,tion civetweb.h:152; mg_request_info::acceptedWebSocketSubprotocolconst char * acceptedWebSocketSubprotocolDefinition civetweb.h:184; mg_request_info::remote_userconst char * remote_userDefinition civetweb.h:164; mg_request_info::remote_portint remote_portDefinition civetweb.h:170; mg_request_info::is_sslint is_sslDefinition civetweb.h:173; mg_request_info::num_headersint num_headersDefinition civetweb.h:178; mg_response_infoDefinition civetweb.h:191; mg_response_info::http_headersstruct mg_header http_headers[(64)]Definition civetweb.h:200; mg_response_info::content_lengthlong long content_lengthDefinition civetweb.h:196; mg_response_info::http_versionconst char * http_versionDefinition civetweb.h:194; mg_response_info::num_headersint num_headersDefinition civetweb.h:199; mg_response_info::status_codeint status_codeDefinition civetweb.h:192; mg_response_info::status_textconst char * status_textDefinition civetweb.h:193; mg_server_portDefinition civetweb.h:712; mg_server_port::protocolint protocolDefinition civetweb.h:713; mg_server_port::is_redirectint is_redirectDefinition civetweb.h:716; mg_server_port::portint portDefinition civetweb.h:714; mg_server_port::is_sslint is_sslDefinition civetweb.h:715; mg_websocket_subprotocolsDefinition civetweb.h:562; mg_websocket_subprotocols::subprotocolsconst char ** subprotocolsDefinition civetweb.h:564; mg_websocket_subprotocols::nb_subprotocolsint nb_subprotocolsDefinition civetweb.h:563; mg_workerTLSDefinition civetweb.c:1579; mg_workerTLS::user_ptrvoid * user_ptrDefinition civetweb.c:1582; mg_workerTLS::alpn_protoconst char * alpn_protoDefinition civetweb.c:1587; mg_workerTLS::is_masterint is_masterDefinition civetweb.c:1580; mg_workerTLS::thread_idxunsigned long thread_idxDefinition civetweb.c:1581; passwdDefinition TWinNTSystem.h:38; passwd::pw_gidint pw_gidDefinition TWinNTSystem.h:42; passwd::pw_uidint pw_uidDefinition TWinNTSystem.h:41; process_control_dataDefinition civetweb.c:11237; process_control_data::referencespt,MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:5692,Modifiability,config,configuration,5692,"18#if defined(__STDC_VERSION__) && __STDC_VERSION__ > 201100L; 119#define mg_static_assert _Static_assert; 120#elif defined(__cplusplus) && __cplusplus >= 201103L; 121#define mg_static_assert static_assert; 122#else; 123char static_assert_replacement[1];; 124#define mg_static_assert(cond, txt) \; 125 extern char static_assert_replacement[(cond) ? 1 : -1]; 126#endif; 127 ; 128mg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,; 129 ""int data type size check"");; 130mg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,; 131 ""pointer data type size check"");; 132mg_static_assert(sizeof(void *) >= sizeof(int), ""data type size check"");; 133 ; 134 ; 135/* Select queue implementation. Diagnosis features originally only implemented; 136 * for the ""ALTERNATIVE_QUEUE"" have been ported to the previous queue; 137 * implementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping be",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:12089,Modifiability,config,configuration,12089,"with __attribute__((unused)).; 302 * On the other hand, if the function is marked with this attribute,; 303 * but is used, the compiler raises a completely idiotic; 304 * ""used-but-marked-unused"" warning - and; 305 * #pragma GCC diagnostic ignored ""-Wused-but-marked-unused""; 306 * raises error: unknown option after ""#pragma GCC diagnostic"".; 307 * Disable this warning completely, until the GCC guys sober up; 308 * again.; 309 */; 310 ; 311#pragma GCC diagnostic ignored ""-Wunused-function""; 312 ; 313#define FUNCTION_MAY_BE_UNUSED /* __attribute__((unused)) */; 314 ; 315#else; 316#define FUNCTION_MAY_BE_UNUSED; 317#endif; 318 ; 319 ; 320/* Some ANSI #includes are not available on Windows CE and Zephyr */; 321#if !defined(_WIN32_WCE) && !defined(__ZEPHYR__); 322#include <errno.h>; 323#include <fcntl.h>; 324#include <signal.h>; 325#include <stdlib.h>; 326#include <sys/stat.h>; 327#include <sys/types.h>; 328#endif /* !_WIN32_WCE */; 329 ; 330 ; 331#if defined(__clang__); 332/* When using -Weverything, clang does not accept it's own headers; 333 * in a release build configuration. Disable what is too much in; 334 * -Weverything. */; 335#pragma clang diagnostic ignored ""-Wdisabled-macro-expansion""; 336#endif; 337 ; 338#if defined(__GNUC__) || defined(__MINGW32__); 339/* Who on earth came to the conclusion, using __DATE__ should rise; 340 * an ""expansion of date or time macro is not reproducible""; 341 * warning. That's exactly what was intended by using this macro.; 342 * Just disable this nonsense warning. */; 343 ; 344/* And disabling them does not work either:; 345 * #pragma clang diagnostic ignored ""-Wno-error=date-time""; 346 * #pragma clang diagnostic ignored ""-Wdate-time""; 347 * So we just have to disable ALL warnings for some lines; 348 * of code.; 349 * This seems to be a known GCC bug, not resolved since 2012:; 350 * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53431; 351 */; 352#endif; 353 ; 354 ; 355#if defined(__MACH__) /* Apple OSX section */; 356 ; 357#if defi",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:14419,Modifiability,variab,variable,14419,"-macro""; 362#endif; 363#endif; 364 ; 365#ifndef CLOCK_MONOTONIC; 366#define CLOCK_MONOTONIC (1); 367#endif; 368#ifndef CLOCK_REALTIME; 369#define CLOCK_REALTIME (2); 370#endif; 371 ; 372#include <mach/clock.h>; 373#include <mach/mach.h>; 374#include <mach/mach_time.h>; 375#include <sys/errno.h>; 376#include <sys/time.h>; 377 ; 378/* clock_gettime is not implemented on OSX prior to 10.12 */; 379static int; 380_civet_clock_gettime(int clk_id, struct timespec *t); 381{; 382 memset(t, 0, sizeof(*t));; 383 if (clk_id == CLOCK_REALTIME) {; 384 struct timeval now;; 385 int rv = gettimeofday(&now, NULL);; 386 if (rv) {; 387 return rv;; 388 }; 389 t->tv_sec = now.tv_sec;; 390 t->tv_nsec = now.tv_usec * 1000;; 391 return 0;; 392 ; 393 } else if (clk_id == CLOCK_MONOTONIC) {; 394 static uint64_t clock_start_time = 0;; 395 static mach_timebase_info_data_t timebase_ifo = {0, 0};; 396 ; 397 uint64_t now = mach_absolute_time();; 398 ; 399 if (clock_start_time == 0) {; 400 kern_return_t mach_status = mach_timebase_info(&timebase_ifo);; 401 DEBUG_ASSERT(mach_status == KERN_SUCCESS);; 402 ; 403 /* appease ""unused variable"" warning for release builds */; 404 (void)mach_status;; 405 ; 406 clock_start_time = now;; 407 }; 408 ; 409 now = (uint64_t)((double)(now - clock_start_time); 410 * (double)timebase_ifo.numer; 411 / (double)timebase_ifo.denom);; 412 ; 413 t->tv_sec = now / 1000000000;; 414 t->tv_nsec = now % 1000000000;; 415 return 0;; 416 }; 417 return -1; /* EINVAL - Clock ID is unknown */; 418}; 419 ; 420/* if clock_gettime is declared, then __CLOCK_AVAILABILITY will be defined */; 421#if defined(__CLOCK_AVAILABILITY); 422/* If we compiled with Mac OSX 10.12 or later, then clock_gettime will be; 423 * declared but it may be NULL at runtime. So we need to check before using; 424 * it. */; 425static int; 426_civet_safe_clock_gettime(int clk_id, struct timespec *t); 427{; 428 if (clock_gettime) {; 429 return clock_gettime(clk_id, t);; 430 }; 431 return _civet_clock_gettime(clk_id, t)",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:16027,Modifiability,config,configuration,16027,"L at runtime. So we need to check before using; 424 * it. */; 425static int; 426_civet_safe_clock_gettime(int clk_id, struct timespec *t); 427{; 428 if (clock_gettime) {; 429 return clock_gettime(clk_id, t);; 430 }; 431 return _civet_clock_gettime(clk_id, t);; 432}; 433#define clock_gettime _civet_safe_clock_gettime; 434#else; 435#define clock_gettime _civet_clock_gettime; 436#endif; 437 ; 438#endif; 439 ; 440 ; 441#if !defined(_WIN32); 442/* Unix might return different error codes indicating to try again.; 443 * For Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; 444 * decades ago, but better check both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_N",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:16178,Modifiability,config,configured,16178,"L at runtime. So we need to check before using; 424 * it. */; 425static int; 426_civet_safe_clock_gettime(int clk_id, struct timespec *t); 427{; 428 if (clock_gettime) {; 429 return clock_gettime(clk_id, t);; 430 }; 431 return _civet_clock_gettime(clk_id, t);; 432}; 433#define clock_gettime _civet_safe_clock_gettime; 434#else; 435#define clock_gettime _civet_clock_gettime; 436#endif; 437 ; 438#endif; 439 ; 440 ; 441#if !defined(_WIN32); 442/* Unix might return different error codes indicating to try again.; 443 * For Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; 444 * decades ago, but better check both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_N",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:16272,Modifiability,config,configuration,16272," 430 }; 431 return _civet_clock_gettime(clk_id, t);; 432}; 433#define clock_gettime _civet_safe_clock_gettime; 434#else; 435#define clock_gettime _civet_clock_gettime; 436#endif; 437 ; 438#endif; 439 ; 440 ; 441#if !defined(_WIN32); 442/* Unix might return different error codes indicating to try again.; 443 * For Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; 444 * decades ago, but better check both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#i",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:16543,Modifiability,config,configuration,16543,"Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; 444 * decades ago, but better check both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#if !defined(CGI_ENVIRONMENT_SIZE); 486#define CGI_ENVIRONMENT_SIZE (4096) /* in bytes */; 487#endif; 488 ; 489/* Maximum number of environment variables. */; 490#if !defined(MAX_CGI_ENVIR_VARS); 491#define MAX_CGI_ENVIR_VARS (256) /* in variables (count) */; 492#endif; 493 ; 494/* General purpose buffer size. */; 49",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:17167,Modifiability,variab,variables,17167," 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#if !defined(CGI_ENVIRONMENT_SIZE); 486#define CGI_ENVIRONMENT_SIZE (4096) /* in bytes */; 487#endif; 488 ; 489/* Maximum number of environment variables. */; 490#if !defined(MAX_CGI_ENVIR_VARS); 491#define MAX_CGI_ENVIR_VARS (256) /* in variables (count) */; 492#endif; 493 ; 494/* General purpose buffer size. */; 495#if !defined(MG_BUF_LEN) /* in bytes */; 496#define MG_BUF_LEN (1024 * 8); 497#endif; 498 ; 499 ; 500/********************************************************************/; 501 ; 502/* Helper makros */; 503#if !defined(ARRAY_SIZE); 504#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0])); 505#endif; 506 ; 507#include <stdint.h>; 508 ; 509/* Standard defines */; 510#if !defined(INT64_MAX); 511#define INT64_MAX (9223372036854775807); 512#endif; 513 ; 514#define SHUTDOWN_RD (0); 515#define SHUTDOWN_WR (1); 516#define SHUTDOWN_BOTH (2); 517 ; 518mg_s",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:17399,Modifiability,variab,variables,17399,"; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#if !defined(CGI_ENVIRONMENT_SIZE); 486#define CGI_ENVIRONMENT_SIZE (4096) /* in bytes */; 487#endif; 488 ; 489/* Maximum number of environment variables. */; 490#if !defined(MAX_CGI_ENVIR_VARS); 491#define MAX_CGI_ENVIR_VARS (256) /* in variables (count) */; 492#endif; 493 ; 494/* General purpose buffer size. */; 495#if !defined(MG_BUF_LEN) /* in bytes */; 496#define MG_BUF_LEN (1024 * 8); 497#endif; 498 ; 499 ; 500/********************************************************************/; 501 ; 502/* Helper makros */; 503#if !defined(ARRAY_SIZE); 504#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0])); 505#endif; 506 ; 507#include <stdint.h>; 508 ; 509/* Standard defines */; 510#if !defined(INT64_MAX); 511#define INT64_MAX (9223372036854775807); 512#endif; 513 ; 514#define SHUTDOWN_RD (0); 515#define SHUTDOWN_WR (1); 516#define SHUTDOWN_BOTH (2); 517 ; 518mg_static_assert(MAX_WORKER_THREADS >= 1,; 519 ""worker threads must be a positive number"");; 520 ; 521mg_static_assert(sizeof(size_t) == 4 || sizeof(size_t) == 8,; 522 ""size_t data type size check"");",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:17493,Modifiability,variab,variables,17493,"oll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#if !defined(CGI_ENVIRONMENT_SIZE); 486#define CGI_ENVIRONMENT_SIZE (4096) /* in bytes */; 487#endif; 488 ; 489/* Maximum number of environment variables. */; 490#if !defined(MAX_CGI_ENVIR_VARS); 491#define MAX_CGI_ENVIR_VARS (256) /* in variables (count) */; 492#endif; 493 ; 494/* General purpose buffer size. */; 495#if !defined(MG_BUF_LEN) /* in bytes */; 496#define MG_BUF_LEN (1024 * 8); 497#endif; 498 ; 499 ; 500/********************************************************************/; 501 ; 502/* Helper makros */; 503#if !defined(ARRAY_SIZE); 504#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0])); 505#endif; 506 ; 507#include <stdint.h>; 508 ; 509/* Standard defines */; 510#if !defined(INT64_MAX); 511#define INT64_MAX (9223372036854775807); 512#endif; 513 ; 514#define SHUTDOWN_RD (0); 515#define SHUTDOWN_WR (1); 516#define SHUTDOWN_BOTH (2); 517 ; 518mg_static_assert(MAX_WORKER_THREADS >= 1,; 519 ""worker threads must be a positive number"");; 520 ; 521mg_static_assert(sizeof(size_t) == 4 || sizeof(size_t) == 8,; 522 ""size_t data type size check"");; 523 ; 524 ; 525#if defined(_WIN32) /* WINDOWS include block */; 526#include <malloc.h> /* *alloc( */; 527#include <stdlib.h> /* *alloc( */; 528#include <time.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:61388,Modifiability,config,config,61388,"defined(USE_TIMERS); 1963 CGI2_TIMEOUT,; 1964#endif; 1965 ; 1966#if defined(USE_4_CGI); 1967 CGI3_EXTENSIONS,; 1968 CGI3_ENVIRONMENT,; 1969 CGI3_INTERPRETER,; 1970 CGI3_INTERPRETER_ARGS,; 1971#if defined(USE_TIMERS); 1972 CGI3_TIMEOUT,; 1973#endif; 1974 ; 1975 CGI4_EXTENSIONS,; 1976 CGI4_ENVIRONMENT,; 1977 CGI4_INTERPRETER,; 1978 CGI4_INTERPRETER_ARGS,; 1979#if defined(USE_TIMERS); 1980 CGI4_TIMEOUT,; 1981#endif; 1982#endif; 1983 ; 1984 PUT_DELETE_PASSWORDS_FILE, /* must follow CGI_* */; 1985 PROTECT_URI,; 1986 AUTHENTICATION_DOMAIN,; 1987 ENABLE_AUTH_DOMAIN_CHECK,; 1988 SSI_EXTENSIONS,; 1989 ENABLE_DIRECTORY_LISTING,; 1990 GLOBAL_PASSWORDS_FILE,; 1991 INDEX_FILES,; 1992 ACCESS_CONTROL_LIST,; 1993 EXTRA_MIME_TYPES,; 1994 SSL_CERTIFICATE,; 1995 SSL_CERTIFICATE_CHAIN,; 1996 URL_REWRITE_PATTERN,; 1997 HIDE_FILES,; 1998 SSL_DO_VERIFY_PEER,; 1999 SSL_CACHE_TIMEOUT,; 2000 SSL_CA_PATH,; 2001 SSL_CA_FILE,; 2002 SSL_VERIFY_DEPTH,; 2003 SSL_DEFAULT_VERIFY_PATHS,; 2004 SSL_CIPHER_LIST,; 2005 SSL_PROTOCOL_VERSION,; 2006 SSL_SHORT_TRUST,; 2007 ; 2008#if defined(USE_LUA); 2009 LUA_PRELOAD_FILE,; 2010 LUA_SCRIPT_EXTENSIONS,; 2011 LUA_SERVER_PAGE_EXTENSIONS,; 2012#if defined(MG_EXPERIMENTAL_INTERFACES); 2013 LUA_DEBUG_PARAMS,; 2014#endif; 2015#endif; 2016#if defined(USE_DUKTAPE); 2017 DUKTAPE_SCRIPT_EXTENSIONS,; 2018#endif; 2019 ; 2020#if defined(USE_WEBSOCKET); 2021 WEBSOCKET_ROOT,; 2022#endif; 2023#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2024 LUA_WEBSOCKET_EXTENSIONS,; 2025#endif; 2026 ; 2027 ACCESS_CONTROL_ALLOW_ORIGIN,; 2028 ACCESS_CONTROL_ALLOW_METHODS,; 2029 ACCESS_CONTROL_ALLOW_HEADERS,; 2030 ACCESS_CONTROL_ALLOW_CREDENTIALS,; 2031 ERROR_PAGES,; 2032#if !defined(NO_CACHING); 2033 STATIC_FILE_MAX_AGE,; 2034 STATIC_FILE_CACHE_CONTROL,; 2035#endif; 2036#if !defined(NO_SSL); 2037 STRICT_HTTPS_MAX_AGE,; 2038#endif; 2039 ADDITIONAL_HEADER,; 2040 ALLOW_INDEX_SCRIPT_SUB_RES,; 2041 ; 2042 NUM_OPTIONS; 2043};; 2044 ; 2045 ; 2046/* Config option name, config types, default value.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:66908,Modifiability,config,config,66908,"2149 ; 2150 {""ssl_ca_path"", MG_CONFIG_TYPE_DIRECTORY, NULL},; 2151 {""ssl_ca_file"", MG_CONFIG_TYPE_FILE, NULL},; 2152 {""ssl_verify_depth"", MG_CONFIG_TYPE_NUMBER, ""9""},; 2153 {""ssl_default_verify_paths"", MG_CONFIG_TYPE_BOOLEAN, ""yes""},; 2154 {""ssl_cipher_list"", MG_CONFIG_TYPE_STRING, NULL},; 2155 ; 2156 /* HTTP2 requires ALPN, and anyway TLS1.2 should be considered; 2157 * as a minimum in 2020 */; 2158 {""ssl_protocol_version"", MG_CONFIG_TYPE_NUMBER, ""4""},; 2159 ; 2160 {""ssl_short_trust"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2161 ; 2162#if defined(USE_LUA); 2163 {""lua_preload_file"", MG_CONFIG_TYPE_FILE, NULL},; 2164 {""lua_script_pattern"", MG_CONFIG_TYPE_EXT_PATTERN, ""**.lua$""},; 2165 {""lua_server_page_pattern"", MG_CONFIG_TYPE_EXT_PATTERN, ""**.lp$|**.lsp$""},; 2166#if defined(MG_EXPERIMENTAL_INTERFACES); 2167 {""lua_debug"", MG_CONFIG_TYPE_STRING, NULL},; 2168#endif; 2169#endif; 2170#if defined(USE_DUKTAPE); 2171 /* The support for duktape is still in alpha version state.; 2172 * The name of this config option might change. */; 2173 {""duktape_script_pattern"", MG_CONFIG_TYPE_EXT_PATTERN, ""**.ssjs$""},; 2174#endif; 2175 ; 2176#if defined(USE_WEBSOCKET); 2177 {""websocket_root"", MG_CONFIG_TYPE_DIRECTORY, NULL},; 2178#endif; 2179#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2180 {""lua_websocket_pattern"", MG_CONFIG_TYPE_EXT_PATTERN, ""**.lua$""},; 2181#endif; 2182 {""access_control_allow_origin"", MG_CONFIG_TYPE_STRING, ""*""},; 2183 {""access_control_allow_methods"", MG_CONFIG_TYPE_STRING, ""*""},; 2184 {""access_control_allow_headers"", MG_CONFIG_TYPE_STRING, ""*""},; 2185 {""access_control_allow_credentials"", MG_CONFIG_TYPE_STRING, """"},; 2186 {""error_pages"", MG_CONFIG_TYPE_DIRECTORY, NULL},; 2187#if !defined(NO_CACHING); 2188 {""static_file_max_age"", MG_CONFIG_TYPE_NUMBER, ""3600""},; 2189 {""static_file_cache_control"", MG_CONFIG_TYPE_STRING, NULL},; 2190#endif; 2191#if !defined(NO_SSL); 2192 {""strict_transport_security_max_age"", MG_CONFIG_TYPE_NUMBER, NULL},; 2193#endif; 2194 {""additional_header"", ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:69613,Modifiability,config,config,69613,"equests. */; 2224 mg_websocket_connect_handler connect_handler;; 2225 mg_websocket_ready_handler ready_handler;; 2226 mg_websocket_data_handler data_handler;; 2227 mg_websocket_close_handler close_handler;; 2228 ; 2229 /* accepted subprotocols for ws/wss requests. */; 2230 struct mg_websocket_subprotocols *subprotocols;; 2231 ; 2232 /* Handler for authorization requests */; 2233 mg_authorization_handler auth_handler;; 2234 ; 2235 /* User supplied argument for the handler function. */; 2236 void *cbdata;; 2237 ; 2238 /* next handler in a linked list */; 2239 struct mg_handler_info *next;; 2240};; 2241 ; 2242 ; 2243enum {; 2244 CONTEXT_INVALID,; 2245 CONTEXT_SERVER,; 2246 CONTEXT_HTTP_CLIENT,; 2247 CONTEXT_WS_CLIENT; 2248};; 2249 ; 2250 ; 2251struct mg_domain_context {; 2252 SSL_CTX *ssl_ctx; /* SSL context */; 2253 char *config[NUM_OPTIONS]; /* Civetweb configuration parameters */; 2254 struct mg_handler_info *handlers; /* linked list of uri handlers */; 2255 int64_t ssl_cert_last_mtime;; 2256 ; 2257 /* Server nonce */; 2258 uint64_t auth_nonce_mask; /* Mask for all nonce values */; 2259 unsigned long nonce_count; /* Used nonces, used for authentication */; 2260 ; 2261#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2262 /* linked list of shared lua websockets */; 2263 struct mg_shared_lua_websocket_list *shared_lua_websockets;; 2264#endif; 2265 ; 2266 /* Linked list of domains */; 2267 struct mg_domain_context *next;; 2268};; 2269 ; 2270 ; 2271/* Stop flag can be ""volatile"" or require a lock.; 2272 * MSDN uses volatile for ""Interlocked"" operations, but also explicitly; 2273 * states a read operation for int is always atomic. */; 2274#if defined(STOP_FLAG_NEEDS_LOCK); 2275 ; 2276typedef ptrdiff_t volatile stop_flag_t;; 2277 ; 2278static int; 2279STOP_FLAG_IS_ZERO(stop_flag_t *f); 2280{; 2281 stop_flag_t sf = mg_atomic_add(f, 0);; 2282 return (sf == 0);; 2283}; 2284 ; 2285static int; 2286STOP_FLAG_IS_TWO(stop_flag_t *f); 2287{; 2288 stop_flag_t sf = mg_atomic_add(f, 0);",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:69646,Modifiability,config,configuration,69646,"equests. */; 2224 mg_websocket_connect_handler connect_handler;; 2225 mg_websocket_ready_handler ready_handler;; 2226 mg_websocket_data_handler data_handler;; 2227 mg_websocket_close_handler close_handler;; 2228 ; 2229 /* accepted subprotocols for ws/wss requests. */; 2230 struct mg_websocket_subprotocols *subprotocols;; 2231 ; 2232 /* Handler for authorization requests */; 2233 mg_authorization_handler auth_handler;; 2234 ; 2235 /* User supplied argument for the handler function. */; 2236 void *cbdata;; 2237 ; 2238 /* next handler in a linked list */; 2239 struct mg_handler_info *next;; 2240};; 2241 ; 2242 ; 2243enum {; 2244 CONTEXT_INVALID,; 2245 CONTEXT_SERVER,; 2246 CONTEXT_HTTP_CLIENT,; 2247 CONTEXT_WS_CLIENT; 2248};; 2249 ; 2250 ; 2251struct mg_domain_context {; 2252 SSL_CTX *ssl_ctx; /* SSL context */; 2253 char *config[NUM_OPTIONS]; /* Civetweb configuration parameters */; 2254 struct mg_handler_info *handlers; /* linked list of uri handlers */; 2255 int64_t ssl_cert_last_mtime;; 2256 ; 2257 /* Server nonce */; 2258 uint64_t auth_nonce_mask; /* Mask for all nonce values */; 2259 unsigned long nonce_count; /* Used nonces, used for authentication */; 2260 ; 2261#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2262 /* linked list of shared lua websockets */; 2263 struct mg_shared_lua_websocket_list *shared_lua_websockets;; 2264#endif; 2265 ; 2266 /* Linked list of domains */; 2267 struct mg_domain_context *next;; 2268};; 2269 ; 2270 ; 2271/* Stop flag can be ""volatile"" or require a lock.; 2272 * MSDN uses volatile for ""Interlocked"" operations, but also explicitly; 2273 * states a read operation for int is always atomic. */; 2274#if defined(STOP_FLAG_NEEDS_LOCK); 2275 ; 2276typedef ptrdiff_t volatile stop_flag_t;; 2277 ; 2278static int; 2279STOP_FLAG_IS_ZERO(stop_flag_t *f); 2280{; 2281 stop_flag_t sf = mg_atomic_add(f, 0);; 2282 return (sf == 0);; 2283}; 2284 ; 2285static int; 2286STOP_FLAG_IS_TWO(stop_flag_t *f); 2287{; 2288 stop_flag_t sf = mg_atomic_add(f, 0);",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:72477,Modifiability,config,configured,72477,"2299}; 2300 ; 2301#else /* STOP_FLAG_NEEDS_LOCK */; 2302 ; 2303typedef int volatile stop_flag_t;; 2304#define STOP_FLAG_IS_ZERO(f) ((*(f)) == 0); 2305#define STOP_FLAG_IS_TWO(f) ((*(f)) == 2); 2306#define STOP_FLAG_ASSIGN(f, v) ((*(f)) = (v)); 2307 ; 2308#endif /* STOP_FLAG_NEEDS_LOCK */; 2309 ; 2310 ; 2311struct mg_context {; 2312 ; 2313 /* Part 1 - Physical context:; 2314 * This holds threads, ports, timeouts, ...; 2315 * set for the entire server, independent from the; 2316 * addressed hostname.; 2317 */; 2318 ; 2319 /* Connection related */; 2320 int context_type; /* See CONTEXT_* above */; 2321 ; 2322 struct socket *listening_sockets;; 2323 struct mg_pollfd *listening_socket_fds;; 2324 unsigned int num_listening_sockets;; 2325 ; 2326 struct mg_connection *worker_connections; /* The connection struct, pre-; 2327 * allocated for each worker */; 2328 ; 2329#if defined(USE_SERVER_STATS); 2330 volatile ptrdiff_t active_connections;; 2331 volatile ptrdiff_t max_active_connections;; 2332 volatile ptrdiff_t total_connections;; 2333 volatile ptrdiff_t total_requests;; 2334 volatile int64_t total_data_read;; 2335 volatile int64_t total_data_written;; 2336#endif; 2337 ; 2338 /* Thread related */; 2339 stop_flag_t stop_flag; /* Should we stop event loop */; 2340 pthread_mutex_t thread_mutex; /* Protects client_socks or queue */; 2341 ; 2342 pthread_t masterthreadid; /* The master thread ID */; 2343 unsigned int; 2344 cfg_worker_threads; /* The number of configured worker threads. */; 2345 pthread_t *worker_threadids; /* The worker thread IDs */; 2346 unsigned long starter_thread_idx; /* thread index which called mg_start */; 2347 ; 2348 /* Connection to thread dispatching */; 2349#if defined(ALTERNATIVE_QUEUE); 2350 struct socket *client_socks;; 2351 void **client_wait_events;; 2352#else; 2353 struct socket *squeue; /* Socket queue (sq) : accepted sockets waiting for a; 2354 worker thread */; 2355 volatile int sq_head; /* Head of the socket queue */; 2356 volatile int sq_t",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:94288,Modifiability,config,config,94288,"runcating vsnprintf buffer: [%.*s]"",; 3098 (int)((buflen > 200) ? 200 : (buflen - 1)),; 3099 buf);; 3100 n = (int)buflen - 1;; 3101 }; 3102 buf[n] = '\0';; 3103}; 3104 ; 3105 ; 3106static void; 3107mg_snprintf(const struct mg_connection *conn,; 3108 int *truncated,; 3109 char *buf,; 3110 size_t buflen,; 3111 const char *fmt,; 3112 ...); 3113{; 3114 va_list ap;; 3115 ; 3116 va_start(ap, fmt);; 3117 mg_vsnprintf(conn, truncated, buf, buflen, fmt, ap);; 3118 va_end(ap);; 3119}; 3120 ; 3121 ; 3122static int; 3123get_option_index(const char *name); 3124{; 3125 int i;; 3126 ; 3127 for (i = 0; config_options[i].name != NULL; i++) {; 3128 if (strcmp(config_options[i].name, name) == 0) {; 3129 return i;; 3130 }; 3131 }; 3132 return -1;; 3133}; 3134 ; 3135 ; 3136const char *; 3137mg_get_option(const struct mg_context *ctx, const char *name); 3138{; 3139 int i;; 3140 if ((i = get_option_index(name)) == -1) {; 3141 return NULL;; 3142 } else if (!ctx || ctx->dd.config[i] == NULL) {; 3143 return """";; 3144 } else {; 3145 return ctx->dd.config[i];; 3146 }; 3147}; 3148 ; 3149#define mg_get_option DO_NOT_USE_THIS_FUNCTION_INTERNALLY__access_directly; 3150 ; 3151struct mg_context *; 3152mg_get_context(const struct mg_connection *conn); 3153{; 3154 return (conn == NULL) ? (struct mg_context *)NULL : (conn->phys_ctx);; 3155}; 3156 ; 3157 ; 3158void *; 3159mg_get_user_data(const struct mg_context *ctx); 3160{; 3161 return (ctx == NULL) ? NULL : ctx->user_data;; 3162}; 3163 ; 3164 ; 3165void *; 3166mg_get_user_context_data(const struct mg_connection *conn); 3167{; 3168 return mg_get_user_data(mg_get_context(conn));; 3169}; 3170 ; 3171 ; 3172void *; 3173mg_get_thread_pointer(const struct mg_connection *conn); 3174{; 3175 /* both methods should return the same pointer */; 3176 if (conn) {; 3177 /* quick access, in case conn is known */; 3178 return conn->tls_user_ptr;; 3179 } else {; 3180 /* otherwise get pointer from thread local storage (TLS) */; 3181 struct mg_workerTLS *tls =; 3182 (str",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:94362,Modifiability,config,config,94362,"urn i;; 3130 }; 3131 }; 3132 return -1;; 3133}; 3134 ; 3135 ; 3136const char *; 3137mg_get_option(const struct mg_context *ctx, const char *name); 3138{; 3139 int i;; 3140 if ((i = get_option_index(name)) == -1) {; 3141 return NULL;; 3142 } else if (!ctx || ctx->dd.config[i] == NULL) {; 3143 return """";; 3144 } else {; 3145 return ctx->dd.config[i];; 3146 }; 3147}; 3148 ; 3149#define mg_get_option DO_NOT_USE_THIS_FUNCTION_INTERNALLY__access_directly; 3150 ; 3151struct mg_context *; 3152mg_get_context(const struct mg_connection *conn); 3153{; 3154 return (conn == NULL) ? (struct mg_context *)NULL : (conn->phys_ctx);; 3155}; 3156 ; 3157 ; 3158void *; 3159mg_get_user_data(const struct mg_context *ctx); 3160{; 3161 return (ctx == NULL) ? NULL : ctx->user_data;; 3162}; 3163 ; 3164 ; 3165void *; 3166mg_get_user_context_data(const struct mg_connection *conn); 3167{; 3168 return mg_get_user_data(mg_get_context(conn));; 3169}; 3170 ; 3171 ; 3172void *; 3173mg_get_thread_pointer(const struct mg_connection *conn); 3174{; 3175 /* both methods should return the same pointer */; 3176 if (conn) {; 3177 /* quick access, in case conn is known */; 3178 return conn->tls_user_ptr;; 3179 } else {; 3180 /* otherwise get pointer from thread local storage (TLS) */; 3181 struct mg_workerTLS *tls =; 3182 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 3183 return tls->user_ptr;; 3184 }; 3185}; 3186 ; 3187 ; 3188void; 3189mg_set_user_connection_data(const struct mg_connection *const_conn, void *data); 3190{; 3191 if (const_conn != NULL) {; 3192 /* Const cast, since ""const struct mg_connection *"" does not mean; 3193 * the connection object is not modified. Here ""const"" is used,; 3194 * to indicate mg_read/mg_write/mg_send/.. must not be called. */; 3195 struct mg_connection *conn = (struct mg_connection *)const_conn;; 3196 conn->request_info.conn_data = data;; 3197 }; 3198}; 3199 ; 3200 ; 3201void *; 3202mg_get_user_connection_data(const struct mg_connection *conn); 3203{; 3204 if (conn !=",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:100893,Modifiability,config,config,100893,"mg_file fi;; 3356 time_t timestamp;; 3357 ; 3358 /* Unused, in the RELEASE build */; 3359 (void)func;; 3360 (void)line;; 3361 ; 3362#if defined(GCC_DIAGNOSTIC); 3363#pragma GCC diagnostic push; 3364#pragma GCC diagnostic ignored ""-Wformat-nonliteral""; 3365#endif; 3366 ; 3367 IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));; 3368 ; 3369#if defined(GCC_DIAGNOSTIC); 3370#pragma GCC diagnostic pop; 3371#endif; 3372 ; 3373 buf[sizeof(buf) - 1] = 0;; 3374 ; 3375 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3376 ; 3377 if (!conn) {; 3378 puts(buf);; 3379 return;; 3380 }; 3381 ; 3382 /* Do not lock when getting the callback value, here and below.; 3383 * I suppose this is fine, since function cannot disappear in the; 3384 * same way string option can. */; 3385 if ((conn->phys_ctx->callbacks.log_message == NULL); 3386 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3387 ; 3388 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3389 if (mg_fopen(conn,; 3390 conn->dom_ctx->config[ERROR_LOG_FILE],; 3391 MG_FOPEN_MODE_APPEND,; 3392 &fi); 3393 == 0) {; 3394 fi.access.fp = NULL;; 3395 }; 3396 } else {; 3397 fi.access.fp = NULL;; 3398 }; 3399 ; 3400 if (fi.access.fp != NULL) {; 3401 flockfile(fi.access.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:100973,Modifiability,config,config,100973,"mg_file fi;; 3356 time_t timestamp;; 3357 ; 3358 /* Unused, in the RELEASE build */; 3359 (void)func;; 3360 (void)line;; 3361 ; 3362#if defined(GCC_DIAGNOSTIC); 3363#pragma GCC diagnostic push; 3364#pragma GCC diagnostic ignored ""-Wformat-nonliteral""; 3365#endif; 3366 ; 3367 IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));; 3368 ; 3369#if defined(GCC_DIAGNOSTIC); 3370#pragma GCC diagnostic pop; 3371#endif; 3372 ; 3373 buf[sizeof(buf) - 1] = 0;; 3374 ; 3375 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3376 ; 3377 if (!conn) {; 3378 puts(buf);; 3379 return;; 3380 }; 3381 ; 3382 /* Do not lock when getting the callback value, here and below.; 3383 * I suppose this is fine, since function cannot disappear in the; 3384 * same way string option can. */; 3385 if ((conn->phys_ctx->callbacks.log_message == NULL); 3386 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3387 ; 3388 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3389 if (mg_fopen(conn,; 3390 conn->dom_ctx->config[ERROR_LOG_FILE],; 3391 MG_FOPEN_MODE_APPEND,; 3392 &fi); 3393 == 0) {; 3394 fi.access.fp = NULL;; 3395 }; 3396 } else {; 3397 fi.access.fp = NULL;; 3398 }; 3399 ; 3400 if (fi.access.fp != NULL) {; 3401 flockfile(fi.access.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:108230,Modifiability,config,config,108230,"printf(conn,; 3606 &truncated,; 3607 buf,; 3608 buflen,; 3609 ""%s.unix://%s%s"",; 3610 proto,; 3611 server_name,; 3612 ri->local_uri);; 3613 default_port = 0;; 3614 return 0;; 3615 }; 3616#endif; 3617 ; 3618 if (define_proto) {; 3619 /* If we got a protocol name, use the default port accordingly. */; 3620 if ((0 == strcmp(define_proto, ""https"")); 3621 || (0 == strcmp(define_proto, ""wss""))) {; 3622 default_port = 443;; 3623 }; 3624 } else if (ri->is_ssl) {; 3625 /* If we did not get a protocol name, use TLS as default if it is; 3626 * already used. */; 3627 default_port = 443;; 3628 }; 3629 ; 3630 {; 3631#if defined(USE_IPV6); 3632 int is_ipv6 = (conn->client.lsa.sa.sa_family == AF_INET6);; 3633#endif; 3634 int auth_domain_check_enabled =; 3635 conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK]; 3636 && (!mg_strcasecmp(; 3637 conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK], ""yes""));; 3638 ; 3639 const char *server_domain =; 3640 conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 3641 ; 3642 char portstr[16];; 3643 char server_ip[48];; 3644 ; 3645 if (port != default_port) {; 3646 sprintf(portstr, "":%u"", (unsigned)port);; 3647 } else {; 3648 portstr[0] = 0;; 3649 }; 3650 ; 3651 if (!auth_domain_check_enabled || !server_domain) {; 3652 ; 3653 sockaddr_to_string(server_ip,; 3654 sizeof(server_ip),; 3655 &conn->client.lsa);; 3656 ; 3657 server_domain = server_ip;; 3658 }; 3659 ; 3660 mg_snprintf(conn,; 3661 &truncated,; 3662 buf,; 3663 buflen,; 3664#if defined(USE_IPV6); 3665 ""%s://%s%s%s%s%s"",; 3666 proto,; 3667 (is_ipv6 && (server_domain == server_ip)) ? ""["" : """",; 3668 server_domain,; 3669 (is_ipv6 && (server_domain == server_ip)) ? ""]"" : """",; 3670#else; 3671 ""%s://%s%s%s"",; 3672 proto,; 3673 server_domain,; 3674#endif; 3675 portstr,; 3676 ri->local_uri);; 3677 ; 3678 if (truncated) {; 3679 return -1;; 3680 }; 3681 return 0;; 3682 }; 3683 }; 3684}; 3685 ; 3686 ; 3687int; 3688mg_get_request_link(const struct mg_connection *conn, char *buf, size_t buflen); 3689{; 3690 return mg",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:108310,Modifiability,config,config,108310,"printf(conn,; 3606 &truncated,; 3607 buf,; 3608 buflen,; 3609 ""%s.unix://%s%s"",; 3610 proto,; 3611 server_name,; 3612 ri->local_uri);; 3613 default_port = 0;; 3614 return 0;; 3615 }; 3616#endif; 3617 ; 3618 if (define_proto) {; 3619 /* If we got a protocol name, use the default port accordingly. */; 3620 if ((0 == strcmp(define_proto, ""https"")); 3621 || (0 == strcmp(define_proto, ""wss""))) {; 3622 default_port = 443;; 3623 }; 3624 } else if (ri->is_ssl) {; 3625 /* If we did not get a protocol name, use TLS as default if it is; 3626 * already used. */; 3627 default_port = 443;; 3628 }; 3629 ; 3630 {; 3631#if defined(USE_IPV6); 3632 int is_ipv6 = (conn->client.lsa.sa.sa_family == AF_INET6);; 3633#endif; 3634 int auth_domain_check_enabled =; 3635 conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK]; 3636 && (!mg_strcasecmp(; 3637 conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK], ""yes""));; 3638 ; 3639 const char *server_domain =; 3640 conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 3641 ; 3642 char portstr[16];; 3643 char server_ip[48];; 3644 ; 3645 if (port != default_port) {; 3646 sprintf(portstr, "":%u"", (unsigned)port);; 3647 } else {; 3648 portstr[0] = 0;; 3649 }; 3650 ; 3651 if (!auth_domain_check_enabled || !server_domain) {; 3652 ; 3653 sockaddr_to_string(server_ip,; 3654 sizeof(server_ip),; 3655 &conn->client.lsa);; 3656 ; 3657 server_domain = server_ip;; 3658 }; 3659 ; 3660 mg_snprintf(conn,; 3661 &truncated,; 3662 buf,; 3663 buflen,; 3664#if defined(USE_IPV6); 3665 ""%s://%s%s%s%s%s"",; 3666 proto,; 3667 (is_ipv6 && (server_domain == server_ip)) ? ""["" : """",; 3668 server_domain,; 3669 (is_ipv6 && (server_domain == server_ip)) ? ""]"" : """",; 3670#else; 3671 ""%s://%s%s%s"",; 3672 proto,; 3673 server_domain,; 3674#endif; 3675 portstr,; 3676 ri->local_uri);; 3677 ; 3678 if (truncated) {; 3679 return -1;; 3680 }; 3681 return 0;; 3682 }; 3683 }; 3684}; 3685 ; 3686 ; 3687int; 3688mg_get_request_link(const struct mg_connection *conn, char *buf, size_t buflen); 3689{; 3690 return mg",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:108415,Modifiability,config,config,108415,"printf(conn,; 3606 &truncated,; 3607 buf,; 3608 buflen,; 3609 ""%s.unix://%s%s"",; 3610 proto,; 3611 server_name,; 3612 ri->local_uri);; 3613 default_port = 0;; 3614 return 0;; 3615 }; 3616#endif; 3617 ; 3618 if (define_proto) {; 3619 /* If we got a protocol name, use the default port accordingly. */; 3620 if ((0 == strcmp(define_proto, ""https"")); 3621 || (0 == strcmp(define_proto, ""wss""))) {; 3622 default_port = 443;; 3623 }; 3624 } else if (ri->is_ssl) {; 3625 /* If we did not get a protocol name, use TLS as default if it is; 3626 * already used. */; 3627 default_port = 443;; 3628 }; 3629 ; 3630 {; 3631#if defined(USE_IPV6); 3632 int is_ipv6 = (conn->client.lsa.sa.sa_family == AF_INET6);; 3633#endif; 3634 int auth_domain_check_enabled =; 3635 conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK]; 3636 && (!mg_strcasecmp(; 3637 conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK], ""yes""));; 3638 ; 3639 const char *server_domain =; 3640 conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 3641 ; 3642 char portstr[16];; 3643 char server_ip[48];; 3644 ; 3645 if (port != default_port) {; 3646 sprintf(portstr, "":%u"", (unsigned)port);; 3647 } else {; 3648 portstr[0] = 0;; 3649 }; 3650 ; 3651 if (!auth_domain_check_enabled || !server_domain) {; 3652 ; 3653 sockaddr_to_string(server_ip,; 3654 sizeof(server_ip),; 3655 &conn->client.lsa);; 3656 ; 3657 server_domain = server_ip;; 3658 }; 3659 ; 3660 mg_snprintf(conn,; 3661 &truncated,; 3662 buf,; 3663 buflen,; 3664#if defined(USE_IPV6); 3665 ""%s://%s%s%s%s%s"",; 3666 proto,; 3667 (is_ipv6 && (server_domain == server_ip)) ? ""["" : """",; 3668 server_domain,; 3669 (is_ipv6 && (server_domain == server_ip)) ? ""]"" : """",; 3670#else; 3671 ""%s://%s%s%s"",; 3672 proto,; 3673 server_domain,; 3674#endif; 3675 portstr,; 3676 ri->local_uri);; 3677 ; 3678 if (truncated) {; 3679 return -1;; 3680 }; 3681 return 0;; 3682 }; 3683 }; 3684}; 3685 ; 3686 ; 3687int; 3688mg_get_request_link(const struct mg_connection *conn, char *buf, size_t buflen); 3689{; 3690 return mg",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:118178,Modifiability,config,config,118178,"tern[i]) != lowercase(&str[j])) {; 3958 return -1;; 3959 }; 3960 }; 3961 return (ptrdiff_t)j;; 3962}; 3963 ; 3964 ; 3965static ptrdiff_t; 3966match_prefix_strlen(const char *pattern, const char *str); 3967{; 3968 if (pattern == NULL) {; 3969 return -1;; 3970 }; 3971 return match_prefix(pattern, strlen(pattern), str);; 3972}; 3973 ; 3974 ; 3975/* HTTP 1.1 assumes keep alive if ""Connection:"" header is not set; 3976 * This function must tolerate situations when connection info is not; 3977 * set up, for example if request parsing failed. */; 3978static int; 3979should_keep_alive(const struct mg_connection *conn); 3980{; 3981 const char *http_version;; 3982 const char *header;; 3983 ; 3984 /* First satisfy needs of the server */; 3985 if ((conn == NULL) || conn->must_close) {; 3986 /* Close, if civetweb framework needs to close */; 3987 return 0;; 3988 }; 3989 ; 3990 if (mg_strcasecmp(conn->dom_ctx->config[ENABLE_KEEP_ALIVE], ""yes"") != 0) {; 3991 /* Close, if keep alive is not enabled */; 3992 return 0;; 3993 }; 3994 ; 3995 /* Check explicit wish of the client */; 3996 header = mg_get_header(conn, ""Connection"");; 3997 if (header) {; 3998 /* If there is a connection header from the client, obey */; 3999 if (header_has_option(header, ""keep-alive"")) {; 4000 return 1;; 4001 }; 4002 return 0;; 4003 }; 4004 ; 4005 /* Use default of the standard */; 4006 http_version = get_http_version(conn);; 4007 if (http_version && (0 == strcmp(http_version, ""1.1""))) {; 4008 /* HTTP 1.1 default is keep alive */; 4009 return 1;; 4010 }; 4011 ; 4012 /* HTTP 1.0 (and earlier) default is to close the connection */; 4013 return 0;; 4014}; 4015 ; 4016 ; 4017static int; 4018should_decode_url(const struct mg_connection *conn); 4019{; 4020 if (!conn || !conn->dom_ctx) {; 4021 return 0;; 4022 }; 4023 ; 4024 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_URL], ""yes"") == 0);; 4025}; 4026 ; 4027 ; 4028static int; 4029should_decode_query_string(const struct mg_connection *conn); 4030{; 4031 if (!conn ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:119110,Modifiability,config,config,119110,", if keep alive is not enabled */; 3992 return 0;; 3993 }; 3994 ; 3995 /* Check explicit wish of the client */; 3996 header = mg_get_header(conn, ""Connection"");; 3997 if (header) {; 3998 /* If there is a connection header from the client, obey */; 3999 if (header_has_option(header, ""keep-alive"")) {; 4000 return 1;; 4001 }; 4002 return 0;; 4003 }; 4004 ; 4005 /* Use default of the standard */; 4006 http_version = get_http_version(conn);; 4007 if (http_version && (0 == strcmp(http_version, ""1.1""))) {; 4008 /* HTTP 1.1 default is keep alive */; 4009 return 1;; 4010 }; 4011 ; 4012 /* HTTP 1.0 (and earlier) default is to close the connection */; 4013 return 0;; 4014}; 4015 ; 4016 ; 4017static int; 4018should_decode_url(const struct mg_connection *conn); 4019{; 4020 if (!conn || !conn->dom_ctx) {; 4021 return 0;; 4022 }; 4023 ; 4024 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_URL], ""yes"") == 0);; 4025}; 4026 ; 4027 ; 4028static int; 4029should_decode_query_string(const struct mg_connection *conn); 4030{; 4031 if (!conn || !conn->dom_ctx) {; 4032 return 0;; 4033 }; 4034 ; 4035 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_QUERY_STRING], ""yes""); 4036 == 0);; 4037}; 4038 ; 4039 ; 4040static const char *; 4041suggest_connection_header(const struct mg_connection *conn); 4042{; 4043 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4044}; 4045 ; 4046 ; 4047#include ""response.inl""; 4048 ; 4049 ; 4050static void; 4051send_no_cache_header(struct mg_connection *conn); 4052{; 4053 /* Send all current and obsolete cache opt-out directives. */; 4054 mg_response_header_add(conn,; 4055 ""Cache-Control"",; 4056 ""no-cache, no-store, ""; 4057 ""must-revalidate, private, max-age=0"",; 4058 -1);; 4059 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4060 ; 4061 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4062 /* Obsolete, but still send it for HTTP/1.0 */; 4063 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4064 }; 4065}; 4066 ; 4067 ; 4068static void; 4069s",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:119365,Modifiability,config,config,119365,", if keep alive is not enabled */; 3992 return 0;; 3993 }; 3994 ; 3995 /* Check explicit wish of the client */; 3996 header = mg_get_header(conn, ""Connection"");; 3997 if (header) {; 3998 /* If there is a connection header from the client, obey */; 3999 if (header_has_option(header, ""keep-alive"")) {; 4000 return 1;; 4001 }; 4002 return 0;; 4003 }; 4004 ; 4005 /* Use default of the standard */; 4006 http_version = get_http_version(conn);; 4007 if (http_version && (0 == strcmp(http_version, ""1.1""))) {; 4008 /* HTTP 1.1 default is keep alive */; 4009 return 1;; 4010 }; 4011 ; 4012 /* HTTP 1.0 (and earlier) default is to close the connection */; 4013 return 0;; 4014}; 4015 ; 4016 ; 4017static int; 4018should_decode_url(const struct mg_connection *conn); 4019{; 4020 if (!conn || !conn->dom_ctx) {; 4021 return 0;; 4022 }; 4023 ; 4024 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_URL], ""yes"") == 0);; 4025}; 4026 ; 4027 ; 4028static int; 4029should_decode_query_string(const struct mg_connection *conn); 4030{; 4031 if (!conn || !conn->dom_ctx) {; 4032 return 0;; 4033 }; 4034 ; 4035 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_QUERY_STRING], ""yes""); 4036 == 0);; 4037}; 4038 ; 4039 ; 4040static const char *; 4041suggest_connection_header(const struct mg_connection *conn); 4042{; 4043 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4044}; 4045 ; 4046 ; 4047#include ""response.inl""; 4048 ; 4049 ; 4050static void; 4051send_no_cache_header(struct mg_connection *conn); 4052{; 4053 /* Send all current and obsolete cache opt-out directives. */; 4054 mg_response_header_add(conn,; 4055 ""Cache-Control"",; 4056 ""no-cache, no-store, ""; 4057 ""must-revalidate, private, max-age=0"",; 4058 -1);; 4059 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4060 ; 4061 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4062 /* Obsolete, but still send it for HTTP/1.0 */; 4063 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4064 }; 4065}; 4066 ; 4067 ; 4068static void; 4069s",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:120424,Modifiability,config,config,120424,"039 ; 4040static const char *; 4041suggest_connection_header(const struct mg_connection *conn); 4042{; 4043 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4044}; 4045 ; 4046 ; 4047#include ""response.inl""; 4048 ; 4049 ; 4050static void; 4051send_no_cache_header(struct mg_connection *conn); 4052{; 4053 /* Send all current and obsolete cache opt-out directives. */; 4054 mg_response_header_add(conn,; 4055 ""Cache-Control"",; 4056 ""no-cache, no-store, ""; 4057 ""must-revalidate, private, max-age=0"",; 4058 -1);; 4059 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4060 ; 4061 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4062 /* Obsolete, but still send it for HTTP/1.0 */; 4063 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4064 }; 4065}; 4066 ; 4067 ; 4068static void; 4069send_static_cache_header(struct mg_connection *conn); 4070{; 4071#if !defined(NO_CACHING); 4072 int max_age;; 4073 char val[64];; 4074 ; 4075 const char *cache_control =; 4076 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4077 ; 4078 /* If there is a full cache-control option configured,0 use it */; 4079 if (cache_control != NULL) {; 4080 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4081 return;; 4082 }; 4083 ; 4084 /* Read the server config to check how long a file may be cached.; 4085 * The configuration is in seconds. */; 4086 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4087 if (max_age <= 0) {; 4088 /* 0 means ""do not cache"". All values <0 are reserved; 4089 * and may be used differently in the future. */; 4090 /* If a file should not be cached, do not only send; 4091 * max-age=0, but also pragmas and Expires headers. */; 4092 send_no_cache_header(conn);; 4093 return;; 4094 }; 4095 ; 4096 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4097 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4098 /* See also https://www.mnot.net/cache_docs/ */; 4099 /* According to RFC 2616, Section 14.21, caching t",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:120515,Modifiability,config,configured,120515,"039 ; 4040static const char *; 4041suggest_connection_header(const struct mg_connection *conn); 4042{; 4043 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4044}; 4045 ; 4046 ; 4047#include ""response.inl""; 4048 ; 4049 ; 4050static void; 4051send_no_cache_header(struct mg_connection *conn); 4052{; 4053 /* Send all current and obsolete cache opt-out directives. */; 4054 mg_response_header_add(conn,; 4055 ""Cache-Control"",; 4056 ""no-cache, no-store, ""; 4057 ""must-revalidate, private, max-age=0"",; 4058 -1);; 4059 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4060 ; 4061 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4062 /* Obsolete, but still send it for HTTP/1.0 */; 4063 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4064 }; 4065}; 4066 ; 4067 ; 4068static void; 4069send_static_cache_header(struct mg_connection *conn); 4070{; 4071#if !defined(NO_CACHING); 4072 int max_age;; 4073 char val[64];; 4074 ; 4075 const char *cache_control =; 4076 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4077 ; 4078 /* If there is a full cache-control option configured,0 use it */; 4079 if (cache_control != NULL) {; 4080 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4081 return;; 4082 }; 4083 ; 4084 /* Read the server config to check how long a file may be cached.; 4085 * The configuration is in seconds. */; 4086 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4087 if (max_age <= 0) {; 4088 /* 0 means ""do not cache"". All values <0 are reserved; 4089 * and may be used differently in the future. */; 4090 /* If a file should not be cached, do not only send; 4091 * max-age=0, but also pragmas and Expires headers. */; 4092 send_no_cache_header(conn);; 4093 return;; 4094 }; 4095 ; 4096 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4097 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4098 /* See also https://www.mnot.net/cache_docs/ */; 4099 /* According to RFC 2616, Section 14.21, caching t",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:120699,Modifiability,config,config,120699,"039 ; 4040static const char *; 4041suggest_connection_header(const struct mg_connection *conn); 4042{; 4043 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4044}; 4045 ; 4046 ; 4047#include ""response.inl""; 4048 ; 4049 ; 4050static void; 4051send_no_cache_header(struct mg_connection *conn); 4052{; 4053 /* Send all current and obsolete cache opt-out directives. */; 4054 mg_response_header_add(conn,; 4055 ""Cache-Control"",; 4056 ""no-cache, no-store, ""; 4057 ""must-revalidate, private, max-age=0"",; 4058 -1);; 4059 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4060 ; 4061 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4062 /* Obsolete, but still send it for HTTP/1.0 */; 4063 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4064 }; 4065}; 4066 ; 4067 ; 4068static void; 4069send_static_cache_header(struct mg_connection *conn); 4070{; 4071#if !defined(NO_CACHING); 4072 int max_age;; 4073 char val[64];; 4074 ; 4075 const char *cache_control =; 4076 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4077 ; 4078 /* If there is a full cache-control option configured,0 use it */; 4079 if (cache_control != NULL) {; 4080 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4081 return;; 4082 }; 4083 ; 4084 /* Read the server config to check how long a file may be cached.; 4085 * The configuration is in seconds. */; 4086 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4087 if (max_age <= 0) {; 4088 /* 0 means ""do not cache"". All values <0 are reserved; 4089 * and may be used differently in the future. */; 4090 /* If a file should not be cached, do not only send; 4091 * max-age=0, but also pragmas and Expires headers. */; 4092 send_no_cache_header(conn);; 4093 return;; 4094 }; 4095 ; 4096 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4097 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4098 /* See also https://www.mnot.net/cache_docs/ */; 4099 /* According to RFC 2616, Section 14.21, caching t",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:120758,Modifiability,config,configuration,120758,"d obsolete cache opt-out directives. */; 4054 mg_response_header_add(conn,; 4055 ""Cache-Control"",; 4056 ""no-cache, no-store, ""; 4057 ""must-revalidate, private, max-age=0"",; 4058 -1);; 4059 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4060 ; 4061 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4062 /* Obsolete, but still send it for HTTP/1.0 */; 4063 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4064 }; 4065}; 4066 ; 4067 ; 4068static void; 4069send_static_cache_header(struct mg_connection *conn); 4070{; 4071#if !defined(NO_CACHING); 4072 int max_age;; 4073 char val[64];; 4074 ; 4075 const char *cache_control =; 4076 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4077 ; 4078 /* If there is a full cache-control option configured,0 use it */; 4079 if (cache_control != NULL) {; 4080 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4081 return;; 4082 }; 4083 ; 4084 /* Read the server config to check how long a file may be cached.; 4085 * The configuration is in seconds. */; 4086 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4087 if (max_age <= 0) {; 4088 /* 0 means ""do not cache"". All values <0 are reserved; 4089 * and may be used differently in the future. */; 4090 /* If a file should not be cached, do not only send; 4091 * max-age=0, but also pragmas and Expires headers. */; 4092 send_no_cache_header(conn);; 4093 return;; 4094 }; 4095 ; 4096 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4097 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4098 /* See also https://www.mnot.net/cache_docs/ */; 4099 /* According to RFC 2616, Section 14.21, caching times should not exceed; 4100 * one year. A year with 365 days corresponds to 31536000 seconds, a; 4101 * leap; 4102 * year to 31622400 seconds. For the moment, we just send whatever has; 4103 * been configured, still the behavior for >1 year should be considered; 4104 * as undefined. */; 4105 mg_snprintf(; 4106 conn, NULL, val, sizeof",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:120826,Modifiability,config,config,120826,"he-Control"",; 4056 ""no-cache, no-store, ""; 4057 ""must-revalidate, private, max-age=0"",; 4058 -1);; 4059 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4060 ; 4061 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4062 /* Obsolete, but still send it for HTTP/1.0 */; 4063 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4064 }; 4065}; 4066 ; 4067 ; 4068static void; 4069send_static_cache_header(struct mg_connection *conn); 4070{; 4071#if !defined(NO_CACHING); 4072 int max_age;; 4073 char val[64];; 4074 ; 4075 const char *cache_control =; 4076 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4077 ; 4078 /* If there is a full cache-control option configured,0 use it */; 4079 if (cache_control != NULL) {; 4080 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4081 return;; 4082 }; 4083 ; 4084 /* Read the server config to check how long a file may be cached.; 4085 * The configuration is in seconds. */; 4086 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4087 if (max_age <= 0) {; 4088 /* 0 means ""do not cache"". All values <0 are reserved; 4089 * and may be used differently in the future. */; 4090 /* If a file should not be cached, do not only send; 4091 * max-age=0, but also pragmas and Expires headers. */; 4092 send_no_cache_header(conn);; 4093 return;; 4094 }; 4095 ; 4096 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4097 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4098 /* See also https://www.mnot.net/cache_docs/ */; 4099 /* According to RFC 2616, Section 14.21, caching times should not exceed; 4100 * one year. A year with 365 days corresponds to 31536000 seconds, a; 4101 * leap; 4102 * year to 31622400 seconds. For the moment, we just send whatever has; 4103 * been configured, still the behavior for >1 year should be considered; 4104 * as undefined. */; 4105 mg_snprintf(; 4106 conn, NULL, val, sizeof(val), ""max-age=%lu"", (unsigned long)max_age);; 4107 mg_response_header_add(conn, ""C",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:121629,Modifiability,config,configured,121629,";; 4081 return;; 4082 }; 4083 ; 4084 /* Read the server config to check how long a file may be cached.; 4085 * The configuration is in seconds. */; 4086 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4087 if (max_age <= 0) {; 4088 /* 0 means ""do not cache"". All values <0 are reserved; 4089 * and may be used differently in the future. */; 4090 /* If a file should not be cached, do not only send; 4091 * max-age=0, but also pragmas and Expires headers. */; 4092 send_no_cache_header(conn);; 4093 return;; 4094 }; 4095 ; 4096 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4097 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4098 /* See also https://www.mnot.net/cache_docs/ */; 4099 /* According to RFC 2616, Section 14.21, caching times should not exceed; 4100 * one year. A year with 365 days corresponds to 31536000 seconds, a; 4101 * leap; 4102 * year to 31622400 seconds. For the moment, we just send whatever has; 4103 * been configured, still the behavior for >1 year should be considered; 4104 * as undefined. */; 4105 mg_snprintf(; 4106 conn, NULL, val, sizeof(val), ""max-age=%lu"", (unsigned long)max_age);; 4107 mg_response_header_add(conn, ""Cache-Control"", val, -1);; 4108 ; 4109#else /* NO_CACHING */; 4110 ; 4111 send_no_cache_header(conn);; 4112#endif /* !NO_CACHING */; 4113}; 4114 ; 4115 ; 4116static void; 4117send_additional_header(struct mg_connection *conn); 4118{; 4119 const char *header = conn->dom_ctx->config[ADDITIONAL_HEADER];; 4120 ; 4121#if !defined(NO_SSL); 4122 if (conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]) {; 4123 long max_age = atol(conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]);; 4124 if (max_age >= 0) {; 4125 char val[64];; 4126 mg_snprintf(conn,; 4127 NULL,; 4128 val,; 4129 sizeof(val),; 4130 ""max-age=%lu"",; 4131 (unsigned long)max_age);; 4132 mg_response_header_add(conn, ""Strict-Transport-Security"", val, -1);; 4133 }; 4134 }; 4135#endif; 4136 ; 4137 if (header && header[0]) {; 4138 mg_response_header_",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:122124,Modifiability,config,config,122124,"RFC 2616, Section 14.21, caching times should not exceed; 4100 * one year. A year with 365 days corresponds to 31536000 seconds, a; 4101 * leap; 4102 * year to 31622400 seconds. For the moment, we just send whatever has; 4103 * been configured, still the behavior for >1 year should be considered; 4104 * as undefined. */; 4105 mg_snprintf(; 4106 conn, NULL, val, sizeof(val), ""max-age=%lu"", (unsigned long)max_age);; 4107 mg_response_header_add(conn, ""Cache-Control"", val, -1);; 4108 ; 4109#else /* NO_CACHING */; 4110 ; 4111 send_no_cache_header(conn);; 4112#endif /* !NO_CACHING */; 4113}; 4114 ; 4115 ; 4116static void; 4117send_additional_header(struct mg_connection *conn); 4118{; 4119 const char *header = conn->dom_ctx->config[ADDITIONAL_HEADER];; 4120 ; 4121#if !defined(NO_SSL); 4122 if (conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]) {; 4123 long max_age = atol(conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]);; 4124 if (max_age >= 0) {; 4125 char val[64];; 4126 mg_snprintf(conn,; 4127 NULL,; 4128 val,; 4129 sizeof(val),; 4130 ""max-age=%lu"",; 4131 (unsigned long)max_age);; 4132 mg_response_header_add(conn, ""Strict-Transport-Security"", val, -1);; 4133 }; 4134 }; 4135#endif; 4136 ; 4137 if (header && header[0]) {; 4138 mg_response_header_add_lines(conn, header);; 4139 }; 4140}; 4141 ; 4142 ; 4143#if !defined(NO_FILESYSTEMS); 4144static void handle_file_based_request(struct mg_connection *conn,; 4145 const char *path,; 4146 struct mg_file *filep);; 4147#endif /* NO_FILESYSTEMS */; 4148 ; 4149 ; 4150const char *; 4151mg_get_response_code_text(const struct mg_connection *conn, int response_code); 4152{; 4153 /* See IANA HTTP status code assignment:; 4154 * http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml; 4155 */; 4156 ; 4157 switch (response_code) {; 4158 /* RFC2616 Section 10.1 - Informational 1xx */; 4159 case 100:; 4160 return ""Continue""; /* RFC2616 Section 10.1.1 */; 4161 case 101:; 4162 return ""Switching Protocols""; /* RFC2616 Section 10.1.2 */; 416",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:122209,Modifiability,config,config,122209,"RFC 2616, Section 14.21, caching times should not exceed; 4100 * one year. A year with 365 days corresponds to 31536000 seconds, a; 4101 * leap; 4102 * year to 31622400 seconds. For the moment, we just send whatever has; 4103 * been configured, still the behavior for >1 year should be considered; 4104 * as undefined. */; 4105 mg_snprintf(; 4106 conn, NULL, val, sizeof(val), ""max-age=%lu"", (unsigned long)max_age);; 4107 mg_response_header_add(conn, ""Cache-Control"", val, -1);; 4108 ; 4109#else /* NO_CACHING */; 4110 ; 4111 send_no_cache_header(conn);; 4112#endif /* !NO_CACHING */; 4113}; 4114 ; 4115 ; 4116static void; 4117send_additional_header(struct mg_connection *conn); 4118{; 4119 const char *header = conn->dom_ctx->config[ADDITIONAL_HEADER];; 4120 ; 4121#if !defined(NO_SSL); 4122 if (conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]) {; 4123 long max_age = atol(conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]);; 4124 if (max_age >= 0) {; 4125 char val[64];; 4126 mg_snprintf(conn,; 4127 NULL,; 4128 val,; 4129 sizeof(val),; 4130 ""max-age=%lu"",; 4131 (unsigned long)max_age);; 4132 mg_response_header_add(conn, ""Strict-Transport-Security"", val, -1);; 4133 }; 4134 }; 4135#endif; 4136 ; 4137 if (header && header[0]) {; 4138 mg_response_header_add_lines(conn, header);; 4139 }; 4140}; 4141 ; 4142 ; 4143#if !defined(NO_FILESYSTEMS); 4144static void handle_file_based_request(struct mg_connection *conn,; 4145 const char *path,; 4146 struct mg_file *filep);; 4147#endif /* NO_FILESYSTEMS */; 4148 ; 4149 ; 4150const char *; 4151mg_get_response_code_text(const struct mg_connection *conn, int response_code); 4152{; 4153 /* See IANA HTTP status code assignment:; 4154 * http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml; 4155 */; 4156 ; 4157 switch (response_code) {; 4158 /* RFC2616 Section 10.1 - Informational 1xx */; 4159 case 100:; 4160 return ""Continue""; /* RFC2616 Section 10.1.1 */; 4161 case 101:; 4162 return ""Switching Protocols""; /* RFC2616 Section 10.1.2 */; 416",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:122282,Modifiability,config,config,122282,"RFC 2616, Section 14.21, caching times should not exceed; 4100 * one year. A year with 365 days corresponds to 31536000 seconds, a; 4101 * leap; 4102 * year to 31622400 seconds. For the moment, we just send whatever has; 4103 * been configured, still the behavior for >1 year should be considered; 4104 * as undefined. */; 4105 mg_snprintf(; 4106 conn, NULL, val, sizeof(val), ""max-age=%lu"", (unsigned long)max_age);; 4107 mg_response_header_add(conn, ""Cache-Control"", val, -1);; 4108 ; 4109#else /* NO_CACHING */; 4110 ; 4111 send_no_cache_header(conn);; 4112#endif /* !NO_CACHING */; 4113}; 4114 ; 4115 ; 4116static void; 4117send_additional_header(struct mg_connection *conn); 4118{; 4119 const char *header = conn->dom_ctx->config[ADDITIONAL_HEADER];; 4120 ; 4121#if !defined(NO_SSL); 4122 if (conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]) {; 4123 long max_age = atol(conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]);; 4124 if (max_age >= 0) {; 4125 char val[64];; 4126 mg_snprintf(conn,; 4127 NULL,; 4128 val,; 4129 sizeof(val),; 4130 ""max-age=%lu"",; 4131 (unsigned long)max_age);; 4132 mg_response_header_add(conn, ""Strict-Transport-Security"", val, -1);; 4133 }; 4134 }; 4135#endif; 4136 ; 4137 if (header && header[0]) {; 4138 mg_response_header_add_lines(conn, header);; 4139 }; 4140}; 4141 ; 4142 ; 4143#if !defined(NO_FILESYSTEMS); 4144static void handle_file_based_request(struct mg_connection *conn,; 4145 const char *path,; 4146 struct mg_file *filep);; 4147#endif /* NO_FILESYSTEMS */; 4148 ; 4149 ; 4150const char *; 4151mg_get_response_code_text(const struct mg_connection *conn, int response_code); 4152{; 4153 /* See IANA HTTP status code assignment:; 4154 * http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml; 4155 */; 4156 ; 4157 switch (response_code) {; 4158 /* RFC2616 Section 10.1 - Informational 1xx */; 4159 case 100:; 4160 return ""Continue""; /* RFC2616 Section 10.1.1 */; 4161 case 101:; 4162 return ""Switching Protocols""; /* RFC2616 Section 10.1.2 */; 416",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:131987,Modifiability,config,config,131987," args);; 4384 mg_vsnprintf(conn, NULL, errmsg_buf, sizeof(errmsg_buf), fmt, ap);; 4385 va_end(ap);; 4386 /* In a debug build, print all html errors */; 4387 DEBUG_TRACE(""Error %i - [%s]"", status, errmsg_buf);; 4388 }; 4389 ; 4390 /* If there is a http_error callback, call it.; 4391 * But don't do it recursively, if callback calls mg_send_http_error again.; 4392 */; 4393 if (!conn->in_error_handler; 4394 && (conn->phys_ctx->callbacks.http_error != NULL)) {; 4395 /* Mark in_error_handler to avoid recursion and call user callback. */; 4396 conn->in_error_handler = 1;; 4397 handled_by_callback =; 4398 (conn->phys_ctx->callbacks.http_error(conn, status, errmsg_buf); 4399 == 0);; 4400 conn->in_error_handler = 0;; 4401 }; 4402 ; 4403 if (!handled_by_callback) {; 4404 /* Check for recursion */; 4405 if (conn->in_error_handler) {; 4406 DEBUG_TRACE(; 4407 ""Recursion when handling error %u - fall back to default"",; 4408 status);; 4409#if !defined(NO_FILESYSTEMS); 4410 } else {; 4411 /* Send user defined error pages, if defined */; 4412 error_handler = conn->dom_ctx->config[ERROR_PAGES];; 4413 error_page_file_ext = conn->dom_ctx->config[INDEX_FILES];; 4414 page_handler_found = 0;; 4415 ; 4416 if (error_handler != NULL) {; 4417 for (scope = 1; (scope <= 3) && !page_handler_found; scope++) {; 4418 switch (scope) {; 4419 case 1: /* Handler for specific error, e.g. 404 error */; 4420 mg_snprintf(conn,; 4421 &truncated,; 4422 path_buf,; 4423 sizeof(path_buf) - 32,; 4424 ""%serror%03u."",; 4425 error_handler,; 4426 status);; 4427 break;; 4428 case 2: /* Handler for error group, e.g., 5xx error; 4429 * handler; 4430 * for all server errors (500-599) */; 4431 mg_snprintf(conn,; 4432 &truncated,; 4433 path_buf,; 4434 sizeof(path_buf) - 32,; 4435 ""%serror%01uxx."",; 4436 error_handler,; 4437 status / 100);; 4438 break;; 4439 default: /* Handler for all errors */; 4440 mg_snprintf(conn,; 4441 &truncated,; 4442 path_buf,; 4443 sizeof(path_buf) - 32,; 4444 ""%serror."",; 4445 error_handler);; 444",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:132051,Modifiability,config,config,132051," args);; 4384 mg_vsnprintf(conn, NULL, errmsg_buf, sizeof(errmsg_buf), fmt, ap);; 4385 va_end(ap);; 4386 /* In a debug build, print all html errors */; 4387 DEBUG_TRACE(""Error %i - [%s]"", status, errmsg_buf);; 4388 }; 4389 ; 4390 /* If there is a http_error callback, call it.; 4391 * But don't do it recursively, if callback calls mg_send_http_error again.; 4392 */; 4393 if (!conn->in_error_handler; 4394 && (conn->phys_ctx->callbacks.http_error != NULL)) {; 4395 /* Mark in_error_handler to avoid recursion and call user callback. */; 4396 conn->in_error_handler = 1;; 4397 handled_by_callback =; 4398 (conn->phys_ctx->callbacks.http_error(conn, status, errmsg_buf); 4399 == 0);; 4400 conn->in_error_handler = 0;; 4401 }; 4402 ; 4403 if (!handled_by_callback) {; 4404 /* Check for recursion */; 4405 if (conn->in_error_handler) {; 4406 DEBUG_TRACE(; 4407 ""Recursion when handling error %u - fall back to default"",; 4408 status);; 4409#if !defined(NO_FILESYSTEMS); 4410 } else {; 4411 /* Send user defined error pages, if defined */; 4412 error_handler = conn->dom_ctx->config[ERROR_PAGES];; 4413 error_page_file_ext = conn->dom_ctx->config[INDEX_FILES];; 4414 page_handler_found = 0;; 4415 ; 4416 if (error_handler != NULL) {; 4417 for (scope = 1; (scope <= 3) && !page_handler_found; scope++) {; 4418 switch (scope) {; 4419 case 1: /* Handler for specific error, e.g. 404 error */; 4420 mg_snprintf(conn,; 4421 &truncated,; 4422 path_buf,; 4423 sizeof(path_buf) - 32,; 4424 ""%serror%03u."",; 4425 error_handler,; 4426 status);; 4427 break;; 4428 case 2: /* Handler for error group, e.g., 5xx error; 4429 * handler; 4430 * for all server errors (500-599) */; 4431 mg_snprintf(conn,; 4432 &truncated,; 4433 path_buf,; 4434 sizeof(path_buf) - 32,; 4435 ""%serror%01uxx."",; 4436 error_handler,; 4437 status / 100);; 4438 break;; 4439 default: /* Handler for all errors */; 4440 mg_snprintf(conn,; 4441 &truncated,; 4442 path_buf,; 4443 sizeof(path_buf) - 32,; 4444 ""%serror."",; 4445 error_handler);; 444",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:133059,Modifiability,config,config,133059,"ig[INDEX_FILES];; 4414 page_handler_found = 0;; 4415 ; 4416 if (error_handler != NULL) {; 4417 for (scope = 1; (scope <= 3) && !page_handler_found; scope++) {; 4418 switch (scope) {; 4419 case 1: /* Handler for specific error, e.g. 404 error */; 4420 mg_snprintf(conn,; 4421 &truncated,; 4422 path_buf,; 4423 sizeof(path_buf) - 32,; 4424 ""%serror%03u."",; 4425 error_handler,; 4426 status);; 4427 break;; 4428 case 2: /* Handler for error group, e.g., 5xx error; 4429 * handler; 4430 * for all server errors (500-599) */; 4431 mg_snprintf(conn,; 4432 &truncated,; 4433 path_buf,; 4434 sizeof(path_buf) - 32,; 4435 ""%serror%01uxx."",; 4436 error_handler,; 4437 status / 100);; 4438 break;; 4439 default: /* Handler for all errors */; 4440 mg_snprintf(conn,; 4441 &truncated,; 4442 path_buf,; 4443 sizeof(path_buf) - 32,; 4444 ""%serror."",; 4445 error_handler);; 4446 break;; 4447 }; 4448 ; 4449 /* String truncation in buf may only occur if; 4450 * error_handler is too long. This string is; 4451 * from the config, not from a client. */; 4452 (void)truncated;; 4453 ; 4454 /* The following code is redundant, but it should avoid; 4455 * false positives in static source code analyzers and; 4456 * vulnerability scanners.; 4457 */; 4458 path_buf[sizeof(path_buf) - 32] = 0;; 4459 len = (int)strlen(path_buf);; 4460 if (len > (int)sizeof(path_buf) - 32) {; 4461 len = (int)sizeof(path_buf) - 32;; 4462 }; 4463 ; 4464 /* Start with the file extenstion from the configuration. */; 4465 tstr = strchr(error_page_file_ext, '.');; 4466 ; 4467 while (tstr) {; 4468 for (i = 1;; 4469 (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');; 4470 i++) {; 4471 /* buffer overrun is not possible here, since; 4472 * (i < 32) && (len < sizeof(path_buf) - 32); 4473 * ==> (i + len) < sizeof(path_buf) */; 4474 path_buf[len + i - 1] = tstr[i];; 4475 }; 4476 /* buffer overrun is not possible here, since; 4477 * (i <= 32) && (len < sizeof(path_buf) - 32); 4478 * ==> (i + len) <= sizeof(path_buf) */; 4479 path_buf[len + i - 1]",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:133510,Modifiability,config,configuration,133510,"ror%03u."",; 4425 error_handler,; 4426 status);; 4427 break;; 4428 case 2: /* Handler for error group, e.g., 5xx error; 4429 * handler; 4430 * for all server errors (500-599) */; 4431 mg_snprintf(conn,; 4432 &truncated,; 4433 path_buf,; 4434 sizeof(path_buf) - 32,; 4435 ""%serror%01uxx."",; 4436 error_handler,; 4437 status / 100);; 4438 break;; 4439 default: /* Handler for all errors */; 4440 mg_snprintf(conn,; 4441 &truncated,; 4442 path_buf,; 4443 sizeof(path_buf) - 32,; 4444 ""%serror."",; 4445 error_handler);; 4446 break;; 4447 }; 4448 ; 4449 /* String truncation in buf may only occur if; 4450 * error_handler is too long. This string is; 4451 * from the config, not from a client. */; 4452 (void)truncated;; 4453 ; 4454 /* The following code is redundant, but it should avoid; 4455 * false positives in static source code analyzers and; 4456 * vulnerability scanners.; 4457 */; 4458 path_buf[sizeof(path_buf) - 32] = 0;; 4459 len = (int)strlen(path_buf);; 4460 if (len > (int)sizeof(path_buf) - 32) {; 4461 len = (int)sizeof(path_buf) - 32;; 4462 }; 4463 ; 4464 /* Start with the file extenstion from the configuration. */; 4465 tstr = strchr(error_page_file_ext, '.');; 4466 ; 4467 while (tstr) {; 4468 for (i = 1;; 4469 (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');; 4470 i++) {; 4471 /* buffer overrun is not possible here, since; 4472 * (i < 32) && (len < sizeof(path_buf) - 32); 4473 * ==> (i + len) < sizeof(path_buf) */; 4474 path_buf[len + i - 1] = tstr[i];; 4475 }; 4476 /* buffer overrun is not possible here, since; 4477 * (i <= 32) && (len < sizeof(path_buf) - 32); 4478 * ==> (i + len) <= sizeof(path_buf) */; 4479 path_buf[len + i - 1] = 0;; 4480 ; 4481 if (mg_stat(conn, path_buf, &error_page_file.stat)) {; 4482 DEBUG_TRACE(""Check error page %s - found"",; 4483 path_buf);; 4484 page_handler_found = 1;; 4485 break;; 4486 }; 4487 DEBUG_TRACE(""Check error page %s - not found"",; 4488 path_buf);; 4489 ; 4490 /* Continue with the next file extenstion from the; 4491 * configurat",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:134388,Modifiability,config,configuration,134388," 4457 */; 4458 path_buf[sizeof(path_buf) - 32] = 0;; 4459 len = (int)strlen(path_buf);; 4460 if (len > (int)sizeof(path_buf) - 32) {; 4461 len = (int)sizeof(path_buf) - 32;; 4462 }; 4463 ; 4464 /* Start with the file extenstion from the configuration. */; 4465 tstr = strchr(error_page_file_ext, '.');; 4466 ; 4467 while (tstr) {; 4468 for (i = 1;; 4469 (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');; 4470 i++) {; 4471 /* buffer overrun is not possible here, since; 4472 * (i < 32) && (len < sizeof(path_buf) - 32); 4473 * ==> (i + len) < sizeof(path_buf) */; 4474 path_buf[len + i - 1] = tstr[i];; 4475 }; 4476 /* buffer overrun is not possible here, since; 4477 * (i <= 32) && (len < sizeof(path_buf) - 32); 4478 * ==> (i + len) <= sizeof(path_buf) */; 4479 path_buf[len + i - 1] = 0;; 4480 ; 4481 if (mg_stat(conn, path_buf, &error_page_file.stat)) {; 4482 DEBUG_TRACE(""Check error page %s - found"",; 4483 path_buf);; 4484 page_handler_found = 1;; 4485 break;; 4486 }; 4487 DEBUG_TRACE(""Check error page %s - not found"",; 4488 path_buf);; 4489 ; 4490 /* Continue with the next file extenstion from the; 4491 * configuration (if there is a next one). */; 4492 tstr = strchr(tstr + i, '.');; 4493 }; 4494 }; 4495 }; 4496 ; 4497 if (page_handler_found) {; 4498 conn->in_error_handler = 1;; 4499 handle_file_based_request(conn, path_buf, &error_page_file);; 4500 conn->in_error_handler = 0;; 4501 return 0;; 4502 }; 4503#endif /* NO_FILESYSTEMS */; 4504 }; 4505 ; 4506 /* No custom error page. Send default error page. */; 4507 conn->must_close = 1;; 4508 mg_response_header_start(conn, status);; 4509 send_no_cache_header(conn);; 4510 send_additional_header(conn);; 4511 if (has_body) {; 4512 mg_response_header_add(conn,; 4513 ""Content-Type"",; 4514 ""text/plain; charset=utf-8"",; 4515 -1);; 4516 }; 4517 mg_response_header_send(conn);; 4518 ; 4519 /* HTTP responses 1xx, 204 and 304 MUST NOT send a body */; 4520 if (has_body) {; 4521 /* For other errors, send a generic error message. */; 4522 cons",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:148489,Modifiability,config,configuration,148489,"4963 ; 4964 /* Convert to Unicode and back. If doubly-converted string does not; 4965 * match the original, something is fishy, reject. */; 4966 memset(wbuf, 0, wbuf_len * sizeof(wchar_t));; 4967 MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int)wbuf_len);; 4968 WideCharToMultiByte(; 4969 CP_UTF8, 0, wbuf, (int)wbuf_len, buf2, sizeof(buf2), NULL, NULL);; 4970 if (strcmp(buf, buf2) != 0) {; 4971 wbuf[0] = L'\0';; 4972 }; 4973 ; 4974 /* Windows file systems are not case sensitive, but you can still use; 4975 * uppercase and lowercase letters (on all modern file systems).; 4976 * The server can check if the URI uses the same upper/lowercase; 4977 * letters an the file system, effectively making Windows servers; 4978 * case sensitive (like Linux servers are). It is still not possible; 4979 * to use two files with the same name in different cases on Windows; 4980 * (like /a and /A) - this would be possible in Linux.; 4981 * As a default, Windows is not case sensitive, but the case sensitive; 4982 * file name check can be activated by an additional configuration. */; 4983 if (conn) {; 4984 if (conn->dom_ctx->config[CASE_SENSITIVE_FILES]; 4985 && !mg_strcasecmp(conn->dom_ctx->config[CASE_SENSITIVE_FILES],; 4986 ""yes"")) {; 4987 /* Use case sensitive compare function */; 4988 fcompare = wcscmp;; 4989 }; 4990 }; 4991 (void)conn; /* conn is currently unused */; 4992 ; 4993 /* Only accept a full file path, not a Windows short (8.3) path. */; 4994 memset(wbuf2, 0, ARRAY_SIZE(wbuf2) * sizeof(wchar_t));; 4995 long_len = GetLongPathNameW(wbuf, wbuf2, ARRAY_SIZE(wbuf2) - 1);; 4996 if (long_len == 0) {; 4997 err = GetLastError();; 4998 if (err == ERROR_FILE_NOT_FOUND) {; 4999 /* File does not exist. This is not always a problem here. */; 5000 return;; 5001 }; 5002 }; 5003 if ((long_len >= ARRAY_SIZE(wbuf2)) || (fcompare(wbuf, wbuf2) != 0)) {; 5004 /* Short name is used. */; 5005 wbuf[0] = L'\0';; 5006 }; 5007}; 5008 ; 5009 ; 5010#if !defined(NO_FILESYSTEMS); 5011/* Get file informat",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:148550,Modifiability,config,config,148550," 4968 WideCharToMultiByte(; 4969 CP_UTF8, 0, wbuf, (int)wbuf_len, buf2, sizeof(buf2), NULL, NULL);; 4970 if (strcmp(buf, buf2) != 0) {; 4971 wbuf[0] = L'\0';; 4972 }; 4973 ; 4974 /* Windows file systems are not case sensitive, but you can still use; 4975 * uppercase and lowercase letters (on all modern file systems).; 4976 * The server can check if the URI uses the same upper/lowercase; 4977 * letters an the file system, effectively making Windows servers; 4978 * case sensitive (like Linux servers are). It is still not possible; 4979 * to use two files with the same name in different cases on Windows; 4980 * (like /a and /A) - this would be possible in Linux.; 4981 * As a default, Windows is not case sensitive, but the case sensitive; 4982 * file name check can be activated by an additional configuration. */; 4983 if (conn) {; 4984 if (conn->dom_ctx->config[CASE_SENSITIVE_FILES]; 4985 && !mg_strcasecmp(conn->dom_ctx->config[CASE_SENSITIVE_FILES],; 4986 ""yes"")) {; 4987 /* Use case sensitive compare function */; 4988 fcompare = wcscmp;; 4989 }; 4990 }; 4991 (void)conn; /* conn is currently unused */; 4992 ; 4993 /* Only accept a full file path, not a Windows short (8.3) path. */; 4994 memset(wbuf2, 0, ARRAY_SIZE(wbuf2) * sizeof(wchar_t));; 4995 long_len = GetLongPathNameW(wbuf, wbuf2, ARRAY_SIZE(wbuf2) - 1);; 4996 if (long_len == 0) {; 4997 err = GetLastError();; 4998 if (err == ERROR_FILE_NOT_FOUND) {; 4999 /* File does not exist. This is not always a problem here. */; 5000 return;; 5001 }; 5002 }; 5003 if ((long_len >= ARRAY_SIZE(wbuf2)) || (fcompare(wbuf, wbuf2) != 0)) {; 5004 /* Short name is used. */; 5005 wbuf[0] = L'\0';; 5006 }; 5007}; 5008 ; 5009 ; 5010#if !defined(NO_FILESYSTEMS); 5011/* Get file information, return 1 if file exists, 0 if not */; 5012static int; 5013mg_stat(const struct mg_connection *conn,; 5014 const char *path,; 5015 struct mg_file_stat *filep); 5016{; 5017 wchar_t wbuf[UTF16_PATH_MAX];; 5018 WIN32_FILE_ATTRIBUTE_DATA info;; 5019 time_t c",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:148618,Modifiability,config,config,148618," 4968 WideCharToMultiByte(; 4969 CP_UTF8, 0, wbuf, (int)wbuf_len, buf2, sizeof(buf2), NULL, NULL);; 4970 if (strcmp(buf, buf2) != 0) {; 4971 wbuf[0] = L'\0';; 4972 }; 4973 ; 4974 /* Windows file systems are not case sensitive, but you can still use; 4975 * uppercase and lowercase letters (on all modern file systems).; 4976 * The server can check if the URI uses the same upper/lowercase; 4977 * letters an the file system, effectively making Windows servers; 4978 * case sensitive (like Linux servers are). It is still not possible; 4979 * to use two files with the same name in different cases on Windows; 4980 * (like /a and /A) - this would be possible in Linux.; 4981 * As a default, Windows is not case sensitive, but the case sensitive; 4982 * file name check can be activated by an additional configuration. */; 4983 if (conn) {; 4984 if (conn->dom_ctx->config[CASE_SENSITIVE_FILES]; 4985 && !mg_strcasecmp(conn->dom_ctx->config[CASE_SENSITIVE_FILES],; 4986 ""yes"")) {; 4987 /* Use case sensitive compare function */; 4988 fcompare = wcscmp;; 4989 }; 4990 }; 4991 (void)conn; /* conn is currently unused */; 4992 ; 4993 /* Only accept a full file path, not a Windows short (8.3) path. */; 4994 memset(wbuf2, 0, ARRAY_SIZE(wbuf2) * sizeof(wchar_t));; 4995 long_len = GetLongPathNameW(wbuf, wbuf2, ARRAY_SIZE(wbuf2) - 1);; 4996 if (long_len == 0) {; 4997 err = GetLastError();; 4998 if (err == ERROR_FILE_NOT_FOUND) {; 4999 /* File does not exist. This is not always a problem here. */; 5000 return;; 5001 }; 5002 }; 5003 if ((long_len >= ARRAY_SIZE(wbuf2)) || (fcompare(wbuf, wbuf2) != 0)) {; 5004 /* Short name is used. */; 5005 wbuf[0] = L'\0';; 5006 }; 5007}; 5008 ; 5009 ; 5010#if !defined(NO_FILESYSTEMS); 5011/* Get file information, return 1 if file exists, 0 if not */; 5012static int; 5013mg_stat(const struct mg_connection *conn,; 5014 const char *path,; 5015 struct mg_file_stat *filep); 5016{; 5017 wchar_t wbuf[UTF16_PATH_MAX];; 5018 WIN32_FILE_ATTRIBUTE_DATA info;; 5019 time_t c",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:161531,Modifiability,inherit,inherited,161531,"r,; 5434 unsigned char cgi_config_idx); 5435{; 5436 HANDLE me;; 5437 char *interp;; 5438 char *interp_arg = 0;; 5439 char full_dir[UTF8_PATH_MAX], cmdline[UTF8_PATH_MAX], buf[UTF8_PATH_MAX];; 5440 int truncated;; 5441 struct mg_file file = STRUCT_FILE_INITIALIZER;; 5442 STARTUPINFOA si;; 5443 PROCESS_INFORMATION pi = {0};; 5444 ; 5445 (void)envp;; 5446 ; 5447 memset(&si, 0, sizeof(si));; 5448 si.cb = sizeof(si);; 5449 ; 5450 si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;; 5451 si.wShowWindow = SW_HIDE;; 5452 ; 5453 me = GetCurrentProcess();; 5454 DuplicateHandle(me,; 5455 (HANDLE)_get_osfhandle(fdin[0]),; 5456 me,; 5457 &si.hStdInput,; 5458 0,; 5459 TRUE,; 5460 DUPLICATE_SAME_ACCESS);; 5461 DuplicateHandle(me,; 5462 (HANDLE)_get_osfhandle(fdout[1]),; 5463 me,; 5464 &si.hStdOutput,; 5465 0,; 5466 TRUE,; 5467 DUPLICATE_SAME_ACCESS);; 5468 DuplicateHandle(me,; 5469 (HANDLE)_get_osfhandle(fderr[1]),; 5470 me,; 5471 &si.hStdError,; 5472 0,; 5473 TRUE,; 5474 DUPLICATE_SAME_ACCESS);; 5475 ; 5476 /* Mark handles that should not be inherited. See; 5477 * https://msdn.microsoft.com/en-us/library/windows/desktop/ms682499%28v=vs.85%29.aspx; 5478 */; 5479 SetHandleInformation((HANDLE)_get_osfhandle(fdin[1]),; 5480 HANDLE_FLAG_INHERIT,; 5481 0);; 5482 SetHandleInformation((HANDLE)_get_osfhandle(fdout[0]),; 5483 HANDLE_FLAG_INHERIT,; 5484 0);; 5485 SetHandleInformation((HANDLE)_get_osfhandle(fderr[0]),; 5486 HANDLE_FLAG_INHERIT,; 5487 0);; 5488 ; 5489 /* First check, if there is a CGI interpreter configured for all CGI; 5490 * scripts. */; 5491 interp = conn->dom_ctx->config[CGI_INTERPRETER + cgi_config_idx];; 5492 if (interp != NULL) {; 5493 /* If there is a configured interpreter, check for additional arguments; 5494 */; 5495 interp_arg =; 5496 conn->dom_ctx->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5497 } else {; 5498 /* Otherwise, the interpreter must be stated in the first line of the; 5499 * CGI script file, after a #! (shebang) mark. */; 5500 buf[0] = buf[",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:161999,Modifiability,config,configured,161999," ; 5447 memset(&si, 0, sizeof(si));; 5448 si.cb = sizeof(si);; 5449 ; 5450 si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;; 5451 si.wShowWindow = SW_HIDE;; 5452 ; 5453 me = GetCurrentProcess();; 5454 DuplicateHandle(me,; 5455 (HANDLE)_get_osfhandle(fdin[0]),; 5456 me,; 5457 &si.hStdInput,; 5458 0,; 5459 TRUE,; 5460 DUPLICATE_SAME_ACCESS);; 5461 DuplicateHandle(me,; 5462 (HANDLE)_get_osfhandle(fdout[1]),; 5463 me,; 5464 &si.hStdOutput,; 5465 0,; 5466 TRUE,; 5467 DUPLICATE_SAME_ACCESS);; 5468 DuplicateHandle(me,; 5469 (HANDLE)_get_osfhandle(fderr[1]),; 5470 me,; 5471 &si.hStdError,; 5472 0,; 5473 TRUE,; 5474 DUPLICATE_SAME_ACCESS);; 5475 ; 5476 /* Mark handles that should not be inherited. See; 5477 * https://msdn.microsoft.com/en-us/library/windows/desktop/ms682499%28v=vs.85%29.aspx; 5478 */; 5479 SetHandleInformation((HANDLE)_get_osfhandle(fdin[1]),; 5480 HANDLE_FLAG_INHERIT,; 5481 0);; 5482 SetHandleInformation((HANDLE)_get_osfhandle(fdout[0]),; 5483 HANDLE_FLAG_INHERIT,; 5484 0);; 5485 SetHandleInformation((HANDLE)_get_osfhandle(fderr[0]),; 5486 HANDLE_FLAG_INHERIT,; 5487 0);; 5488 ; 5489 /* First check, if there is a CGI interpreter configured for all CGI; 5490 * scripts. */; 5491 interp = conn->dom_ctx->config[CGI_INTERPRETER + cgi_config_idx];; 5492 if (interp != NULL) {; 5493 /* If there is a configured interpreter, check for additional arguments; 5494 */; 5495 interp_arg =; 5496 conn->dom_ctx->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5497 } else {; 5498 /* Otherwise, the interpreter must be stated in the first line of the; 5499 * CGI script file, after a #! (shebang) mark. */; 5500 buf[0] = buf[1] = '\0';; 5501 ; 5502 /* Get the full script path */; 5503 mg_snprintf(; 5504 conn, &truncated, cmdline, sizeof(cmdline), ""%s/%s"", dir, prog);; 5505 ; 5506 if (truncated) {; 5507 pi.hProcess = (pid_t)-1;; 5508 goto spawn_cleanup;; 5509 }; 5510 ; 5511 /* Open the script file, to read the first line */; 5512 if (mg_fopen(conn, cmdline, MG_FOPEN_MODE_REA",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:162072,Modifiability,config,config,162072,"]),; 5463 me,; 5464 &si.hStdOutput,; 5465 0,; 5466 TRUE,; 5467 DUPLICATE_SAME_ACCESS);; 5468 DuplicateHandle(me,; 5469 (HANDLE)_get_osfhandle(fderr[1]),; 5470 me,; 5471 &si.hStdError,; 5472 0,; 5473 TRUE,; 5474 DUPLICATE_SAME_ACCESS);; 5475 ; 5476 /* Mark handles that should not be inherited. See; 5477 * https://msdn.microsoft.com/en-us/library/windows/desktop/ms682499%28v=vs.85%29.aspx; 5478 */; 5479 SetHandleInformation((HANDLE)_get_osfhandle(fdin[1]),; 5480 HANDLE_FLAG_INHERIT,; 5481 0);; 5482 SetHandleInformation((HANDLE)_get_osfhandle(fdout[0]),; 5483 HANDLE_FLAG_INHERIT,; 5484 0);; 5485 SetHandleInformation((HANDLE)_get_osfhandle(fderr[0]),; 5486 HANDLE_FLAG_INHERIT,; 5487 0);; 5488 ; 5489 /* First check, if there is a CGI interpreter configured for all CGI; 5490 * scripts. */; 5491 interp = conn->dom_ctx->config[CGI_INTERPRETER + cgi_config_idx];; 5492 if (interp != NULL) {; 5493 /* If there is a configured interpreter, check for additional arguments; 5494 */; 5495 interp_arg =; 5496 conn->dom_ctx->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5497 } else {; 5498 /* Otherwise, the interpreter must be stated in the first line of the; 5499 * CGI script file, after a #! (shebang) mark. */; 5500 buf[0] = buf[1] = '\0';; 5501 ; 5502 /* Get the full script path */; 5503 mg_snprintf(; 5504 conn, &truncated, cmdline, sizeof(cmdline), ""%s/%s"", dir, prog);; 5505 ; 5506 if (truncated) {; 5507 pi.hProcess = (pid_t)-1;; 5508 goto spawn_cleanup;; 5509 }; 5510 ; 5511 /* Open the script file, to read the first line */; 5512 if (mg_fopen(conn, cmdline, MG_FOPEN_MODE_READ, &file)) {; 5513 ; 5514 /* Read the first line of the script into the buffer */; 5515 mg_fgets(buf, sizeof(buf), &file);; 5516 (void)mg_fclose(&file.access); /* ignore error on read only file */; 5517 buf[sizeof(buf) - 1] = '\0';; 5518 }; 5519 ; 5520 if ((buf[0] == '#') && (buf[1] == '!')) {; 5521 trim_trailing_whitespaces(buf + 2);; 5522 } else {; 5523 buf[2] = '\0';; 5524 }; 5525 interp = buf + 2;; 5526 }",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:162165,Modifiability,config,configured,162165,"]),; 5463 me,; 5464 &si.hStdOutput,; 5465 0,; 5466 TRUE,; 5467 DUPLICATE_SAME_ACCESS);; 5468 DuplicateHandle(me,; 5469 (HANDLE)_get_osfhandle(fderr[1]),; 5470 me,; 5471 &si.hStdError,; 5472 0,; 5473 TRUE,; 5474 DUPLICATE_SAME_ACCESS);; 5475 ; 5476 /* Mark handles that should not be inherited. See; 5477 * https://msdn.microsoft.com/en-us/library/windows/desktop/ms682499%28v=vs.85%29.aspx; 5478 */; 5479 SetHandleInformation((HANDLE)_get_osfhandle(fdin[1]),; 5480 HANDLE_FLAG_INHERIT,; 5481 0);; 5482 SetHandleInformation((HANDLE)_get_osfhandle(fdout[0]),; 5483 HANDLE_FLAG_INHERIT,; 5484 0);; 5485 SetHandleInformation((HANDLE)_get_osfhandle(fderr[0]),; 5486 HANDLE_FLAG_INHERIT,; 5487 0);; 5488 ; 5489 /* First check, if there is a CGI interpreter configured for all CGI; 5490 * scripts. */; 5491 interp = conn->dom_ctx->config[CGI_INTERPRETER + cgi_config_idx];; 5492 if (interp != NULL) {; 5493 /* If there is a configured interpreter, check for additional arguments; 5494 */; 5495 interp_arg =; 5496 conn->dom_ctx->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5497 } else {; 5498 /* Otherwise, the interpreter must be stated in the first line of the; 5499 * CGI script file, after a #! (shebang) mark. */; 5500 buf[0] = buf[1] = '\0';; 5501 ; 5502 /* Get the full script path */; 5503 mg_snprintf(; 5504 conn, &truncated, cmdline, sizeof(cmdline), ""%s/%s"", dir, prog);; 5505 ; 5506 if (truncated) {; 5507 pi.hProcess = (pid_t)-1;; 5508 goto spawn_cleanup;; 5509 }; 5510 ; 5511 /* Open the script file, to read the first line */; 5512 if (mg_fopen(conn, cmdline, MG_FOPEN_MODE_READ, &file)) {; 5513 ; 5514 /* Read the first line of the script into the buffer */; 5515 mg_fgets(buf, sizeof(buf), &file);; 5516 (void)mg_fclose(&file.access); /* ignore error on read only file */; 5517 buf[sizeof(buf) - 1] = '\0';; 5518 }; 5519 ; 5520 if ((buf[0] == '#') && (buf[1] == '!')) {; 5521 trim_trailing_whitespaces(buf + 2);; 5522 } else {; 5523 buf[2] = '\0';; 5524 }; 5525 interp = buf + 2;; 5526 }",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:162269,Modifiability,config,config,162269,"]),; 5463 me,; 5464 &si.hStdOutput,; 5465 0,; 5466 TRUE,; 5467 DUPLICATE_SAME_ACCESS);; 5468 DuplicateHandle(me,; 5469 (HANDLE)_get_osfhandle(fderr[1]),; 5470 me,; 5471 &si.hStdError,; 5472 0,; 5473 TRUE,; 5474 DUPLICATE_SAME_ACCESS);; 5475 ; 5476 /* Mark handles that should not be inherited. See; 5477 * https://msdn.microsoft.com/en-us/library/windows/desktop/ms682499%28v=vs.85%29.aspx; 5478 */; 5479 SetHandleInformation((HANDLE)_get_osfhandle(fdin[1]),; 5480 HANDLE_FLAG_INHERIT,; 5481 0);; 5482 SetHandleInformation((HANDLE)_get_osfhandle(fdout[0]),; 5483 HANDLE_FLAG_INHERIT,; 5484 0);; 5485 SetHandleInformation((HANDLE)_get_osfhandle(fderr[0]),; 5486 HANDLE_FLAG_INHERIT,; 5487 0);; 5488 ; 5489 /* First check, if there is a CGI interpreter configured for all CGI; 5490 * scripts. */; 5491 interp = conn->dom_ctx->config[CGI_INTERPRETER + cgi_config_idx];; 5492 if (interp != NULL) {; 5493 /* If there is a configured interpreter, check for additional arguments; 5494 */; 5495 interp_arg =; 5496 conn->dom_ctx->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5497 } else {; 5498 /* Otherwise, the interpreter must be stated in the first line of the; 5499 * CGI script file, after a #! (shebang) mark. */; 5500 buf[0] = buf[1] = '\0';; 5501 ; 5502 /* Get the full script path */; 5503 mg_snprintf(; 5504 conn, &truncated, cmdline, sizeof(cmdline), ""%s/%s"", dir, prog);; 5505 ; 5506 if (truncated) {; 5507 pi.hProcess = (pid_t)-1;; 5508 goto spawn_cleanup;; 5509 }; 5510 ; 5511 /* Open the script file, to read the first line */; 5512 if (mg_fopen(conn, cmdline, MG_FOPEN_MODE_READ, &file)) {; 5513 ; 5514 /* Read the first line of the script into the buffer */; 5515 mg_fgets(buf, sizeof(buf), &file);; 5516 (void)mg_fclose(&file.access); /* ignore error on read only file */; 5517 buf[sizeof(buf) - 1] = '\0';; 5518 }; 5519 ; 5520 if ((buf[0] == '#') && (buf[1] == '!')) {; 5521 trim_trailing_whitespaces(buf + 2);; 5522 } else {; 5523 buf[2] = '\0';; 5524 }; 5525 interp = buf + 2;; 5526 }",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:170766,Modifiability,config,config,170766,"SIGCHLD's handler; 5803 * will leave unchanged after exec if it was set to be ignored.; 5804 * Restore it to default action. */; 5805 memset(&sa, 0, sizeof(sa));; 5806 sa.sa_handler = SIG_DFL;; 5807 sigaction(SIGCHLD, &sa, NULL);; 5808 ; 5809 interp = conn->dom_ctx->config[CGI_INTERPRETER + cgi_config_idx];; 5810 if (interp == NULL) {; 5811 /* no interpreter configured, call the programm directly */; 5812 (void)execle(prog, prog, NULL, envp);; 5813 mg_cry_internal(conn,; 5814 ""%s: execle(%s): %s"",; 5815 __func__,; 5816 prog,; 5817 strerror(ERRNO));; 5818 } else {; 5819 /* call the configured interpreter */; 5820 const char *interp_args =; 5821 conn->dom_ctx; 5822 ->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5823 ; 5824 if ((interp_args != NULL) && (interp_args[0] != 0)) {; 5825 (void)execle(interp, interp, interp_args, prog, NULL, envp);; 5826 } else {; 5827 (void)execle(interp, interp, prog, NULL, envp);; 5828 }; 5829 mg_cry_internal(conn,; 5830 ""%s: execle(%s %s): %s"",; 5831 __func__,; 5832 interp,; 5833 prog,; 5834 strerror(ERRNO));; 5835 }; 5836 }; 5837 exit(EXIT_FAILURE);; 5838 }; 5839 ; 5840 return pid;; 5841}; 5842#endif /* !NO_CGI */; 5843 ; 5844 ; 5845static int; 5846set_non_blocking_mode(SOCKET sock); 5847{; 5848 int flags = fcntl(sock, F_GETFL, 0);; 5849 if (flags < 0) {; 5850 return -1;; 5851 }; 5852 ; 5853 if (fcntl(sock, F_SETFL, (flags | O_NONBLOCK)) < 0) {; 5854 return -1;; 5855 }; 5856 return 0;; 5857}; 5858 ; 5859static int; 5860set_blocking_mode(SOCKET sock); 5861{; 5862 int flags = fcntl(sock, F_GETFL, 0);; 5863 if (flags < 0) {; 5864 return -1;; 5865 }; 5866 ; 5867 if (fcntl(sock, F_SETFL, flags & (~(int)(O_NONBLOCK))) < 0) {; 5868 return -1;; 5869 }; 5870 return 0;; 5871}; 5872#endif /* _WIN32 / else */; 5873 ; 5874/* End of initial operating system specific define block. */; 5875 ; 5876 ; 5877/* Get a random number (independent of C rand function) */; 5878static uint64_t; 5879get_random(void); 5880{; 5881 static uint64_t lfsr = 0; /* Line",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:170860,Modifiability,config,configured,170860,"SIGCHLD's handler; 5803 * will leave unchanged after exec if it was set to be ignored.; 5804 * Restore it to default action. */; 5805 memset(&sa, 0, sizeof(sa));; 5806 sa.sa_handler = SIG_DFL;; 5807 sigaction(SIGCHLD, &sa, NULL);; 5808 ; 5809 interp = conn->dom_ctx->config[CGI_INTERPRETER + cgi_config_idx];; 5810 if (interp == NULL) {; 5811 /* no interpreter configured, call the programm directly */; 5812 (void)execle(prog, prog, NULL, envp);; 5813 mg_cry_internal(conn,; 5814 ""%s: execle(%s): %s"",; 5815 __func__,; 5816 prog,; 5817 strerror(ERRNO));; 5818 } else {; 5819 /* call the configured interpreter */; 5820 const char *interp_args =; 5821 conn->dom_ctx; 5822 ->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5823 ; 5824 if ((interp_args != NULL) && (interp_args[0] != 0)) {; 5825 (void)execle(interp, interp, interp_args, prog, NULL, envp);; 5826 } else {; 5827 (void)execle(interp, interp, prog, NULL, envp);; 5828 }; 5829 mg_cry_internal(conn,; 5830 ""%s: execle(%s %s): %s"",; 5831 __func__,; 5832 interp,; 5833 prog,; 5834 strerror(ERRNO));; 5835 }; 5836 }; 5837 exit(EXIT_FAILURE);; 5838 }; 5839 ; 5840 return pid;; 5841}; 5842#endif /* !NO_CGI */; 5843 ; 5844 ; 5845static int; 5846set_non_blocking_mode(SOCKET sock); 5847{; 5848 int flags = fcntl(sock, F_GETFL, 0);; 5849 if (flags < 0) {; 5850 return -1;; 5851 }; 5852 ; 5853 if (fcntl(sock, F_SETFL, (flags | O_NONBLOCK)) < 0) {; 5854 return -1;; 5855 }; 5856 return 0;; 5857}; 5858 ; 5859static int; 5860set_blocking_mode(SOCKET sock); 5861{; 5862 int flags = fcntl(sock, F_GETFL, 0);; 5863 if (flags < 0) {; 5864 return -1;; 5865 }; 5866 ; 5867 if (fcntl(sock, F_SETFL, flags & (~(int)(O_NONBLOCK))) < 0) {; 5868 return -1;; 5869 }; 5870 return 0;; 5871}; 5872#endif /* _WIN32 / else */; 5873 ; 5874/* End of initial operating system specific define block. */; 5875 ; 5876 ; 5877/* Get a random number (independent of C rand function) */; 5878static uint64_t; 5879get_random(void); 5880{; 5881 static uint64_t lfsr = 0; /* Line",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:171087,Modifiability,config,configured,171087,"SIGCHLD's handler; 5803 * will leave unchanged after exec if it was set to be ignored.; 5804 * Restore it to default action. */; 5805 memset(&sa, 0, sizeof(sa));; 5806 sa.sa_handler = SIG_DFL;; 5807 sigaction(SIGCHLD, &sa, NULL);; 5808 ; 5809 interp = conn->dom_ctx->config[CGI_INTERPRETER + cgi_config_idx];; 5810 if (interp == NULL) {; 5811 /* no interpreter configured, call the programm directly */; 5812 (void)execle(prog, prog, NULL, envp);; 5813 mg_cry_internal(conn,; 5814 ""%s: execle(%s): %s"",; 5815 __func__,; 5816 prog,; 5817 strerror(ERRNO));; 5818 } else {; 5819 /* call the configured interpreter */; 5820 const char *interp_args =; 5821 conn->dom_ctx; 5822 ->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5823 ; 5824 if ((interp_args != NULL) && (interp_args[0] != 0)) {; 5825 (void)execle(interp, interp, interp_args, prog, NULL, envp);; 5826 } else {; 5827 (void)execle(interp, interp, prog, NULL, envp);; 5828 }; 5829 mg_cry_internal(conn,; 5830 ""%s: execle(%s %s): %s"",; 5831 __func__,; 5832 interp,; 5833 prog,; 5834 strerror(ERRNO));; 5835 }; 5836 }; 5837 exit(EXIT_FAILURE);; 5838 }; 5839 ; 5840 return pid;; 5841}; 5842#endif /* !NO_CGI */; 5843 ; 5844 ; 5845static int; 5846set_non_blocking_mode(SOCKET sock); 5847{; 5848 int flags = fcntl(sock, F_GETFL, 0);; 5849 if (flags < 0) {; 5850 return -1;; 5851 }; 5852 ; 5853 if (fcntl(sock, F_SETFL, (flags | O_NONBLOCK)) < 0) {; 5854 return -1;; 5855 }; 5856 return 0;; 5857}; 5858 ; 5859static int; 5860set_blocking_mode(SOCKET sock); 5861{; 5862 int flags = fcntl(sock, F_GETFL, 0);; 5863 if (flags < 0) {; 5864 return -1;; 5865 }; 5866 ; 5867 if (fcntl(sock, F_SETFL, flags & (~(int)(O_NONBLOCK))) < 0) {; 5868 return -1;; 5869 }; 5870 return 0;; 5871}; 5872#endif /* _WIN32 / else */; 5873 ; 5874/* End of initial operating system specific define block. */; 5875 ; 5876 ; 5877/* Get a random number (independent of C rand function) */; 5878static uint64_t; 5879get_random(void); 5880{; 5881 static uint64_t lfsr = 0; /* Line",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:171173,Modifiability,config,config,171173,"SIGCHLD's handler; 5803 * will leave unchanged after exec if it was set to be ignored.; 5804 * Restore it to default action. */; 5805 memset(&sa, 0, sizeof(sa));; 5806 sa.sa_handler = SIG_DFL;; 5807 sigaction(SIGCHLD, &sa, NULL);; 5808 ; 5809 interp = conn->dom_ctx->config[CGI_INTERPRETER + cgi_config_idx];; 5810 if (interp == NULL) {; 5811 /* no interpreter configured, call the programm directly */; 5812 (void)execle(prog, prog, NULL, envp);; 5813 mg_cry_internal(conn,; 5814 ""%s: execle(%s): %s"",; 5815 __func__,; 5816 prog,; 5817 strerror(ERRNO));; 5818 } else {; 5819 /* call the configured interpreter */; 5820 const char *interp_args =; 5821 conn->dom_ctx; 5822 ->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5823 ; 5824 if ((interp_args != NULL) && (interp_args[0] != 0)) {; 5825 (void)execle(interp, interp, interp_args, prog, NULL, envp);; 5826 } else {; 5827 (void)execle(interp, interp, prog, NULL, envp);; 5828 }; 5829 mg_cry_internal(conn,; 5830 ""%s: execle(%s %s): %s"",; 5831 __func__,; 5832 interp,; 5833 prog,; 5834 strerror(ERRNO));; 5835 }; 5836 }; 5837 exit(EXIT_FAILURE);; 5838 }; 5839 ; 5840 return pid;; 5841}; 5842#endif /* !NO_CGI */; 5843 ; 5844 ; 5845static int; 5846set_non_blocking_mode(SOCKET sock); 5847{; 5848 int flags = fcntl(sock, F_GETFL, 0);; 5849 if (flags < 0) {; 5850 return -1;; 5851 }; 5852 ; 5853 if (fcntl(sock, F_SETFL, (flags | O_NONBLOCK)) < 0) {; 5854 return -1;; 5855 }; 5856 return 0;; 5857}; 5858 ; 5859static int; 5860set_blocking_mode(SOCKET sock); 5861{; 5862 int flags = fcntl(sock, F_GETFL, 0);; 5863 if (flags < 0) {; 5864 return -1;; 5865 }; 5866 ; 5867 if (fcntl(sock, F_SETFL, flags & (~(int)(O_NONBLOCK))) < 0) {; 5868 return -1;; 5869 }; 5870 return 0;; 5871}; 5872#endif /* _WIN32 / else */; 5873 ; 5874/* End of initial operating system specific define block. */; 5875 ; 5876 ; 5877/* Get a random number (independent of C rand function) */; 5878static uint64_t; 5879get_random(void); 5880{; 5881 static uint64_t lfsr = 0; /* Line",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:179413,Modifiability,config,config,179413," {; 6104 /* For sockets, wait for the socket using poll */; 6105 struct mg_pollfd pfd[1];; 6106 int pollres;; 6107 ; 6108 pfd[0].fd = sock;; 6109 pfd[0].events = POLLOUT;; 6110 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6111 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6112 return -2;; 6113 }; 6114 if (pollres > 0) {; 6115 continue;; 6116 }; 6117 }; 6118 ; 6119 if (timeout > 0) {; 6120 now = mg_get_current_time_ns();; 6121 if ((now - start) > timeout_ns) {; 6122 /* Timeout */; 6123 break;; 6124 }; 6125 }; 6126 }; 6127 ; 6128 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6129 used */; 6130 ; 6131 return -1;; 6132}; 6133 ; 6134 ; 6135static int; 6136push_all(struct mg_context *ctx,; 6137 FILE *fp,; 6138 SOCKET sock,; 6139 SSL *ssl,; 6140 const char *buf,; 6141 int len); 6142{; 6143 double timeout = -1.0;; 6144 int n, nwritten = 0;; 6145 ; 6146 if (ctx == NULL) {; 6147 return -1;; 6148 }; 6149 ; 6150 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6151 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6152 }; 6153 if (timeout <= 0.0) {; 6154 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6155 / 1000.0;; 6156 }; 6157 ; 6158 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6159 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6160 if (n < 0) {; 6161 if (nwritten == 0) {; 6162 nwritten = -1; /* Propagate the error */; 6163 }; 6164 break;; 6165 } else if (n == 0) {; 6166 break; /* No more data to write */; 6167 } else {; 6168 nwritten += n;; 6169 len -= n;; 6170 }; 6171 }; 6172 ; 6173 return nwritten;; 6174}; 6175 ; 6176 ; 6177/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6178 * Return value:; 6179 * >=0 .. number of bytes successfully read; 6180 * -1 .. timeout; 6181 * -2 .. error; 6182 */; 6183static int; 6184pull_inner(FILE *fp,; 6185 struct mg_connection *conn,; 6186 char *buf,; 6187 int len,; 6188 double timeout); 6189{; 6190 int nread,",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:179469,Modifiability,config,config,179469," using poll */; 6105 struct mg_pollfd pfd[1];; 6106 int pollres;; 6107 ; 6108 pfd[0].fd = sock;; 6109 pfd[0].events = POLLOUT;; 6110 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6111 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6112 return -2;; 6113 }; 6114 if (pollres > 0) {; 6115 continue;; 6116 }; 6117 }; 6118 ; 6119 if (timeout > 0) {; 6120 now = mg_get_current_time_ns();; 6121 if ((now - start) > timeout_ns) {; 6122 /* Timeout */; 6123 break;; 6124 }; 6125 }; 6126 }; 6127 ; 6128 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6129 used */; 6130 ; 6131 return -1;; 6132}; 6133 ; 6134 ; 6135static int; 6136push_all(struct mg_context *ctx,; 6137 FILE *fp,; 6138 SOCKET sock,; 6139 SSL *ssl,; 6140 const char *buf,; 6141 int len); 6142{; 6143 double timeout = -1.0;; 6144 int n, nwritten = 0;; 6145 ; 6146 if (ctx == NULL) {; 6147 return -1;; 6148 }; 6149 ; 6150 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6151 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6152 }; 6153 if (timeout <= 0.0) {; 6154 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6155 / 1000.0;; 6156 }; 6157 ; 6158 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6159 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6160 if (n < 0) {; 6161 if (nwritten == 0) {; 6162 nwritten = -1; /* Propagate the error */; 6163 }; 6164 break;; 6165 } else if (n == 0) {; 6166 break; /* No more data to write */; 6167 } else {; 6168 nwritten += n;; 6169 len -= n;; 6170 }; 6171 }; 6172 ; 6173 return nwritten;; 6174}; 6175 ; 6176 ; 6177/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6178 * Return value:; 6179 * >=0 .. number of bytes successfully read; 6180 * -1 .. timeout; 6181 * -2 .. error; 6182 */; 6183static int; 6184pull_inner(FILE *fp,; 6185 struct mg_connection *conn,; 6186 char *buf,; 6187 int len,; 6188 double timeout); 6189{; 6190 int nread, err = 0;; 6191 ; 6192#if defined(_WIN32); 6",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:186995,Modifiability,config,config,186995,"e have to wait for the timeout in both cases for now.; 6387 */; 6388 if (ERROR_TRY_AGAIN(err)) {; 6389 /* TODO (low): check if this is still required */; 6390 /* EAGAIN/EWOULDBLOCK:; 6391 * standard case if called from close_socket_gracefully; 6392 * => should return -1 */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6420 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6421 }; 6422 if (timeout <= 0.0) {; 6423 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6424 / 1000.0;; 6425 }; 6426 start_time = mg_get_current_time_ns();; 6427 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6428 ; 6429 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6430 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6431 if (n == -2) {; 6432 if (nread == 0) {; 6433 nread = -1; /* Propagate the error */; 6434 }; 6435 break;; 6436 } else if (n == -1) {; 6437 /* timeout */; 6438 if (timeout >= 0.0) {; 6439 now = mg_get_current_time_ns();; 6440 if ((now - start_time) <= timeout_ns) {; 6441 continue;; 6442 }; 6443 }; 6444 break;; 6445 } else if (n == 0) {; 6446 break; /* No more data to read */; 6447 } else {; 6448 nread += n;; 6449 len -= n;; 6450 }; 6451 }; 6452 ; 6453 return nread;; 6454}; 6455 ; 6456 ; 6457static void; 6458discard_unread_re",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:187058,Modifiability,config,config,187058,"e have to wait for the timeout in both cases for now.; 6387 */; 6388 if (ERROR_TRY_AGAIN(err)) {; 6389 /* TODO (low): check if this is still required */; 6390 /* EAGAIN/EWOULDBLOCK:; 6391 * standard case if called from close_socket_gracefully; 6392 * => should return -1 */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6420 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6421 }; 6422 if (timeout <= 0.0) {; 6423 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6424 / 1000.0;; 6425 }; 6426 start_time = mg_get_current_time_ns();; 6427 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6428 ; 6429 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6430 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6431 if (n == -2) {; 6432 if (nread == 0) {; 6433 nread = -1; /* Propagate the error */; 6434 }; 6435 break;; 6436 } else if (n == -1) {; 6437 /* timeout */; 6438 if (timeout >= 0.0) {; 6439 now = mg_get_current_time_ns();; 6440 if ((now - start_time) <= timeout_ns) {; 6441 continue;; 6442 }; 6443 }; 6444 break;; 6445 } else if (n == 0) {; 6446 break; /* No more data to read */; 6447 } else {; 6448 nread += n;; 6449 len -= n;; 6450 }; 6451 }; 6452 ; 6453 return nread;; 6454}; 6455 ; 6456 ; 6457static void; 6458discard_unread_re",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:202757,Modifiability,variab,variable,202757,"96 return mg_get_var2(data, data_len, name, dst, dst_len, 0);; 6997}; 6998 ; 6999 ; 7000int; 7001mg_get_var2(const char *data,; 7002 size_t data_len,; 7003 const char *name,; 7004 char *dst,; 7005 size_t dst_len,; 7006 size_t occurrence); 7007{; 7008 const char *p, *e, *s;; 7009 size_t name_len;; 7010 int len;; 7011 ; 7012 if ((dst == NULL) || (dst_len == 0)) {; 7013 len = -2;; 7014 } else if ((data == NULL) || (name == NULL) || (data_len == 0)) {; 7015 len = -1;; 7016 dst[0] = '\0';; 7017 } else {; 7018 name_len = strlen(name);; 7019 e = data + data_len;; 7020 len = -1;; 7021 dst[0] = '\0';; 7022 ; 7023 /* data is ""var1=val1&var2=val2..."". Find variable first */; 7024 for (p = data; p + name_len < e; p++) {; 7025 if (((p == data) || (p[-1] == '&')) && (p[name_len] == '='); 7026 && !mg_strncasecmp(name, p, name_len) && 0 == occurrence--) {; 7027 /* Point p to variable value */; 7028 p += name_len + 1;; 7029 ; 7030 /* Point s to the end of the value */; 7031 s = (const char *)memchr(p, '&', (size_t)(e - p));; 7032 if (s == NULL) {; 7033 s = e;; 7034 }; 7035 DEBUG_ASSERT(s >= p);; 7036 if (s < p) {; 7037 return -3;; 7038 }; 7039 ; 7040 /* Decode variable into destination buffer */; 7041 len = mg_url_decode(p, (int)(s - p), dst, (int)dst_len, 1);; 7042 ; 7043 /* Redirect error code from -1 to -2 (destination buffer too; 7044 * small). */; 7045 if (len == -1) {; 7046 len = -2;; 7047 }; 7048 break;; 7049 }; 7050 }; 7051 }; 7052 ; 7053 return len;; 7054}; 7055 ; 7056 ; 7057/* split a string ""key1=val1&key2=val2"" into key/value pairs */; 7058int; 7059mg_split_form_urlencoded(char *data,; 7060 struct mg_header *form_fields,; 7061 unsigned num_form_fields); 7062{; 7063 char *b;; 7064 int i;; 7065 int num = 0;; 7066 ; 7067 if (data == NULL) {; 7068 /* parameter error */; 7069 return -1;; 7070 }; 7071 ; 7072 if ((form_fields == NULL) && (num_form_fields == 0)) {; 7073 /* determine the number of expected fields */; 7074 if (data[0] == 0) {; 7075 return 0;; 7076 }; 7077 /* count ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:202975,Modifiability,variab,variable,202975,"96 return mg_get_var2(data, data_len, name, dst, dst_len, 0);; 6997}; 6998 ; 6999 ; 7000int; 7001mg_get_var2(const char *data,; 7002 size_t data_len,; 7003 const char *name,; 7004 char *dst,; 7005 size_t dst_len,; 7006 size_t occurrence); 7007{; 7008 const char *p, *e, *s;; 7009 size_t name_len;; 7010 int len;; 7011 ; 7012 if ((dst == NULL) || (dst_len == 0)) {; 7013 len = -2;; 7014 } else if ((data == NULL) || (name == NULL) || (data_len == 0)) {; 7015 len = -1;; 7016 dst[0] = '\0';; 7017 } else {; 7018 name_len = strlen(name);; 7019 e = data + data_len;; 7020 len = -1;; 7021 dst[0] = '\0';; 7022 ; 7023 /* data is ""var1=val1&var2=val2..."". Find variable first */; 7024 for (p = data; p + name_len < e; p++) {; 7025 if (((p == data) || (p[-1] == '&')) && (p[name_len] == '='); 7026 && !mg_strncasecmp(name, p, name_len) && 0 == occurrence--) {; 7027 /* Point p to variable value */; 7028 p += name_len + 1;; 7029 ; 7030 /* Point s to the end of the value */; 7031 s = (const char *)memchr(p, '&', (size_t)(e - p));; 7032 if (s == NULL) {; 7033 s = e;; 7034 }; 7035 DEBUG_ASSERT(s >= p);; 7036 if (s < p) {; 7037 return -3;; 7038 }; 7039 ; 7040 /* Decode variable into destination buffer */; 7041 len = mg_url_decode(p, (int)(s - p), dst, (int)dst_len, 1);; 7042 ; 7043 /* Redirect error code from -1 to -2 (destination buffer too; 7044 * small). */; 7045 if (len == -1) {; 7046 len = -2;; 7047 }; 7048 break;; 7049 }; 7050 }; 7051 }; 7052 ; 7053 return len;; 7054}; 7055 ; 7056 ; 7057/* split a string ""key1=val1&key2=val2"" into key/value pairs */; 7058int; 7059mg_split_form_urlencoded(char *data,; 7060 struct mg_header *form_fields,; 7061 unsigned num_form_fields); 7062{; 7063 char *b;; 7064 int i;; 7065 int num = 0;; 7066 ; 7067 if (data == NULL) {; 7068 /* parameter error */; 7069 return -1;; 7070 }; 7071 ; 7072 if ((form_fields == NULL) && (num_form_fields == 0)) {; 7073 /* determine the number of expected fields */; 7074 if (data[0] == 0) {; 7075 return 0;; 7076 }; 7077 /* count ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:203265,Modifiability,variab,variable,203265,"96 return mg_get_var2(data, data_len, name, dst, dst_len, 0);; 6997}; 6998 ; 6999 ; 7000int; 7001mg_get_var2(const char *data,; 7002 size_t data_len,; 7003 const char *name,; 7004 char *dst,; 7005 size_t dst_len,; 7006 size_t occurrence); 7007{; 7008 const char *p, *e, *s;; 7009 size_t name_len;; 7010 int len;; 7011 ; 7012 if ((dst == NULL) || (dst_len == 0)) {; 7013 len = -2;; 7014 } else if ((data == NULL) || (name == NULL) || (data_len == 0)) {; 7015 len = -1;; 7016 dst[0] = '\0';; 7017 } else {; 7018 name_len = strlen(name);; 7019 e = data + data_len;; 7020 len = -1;; 7021 dst[0] = '\0';; 7022 ; 7023 /* data is ""var1=val1&var2=val2..."". Find variable first */; 7024 for (p = data; p + name_len < e; p++) {; 7025 if (((p == data) || (p[-1] == '&')) && (p[name_len] == '='); 7026 && !mg_strncasecmp(name, p, name_len) && 0 == occurrence--) {; 7027 /* Point p to variable value */; 7028 p += name_len + 1;; 7029 ; 7030 /* Point s to the end of the value */; 7031 s = (const char *)memchr(p, '&', (size_t)(e - p));; 7032 if (s == NULL) {; 7033 s = e;; 7034 }; 7035 DEBUG_ASSERT(s >= p);; 7036 if (s < p) {; 7037 return -3;; 7038 }; 7039 ; 7040 /* Decode variable into destination buffer */; 7041 len = mg_url_decode(p, (int)(s - p), dst, (int)dst_len, 1);; 7042 ; 7043 /* Redirect error code from -1 to -2 (destination buffer too; 7044 * small). */; 7045 if (len == -1) {; 7046 len = -2;; 7047 }; 7048 break;; 7049 }; 7050 }; 7051 }; 7052 ; 7053 return len;; 7054}; 7055 ; 7056 ; 7057/* split a string ""key1=val1&key2=val2"" into key/value pairs */; 7058int; 7059mg_split_form_urlencoded(char *data,; 7060 struct mg_header *form_fields,; 7061 unsigned num_form_fields); 7062{; 7063 char *b;; 7064 int i;; 7065 int num = 0;; 7066 ; 7067 if (data == NULL) {; 7068 /* parameter error */; 7069 return -1;; 7070 }; 7071 ; 7072 if ((form_fields == NULL) && (num_form_fields == 0)) {; 7073 /* determine the number of expected fields */; 7074 if (data[0] == 0) {; 7075 return 0;; 7076 }; 7077 /* count ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:210127,Modifiability,config,config,210127,"+ (c >> 2);; 7294 if (d != 255) {; 7295 dst[(*dst_len)++] = (c << 6) + d;; 7296 }; 7297 }; 7298 }; 7299 return -1;; 7300}; 7301#endif; 7302 ; 7303 ; 7304static int; 7305is_put_or_delete_method(const struct mg_connection *conn); 7306{; 7307 if (conn) {; 7308 const char *s = conn->request_info.request_method;; 7309 return (s != NULL); 7310 && (!strcmp(s, ""PUT"") || !strcmp(s, ""DELETE""); 7311 || !strcmp(s, ""MKCOL"") || !strcmp(s, ""PATCH""));; 7312 }; 7313 return 0;; 7314}; 7315 ; 7316 ; 7317#if !defined(NO_FILES); 7318static int; 7319extention_matches_script(; 7320 struct mg_connection *conn, /* in: request (must be valid) */; 7321 const char *filename /* in: filename (must be valid) */; 7322); 7323{; 7324#if !defined(NO_CGI); 7325 unsigned char cgi_config_idx, inc, max;; 7326#endif; 7327 ; 7328#if defined(USE_LUA); 7329 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS],; 7330 filename); 7331 > 0) {; 7332 return 1;; 7333 }; 7334#endif; 7335#if defined(USE_DUKTAPE); 7336 if (match_prefix_strlen(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],; 7337 filename); 7338 > 0) {; 7339 return 1;; 7340 }; 7341#endif; 7342#if !defined(NO_CGI); 7343 inc = CGI2_EXTENSIONS - CGI_EXTENSIONS;; 7344 max = PUT_DELETE_PASSWORDS_FILE - CGI_EXTENSIONS;; 7345 for (cgi_config_idx = 0; cgi_config_idx < max; cgi_config_idx += inc) {; 7346 if ((conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx] != NULL); 7347 && (match_prefix_strlen(; 7348 conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx],; 7349 filename); 7350 > 0)) {; 7351 return 1;; 7352 }; 7353 }; 7354#endif; 7355 /* filename and conn could be unused, if all preocessor conditions; 7356 * are false (no script language supported). */; 7357 (void)filename;; 7358 (void)conn;; 7359 ; 7360 return 0;; 7361}; 7362 ; 7363 ; 7364static int; 7365extention_matches_template_text(; 7366 struct mg_connection *conn, /* in: request (must be valid) */; 7367 const char *filename /* in: filename (must be valid) */; 7368); 7369{; 7370#i",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:210298,Modifiability,config,config,210298,"+ (c >> 2);; 7294 if (d != 255) {; 7295 dst[(*dst_len)++] = (c << 6) + d;; 7296 }; 7297 }; 7298 }; 7299 return -1;; 7300}; 7301#endif; 7302 ; 7303 ; 7304static int; 7305is_put_or_delete_method(const struct mg_connection *conn); 7306{; 7307 if (conn) {; 7308 const char *s = conn->request_info.request_method;; 7309 return (s != NULL); 7310 && (!strcmp(s, ""PUT"") || !strcmp(s, ""DELETE""); 7311 || !strcmp(s, ""MKCOL"") || !strcmp(s, ""PATCH""));; 7312 }; 7313 return 0;; 7314}; 7315 ; 7316 ; 7317#if !defined(NO_FILES); 7318static int; 7319extention_matches_script(; 7320 struct mg_connection *conn, /* in: request (must be valid) */; 7321 const char *filename /* in: filename (must be valid) */; 7322); 7323{; 7324#if !defined(NO_CGI); 7325 unsigned char cgi_config_idx, inc, max;; 7326#endif; 7327 ; 7328#if defined(USE_LUA); 7329 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS],; 7330 filename); 7331 > 0) {; 7332 return 1;; 7333 }; 7334#endif; 7335#if defined(USE_DUKTAPE); 7336 if (match_prefix_strlen(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],; 7337 filename); 7338 > 0) {; 7339 return 1;; 7340 }; 7341#endif; 7342#if !defined(NO_CGI); 7343 inc = CGI2_EXTENSIONS - CGI_EXTENSIONS;; 7344 max = PUT_DELETE_PASSWORDS_FILE - CGI_EXTENSIONS;; 7345 for (cgi_config_idx = 0; cgi_config_idx < max; cgi_config_idx += inc) {; 7346 if ((conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx] != NULL); 7347 && (match_prefix_strlen(; 7348 conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx],; 7349 filename); 7350 > 0)) {; 7351 return 1;; 7352 }; 7353 }; 7354#endif; 7355 /* filename and conn could be unused, if all preocessor conditions; 7356 * are false (no script language supported). */; 7357 (void)filename;; 7358 (void)conn;; 7359 ; 7360 return 0;; 7361}; 7362 ; 7363 ; 7364static int; 7365extention_matches_template_text(; 7366 struct mg_connection *conn, /* in: request (must be valid) */; 7367 const char *filename /* in: filename (must be valid) */; 7368); 7369{; 7370#i",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:210630,Modifiability,config,config,210630,"+ (c >> 2);; 7294 if (d != 255) {; 7295 dst[(*dst_len)++] = (c << 6) + d;; 7296 }; 7297 }; 7298 }; 7299 return -1;; 7300}; 7301#endif; 7302 ; 7303 ; 7304static int; 7305is_put_or_delete_method(const struct mg_connection *conn); 7306{; 7307 if (conn) {; 7308 const char *s = conn->request_info.request_method;; 7309 return (s != NULL); 7310 && (!strcmp(s, ""PUT"") || !strcmp(s, ""DELETE""); 7311 || !strcmp(s, ""MKCOL"") || !strcmp(s, ""PATCH""));; 7312 }; 7313 return 0;; 7314}; 7315 ; 7316 ; 7317#if !defined(NO_FILES); 7318static int; 7319extention_matches_script(; 7320 struct mg_connection *conn, /* in: request (must be valid) */; 7321 const char *filename /* in: filename (must be valid) */; 7322); 7323{; 7324#if !defined(NO_CGI); 7325 unsigned char cgi_config_idx, inc, max;; 7326#endif; 7327 ; 7328#if defined(USE_LUA); 7329 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS],; 7330 filename); 7331 > 0) {; 7332 return 1;; 7333 }; 7334#endif; 7335#if defined(USE_DUKTAPE); 7336 if (match_prefix_strlen(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],; 7337 filename); 7338 > 0) {; 7339 return 1;; 7340 }; 7341#endif; 7342#if !defined(NO_CGI); 7343 inc = CGI2_EXTENSIONS - CGI_EXTENSIONS;; 7344 max = PUT_DELETE_PASSWORDS_FILE - CGI_EXTENSIONS;; 7345 for (cgi_config_idx = 0; cgi_config_idx < max; cgi_config_idx += inc) {; 7346 if ((conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx] != NULL); 7347 && (match_prefix_strlen(; 7348 conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx],; 7349 filename); 7350 > 0)) {; 7351 return 1;; 7352 }; 7353 }; 7354#endif; 7355 /* filename and conn could be unused, if all preocessor conditions; 7356 * are false (no script language supported). */; 7357 (void)filename;; 7358 (void)conn;; 7359 ; 7360 return 0;; 7361}; 7362 ; 7363 ; 7364static int; 7365extention_matches_template_text(; 7366 struct mg_connection *conn, /* in: request (must be valid) */; 7367 const char *filename /* in: filename (must be valid) */; 7368); 7369{; 7370#i",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:210731,Modifiability,config,config,210731,"+ (c >> 2);; 7294 if (d != 255) {; 7295 dst[(*dst_len)++] = (c << 6) + d;; 7296 }; 7297 }; 7298 }; 7299 return -1;; 7300}; 7301#endif; 7302 ; 7303 ; 7304static int; 7305is_put_or_delete_method(const struct mg_connection *conn); 7306{; 7307 if (conn) {; 7308 const char *s = conn->request_info.request_method;; 7309 return (s != NULL); 7310 && (!strcmp(s, ""PUT"") || !strcmp(s, ""DELETE""); 7311 || !strcmp(s, ""MKCOL"") || !strcmp(s, ""PATCH""));; 7312 }; 7313 return 0;; 7314}; 7315 ; 7316 ; 7317#if !defined(NO_FILES); 7318static int; 7319extention_matches_script(; 7320 struct mg_connection *conn, /* in: request (must be valid) */; 7321 const char *filename /* in: filename (must be valid) */; 7322); 7323{; 7324#if !defined(NO_CGI); 7325 unsigned char cgi_config_idx, inc, max;; 7326#endif; 7327 ; 7328#if defined(USE_LUA); 7329 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS],; 7330 filename); 7331 > 0) {; 7332 return 1;; 7333 }; 7334#endif; 7335#if defined(USE_DUKTAPE); 7336 if (match_prefix_strlen(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],; 7337 filename); 7338 > 0) {; 7339 return 1;; 7340 }; 7341#endif; 7342#if !defined(NO_CGI); 7343 inc = CGI2_EXTENSIONS - CGI_EXTENSIONS;; 7344 max = PUT_DELETE_PASSWORDS_FILE - CGI_EXTENSIONS;; 7345 for (cgi_config_idx = 0; cgi_config_idx < max; cgi_config_idx += inc) {; 7346 if ((conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx] != NULL); 7347 && (match_prefix_strlen(; 7348 conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx],; 7349 filename); 7350 > 0)) {; 7351 return 1;; 7352 }; 7353 }; 7354#endif; 7355 /* filename and conn could be unused, if all preocessor conditions; 7356 * are false (no script language supported). */; 7357 (void)filename;; 7358 (void)conn;; 7359 ; 7360 return 0;; 7361}; 7362 ; 7363 ; 7364static int; 7365extention_matches_template_text(; 7366 struct mg_connection *conn, /* in: request (must be valid) */; 7367 const char *filename /* in: filename (must be valid) */; 7368); 7369{; 7370#i",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:211325,Modifiability,config,config,211325,"KTAPE_SCRIPT_EXTENSIONS],; 7337 filename); 7338 > 0) {; 7339 return 1;; 7340 }; 7341#endif; 7342#if !defined(NO_CGI); 7343 inc = CGI2_EXTENSIONS - CGI_EXTENSIONS;; 7344 max = PUT_DELETE_PASSWORDS_FILE - CGI_EXTENSIONS;; 7345 for (cgi_config_idx = 0; cgi_config_idx < max; cgi_config_idx += inc) {; 7346 if ((conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx] != NULL); 7347 && (match_prefix_strlen(; 7348 conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx],; 7349 filename); 7350 > 0)) {; 7351 return 1;; 7352 }; 7353 }; 7354#endif; 7355 /* filename and conn could be unused, if all preocessor conditions; 7356 * are false (no script language supported). */; 7357 (void)filename;; 7358 (void)conn;; 7359 ; 7360 return 0;; 7361}; 7362 ; 7363 ; 7364static int; 7365extention_matches_template_text(; 7366 struct mg_connection *conn, /* in: request (must be valid) */; 7367 const char *filename /* in: filename (must be valid) */; 7368); 7369{; 7370#if defined(USE_LUA); 7371 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS],; 7372 filename); 7373 > 0) {; 7374 return 1;; 7375 }; 7376#endif; 7377 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], filename); 7378 > 0) {; 7379 return 1;; 7380 }; 7381 return 0;; 7382}; 7383 ; 7384 ; 7385/* For given directory path, substitute it to valid index file.; 7386 * Return 1 if index file has been found, 0 if not found.; 7387 * If the file is found, it's stats is returned in stp. */; 7388static int; 7389substitute_index_file(struct mg_connection *conn,; 7390 char *path,; 7391 size_t path_len,; 7392 struct mg_file_stat *filestat); 7393{; 7394 const char *list = conn->dom_ctx->config[INDEX_FILES];; 7395 struct vec filename_vec;; 7396 size_t n = strlen(path);; 7397 int found = 0;; 7398 ; 7399 /* The 'path' given to us points to the directory. Remove all trailing; 7400 * directory separator characters from the end of the path, and; 7401 * then append single directory separator character. */; 7402 while ((n > 0",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:211471,Modifiability,config,config,211471,"KTAPE_SCRIPT_EXTENSIONS],; 7337 filename); 7338 > 0) {; 7339 return 1;; 7340 }; 7341#endif; 7342#if !defined(NO_CGI); 7343 inc = CGI2_EXTENSIONS - CGI_EXTENSIONS;; 7344 max = PUT_DELETE_PASSWORDS_FILE - CGI_EXTENSIONS;; 7345 for (cgi_config_idx = 0; cgi_config_idx < max; cgi_config_idx += inc) {; 7346 if ((conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx] != NULL); 7347 && (match_prefix_strlen(; 7348 conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx],; 7349 filename); 7350 > 0)) {; 7351 return 1;; 7352 }; 7353 }; 7354#endif; 7355 /* filename and conn could be unused, if all preocessor conditions; 7356 * are false (no script language supported). */; 7357 (void)filename;; 7358 (void)conn;; 7359 ; 7360 return 0;; 7361}; 7362 ; 7363 ; 7364static int; 7365extention_matches_template_text(; 7366 struct mg_connection *conn, /* in: request (must be valid) */; 7367 const char *filename /* in: filename (must be valid) */; 7368); 7369{; 7370#if defined(USE_LUA); 7371 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS],; 7372 filename); 7373 > 0) {; 7374 return 1;; 7375 }; 7376#endif; 7377 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], filename); 7378 > 0) {; 7379 return 1;; 7380 }; 7381 return 0;; 7382}; 7383 ; 7384 ; 7385/* For given directory path, substitute it to valid index file.; 7386 * Return 1 if index file has been found, 0 if not found.; 7387 * If the file is found, it's stats is returned in stp. */; 7388static int; 7389substitute_index_file(struct mg_connection *conn,; 7390 char *path,; 7391 size_t path_len,; 7392 struct mg_file_stat *filestat); 7393{; 7394 const char *list = conn->dom_ctx->config[INDEX_FILES];; 7395 struct vec filename_vec;; 7396 size_t n = strlen(path);; 7397 int found = 0;; 7398 ; 7399 /* The 'path' given to us points to the directory. Remove all trailing; 7400 * directory separator characters from the end of the path, and; 7401 * then append single directory separator character. */; 7402 while ((n > 0",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:211971,Modifiability,config,config,211971,"ge supported). */; 7357 (void)filename;; 7358 (void)conn;; 7359 ; 7360 return 0;; 7361}; 7362 ; 7363 ; 7364static int; 7365extention_matches_template_text(; 7366 struct mg_connection *conn, /* in: request (must be valid) */; 7367 const char *filename /* in: filename (must be valid) */; 7368); 7369{; 7370#if defined(USE_LUA); 7371 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS],; 7372 filename); 7373 > 0) {; 7374 return 1;; 7375 }; 7376#endif; 7377 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], filename); 7378 > 0) {; 7379 return 1;; 7380 }; 7381 return 0;; 7382}; 7383 ; 7384 ; 7385/* For given directory path, substitute it to valid index file.; 7386 * Return 1 if index file has been found, 0 if not found.; 7387 * If the file is found, it's stats is returned in stp. */; 7388static int; 7389substitute_index_file(struct mg_connection *conn,; 7390 char *path,; 7391 size_t path_len,; 7392 struct mg_file_stat *filestat); 7393{; 7394 const char *list = conn->dom_ctx->config[INDEX_FILES];; 7395 struct vec filename_vec;; 7396 size_t n = strlen(path);; 7397 int found = 0;; 7398 ; 7399 /* The 'path' given to us points to the directory. Remove all trailing; 7400 * directory separator characters from the end of the path, and; 7401 * then append single directory separator character. */; 7402 while ((n > 0) && (path[n - 1] == '/')) {; 7403 n--;; 7404 }; 7405 path[n] = '/';; 7406 ; 7407 /* Traverse index files list. For each entry, append it to the given; 7408 * path and see if the file exists. If it exists, break the loop */; 7409 while ((list = next_option(list, &filename_vec, NULL)) != NULL) {; 7410 /* Ignore too long entries that may overflow path buffer */; 7411 if ((filename_vec.len + 1) > (path_len - (n + 1))) {; 7412 continue;; 7413 }; 7414 ; 7415 /* Prepare full path to the index file */; 7416 mg_strlcpy(path + n + 1, filename_vec.ptr, filename_vec.len + 1);; 7417 ; 7418 /* Does it exist? */; 7419 if (mg_stat(conn, path, filestat)) ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:213987,Modifiability,config,config,213987," */; 7446); 7447{; 7448 char const *accept_encoding;; 7449 ; 7450#if !defined(NO_FILES); 7451 const char *uri = conn->request_info.local_uri;; 7452 const char *root = conn->dom_ctx->config[DOCUMENT_ROOT];; 7453 const char *rewrite;; 7454 struct vec a, b;; 7455 ptrdiff_t match_len;; 7456 char gz_path[UTF8_PATH_MAX];; 7457 int truncated;; 7458#if !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE); 7459 char *tmp_str;; 7460 size_t tmp_str_len, sep_pos;; 7461 int allow_substitute_script_subresources;; 7462#endif; 7463#else; 7464 (void)filename_buf_len; /* unused if NO_FILES is defined */; 7465#endif; 7466 ; 7467 /* Step 1: Set all initially unknown outputs to zero */; 7468 memset(filestat, 0, sizeof(*filestat));; 7469 *filename = 0;; 7470 *is_found = 0;; 7471 *is_script_resource = 0;; 7472 *is_template_text = 0;; 7473 ; 7474 /* Step 2: Check if the request attempts to modify the file system */; 7475 *is_put_or_delete_request = is_put_or_delete_method(conn);; 7476 ; 7477 /* Step 3: Check if it is a websocket request, and modify the document; 7478 * root if required */; 7479#if defined(USE_WEBSOCKET); 7480 *is_websocket_request = (conn->protocol_type == PROTOCOL_TYPE_WEBSOCKET);; 7481#if !defined(NO_FILES); 7482 if (*is_websocket_request && conn->dom_ctx->config[WEBSOCKET_ROOT]) {; 7483 root = conn->dom_ctx->config[WEBSOCKET_ROOT];; 7484 }; 7485#endif /* !NO_FILES */; 7486#else /* USE_WEBSOCKET */; 7487 *is_websocket_request = 0;; 7488#endif /* USE_WEBSOCKET */; 7489 ; 7490 /* Step 4: Check if gzip encoded response is allowed */; 7491 conn->accept_gzip = 0;; 7492 if ((accept_encoding = mg_get_header(conn, ""Accept-Encoding"")) != NULL) {; 7493 if (strstr(accept_encoding, ""gzip"") != NULL) {; 7494 conn->accept_gzip = 1;; 7495 }; 7496 }; 7497 ; 7498#if !defined(NO_FILES); 7499 /* Step 5: If there is no root directory, don't look for files. */; 7500 /* Note that root == NULL is a regular use case here. This occurs,; 7501 * if all requests are handled by callbacks, so t",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:214028,Modifiability,rewrite,rewrite,214028," */; 7446); 7447{; 7448 char const *accept_encoding;; 7449 ; 7450#if !defined(NO_FILES); 7451 const char *uri = conn->request_info.local_uri;; 7452 const char *root = conn->dom_ctx->config[DOCUMENT_ROOT];; 7453 const char *rewrite;; 7454 struct vec a, b;; 7455 ptrdiff_t match_len;; 7456 char gz_path[UTF8_PATH_MAX];; 7457 int truncated;; 7458#if !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE); 7459 char *tmp_str;; 7460 size_t tmp_str_len, sep_pos;; 7461 int allow_substitute_script_subresources;; 7462#endif; 7463#else; 7464 (void)filename_buf_len; /* unused if NO_FILES is defined */; 7465#endif; 7466 ; 7467 /* Step 1: Set all initially unknown outputs to zero */; 7468 memset(filestat, 0, sizeof(*filestat));; 7469 *filename = 0;; 7470 *is_found = 0;; 7471 *is_script_resource = 0;; 7472 *is_template_text = 0;; 7473 ; 7474 /* Step 2: Check if the request attempts to modify the file system */; 7475 *is_put_or_delete_request = is_put_or_delete_method(conn);; 7476 ; 7477 /* Step 3: Check if it is a websocket request, and modify the document; 7478 * root if required */; 7479#if defined(USE_WEBSOCKET); 7480 *is_websocket_request = (conn->protocol_type == PROTOCOL_TYPE_WEBSOCKET);; 7481#if !defined(NO_FILES); 7482 if (*is_websocket_request && conn->dom_ctx->config[WEBSOCKET_ROOT]) {; 7483 root = conn->dom_ctx->config[WEBSOCKET_ROOT];; 7484 }; 7485#endif /* !NO_FILES */; 7486#else /* USE_WEBSOCKET */; 7487 *is_websocket_request = 0;; 7488#endif /* USE_WEBSOCKET */; 7489 ; 7490 /* Step 4: Check if gzip encoded response is allowed */; 7491 conn->accept_gzip = 0;; 7492 if ((accept_encoding = mg_get_header(conn, ""Accept-Encoding"")) != NULL) {; 7493 if (strstr(accept_encoding, ""gzip"") != NULL) {; 7494 conn->accept_gzip = 1;; 7495 }; 7496 }; 7497 ; 7498#if !defined(NO_FILES); 7499 /* Step 5: If there is no root directory, don't look for files. */; 7500 /* Note that root == NULL is a regular use case here. This occurs,; 7501 * if all requests are handled by callbacks, so t",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:215085,Modifiability,config,config,215085," */; 7446); 7447{; 7448 char const *accept_encoding;; 7449 ; 7450#if !defined(NO_FILES); 7451 const char *uri = conn->request_info.local_uri;; 7452 const char *root = conn->dom_ctx->config[DOCUMENT_ROOT];; 7453 const char *rewrite;; 7454 struct vec a, b;; 7455 ptrdiff_t match_len;; 7456 char gz_path[UTF8_PATH_MAX];; 7457 int truncated;; 7458#if !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE); 7459 char *tmp_str;; 7460 size_t tmp_str_len, sep_pos;; 7461 int allow_substitute_script_subresources;; 7462#endif; 7463#else; 7464 (void)filename_buf_len; /* unused if NO_FILES is defined */; 7465#endif; 7466 ; 7467 /* Step 1: Set all initially unknown outputs to zero */; 7468 memset(filestat, 0, sizeof(*filestat));; 7469 *filename = 0;; 7470 *is_found = 0;; 7471 *is_script_resource = 0;; 7472 *is_template_text = 0;; 7473 ; 7474 /* Step 2: Check if the request attempts to modify the file system */; 7475 *is_put_or_delete_request = is_put_or_delete_method(conn);; 7476 ; 7477 /* Step 3: Check if it is a websocket request, and modify the document; 7478 * root if required */; 7479#if defined(USE_WEBSOCKET); 7480 *is_websocket_request = (conn->protocol_type == PROTOCOL_TYPE_WEBSOCKET);; 7481#if !defined(NO_FILES); 7482 if (*is_websocket_request && conn->dom_ctx->config[WEBSOCKET_ROOT]) {; 7483 root = conn->dom_ctx->config[WEBSOCKET_ROOT];; 7484 }; 7485#endif /* !NO_FILES */; 7486#else /* USE_WEBSOCKET */; 7487 *is_websocket_request = 0;; 7488#endif /* USE_WEBSOCKET */; 7489 ; 7490 /* Step 4: Check if gzip encoded response is allowed */; 7491 conn->accept_gzip = 0;; 7492 if ((accept_encoding = mg_get_header(conn, ""Accept-Encoding"")) != NULL) {; 7493 if (strstr(accept_encoding, ""gzip"") != NULL) {; 7494 conn->accept_gzip = 1;; 7495 }; 7496 }; 7497 ; 7498#if !defined(NO_FILES); 7499 /* Step 5: If there is no root directory, don't look for files. */; 7500 /* Note that root == NULL is a regular use case here. This occurs,; 7501 * if all requests are handled by callbacks, so t",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:215139,Modifiability,config,config,215139," */; 7446); 7447{; 7448 char const *accept_encoding;; 7449 ; 7450#if !defined(NO_FILES); 7451 const char *uri = conn->request_info.local_uri;; 7452 const char *root = conn->dom_ctx->config[DOCUMENT_ROOT];; 7453 const char *rewrite;; 7454 struct vec a, b;; 7455 ptrdiff_t match_len;; 7456 char gz_path[UTF8_PATH_MAX];; 7457 int truncated;; 7458#if !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE); 7459 char *tmp_str;; 7460 size_t tmp_str_len, sep_pos;; 7461 int allow_substitute_script_subresources;; 7462#endif; 7463#else; 7464 (void)filename_buf_len; /* unused if NO_FILES is defined */; 7465#endif; 7466 ; 7467 /* Step 1: Set all initially unknown outputs to zero */; 7468 memset(filestat, 0, sizeof(*filestat));; 7469 *filename = 0;; 7470 *is_found = 0;; 7471 *is_script_resource = 0;; 7472 *is_template_text = 0;; 7473 ; 7474 /* Step 2: Check if the request attempts to modify the file system */; 7475 *is_put_or_delete_request = is_put_or_delete_method(conn);; 7476 ; 7477 /* Step 3: Check if it is a websocket request, and modify the document; 7478 * root if required */; 7479#if defined(USE_WEBSOCKET); 7480 *is_websocket_request = (conn->protocol_type == PROTOCOL_TYPE_WEBSOCKET);; 7481#if !defined(NO_FILES); 7482 if (*is_websocket_request && conn->dom_ctx->config[WEBSOCKET_ROOT]) {; 7483 root = conn->dom_ctx->config[WEBSOCKET_ROOT];; 7484 }; 7485#endif /* !NO_FILES */; 7486#else /* USE_WEBSOCKET */; 7487 *is_websocket_request = 0;; 7488#endif /* USE_WEBSOCKET */; 7489 ; 7490 /* Step 4: Check if gzip encoded response is allowed */; 7491 conn->accept_gzip = 0;; 7492 if ((accept_encoding = mg_get_header(conn, ""Accept-Encoding"")) != NULL) {; 7493 if (strstr(accept_encoding, ""gzip"") != NULL) {; 7494 conn->accept_gzip = 1;; 7495 }; 7496 }; 7497 ; 7498#if !defined(NO_FILES); 7499 /* Step 5: If there is no root directory, don't look for files. */; 7500 /* Note that root == NULL is a regular use case here. This occurs,; 7501 * if all requests are handled by callbacks, so t",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:215832,Modifiability,config,config,215832,"/* Step 3: Check if it is a websocket request, and modify the document; 7478 * root if required */; 7479#if defined(USE_WEBSOCKET); 7480 *is_websocket_request = (conn->protocol_type == PROTOCOL_TYPE_WEBSOCKET);; 7481#if !defined(NO_FILES); 7482 if (*is_websocket_request && conn->dom_ctx->config[WEBSOCKET_ROOT]) {; 7483 root = conn->dom_ctx->config[WEBSOCKET_ROOT];; 7484 }; 7485#endif /* !NO_FILES */; 7486#else /* USE_WEBSOCKET */; 7487 *is_websocket_request = 0;; 7488#endif /* USE_WEBSOCKET */; 7489 ; 7490 /* Step 4: Check if gzip encoded response is allowed */; 7491 conn->accept_gzip = 0;; 7492 if ((accept_encoding = mg_get_header(conn, ""Accept-Encoding"")) != NULL) {; 7493 if (strstr(accept_encoding, ""gzip"") != NULL) {; 7494 conn->accept_gzip = 1;; 7495 }; 7496 }; 7497 ; 7498#if !defined(NO_FILES); 7499 /* Step 5: If there is no root directory, don't look for files. */; 7500 /* Note that root == NULL is a regular use case here. This occurs,; 7501 * if all requests are handled by callbacks, so the WEBSOCKET_ROOT; 7502 * config is not required. */; 7503 if (root == NULL) {; 7504 /* all file related outputs have already been set to 0, just return; 7505 */; 7506 return;; 7507 }; 7508 ; 7509 /* Step 6: Determine the local file path from the root path and the; 7510 * request uri. */; 7511 /* Using filename_buf_len - 1 because memmove() for PATH_INFO may shift; 7512 * part of the path one byte on the right. */; 7513 truncated = 0;; 7514 mg_snprintf(; 7515 conn, &truncated, filename, filename_buf_len - 1, ""%s%s"", root, uri);; 7516 ; 7517 if (truncated) {; 7518 goto interpret_cleanup;; 7519 }; 7520 ; 7521 /* Step 7: URI rewriting */; 7522 rewrite = conn->dom_ctx->config[URL_REWRITE_PATTERN];; 7523 while ((rewrite = next_option(rewrite, &a, &b)) != NULL) {; 7524 if ((match_len = match_prefix(a.ptr, a.len, uri)) > 0) {; 7525 mg_snprintf(conn,; 7526 &truncated,; 7527 filename,; 7528 filename_buf_len - 1,; 7529 ""%.*s%s"",; 7530 (int)b.len,; 7531 b.ptr,; 7532 uri + match_len);; 75",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:216455,Modifiability,rewrite,rewrite,216455,"ing = mg_get_header(conn, ""Accept-Encoding"")) != NULL) {; 7493 if (strstr(accept_encoding, ""gzip"") != NULL) {; 7494 conn->accept_gzip = 1;; 7495 }; 7496 }; 7497 ; 7498#if !defined(NO_FILES); 7499 /* Step 5: If there is no root directory, don't look for files. */; 7500 /* Note that root == NULL is a regular use case here. This occurs,; 7501 * if all requests are handled by callbacks, so the WEBSOCKET_ROOT; 7502 * config is not required. */; 7503 if (root == NULL) {; 7504 /* all file related outputs have already been set to 0, just return; 7505 */; 7506 return;; 7507 }; 7508 ; 7509 /* Step 6: Determine the local file path from the root path and the; 7510 * request uri. */; 7511 /* Using filename_buf_len - 1 because memmove() for PATH_INFO may shift; 7512 * part of the path one byte on the right. */; 7513 truncated = 0;; 7514 mg_snprintf(; 7515 conn, &truncated, filename, filename_buf_len - 1, ""%s%s"", root, uri);; 7516 ; 7517 if (truncated) {; 7518 goto interpret_cleanup;; 7519 }; 7520 ; 7521 /* Step 7: URI rewriting */; 7522 rewrite = conn->dom_ctx->config[URL_REWRITE_PATTERN];; 7523 while ((rewrite = next_option(rewrite, &a, &b)) != NULL) {; 7524 if ((match_len = match_prefix(a.ptr, a.len, uri)) > 0) {; 7525 mg_snprintf(conn,; 7526 &truncated,; 7527 filename,; 7528 filename_buf_len - 1,; 7529 ""%.*s%s"",; 7530 (int)b.len,; 7531 b.ptr,; 7532 uri + match_len);; 7533 break;; 7534 }; 7535 }; 7536 ; 7537 if (truncated) {; 7538 goto interpret_cleanup;; 7539 }; 7540 ; 7541 /* Step 8: Check if the file exists at the server */; 7542 /* Local file path and name, corresponding to requested URI; 7543 * is now stored in ""filename"" variable. */; 7544 if (mg_stat(conn, filename, filestat)) {; 7545 int uri_len = (int)strlen(uri);; 7546 int is_uri_end_slash = (uri_len > 0) && (uri[uri_len - 1] == '/');; 7547 ; 7548 /* 8.1: File exists. */; 7549 *is_found = 1;; 7550 ; 7551 /* 8.2: Check if it is a script type. */; 7552 if (extention_matches_script(conn, filename)) {; 7553 /* The request",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:216480,Modifiability,config,config,216480,"ing = mg_get_header(conn, ""Accept-Encoding"")) != NULL) {; 7493 if (strstr(accept_encoding, ""gzip"") != NULL) {; 7494 conn->accept_gzip = 1;; 7495 }; 7496 }; 7497 ; 7498#if !defined(NO_FILES); 7499 /* Step 5: If there is no root directory, don't look for files. */; 7500 /* Note that root == NULL is a regular use case here. This occurs,; 7501 * if all requests are handled by callbacks, so the WEBSOCKET_ROOT; 7502 * config is not required. */; 7503 if (root == NULL) {; 7504 /* all file related outputs have already been set to 0, just return; 7505 */; 7506 return;; 7507 }; 7508 ; 7509 /* Step 6: Determine the local file path from the root path and the; 7510 * request uri. */; 7511 /* Using filename_buf_len - 1 because memmove() for PATH_INFO may shift; 7512 * part of the path one byte on the right. */; 7513 truncated = 0;; 7514 mg_snprintf(; 7515 conn, &truncated, filename, filename_buf_len - 1, ""%s%s"", root, uri);; 7516 ; 7517 if (truncated) {; 7518 goto interpret_cleanup;; 7519 }; 7520 ; 7521 /* Step 7: URI rewriting */; 7522 rewrite = conn->dom_ctx->config[URL_REWRITE_PATTERN];; 7523 while ((rewrite = next_option(rewrite, &a, &b)) != NULL) {; 7524 if ((match_len = match_prefix(a.ptr, a.len, uri)) > 0) {; 7525 mg_snprintf(conn,; 7526 &truncated,; 7527 filename,; 7528 filename_buf_len - 1,; 7529 ""%.*s%s"",; 7530 (int)b.len,; 7531 b.ptr,; 7532 uri + match_len);; 7533 break;; 7534 }; 7535 }; 7536 ; 7537 if (truncated) {; 7538 goto interpret_cleanup;; 7539 }; 7540 ; 7541 /* Step 8: Check if the file exists at the server */; 7542 /* Local file path and name, corresponding to requested URI; 7543 * is now stored in ""filename"" variable. */; 7544 if (mg_stat(conn, filename, filestat)) {; 7545 int uri_len = (int)strlen(uri);; 7546 int is_uri_end_slash = (uri_len > 0) && (uri[uri_len - 1] == '/');; 7547 ; 7548 /* 8.1: File exists. */; 7549 *is_found = 1;; 7550 ; 7551 /* 8.2: Check if it is a script type. */; 7552 if (extention_matches_script(conn, filename)) {; 7553 /* The request",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:216523,Modifiability,rewrite,rewrite,216523,"ing = mg_get_header(conn, ""Accept-Encoding"")) != NULL) {; 7493 if (strstr(accept_encoding, ""gzip"") != NULL) {; 7494 conn->accept_gzip = 1;; 7495 }; 7496 }; 7497 ; 7498#if !defined(NO_FILES); 7499 /* Step 5: If there is no root directory, don't look for files. */; 7500 /* Note that root == NULL is a regular use case here. This occurs,; 7501 * if all requests are handled by callbacks, so the WEBSOCKET_ROOT; 7502 * config is not required. */; 7503 if (root == NULL) {; 7504 /* all file related outputs have already been set to 0, just return; 7505 */; 7506 return;; 7507 }; 7508 ; 7509 /* Step 6: Determine the local file path from the root path and the; 7510 * request uri. */; 7511 /* Using filename_buf_len - 1 because memmove() for PATH_INFO may shift; 7512 * part of the path one byte on the right. */; 7513 truncated = 0;; 7514 mg_snprintf(; 7515 conn, &truncated, filename, filename_buf_len - 1, ""%s%s"", root, uri);; 7516 ; 7517 if (truncated) {; 7518 goto interpret_cleanup;; 7519 }; 7520 ; 7521 /* Step 7: URI rewriting */; 7522 rewrite = conn->dom_ctx->config[URL_REWRITE_PATTERN];; 7523 while ((rewrite = next_option(rewrite, &a, &b)) != NULL) {; 7524 if ((match_len = match_prefix(a.ptr, a.len, uri)) > 0) {; 7525 mg_snprintf(conn,; 7526 &truncated,; 7527 filename,; 7528 filename_buf_len - 1,; 7529 ""%.*s%s"",; 7530 (int)b.len,; 7531 b.ptr,; 7532 uri + match_len);; 7533 break;; 7534 }; 7535 }; 7536 ; 7537 if (truncated) {; 7538 goto interpret_cleanup;; 7539 }; 7540 ; 7541 /* Step 8: Check if the file exists at the server */; 7542 /* Local file path and name, corresponding to requested URI; 7543 * is now stored in ""filename"" variable. */; 7544 if (mg_stat(conn, filename, filestat)) {; 7545 int uri_len = (int)strlen(uri);; 7546 int is_uri_end_slash = (uri_len > 0) && (uri[uri_len - 1] == '/');; 7547 ; 7548 /* 8.1: File exists. */; 7549 *is_found = 1;; 7550 ; 7551 /* 8.2: Check if it is a script type. */; 7552 if (extention_matches_script(conn, filename)) {; 7553 /* The request",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:216545,Modifiability,rewrite,rewrite,216545,"ing = mg_get_header(conn, ""Accept-Encoding"")) != NULL) {; 7493 if (strstr(accept_encoding, ""gzip"") != NULL) {; 7494 conn->accept_gzip = 1;; 7495 }; 7496 }; 7497 ; 7498#if !defined(NO_FILES); 7499 /* Step 5: If there is no root directory, don't look for files. */; 7500 /* Note that root == NULL is a regular use case here. This occurs,; 7501 * if all requests are handled by callbacks, so the WEBSOCKET_ROOT; 7502 * config is not required. */; 7503 if (root == NULL) {; 7504 /* all file related outputs have already been set to 0, just return; 7505 */; 7506 return;; 7507 }; 7508 ; 7509 /* Step 6: Determine the local file path from the root path and the; 7510 * request uri. */; 7511 /* Using filename_buf_len - 1 because memmove() for PATH_INFO may shift; 7512 * part of the path one byte on the right. */; 7513 truncated = 0;; 7514 mg_snprintf(; 7515 conn, &truncated, filename, filename_buf_len - 1, ""%s%s"", root, uri);; 7516 ; 7517 if (truncated) {; 7518 goto interpret_cleanup;; 7519 }; 7520 ; 7521 /* Step 7: URI rewriting */; 7522 rewrite = conn->dom_ctx->config[URL_REWRITE_PATTERN];; 7523 while ((rewrite = next_option(rewrite, &a, &b)) != NULL) {; 7524 if ((match_len = match_prefix(a.ptr, a.len, uri)) > 0) {; 7525 mg_snprintf(conn,; 7526 &truncated,; 7527 filename,; 7528 filename_buf_len - 1,; 7529 ""%.*s%s"",; 7530 (int)b.len,; 7531 b.ptr,; 7532 uri + match_len);; 7533 break;; 7534 }; 7535 }; 7536 ; 7537 if (truncated) {; 7538 goto interpret_cleanup;; 7539 }; 7540 ; 7541 /* Step 8: Check if the file exists at the server */; 7542 /* Local file path and name, corresponding to requested URI; 7543 * is now stored in ""filename"" variable. */; 7544 if (mg_stat(conn, filename, filestat)) {; 7545 int uri_len = (int)strlen(uri);; 7546 int is_uri_end_slash = (uri_len > 0) && (uri[uri_len - 1] == '/');; 7547 ; 7548 /* 8.1: File exists. */; 7549 *is_found = 1;; 7550 ; 7551 /* 8.2: Check if it is a script type. */; 7552 if (extention_matches_script(conn, filename)) {; 7553 /* The request",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:217059,Modifiability,variab,variable,217059,"ts have already been set to 0, just return; 7505 */; 7506 return;; 7507 }; 7508 ; 7509 /* Step 6: Determine the local file path from the root path and the; 7510 * request uri. */; 7511 /* Using filename_buf_len - 1 because memmove() for PATH_INFO may shift; 7512 * part of the path one byte on the right. */; 7513 truncated = 0;; 7514 mg_snprintf(; 7515 conn, &truncated, filename, filename_buf_len - 1, ""%s%s"", root, uri);; 7516 ; 7517 if (truncated) {; 7518 goto interpret_cleanup;; 7519 }; 7520 ; 7521 /* Step 7: URI rewriting */; 7522 rewrite = conn->dom_ctx->config[URL_REWRITE_PATTERN];; 7523 while ((rewrite = next_option(rewrite, &a, &b)) != NULL) {; 7524 if ((match_len = match_prefix(a.ptr, a.len, uri)) > 0) {; 7525 mg_snprintf(conn,; 7526 &truncated,; 7527 filename,; 7528 filename_buf_len - 1,; 7529 ""%.*s%s"",; 7530 (int)b.len,; 7531 b.ptr,; 7532 uri + match_len);; 7533 break;; 7534 }; 7535 }; 7536 ; 7537 if (truncated) {; 7538 goto interpret_cleanup;; 7539 }; 7540 ; 7541 /* Step 8: Check if the file exists at the server */; 7542 /* Local file path and name, corresponding to requested URI; 7543 * is now stored in ""filename"" variable. */; 7544 if (mg_stat(conn, filename, filestat)) {; 7545 int uri_len = (int)strlen(uri);; 7546 int is_uri_end_slash = (uri_len > 0) && (uri[uri_len - 1] == '/');; 7547 ; 7548 /* 8.1: File exists. */; 7549 *is_found = 1;; 7550 ; 7551 /* 8.2: Check if it is a script type. */; 7552 if (extention_matches_script(conn, filename)) {; 7553 /* The request addresses a CGI resource, Lua script or; 7554 * server-side javascript.; 7555 * The URI corresponds to the script itself (like; 7556 * /path/script.cgi), and there is no additional resource; 7557 * path (like /path/script.cgi/something).; 7558 * Requests that modify (replace or delete) a resource, like; 7559 * PUT and DELETE requests, should replace/delete the script; 7560 * file.; 7561 * Requests that read or write from/to a resource, like GET and; 7562 * POST requests, should call the script a",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:221008,Modifiability,config,config,221008,,MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:221140,Modifiability,config,config,221140,,MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:236079,Modifiability,config,config,236079,"(path_len - builtin_mime_types[i].ext_len);; 8144 if ((path_len > builtin_mime_types[i].ext_len); 8145 && (mg_strcasecmp(ext, builtin_mime_types[i].extension) == 0)) {; 8146 return builtin_mime_types[i].mime_type;; 8147 }; 8148 }; 8149 ; 8150 return ""text/plain"";; 8151}; 8152 ; 8153 ; 8154/* Look at the ""path"" extension and figure what mime type it has.; 8155 * Store mime type in the vector. */; 8156static void; 8157get_mime_type(struct mg_connection *conn, const char *path, struct vec *vec); 8158{; 8159 struct vec ext_vec, mime_vec;; 8160 const char *list, *ext;; 8161 size_t path_len;; 8162 ; 8163 path_len = strlen(path);; 8164 ; 8165 if ((conn == NULL) || (vec == NULL)) {; 8166 if (vec != NULL) {; 8167 memset(vec, '\0', sizeof(struct vec));; 8168 }; 8169 return;; 8170 }; 8171 ; 8172 /* Scan user-defined mime types first, in case user wants to; 8173 * override default mime types. */; 8174 list = conn->dom_ctx->config[EXTRA_MIME_TYPES];; 8175 while ((list = next_option(list, &ext_vec, &mime_vec)) != NULL) {; 8176 /* ext now points to the path suffix */; 8177 ext = path + path_len - ext_vec.len;; 8178 if (mg_strncasecmp(ext, ext_vec.ptr, ext_vec.len) == 0) {; 8179 *vec = mime_vec;; 8180 return;; 8181 }; 8182 }; 8183 ; 8184 vec->ptr = mg_get_builtin_mime_type(path);; 8185 vec->len = strlen(vec->ptr);; 8186}; 8187 ; 8188 ; 8189/* Stringify binary data. Output buffer must be twice as big as input,; 8190 * because each byte takes 2 bytes in string representation */; 8191static void; 8192bin2str(char *to, const unsigned char *p, size_t len); 8193{; 8194 static const char *hex = ""0123456789abcdef"";; 8195 ; 8196 for (; len--; p++) {; 8197 *to++ = hex[p[0] >> 4];; 8198 *to++ = hex[p[0] & 0x0f];; 8199 }; 8200 *to = '\0';; 8201}; 8202 ; 8203 ; 8204/* Return stringified MD5 hash for list of strings. Buffer must be 33 bytes.; 8205 */; 8206char *; 8207mg_md5(char buf[33], ...); 8208{; 8209 md5_byte_t hash[16];; 8210 const char *p;; 8211 va_list ap;; 8212 md5_state_t ctx;; 8213 ; ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:238893,Modifiability,config,config,238893,"| (nc == NULL) || (cnonce == NULL); 8243 || (qop == NULL) || (response == NULL)) {; 8244 return 0;; 8245 }; 8246 ; 8247 /* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */; 8248 if (strlen(response) != 32) {; 8249 return 0;; 8250 }; 8251 ; 8252 mg_md5(ha2, method, "":"", uri, NULL);; 8253 mg_md5(expected_response,; 8254 ha1,; 8255 "":"",; 8256 nonce,; 8257 "":"",; 8258 nc,; 8259 "":"",; 8260 cnonce,; 8261 "":"",; 8262 qop,; 8263 "":"",; 8264 ha2,; 8265 NULL);; 8266 ; 8267 return mg_strcasecmp(response, expected_response) == 0;; 8268}; 8269 ; 8270 ; 8271#if !defined(NO_FILESYSTEMS); 8272/* Use the global passwords file, if specified by auth_gpass option,; 8273 * or search for .htpasswd in the requested directory. */; 8274static void; 8275open_auth_file(struct mg_connection *conn,; 8276 const char *path,; 8277 struct mg_file *filep); 8278{; 8279 if ((conn != NULL) && (conn->dom_ctx != NULL)) {; 8280 char name[UTF8_PATH_MAX];; 8281 const char *p, *e,; 8282 *gpass = conn->dom_ctx->config[GLOBAL_PASSWORDS_FILE];; 8283 int truncated;; 8284 ; 8285 if (gpass != NULL) {; 8286 /* Use global passwords file */; 8287 if (!mg_fopen(conn, gpass, MG_FOPEN_MODE_READ, filep)) {; 8288#if defined(DEBUG); 8289 /* Use mg_cry_internal here, since gpass has been; 8290 * configured. */; 8291 mg_cry_internal(conn, ""fopen(%s): %s"", gpass, strerror(ERRNO));; 8292#endif; 8293 }; 8294 /* Important: using local struct mg_file to test path for; 8295 * is_directory flag. If filep is used, mg_stat() makes it; 8296 * appear as if auth file was opened.; 8297 * TODO(mid): Check if this is still required after rewriting; 8298 * mg_stat */; 8299 } else if (mg_stat(conn, path, &filep->stat); 8300 && filep->stat.is_directory) {; 8301 mg_snprintf(conn,; 8302 &truncated,; 8303 name,; 8304 sizeof(name),; 8305 ""%s/%s"",; 8306 path,; 8307 PASSWORDS_FILE_NAME);; 8308 ; 8309 if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {; 8310#if defined(DEBUG); 8311 /* Don't use mg_cry_internal here, but onl",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:239168,Modifiability,config,configured,239168,"| (nc == NULL) || (cnonce == NULL); 8243 || (qop == NULL) || (response == NULL)) {; 8244 return 0;; 8245 }; 8246 ; 8247 /* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */; 8248 if (strlen(response) != 32) {; 8249 return 0;; 8250 }; 8251 ; 8252 mg_md5(ha2, method, "":"", uri, NULL);; 8253 mg_md5(expected_response,; 8254 ha1,; 8255 "":"",; 8256 nonce,; 8257 "":"",; 8258 nc,; 8259 "":"",; 8260 cnonce,; 8261 "":"",; 8262 qop,; 8263 "":"",; 8264 ha2,; 8265 NULL);; 8266 ; 8267 return mg_strcasecmp(response, expected_response) == 0;; 8268}; 8269 ; 8270 ; 8271#if !defined(NO_FILESYSTEMS); 8272/* Use the global passwords file, if specified by auth_gpass option,; 8273 * or search for .htpasswd in the requested directory. */; 8274static void; 8275open_auth_file(struct mg_connection *conn,; 8276 const char *path,; 8277 struct mg_file *filep); 8278{; 8279 if ((conn != NULL) && (conn->dom_ctx != NULL)) {; 8280 char name[UTF8_PATH_MAX];; 8281 const char *p, *e,; 8282 *gpass = conn->dom_ctx->config[GLOBAL_PASSWORDS_FILE];; 8283 int truncated;; 8284 ; 8285 if (gpass != NULL) {; 8286 /* Use global passwords file */; 8287 if (!mg_fopen(conn, gpass, MG_FOPEN_MODE_READ, filep)) {; 8288#if defined(DEBUG); 8289 /* Use mg_cry_internal here, since gpass has been; 8290 * configured. */; 8291 mg_cry_internal(conn, ""fopen(%s): %s"", gpass, strerror(ERRNO));; 8292#endif; 8293 }; 8294 /* Important: using local struct mg_file to test path for; 8295 * is_directory flag. If filep is used, mg_stat() makes it; 8296 * appear as if auth file was opened.; 8297 * TODO(mid): Check if this is still required after rewriting; 8298 * mg_stat */; 8299 } else if (mg_stat(conn, path, &filep->stat); 8300 && filep->stat.is_directory) {; 8301 mg_snprintf(conn,; 8302 &truncated,; 8303 name,; 8304 sizeof(name),; 8305 ""%s/%s"",; 8306 path,; 8307 PASSWORDS_FILE_NAME);; 8308 ; 8309 if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {; 8310#if defined(DEBUG); 8311 /* Don't use mg_cry_internal here, but onl",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:248998,Modifiability,config,config,248998,"06 }; 8607 }; 8608 ; 8609 return is_authorized;; 8610}; 8611 ; 8612 ; 8613/* Authorize against the opened passwords file. Return 1 if authorized. */; 8614static int; 8615authorize(struct mg_connection *conn, struct mg_file *filep, const char *realm); 8616{; 8617 struct read_auth_file_struct workdata;; 8618 char buf[MG_BUF_LEN];; 8619 ; 8620 if (!conn || !conn->dom_ctx) {; 8621 return 0;; 8622 }; 8623 ; 8624 memset(&workdata, 0, sizeof(workdata));; 8625 workdata.conn = conn;; 8626 ; 8627 if (!parse_auth_header(conn, buf, sizeof(buf), &workdata.ah)) {; 8628 return 0;; 8629 }; 8630 ; 8631 if (realm) {; 8632 workdata.domain = realm;; 8633 } else {; 8634 workdata.domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8635 }; 8636 ; 8637 return read_auth_file(filep, &workdata, INITIAL_DEPTH);; 8638}; 8639 ; 8640 ; 8641/* Public function to check http digest authentication header */; 8642int; 8643mg_check_digest_access_authentication(struct mg_connection *conn,; 8644 const char *realm,; 8645 const char *filename); 8646{; 8647 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8648 int auth;; 8649 ; 8650 if (!conn || !filename) {; 8651 return -1;; 8652 }; 8653 if (!mg_fopen(conn, filename, MG_FOPEN_MODE_READ, &file)) {; 8654 return -2;; 8655 }; 8656 ; 8657 auth = authorize(conn, &file, realm);; 8658 ; 8659 mg_fclose(&file.access);; 8660 ; 8661 return auth;; 8662}; 8663#endif /* NO_FILESYSTEMS */; 8664 ; 8665 ; 8666/* Return 1 if request is authorised, 0 otherwise. */; 8667static int; 8668check_authorization(struct mg_connection *conn, const char *path); 8669{; 8670#if !defined(NO_FILESYSTEMS); 8671 char fname[UTF8_PATH_MAX];; 8672 struct vec uri_vec, filename_vec;; 8673 const char *list;; 8674 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8675 int authorized = 1, truncated;; 8676 ; 8677 if (!conn || !conn->dom_ctx) {; 8678 return 0;; 8679 }; 8680 ; 8681 list = conn->dom_ctx->config[PROTECT_URI];; 8682 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 868",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:250207,Modifiability,config,config,250207,"uth_file(filep, &workdata, INITIAL_DEPTH);; 8638}; 8639 ; 8640 ; 8641/* Public function to check http digest authentication header */; 8642int; 8643mg_check_digest_access_authentication(struct mg_connection *conn,; 8644 const char *realm,; 8645 const char *filename); 8646{; 8647 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8648 int auth;; 8649 ; 8650 if (!conn || !filename) {; 8651 return -1;; 8652 }; 8653 if (!mg_fopen(conn, filename, MG_FOPEN_MODE_READ, &file)) {; 8654 return -2;; 8655 }; 8656 ; 8657 auth = authorize(conn, &file, realm);; 8658 ; 8659 mg_fclose(&file.access);; 8660 ; 8661 return auth;; 8662}; 8663#endif /* NO_FILESYSTEMS */; 8664 ; 8665 ; 8666/* Return 1 if request is authorised, 0 otherwise. */; 8667static int; 8668check_authorization(struct mg_connection *conn, const char *path); 8669{; 8670#if !defined(NO_FILESYSTEMS); 8671 char fname[UTF8_PATH_MAX];; 8672 struct vec uri_vec, filename_vec;; 8673 const char *list;; 8674 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8675 int authorized = 1, truncated;; 8676 ; 8677 if (!conn || !conn->dom_ctx) {; 8678 return 0;; 8679 }; 8680 ; 8681 list = conn->dom_ctx->config[PROTECT_URI];; 8682 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 8683 if (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {; 8684 mg_snprintf(conn,; 8685 &truncated,; 8686 fname,; 8687 sizeof(fname),; 8688 ""%.*s"",; 8689 (int)filename_vec.len,; 8690 filename_vec.ptr);; 8691 ; 8692 if (truncated; 8693 || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {; 8694 mg_cry_internal(conn,; 8695 ""%s: cannot open %s: %s"",; 8696 __func__,; 8697 fname,; 8698 strerror(errno));; 8699 }; 8700 break;; 8701 }; 8702 }; 8703 ; 8704 if (!is_file_opened(&file.access)) {; 8705 open_auth_file(conn, path, &file);; 8706 }; 8707 ; 8708 if (is_file_opened(&file.access)) {; 8709 authorized = authorize(conn, &file, NULL);; 8710 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8711 }; 8712 ; 8713 return ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:251508,Modifiability,config,config,251508," }; 8707 ; 8708 if (is_file_opened(&file.access)) {; 8709 authorized = authorize(conn, &file, NULL);; 8710 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8711 }; 8712 ; 8713 return authorized;; 8714#else; 8715 (void)conn;; 8716 (void)path;; 8717 return 1;; 8718#endif /* NO_FILESYSTEMS */; 8719}; 8720 ; 8721 ; 8722/* Internal function. Assumes conn is valid */; 8723static void; 8724send_authorization_request(struct mg_connection *conn, const char *realm); 8725{; 8726 uint64_t nonce = (uint64_t)(conn->phys_ctx->start_time);; 8727 int trunc = 0;; 8728 char buf[128];; 8729 ; 8730 if (!realm) {; 8731 realm = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8732 }; 8733 ; 8734 mg_lock_context(conn->phys_ctx);; 8735 nonce += conn->dom_ctx->nonce_count;; 8736 ++conn->dom_ctx->nonce_count;; 8737 mg_unlock_context(conn->phys_ctx);; 8738 ; 8739 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8740 conn->must_close = 1;; 8741 ; 8742 /* Create 401 response */; 8743 mg_response_header_start(conn, 401);; 8744 send_no_cache_header(conn);; 8745 send_additional_header(conn);; 8746 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 8747 ; 8748 /* Content for ""WWW-Authenticate"" header */; 8749 mg_snprintf(conn,; 8750 &trunc,; 8751 buf,; 8752 sizeof(buf),; 8753 ""Digest qop=\""auth\"", realm=\""%s\"", ""; 8754 ""nonce=\""%"" UINT64_FMT ""\"""",; 8755 realm,; 8756 nonce);; 8757 ; 8758 if (!trunc) {; 8759 /* !trunc should always be true */; 8760 mg_response_header_add(conn, ""WWW-Authenticate"", buf, -1);; 8761 }; 8762 ; 8763 /* Send all headers */; 8764 mg_response_header_send(conn);; 8765}; 8766 ; 8767 ; 8768/* Interface function. Parameters are provided by the user, so do; 8769 * at least some basic checks.; 8770 */; 8771int; 8772mg_send_digest_access_authentication_request(struct mg_connection *conn,; 8773 const char *realm); 8774{; 8775 if (conn && conn->dom_ctx) {; 8776 send_authorization_request(conn, realm);; 8777 return 0;; 8778 }; 8779 return -1;; 8780}; 8781 ; 8782 ; 8783#",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:253076,Modifiability,config,config,253076,"conn);; 8746 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 8747 ; 8748 /* Content for ""WWW-Authenticate"" header */; 8749 mg_snprintf(conn,; 8750 &trunc,; 8751 buf,; 8752 sizeof(buf),; 8753 ""Digest qop=\""auth\"", realm=\""%s\"", ""; 8754 ""nonce=\""%"" UINT64_FMT ""\"""",; 8755 realm,; 8756 nonce);; 8757 ; 8758 if (!trunc) {; 8759 /* !trunc should always be true */; 8760 mg_response_header_add(conn, ""WWW-Authenticate"", buf, -1);; 8761 }; 8762 ; 8763 /* Send all headers */; 8764 mg_response_header_send(conn);; 8765}; 8766 ; 8767 ; 8768/* Interface function. Parameters are provided by the user, so do; 8769 * at least some basic checks.; 8770 */; 8771int; 8772mg_send_digest_access_authentication_request(struct mg_connection *conn,; 8773 const char *realm); 8774{; 8775 if (conn && conn->dom_ctx) {; 8776 send_authorization_request(conn, realm);; 8777 return 0;; 8778 }; 8779 return -1;; 8780}; 8781 ; 8782 ; 8783#if !defined(NO_FILES); 8784static int; 8785is_authorized_for_put(struct mg_connection *conn); 8786{; 8787 if (conn) {; 8788 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8789 const char *passfile = conn->dom_ctx->config[PUT_DELETE_PASSWORDS_FILE];; 8790 int ret = 0;; 8791 ; 8792 if (passfile != NULL; 8793 && mg_fopen(conn, passfile, MG_FOPEN_MODE_READ, &file)) {; 8794 ret = authorize(conn, &file, NULL);; 8795 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8796 }; 8797 ; 8798 return ret;; 8799 }; 8800 return 0;; 8801}; 8802#endif; 8803 ; 8804 ; 8805static int; 8806modify_passwords_file(const char *fname,; 8807 const char *domain,; 8808 const char *user,; 8809 const char *pass,; 8810 const char *ha1); 8811{; 8812 int found, i;; 8813 char line[512], u[512] = """", d[512] = """", ha1buf[33],; 8814 tmp[UTF8_PATH_MAX + 8];; 8815 FILE *fp, *fp2;; 8816 ; 8817 found = 0;; 8818 fp = fp2 = NULL;; 8819 ; 8820 /* Regard empty password as no password - remove user record. */; 8821 if ((pass != NULL) && (pass[0] == '\0')) {; 8822 pass = NULL;; 8823 }; 8824 ;",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:270789,Modifiability,config,config,270789,"se if (!a->file.is_directory && b->file.is_directory) {; 9413 return 1; /* Always put directories on top */; 9414 } else if (*query_string == 'n') {; 9415 cmp_result = strcmp(a->file_name, b->file_name);; 9416 } else if (*query_string == 's') {; 9417 cmp_result = (a->file.size == b->file.size); 9418 ? 0; 9419 : ((a->file.size > b->file.size) ? 1 : -1);; 9420 } else if (*query_string == 'd') {; 9421 cmp_result =; 9422 (a->file.last_modified == b->file.last_modified); 9423 ? 0; 9424 : ((a->file.last_modified > b->file.last_modified) ? 1; 9425 : -1);; 9426 }; 9427 ; 9428 return (query_string[1] == 'd') ? -cmp_result : cmp_result;; 9429 }; 9430 return 0;; 9431}; 9432 ; 9433 ; 9434static int; 9435must_hide_file(struct mg_connection *conn, const char *path); 9436{; 9437 if (conn && conn->dom_ctx) {; 9438 const char *pw_pattern = ""**"" PASSWORDS_FILE_NAME ""$"";; 9439 const char *pattern = conn->dom_ctx->config[HIDE_FILES];; 9440 return (match_prefix_strlen(pw_pattern, path) > 0); 9441 || (match_prefix_strlen(pattern, path) > 0);; 9442 }; 9443 return 0;; 9444}; 9445 ; 9446 ; 9447#if !defined(NO_FILESYSTEMS); 9448static int; 9449scan_directory(struct mg_connection *conn,; 9450 const char *dir,; 9451 void *data,; 9452 int (*cb)(struct de *, void *)); 9453{; 9454 char path[UTF8_PATH_MAX];; 9455 struct dirent *dp;; 9456 DIR *dirp;; 9457 struct de de;; 9458 int truncated;; 9459 ; 9460 if ((dirp = mg_opendir(conn, dir)) == NULL) {; 9461 return 0;; 9462 } else {; 9463 de.conn = conn;; 9464 ; 9465 while ((dp = mg_readdir(dirp)) != NULL) {; 9466 /* Do not show current dir and hidden files */; 9467 if (!strcmp(dp->d_name, ""."") || !strcmp(dp->d_name, ""..""); 9468 || must_hide_file(conn, dp->d_name)) {; 9469 continue;; 9470 }; 9471 ; 9472 mg_snprintf(; 9473 conn, &truncated, path, sizeof(path), ""%s/%s"", dir, dp->d_name);; 9474 ; 9475 /* If we don't memset stat structure to zero, mtime will have; 9476 * garbage and strftime() will segfault later on in; 9477 * print_dir_entry(). memset is re",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:279268,Modifiability,config,config,279268,"ntries[i].file_name);; 9716 }; 9717 mg_free(data.entries);; 9718 }; 9719 ; 9720 mg_printf(conn, ""%s"", ""</table></pre></body></html>"");; 9721 conn->status_code = 200;; 9722}; 9723#endif /* NO_FILESYSTEMS */; 9724 ; 9725 ; 9726/* Send len bytes from the opened file to the client. */; 9727static void; 9728send_file_data(struct mg_connection *conn,; 9729 struct mg_file *filep,; 9730 int64_t offset,; 9731 int64_t len); 9732{; 9733 char buf[MG_BUF_LEN];; 9734 int to_read, num_read, num_written;; 9735 int64_t size;; 9736 ; 9737 if (!filep || !conn) {; 9738 return;; 9739 }; 9740 ; 9741 /* Sanity check the offset */; 9742 size = (filep->stat.size > INT64_MAX) ? INT64_MAX; 9743 : (int64_t)(filep->stat.size);; 9744 offset = (offset < 0) ? 0 : ((offset > size) ? size : offset);; 9745 ; 9746 if (len > 0 && filep->access.fp != NULL) {; 9747 /* file stored on disk */; 9748#if defined(__linux__); 9749 /* sendfile is only available for Linux */; 9750 if ((conn->ssl == 0) && (conn->throttle == 0); 9751 && (!mg_strcasecmp(conn->dom_ctx->config[ALLOW_SENDFILE_CALL],; 9752 ""yes""))) {; 9753 off_t sf_offs = (off_t)offset;; 9754 ssize_t sf_sent;; 9755 int sf_file = fileno(filep->access.fp);; 9756 int loop_cnt = 0;; 9757 ; 9758 do {; 9759 /* 2147479552 (0x7FFFF000) is a limit found by experiment on; 9760 * 64 bit Linux (2^31 minus one memory page of 4k?). */; 9761 size_t sf_tosend =; 9762 (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);; 9763 sf_sent =; 9764 sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);; 9765 if (sf_sent > 0) {; 9766 len -= sf_sent;; 9767 offset += sf_sent;; 9768 } else if (loop_cnt == 0) {; 9769 /* This file can not be sent using sendfile.; 9770 * This might be the case for pseudo-files in the; 9771 * /sys/ and /proc/ file system.; 9772 * Use the regular user mode copy code instead. */; 9773 break;; 9774 } else if (sf_sent == 0) {; 9775 /* No error, but 0 bytes sent. May be EOF? */; 9776 return;; 9777 }; 9778 loop_cnt++;; 9779 ; 9780 } while ((len > 0) && (sf_",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:284594,Modifiability,rewrite,rewrite,284594,"too small or a; 9905 * ""range"" request was made, on the fly compression is not possible. */; 9906 int allow_on_the_fly_compression = 1;; 9907#endif; 9908 ; 9909 if ((conn == NULL) || (conn->dom_ctx == NULL) || (filep == NULL)) {; 9910 return;; 9911 }; 9912 ; 9913 is_head_request = !strcmp(conn->request_info.request_method, ""HEAD"");; 9914 ; 9915 if (mime_type == NULL) {; 9916 get_mime_type(conn, path, &mime_vec);; 9917 } else {; 9918 mime_vec.ptr = mime_type;; 9919 mime_vec.len = strlen(mime_type);; 9920 }; 9921 if (filep->stat.size > INT64_MAX) {; 9922 mg_send_http_error(conn,; 9923 500,; 9924 ""Error: File size is too large to send\n%"" INT64_FMT,; 9925 filep->stat.size);; 9926 return;; 9927 }; 9928 cl = (int64_t)filep->stat.size;; 9929 conn->status_code = 200;; 9930 range[0] = '\0';; 9931 ; 9932#if defined(USE_ZLIB); 9933 /* if this file is in fact a pre-gzipped file, rewrite its filename; 9934 * it's important to rewrite the filename after resolving; 9935 * the mime type from it, to preserve the actual file's type */; 9936 if (!conn->accept_gzip) {; 9937 allow_on_the_fly_compression = 0;; 9938 }; 9939#endif; 9940 ; 9941 /* Check if there is a range header */; 9942 range_hdr = mg_get_header(conn, ""Range"");; 9943 ; 9944 /* For gzipped files, add *.gz */; 9945 if (filep->stat.is_gzipped) {; 9946 mg_snprintf(conn, &truncated, gz_path, sizeof(gz_path), ""%s.gz"", path);; 9947 ; 9948 if (truncated) {; 9949 mg_send_http_error(conn,; 9950 500,; 9951 ""Error: Path of zipped file too long (%s)"",; 9952 path);; 9953 return;; 9954 }; 9955 ; 9956 path = gz_path;; 9957 encoding = ""gzip"";; 9958 ; 9959#if defined(USE_ZLIB); 9960 /* File is already compressed. No ""on the fly"" compression. */; 9961 allow_on_the_fly_compression = 0;; 9962#endif; 9963 } else if ((conn->accept_gzip) && (range_hdr == NULL); 9964 && (filep->stat.size >= MG_FILE_COMPRESSION_SIZE_LIMIT)) {; 9965 struct mg_file_stat file_stat;; 9966 ; 9967 mg_snprintf(conn, &truncated, gz_path, sizeof(gz_path), ""%s.gz"", path);; ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:284641,Modifiability,rewrite,rewrite,284641,"too small or a; 9905 * ""range"" request was made, on the fly compression is not possible. */; 9906 int allow_on_the_fly_compression = 1;; 9907#endif; 9908 ; 9909 if ((conn == NULL) || (conn->dom_ctx == NULL) || (filep == NULL)) {; 9910 return;; 9911 }; 9912 ; 9913 is_head_request = !strcmp(conn->request_info.request_method, ""HEAD"");; 9914 ; 9915 if (mime_type == NULL) {; 9916 get_mime_type(conn, path, &mime_vec);; 9917 } else {; 9918 mime_vec.ptr = mime_type;; 9919 mime_vec.len = strlen(mime_type);; 9920 }; 9921 if (filep->stat.size > INT64_MAX) {; 9922 mg_send_http_error(conn,; 9923 500,; 9924 ""Error: File size is too large to send\n%"" INT64_FMT,; 9925 filep->stat.size);; 9926 return;; 9927 }; 9928 cl = (int64_t)filep->stat.size;; 9929 conn->status_code = 200;; 9930 range[0] = '\0';; 9931 ; 9932#if defined(USE_ZLIB); 9933 /* if this file is in fact a pre-gzipped file, rewrite its filename; 9934 * it's important to rewrite the filename after resolving; 9935 * the mime type from it, to preserve the actual file's type */; 9936 if (!conn->accept_gzip) {; 9937 allow_on_the_fly_compression = 0;; 9938 }; 9939#endif; 9940 ; 9941 /* Check if there is a range header */; 9942 range_hdr = mg_get_header(conn, ""Range"");; 9943 ; 9944 /* For gzipped files, add *.gz */; 9945 if (filep->stat.is_gzipped) {; 9946 mg_snprintf(conn, &truncated, gz_path, sizeof(gz_path), ""%s.gz"", path);; 9947 ; 9948 if (truncated) {; 9949 mg_send_http_error(conn,; 9950 500,; 9951 ""Error: Path of zipped file too long (%s)"",; 9952 path);; 9953 return;; 9954 }; 9955 ; 9956 path = gz_path;; 9957 encoding = ""gzip"";; 9958 ; 9959#if defined(USE_ZLIB); 9960 /* File is already compressed. No ""on the fly"" compression. */; 9961 allow_on_the_fly_compression = 0;; 9962#endif; 9963 } else if ((conn->accept_gzip) && (range_hdr == NULL); 9964 && (filep->stat.size >= MG_FILE_COMPRESSION_SIZE_LIMIT)) {; 9965 struct mg_file_stat file_stat;; 9966 ; 9967 mg_snprintf(conn, &truncated, gz_path, sizeof(gz_path), ""%s.gz"", path);; ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:288002,Modifiability,config,config,288002,"ep->access); /* ignore error on read only file */; 10011 return;; 10012 }; 10013 conn->status_code = 206;; 10014 cl = (n == 2) ? (((r2 > cl) ? cl : r2) - r1 + 1) : (cl - r1);; 10015 mg_snprintf(conn,; 10016 NULL, /* range buffer is big enough */; 10017 range,; 10018 sizeof(range),; 10019 ""bytes ""; 10020 ""%"" INT64_FMT ""-%"" INT64_FMT ""/%"" INT64_FMT,; 10021 r1,; 10022 r1 + cl - 1,; 10023 filep->stat.size);; 10024 ; 10025#if defined(USE_ZLIB); 10026 /* Do not compress ranges. */; 10027 allow_on_the_fly_compression = 0;; 10028#endif; 10029 }; 10030 ; 10031 /* Do not compress small files. Small files do not benefit from file; 10032 * compression, but there is still some overhead. */; 10033#if defined(USE_ZLIB); 10034 if (filep->stat.size < MG_FILE_COMPRESSION_SIZE_LIMIT) {; 10035 /* File is below the size limit. */; 10036 allow_on_the_fly_compression = 0;; 10037 }; 10038#endif; 10039 ; 10040 /* Standard CORS header */; 10041 cors_orig_cfg = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];; 10042 origin_hdr = mg_get_header(conn, ""Origin"");; 10043 if (cors_orig_cfg && *cors_orig_cfg && origin_hdr) {; 10044 /* Cross-origin resource sharing (CORS), see; 10045 * http://www.html5rocks.com/en/tutorials/cors/,; 10046 * http://www.html5rocks.com/static/images/cors_server_flowchart.png; 10047 * -; 10048 * preflight is not supported for files. */; 10049 cors1 = ""Access-Control-Allow-Origin"";; 10050 cors2 = cors_orig_cfg;; 10051 } else {; 10052 cors1 = cors2 = """";; 10053 }; 10054 ; 10055 /* Credentials CORS header */; 10056 cors_cred_cfg = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_CREDENTIALS];; 10057 if (cors_cred_cfg && *cors_cred_cfg && origin_hdr) {; 10058 cors3 = ""Access-Control-Allow-Credentials"";; 10059 cors4 = cors_cred_cfg;; 10060 } else {; 10061 cors3 = cors4 = """";; 10062 }; 10063 ; 10064 /* Prepare Etag, and Last-Modified headers. */; 10065 gmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);; 10066 construct_etag(etag, sizeof(etag), &filep->stat);; 10067 ; 1006",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:288604,Modifiability,config,config,288604,"not benefit from file; 10032 * compression, but there is still some overhead. */; 10033#if defined(USE_ZLIB); 10034 if (filep->stat.size < MG_FILE_COMPRESSION_SIZE_LIMIT) {; 10035 /* File is below the size limit. */; 10036 allow_on_the_fly_compression = 0;; 10037 }; 10038#endif; 10039 ; 10040 /* Standard CORS header */; 10041 cors_orig_cfg = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];; 10042 origin_hdr = mg_get_header(conn, ""Origin"");; 10043 if (cors_orig_cfg && *cors_orig_cfg && origin_hdr) {; 10044 /* Cross-origin resource sharing (CORS), see; 10045 * http://www.html5rocks.com/en/tutorials/cors/,; 10046 * http://www.html5rocks.com/static/images/cors_server_flowchart.png; 10047 * -; 10048 * preflight is not supported for files. */; 10049 cors1 = ""Access-Control-Allow-Origin"";; 10050 cors2 = cors_orig_cfg;; 10051 } else {; 10052 cors1 = cors2 = """";; 10053 }; 10054 ; 10055 /* Credentials CORS header */; 10056 cors_cred_cfg = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_CREDENTIALS];; 10057 if (cors_cred_cfg && *cors_cred_cfg && origin_hdr) {; 10058 cors3 = ""Access-Control-Allow-Credentials"";; 10059 cors4 = cors_cred_cfg;; 10060 } else {; 10061 cors3 = cors4 = """";; 10062 }; 10063 ; 10064 /* Prepare Etag, and Last-Modified headers. */; 10065 gmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);; 10066 construct_etag(etag, sizeof(etag), &filep->stat);; 10067 ; 10068 /* Create 2xx (200, 206) response */; 10069 mg_response_header_start(conn, conn->status_code);; 10070 send_static_cache_header(conn);; 10071 send_additional_header(conn);; 10072 mg_response_header_add(conn,; 10073 ""Content-Type"",; 10074 mime_vec.ptr,; 10075 (int)mime_vec.len);; 10076 if (cors1[0] != 0) {; 10077 mg_response_header_add(conn, cors1, cors2, -1);; 10078 }; 10079 if (cors3[0] != 0) {; 10080 mg_response_header_add(conn, cors3, cors4, -1);; 10081 }; 10082 mg_response_header_add(conn, ""Last-Modified"", lm, -1);; 10083 mg_response_header_add(conn, ""Etag"", etag, -1);; 10084 ; 10085#if defin",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:294595,Modifiability,config,config,294595,"15{; 10216 mg_send_mime_file2(conn, path, mime_type, NULL);; 10217}; 10218 ; 10219 ; 10220void; 10221mg_send_mime_file2(struct mg_connection *conn,; 10222 const char *path,; 10223 const char *mime_type,; 10224 const char *additional_headers); 10225{; 10226 struct mg_file file = STRUCT_FILE_INITIALIZER;; 10227 ; 10228 if (!conn) {; 10229 /* No conn */; 10230 return;; 10231 }; 10232 ; 10233 if (mg_stat(conn, path, &file.stat)) {; 10234#if !defined(NO_CACHING); 10235 if (is_not_modified(conn, &file.stat)) {; 10236 /* Send 304 ""Not Modified"" - this must not send any body data */; 10237 handle_not_modified_static_file_request(conn, &file);; 10238 } else; 10239#endif /* NO_CACHING */; 10240 if (file.stat.is_directory) {; 10241 if (!mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],; 10242 ""yes"")) {; 10243 handle_directory_request(conn, path);; 10244 } else {; 10245 mg_send_http_error(conn,; 10246 403,; 10247 ""%s"",; 10248 ""Error: Directory listing denied"");; 10249 }; 10250 } else {; 10251 handle_static_file_request(; 10252 conn, path, &file, mime_type, additional_headers);; 10253 }; 10254 } else {; 10255 mg_send_http_error(conn, 404, ""%s"", ""Error: File not found"");; 10256 }; 10257}; 10258 ; 10259 ; 10260/* For a given PUT path, create all intermediate subdirectories.; 10261 * Return 0 if the path itself is a directory.; 10262 * Return 1 if the path leads to a file.; 10263 * Return -1 for if the path is too long.; 10264 * Return -2 if path can not be created.; 10265 */; 10266static int; 10267put_dir(struct mg_connection *conn, const char *path); 10268{; 10269 char buf[UTF8_PATH_MAX];; 10270 const char *s, *p;; 10271 struct mg_file file = STRUCT_FILE_INITIALIZER;; 10272 size_t len;; 10273 int res = 1;; 10274 ; 10275 for (s = p = path + 2; (p = strchr(s, '/')) != NULL; s = ++p) {; 10276 len = (size_t)(p - path);; 10277 if (len >= sizeof(buf)) {; 10278 /* path too long */; 10279 res = -1;; 10280 break;; 10281 }; 10282 memcpy(buf, path, len);; 10283 buf[len] = '\0';",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:311125,Modifiability,config,config,311125,"har)*buf));; 10779 ; 10780 ; 10781 /* Parse all HTTP headers */; 10782 ri->num_headers = parse_http_headers(&buf, ri->http_headers);; 10783 if (ri->num_headers < 0) {; 10784 /* Error while parsing headers */; 10785 return -1;; 10786 }; 10787 ; 10788 return response_length + init_skip;; 10789}; 10790 ; 10791 ; 10792/* Keep reading the input (either opened file descriptor fd, or socket sock,; 10793 * or SSL descriptor ssl) into buffer buf, until \r\n\r\n appears in the; 10794 * buffer (which marks the end of HTTP request). Buffer buf may already; 10795 * have some data. The length of the data is stored in nread.; 10796 * Upon every read operation, increase nread by the number of bytes read. */; 10797static int; 10798read_message(FILE *fp,; 10799 struct mg_connection *conn,; 10800 char *buf,; 10801 int bufsiz,; 10802 int *nread); 10803{; 10804 int request_len, n = 0;; 10805 struct timespec last_action_time;; 10806 double request_timeout;; 10807 ; 10808 if (!conn) {; 10809 return 0;; 10810 }; 10811 ; 10812 memset(&last_action_time, 0, sizeof(last_action_time));; 10813 ; 10814 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 10815 /* value of request_timeout is in seconds, config in milliseconds */; 10816 request_timeout =; 10817 strtod(conn->dom_ctx->config[REQUEST_TIMEOUT], NULL) / 1000.0;; 10818 } else {; 10819 request_timeout =; 10820 strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 10821 / 1000.0;; 10822 }; 10823 if (conn->handled_requests > 0) {; 10824 if (conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT]) {; 10825 request_timeout =; 10826 strtod(conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT], NULL); 10827 / 1000.0;; 10828 }; 10829 }; 10830 ; 10831 request_len = get_http_header_len(buf, *nread);; 10832 ; 10833 while (request_len == 0) {; 10834 /* Full request not yet received */; 10835 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 10836 /* Server is to be stopped. */; 10837 return -1;; 10838 }; 10839 ; 10840 if (*nread >= bufsiz) {; 10841 /* Request too long ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:311202,Modifiability,config,config,311202,"har)*buf));; 10779 ; 10780 ; 10781 /* Parse all HTTP headers */; 10782 ri->num_headers = parse_http_headers(&buf, ri->http_headers);; 10783 if (ri->num_headers < 0) {; 10784 /* Error while parsing headers */; 10785 return -1;; 10786 }; 10787 ; 10788 return response_length + init_skip;; 10789}; 10790 ; 10791 ; 10792/* Keep reading the input (either opened file descriptor fd, or socket sock,; 10793 * or SSL descriptor ssl) into buffer buf, until \r\n\r\n appears in the; 10794 * buffer (which marks the end of HTTP request). Buffer buf may already; 10795 * have some data. The length of the data is stored in nread.; 10796 * Upon every read operation, increase nread by the number of bytes read. */; 10797static int; 10798read_message(FILE *fp,; 10799 struct mg_connection *conn,; 10800 char *buf,; 10801 int bufsiz,; 10802 int *nread); 10803{; 10804 int request_len, n = 0;; 10805 struct timespec last_action_time;; 10806 double request_timeout;; 10807 ; 10808 if (!conn) {; 10809 return 0;; 10810 }; 10811 ; 10812 memset(&last_action_time, 0, sizeof(last_action_time));; 10813 ; 10814 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 10815 /* value of request_timeout is in seconds, config in milliseconds */; 10816 request_timeout =; 10817 strtod(conn->dom_ctx->config[REQUEST_TIMEOUT], NULL) / 1000.0;; 10818 } else {; 10819 request_timeout =; 10820 strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 10821 / 1000.0;; 10822 }; 10823 if (conn->handled_requests > 0) {; 10824 if (conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT]) {; 10825 request_timeout =; 10826 strtod(conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT], NULL); 10827 / 1000.0;; 10828 }; 10829 }; 10830 ; 10831 request_len = get_http_header_len(buf, *nread);; 10832 ; 10833 while (request_len == 0) {; 10834 /* Full request not yet received */; 10835 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 10836 /* Server is to be stopped. */; 10837 return -1;; 10838 }; 10839 ; 10840 if (*nread >= bufsiz) {; 10841 /* Request too long ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:311282,Modifiability,config,config,311282,"har)*buf));; 10779 ; 10780 ; 10781 /* Parse all HTTP headers */; 10782 ri->num_headers = parse_http_headers(&buf, ri->http_headers);; 10783 if (ri->num_headers < 0) {; 10784 /* Error while parsing headers */; 10785 return -1;; 10786 }; 10787 ; 10788 return response_length + init_skip;; 10789}; 10790 ; 10791 ; 10792/* Keep reading the input (either opened file descriptor fd, or socket sock,; 10793 * or SSL descriptor ssl) into buffer buf, until \r\n\r\n appears in the; 10794 * buffer (which marks the end of HTTP request). Buffer buf may already; 10795 * have some data. The length of the data is stored in nread.; 10796 * Upon every read operation, increase nread by the number of bytes read. */; 10797static int; 10798read_message(FILE *fp,; 10799 struct mg_connection *conn,; 10800 char *buf,; 10801 int bufsiz,; 10802 int *nread); 10803{; 10804 int request_len, n = 0;; 10805 struct timespec last_action_time;; 10806 double request_timeout;; 10807 ; 10808 if (!conn) {; 10809 return 0;; 10810 }; 10811 ; 10812 memset(&last_action_time, 0, sizeof(last_action_time));; 10813 ; 10814 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 10815 /* value of request_timeout is in seconds, config in milliseconds */; 10816 request_timeout =; 10817 strtod(conn->dom_ctx->config[REQUEST_TIMEOUT], NULL) / 1000.0;; 10818 } else {; 10819 request_timeout =; 10820 strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 10821 / 1000.0;; 10822 }; 10823 if (conn->handled_requests > 0) {; 10824 if (conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT]) {; 10825 request_timeout =; 10826 strtod(conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT], NULL); 10827 / 1000.0;; 10828 }; 10829 }; 10830 ; 10831 request_len = get_http_header_len(buf, *nread);; 10832 ; 10833 while (request_len == 0) {; 10834 /* Full request not yet received */; 10835 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 10836 /* Server is to be stopped. */; 10837 return -1;; 10838 }; 10839 ; 10840 if (*nread >= bufsiz) {; 10841 /* Request too long ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:311524,Modifiability,config,config,311524," buf may already; 10795 * have some data. The length of the data is stored in nread.; 10796 * Upon every read operation, increase nread by the number of bytes read. */; 10797static int; 10798read_message(FILE *fp,; 10799 struct mg_connection *conn,; 10800 char *buf,; 10801 int bufsiz,; 10802 int *nread); 10803{; 10804 int request_len, n = 0;; 10805 struct timespec last_action_time;; 10806 double request_timeout;; 10807 ; 10808 if (!conn) {; 10809 return 0;; 10810 }; 10811 ; 10812 memset(&last_action_time, 0, sizeof(last_action_time));; 10813 ; 10814 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 10815 /* value of request_timeout is in seconds, config in milliseconds */; 10816 request_timeout =; 10817 strtod(conn->dom_ctx->config[REQUEST_TIMEOUT], NULL) / 1000.0;; 10818 } else {; 10819 request_timeout =; 10820 strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 10821 / 1000.0;; 10822 }; 10823 if (conn->handled_requests > 0) {; 10824 if (conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT]) {; 10825 request_timeout =; 10826 strtod(conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT], NULL); 10827 / 1000.0;; 10828 }; 10829 }; 10830 ; 10831 request_len = get_http_header_len(buf, *nread);; 10832 ; 10833 while (request_len == 0) {; 10834 /* Full request not yet received */; 10835 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 10836 /* Server is to be stopped. */; 10837 return -1;; 10838 }; 10839 ; 10840 if (*nread >= bufsiz) {; 10841 /* Request too long */; 10842 return -2;; 10843 }; 10844 ; 10845 n = pull_inner(; 10846 fp, conn, buf + *nread, bufsiz - *nread, request_timeout);; 10847 if (n == -2) {; 10848 /* Receive error */; 10849 return -1;; 10850 }; 10851 ; 10852 /* update clock after every read request */; 10853 clock_gettime(CLOCK_MONOTONIC, &last_action_time);; 10854 ; 10855 if (n > 0) {; 10856 *nread += n;; 10857 request_len = get_http_header_len(buf, *nread);; 10858 }; 10859 ; 10860 if ((request_len == 0) && (request_timeout >= 0)) {; 10861 if (mg_difftimespec(&last_ac",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:311608,Modifiability,config,config,311608," buf may already; 10795 * have some data. The length of the data is stored in nread.; 10796 * Upon every read operation, increase nread by the number of bytes read. */; 10797static int; 10798read_message(FILE *fp,; 10799 struct mg_connection *conn,; 10800 char *buf,; 10801 int bufsiz,; 10802 int *nread); 10803{; 10804 int request_len, n = 0;; 10805 struct timespec last_action_time;; 10806 double request_timeout;; 10807 ; 10808 if (!conn) {; 10809 return 0;; 10810 }; 10811 ; 10812 memset(&last_action_time, 0, sizeof(last_action_time));; 10813 ; 10814 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 10815 /* value of request_timeout is in seconds, config in milliseconds */; 10816 request_timeout =; 10817 strtod(conn->dom_ctx->config[REQUEST_TIMEOUT], NULL) / 1000.0;; 10818 } else {; 10819 request_timeout =; 10820 strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 10821 / 1000.0;; 10822 }; 10823 if (conn->handled_requests > 0) {; 10824 if (conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT]) {; 10825 request_timeout =; 10826 strtod(conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT], NULL); 10827 / 1000.0;; 10828 }; 10829 }; 10830 ; 10831 request_len = get_http_header_len(buf, *nread);; 10832 ; 10833 while (request_len == 0) {; 10834 /* Full request not yet received */; 10835 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 10836 /* Server is to be stopped. */; 10837 return -1;; 10838 }; 10839 ; 10840 if (*nread >= bufsiz) {; 10841 /* Request too long */; 10842 return -2;; 10843 }; 10844 ; 10845 n = pull_inner(; 10846 fp, conn, buf + *nread, bufsiz - *nread, request_timeout);; 10847 if (n == -2) {; 10848 /* Receive error */; 10849 return -1;; 10850 }; 10851 ; 10852 /* update clock after every read request */; 10853 clock_gettime(CLOCK_MONOTONIC, &last_action_time);; 10854 ; 10855 if (n > 0) {; 10856 *nread += n;; 10857 request_len = get_http_header_len(buf, *nread);; 10858 }; 10859 ; 10860 if ((request_len == 0) && (request_timeout >= 0)) {; 10861 if (mg_difftimespec(&last_ac",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:315617,Modifiability,variab,variables,315617,"0935 ; 10936#if defined(USE_TIMERS); 10937 ; 10938#define TIMER_API static; 10939#include ""timer.inl""; 10940 ; 10941#endif /* USE_TIMERS */; 10942 ; 10943 ; 10944#if !defined(NO_CGI); 10945/* This structure helps to create an environment for the spawned CGI; 10946 * program.; 10947 * Environment is an array of ""VARIABLE=VALUE\0"" ASCII strings,; 10948 * last element must be NULL.; 10949 * However, on Windows there is a requirement that all these; 10950 * VARIABLE=VALUE\0; 10951 * strings must reside in a contiguous buffer. The end of the buffer is; 10952 * marked by two '\0' characters.; 10953 * We satisfy both worlds: we create an envp array (which is vars), all; 10954 * entries are actually pointers inside buf. */; 10955struct cgi_environment {; 10956 struct mg_connection *conn;; 10957 /* Data block */; 10958 char *buf; /* Environment buffer */; 10959 size_t buflen; /* Space available in buf */; 10960 size_t bufused; /* Space taken in buf */; 10961 /* Index block */; 10962 char **var; /* char **envp */; 10963 size_t varlen; /* Number of variables available in var */; 10964 size_t varused; /* Number of variables stored in var */; 10965};; 10966 ; 10967 ; 10968static void addenv(struct cgi_environment *env,; 10969 PRINTF_FORMAT_STRING(const char *fmt),; 10970 ...) PRINTF_ARGS(2, 3);; 10971 ; 10972/* Append VARIABLE=VALUE\0 string to the buffer, and add a respective; 10973 * pointer into the vars array. Assumes env != NULL and fmt != NULL. */; 10974static void; 10975addenv(struct cgi_environment *env, const char *fmt, ...); 10976{; 10977 size_t i, n, space;; 10978 int truncated = 0;; 10979 char *added;; 10980 va_list ap;; 10981 ; 10982 if ((env->varlen - env->varused) < 2) {; 10983 mg_cry_internal(env->conn,; 10984 ""%s: Cannot register CGI variable [%s]"",; 10985 __func__,; 10986 fmt);; 10987 return;; 10988 }; 10989 ; 10990 /* Calculate how much space is left in the buffer */; 10991 space = (env->buflen - env->bufused);; 10992 ; 10993 do {; 10994 /* Space for ""\0\0"" is ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:315683,Modifiability,variab,variables,315683,"0935 ; 10936#if defined(USE_TIMERS); 10937 ; 10938#define TIMER_API static; 10939#include ""timer.inl""; 10940 ; 10941#endif /* USE_TIMERS */; 10942 ; 10943 ; 10944#if !defined(NO_CGI); 10945/* This structure helps to create an environment for the spawned CGI; 10946 * program.; 10947 * Environment is an array of ""VARIABLE=VALUE\0"" ASCII strings,; 10948 * last element must be NULL.; 10949 * However, on Windows there is a requirement that all these; 10950 * VARIABLE=VALUE\0; 10951 * strings must reside in a contiguous buffer. The end of the buffer is; 10952 * marked by two '\0' characters.; 10953 * We satisfy both worlds: we create an envp array (which is vars), all; 10954 * entries are actually pointers inside buf. */; 10955struct cgi_environment {; 10956 struct mg_connection *conn;; 10957 /* Data block */; 10958 char *buf; /* Environment buffer */; 10959 size_t buflen; /* Space available in buf */; 10960 size_t bufused; /* Space taken in buf */; 10961 /* Index block */; 10962 char **var; /* char **envp */; 10963 size_t varlen; /* Number of variables available in var */; 10964 size_t varused; /* Number of variables stored in var */; 10965};; 10966 ; 10967 ; 10968static void addenv(struct cgi_environment *env,; 10969 PRINTF_FORMAT_STRING(const char *fmt),; 10970 ...) PRINTF_ARGS(2, 3);; 10971 ; 10972/* Append VARIABLE=VALUE\0 string to the buffer, and add a respective; 10973 * pointer into the vars array. Assumes env != NULL and fmt != NULL. */; 10974static void; 10975addenv(struct cgi_environment *env, const char *fmt, ...); 10976{; 10977 size_t i, n, space;; 10978 int truncated = 0;; 10979 char *added;; 10980 va_list ap;; 10981 ; 10982 if ((env->varlen - env->varused) < 2) {; 10983 mg_cry_internal(env->conn,; 10984 ""%s: Cannot register CGI variable [%s]"",; 10985 __func__,; 10986 fmt);; 10987 return;; 10988 }; 10989 ; 10990 /* Calculate how much space is left in the buffer */; 10991 space = (env->buflen - env->bufused);; 10992 ; 10993 do {; 10994 /* Space for ""\0\0"" is ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:316331,Modifiability,variab,variable,316331,"ion *conn;; 10957 /* Data block */; 10958 char *buf; /* Environment buffer */; 10959 size_t buflen; /* Space available in buf */; 10960 size_t bufused; /* Space taken in buf */; 10961 /* Index block */; 10962 char **var; /* char **envp */; 10963 size_t varlen; /* Number of variables available in var */; 10964 size_t varused; /* Number of variables stored in var */; 10965};; 10966 ; 10967 ; 10968static void addenv(struct cgi_environment *env,; 10969 PRINTF_FORMAT_STRING(const char *fmt),; 10970 ...) PRINTF_ARGS(2, 3);; 10971 ; 10972/* Append VARIABLE=VALUE\0 string to the buffer, and add a respective; 10973 * pointer into the vars array. Assumes env != NULL and fmt != NULL. */; 10974static void; 10975addenv(struct cgi_environment *env, const char *fmt, ...); 10976{; 10977 size_t i, n, space;; 10978 int truncated = 0;; 10979 char *added;; 10980 va_list ap;; 10981 ; 10982 if ((env->varlen - env->varused) < 2) {; 10983 mg_cry_internal(env->conn,; 10984 ""%s: Cannot register CGI variable [%s]"",; 10985 __func__,; 10986 fmt);; 10987 return;; 10988 }; 10989 ; 10990 /* Calculate how much space is left in the buffer */; 10991 space = (env->buflen - env->bufused);; 10992 ; 10993 do {; 10994 /* Space for ""\0\0"" is always needed. */; 10995 if (space <= 2) {; 10996 /* Allocate new buffer */; 10997 n = env->buflen + CGI_ENVIRONMENT_SIZE;; 10998 added = (char *)mg_realloc_ctx(env->buf, n, env->conn->phys_ctx);; 10999 if (!added) {; 11000 /* Out of memory */; 11001 mg_cry_internal(; 11002 env->conn,; 11003 ""%s: Cannot allocate memory for CGI variable [%s]"",; 11004 __func__,; 11005 fmt);; 11006 return;; 11007 }; 11008 /* Retarget pointers */; 11009 env->buf = added;; 11010 env->buflen = n;; 11011 for (i = 0, n = 0; i < env->varused; i++) {; 11012 env->var[i] = added + n;; 11013 n += strlen(added + n) + 1;; 11014 }; 11015 space = (env->buflen - env->bufused);; 11016 }; 11017 ; 11018 /* Make a pointer to the free space int the buffer */; 11019 added = env->buf + env->bufused;; 11020 ; 1",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:316893,Modifiability,variab,variable,316893,"Cannot register CGI variable [%s]"",; 10985 __func__,; 10986 fmt);; 10987 return;; 10988 }; 10989 ; 10990 /* Calculate how much space is left in the buffer */; 10991 space = (env->buflen - env->bufused);; 10992 ; 10993 do {; 10994 /* Space for ""\0\0"" is always needed. */; 10995 if (space <= 2) {; 10996 /* Allocate new buffer */; 10997 n = env->buflen + CGI_ENVIRONMENT_SIZE;; 10998 added = (char *)mg_realloc_ctx(env->buf, n, env->conn->phys_ctx);; 10999 if (!added) {; 11000 /* Out of memory */; 11001 mg_cry_internal(; 11002 env->conn,; 11003 ""%s: Cannot allocate memory for CGI variable [%s]"",; 11004 __func__,; 11005 fmt);; 11006 return;; 11007 }; 11008 /* Retarget pointers */; 11009 env->buf = added;; 11010 env->buflen = n;; 11011 for (i = 0, n = 0; i < env->varused; i++) {; 11012 env->var[i] = added + n;; 11013 n += strlen(added + n) + 1;; 11014 }; 11015 space = (env->buflen - env->bufused);; 11016 }; 11017 ; 11018 /* Make a pointer to the free space int the buffer */; 11019 added = env->buf + env->bufused;; 11020 ; 11021 /* Copy VARIABLE=VALUE\0 string into the free space */; 11022 va_start(ap, fmt);; 11023 mg_vsnprintf(env->conn, &truncated, added, space - 1, fmt, ap);; 11024 va_end(ap);; 11025 ; 11026 /* Do not add truncated strings to the environment */; 11027 if (truncated) {; 11028 /* Reallocate the buffer */; 11029 space = 0;; 11030 }; 11031 } while (truncated);; 11032 ; 11033 /* Calculate number of bytes added to the environment */; 11034 n = strlen(added) + 1;; 11035 env->bufused += n;; 11036 ; 11037 /* Append a pointer to the added string into the envp array */; 11038 env->var[env->varused] = added;; 11039 env->varused++;; 11040}; 11041 ; 11042/* Return 0 on success, non-zero if an error occurs. */; 11043 ; 11044static int; 11045prepare_cgi_environment(struct mg_connection *conn,; 11046 const char *prog,; 11047 struct cgi_environment *env,; 11048 unsigned char cgi_config_idx); 11049{; 11050 const char *s;; 11051 struct vec var_vec;; 11052 char *p, src_addr[",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:319084,Modifiability,variab,variables,319084,"env->bufused += n;; 11036 ; 11037 /* Append a pointer to the added string into the envp array */; 11038 env->var[env->varused] = added;; 11039 env->varused++;; 11040}; 11041 ; 11042/* Return 0 on success, non-zero if an error occurs. */; 11043 ; 11044static int; 11045prepare_cgi_environment(struct mg_connection *conn,; 11046 const char *prog,; 11047 struct cgi_environment *env,; 11048 unsigned char cgi_config_idx); 11049{; 11050 const char *s;; 11051 struct vec var_vec;; 11052 char *p, src_addr[IP_ADDR_STR_LEN], http_var_name[128];; 11053 int i, truncated, uri_len;; 11054 ; 11055 if ((conn == NULL) || (prog == NULL) || (env == NULL)) {; 11056 return -1;; 11057 }; 11058 ; 11059 env->conn = conn;; 11060 env->buflen = CGI_ENVIRONMENT_SIZE;; 11061 env->bufused = 0;; 11062 env->buf = (char *)mg_malloc_ctx(env->buflen, conn->phys_ctx);; 11063 if (env->buf == NULL) {; 11064 mg_cry_internal(conn,; 11065 ""%s: Not enough memory for environmental buffer"",; 11066 __func__);; 11067 return -1;; 11068 }; 11069 env->varlen = MAX_CGI_ENVIR_VARS;; 11070 env->varused = 0;; 11071 env->var =; 11072 (char **)mg_malloc_ctx(env->varlen * sizeof(char *), conn->phys_ctx);; 11073 if (env->var == NULL) {; 11074 mg_cry_internal(conn,; 11075 ""%s: Not enough memory for environmental variables"",; 11076 __func__);; 11077 mg_free(env->buf);; 11078 return -1;; 11079 }; 11080 ; 11081 addenv(env, ""SERVER_NAME=%s"", conn->dom_ctx->config[AUTHENTICATION_DOMAIN]);; 11082 addenv(env, ""SERVER_ROOT=%s"", conn->dom_ctx->config[DOCUMENT_ROOT]);; 11083 addenv(env, ""DOCUMENT_ROOT=%s"", conn->dom_ctx->config[DOCUMENT_ROOT]);; 11084 addenv(env, ""SERVER_SOFTWARE=CivetWeb/%s"", mg_version());; 11085 ; 11086 /* Prepare the environment block */; 11087 addenv(env, ""%s"", ""GATEWAY_INTERFACE=CGI/1.1"");; 11088 addenv(env, ""%s"", ""SERVER_PROTOCOL=HTTP/1.1"");; 11089 addenv(env, ""%s"", ""REDIRECT_STATUS=200""); /* For PHP */; 11090 ; 11091 addenv(env, ""SERVER_PORT=%d"", conn->request_info.server_port);; 11092 ; 11093 sockaddr_to_string",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:319227,Modifiability,config,config,319227,"env->bufused += n;; 11036 ; 11037 /* Append a pointer to the added string into the envp array */; 11038 env->var[env->varused] = added;; 11039 env->varused++;; 11040}; 11041 ; 11042/* Return 0 on success, non-zero if an error occurs. */; 11043 ; 11044static int; 11045prepare_cgi_environment(struct mg_connection *conn,; 11046 const char *prog,; 11047 struct cgi_environment *env,; 11048 unsigned char cgi_config_idx); 11049{; 11050 const char *s;; 11051 struct vec var_vec;; 11052 char *p, src_addr[IP_ADDR_STR_LEN], http_var_name[128];; 11053 int i, truncated, uri_len;; 11054 ; 11055 if ((conn == NULL) || (prog == NULL) || (env == NULL)) {; 11056 return -1;; 11057 }; 11058 ; 11059 env->conn = conn;; 11060 env->buflen = CGI_ENVIRONMENT_SIZE;; 11061 env->bufused = 0;; 11062 env->buf = (char *)mg_malloc_ctx(env->buflen, conn->phys_ctx);; 11063 if (env->buf == NULL) {; 11064 mg_cry_internal(conn,; 11065 ""%s: Not enough memory for environmental buffer"",; 11066 __func__);; 11067 return -1;; 11068 }; 11069 env->varlen = MAX_CGI_ENVIR_VARS;; 11070 env->varused = 0;; 11071 env->var =; 11072 (char **)mg_malloc_ctx(env->varlen * sizeof(char *), conn->phys_ctx);; 11073 if (env->var == NULL) {; 11074 mg_cry_internal(conn,; 11075 ""%s: Not enough memory for environmental variables"",; 11076 __func__);; 11077 mg_free(env->buf);; 11078 return -1;; 11079 }; 11080 ; 11081 addenv(env, ""SERVER_NAME=%s"", conn->dom_ctx->config[AUTHENTICATION_DOMAIN]);; 11082 addenv(env, ""SERVER_ROOT=%s"", conn->dom_ctx->config[DOCUMENT_ROOT]);; 11083 addenv(env, ""DOCUMENT_ROOT=%s"", conn->dom_ctx->config[DOCUMENT_ROOT]);; 11084 addenv(env, ""SERVER_SOFTWARE=CivetWeb/%s"", mg_version());; 11085 ; 11086 /* Prepare the environment block */; 11087 addenv(env, ""%s"", ""GATEWAY_INTERFACE=CGI/1.1"");; 11088 addenv(env, ""%s"", ""SERVER_PROTOCOL=HTTP/1.1"");; 11089 addenv(env, ""%s"", ""REDIRECT_STATUS=200""); /* For PHP */; 11090 ; 11091 addenv(env, ""SERVER_PORT=%d"", conn->request_info.server_port);; 11092 ; 11093 sockaddr_to_string",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:319311,Modifiability,config,config,319311,"env->bufused += n;; 11036 ; 11037 /* Append a pointer to the added string into the envp array */; 11038 env->var[env->varused] = added;; 11039 env->varused++;; 11040}; 11041 ; 11042/* Return 0 on success, non-zero if an error occurs. */; 11043 ; 11044static int; 11045prepare_cgi_environment(struct mg_connection *conn,; 11046 const char *prog,; 11047 struct cgi_environment *env,; 11048 unsigned char cgi_config_idx); 11049{; 11050 const char *s;; 11051 struct vec var_vec;; 11052 char *p, src_addr[IP_ADDR_STR_LEN], http_var_name[128];; 11053 int i, truncated, uri_len;; 11054 ; 11055 if ((conn == NULL) || (prog == NULL) || (env == NULL)) {; 11056 return -1;; 11057 }; 11058 ; 11059 env->conn = conn;; 11060 env->buflen = CGI_ENVIRONMENT_SIZE;; 11061 env->bufused = 0;; 11062 env->buf = (char *)mg_malloc_ctx(env->buflen, conn->phys_ctx);; 11063 if (env->buf == NULL) {; 11064 mg_cry_internal(conn,; 11065 ""%s: Not enough memory for environmental buffer"",; 11066 __func__);; 11067 return -1;; 11068 }; 11069 env->varlen = MAX_CGI_ENVIR_VARS;; 11070 env->varused = 0;; 11071 env->var =; 11072 (char **)mg_malloc_ctx(env->varlen * sizeof(char *), conn->phys_ctx);; 11073 if (env->var == NULL) {; 11074 mg_cry_internal(conn,; 11075 ""%s: Not enough memory for environmental variables"",; 11076 __func__);; 11077 mg_free(env->buf);; 11078 return -1;; 11079 }; 11080 ; 11081 addenv(env, ""SERVER_NAME=%s"", conn->dom_ctx->config[AUTHENTICATION_DOMAIN]);; 11082 addenv(env, ""SERVER_ROOT=%s"", conn->dom_ctx->config[DOCUMENT_ROOT]);; 11083 addenv(env, ""DOCUMENT_ROOT=%s"", conn->dom_ctx->config[DOCUMENT_ROOT]);; 11084 addenv(env, ""SERVER_SOFTWARE=CivetWeb/%s"", mg_version());; 11085 ; 11086 /* Prepare the environment block */; 11087 addenv(env, ""%s"", ""GATEWAY_INTERFACE=CGI/1.1"");; 11088 addenv(env, ""%s"", ""SERVER_PROTOCOL=HTTP/1.1"");; 11089 addenv(env, ""%s"", ""REDIRECT_STATUS=200""); /* For PHP */; 11090 ; 11091 addenv(env, ""SERVER_PORT=%d"", conn->request_info.server_port);; 11092 ; 11093 sockaddr_to_string",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:319389,Modifiability,config,config,319389,"env->bufused += n;; 11036 ; 11037 /* Append a pointer to the added string into the envp array */; 11038 env->var[env->varused] = added;; 11039 env->varused++;; 11040}; 11041 ; 11042/* Return 0 on success, non-zero if an error occurs. */; 11043 ; 11044static int; 11045prepare_cgi_environment(struct mg_connection *conn,; 11046 const char *prog,; 11047 struct cgi_environment *env,; 11048 unsigned char cgi_config_idx); 11049{; 11050 const char *s;; 11051 struct vec var_vec;; 11052 char *p, src_addr[IP_ADDR_STR_LEN], http_var_name[128];; 11053 int i, truncated, uri_len;; 11054 ; 11055 if ((conn == NULL) || (prog == NULL) || (env == NULL)) {; 11056 return -1;; 11057 }; 11058 ; 11059 env->conn = conn;; 11060 env->buflen = CGI_ENVIRONMENT_SIZE;; 11061 env->bufused = 0;; 11062 env->buf = (char *)mg_malloc_ctx(env->buflen, conn->phys_ctx);; 11063 if (env->buf == NULL) {; 11064 mg_cry_internal(conn,; 11065 ""%s: Not enough memory for environmental buffer"",; 11066 __func__);; 11067 return -1;; 11068 }; 11069 env->varlen = MAX_CGI_ENVIR_VARS;; 11070 env->varused = 0;; 11071 env->var =; 11072 (char **)mg_malloc_ctx(env->varlen * sizeof(char *), conn->phys_ctx);; 11073 if (env->var == NULL) {; 11074 mg_cry_internal(conn,; 11075 ""%s: Not enough memory for environmental variables"",; 11076 __func__);; 11077 mg_free(env->buf);; 11078 return -1;; 11079 }; 11080 ; 11081 addenv(env, ""SERVER_NAME=%s"", conn->dom_ctx->config[AUTHENTICATION_DOMAIN]);; 11082 addenv(env, ""SERVER_ROOT=%s"", conn->dom_ctx->config[DOCUMENT_ROOT]);; 11083 addenv(env, ""DOCUMENT_ROOT=%s"", conn->dom_ctx->config[DOCUMENT_ROOT]);; 11084 addenv(env, ""SERVER_SOFTWARE=CivetWeb/%s"", mg_version());; 11085 ; 11086 /* Prepare the environment block */; 11087 addenv(env, ""%s"", ""GATEWAY_INTERFACE=CGI/1.1"");; 11088 addenv(env, ""%s"", ""SERVER_PROTOCOL=HTTP/1.1"");; 11089 addenv(env, ""%s"", ""REDIRECT_STATUS=200""); /* For PHP */; 11090 ; 11091 addenv(env, ""SERVER_PORT=%d"", conn->request_info.server_port);; 11092 ; 11093 sockaddr_to_string",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:321222,Modifiability,config,config,321222,")strlen(conn->request_info.local_uri);; 11105 if (conn->path_info == NULL) {; 11106 if (conn->request_info.local_uri[uri_len - 1] != '/') {; 11107 /* URI: /path_to_script/script.cgi */; 11108 addenv(env, ""SCRIPT_NAME=%s"", conn->request_info.local_uri);; 11109 } else {; 11110 /* URI: /path_to_script/ ... using index.cgi */; 11111 const char *index_file = strrchr(prog, '/');; 11112 if (index_file) {; 11113 addenv(env,; 11114 ""SCRIPT_NAME=%s%s"",; 11115 conn->request_info.local_uri,; 11116 index_file + 1);; 11117 }; 11118 }; 11119 } else {; 11120 /* URI: /path_to_script/script.cgi/path_info */; 11121 addenv(env,; 11122 ""SCRIPT_NAME=%.*s"",; 11123 uri_len - (int)strlen(conn->path_info),; 11124 conn->request_info.local_uri);; 11125 }; 11126 ; 11127 addenv(env, ""SCRIPT_FILENAME=%s"", prog);; 11128 if (conn->path_info == NULL) {; 11129 addenv(env, ""PATH_TRANSLATED=%s"", conn->dom_ctx->config[DOCUMENT_ROOT]);; 11130 } else {; 11131 addenv(env,; 11132 ""PATH_TRANSLATED=%s%s"",; 11133 conn->dom_ctx->config[DOCUMENT_ROOT],; 11134 conn->path_info);; 11135 }; 11136 ; 11137 addenv(env, ""HTTPS=%s"", (conn->ssl == NULL) ? ""off"" : ""on"");; 11138 ; 11139 if ((s = mg_get_header(conn, ""Content-Type"")) != NULL) {; 11140 addenv(env, ""CONTENT_TYPE=%s"", s);; 11141 }; 11142 if (conn->request_info.query_string != NULL) {; 11143 addenv(env, ""QUERY_STRING=%s"", conn->request_info.query_string);; 11144 }; 11145 if ((s = mg_get_header(conn, ""Content-Length"")) != NULL) {; 11146 addenv(env, ""CONTENT_LENGTH=%s"", s);; 11147 }; 11148 if ((s = getenv(""PATH"")) != NULL) {; 11149 addenv(env, ""PATH=%s"", s);; 11150 }; 11151 if (conn->path_info != NULL) {; 11152 addenv(env, ""PATH_INFO=%s"", conn->path_info);; 11153 }; 11154 ; 11155 if (conn->status_code > 0) {; 11156 /* CGI error handler should show the status code */; 11157 addenv(env, ""STATUS=%d"", conn->status_code);; 11158 }; 11159 ; 11160#if defined(_WIN32); 11161 if ((s = getenv(""COMSPEC"")) != NULL) {; 11162 addenv(env, ""COMSPEC=%s"", s);; 11163 }; 11164 if ((s = ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:321334,Modifiability,config,config,321334,")strlen(conn->request_info.local_uri);; 11105 if (conn->path_info == NULL) {; 11106 if (conn->request_info.local_uri[uri_len - 1] != '/') {; 11107 /* URI: /path_to_script/script.cgi */; 11108 addenv(env, ""SCRIPT_NAME=%s"", conn->request_info.local_uri);; 11109 } else {; 11110 /* URI: /path_to_script/ ... using index.cgi */; 11111 const char *index_file = strrchr(prog, '/');; 11112 if (index_file) {; 11113 addenv(env,; 11114 ""SCRIPT_NAME=%s%s"",; 11115 conn->request_info.local_uri,; 11116 index_file + 1);; 11117 }; 11118 }; 11119 } else {; 11120 /* URI: /path_to_script/script.cgi/path_info */; 11121 addenv(env,; 11122 ""SCRIPT_NAME=%.*s"",; 11123 uri_len - (int)strlen(conn->path_info),; 11124 conn->request_info.local_uri);; 11125 }; 11126 ; 11127 addenv(env, ""SCRIPT_FILENAME=%s"", prog);; 11128 if (conn->path_info == NULL) {; 11129 addenv(env, ""PATH_TRANSLATED=%s"", conn->dom_ctx->config[DOCUMENT_ROOT]);; 11130 } else {; 11131 addenv(env,; 11132 ""PATH_TRANSLATED=%s%s"",; 11133 conn->dom_ctx->config[DOCUMENT_ROOT],; 11134 conn->path_info);; 11135 }; 11136 ; 11137 addenv(env, ""HTTPS=%s"", (conn->ssl == NULL) ? ""off"" : ""on"");; 11138 ; 11139 if ((s = mg_get_header(conn, ""Content-Type"")) != NULL) {; 11140 addenv(env, ""CONTENT_TYPE=%s"", s);; 11141 }; 11142 if (conn->request_info.query_string != NULL) {; 11143 addenv(env, ""QUERY_STRING=%s"", conn->request_info.query_string);; 11144 }; 11145 if ((s = mg_get_header(conn, ""Content-Length"")) != NULL) {; 11146 addenv(env, ""CONTENT_LENGTH=%s"", s);; 11147 }; 11148 if ((s = getenv(""PATH"")) != NULL) {; 11149 addenv(env, ""PATH=%s"", s);; 11150 }; 11151 if (conn->path_info != NULL) {; 11152 addenv(env, ""PATH_INFO=%s"", conn->path_info);; 11153 }; 11154 ; 11155 if (conn->status_code > 0) {; 11156 /* CGI error handler should show the status code */; 11157 addenv(env, ""STATUS=%d"", conn->status_code);; 11158 }; 11159 ; 11160#if defined(_WIN32); 11161 if ((s = getenv(""COMSPEC"")) != NULL) {; 11162 addenv(env, ""COMSPEC=%s"", s);; 11163 }; 11164 if ((s = ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:323208,Modifiability,variab,variables,323208,"ode);; 11158 }; 11159 ; 11160#if defined(_WIN32); 11161 if ((s = getenv(""COMSPEC"")) != NULL) {; 11162 addenv(env, ""COMSPEC=%s"", s);; 11163 }; 11164 if ((s = getenv(""SYSTEMROOT"")) != NULL) {; 11165 addenv(env, ""SYSTEMROOT=%s"", s);; 11166 }; 11167 if ((s = getenv(""SystemDrive"")) != NULL) {; 11168 addenv(env, ""SystemDrive=%s"", s);; 11169 }; 11170 if ((s = getenv(""ProgramFiles"")) != NULL) {; 11171 addenv(env, ""ProgramFiles=%s"", s);; 11172 }; 11173 if ((s = getenv(""ProgramFiles(x86)"")) != NULL) {; 11174 addenv(env, ""ProgramFiles(x86)=%s"", s);; 11175 }; 11176#else; 11177 if ((s = getenv(""LD_LIBRARY_PATH"")) != NULL) {; 11178 addenv(env, ""LD_LIBRARY_PATH=%s"", s);; 11179 }; 11180#endif /* _WIN32 */; 11181 ; 11182 if ((s = getenv(""PERLLIB"")) != NULL) {; 11183 addenv(env, ""PERLLIB=%s"", s);; 11184 }; 11185 ; 11186 if (conn->request_info.remote_user != NULL) {; 11187 addenv(env, ""REMOTE_USER=%s"", conn->request_info.remote_user);; 11188 addenv(env, ""%s"", ""AUTH_TYPE=Digest"");; 11189 }; 11190 ; 11191 /* Add all headers as HTTP_* variables */; 11192 for (i = 0; i < conn->request_info.num_headers; i++) {; 11193 ; 11194 (void)mg_snprintf(conn,; 11195 &truncated,; 11196 http_var_name,; 11197 sizeof(http_var_name),; 11198 ""HTTP_%s"",; 11199 conn->request_info.http_headers[i].name);; 11200 ; 11201 if (truncated) {; 11202 mg_cry_internal(conn,; 11203 ""%s: HTTP header variable too long [%s]"",; 11204 __func__,; 11205 conn->request_info.http_headers[i].name);; 11206 continue;; 11207 }; 11208 ; 11209 /* Convert variable name into uppercase, and change - to _ */; 11210 for (p = http_var_name; *p != '\0'; p++) {; 11211 if (*p == '-') {; 11212 *p = '_';; 11213 }; 11214 *p = (char)toupper((unsigned char)*p);; 11215 }; 11216 ; 11217 addenv(env,; 11218 ""%s=%s"",; 11219 http_var_name,; 11220 conn->request_info.http_headers[i].value);; 11221 }; 11222 ; 11223 /* Add user-specified variables */; 11224 s = conn->dom_ctx->config[CGI_ENVIRONMENT + cgi_config_idx];; 11225 while ((s = next_option(s, &var_vec,",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:323545,Modifiability,variab,variable,323545," getenv(""ProgramFiles"")) != NULL) {; 11171 addenv(env, ""ProgramFiles=%s"", s);; 11172 }; 11173 if ((s = getenv(""ProgramFiles(x86)"")) != NULL) {; 11174 addenv(env, ""ProgramFiles(x86)=%s"", s);; 11175 }; 11176#else; 11177 if ((s = getenv(""LD_LIBRARY_PATH"")) != NULL) {; 11178 addenv(env, ""LD_LIBRARY_PATH=%s"", s);; 11179 }; 11180#endif /* _WIN32 */; 11181 ; 11182 if ((s = getenv(""PERLLIB"")) != NULL) {; 11183 addenv(env, ""PERLLIB=%s"", s);; 11184 }; 11185 ; 11186 if (conn->request_info.remote_user != NULL) {; 11187 addenv(env, ""REMOTE_USER=%s"", conn->request_info.remote_user);; 11188 addenv(env, ""%s"", ""AUTH_TYPE=Digest"");; 11189 }; 11190 ; 11191 /* Add all headers as HTTP_* variables */; 11192 for (i = 0; i < conn->request_info.num_headers; i++) {; 11193 ; 11194 (void)mg_snprintf(conn,; 11195 &truncated,; 11196 http_var_name,; 11197 sizeof(http_var_name),; 11198 ""HTTP_%s"",; 11199 conn->request_info.http_headers[i].name);; 11200 ; 11201 if (truncated) {; 11202 mg_cry_internal(conn,; 11203 ""%s: HTTP header variable too long [%s]"",; 11204 __func__,; 11205 conn->request_info.http_headers[i].name);; 11206 continue;; 11207 }; 11208 ; 11209 /* Convert variable name into uppercase, and change - to _ */; 11210 for (p = http_var_name; *p != '\0'; p++) {; 11211 if (*p == '-') {; 11212 *p = '_';; 11213 }; 11214 *p = (char)toupper((unsigned char)*p);; 11215 }; 11216 ; 11217 addenv(env,; 11218 ""%s=%s"",; 11219 http_var_name,; 11220 conn->request_info.http_headers[i].value);; 11221 }; 11222 ; 11223 /* Add user-specified variables */; 11224 s = conn->dom_ctx->config[CGI_ENVIRONMENT + cgi_config_idx];; 11225 while ((s = next_option(s, &var_vec, NULL)) != NULL) {; 11226 addenv(env, ""%.*s"", (int)var_vec.len, var_vec.ptr);; 11227 }; 11228 ; 11229 env->var[env->varused] = NULL;; 11230 env->buf[env->bufused] = '\0';; 11231 ; 11232 return 0;; 11233}; 11234 ; 11235 ; 11236/* Data for CGI process control: PID and number of references */; 11237struct process_control_data {; 11238 pid_t pid;; 11239 pt",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:323688,Modifiability,variab,variable,323688,"denv(env, ""LD_LIBRARY_PATH=%s"", s);; 11179 }; 11180#endif /* _WIN32 */; 11181 ; 11182 if ((s = getenv(""PERLLIB"")) != NULL) {; 11183 addenv(env, ""PERLLIB=%s"", s);; 11184 }; 11185 ; 11186 if (conn->request_info.remote_user != NULL) {; 11187 addenv(env, ""REMOTE_USER=%s"", conn->request_info.remote_user);; 11188 addenv(env, ""%s"", ""AUTH_TYPE=Digest"");; 11189 }; 11190 ; 11191 /* Add all headers as HTTP_* variables */; 11192 for (i = 0; i < conn->request_info.num_headers; i++) {; 11193 ; 11194 (void)mg_snprintf(conn,; 11195 &truncated,; 11196 http_var_name,; 11197 sizeof(http_var_name),; 11198 ""HTTP_%s"",; 11199 conn->request_info.http_headers[i].name);; 11200 ; 11201 if (truncated) {; 11202 mg_cry_internal(conn,; 11203 ""%s: HTTP header variable too long [%s]"",; 11204 __func__,; 11205 conn->request_info.http_headers[i].name);; 11206 continue;; 11207 }; 11208 ; 11209 /* Convert variable name into uppercase, and change - to _ */; 11210 for (p = http_var_name; *p != '\0'; p++) {; 11211 if (*p == '-') {; 11212 *p = '_';; 11213 }; 11214 *p = (char)toupper((unsigned char)*p);; 11215 }; 11216 ; 11217 addenv(env,; 11218 ""%s=%s"",; 11219 http_var_name,; 11220 conn->request_info.http_headers[i].value);; 11221 }; 11222 ; 11223 /* Add user-specified variables */; 11224 s = conn->dom_ctx->config[CGI_ENVIRONMENT + cgi_config_idx];; 11225 while ((s = next_option(s, &var_vec, NULL)) != NULL) {; 11226 addenv(env, ""%.*s"", (int)var_vec.len, var_vec.ptr);; 11227 }; 11228 ; 11229 env->var[env->varused] = NULL;; 11230 env->buf[env->bufused] = '\0';; 11231 ; 11232 return 0;; 11233}; 11234 ; 11235 ; 11236/* Data for CGI process control: PID and number of references */; 11237struct process_control_data {; 11238 pid_t pid;; 11239 ptrdiff_t references;; 11240};; 11241 ; 11242static int; 11243abort_cgi_process(void *data); 11244{; 11245 /* Waitpid checks for child status and won't work for a pid that does; 11246 * not identify a child of the current process. Thus, if the pid is; 11247 * reused, we will ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:324055,Modifiability,variab,variables,324055,"11188 addenv(env, ""%s"", ""AUTH_TYPE=Digest"");; 11189 }; 11190 ; 11191 /* Add all headers as HTTP_* variables */; 11192 for (i = 0; i < conn->request_info.num_headers; i++) {; 11193 ; 11194 (void)mg_snprintf(conn,; 11195 &truncated,; 11196 http_var_name,; 11197 sizeof(http_var_name),; 11198 ""HTTP_%s"",; 11199 conn->request_info.http_headers[i].name);; 11200 ; 11201 if (truncated) {; 11202 mg_cry_internal(conn,; 11203 ""%s: HTTP header variable too long [%s]"",; 11204 __func__,; 11205 conn->request_info.http_headers[i].name);; 11206 continue;; 11207 }; 11208 ; 11209 /* Convert variable name into uppercase, and change - to _ */; 11210 for (p = http_var_name; *p != '\0'; p++) {; 11211 if (*p == '-') {; 11212 *p = '_';; 11213 }; 11214 *p = (char)toupper((unsigned char)*p);; 11215 }; 11216 ; 11217 addenv(env,; 11218 ""%s=%s"",; 11219 http_var_name,; 11220 conn->request_info.http_headers[i].value);; 11221 }; 11222 ; 11223 /* Add user-specified variables */; 11224 s = conn->dom_ctx->config[CGI_ENVIRONMENT + cgi_config_idx];; 11225 while ((s = next_option(s, &var_vec, NULL)) != NULL) {; 11226 addenv(env, ""%.*s"", (int)var_vec.len, var_vec.ptr);; 11227 }; 11228 ; 11229 env->var[env->varused] = NULL;; 11230 env->buf[env->bufused] = '\0';; 11231 ; 11232 return 0;; 11233}; 11234 ; 11235 ; 11236/* Data for CGI process control: PID and number of references */; 11237struct process_control_data {; 11238 pid_t pid;; 11239 ptrdiff_t references;; 11240};; 11241 ; 11242static int; 11243abort_cgi_process(void *data); 11244{; 11245 /* Waitpid checks for child status and won't work for a pid that does; 11246 * not identify a child of the current process. Thus, if the pid is; 11247 * reused, we will not affect a different process. */; 11248 struct process_control_data *proc = (struct process_control_data *)data;; 11249 int status = 0;; 11250 ptrdiff_t refs;; 11251 pid_t ret_pid;; 11252 ; 11253 ret_pid = waitpid(proc->pid, &status, WNOHANG);; 11254 if ((ret_pid != (pid_t)-1) && (status == 0)) {; 112",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:324094,Modifiability,config,config,324094,"11188 addenv(env, ""%s"", ""AUTH_TYPE=Digest"");; 11189 }; 11190 ; 11191 /* Add all headers as HTTP_* variables */; 11192 for (i = 0; i < conn->request_info.num_headers; i++) {; 11193 ; 11194 (void)mg_snprintf(conn,; 11195 &truncated,; 11196 http_var_name,; 11197 sizeof(http_var_name),; 11198 ""HTTP_%s"",; 11199 conn->request_info.http_headers[i].name);; 11200 ; 11201 if (truncated) {; 11202 mg_cry_internal(conn,; 11203 ""%s: HTTP header variable too long [%s]"",; 11204 __func__,; 11205 conn->request_info.http_headers[i].name);; 11206 continue;; 11207 }; 11208 ; 11209 /* Convert variable name into uppercase, and change - to _ */; 11210 for (p = http_var_name; *p != '\0'; p++) {; 11211 if (*p == '-') {; 11212 *p = '_';; 11213 }; 11214 *p = (char)toupper((unsigned char)*p);; 11215 }; 11216 ; 11217 addenv(env,; 11218 ""%s=%s"",; 11219 http_var_name,; 11220 conn->request_info.http_headers[i].value);; 11221 }; 11222 ; 11223 /* Add user-specified variables */; 11224 s = conn->dom_ctx->config[CGI_ENVIRONMENT + cgi_config_idx];; 11225 while ((s = next_option(s, &var_vec, NULL)) != NULL) {; 11226 addenv(env, ""%.*s"", (int)var_vec.len, var_vec.ptr);; 11227 }; 11228 ; 11229 env->var[env->varused] = NULL;; 11230 env->buf[env->bufused] = '\0';; 11231 ; 11232 return 0;; 11233}; 11234 ; 11235 ; 11236/* Data for CGI process control: PID and number of references */; 11237struct process_control_data {; 11238 pid_t pid;; 11239 ptrdiff_t references;; 11240};; 11241 ; 11242static int; 11243abort_cgi_process(void *data); 11244{; 11245 /* Waitpid checks for child status and won't work for a pid that does; 11246 * not identify a child of the current process. Thus, if the pid is; 11247 * reused, we will not affect a different process. */; 11248 struct process_control_data *proc = (struct process_control_data *)data;; 11249 int status = 0;; 11250 ptrdiff_t refs;; 11251 pid_t ret_pid;; 11252 ; 11253 ret_pid = waitpid(proc->pid, &status, WNOHANG);; 11254 if ((ret_pid != (pid_t)-1) && (status == 0)) {; 112",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:326548,Modifiability,config,config,326548," /* Wait until process is terminated (don't leave zombies) */; 11260 while (waitpid(proc->pid, &status, 0) != (pid_t)-1) /* nop */; 11261 ;; 11262 } else {; 11263 DEBUG_TRACE(""CGI timer: Child process %d already stopped\n"", proc->pid);; 11264 }; 11265 /* Dec reference counter */; 11266 refs = mg_atomic_dec(&proc->references);; 11267 if (refs == 0) {; 11268 /* no more references - free data */; 11269 mg_free(data);; 11270 }; 11271 ; 11272 return 0;; 11273}; 11274 ; 11275 ; 11276/* Local (static) function assumes all arguments are valid. */; 11277static void; 11278handle_cgi_request(struct mg_connection *conn,; 11279 const char *prog,; 11280 unsigned char cgi_config_idx); 11281{; 11282 char *buf;; 11283 size_t buflen;; 11284 int headers_len, data_len, i, truncated;; 11285 int fdin[2] = {-1, -1}, fdout[2] = {-1, -1}, fderr[2] = {-1, -1};; 11286 const char *status, *status_text, *connection_state;; 11287 char *pbuf, dir[UTF8_PATH_MAX], *p;; 11288 struct mg_request_info ri;; 11289 struct cgi_environment blk;; 11290 FILE *in = NULL, *out = NULL, *err = NULL;; 11291 struct mg_file fout = STRUCT_FILE_INITIALIZER;; 11292 pid_t pid = (pid_t)-1;; 11293 struct process_control_data *proc = NULL;; 11294 ; 11295#if defined(USE_TIMERS); 11296 double cgi_timeout;; 11297 if (conn->dom_ctx->config[CGI_TIMEOUT + cgi_config_idx]) {; 11298 /* Get timeout in seconds */; 11299 cgi_timeout =; 11300 atof(conn->dom_ctx->config[CGI_TIMEOUT + cgi_config_idx]) * 0.001;; 11301 } else {; 11302 cgi_timeout =; 11303 atof(config_options[REQUEST_TIMEOUT].default_value) * 0.001;; 11304 }; 11305 ; 11306#endif; 11307 ; 11308 buf = NULL;; 11309 buflen = conn->phys_ctx->max_request_size;; 11310 i = prepare_cgi_environment(conn, prog, &blk, cgi_config_idx);; 11311 if (i != 0) {; 11312 blk.buf = NULL;; 11313 blk.var = NULL;; 11314 goto done;; 11315 }; 11316 ; 11317 /* CGI must be executed in its own directory. 'dir' must point to the; 11318 * directory containing executable program, 'p' must point to the; 11",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:326672,Modifiability,config,config,326672," /* Wait until process is terminated (don't leave zombies) */; 11260 while (waitpid(proc->pid, &status, 0) != (pid_t)-1) /* nop */; 11261 ;; 11262 } else {; 11263 DEBUG_TRACE(""CGI timer: Child process %d already stopped\n"", proc->pid);; 11264 }; 11265 /* Dec reference counter */; 11266 refs = mg_atomic_dec(&proc->references);; 11267 if (refs == 0) {; 11268 /* no more references - free data */; 11269 mg_free(data);; 11270 }; 11271 ; 11272 return 0;; 11273}; 11274 ; 11275 ; 11276/* Local (static) function assumes all arguments are valid. */; 11277static void; 11278handle_cgi_request(struct mg_connection *conn,; 11279 const char *prog,; 11280 unsigned char cgi_config_idx); 11281{; 11282 char *buf;; 11283 size_t buflen;; 11284 int headers_len, data_len, i, truncated;; 11285 int fdin[2] = {-1, -1}, fdout[2] = {-1, -1}, fderr[2] = {-1, -1};; 11286 const char *status, *status_text, *connection_state;; 11287 char *pbuf, dir[UTF8_PATH_MAX], *p;; 11288 struct mg_request_info ri;; 11289 struct cgi_environment blk;; 11290 FILE *in = NULL, *out = NULL, *err = NULL;; 11291 struct mg_file fout = STRUCT_FILE_INITIALIZER;; 11292 pid_t pid = (pid_t)-1;; 11293 struct process_control_data *proc = NULL;; 11294 ; 11295#if defined(USE_TIMERS); 11296 double cgi_timeout;; 11297 if (conn->dom_ctx->config[CGI_TIMEOUT + cgi_config_idx]) {; 11298 /* Get timeout in seconds */; 11299 cgi_timeout =; 11300 atof(conn->dom_ctx->config[CGI_TIMEOUT + cgi_config_idx]) * 0.001;; 11301 } else {; 11302 cgi_timeout =; 11303 atof(config_options[REQUEST_TIMEOUT].default_value) * 0.001;; 11304 }; 11305 ; 11306#endif; 11307 ; 11308 buf = NULL;; 11309 buflen = conn->phys_ctx->max_request_size;; 11310 i = prepare_cgi_environment(conn, prog, &blk, cgi_config_idx);; 11311 if (i != 0) {; 11312 blk.buf = NULL;; 11313 blk.var = NULL;; 11314 goto done;; 11315 }; 11316 ; 11317 /* CGI must be executed in its own directory. 'dir' must point to the; 11318 * directory containing executable program, 'p' must point to the; 11",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:344116,Modifiability,config,config,344116,"sscanf() is safe here, since send_ssi_file() also uses buffer; 11875 * of size MG_BUF_LEN to get the tag. So strlen(tag) is; 11876 * always < MG_BUF_LEN. */; 11877 if (sscanf(tag, "" virtual=\""%511[^\""]\"""", file_name) == 1) {; 11878 /* File name is relative to the webserver root */; 11879 file_name[511] = 0;; 11880 (void)mg_snprintf(conn,; 11881 &truncated,; 11882 path,; 11883 sizeof(path),; 11884 ""%s/%s"",; 11885 conn->dom_ctx->config[DOCUMENT_ROOT],; 11886 file_name);; 11887 ; 11888 } else if (sscanf(tag, "" abspath=\""%511[^\""]\"""", file_name) == 1) {; 11889 /* File name is relative to the webserver working directory; 11890 * or it is absolute system path */; 11891 file_name[511] = 0;; 11892 (void); 11893 mg_snprintf(conn, &truncated, path, sizeof(path), ""%s"", file_name);; 11894 ; 11895 } else if ((sscanf(tag, "" file=\""%511[^\""]\"""", file_name) == 1); 11896 || (sscanf(tag, "" \""%511[^\""]\"""", file_name) == 1)) {; 11897 /* File name is relative to the currect document */; 11898 file_name[511] = 0;; 11899 (void)mg_snprintf(conn, &truncated, path, sizeof(path), ""%s"", ssi);; 11900 ; 11901 if (!truncated) {; 11902 if ((p = strrchr(path, '/')) != NULL) {; 11903 p[1] = '\0';; 11904 }; 11905 len = strlen(path);; 11906 (void)mg_snprintf(conn,; 11907 &truncated,; 11908 path + len,; 11909 sizeof(path) - len,; 11910 ""%s"",; 11911 file_name);; 11912 }; 11913 ; 11914 } else {; 11915 mg_cry_internal(conn, ""Bad SSI #include: [%s]"", tag);; 11916 return;; 11917 }; 11918 ; 11919 if (truncated) {; 11920 mg_cry_internal(conn, ""SSI #include path length overflow: [%s]"", tag);; 11921 return;; 11922 }; 11923 ; 11924 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {; 11925 mg_cry_internal(conn,; 11926 ""Cannot open SSI #include: [%s]: fopen(%s): %s"",; 11927 tag,; 11928 path,; 11929 strerror(ERRNO));; 11930 } else {; 11931 fclose_on_exec(&file.access, conn);; 11932 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], path); 11933 > 0) {; 11934 send_ssi_file(conn, path, &file, include_",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:345594,Modifiability,config,config,345594,"1898 file_name[511] = 0;; 11899 (void)mg_snprintf(conn, &truncated, path, sizeof(path), ""%s"", ssi);; 11900 ; 11901 if (!truncated) {; 11902 if ((p = strrchr(path, '/')) != NULL) {; 11903 p[1] = '\0';; 11904 }; 11905 len = strlen(path);; 11906 (void)mg_snprintf(conn,; 11907 &truncated,; 11908 path + len,; 11909 sizeof(path) - len,; 11910 ""%s"",; 11911 file_name);; 11912 }; 11913 ; 11914 } else {; 11915 mg_cry_internal(conn, ""Bad SSI #include: [%s]"", tag);; 11916 return;; 11917 }; 11918 ; 11919 if (truncated) {; 11920 mg_cry_internal(conn, ""SSI #include path length overflow: [%s]"", tag);; 11921 return;; 11922 }; 11923 ; 11924 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {; 11925 mg_cry_internal(conn,; 11926 ""Cannot open SSI #include: [%s]: fopen(%s): %s"",; 11927 tag,; 11928 path,; 11929 strerror(ERRNO));; 11930 } else {; 11931 fclose_on_exec(&file.access, conn);; 11932 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], path); 11933 > 0) {; 11934 send_ssi_file(conn, path, &file, include_level + 1);; 11935 } else {; 11936 send_file_data(conn, &file, 0, INT64_MAX);; 11937 }; 11938 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 11939 }; 11940}; 11941 ; 11942 ; 11943#if !defined(NO_POPEN); 11944static void; 11945do_ssi_exec(struct mg_connection *conn, char *tag); 11946{; 11947 char cmd[1024] = """";; 11948 struct mg_file file = STRUCT_FILE_INITIALIZER;; 11949 ; 11950 if (sscanf(tag, "" \""%1023[^\""]\"""", cmd) != 1) {; 11951 mg_cry_internal(conn, ""Bad SSI #exec: [%s]"", tag);; 11952 } else {; 11953 cmd[1023] = 0;; 11954 if ((file.access.fp = popen(cmd, ""r"")) == NULL) {; 11955 mg_cry_internal(conn,; 11956 ""Cannot SSI #exec: [%s]: %s"",; 11957 cmd,; 11958 strerror(ERRNO));; 11959 } else {; 11960 send_file_data(conn, &file, 0, INT64_MAX);; 11961 pclose(file.access.fp);; 11962 }; 11963 }; 11964}; 11965#endif /* !NO_POPEN */; 11966 ; 11967 ; 11968static int; 11969mg_fgetc(struct mg_file *filep); 11970{; 11971 if (filep == NULL) {; 11972 return",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:349908,Modifiability,config,config,349908,"45 ; 12046 if ((len + 2) > (int)sizeof(buf)) {; 12047 /* Tag to long for buffer */; 12048 mg_cry_internal(conn, ""%s: tag is too large"", path);; 12049 return;; 12050 }; 12051 }; 12052 ; 12053 } else {; 12054 ; 12055 /* We are not in a tag yet. */; 12056 if (ch == '<') {; 12057 /* Tag is opening */; 12058 in_tag = 1;; 12059 ; 12060 if (len > 0) {; 12061 /* Flush current buffer.; 12062 * Buffer is filled with ""len"" bytes. */; 12063 (void)mg_write(conn, buf, (size_t)len);; 12064 }; 12065 /* Store the < */; 12066 len = 1;; 12067 buf[0] = '<';; 12068 ; 12069 } else {; 12070 /* No Tag */; 12071 /* Add data to buffer */; 12072 buf[len++] = (char)(ch & 0xff);; 12073 /* Flush if buffer is full */; 12074 if (len == (int)sizeof(buf)) {; 12075 mg_write(conn, buf, (size_t)len);; 12076 len = 0;; 12077 }; 12078 }; 12079 }; 12080 }; 12081 ; 12082 /* Send the rest of buffered data */; 12083 if (len > 0) {; 12084 mg_write(conn, buf, (size_t)len);; 12085 }; 12086}; 12087 ; 12088 ; 12089static void; 12090handle_ssi_file_request(struct mg_connection *conn,; 12091 const char *path,; 12092 struct mg_file *filep); 12093{; 12094 char date[64];; 12095 time_t curtime = time(NULL);; 12096 const char *cors_orig_cfg, *cors_cred_cfg;; 12097 const char *cors1, *cors2, *cors3, *cors4;; 12098 ; 12099 if ((conn == NULL) || (path == NULL) || (filep == NULL)) {; 12100 return;; 12101 }; 12102 ; 12103 cors_orig_cfg = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];; 12104 if (cors_orig_cfg && *cors_orig_cfg && mg_get_header(conn, ""Origin"")) {; 12105 /* Cross-origin resource sharing (CORS). */; 12106 cors1 = ""Access-Control-Allow-Origin"";; 12107 cors2 = cors_orig_cfg;; 12108 } else {; 12109 cors1 = cors2 = """";; 12110 }; 12111 ; 12112 cors_cred_cfg = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_CREDENTIALS];; 12113 if (cors_cred_cfg && *cors_cred_cfg && mg_get_header(conn, ""Origin"")) {; 12114 /* Credentials CORS header */; 12115 cors3 = ""Access-Control-Allow-Credentials"";; 12116 cors4 = cors_cred_cfg;; 1211",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:350249,Modifiability,config,config,350249,"2084 mg_write(conn, buf, (size_t)len);; 12085 }; 12086}; 12087 ; 12088 ; 12089static void; 12090handle_ssi_file_request(struct mg_connection *conn,; 12091 const char *path,; 12092 struct mg_file *filep); 12093{; 12094 char date[64];; 12095 time_t curtime = time(NULL);; 12096 const char *cors_orig_cfg, *cors_cred_cfg;; 12097 const char *cors1, *cors2, *cors3, *cors4;; 12098 ; 12099 if ((conn == NULL) || (path == NULL) || (filep == NULL)) {; 12100 return;; 12101 }; 12102 ; 12103 cors_orig_cfg = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];; 12104 if (cors_orig_cfg && *cors_orig_cfg && mg_get_header(conn, ""Origin"")) {; 12105 /* Cross-origin resource sharing (CORS). */; 12106 cors1 = ""Access-Control-Allow-Origin"";; 12107 cors2 = cors_orig_cfg;; 12108 } else {; 12109 cors1 = cors2 = """";; 12110 }; 12111 ; 12112 cors_cred_cfg = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_CREDENTIALS];; 12113 if (cors_cred_cfg && *cors_cred_cfg && mg_get_header(conn, ""Origin"")) {; 12114 /* Credentials CORS header */; 12115 cors3 = ""Access-Control-Allow-Credentials"";; 12116 cors4 = cors_cred_cfg;; 12117 } else {; 12118 cors3 = cors4 = """";; 12119 }; 12120 ; 12121 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {; 12122 /* File exists (precondition for calling this function),; 12123 * but can not be opened by the server. */; 12124 mg_send_http_error(conn,; 12125 500,; 12126 ""Error: Cannot read file\nfopen(%s): %s"",; 12127 path,; 12128 strerror(ERRNO));; 12129 } else {; 12130 /* Set ""must_close"" for HTTP/1.x, since we do not know the; 12131 * content length */; 12132 conn->must_close = 1;; 12133 gmt_time_string(date, sizeof(date), &curtime);; 12134 fclose_on_exec(&filep->access, conn);; 12135 ; 12136 /* 200 OK response */; 12137 mg_response_header_start(conn, 200);; 12138 send_no_cache_header(conn);; 12139 send_additional_header(conn);; 12140 mg_response_header_add(conn, ""Content-Type"", ""text/html"", -1);; 12141 if (cors1[0]) {; 12142 mg_response_header_add(conn, cors1, cors2, -1);; 12",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:355973,Modifiability,config,config,355973,"ponse_header_add(conn, ""Content-Type"", ""text/xml; charset=utf-8"", -1);; 12282 mg_response_header_send(conn);; 12283 ; 12284 /* Content */; 12285 mg_printf(conn,; 12286 ""<?xml version=\""1.0\"" encoding=\""utf-8\""?>""; 12287 ""<d:multistatus xmlns:d='DAV:'>\n"");; 12288 ; 12289 /* Print properties for the requested resource itself */; 12290 print_props(conn, conn->request_info.local_uri, """", filep);; 12291 ; 12292 /* If it is a directory, print directory entries too if Depth is not 0; 12293 */; 12294 if (filep->is_directory; 12295 && !mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],; 12296 ""yes""); 12297 && ((depth == NULL) || (strcmp(depth, ""0"") != 0))) {; 12298 scan_directory(conn, path, conn, &print_dav_dir_entry);; 12299 }; 12300 ; 12301 mg_printf(conn, ""%s\n"", ""</d:multistatus>"");; 12302}; 12303#endif; 12304 ; 12305void; 12306mg_lock_connection(struct mg_connection *conn); 12307{; 12308 if (conn) {; 12309 (void)pthread_mutex_lock(&conn->mutex);; 12310 }; 12311}; 12312 ; 12313void; 12314mg_unlock_connection(struct mg_connection *conn); 12315{; 12316 if (conn) {; 12317 (void)pthread_mutex_unlock(&conn->mutex);; 12318 }; 12319}; 12320 ; 12321void; 12322mg_lock_context(struct mg_context *ctx); 12323{; 12324 if (ctx && (ctx->context_type == CONTEXT_SERVER)) {; 12325 (void)pthread_mutex_lock(&ctx->nonce_mutex);; 12326 }; 12327}; 12328 ; 12329void; 12330mg_unlock_context(struct mg_context *ctx); 12331{; 12332 if (ctx && (ctx->context_type == CONTEXT_SERVER)) {; 12333 (void)pthread_mutex_unlock(&ctx->nonce_mutex);; 12334 }; 12335}; 12336 ; 12337 ; 12338#if defined(USE_LUA); 12339#include ""mod_lua.inl""; 12340#endif /* USE_LUA */; 12341 ; 12342#if defined(USE_DUKTAPE); 12343#include ""mod_duktape.inl""; 12344#endif /* USE_DUKTAPE */; 12345 ; 12346#if defined(USE_WEBSOCKET); 12347 ; 12348#if !defined(NO_SSL_DL); 12349#if !defined(OPENSSL_API_3_0); 12350#define SHA_API static; 12351#include ""sha1.inl""; 12352#endif; 12353#endif; 12354 ; 12355static int; 12356send_websoc",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:361076,Modifiability,config,config,361076,"urrent message's data payload; 12433 * header_len is the length of the current message's header */; 12434 size_t i, len, mask_len = 0, header_len, body_len;; 12435 uint64_t data_len = 0;; 12436 ; 12437 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12438 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12439 */; 12440 unsigned char mask[4];; 12441 ; 12442 /* data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];; 12446 unsigned char mop; /* mask flag and opcode */; 12447 ; 12448 ; 12449 /* Variables used for connection monitoring */; 12450 double timeout = -1.0;; 12451 int enable_ping_pong = 0;; 12452 int ping_count = 0;; 12453 ; 12454 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12455 enable_ping_pong =; 12456 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12457 ""yes"");; 12458 }; 12459 ; 12460 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12461 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12462 }; 12463 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12464 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12465 }; 12466 if (timeout <= 0.0) {; 12467 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12468 }; 12469 ; 12470 /* Enter data processing loop */; 12471 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12472 conn->request_info.remote_addr,; 12473 conn->request_info.remote_port);; 12474 conn->in_websocket_handling = 1;; 12475 mg_set_thread_name(""wsock"");; 12476 ; 12477 /* Loop continuously, reading messages from the socket, invoking the; 12478 * callback, and waiting repeatedly until an error occurs. */; 12479 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12480 && (!conn->must_close",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:361177,Modifiability,config,config,361177,"urrent message's data payload; 12433 * header_len is the length of the current message's header */; 12434 size_t i, len, mask_len = 0, header_len, body_len;; 12435 uint64_t data_len = 0;; 12436 ; 12437 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12438 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12439 */; 12440 unsigned char mask[4];; 12441 ; 12442 /* data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];; 12446 unsigned char mop; /* mask flag and opcode */; 12447 ; 12448 ; 12449 /* Variables used for connection monitoring */; 12450 double timeout = -1.0;; 12451 int enable_ping_pong = 0;; 12452 int ping_count = 0;; 12453 ; 12454 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12455 enable_ping_pong =; 12456 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12457 ""yes"");; 12458 }; 12459 ; 12460 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12461 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12462 }; 12463 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12464 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12465 }; 12466 if (timeout <= 0.0) {; 12467 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12468 }; 12469 ; 12470 /* Enter data processing loop */; 12471 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12472 conn->request_info.remote_addr,; 12473 conn->request_info.remote_port);; 12474 conn->in_websocket_handling = 1;; 12475 mg_set_thread_name(""wsock"");; 12476 ; 12477 /* Loop continuously, reading messages from the socket, invoking the; 12478 * callback, and waiting repeatedly until an error occurs. */; 12479 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12480 && (!conn->must_close",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:361271,Modifiability,config,config,361271,"urrent message's data payload; 12433 * header_len is the length of the current message's header */; 12434 size_t i, len, mask_len = 0, header_len, body_len;; 12435 uint64_t data_len = 0;; 12436 ; 12437 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12438 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12439 */; 12440 unsigned char mask[4];; 12441 ; 12442 /* data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];; 12446 unsigned char mop; /* mask flag and opcode */; 12447 ; 12448 ; 12449 /* Variables used for connection monitoring */; 12450 double timeout = -1.0;; 12451 int enable_ping_pong = 0;; 12452 int ping_count = 0;; 12453 ; 12454 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12455 enable_ping_pong =; 12456 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12457 ""yes"");; 12458 }; 12459 ; 12460 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12461 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12462 }; 12463 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12464 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12465 }; 12466 if (timeout <= 0.0) {; 12467 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12468 }; 12469 ; 12470 /* Enter data processing loop */; 12471 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12472 conn->request_info.remote_addr,; 12473 conn->request_info.remote_port);; 12474 conn->in_websocket_handling = 1;; 12475 mg_set_thread_name(""wsock"");; 12476 ; 12477 /* Loop continuously, reading messages from the socket, invoking the; 12478 * callback, and waiting repeatedly until an error occurs. */; 12479 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12480 && (!conn->must_close",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:361337,Modifiability,config,config,361337,"urrent message's data payload; 12433 * header_len is the length of the current message's header */; 12434 size_t i, len, mask_len = 0, header_len, body_len;; 12435 uint64_t data_len = 0;; 12436 ; 12437 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12438 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12439 */; 12440 unsigned char mask[4];; 12441 ; 12442 /* data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];; 12446 unsigned char mop; /* mask flag and opcode */; 12447 ; 12448 ; 12449 /* Variables used for connection monitoring */; 12450 double timeout = -1.0;; 12451 int enable_ping_pong = 0;; 12452 int ping_count = 0;; 12453 ; 12454 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12455 enable_ping_pong =; 12456 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12457 ""yes"");; 12458 }; 12459 ; 12460 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12461 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12462 }; 12463 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12464 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12465 }; 12466 if (timeout <= 0.0) {; 12467 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12468 }; 12469 ; 12470 /* Enter data processing loop */; 12471 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12472 conn->request_info.remote_addr,; 12473 conn->request_info.remote_port);; 12474 conn->in_websocket_handling = 1;; 12475 mg_set_thread_name(""wsock"");; 12476 ; 12477 /* Loop continuously, reading messages from the socket, invoking the; 12478 * callback, and waiting repeatedly until an error occurs. */; 12479 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12480 && (!conn->must_close",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:361430,Modifiability,config,config,361430,"ls.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12439 */; 12440 unsigned char mask[4];; 12441 ; 12442 /* data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];; 12446 unsigned char mop; /* mask flag and opcode */; 12447 ; 12448 ; 12449 /* Variables used for connection monitoring */; 12450 double timeout = -1.0;; 12451 int enable_ping_pong = 0;; 12452 int ping_count = 0;; 12453 ; 12454 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12455 enable_ping_pong =; 12456 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12457 ""yes"");; 12458 }; 12459 ; 12460 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12461 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12462 }; 12463 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12464 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12465 }; 12466 if (timeout <= 0.0) {; 12467 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12468 }; 12469 ; 12470 /* Enter data processing loop */; 12471 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12472 conn->request_info.remote_addr,; 12473 conn->request_info.remote_port);; 12474 conn->in_websocket_handling = 1;; 12475 mg_set_thread_name(""wsock"");; 12476 ; 12477 /* Loop continuously, reading messages from the socket, invoking the; 12478 * callback, and waiting repeatedly until an error occurs. */; 12479 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12480 && (!conn->must_close)) {; 12481 header_len = 0;; 12482 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12483 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12484 len = buf[1] & 127;; 12485 mask_len = (buf[1] & 128) ? 4 : 0;; 12486 if ((len < 126) && (body_len >= mask_len)) {; 12487 /*",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:361495,Modifiability,config,config,361495,"ls.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12439 */; 12440 unsigned char mask[4];; 12441 ; 12442 /* data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];; 12446 unsigned char mop; /* mask flag and opcode */; 12447 ; 12448 ; 12449 /* Variables used for connection monitoring */; 12450 double timeout = -1.0;; 12451 int enable_ping_pong = 0;; 12452 int ping_count = 0;; 12453 ; 12454 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12455 enable_ping_pong =; 12456 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12457 ""yes"");; 12458 }; 12459 ; 12460 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12461 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12462 }; 12463 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12464 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12465 }; 12466 if (timeout <= 0.0) {; 12467 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12468 }; 12469 ; 12470 /* Enter data processing loop */; 12471 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12472 conn->request_info.remote_addr,; 12473 conn->request_info.remote_port);; 12474 conn->in_websocket_handling = 1;; 12475 mg_set_thread_name(""wsock"");; 12476 ; 12477 /* Loop continuously, reading messages from the socket, invoking the; 12478 * callback, and waiting repeatedly until an error occurs. */; 12479 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12480 && (!conn->must_close)) {; 12481 header_len = 0;; 12482 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12483 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12484 len = buf[1] & 127;; 12485 mask_len = (buf[1] & 128) ? 4 : 0;; 12486 if ((len < 126) && (body_len >= mask_len)) {; 12487 /*",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:383842,Modifiability,config,config,383842," the client; 13123 * has; 13124 * offered.; 13125 */; 13126 while (isspace((unsigned char)*++sep)) {; 13127 ; /* ignore leading whitespaces */; 13128 }; 13129 conn->request_info.acceptedWebSocketSubprotocol = sep;; 13130 }; 13131 }; 13132 ; 13133#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 13134 websocket_deflate_negotiate(conn);; 13135#endif; 13136 ; 13137 if ((ws_connect_handler != NULL); 13138 && (ws_connect_handler(conn, cbData) != 0)) {; 13139 /* C callback has returned non-zero, do not proceed with; 13140 * handshake.; 13141 */; 13142 /* Note that C callbacks are no longer called when Lua is; 13143 * responsible, so C can no longer filter callbacks for Lua. */; 13144 return;; 13145 }; 13146 }; 13147 ; 13148#if defined(USE_LUA); 13149 /* Step 3: No callback. Check if Lua is responsible. */; 13150 else {; 13151 /* Step 3.1: Check if Lua is responsible. */; 13152 if (conn->dom_ctx->config[LUA_WEBSOCKET_EXTENSIONS]) {; 13153 lua_websock = match_prefix_strlen(; 13154 conn->dom_ctx->config[LUA_WEBSOCKET_EXTENSIONS], path);; 13155 }; 13156 ; 13157 if (lua_websock) {; 13158 /* Step 3.2: Lua is responsible: call it. */; 13159 conn->lua_websocket_state = lua_websocket_new(path, conn);; 13160 if (!conn->lua_websocket_state) {; 13161 /* Lua rejected the new client */; 13162 return;; 13163 }; 13164 }; 13165 }; 13166#endif; 13167 ; 13168 /* Step 4: Check if there is a responsible websocket handler. */; 13169 if (!is_callback_resource && !lua_websock) {; 13170 /* There is no callback, and Lua is not responsible either. */; 13171 /* Reply with a 404 Not Found. We are still at a standard; 13172 * HTTP request here, before the websocket handshake, so; 13173 * we can still send standard HTTP error replies. */; 13174 mg_send_http_error(conn, 404, ""%s"", ""Not found"");; 13175 return;; 13176 }; 13177 ; 13178 /* Step 5: The websocket connection has been accepted */; 13179 if (!send_websocket_handshake(conn, websock_key)) {; 13180 mg_send_http_error(conn, 500, ""%s"", ""We",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:383942,Modifiability,config,config,383942," the client; 13123 * has; 13124 * offered.; 13125 */; 13126 while (isspace((unsigned char)*++sep)) {; 13127 ; /* ignore leading whitespaces */; 13128 }; 13129 conn->request_info.acceptedWebSocketSubprotocol = sep;; 13130 }; 13131 }; 13132 ; 13133#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 13134 websocket_deflate_negotiate(conn);; 13135#endif; 13136 ; 13137 if ((ws_connect_handler != NULL); 13138 && (ws_connect_handler(conn, cbData) != 0)) {; 13139 /* C callback has returned non-zero, do not proceed with; 13140 * handshake.; 13141 */; 13142 /* Note that C callbacks are no longer called when Lua is; 13143 * responsible, so C can no longer filter callbacks for Lua. */; 13144 return;; 13145 }; 13146 }; 13147 ; 13148#if defined(USE_LUA); 13149 /* Step 3: No callback. Check if Lua is responsible. */; 13150 else {; 13151 /* Step 3.1: Check if Lua is responsible. */; 13152 if (conn->dom_ctx->config[LUA_WEBSOCKET_EXTENSIONS]) {; 13153 lua_websock = match_prefix_strlen(; 13154 conn->dom_ctx->config[LUA_WEBSOCKET_EXTENSIONS], path);; 13155 }; 13156 ; 13157 if (lua_websock) {; 13158 /* Step 3.2: Lua is responsible: call it. */; 13159 conn->lua_websocket_state = lua_websocket_new(path, conn);; 13160 if (!conn->lua_websocket_state) {; 13161 /* Lua rejected the new client */; 13162 return;; 13163 }; 13164 }; 13165 }; 13166#endif; 13167 ; 13168 /* Step 4: Check if there is a responsible websocket handler. */; 13169 if (!is_callback_resource && !lua_websock) {; 13170 /* There is no callback, and Lua is not responsible either. */; 13171 /* Reply with a 404 Not Found. We are still at a standard; 13172 * HTTP request here, before the websocket handshake, so; 13173 * we can still send standard HTTP error replies. */; 13174 mg_send_http_error(conn, 404, ""%s"", ""Not found"");; 13175 return;; 13176 }; 13177 ; 13178 /* Step 5: The websocket connection has been accepted */; 13179 if (!send_websocket_handshake(conn, websock_key)) {; 13180 mg_send_http_error(conn, 500, ""%s"", ""We",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:394310,Modifiability,config,config,394310,"3461 DEBUG_TRACE(""%s"", ""Host name format error '[' without ']'"");; 13462 return;; 13463 }; 13464 /* terminate after ']' */; 13465 host->ptr = host_header;; 13466 host->len = (size_t)(pos + 1 - host_header);; 13467 } else {; 13468 /* Otherwise, a ':' separates hostname and port number */; 13469 pos = strchr(host_header, ':');; 13470 if (pos != NULL) {; 13471 host->len = (size_t)(pos - host_header);; 13472 } else {; 13473 host->len = strlen(host_header);; 13474 }; 13475 host->ptr = host_header;; 13476 }; 13477 }; 13478}; 13479 ; 13480 ; 13481static int; 13482switch_domain_context(struct mg_connection *conn); 13483{; 13484 struct vec host;; 13485 ; 13486 get_host_from_request_info(&host, &conn->request_info);; 13487 ; 13488 if (host.ptr) {; 13489 if (conn->ssl) {; 13490 /* This is a HTTPS connection, maybe we have a hostname; 13491 * from SNI (set in ssl_servername_callback). */; 13492 const char *sslhost = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 13493 if (sslhost && (conn->dom_ctx != &(conn->phys_ctx->dd))) {; 13494 /* We are not using the default domain */; 13495 if ((strlen(sslhost) != host.len); 13496 || mg_strncasecmp(host.ptr, sslhost, host.len)) {; 13497 /* Mismatch between SNI domain and HTTP domain */; 13498 DEBUG_TRACE(""Host mismatch: SNI: %s, HTTPS: %.*s"",; 13499 sslhost,; 13500 (int)host.len,; 13501 host.ptr);; 13502 return 0;; 13503 }; 13504 }; 13505 ; 13506 } else {; 13507 struct mg_domain_context *dom = &(conn->phys_ctx->dd);; 13508 while (dom) {; 13509 const char *domName = dom->config[AUTHENTICATION_DOMAIN];; 13510 size_t domNameLen = strlen(domName);; 13511 if ((domNameLen == host.len); 13512 && !mg_strncasecmp(host.ptr, domName, host.len)) {; 13513 ; 13514 /* Found matching domain */; 13515 DEBUG_TRACE(""HTTP domain %s found"",; 13516 dom->config[AUTHENTICATION_DOMAIN]);; 13517 ; 13518 /* TODO: Check if this is a HTTP or HTTPS domain */; 13519 conn->dom_ctx = dom;; 13520 break;; 13521 }; 13522 mg_lock_context(conn->phys_ctx);; 13523 dom = dom->n",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:394901,Modifiability,config,config,394901,"ost_header;; 13476 }; 13477 }; 13478}; 13479 ; 13480 ; 13481static int; 13482switch_domain_context(struct mg_connection *conn); 13483{; 13484 struct vec host;; 13485 ; 13486 get_host_from_request_info(&host, &conn->request_info);; 13487 ; 13488 if (host.ptr) {; 13489 if (conn->ssl) {; 13490 /* This is a HTTPS connection, maybe we have a hostname; 13491 * from SNI (set in ssl_servername_callback). */; 13492 const char *sslhost = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 13493 if (sslhost && (conn->dom_ctx != &(conn->phys_ctx->dd))) {; 13494 /* We are not using the default domain */; 13495 if ((strlen(sslhost) != host.len); 13496 || mg_strncasecmp(host.ptr, sslhost, host.len)) {; 13497 /* Mismatch between SNI domain and HTTP domain */; 13498 DEBUG_TRACE(""Host mismatch: SNI: %s, HTTPS: %.*s"",; 13499 sslhost,; 13500 (int)host.len,; 13501 host.ptr);; 13502 return 0;; 13503 }; 13504 }; 13505 ; 13506 } else {; 13507 struct mg_domain_context *dom = &(conn->phys_ctx->dd);; 13508 while (dom) {; 13509 const char *domName = dom->config[AUTHENTICATION_DOMAIN];; 13510 size_t domNameLen = strlen(domName);; 13511 if ((domNameLen == host.len); 13512 && !mg_strncasecmp(host.ptr, domName, host.len)) {; 13513 ; 13514 /* Found matching domain */; 13515 DEBUG_TRACE(""HTTP domain %s found"",; 13516 dom->config[AUTHENTICATION_DOMAIN]);; 13517 ; 13518 /* TODO: Check if this is a HTTP or HTTPS domain */; 13519 conn->dom_ctx = dom;; 13520 break;; 13521 }; 13522 mg_lock_context(conn->phys_ctx);; 13523 dom = dom->next;; 13524 mg_unlock_context(conn->phys_ctx);; 13525 }; 13526 }; 13527 ; 13528 DEBUG_TRACE(""HTTP%s Host: %.*s"",; 13529 conn->ssl ? ""S"" : """",; 13530 (int)host.len,; 13531 host.ptr);; 13532 ; 13533 } else {; 13534 DEBUG_TRACE(""HTTP%s Host is not set"", conn->ssl ? ""S"" : """");; 13535 return 1;; 13536 }; 13537 ; 13538 return 1;; 13539}; 13540 ; 13541 ; 13542static void; 13543redirect_to_https_port(struct mg_connection *conn, int port); 13544{; 13545 char target_url[MG_BUF_LEN];; 13546 i",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:395168,Modifiability,config,config,395168,"const char *sslhost = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 13493 if (sslhost && (conn->dom_ctx != &(conn->phys_ctx->dd))) {; 13494 /* We are not using the default domain */; 13495 if ((strlen(sslhost) != host.len); 13496 || mg_strncasecmp(host.ptr, sslhost, host.len)) {; 13497 /* Mismatch between SNI domain and HTTP domain */; 13498 DEBUG_TRACE(""Host mismatch: SNI: %s, HTTPS: %.*s"",; 13499 sslhost,; 13500 (int)host.len,; 13501 host.ptr);; 13502 return 0;; 13503 }; 13504 }; 13505 ; 13506 } else {; 13507 struct mg_domain_context *dom = &(conn->phys_ctx->dd);; 13508 while (dom) {; 13509 const char *domName = dom->config[AUTHENTICATION_DOMAIN];; 13510 size_t domNameLen = strlen(domName);; 13511 if ((domNameLen == host.len); 13512 && !mg_strncasecmp(host.ptr, domName, host.len)) {; 13513 ; 13514 /* Found matching domain */; 13515 DEBUG_TRACE(""HTTP domain %s found"",; 13516 dom->config[AUTHENTICATION_DOMAIN]);; 13517 ; 13518 /* TODO: Check if this is a HTTP or HTTPS domain */; 13519 conn->dom_ctx = dom;; 13520 break;; 13521 }; 13522 mg_lock_context(conn->phys_ctx);; 13523 dom = dom->next;; 13524 mg_unlock_context(conn->phys_ctx);; 13525 }; 13526 }; 13527 ; 13528 DEBUG_TRACE(""HTTP%s Host: %.*s"",; 13529 conn->ssl ? ""S"" : """",; 13530 (int)host.len,; 13531 host.ptr);; 13532 ; 13533 } else {; 13534 DEBUG_TRACE(""HTTP%s Host is not set"", conn->ssl ? ""S"" : """");; 13535 return 1;; 13536 }; 13537 ; 13538 return 1;; 13539}; 13540 ; 13541 ; 13542static void; 13543redirect_to_https_port(struct mg_connection *conn, int port); 13544{; 13545 char target_url[MG_BUF_LEN];; 13546 int truncated = 0;; 13547 const char *expect_proto =; 13548 (conn->protocol_type == PROTOCOL_TYPE_WEBSOCKET) ? ""wss"" : ""https"";; 13549 ; 13550 /* Use ""308 Permanent Redirect"" */; 13551 int redirect_code = 308;; 13552 ; 13553 /* In any case, close the current connection */; 13554 conn->must_close = 1;; 13555 ; 13556 /* Send host, port, uri and (if it exists) ?query_string */; 13557 if (mg_construct_local_link(",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:408338,Modifiability,config,config,408338,"ata_handler;; 13921 *close_handler = tmp_rh->close_handler;; 13922 } else if (handler_type == REQUEST_HANDLER) {; 13923 if (tmp_rh->removing) {; 13924 /* Treat as none found */; 13925 step = 2;; 13926 break;; 13927 }; 13928 *handler = tmp_rh->handler;; 13929 /* Acquire handler and give it back */; 13930 tmp_rh->refcount++;; 13931 *handler_info = tmp_rh;; 13932 } else { /* AUTH_HANDLER */; 13933 *auth_handler = tmp_rh->auth_handler;; 13934 }; 13935 *cbdata = tmp_rh->cbdata;; 13936 mg_unlock_context(conn->phys_ctx);; 13937 return 1;; 13938 }; 13939 }; 13940 }; 13941 ; 13942 mg_unlock_context(conn->phys_ctx);; 13943 }; 13944 return 0; /* none found */; 13945}; 13946 ; 13947 ; 13948/* Check if the script file is in a path, allowed for script files.; 13949 * This can be used if uploading files is possible not only for the server; 13950 * admin, and the upload mechanism does not check the file extension.; 13951 */; 13952static int; 13953is_in_script_path(const struct mg_connection *conn, const char *path); 13954{; 13955 /* TODO (Feature): Add config value for allowed script path.; 13956 * Default: All allowed. */; 13957 (void)conn;; 13958 (void)path;; 13959 return 1;; 13960}; 13961 ; 13962 ; 13963#if defined(USE_WEBSOCKET) && defined(MG_EXPERIMENTAL_INTERFACES); 13964static int; 13965experimental_websocket_client_data_wrapper(struct mg_connection *conn,; 13966 int bits,; 13967 char *data,; 13968 size_t len,; 13969 void *cbdata); 13970{; 13971 struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;; 13972 if (pcallbacks->websocket_data) {; 13973 return pcallbacks->websocket_data(conn, bits, data, len);; 13974 }; 13975 /* No handler set - assume ""OK"" */; 13976 return 1;; 13977}; 13978 ; 13979 ; 13980static void; 13981experimental_websocket_client_close_wrapper(const struct mg_connection *conn,; 13982 void *cbdata); 13983{; 13984 struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;; 13985 if (pcallbacks->connection_close) {; 13986 pcallbacks->connection_c",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:412114,Modifiability,config,configured,412114,"internal state (required for HTTP/2 proxy) */; 14040 conn->request_state = 0;; 14041 ; 14042 /* 1. get the request url */; 14043 /* 1.1. split into url and query string */; 14044 if ((conn->request_info.query_string = strchr(ri->request_uri, '?')); 14045 != NULL) {; 14046 *((char *)conn->request_info.query_string++) = '\0';; 14047 }; 14048 ; 14049 /* 1.2. do a https redirect, if required. Do not decode URIs yet. */; 14050 if (!conn->client.is_ssl && conn->client.ssl_redir) {; 14051 ssl_index = get_first_ssl_listener_index(conn->phys_ctx);; 14052 if (ssl_index >= 0) {; 14053 int port = (int)ntohs(USA_IN_PORT_UNSAFE(; 14054 &(conn->phys_ctx->listening_sockets[ssl_index].lsa)));; 14055 redirect_to_https_port(conn, port);; 14056 } else {; 14057 /* A http to https forward port has been specified,; 14058 * but no https port to forward to. */; 14059 mg_send_http_error(conn,; 14060 503,; 14061 ""%s"",; 14062 ""Error: SSL forward not configured properly"");; 14063 mg_cry_internal(conn,; 14064 ""%s"",; 14065 ""Can not redirect to SSL, no SSL port available"");; 14066 }; 14067 return;; 14068 }; 14069 uri_len = (int)strlen(ri->local_uri);; 14070 ; 14071 /* 1.3. decode url (if config says so) */; 14072 if (should_decode_url(conn)) {; 14073 mg_url_decode(; 14074 ri->local_uri, uri_len, (char *)ri->local_uri, uri_len + 1, 0);; 14075 }; 14076 ; 14077 /* URL decode the query-string only if explicity set in the configuration */; 14078 if (conn->request_info.query_string) {; 14079 if (should_decode_query_string(conn)) {; 14080 url_decode_in_place((char *)conn->request_info.query_string);; 14081 }; 14082 }; 14083 ; 14084 /* 1.4. clean URIs, so a path like allowed_dir/../forbidden_file is not; 14085 * possible. The fact that we cleaned the URI is stored in that the; 14086 * pointer to ri->local_ur and ri->local_uri_raw are now different.; 14087 * ri->local_uri_raw still points to memory allocated in; 14088 * worker_thread_run(). ri->local_uri is private to the request so we; 14089 * don't have t",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:412353,Modifiability,config,config,412353,"_string++) = '\0';; 14047 }; 14048 ; 14049 /* 1.2. do a https redirect, if required. Do not decode URIs yet. */; 14050 if (!conn->client.is_ssl && conn->client.ssl_redir) {; 14051 ssl_index = get_first_ssl_listener_index(conn->phys_ctx);; 14052 if (ssl_index >= 0) {; 14053 int port = (int)ntohs(USA_IN_PORT_UNSAFE(; 14054 &(conn->phys_ctx->listening_sockets[ssl_index].lsa)));; 14055 redirect_to_https_port(conn, port);; 14056 } else {; 14057 /* A http to https forward port has been specified,; 14058 * but no https port to forward to. */; 14059 mg_send_http_error(conn,; 14060 503,; 14061 ""%s"",; 14062 ""Error: SSL forward not configured properly"");; 14063 mg_cry_internal(conn,; 14064 ""%s"",; 14065 ""Can not redirect to SSL, no SSL port available"");; 14066 }; 14067 return;; 14068 }; 14069 uri_len = (int)strlen(ri->local_uri);; 14070 ; 14071 /* 1.3. decode url (if config says so) */; 14072 if (should_decode_url(conn)) {; 14073 mg_url_decode(; 14074 ri->local_uri, uri_len, (char *)ri->local_uri, uri_len + 1, 0);; 14075 }; 14076 ; 14077 /* URL decode the query-string only if explicity set in the configuration */; 14078 if (conn->request_info.query_string) {; 14079 if (should_decode_query_string(conn)) {; 14080 url_decode_in_place((char *)conn->request_info.query_string);; 14081 }; 14082 }; 14083 ; 14084 /* 1.4. clean URIs, so a path like allowed_dir/../forbidden_file is not; 14085 * possible. The fact that we cleaned the URI is stored in that the; 14086 * pointer to ri->local_ur and ri->local_uri_raw are now different.; 14087 * ri->local_uri_raw still points to memory allocated in; 14088 * worker_thread_run(). ri->local_uri is private to the request so we; 14089 * don't have to use preallocated memory here. */; 14090 tmp = mg_strdup(ri->local_uri_raw);; 14091 if (!tmp) {; 14092 /* Out of memory. We cannot do anything reasonable here. */; 14093 return;; 14094 }; 14095 remove_dot_segments(tmp);; 14096 ri->local_uri = tmp;; 14097 ; 14098 /* step 1. completed, the url is known now ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:412587,Modifiability,config,configuration,412587,"_string++) = '\0';; 14047 }; 14048 ; 14049 /* 1.2. do a https redirect, if required. Do not decode URIs yet. */; 14050 if (!conn->client.is_ssl && conn->client.ssl_redir) {; 14051 ssl_index = get_first_ssl_listener_index(conn->phys_ctx);; 14052 if (ssl_index >= 0) {; 14053 int port = (int)ntohs(USA_IN_PORT_UNSAFE(; 14054 &(conn->phys_ctx->listening_sockets[ssl_index].lsa)));; 14055 redirect_to_https_port(conn, port);; 14056 } else {; 14057 /* A http to https forward port has been specified,; 14058 * but no https port to forward to. */; 14059 mg_send_http_error(conn,; 14060 503,; 14061 ""%s"",; 14062 ""Error: SSL forward not configured properly"");; 14063 mg_cry_internal(conn,; 14064 ""%s"",; 14065 ""Can not redirect to SSL, no SSL port available"");; 14066 }; 14067 return;; 14068 }; 14069 uri_len = (int)strlen(ri->local_uri);; 14070 ; 14071 /* 1.3. decode url (if config says so) */; 14072 if (should_decode_url(conn)) {; 14073 mg_url_decode(; 14074 ri->local_uri, uri_len, (char *)ri->local_uri, uri_len + 1, 0);; 14075 }; 14076 ; 14077 /* URL decode the query-string only if explicity set in the configuration */; 14078 if (conn->request_info.query_string) {; 14079 if (should_decode_query_string(conn)) {; 14080 url_decode_in_place((char *)conn->request_info.query_string);; 14081 }; 14082 }; 14083 ; 14084 /* 1.4. clean URIs, so a path like allowed_dir/../forbidden_file is not; 14085 * possible. The fact that we cleaned the URI is stored in that the; 14086 * pointer to ri->local_ur and ri->local_uri_raw are now different.; 14087 * ri->local_uri_raw still points to memory allocated in; 14088 * worker_thread_run(). ri->local_uri is private to the request so we; 14089 * don't have to use preallocated memory here. */; 14090 tmp = mg_strdup(ri->local_uri_raw);; 14091 if (!tmp) {; 14092 /* Out of memory. We cannot do anything reasonable here. */; 14093 return;; 14094 }; 14095 remove_dot_segments(tmp);; 14096 ri->local_uri = tmp;; 14097 ; 14098 /* step 1. completed, the url is known now ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:413668,Modifiability,config,config,413668,"fo.query_string) {; 14079 if (should_decode_query_string(conn)) {; 14080 url_decode_in_place((char *)conn->request_info.query_string);; 14081 }; 14082 }; 14083 ; 14084 /* 1.4. clean URIs, so a path like allowed_dir/../forbidden_file is not; 14085 * possible. The fact that we cleaned the URI is stored in that the; 14086 * pointer to ri->local_ur and ri->local_uri_raw are now different.; 14087 * ri->local_uri_raw still points to memory allocated in; 14088 * worker_thread_run(). ri->local_uri is private to the request so we; 14089 * don't have to use preallocated memory here. */; 14090 tmp = mg_strdup(ri->local_uri_raw);; 14091 if (!tmp) {; 14092 /* Out of memory. We cannot do anything reasonable here. */; 14093 return;; 14094 }; 14095 remove_dot_segments(tmp);; 14096 ri->local_uri = tmp;; 14097 ; 14098 /* step 1. completed, the url is known now */; 14099 DEBUG_TRACE(""URL: %s"", ri->local_uri);; 14100 ; 14101 /* 2. if this ip has limited speed, set it for this connection */; 14102 conn->throttle = set_throttle(conn->dom_ctx->config[THROTTLE],; 14103 &conn->client.rsa,; 14104 ri->local_uri);; 14105 ; 14106 /* 3. call a ""handle everything"" callback, if registered */; 14107 if (conn->phys_ctx->callbacks.begin_request != NULL) {; 14108 /* Note that since V1.7 the ""begin_request"" function is called; 14109 * before an authorization check. If an authorization check is; 14110 * required, use a request_handler instead. */; 14111 i = conn->phys_ctx->callbacks.begin_request(conn);; 14112 if (i > 0) {; 14113 /* callback already processed the request. Store the; 14114 return value as a status code for the access log. */; 14115 conn->status_code = i;; 14116 if (!conn->must_close) {; 14117 discard_unread_request_data(conn);; 14118 }; 14119 return;; 14120 } else if (i == 0) {; 14121 /* civetweb should process the request */; 14122 } else {; 14123 /* unspecified - may change with the next version */; 14124 return;; 14125 }; 14126 }; 14127 ; 14128 /* request not yet handled by a handler ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:414764,Modifiability,config,configured,414764,"; 14106 /* 3. call a ""handle everything"" callback, if registered */; 14107 if (conn->phys_ctx->callbacks.begin_request != NULL) {; 14108 /* Note that since V1.7 the ""begin_request"" function is called; 14109 * before an authorization check. If an authorization check is; 14110 * required, use a request_handler instead. */; 14111 i = conn->phys_ctx->callbacks.begin_request(conn);; 14112 if (i > 0) {; 14113 /* callback already processed the request. Store the; 14114 return value as a status code for the access log. */; 14115 conn->status_code = i;; 14116 if (!conn->must_close) {; 14117 discard_unread_request_data(conn);; 14118 }; 14119 return;; 14120 } else if (i == 0) {; 14121 /* civetweb should process the request */; 14122 } else {; 14123 /* unspecified - may change with the next version */; 14124 return;; 14125 }; 14126 }; 14127 ; 14128 /* request not yet handled by a handler or redirect, so the request; 14129 * is processed here */; 14130 ; 14131 /* 4. Check for CORS preflight requests and handle them (if configured).; 14132 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS; 14133 */; 14134 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14135 /* Send a response to CORS preflights only if; 14136 * access_control_allow_methods is not NULL and not an empty string.; 14137 * In this case, scripts can still handle CORS. */; 14138 const char *cors_meth_cfg =; 14139 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_METHODS];; 14140 const char *cors_orig_cfg =; 14141 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];; 14142 const char *cors_cred_cfg =; 14143 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_CREDENTIALS];; 14144 const char *cors_origin =; 14145 get_header(ri->http_headers, ri->num_headers, ""Origin"");; 14146 const char *cors_acrm = get_header(ri->http_headers,; 14147 ri->num_headers,; 14148 ""Access-Control-Request-Method"");; 14149 ; 14150 /* Todo: check if cors_origin is in cors_orig_cfg.; 14151 * Or, let the client check this. */; 14152 ; 14153 if ((",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:415161,Modifiability,config,config,415161,"; 14120 } else if (i == 0) {; 14121 /* civetweb should process the request */; 14122 } else {; 14123 /* unspecified - may change with the next version */; 14124 return;; 14125 }; 14126 }; 14127 ; 14128 /* request not yet handled by a handler or redirect, so the request; 14129 * is processed here */; 14130 ; 14131 /* 4. Check for CORS preflight requests and handle them (if configured).; 14132 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS; 14133 */; 14134 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14135 /* Send a response to CORS preflights only if; 14136 * access_control_allow_methods is not NULL and not an empty string.; 14137 * In this case, scripts can still handle CORS. */; 14138 const char *cors_meth_cfg =; 14139 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_METHODS];; 14140 const char *cors_orig_cfg =; 14141 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];; 14142 const char *cors_cred_cfg =; 14143 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_CREDENTIALS];; 14144 const char *cors_origin =; 14145 get_header(ri->http_headers, ri->num_headers, ""Origin"");; 14146 const char *cors_acrm = get_header(ri->http_headers,; 14147 ri->num_headers,; 14148 ""Access-Control-Request-Method"");; 14149 ; 14150 /* Todo: check if cors_origin is in cors_orig_cfg.; 14151 * Or, let the client check this. */; 14152 ; 14153 if ((cors_meth_cfg != NULL) && (*cors_meth_cfg != 0); 14154 && (cors_orig_cfg != NULL) && (*cors_orig_cfg != 0); 14155 && (cors_origin != NULL) && (cors_acrm != NULL)) {; 14156 /* This is a valid CORS preflight, and the server is configured; 14157 * to handle it automatically. */; 14158 const char *cors_acrh =; 14159 get_header(ri->http_headers,; 14160 ri->num_headers,; 14161 ""Access-Control-Request-Headers"");; 14162 ; 14163 gmt_time_string(date, sizeof(date), &curtime);; 14164 mg_printf(conn,; 14165 ""HTTP/1.1 200 OK\r\n""; 14166 ""Date: %s\r\n""; 14167 ""Access-Control-Allow-Origin: %s\r\n""; 14168 ""Access-Control-Allow-Methods: %s\r\n""; 14169 ""Con",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:415256,Modifiability,config,config,415256,"; 14120 } else if (i == 0) {; 14121 /* civetweb should process the request */; 14122 } else {; 14123 /* unspecified - may change with the next version */; 14124 return;; 14125 }; 14126 }; 14127 ; 14128 /* request not yet handled by a handler or redirect, so the request; 14129 * is processed here */; 14130 ; 14131 /* 4. Check for CORS preflight requests and handle them (if configured).; 14132 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS; 14133 */; 14134 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14135 /* Send a response to CORS preflights only if; 14136 * access_control_allow_methods is not NULL and not an empty string.; 14137 * In this case, scripts can still handle CORS. */; 14138 const char *cors_meth_cfg =; 14139 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_METHODS];; 14140 const char *cors_orig_cfg =; 14141 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];; 14142 const char *cors_cred_cfg =; 14143 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_CREDENTIALS];; 14144 const char *cors_origin =; 14145 get_header(ri->http_headers, ri->num_headers, ""Origin"");; 14146 const char *cors_acrm = get_header(ri->http_headers,; 14147 ri->num_headers,; 14148 ""Access-Control-Request-Method"");; 14149 ; 14150 /* Todo: check if cors_origin is in cors_orig_cfg.; 14151 * Or, let the client check this. */; 14152 ; 14153 if ((cors_meth_cfg != NULL) && (*cors_meth_cfg != 0); 14154 && (cors_orig_cfg != NULL) && (*cors_orig_cfg != 0); 14155 && (cors_origin != NULL) && (cors_acrm != NULL)) {; 14156 /* This is a valid CORS preflight, and the server is configured; 14157 * to handle it automatically. */; 14158 const char *cors_acrh =; 14159 get_header(ri->http_headers,; 14160 ri->num_headers,; 14161 ""Access-Control-Request-Headers"");; 14162 ; 14163 gmt_time_string(date, sizeof(date), &curtime);; 14164 mg_printf(conn,; 14165 ""HTTP/1.1 200 OK\r\n""; 14166 ""Date: %s\r\n""; 14167 ""Access-Control-Allow-Origin: %s\r\n""; 14168 ""Access-Control-Allow-Methods: %s\r\n""; 14169 ""Con",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:415350,Modifiability,config,config,415350,"; 14120 } else if (i == 0) {; 14121 /* civetweb should process the request */; 14122 } else {; 14123 /* unspecified - may change with the next version */; 14124 return;; 14125 }; 14126 }; 14127 ; 14128 /* request not yet handled by a handler or redirect, so the request; 14129 * is processed here */; 14130 ; 14131 /* 4. Check for CORS preflight requests and handle them (if configured).; 14132 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS; 14133 */; 14134 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14135 /* Send a response to CORS preflights only if; 14136 * access_control_allow_methods is not NULL and not an empty string.; 14137 * In this case, scripts can still handle CORS. */; 14138 const char *cors_meth_cfg =; 14139 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_METHODS];; 14140 const char *cors_orig_cfg =; 14141 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];; 14142 const char *cors_cred_cfg =; 14143 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_CREDENTIALS];; 14144 const char *cors_origin =; 14145 get_header(ri->http_headers, ri->num_headers, ""Origin"");; 14146 const char *cors_acrm = get_header(ri->http_headers,; 14147 ri->num_headers,; 14148 ""Access-Control-Request-Method"");; 14149 ; 14150 /* Todo: check if cors_origin is in cors_orig_cfg.; 14151 * Or, let the client check this. */; 14152 ; 14153 if ((cors_meth_cfg != NULL) && (*cors_meth_cfg != 0); 14154 && (cors_orig_cfg != NULL) && (*cors_orig_cfg != 0); 14155 && (cors_origin != NULL) && (cors_acrm != NULL)) {; 14156 /* This is a valid CORS preflight, and the server is configured; 14157 * to handle it automatically. */; 14158 const char *cors_acrh =; 14159 get_header(ri->http_headers,; 14160 ri->num_headers,; 14161 ""Access-Control-Request-Headers"");; 14162 ; 14163 gmt_time_string(date, sizeof(date), &curtime);; 14164 mg_printf(conn,; 14165 ""HTTP/1.1 200 OK\r\n""; 14166 ""Date: %s\r\n""; 14167 ""Access-Control-Allow-Origin: %s\r\n""; 14168 ""Access-Control-Allow-Methods: %s\r\n""; 14169 ""Con",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:415968,Modifiability,config,configured,415968,"14134 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14135 /* Send a response to CORS preflights only if; 14136 * access_control_allow_methods is not NULL and not an empty string.; 14137 * In this case, scripts can still handle CORS. */; 14138 const char *cors_meth_cfg =; 14139 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_METHODS];; 14140 const char *cors_orig_cfg =; 14141 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];; 14142 const char *cors_cred_cfg =; 14143 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_CREDENTIALS];; 14144 const char *cors_origin =; 14145 get_header(ri->http_headers, ri->num_headers, ""Origin"");; 14146 const char *cors_acrm = get_header(ri->http_headers,; 14147 ri->num_headers,; 14148 ""Access-Control-Request-Method"");; 14149 ; 14150 /* Todo: check if cors_origin is in cors_orig_cfg.; 14151 * Or, let the client check this. */; 14152 ; 14153 if ((cors_meth_cfg != NULL) && (*cors_meth_cfg != 0); 14154 && (cors_orig_cfg != NULL) && (*cors_orig_cfg != 0); 14155 && (cors_origin != NULL) && (cors_acrm != NULL)) {; 14156 /* This is a valid CORS preflight, and the server is configured; 14157 * to handle it automatically. */; 14158 const char *cors_acrh =; 14159 get_header(ri->http_headers,; 14160 ri->num_headers,; 14161 ""Access-Control-Request-Headers"");; 14162 ; 14163 gmt_time_string(date, sizeof(date), &curtime);; 14164 mg_printf(conn,; 14165 ""HTTP/1.1 200 OK\r\n""; 14166 ""Date: %s\r\n""; 14167 ""Access-Control-Allow-Origin: %s\r\n""; 14168 ""Access-Control-Allow-Methods: %s\r\n""; 14169 ""Content-Length: 0\r\n""; 14170 ""Connection: %s\r\n"",; 14171 date,; 14172 cors_orig_cfg,; 14173 ((cors_meth_cfg[0] == '*') ? cors_acrm : cors_meth_cfg),; 14174 suggest_connection_header(conn));; 14175 ; 14176 if (cors_acrh != NULL) {; 14177 /* CORS request is asking for additional headers */; 14178 const char *cors_hdr_cfg =; 14179 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_HEADERS];; 14180 ; 14181 if ((cors_hdr_cfg != NULL) && (*cors_hdr_cfg != 0)) {; 14182 /* Allow only if ac",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:416734,Modifiability,config,config,416734,"-Request-Method"");; 14149 ; 14150 /* Todo: check if cors_origin is in cors_orig_cfg.; 14151 * Or, let the client check this. */; 14152 ; 14153 if ((cors_meth_cfg != NULL) && (*cors_meth_cfg != 0); 14154 && (cors_orig_cfg != NULL) && (*cors_orig_cfg != 0); 14155 && (cors_origin != NULL) && (cors_acrm != NULL)) {; 14156 /* This is a valid CORS preflight, and the server is configured; 14157 * to handle it automatically. */; 14158 const char *cors_acrh =; 14159 get_header(ri->http_headers,; 14160 ri->num_headers,; 14161 ""Access-Control-Request-Headers"");; 14162 ; 14163 gmt_time_string(date, sizeof(date), &curtime);; 14164 mg_printf(conn,; 14165 ""HTTP/1.1 200 OK\r\n""; 14166 ""Date: %s\r\n""; 14167 ""Access-Control-Allow-Origin: %s\r\n""; 14168 ""Access-Control-Allow-Methods: %s\r\n""; 14169 ""Content-Length: 0\r\n""; 14170 ""Connection: %s\r\n"",; 14171 date,; 14172 cors_orig_cfg,; 14173 ((cors_meth_cfg[0] == '*') ? cors_acrm : cors_meth_cfg),; 14174 suggest_connection_header(conn));; 14175 ; 14176 if (cors_acrh != NULL) {; 14177 /* CORS request is asking for additional headers */; 14178 const char *cors_hdr_cfg =; 14179 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_HEADERS];; 14180 ; 14181 if ((cors_hdr_cfg != NULL) && (*cors_hdr_cfg != 0)) {; 14182 /* Allow only if access_control_allow_headers is; 14183 * not NULL and not an empty string. If this; 14184 * configuration is set to *, allow everything.; 14185 * Otherwise this configuration must be a list; 14186 * of allowed HTTP header names. */; 14187 mg_printf(conn,; 14188 ""Access-Control-Allow-Headers: %s\r\n"",; 14189 ((cors_hdr_cfg[0] == '*') ? cors_acrh; 14190 : cors_hdr_cfg));; 14191 }; 14192 }; 14193 if (cors_cred_cfg && *cors_cred_cfg) {; 14194 mg_printf(conn,; 14195 ""Access-Control-Allow-Credentials: %s\r\n"",; 14196 cors_cred_cfg);; 14197 }; 14198 ; 14199 mg_printf(conn, ""Access-Control-Max-Age: 60\r\n"");; 14200 ; 14201 mg_printf(conn, ""\r\n"");; 14202 return;; 14203 }; 14204 }; 14205 ; 14206 /* 5. interpret the url to find out",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:416957,Modifiability,config,configuration,416957,"nfigured; 14157 * to handle it automatically. */; 14158 const char *cors_acrh =; 14159 get_header(ri->http_headers,; 14160 ri->num_headers,; 14161 ""Access-Control-Request-Headers"");; 14162 ; 14163 gmt_time_string(date, sizeof(date), &curtime);; 14164 mg_printf(conn,; 14165 ""HTTP/1.1 200 OK\r\n""; 14166 ""Date: %s\r\n""; 14167 ""Access-Control-Allow-Origin: %s\r\n""; 14168 ""Access-Control-Allow-Methods: %s\r\n""; 14169 ""Content-Length: 0\r\n""; 14170 ""Connection: %s\r\n"",; 14171 date,; 14172 cors_orig_cfg,; 14173 ((cors_meth_cfg[0] == '*') ? cors_acrm : cors_meth_cfg),; 14174 suggest_connection_header(conn));; 14175 ; 14176 if (cors_acrh != NULL) {; 14177 /* CORS request is asking for additional headers */; 14178 const char *cors_hdr_cfg =; 14179 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_HEADERS];; 14180 ; 14181 if ((cors_hdr_cfg != NULL) && (*cors_hdr_cfg != 0)) {; 14182 /* Allow only if access_control_allow_headers is; 14183 * not NULL and not an empty string. If this; 14184 * configuration is set to *, allow everything.; 14185 * Otherwise this configuration must be a list; 14186 * of allowed HTTP header names. */; 14187 mg_printf(conn,; 14188 ""Access-Control-Allow-Headers: %s\r\n"",; 14189 ((cors_hdr_cfg[0] == '*') ? cors_acrh; 14190 : cors_hdr_cfg));; 14191 }; 14192 }; 14193 if (cors_cred_cfg && *cors_cred_cfg) {; 14194 mg_printf(conn,; 14195 ""Access-Control-Allow-Credentials: %s\r\n"",; 14196 cors_cred_cfg);; 14197 }; 14198 ; 14199 mg_printf(conn, ""Access-Control-Max-Age: 60\r\n"");; 14200 ; 14201 mg_printf(conn, ""\r\n"");; 14202 return;; 14203 }; 14204 }; 14205 ; 14206 /* 5. interpret the url to find out how the request must be handled; 14207 */; 14208 /* 5.1. first test, if the request targets the regular http(s)://; 14209 * protocol namespace or the websocket ws(s):// protocol namespace.; 14210 */; 14211 is_websocket_request = (conn->protocol_type == PROTOCOL_TYPE_WEBSOCKET);; 14212#if defined(USE_WEBSOCKET); 14213 handler_type = is_websocket_request ? WEBSOCKET_HANDLE",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:417026,Modifiability,config,configuration,417026," =; 14159 get_header(ri->http_headers,; 14160 ri->num_headers,; 14161 ""Access-Control-Request-Headers"");; 14162 ; 14163 gmt_time_string(date, sizeof(date), &curtime);; 14164 mg_printf(conn,; 14165 ""HTTP/1.1 200 OK\r\n""; 14166 ""Date: %s\r\n""; 14167 ""Access-Control-Allow-Origin: %s\r\n""; 14168 ""Access-Control-Allow-Methods: %s\r\n""; 14169 ""Content-Length: 0\r\n""; 14170 ""Connection: %s\r\n"",; 14171 date,; 14172 cors_orig_cfg,; 14173 ((cors_meth_cfg[0] == '*') ? cors_acrm : cors_meth_cfg),; 14174 suggest_connection_header(conn));; 14175 ; 14176 if (cors_acrh != NULL) {; 14177 /* CORS request is asking for additional headers */; 14178 const char *cors_hdr_cfg =; 14179 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_HEADERS];; 14180 ; 14181 if ((cors_hdr_cfg != NULL) && (*cors_hdr_cfg != 0)) {; 14182 /* Allow only if access_control_allow_headers is; 14183 * not NULL and not an empty string. If this; 14184 * configuration is set to *, allow everything.; 14185 * Otherwise this configuration must be a list; 14186 * of allowed HTTP header names. */; 14187 mg_printf(conn,; 14188 ""Access-Control-Allow-Headers: %s\r\n"",; 14189 ((cors_hdr_cfg[0] == '*') ? cors_acrh; 14190 : cors_hdr_cfg));; 14191 }; 14192 }; 14193 if (cors_cred_cfg && *cors_cred_cfg) {; 14194 mg_printf(conn,; 14195 ""Access-Control-Allow-Credentials: %s\r\n"",; 14196 cors_cred_cfg);; 14197 }; 14198 ; 14199 mg_printf(conn, ""Access-Control-Max-Age: 60\r\n"");; 14200 ; 14201 mg_printf(conn, ""\r\n"");; 14202 return;; 14203 }; 14204 }; 14205 ; 14206 /* 5. interpret the url to find out how the request must be handled; 14207 */; 14208 /* 5.1. first test, if the request targets the regular http(s)://; 14209 * protocol namespace or the websocket ws(s):// protocol namespace.; 14210 */; 14211 is_websocket_request = (conn->protocol_type == PROTOCOL_TYPE_WEBSOCKET);; 14212#if defined(USE_WEBSOCKET); 14213 handler_type = is_websocket_request ? WEBSOCKET_HANDLER : REQUEST_HANDLER;; 14214#else; 14215 handler_type = REQUEST_HANDLER;; 1421",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:420134,Modifiability,config,config,420134,"cket_request,; 14254 &is_put_or_delete_request,; 14255 &is_template_text_file);; 14256 }; 14257 ; 14258 /* 6. authorization check */; 14259 /* 6.1. a custom authorization handler is installed */; 14260 if (get_request_handler(conn,; 14261 AUTH_HANDLER,; 14262 NULL,; 14263 NULL,; 14264 NULL,; 14265 NULL,; 14266 NULL,; 14267 NULL,; 14268 &auth_handler,; 14269 &auth_callback_data,; 14270 NULL)) {; 14271 if (!auth_handler(conn, auth_callback_data)) {; 14272 ; 14273 /* Callback handler will not be used anymore. Release it */; 14274 release_handler_ref(conn, handler_info);; 14275 ; 14276 return;; 14277 }; 14278 } else if (is_put_or_delete_request && !is_script_resource; 14279 && !is_callback_resource) {; 14280 HTTP1_only;; 14281 /* 6.2. this request is a PUT/DELETE to a real file */; 14282 /* 6.2.1. thus, the server must have real files */; 14283#if defined(NO_FILES); 14284 if (1) {; 14285#else; 14286 if (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {; 14287#endif; 14288 /* This code path will not be called for request handlers */; 14289 DEBUG_ASSERT(handler_info == NULL);; 14290 ; 14291 /* This server does not have any real files, thus the; 14292 * PUT/DELETE methods are not valid. */; 14293 mg_send_http_error(conn,; 14294 405,; 14295 ""%s method not allowed"",; 14296 conn->request_info.request_method);; 14297 return;; 14298 }; 14299 ; 14300#if !defined(NO_FILES); 14301 /* 6.2.2. Check if put authorization for static files is; 14302 * available.; 14303 */; 14304 if (!is_authorized_for_put(conn)) {; 14305 send_authorization_request(conn, NULL);; 14306 return;; 14307 }; 14308#endif; 14309 ; 14310 } else {; 14311 /* 6.3. This is either a OPTIONS, GET, HEAD or POST request,; 14312 * or it is a PUT or DELETE request to a resource that does not; 14313 * correspond to a file. Check authorization. */; 14314 if (!check_authorization(conn, path)) {; 14315 send_authorization_request(conn, NULL);; 14316 ; 14317 /* Callback handler will not be used anymore. Release it */; 14318 releas",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:424946,Modifiability,config,config,424946,"(is_script_resource) {; 14404 ; 14405 if (is_in_script_path(conn, path)) {; 14406 /* Websocket Lua script */; 14407 handle_websocket_request(conn,; 14408 path,; 14409 0 /* Lua Script */,; 14410 NULL,; 14411 NULL,; 14412 NULL,; 14413 NULL,; 14414 NULL,; 14415 conn->phys_ctx->user_data);; 14416 } else {; 14417 /* Script was in an illegal path */; 14418 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14419 }; 14420 } else {; 14421 mg_send_http_error(conn, 404, ""%s"", ""Not found"");; 14422 }; 14423 return;; 14424 } else; 14425#endif; 14426 ; 14427#if defined(NO_FILES); 14428 /* 9a. In case the server uses only callbacks, this uri is; 14429 * unknown.; 14430 * Then, all request handling ends here. */; 14431 mg_send_http_error(conn, 404, ""%s"", ""Not Found"");; 14432 ; 14433#else; 14434 /* 9b. This request is either for a static file or resource handled; 14435 * by a script file. Thus, a DOCUMENT_ROOT must exist. */; 14436 if (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {; 14437 mg_send_http_error(conn, 404, ""%s"", ""Not Found"");; 14438 return;; 14439 }; 14440 ; 14441 /* 10. Request is handled by a script */; 14442 if (is_script_resource) {; 14443 HTTP1_only;; 14444 handle_file_based_request(conn, path, &file);; 14445 return;; 14446 }; 14447 ; 14448 /* 11. Handle put/delete/mkcol requests */; 14449 if (is_put_or_delete_request) {; 14450 HTTP1_only;; 14451 /* 11.1. PUT method */; 14452 if (!strcmp(ri->request_method, ""PUT"")) {; 14453 put_file(conn, path);; 14454 return;; 14455 }; 14456 /* 11.2. DELETE method */; 14457 if (!strcmp(ri->request_method, ""DELETE"")) {; 14458 delete_file(conn, path);; 14459 return;; 14460 }; 14461 /* 11.3. MKCOL method */; 14462 if (!strcmp(ri->request_method, ""MKCOL"")) {; 14463 mkcol(conn, path);; 14464 return;; 14465 }; 14466 /* 11.4. PATCH method; 14467 * This method is not supported for static resources,; 14468 * only for scripts (Lua, CGI) and callbacks. */; 14469 mg_send_http_error(conn,; 14470 405,; 14471 ""%s method not allowed"",; 14472 conn-",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:426107,Modifiability,config,configured,426107,"equest(conn, path, &file);; 14445 return;; 14446 }; 14447 ; 14448 /* 11. Handle put/delete/mkcol requests */; 14449 if (is_put_or_delete_request) {; 14450 HTTP1_only;; 14451 /* 11.1. PUT method */; 14452 if (!strcmp(ri->request_method, ""PUT"")) {; 14453 put_file(conn, path);; 14454 return;; 14455 }; 14456 /* 11.2. DELETE method */; 14457 if (!strcmp(ri->request_method, ""DELETE"")) {; 14458 delete_file(conn, path);; 14459 return;; 14460 }; 14461 /* 11.3. MKCOL method */; 14462 if (!strcmp(ri->request_method, ""MKCOL"")) {; 14463 mkcol(conn, path);; 14464 return;; 14465 }; 14466 /* 11.4. PATCH method; 14467 * This method is not supported for static resources,; 14468 * only for scripts (Lua, CGI) and callbacks. */; 14469 mg_send_http_error(conn,; 14470 405,; 14471 ""%s method not allowed"",; 14472 conn->request_info.request_method);; 14473 return;; 14474 }; 14475 ; 14476 /* 11. File does not exist, or it was configured that it should be; 14477 * hidden */; 14478 if (!is_found || (must_hide_file(conn, path))) {; 14479 mg_send_http_error(conn, 404, ""%s"", ""Not found"");; 14480 return;; 14481 }; 14482 ; 14483 /* 12. Directory uris should end with a slash */; 14484 if (file.stat.is_directory && (uri_len > 0); 14485 && (ri->local_uri[uri_len - 1] != '/')) {; 14486 ; 14487 size_t len = strlen(ri->request_uri);; 14488 size_t lenQS = ri->query_string ? strlen(ri->query_string) + 1 : 0;; 14489 char *new_path = (char *)mg_malloc_ctx(len + lenQS + 2, conn->phys_ctx);; 14490 if (!new_path) {; 14491 mg_send_http_error(conn, 500, ""out or memory"");; 14492 } else {; 14493 memcpy(new_path, ri->request_uri, len);; 14494 new_path[len] = '/';; 14495 new_path[len + 1] = 0;; 14496 if (ri->query_string) {; 14497 new_path[len + 1] = '?';; 14498 /* Copy query string including terminating zero */; 14499 memcpy(new_path + len + 2, ri->query_string, lenQS);; 14500 }; 14501 mg_send_http_redirect(conn, new_path, 301);; 14502 mg_free(new_path);; 14503 }; 14504 return;; 14505 }; 14506 ; 14507 /* 13. Handle o",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:428396,Modifiability,config,config,428396,"handler is only used for real files.; 14516 * Scripts should support the OPTIONS method themselves, to allow a; 14517 * maximum flexibility.; 14518 * Lua and CGI scripts may fully support CORS this way (including; 14519 * preflights). */; 14520 send_options(conn);; 14521 return;; 14522 }; 14523 /* 13.3. everything but GET and HEAD (e.g. POST) */; 14524 if ((0 != strcmp(ri->request_method, ""GET"")); 14525 && (0 != strcmp(ri->request_method, ""HEAD""))) {; 14526 mg_send_http_error(conn,; 14527 405,; 14528 ""%s method not allowed"",; 14529 conn->request_info.request_method);; 14530 return;; 14531 }; 14532 ; 14533 /* 14. directories */; 14534 if (file.stat.is_directory) {; 14535 /* Substitute files have already been handled above. */; 14536 /* Here we can either generate and send a directory listing,; 14537 * or send an ""access denied"" error. */; 14538 if (!mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],; 14539 ""yes"")) {; 14540 handle_directory_request(conn, path);; 14541 } else {; 14542 mg_send_http_error(conn,; 14543 403,; 14544 ""%s"",; 14545 ""Error: Directory listing denied"");; 14546 }; 14547 return;; 14548 }; 14549 ; 14550 /* 15. Files with search/replace patterns: LSP and SSI */; 14551 if (is_template_text_file) {; 14552 HTTP1_only;; 14553 handle_file_based_request(conn, path, &file);; 14554 return;; 14555 }; 14556 ; 14557 /* 16. Static file - maybe cached */; 14558#if !defined(NO_CACHING); 14559 if ((!conn->in_error_handler) && is_not_modified(conn, &file.stat)) {; 14560 /* Send 304 ""Not Modified"" - this must not send any body data */; 14561 handle_not_modified_static_file_request(conn, &file);; 14562 return;; 14563 }; 14564#endif /* !NO_CACHING */; 14565 ; 14566 /* 17. Static file - not cached */; 14567 handle_static_file_request(conn, path, &file, NULL, NULL);; 14568 ; 14569#endif /* !defined(NO_FILES) */; 14570}; 14571 ; 14572 ; 14573#if !defined(NO_FILESYSTEMS); 14574static void; 14575handle_file_based_request(struct mg_connection *conn,; 14576 const c",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:429793,Modifiability,config,config,429793,"return;; 14548 }; 14549 ; 14550 /* 15. Files with search/replace patterns: LSP and SSI */; 14551 if (is_template_text_file) {; 14552 HTTP1_only;; 14553 handle_file_based_request(conn, path, &file);; 14554 return;; 14555 }; 14556 ; 14557 /* 16. Static file - maybe cached */; 14558#if !defined(NO_CACHING); 14559 if ((!conn->in_error_handler) && is_not_modified(conn, &file.stat)) {; 14560 /* Send 304 ""Not Modified"" - this must not send any body data */; 14561 handle_not_modified_static_file_request(conn, &file);; 14562 return;; 14563 }; 14564#endif /* !NO_CACHING */; 14565 ; 14566 /* 17. Static file - not cached */; 14567 handle_static_file_request(conn, path, &file, NULL, NULL);; 14568 ; 14569#endif /* !defined(NO_FILES) */; 14570}; 14571 ; 14572 ; 14573#if !defined(NO_FILESYSTEMS); 14574static void; 14575handle_file_based_request(struct mg_connection *conn,; 14576 const char *path,; 14577 struct mg_file *file); 14578{; 14579#if !defined(NO_CGI); 14580 unsigned char cgi_config_idx, inc, max;; 14581#endif; 14582 ; 14583 if (!conn || !conn->dom_ctx) {; 14584 return;; 14585 }; 14586 ; 14587#if defined(USE_LUA); 14588 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS],; 14589 path); 14590 > 0) {; 14591 if (is_in_script_path(conn, path)) {; 14592 /* Lua server page: an SSI like page containing mostly plain; 14593 * html code plus some tags with server generated contents. */; 14594 handle_lsp_request(conn, path, file, NULL);; 14595 } else {; 14596 /* Script was in an illegal path */; 14597 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14598 }; 14599 return;; 14600 }; 14601 ; 14602 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS], path); 14603 > 0) {; 14604 if (is_in_script_path(conn, path)) {; 14605 /* Lua in-server module script: a CGI like script used to; 14606 * generate the entire reply. */; 14607 mg_exec_lua_script(conn, path, NULL);; 14608 } else {; 14609 /* Script was in an illegal path */; 14610 mg_send_http_error(conn",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:430291,Modifiability,config,config,430291,"tatic_file_request(conn, path, &file, NULL, NULL);; 14568 ; 14569#endif /* !defined(NO_FILES) */; 14570}; 14571 ; 14572 ; 14573#if !defined(NO_FILESYSTEMS); 14574static void; 14575handle_file_based_request(struct mg_connection *conn,; 14576 const char *path,; 14577 struct mg_file *file); 14578{; 14579#if !defined(NO_CGI); 14580 unsigned char cgi_config_idx, inc, max;; 14581#endif; 14582 ; 14583 if (!conn || !conn->dom_ctx) {; 14584 return;; 14585 }; 14586 ; 14587#if defined(USE_LUA); 14588 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS],; 14589 path); 14590 > 0) {; 14591 if (is_in_script_path(conn, path)) {; 14592 /* Lua server page: an SSI like page containing mostly plain; 14593 * html code plus some tags with server generated contents. */; 14594 handle_lsp_request(conn, path, file, NULL);; 14595 } else {; 14596 /* Script was in an illegal path */; 14597 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14598 }; 14599 return;; 14600 }; 14601 ; 14602 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS], path); 14603 > 0) {; 14604 if (is_in_script_path(conn, path)) {; 14605 /* Lua in-server module script: a CGI like script used to; 14606 * generate the entire reply. */; 14607 mg_exec_lua_script(conn, path, NULL);; 14608 } else {; 14609 /* Script was in an illegal path */; 14610 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14611 }; 14612 return;; 14613 }; 14614#endif; 14615 ; 14616#if defined(USE_DUKTAPE); 14617 if (match_prefix_strlen(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],; 14618 path); 14619 > 0) {; 14620 if (is_in_script_path(conn, path)) {; 14621 /* Call duktape to generate the page */; 14622 mg_exec_duktape_script(conn, path);; 14623 } else {; 14624 /* Script was in an illegal path */; 14625 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14626 }; 14627 return;; 14628 }; 14629#endif; 14630 ; 14631#if !defined(NO_CGI); 14632 inc = CGI2_EXTENSIONS - CGI_EXTENSIONS;; 14633 max = PUT_DELETE_PASSWORDS_FILE",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:430782,Modifiability,config,config,430782,,MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:431384,Modifiability,config,config,431384,,MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:431489,Modifiability,config,config,431489,"4607 mg_exec_lua_script(conn, path, NULL);; 14608 } else {; 14609 /* Script was in an illegal path */; 14610 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14611 }; 14612 return;; 14613 }; 14614#endif; 14615 ; 14616#if defined(USE_DUKTAPE); 14617 if (match_prefix_strlen(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],; 14618 path); 14619 > 0) {; 14620 if (is_in_script_path(conn, path)) {; 14621 /* Call duktape to generate the page */; 14622 mg_exec_duktape_script(conn, path);; 14623 } else {; 14624 /* Script was in an illegal path */; 14625 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14626 }; 14627 return;; 14628 }; 14629#endif; 14630 ; 14631#if !defined(NO_CGI); 14632 inc = CGI2_EXTENSIONS - CGI_EXTENSIONS;; 14633 max = PUT_DELETE_PASSWORDS_FILE - CGI_EXTENSIONS;; 14634 for (cgi_config_idx = 0; cgi_config_idx < max; cgi_config_idx += inc) {; 14635 if (conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx] != NULL) {; 14636 if (match_prefix_strlen(; 14637 conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx],; 14638 path); 14639 > 0) {; 14640 if (is_in_script_path(conn, path)) {; 14641 /* CGI scripts may support all HTTP methods */; 14642 handle_cgi_request(conn, path, 0);; 14643 } else {; 14644 /* Script was in an illegal path */; 14645 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14646 }; 14647 return;; 14648 }; 14649 }; 14650 }; 14651#endif /* !NO_CGI */; 14652 ; 14653 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], path) > 0) {; 14654 if (is_in_script_path(conn, path)) {; 14655 handle_ssi_file_request(conn, path, file);; 14656 } else {; 14657 /* Script was in an illegal path */; 14658 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14659 }; 14660 return;; 14661 }; 14662 ; 14663#if !defined(NO_CACHING); 14664 if ((!conn->in_error_handler) && is_not_modified(conn, &file->stat)) {; 14665 /* Send 304 ""Not Modified"" - this must not send any body data */; 14666 handle_not_modified_static_file_request(conn, file);; 14667 return;; 146",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:431945,Modifiability,config,config,431945,"te the page */; 14622 mg_exec_duktape_script(conn, path);; 14623 } else {; 14624 /* Script was in an illegal path */; 14625 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14626 }; 14627 return;; 14628 }; 14629#endif; 14630 ; 14631#if !defined(NO_CGI); 14632 inc = CGI2_EXTENSIONS - CGI_EXTENSIONS;; 14633 max = PUT_DELETE_PASSWORDS_FILE - CGI_EXTENSIONS;; 14634 for (cgi_config_idx = 0; cgi_config_idx < max; cgi_config_idx += inc) {; 14635 if (conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx] != NULL) {; 14636 if (match_prefix_strlen(; 14637 conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx],; 14638 path); 14639 > 0) {; 14640 if (is_in_script_path(conn, path)) {; 14641 /* CGI scripts may support all HTTP methods */; 14642 handle_cgi_request(conn, path, 0);; 14643 } else {; 14644 /* Script was in an illegal path */; 14645 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14646 }; 14647 return;; 14648 }; 14649 }; 14650 }; 14651#endif /* !NO_CGI */; 14652 ; 14653 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], path) > 0) {; 14654 if (is_in_script_path(conn, path)) {; 14655 handle_ssi_file_request(conn, path, file);; 14656 } else {; 14657 /* Script was in an illegal path */; 14658 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14659 }; 14660 return;; 14661 }; 14662 ; 14663#if !defined(NO_CACHING); 14664 if ((!conn->in_error_handler) && is_not_modified(conn, &file->stat)) {; 14665 /* Send 304 ""Not Modified"" - this must not send any body data */; 14666 handle_not_modified_static_file_request(conn, file);; 14667 return;; 14668 }; 14669#endif /* !NO_CACHING */; 14670 ; 14671 handle_static_file_request(conn, path, file, NULL, NULL);; 14672}; 14673#endif /* NO_FILESYSTEMS */; 14674 ; 14675 ; 14676static void; 14677close_all_listening_sockets(struct mg_context *ctx); 14678{; 14679 unsigned int i;; 14680 if (!ctx) {; 14681 return;; 14682 }; 14683 ; 14684 for (i = 0; i < ctx->num_listening_sockets; i++) {; 14685 closesocket(ctx->listening_sockets[i].",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:443498,Modifiability,config,config,443498," 'r')) {; 14943 return 1;; 14944 }; 14945 if (ports[i] >= '0' && ports[i] <= '9') {; 14946 prevIsNumber = 1;; 14947 } else {; 14948 prevIsNumber = 0;; 14949 }; 14950 }; 14951 }; 14952 return 0;; 14953}; 14954 ; 14955 ; 14956static int; 14957set_ports_option(struct mg_context *phys_ctx); 14958{; 14959 const char *list;; 14960 int on = 1;; 14961#if defined(USE_IPV6); 14962 int off = 0;; 14963#endif; 14964 struct vec vec;; 14965 struct socket so, *ptr;; 14966 ; 14967 struct mg_pollfd *pfd;; 14968 union usa usa;; 14969 socklen_t len;; 14970 int ip_version;; 14971 ; 14972 int portsTotal = 0;; 14973 int portsOk = 0;; 14974 ; 14975 const char *opt_txt;; 14976 long opt_listen_backlog;; 14977 ; 14978 if (!phys_ctx) {; 14979 return 0;; 14980 }; 14981 ; 14982 memset(&so, 0, sizeof(so));; 14983 memset(&usa, 0, sizeof(usa));; 14984 len = sizeof(usa);; 14985 list = phys_ctx->dd.config[LISTENING_PORTS];; 14986 ; 14987 while ((list = next_option(list, &vec, NULL)) != NULL) {; 14988 ; 14989 portsTotal++;; 14990 ; 14991 if (!parse_port_string(&vec, &so, &ip_version)) {; 14992 mg_cry_ctx_internal(; 14993 phys_ctx,; 14994 ""%.*s: invalid port spec (entry %i). Expecting list of: %s"",; 14995 (int)vec.len,; 14996 vec.ptr,; 14997 portsTotal,; 14998 ""[IP_ADDRESS:]PORT[s|r]"");; 14999 continue;; 15000 }; 15001 ; 15002#if !defined(NO_SSL); 15003 if (so.is_ssl && phys_ctx->dd.ssl_ctx == NULL) {; 15004 ; 15005 mg_cry_ctx_internal(phys_ctx,; 15006 ""Cannot add SSL socket (entry %i)"",; 15007 portsTotal);; 15008 continue;; 15009 }; 15010#endif; 15011 /* Create socket. */; 15012 /* For a list of protocol numbers (e.g., TCP==6) see:; 15013 * https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml; 15014 */; 15015 if ((so.sock =; 15016 socket(so.lsa.sa.sa_family,; 15017 SOCK_STREAM,; 15018 (ip_version == 99) ? (/* LOCAL */ 0) : (/* TCP */ 6))); 15019 == INVALID_SOCKET) {; 15020 ; 15021 mg_cry_ctx_internal(phys_ctx,; 15022 ""cannot create socket (entry %i)"",; 15023 portsTotal);; 15024 con",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:448592,Modifiability,config,config,448592,"38 (int)ERRNO,; 15139 strerror(errno));; 15140 closesocket(so.sock);; 15141 so.sock = INVALID_SOCKET;; 15142 continue;; 15143 }; 15144 }; 15145#endif; 15146#if defined(USE_X_DOM_SOCKET); 15147 else if (so.lsa.sa.sa_family == AF_UNIX) {; 15148 ; 15149 len = sizeof(so.lsa.sun);; 15150 if (bind(so.sock, &so.lsa.sa, len) != 0) {; 15151 mg_cry_ctx_internal(phys_ctx,; 15152 ""cannot bind to unix socket %s: %d (%s)"",; 15153 so.lsa.sun.sun_path,; 15154 (int)ERRNO,; 15155 strerror(errno));; 15156 closesocket(so.sock);; 15157 so.sock = INVALID_SOCKET;; 15158 continue;; 15159 }; 15160 }; 15161#endif; 15162 else {; 15163 mg_cry_ctx_internal(; 15164 phys_ctx,; 15165 ""cannot bind: address family not supported (entry %i)"",; 15166 portsTotal);; 15167 closesocket(so.sock);; 15168 so.sock = INVALID_SOCKET;; 15169 continue;; 15170 }; 15171 ; 15172 opt_txt = phys_ctx->dd.config[LISTEN_BACKLOG_SIZE];; 15173 opt_listen_backlog = strtol(opt_txt, NULL, 10);; 15174 if ((opt_listen_backlog > INT_MAX) || (opt_listen_backlog < 1)) {; 15175 mg_cry_ctx_internal(phys_ctx,; 15176 ""%s value \""%s\"" is invalid"",; 15177 config_options[LISTEN_BACKLOG_SIZE].name,; 15178 opt_txt);; 15179 closesocket(so.sock);; 15180 so.sock = INVALID_SOCKET;; 15181 continue;; 15182 }; 15183 ; 15184 if (listen(so.sock, (int)opt_listen_backlog) != 0) {; 15185 ; 15186 mg_cry_ctx_internal(phys_ctx,; 15187 ""cannot listen to %.*s: %d (%s)"",; 15188 (int)vec.len,; 15189 vec.ptr,; 15190 (int)ERRNO,; 15191 strerror(errno));; 15192 closesocket(so.sock);; 15193 so.sock = INVALID_SOCKET;; 15194 continue;; 15195 }; 15196 ; 15197 if ((getsockname(so.sock, &(usa.sa), &len) != 0); 15198 || (usa.sa.sa_family != so.lsa.sa.sa_family)) {; 15199 ; 15200 int err = (int)ERRNO;; 15201 mg_cry_ctx_internal(phys_ctx,; 15202 ""call to getsockname failed %.*s: %d (%s)"",; 15203 (int)vec.len,; 15204 vec.ptr,; 15205 err,; 15206 strerror(errno));; 15207 closesocket(so.sock);; 15208 so.sock = INVALID_SOCKET;; 15209 continue;; 15210 }; 15211 ; 15212 /* Updat",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:453636,Modifiability,config,config,453636,"; 15287 struct mg_file fi;; 15288 char date[64], src_addr[IP_ADDR_STR_LEN];; 15289 struct tm *tm;; 15290 ; 15291 const char *referer;; 15292 const char *user_agent;; 15293 ; 15294 char log_buf[4096];; 15295 ; 15296 if (!conn || !conn->dom_ctx) {; 15297 return;; 15298 }; 15299 ; 15300 /* Set log message to ""empty"" */; 15301 log_buf[0] = 0;; 15302 ; 15303#if defined(USE_LUA); 15304 if (conn->phys_ctx->lua_bg_log_available) {; 15305 int ret;; 15306 struct mg_context *ctx = conn->phys_ctx;; 15307 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 15308 pthread_mutex_lock(&ctx->lua_bg_mutex);; 15309 /* call ""log()"" in Lua */; 15310 lua_getglobal(lstate, ""log"");; 15311 prepare_lua_request_info_inner(conn, lstate);; 15312 push_lua_response_log_data(conn, lstate);; 15313 ; 15314 ret = lua_pcall(lstate, /* args */ 2, /* results */ 1, 0);; 15315 if (ret == 0) {; 15316 int t = lua_type(lstate, -1);; 15317 if (t == LUA_TBOOLEAN) {; 15318 if (lua_toboolean(lstate, -1) == 0) {; 15319 /* log() returned false: do not log */; 15320 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15321 return;; 15322 }; 15323 /* log returned true: continue logging */; 15324 } else if (t == LUA_TSTRING) {; 15325 size_t len;; 15326 const char *txt = lua_tolstring(lstate, -1, &len);; 15327 if ((len == 0) || (*txt == 0)) {; 15328 /* log() returned empty string: do not log */; 15329 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15330 return;; 15331 }; 15332 /* Copy test from Lua into log_buf */; 15333 if (len >= sizeof(log_buf)) {; 15334 len = sizeof(log_buf) - 1;; 15335 }; 15336 memcpy(log_buf, txt, len);; 15337 log_buf[len] = 0;; 15338 }; 15339 } else {; 15340 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15341 }; 15342 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15343 }; 15344#endif; 15345 ; 15346 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15347 if (mg_fopen(conn,; 15348 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15349 MG_FOPEN_MODE_APPEND,; 15350 &fi); 15351 == 0) {; 15352 fi.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:453719,Modifiability,config,config,453719,"; 15287 struct mg_file fi;; 15288 char date[64], src_addr[IP_ADDR_STR_LEN];; 15289 struct tm *tm;; 15290 ; 15291 const char *referer;; 15292 const char *user_agent;; 15293 ; 15294 char log_buf[4096];; 15295 ; 15296 if (!conn || !conn->dom_ctx) {; 15297 return;; 15298 }; 15299 ; 15300 /* Set log message to ""empty"" */; 15301 log_buf[0] = 0;; 15302 ; 15303#if defined(USE_LUA); 15304 if (conn->phys_ctx->lua_bg_log_available) {; 15305 int ret;; 15306 struct mg_context *ctx = conn->phys_ctx;; 15307 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 15308 pthread_mutex_lock(&ctx->lua_bg_mutex);; 15309 /* call ""log()"" in Lua */; 15310 lua_getglobal(lstate, ""log"");; 15311 prepare_lua_request_info_inner(conn, lstate);; 15312 push_lua_response_log_data(conn, lstate);; 15313 ; 15314 ret = lua_pcall(lstate, /* args */ 2, /* results */ 1, 0);; 15315 if (ret == 0) {; 15316 int t = lua_type(lstate, -1);; 15317 if (t == LUA_TBOOLEAN) {; 15318 if (lua_toboolean(lstate, -1) == 0) {; 15319 /* log() returned false: do not log */; 15320 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15321 return;; 15322 }; 15323 /* log returned true: continue logging */; 15324 } else if (t == LUA_TSTRING) {; 15325 size_t len;; 15326 const char *txt = lua_tolstring(lstate, -1, &len);; 15327 if ((len == 0) || (*txt == 0)) {; 15328 /* log() returned empty string: do not log */; 15329 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15330 return;; 15331 }; 15332 /* Copy test from Lua into log_buf */; 15333 if (len >= sizeof(log_buf)) {; 15334 len = sizeof(log_buf) - 1;; 15335 }; 15336 memcpy(log_buf, txt, len);; 15337 log_buf[len] = 0;; 15338 }; 15339 } else {; 15340 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15341 }; 15342 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15343 }; 15344#endif; 15345 ; 15346 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15347 if (mg_fopen(conn,; 15348 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15349 MG_FOPEN_MODE_APPEND,; 15350 &fi); 15351 == 0) {; 15352 fi.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:456155,Modifiability,config,config,456155,": """",; 15394 ri->http_version,; 15395 conn->status_code,; 15396 conn->num_bytes_sent,; 15397 referer,; 15398 user_agent);; 15399 }; 15400 ; 15401 /* Here we have a log message in log_buf. Call the callback */; 15402 if (conn->phys_ctx->callbacks.log_access) {; 15403 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15404 /* do not log if callack returns non-zero */; 15405 if (fi.access.fp) {; 15406 mg_fclose(&fi.access);; 15407 }; 15408 return;; 15409 }; 15410 }; 15411 ; 15412 /* Store in file */; 15413 if (fi.access.fp) {; 15414 int ok = 1;; 15415 flockfile(fi.access.fp);; 15416 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15417 ok = 0;; 15418 }; 15419 if (fflush(fi.access.fp) != 0) {; 15420 ok = 0;; 15421 }; 15422 funlockfile(fi.access.fp);; 15423 if (mg_fclose(&fi.access) != 0) {; 15424 ok = 0;; 15425 }; 15426 if (!ok) {; 15427 mg_cry_internal(conn,; 15428 ""Error writing log file %s"",; 15429 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15430 }; 15431 }; 15432}; 15433#else; 15434#error ""Either enable filesystems or provide a custom log_access implementation""; 15435#endif /* Externally provided function */; 15436 ; 15437 ; 15438/* Verify given socket address against the ACL.; 15439 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15440 */; 15441static int; 15442check_acl(struct mg_context *phys_ctx, const union usa *sa); 15443{; 15444 int allowed, flag, matched;; 15445 struct vec vec;; 15446 ; 15447 if (phys_ctx) {; 15448 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15449 ; 15450 /* If any ACL is set, deny by default */; 15451 allowed = (list == NULL) ? '+' : '-';; 15452 ; 15453 while ((list = next_option(list, &vec, NULL)) != NULL) {; 15454 flag = vec.ptr[0];; 15455 matched = -1;; 15456 if ((vec.len > 0) && ((flag == '+') || (flag == '-'))) {; 15457 vec.ptr++;; 15458 vec.len--;; 15459 matched = parse_match_net(&vec, sa, 1);; 15460 }; 15461 if (matched < 0) {; 15462 mg_cry_ctx_internal(phys_ctx,; 15463 ""%s: su",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:456735,Modifiability,config,config,456735,", log_buf) < 1) {; 15417 ok = 0;; 15418 }; 15419 if (fflush(fi.access.fp) != 0) {; 15420 ok = 0;; 15421 }; 15422 funlockfile(fi.access.fp);; 15423 if (mg_fclose(&fi.access) != 0) {; 15424 ok = 0;; 15425 }; 15426 if (!ok) {; 15427 mg_cry_internal(conn,; 15428 ""Error writing log file %s"",; 15429 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15430 }; 15431 }; 15432}; 15433#else; 15434#error ""Either enable filesystems or provide a custom log_access implementation""; 15435#endif /* Externally provided function */; 15436 ; 15437 ; 15438/* Verify given socket address against the ACL.; 15439 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15440 */; 15441static int; 15442check_acl(struct mg_context *phys_ctx, const union usa *sa); 15443{; 15444 int allowed, flag, matched;; 15445 struct vec vec;; 15446 ; 15447 if (phys_ctx) {; 15448 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15449 ; 15450 /* If any ACL is set, deny by default */; 15451 allowed = (list == NULL) ? '+' : '-';; 15452 ; 15453 while ((list = next_option(list, &vec, NULL)) != NULL) {; 15454 flag = vec.ptr[0];; 15455 matched = -1;; 15456 if ((vec.len > 0) && ((flag == '+') || (flag == '-'))) {; 15457 vec.ptr++;; 15458 vec.len--;; 15459 matched = parse_match_net(&vec, sa, 1);; 15460 }; 15461 if (matched < 0) {; 15462 mg_cry_ctx_internal(phys_ctx,; 15463 ""%s: subnet must be [+|-]IP-addr[/x]"",; 15464 __func__);; 15465 return -1;; 15466 }; 15467 if (matched) {; 15468 allowed = flag;; 15469 }; 15470 }; 15471 ; 15472 return allowed == '+';; 15473 }; 15474 return -1;; 15475}; 15476 ; 15477 ; 15478#if !defined(_WIN32) && !defined(__ZEPHYR__); 15479static int; 15480set_uid_option(struct mg_context *phys_ctx); 15481{; 15482 int success = 0;; 15483 ; 15484 if (phys_ctx) {; 15485 /* We are currently running as curr_uid. */; 15486 const uid_t curr_uid = getuid();; 15487 /* If set, we want to run as run_as_user. */; 15488 const char *run_as_user = phys_ctx->dd.config[RUN_AS_USER];; 15489 c",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:457816,Modifiability,config,config,457816,"c, NULL)) != NULL) {; 15454 flag = vec.ptr[0];; 15455 matched = -1;; 15456 if ((vec.len > 0) && ((flag == '+') || (flag == '-'))) {; 15457 vec.ptr++;; 15458 vec.len--;; 15459 matched = parse_match_net(&vec, sa, 1);; 15460 }; 15461 if (matched < 0) {; 15462 mg_cry_ctx_internal(phys_ctx,; 15463 ""%s: subnet must be [+|-]IP-addr[/x]"",; 15464 __func__);; 15465 return -1;; 15466 }; 15467 if (matched) {; 15468 allowed = flag;; 15469 }; 15470 }; 15471 ; 15472 return allowed == '+';; 15473 }; 15474 return -1;; 15475}; 15476 ; 15477 ; 15478#if !defined(_WIN32) && !defined(__ZEPHYR__); 15479static int; 15480set_uid_option(struct mg_context *phys_ctx); 15481{; 15482 int success = 0;; 15483 ; 15484 if (phys_ctx) {; 15485 /* We are currently running as curr_uid. */; 15486 const uid_t curr_uid = getuid();; 15487 /* If set, we want to run as run_as_user. */; 15488 const char *run_as_user = phys_ctx->dd.config[RUN_AS_USER];; 15489 const struct passwd *to_pw = NULL;; 15490 ; 15491 if ((run_as_user != NULL) && (to_pw = getpwnam(run_as_user)) == NULL) {; 15492 /* run_as_user does not exist on the system. We can't proceed; 15493 * further. */; 15494 mg_cry_ctx_internal(phys_ctx,; 15495 ""%s: unknown user [%s]"",; 15496 __func__,; 15497 run_as_user);; 15498 } else if ((run_as_user == NULL) || (curr_uid == to_pw->pw_uid)) {; 15499 /* There was either no request to change user, or we're already; 15500 * running as run_as_user. Nothing else to do.; 15501 */; 15502 success = 1;; 15503 } else {; 15504 /* Valid change request. */; 15505 if (setgid(to_pw->pw_gid) == -1) {; 15506 mg_cry_ctx_internal(phys_ctx,; 15507 ""%s: setgid(%s): %s"",; 15508 __func__,; 15509 run_as_user,; 15510 strerror(errno));; 15511 } else if (setgroups(0, NULL) == -1) {; 15512 mg_cry_ctx_internal(phys_ctx,; 15513 ""%s: setgroups(): %s"",; 15514 __func__,; 15515 strerror(errno));; 15516 } else if (setuid(to_pw->pw_uid) == -1) {; 15517 mg_cry_ctx_internal(phys_ctx,; 15518 ""%s: setuid(%s): %s"",; 15519 __func__,; 15520 run_as_user",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:459867,Modifiability,config,config,459867,"rror(errno));; 15516 } else if (setuid(to_pw->pw_uid) == -1) {; 15517 mg_cry_ctx_internal(phys_ctx,; 15518 ""%s: setuid(%s): %s"",; 15519 __func__,; 15520 run_as_user,; 15521 strerror(errno));; 15522 } else {; 15523 success = 1;; 15524 }; 15525 }; 15526 }; 15527 ; 15528 return success;; 15529}; 15530#endif /* !_WIN32 */; 15531 ; 15532 ; 15533static void; 15534tls_dtor(void *key); 15535{; 15536 struct mg_workerTLS *tls = (struct mg_workerTLS *)key;; 15537 /* key == pthread_getspecific(sTlsKey); */; 15538 ; 15539 if (tls) {; 15540 if (tls->is_master == 2) {; 15541 tls->is_master = -3; /* Mark memory as dead */; 15542 mg_free(tls);; 15543 }; 15544 }; 15545 pthread_setspecific(sTlsKey, NULL);; 15546}; 15547 ; 15548 ; 15549#if defined(USE_MBEDTLS); 15550/* Check if SSL is required.; 15551 * If so, set up ctx->ssl_ctx pointer. */; 15552static int; 15553mg_sslctx_init(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx); 15554{; 15555 if (!phys_ctx) {; 15556 return 0;; 15557 }; 15558 ; 15559 if (!dom_ctx) {; 15560 dom_ctx = &(phys_ctx->dd);; 15561 }; 15562 ; 15563 if (!is_ssl_port_used(dom_ctx->config[LISTENING_PORTS])) {; 15564 /* No SSL port is set. No need to setup SSL. */; 15565 return 1;; 15566 }; 15567 ; 15568 dom_ctx->ssl_ctx = (SSL_CTX *)mg_calloc(1, sizeof(*dom_ctx->ssl_ctx));; 15569 if (dom_ctx->ssl_ctx == NULL) {; 15570 fprintf(stderr, ""ssl_ctx malloc failed\n"");; 15571 return 0;; 15572 }; 15573 ; 15574 return mbed_sslctx_init(dom_ctx->ssl_ctx, dom_ctx->config[SSL_CERTIFICATE]); 15575 == 0; 15576 ? 1; 15577 : 0;; 15578}; 15579 ; 15580#elif !defined(NO_SSL); 15581 ; 15582static int ssl_use_pem_file(struct mg_context *phys_ctx,; 15583 struct mg_domain_context *dom_ctx,; 15584 const char *pem,; 15585 const char *chain);; 15586static const char *ssl_error(void);; 15587 ; 15588 ; 15589static int; 15590refresh_trust(struct mg_connection *conn); 15591{; 15592 struct stat cert_buf;; 15593 int64_t t = 0;; 15594 const char *pem;; 15595 const char *chain;; 15596 in",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:460244,Modifiability,config,config,460244,"cific(sTlsKey, NULL);; 15546}; 15547 ; 15548 ; 15549#if defined(USE_MBEDTLS); 15550/* Check if SSL is required.; 15551 * If so, set up ctx->ssl_ctx pointer. */; 15552static int; 15553mg_sslctx_init(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx); 15554{; 15555 if (!phys_ctx) {; 15556 return 0;; 15557 }; 15558 ; 15559 if (!dom_ctx) {; 15560 dom_ctx = &(phys_ctx->dd);; 15561 }; 15562 ; 15563 if (!is_ssl_port_used(dom_ctx->config[LISTENING_PORTS])) {; 15564 /* No SSL port is set. No need to setup SSL. */; 15565 return 1;; 15566 }; 15567 ; 15568 dom_ctx->ssl_ctx = (SSL_CTX *)mg_calloc(1, sizeof(*dom_ctx->ssl_ctx));; 15569 if (dom_ctx->ssl_ctx == NULL) {; 15570 fprintf(stderr, ""ssl_ctx malloc failed\n"");; 15571 return 0;; 15572 }; 15573 ; 15574 return mbed_sslctx_init(dom_ctx->ssl_ctx, dom_ctx->config[SSL_CERTIFICATE]); 15575 == 0; 15576 ? 1; 15577 : 0;; 15578}; 15579 ; 15580#elif !defined(NO_SSL); 15581 ; 15582static int ssl_use_pem_file(struct mg_context *phys_ctx,; 15583 struct mg_domain_context *dom_ctx,; 15584 const char *pem,; 15585 const char *chain);; 15586static const char *ssl_error(void);; 15587 ; 15588 ; 15589static int; 15590refresh_trust(struct mg_connection *conn); 15591{; 15592 struct stat cert_buf;; 15593 int64_t t = 0;; 15594 const char *pem;; 15595 const char *chain;; 15596 int should_verify_peer;; 15597 ; 15598 if ((pem = conn->dom_ctx->config[SSL_CERTIFICATE]) == NULL) {; 15599 /* If pem is NULL and conn->phys_ctx->callbacks.init_ssl is not,; 15600 * refresh_trust still can not work. */; 15601 return 0;; 15602 }; 15603 chain = conn->dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 15604 if (chain == NULL) {; 15605 /* pem is not NULL here */; 15606 chain = pem;; 15607 }; 15608 if (*chain == 0) {; 15609 chain = NULL;; 15610 }; 15611 ; 15612 if (stat(pem, &cert_buf) != -1) {; 15613 t = (int64_t)cert_buf.st_mtime;; 15614 }; 15615 ; 15616 mg_lock_context(conn->phys_ctx);; 15617 if ((t != 0) && (conn->dom_ctx->ssl_cert_last_mtime != t)) {; 15618 co",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:460817,Modifiability,config,config,460817,"cific(sTlsKey, NULL);; 15546}; 15547 ; 15548 ; 15549#if defined(USE_MBEDTLS); 15550/* Check if SSL is required.; 15551 * If so, set up ctx->ssl_ctx pointer. */; 15552static int; 15553mg_sslctx_init(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx); 15554{; 15555 if (!phys_ctx) {; 15556 return 0;; 15557 }; 15558 ; 15559 if (!dom_ctx) {; 15560 dom_ctx = &(phys_ctx->dd);; 15561 }; 15562 ; 15563 if (!is_ssl_port_used(dom_ctx->config[LISTENING_PORTS])) {; 15564 /* No SSL port is set. No need to setup SSL. */; 15565 return 1;; 15566 }; 15567 ; 15568 dom_ctx->ssl_ctx = (SSL_CTX *)mg_calloc(1, sizeof(*dom_ctx->ssl_ctx));; 15569 if (dom_ctx->ssl_ctx == NULL) {; 15570 fprintf(stderr, ""ssl_ctx malloc failed\n"");; 15571 return 0;; 15572 }; 15573 ; 15574 return mbed_sslctx_init(dom_ctx->ssl_ctx, dom_ctx->config[SSL_CERTIFICATE]); 15575 == 0; 15576 ? 1; 15577 : 0;; 15578}; 15579 ; 15580#elif !defined(NO_SSL); 15581 ; 15582static int ssl_use_pem_file(struct mg_context *phys_ctx,; 15583 struct mg_domain_context *dom_ctx,; 15584 const char *pem,; 15585 const char *chain);; 15586static const char *ssl_error(void);; 15587 ; 15588 ; 15589static int; 15590refresh_trust(struct mg_connection *conn); 15591{; 15592 struct stat cert_buf;; 15593 int64_t t = 0;; 15594 const char *pem;; 15595 const char *chain;; 15596 int should_verify_peer;; 15597 ; 15598 if ((pem = conn->dom_ctx->config[SSL_CERTIFICATE]) == NULL) {; 15599 /* If pem is NULL and conn->phys_ctx->callbacks.init_ssl is not,; 15600 * refresh_trust still can not work. */; 15601 return 0;; 15602 }; 15603 chain = conn->dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 15604 if (chain == NULL) {; 15605 /* pem is not NULL here */; 15606 chain = pem;; 15607 }; 15608 if (*chain == 0) {; 15609 chain = NULL;; 15610 }; 15611 ; 15612 if (stat(pem, &cert_buf) != -1) {; 15613 t = (int64_t)cert_buf.st_mtime;; 15614 }; 15615 ; 15616 mg_lock_context(conn->phys_ctx);; 15617 if ((t != 0) && (conn->dom_ctx->ssl_cert_last_mtime != t)) {; 15618 co",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:461027,Modifiability,config,config,461027,"ssl_ctx malloc failed\n"");; 15571 return 0;; 15572 }; 15573 ; 15574 return mbed_sslctx_init(dom_ctx->ssl_ctx, dom_ctx->config[SSL_CERTIFICATE]); 15575 == 0; 15576 ? 1; 15577 : 0;; 15578}; 15579 ; 15580#elif !defined(NO_SSL); 15581 ; 15582static int ssl_use_pem_file(struct mg_context *phys_ctx,; 15583 struct mg_domain_context *dom_ctx,; 15584 const char *pem,; 15585 const char *chain);; 15586static const char *ssl_error(void);; 15587 ; 15588 ; 15589static int; 15590refresh_trust(struct mg_connection *conn); 15591{; 15592 struct stat cert_buf;; 15593 int64_t t = 0;; 15594 const char *pem;; 15595 const char *chain;; 15596 int should_verify_peer;; 15597 ; 15598 if ((pem = conn->dom_ctx->config[SSL_CERTIFICATE]) == NULL) {; 15599 /* If pem is NULL and conn->phys_ctx->callbacks.init_ssl is not,; 15600 * refresh_trust still can not work. */; 15601 return 0;; 15602 }; 15603 chain = conn->dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 15604 if (chain == NULL) {; 15605 /* pem is not NULL here */; 15606 chain = pem;; 15607 }; 15608 if (*chain == 0) {; 15609 chain = NULL;; 15610 }; 15611 ; 15612 if (stat(pem, &cert_buf) != -1) {; 15613 t = (int64_t)cert_buf.st_mtime;; 15614 }; 15615 ; 15616 mg_lock_context(conn->phys_ctx);; 15617 if ((t != 0) && (conn->dom_ctx->ssl_cert_last_mtime != t)) {; 15618 conn->dom_ctx->ssl_cert_last_mtime = t;; 15619 ; 15620 should_verify_peer = 0;; 15621 if (conn->dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 15622 if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes""); 15623 == 0) {; 15624 should_verify_peer = 1;; 15625 } else if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER],; 15626 ""optional""); 15627 == 0) {; 15628 should_verify_peer = 1;; 15629 }; 15630 }; 15631 ; 15632 if (should_verify_peer) {; 15633 char *ca_path = conn->dom_ctx->config[SSL_CA_PATH];; 15634 char *ca_file = conn->dom_ctx->config[SSL_CA_FILE];; 15635 if (SSL_CTX_load_verify_locations(conn->dom_ctx->ssl_ctx,; 15636 ca_file,; 15637 ca_path); 15638 != 1) {; 15639 ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:461530,Modifiability,config,config,461530,"x->config[SSL_CERTIFICATE]) == NULL) {; 15599 /* If pem is NULL and conn->phys_ctx->callbacks.init_ssl is not,; 15600 * refresh_trust still can not work. */; 15601 return 0;; 15602 }; 15603 chain = conn->dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 15604 if (chain == NULL) {; 15605 /* pem is not NULL here */; 15606 chain = pem;; 15607 }; 15608 if (*chain == 0) {; 15609 chain = NULL;; 15610 }; 15611 ; 15612 if (stat(pem, &cert_buf) != -1) {; 15613 t = (int64_t)cert_buf.st_mtime;; 15614 }; 15615 ; 15616 mg_lock_context(conn->phys_ctx);; 15617 if ((t != 0) && (conn->dom_ctx->ssl_cert_last_mtime != t)) {; 15618 conn->dom_ctx->ssl_cert_last_mtime = t;; 15619 ; 15620 should_verify_peer = 0;; 15621 if (conn->dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 15622 if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes""); 15623 == 0) {; 15624 should_verify_peer = 1;; 15625 } else if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER],; 15626 ""optional""); 15627 == 0) {; 15628 should_verify_peer = 1;; 15629 }; 15630 }; 15631 ; 15632 if (should_verify_peer) {; 15633 char *ca_path = conn->dom_ctx->config[SSL_CA_PATH];; 15634 char *ca_file = conn->dom_ctx->config[SSL_CA_FILE];; 15635 if (SSL_CTX_load_verify_locations(conn->dom_ctx->ssl_ctx,; 15636 ca_file,; 15637 ca_path); 15638 != 1) {; 15639 mg_unlock_context(conn->phys_ctx);; 15640 mg_cry_ctx_internal(; 15641 conn->phys_ctx,; 15642 ""SSL_CTX_load_verify_locations error: %s ""; 15643 ""ssl_verify_peer requires setting ""; 15644 ""either ssl_ca_path or ssl_ca_file. Is any of them ""; 15645 ""present in ""; 15646 ""the .conf file?"",; 15647 ssl_error());; 15648 return 0;; 15649 }; 15650 }; 15651 ; 15652 if (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain) == 0) {; 15653 mg_unlock_context(conn->phys_ctx);; 15654 return 0;; 15655 }; 15656 }; 15657 mg_unlock_context(conn->phys_ctx);; 15658 ; 15659 return 1;; 15660}; 15661 ; 15662#if defined(OPENSSL_API_1_1); 15663#else; 15664static pthread_mutex_t *ssl_mutexes;; 15665#endi",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:461608,Modifiability,config,config,461608,"x->config[SSL_CERTIFICATE]) == NULL) {; 15599 /* If pem is NULL and conn->phys_ctx->callbacks.init_ssl is not,; 15600 * refresh_trust still can not work. */; 15601 return 0;; 15602 }; 15603 chain = conn->dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 15604 if (chain == NULL) {; 15605 /* pem is not NULL here */; 15606 chain = pem;; 15607 }; 15608 if (*chain == 0) {; 15609 chain = NULL;; 15610 }; 15611 ; 15612 if (stat(pem, &cert_buf) != -1) {; 15613 t = (int64_t)cert_buf.st_mtime;; 15614 }; 15615 ; 15616 mg_lock_context(conn->phys_ctx);; 15617 if ((t != 0) && (conn->dom_ctx->ssl_cert_last_mtime != t)) {; 15618 conn->dom_ctx->ssl_cert_last_mtime = t;; 15619 ; 15620 should_verify_peer = 0;; 15621 if (conn->dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 15622 if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes""); 15623 == 0) {; 15624 should_verify_peer = 1;; 15625 } else if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER],; 15626 ""optional""); 15627 == 0) {; 15628 should_verify_peer = 1;; 15629 }; 15630 }; 15631 ; 15632 if (should_verify_peer) {; 15633 char *ca_path = conn->dom_ctx->config[SSL_CA_PATH];; 15634 char *ca_file = conn->dom_ctx->config[SSL_CA_FILE];; 15635 if (SSL_CTX_load_verify_locations(conn->dom_ctx->ssl_ctx,; 15636 ca_file,; 15637 ca_path); 15638 != 1) {; 15639 mg_unlock_context(conn->phys_ctx);; 15640 mg_cry_ctx_internal(; 15641 conn->phys_ctx,; 15642 ""SSL_CTX_load_verify_locations error: %s ""; 15643 ""ssl_verify_peer requires setting ""; 15644 ""either ssl_ca_path or ssl_ca_file. Is any of them ""; 15645 ""present in ""; 15646 ""the .conf file?"",; 15647 ssl_error());; 15648 return 0;; 15649 }; 15650 }; 15651 ; 15652 if (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain) == 0) {; 15653 mg_unlock_context(conn->phys_ctx);; 15654 return 0;; 15655 }; 15656 }; 15657 mg_unlock_context(conn->phys_ctx);; 15658 ; 15659 return 1;; 15660}; 15661 ; 15662#if defined(OPENSSL_API_1_1); 15663#else; 15664static pthread_mutex_t *ssl_mutexes;; 15665#endi",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:461736,Modifiability,config,config,461736,"x->config[SSL_CERTIFICATE]) == NULL) {; 15599 /* If pem is NULL and conn->phys_ctx->callbacks.init_ssl is not,; 15600 * refresh_trust still can not work. */; 15601 return 0;; 15602 }; 15603 chain = conn->dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 15604 if (chain == NULL) {; 15605 /* pem is not NULL here */; 15606 chain = pem;; 15607 }; 15608 if (*chain == 0) {; 15609 chain = NULL;; 15610 }; 15611 ; 15612 if (stat(pem, &cert_buf) != -1) {; 15613 t = (int64_t)cert_buf.st_mtime;; 15614 }; 15615 ; 15616 mg_lock_context(conn->phys_ctx);; 15617 if ((t != 0) && (conn->dom_ctx->ssl_cert_last_mtime != t)) {; 15618 conn->dom_ctx->ssl_cert_last_mtime = t;; 15619 ; 15620 should_verify_peer = 0;; 15621 if (conn->dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 15622 if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes""); 15623 == 0) {; 15624 should_verify_peer = 1;; 15625 } else if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER],; 15626 ""optional""); 15627 == 0) {; 15628 should_verify_peer = 1;; 15629 }; 15630 }; 15631 ; 15632 if (should_verify_peer) {; 15633 char *ca_path = conn->dom_ctx->config[SSL_CA_PATH];; 15634 char *ca_file = conn->dom_ctx->config[SSL_CA_FILE];; 15635 if (SSL_CTX_load_verify_locations(conn->dom_ctx->ssl_ctx,; 15636 ca_file,; 15637 ca_path); 15638 != 1) {; 15639 mg_unlock_context(conn->phys_ctx);; 15640 mg_cry_ctx_internal(; 15641 conn->phys_ctx,; 15642 ""SSL_CTX_load_verify_locations error: %s ""; 15643 ""ssl_verify_peer requires setting ""; 15644 ""either ssl_ca_path or ssl_ca_file. Is any of them ""; 15645 ""present in ""; 15646 ""the .conf file?"",; 15647 ssl_error());; 15648 return 0;; 15649 }; 15650 }; 15651 ; 15652 if (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain) == 0) {; 15653 mg_unlock_context(conn->phys_ctx);; 15654 return 0;; 15655 }; 15656 }; 15657 mg_unlock_context(conn->phys_ctx);; 15658 ; 15659 return 1;; 15660}; 15661 ; 15662#if defined(OPENSSL_API_1_1); 15663#else; 15664static pthread_mutex_t *ssl_mutexes;; 15665#endi",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:461926,Modifiability,config,config,461926,"x->config[SSL_CERTIFICATE]) == NULL) {; 15599 /* If pem is NULL and conn->phys_ctx->callbacks.init_ssl is not,; 15600 * refresh_trust still can not work. */; 15601 return 0;; 15602 }; 15603 chain = conn->dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 15604 if (chain == NULL) {; 15605 /* pem is not NULL here */; 15606 chain = pem;; 15607 }; 15608 if (*chain == 0) {; 15609 chain = NULL;; 15610 }; 15611 ; 15612 if (stat(pem, &cert_buf) != -1) {; 15613 t = (int64_t)cert_buf.st_mtime;; 15614 }; 15615 ; 15616 mg_lock_context(conn->phys_ctx);; 15617 if ((t != 0) && (conn->dom_ctx->ssl_cert_last_mtime != t)) {; 15618 conn->dom_ctx->ssl_cert_last_mtime = t;; 15619 ; 15620 should_verify_peer = 0;; 15621 if (conn->dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 15622 if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes""); 15623 == 0) {; 15624 should_verify_peer = 1;; 15625 } else if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER],; 15626 ""optional""); 15627 == 0) {; 15628 should_verify_peer = 1;; 15629 }; 15630 }; 15631 ; 15632 if (should_verify_peer) {; 15633 char *ca_path = conn->dom_ctx->config[SSL_CA_PATH];; 15634 char *ca_file = conn->dom_ctx->config[SSL_CA_FILE];; 15635 if (SSL_CTX_load_verify_locations(conn->dom_ctx->ssl_ctx,; 15636 ca_file,; 15637 ca_path); 15638 != 1) {; 15639 mg_unlock_context(conn->phys_ctx);; 15640 mg_cry_ctx_internal(; 15641 conn->phys_ctx,; 15642 ""SSL_CTX_load_verify_locations error: %s ""; 15643 ""ssl_verify_peer requires setting ""; 15644 ""either ssl_ca_path or ssl_ca_file. Is any of them ""; 15645 ""present in ""; 15646 ""the .conf file?"",; 15647 ssl_error());; 15648 return 0;; 15649 }; 15650 }; 15651 ; 15652 if (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain) == 0) {; 15653 mg_unlock_context(conn->phys_ctx);; 15654 return 0;; 15655 }; 15656 }; 15657 mg_unlock_context(conn->phys_ctx);; 15658 ; 15659 return 1;; 15660}; 15661 ; 15662#if defined(OPENSSL_API_1_1); 15663#else; 15664static pthread_mutex_t *ssl_mutexes;; 15665#endi",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:461985,Modifiability,config,config,461985,"x->config[SSL_CERTIFICATE]) == NULL) {; 15599 /* If pem is NULL and conn->phys_ctx->callbacks.init_ssl is not,; 15600 * refresh_trust still can not work. */; 15601 return 0;; 15602 }; 15603 chain = conn->dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 15604 if (chain == NULL) {; 15605 /* pem is not NULL here */; 15606 chain = pem;; 15607 }; 15608 if (*chain == 0) {; 15609 chain = NULL;; 15610 }; 15611 ; 15612 if (stat(pem, &cert_buf) != -1) {; 15613 t = (int64_t)cert_buf.st_mtime;; 15614 }; 15615 ; 15616 mg_lock_context(conn->phys_ctx);; 15617 if ((t != 0) && (conn->dom_ctx->ssl_cert_last_mtime != t)) {; 15618 conn->dom_ctx->ssl_cert_last_mtime = t;; 15619 ; 15620 should_verify_peer = 0;; 15621 if (conn->dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 15622 if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes""); 15623 == 0) {; 15624 should_verify_peer = 1;; 15625 } else if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER],; 15626 ""optional""); 15627 == 0) {; 15628 should_verify_peer = 1;; 15629 }; 15630 }; 15631 ; 15632 if (should_verify_peer) {; 15633 char *ca_path = conn->dom_ctx->config[SSL_CA_PATH];; 15634 char *ca_file = conn->dom_ctx->config[SSL_CA_FILE];; 15635 if (SSL_CTX_load_verify_locations(conn->dom_ctx->ssl_ctx,; 15636 ca_file,; 15637 ca_path); 15638 != 1) {; 15639 mg_unlock_context(conn->phys_ctx);; 15640 mg_cry_ctx_internal(; 15641 conn->phys_ctx,; 15642 ""SSL_CTX_load_verify_locations error: %s ""; 15643 ""ssl_verify_peer requires setting ""; 15644 ""either ssl_ca_path or ssl_ca_file. Is any of them ""; 15645 ""present in ""; 15646 ""the .conf file?"",; 15647 ssl_error());; 15648 return 0;; 15649 }; 15650 }; 15651 ; 15652 if (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain) == 0) {; 15653 mg_unlock_context(conn->phys_ctx);; 15654 return 0;; 15655 }; 15656 }; 15657 mg_unlock_context(conn->phys_ctx);; 15658 ; 15659 return 1;; 15660}; 15661 ; 15662#if defined(OPENSSL_API_1_1); 15663#else; 15664static pthread_mutex_t *ssl_mutexes;; 15665#endi",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:463197,Modifiability,config,config,463197,"lock_context(conn->phys_ctx);; 15640 mg_cry_ctx_internal(; 15641 conn->phys_ctx,; 15642 ""SSL_CTX_load_verify_locations error: %s ""; 15643 ""ssl_verify_peer requires setting ""; 15644 ""either ssl_ca_path or ssl_ca_file. Is any of them ""; 15645 ""present in ""; 15646 ""the .conf file?"",; 15647 ssl_error());; 15648 return 0;; 15649 }; 15650 }; 15651 ; 15652 if (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain) == 0) {; 15653 mg_unlock_context(conn->phys_ctx);; 15654 return 0;; 15655 }; 15656 }; 15657 mg_unlock_context(conn->phys_ctx);; 15658 ; 15659 return 1;; 15660}; 15661 ; 15662#if defined(OPENSSL_API_1_1); 15663#else; 15664static pthread_mutex_t *ssl_mutexes;; 15665#endif /* OPENSSL_API_1_1 */; 15666 ; 15667static int; 15668sslize(struct mg_connection *conn,; 15669 int (*func)(SSL *),; 15670 const struct mg_client_options *client_options); 15671{; 15672 int ret, err;; 15673 int short_trust;; 15674 unsigned timeout = 1024;; 15675 unsigned i;; 15676 ; 15677 if (!conn) {; 15678 return 0;; 15679 }; 15680 ; 15681 short_trust =; 15682 (conn->dom_ctx->config[SSL_SHORT_TRUST] != NULL); 15683 && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], ""yes"") == 0);; 15684 ; 15685 if (short_trust) {; 15686 int trust_ret = refresh_trust(conn);; 15687 if (!trust_ret) {; 15688 return trust_ret;; 15689 }; 15690 }; 15691 ; 15692 mg_lock_context(conn->phys_ctx);; 15693 conn->ssl = SSL_new(conn->dom_ctx->ssl_ctx);; 15694 mg_unlock_context(conn->phys_ctx);; 15695 if (conn->ssl == NULL) {; 15696 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15697 OPENSSL_REMOVE_THREAD_STATE();; 15698 return 0;; 15699 }; 15700 SSL_set_app_data(conn->ssl, (char *)conn);; 15701 ; 15702 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15703 if (ret != 1) {; 15704 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15705 SSL_free(conn->ssl);; 15706 conn->ssl = NULL;; 15707 OPENSSL_REMOVE_THREAD_STATE();; 15708 return 0;; 15709 }; 15710 ; 15711 if (client_options) {; 15712 if (client_opt",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:463270,Modifiability,config,config,463270,"lock_context(conn->phys_ctx);; 15640 mg_cry_ctx_internal(; 15641 conn->phys_ctx,; 15642 ""SSL_CTX_load_verify_locations error: %s ""; 15643 ""ssl_verify_peer requires setting ""; 15644 ""either ssl_ca_path or ssl_ca_file. Is any of them ""; 15645 ""present in ""; 15646 ""the .conf file?"",; 15647 ssl_error());; 15648 return 0;; 15649 }; 15650 }; 15651 ; 15652 if (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain) == 0) {; 15653 mg_unlock_context(conn->phys_ctx);; 15654 return 0;; 15655 }; 15656 }; 15657 mg_unlock_context(conn->phys_ctx);; 15658 ; 15659 return 1;; 15660}; 15661 ; 15662#if defined(OPENSSL_API_1_1); 15663#else; 15664static pthread_mutex_t *ssl_mutexes;; 15665#endif /* OPENSSL_API_1_1 */; 15666 ; 15667static int; 15668sslize(struct mg_connection *conn,; 15669 int (*func)(SSL *),; 15670 const struct mg_client_options *client_options); 15671{; 15672 int ret, err;; 15673 int short_trust;; 15674 unsigned timeout = 1024;; 15675 unsigned i;; 15676 ; 15677 if (!conn) {; 15678 return 0;; 15679 }; 15680 ; 15681 short_trust =; 15682 (conn->dom_ctx->config[SSL_SHORT_TRUST] != NULL); 15683 && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], ""yes"") == 0);; 15684 ; 15685 if (short_trust) {; 15686 int trust_ret = refresh_trust(conn);; 15687 if (!trust_ret) {; 15688 return trust_ret;; 15689 }; 15690 }; 15691 ; 15692 mg_lock_context(conn->phys_ctx);; 15693 conn->ssl = SSL_new(conn->dom_ctx->ssl_ctx);; 15694 mg_unlock_context(conn->phys_ctx);; 15695 if (conn->ssl == NULL) {; 15696 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15697 OPENSSL_REMOVE_THREAD_STATE();; 15698 return 0;; 15699 }; 15700 SSL_set_app_data(conn->ssl, (char *)conn);; 15701 ; 15702 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15703 if (ret != 1) {; 15704 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15705 SSL_free(conn->ssl);; 15706 conn->ssl = NULL;; 15707 OPENSSL_REMOVE_THREAD_STATE();; 15708 return 0;; 15709 }; 15710 ; 15711 if (client_options) {; 15712 if (client_opt",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:464350,Modifiability,config,config,464350,"nn->dom_ctx->config[SSL_SHORT_TRUST] != NULL); 15683 && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], ""yes"") == 0);; 15684 ; 15685 if (short_trust) {; 15686 int trust_ret = refresh_trust(conn);; 15687 if (!trust_ret) {; 15688 return trust_ret;; 15689 }; 15690 }; 15691 ; 15692 mg_lock_context(conn->phys_ctx);; 15693 conn->ssl = SSL_new(conn->dom_ctx->ssl_ctx);; 15694 mg_unlock_context(conn->phys_ctx);; 15695 if (conn->ssl == NULL) {; 15696 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15697 OPENSSL_REMOVE_THREAD_STATE();; 15698 return 0;; 15699 }; 15700 SSL_set_app_data(conn->ssl, (char *)conn);; 15701 ; 15702 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15703 if (ret != 1) {; 15704 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15705 SSL_free(conn->ssl);; 15706 conn->ssl = NULL;; 15707 OPENSSL_REMOVE_THREAD_STATE();; 15708 return 0;; 15709 }; 15710 ; 15711 if (client_options) {; 15712 if (client_options->host_name) {; 15713 SSL_set_tlsext_host_name(conn->ssl, client_options->host_name);; 15714 }; 15715 }; 15716 ; 15717 /* Reuse the request timeout for the SSL_Accept/SSL_connect timeout */; 15718 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 15719 /* NOTE: The loop below acts as a back-off, so we can end; 15720 * up sleeping for more (or less) than the REQUEST_TIMEOUT. */; 15721 int to = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]);; 15722 if (to >= 0) {; 15723 timeout = (unsigned)to;; 15724 }; 15725 }; 15726 ; 15727 /* SSL functions may fail and require to be called again:; 15728 * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html; 15729 * Here ""func"" could be SSL_connect or SSL_accept. */; 15730 for (i = 0; i <= timeout; i += 50) {; 15731 ERR_clear_error();; 15732 /* conn->dom_ctx may be changed here (see ssl_servername_callback) */; 15733 ret = func(conn->ssl);; 15734 if (ret != 1) {; 15735 err = SSL_get_error(conn->ssl, ret);; 15736 if ((err == SSL_ERROR_WANT_CONNECT); 15737 || (err == SSL_ERROR_WANT_ACCEPT); 1573",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:464547,Modifiability,config,config,464547,"L) {; 15696 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15697 OPENSSL_REMOVE_THREAD_STATE();; 15698 return 0;; 15699 }; 15700 SSL_set_app_data(conn->ssl, (char *)conn);; 15701 ; 15702 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15703 if (ret != 1) {; 15704 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15705 SSL_free(conn->ssl);; 15706 conn->ssl = NULL;; 15707 OPENSSL_REMOVE_THREAD_STATE();; 15708 return 0;; 15709 }; 15710 ; 15711 if (client_options) {; 15712 if (client_options->host_name) {; 15713 SSL_set_tlsext_host_name(conn->ssl, client_options->host_name);; 15714 }; 15715 }; 15716 ; 15717 /* Reuse the request timeout for the SSL_Accept/SSL_connect timeout */; 15718 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 15719 /* NOTE: The loop below acts as a back-off, so we can end; 15720 * up sleeping for more (or less) than the REQUEST_TIMEOUT. */; 15721 int to = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]);; 15722 if (to >= 0) {; 15723 timeout = (unsigned)to;; 15724 }; 15725 }; 15726 ; 15727 /* SSL functions may fail and require to be called again:; 15728 * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html; 15729 * Here ""func"" could be SSL_connect or SSL_accept. */; 15730 for (i = 0; i <= timeout; i += 50) {; 15731 ERR_clear_error();; 15732 /* conn->dom_ctx may be changed here (see ssl_servername_callback) */; 15733 ret = func(conn->ssl);; 15734 if (ret != 1) {; 15735 err = SSL_get_error(conn->ssl, ret);; 15736 if ((err == SSL_ERROR_WANT_CONNECT); 15737 || (err == SSL_ERROR_WANT_ACCEPT); 15738 || (err == SSL_ERROR_WANT_READ) || (err == SSL_ERROR_WANT_WRITE); 15739 || (err == SSL_ERROR_WANT_X509_LOOKUP)) {; 15740 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 15741 /* Don't wait if the server is going to be stopped. */; 15742 break;; 15743 }; 15744 if (err == SSL_ERROR_WANT_X509_LOOKUP) {; 15745 /* Simply retry the function call. */; 15746 mg_sleep(50);; 15747 } else {; 15748 /* Need to retry the function call ""later",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:480229,Modifiability,layers,layers,480229,"5#endif; 16226 return ret;; 16227}; 16228#else; 16229static long; 16230ssl_get_protocol(int version_id); 16231{; 16232 unsigned long ret = (unsigned long)SSL_OP_ALL;; 16233 if (version_id > 0); 16234 ret |= SSL_OP_NO_SSLv2;; 16235 if (version_id > 1); 16236 ret |= SSL_OP_NO_SSLv3;; 16237 if (version_id > 2); 16238 ret |= SSL_OP_NO_TLSv1;; 16239 if (version_id > 3); 16240 ret |= SSL_OP_NO_TLSv1_1;; 16241 if (version_id > 4); 16242 ret |= SSL_OP_NO_TLSv1_2;; 16243#if defined(SSL_OP_NO_TLSv1_3); 16244 if (version_id > 5); 16245 ret |= SSL_OP_NO_TLSv1_3;; 16246#endif; 16247 return (long)ret;; 16248}; 16249#endif /* OPENSSL_API_1_1 */; 16250 ; 16251 ; 16252/* SSL callback documentation:; 16253 * https://www.openssl.org/docs/man1.1.0/ssl/SSL_set_info_callback.html; 16254 * https://wiki.openssl.org/index.php/Manual:SSL_CTX_set_info_callback(3); 16255 * https://linux.die.net/man/3/ssl_set_info_callback */; 16256/* Note: There is no ""const"" for the first argument in the documentation; 16257 * examples, however some (maybe most, but not all) headers of OpenSSL; 16258 * versions / OpenSSL compatibility layers have it. Having a different; 16259 * definition will cause a warning in C and an error in C++. Use ""const SSL; 16260 * *"", while automatical conversion from ""SSL *"" works for all compilers,; 16261 * but not other way around */; 16262static void; 16263ssl_info_callback(const SSL *ssl, int what, int ret); 16264{; 16265 (void)ret;; 16266 ; 16267 if (what & SSL_CB_HANDSHAKE_START) {; 16268 SSL_get_app_data(ssl);; 16269 }; 16270 if (what & SSL_CB_HANDSHAKE_DONE) {; 16271 /* TODO: check for openSSL 1.1 */; 16272 //#define SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS 0x0001; 16273 // ssl->s3->flags |= SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS;; 16274 }; 16275}; 16276 ; 16277 ; 16278static int; 16279ssl_servername_callback(SSL *ssl, int *ad, void *arg); 16280{; 16281#if defined(GCC_DIAGNOSTIC); 16282#pragma GCC diagnostic push; 16283#pragma GCC diagnostic ignored ""-Wcast-align""; 16284#endif /* defi",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:482513,Modifiability,config,config,482513,"94 ; 16295 (void)ad;; 16296 (void)arg;; 16297 ; 16298 if ((conn == NULL) || (conn->phys_ctx == NULL)) {; 16299 DEBUG_ASSERT(0);; 16300 return SSL_TLSEXT_ERR_NOACK;; 16301 }; 16302 conn->dom_ctx = &(conn->phys_ctx->dd);; 16303 ; 16304 /* Old clients (Win XP) will not support SNI. Then, there; 16305 * is no server name available in the request - we can; 16306 * only work with the default certificate.; 16307 * Multiple HTTPS hosts on one IP+port are only possible; 16308 * with a certificate containing all alternative names.; 16309 */; 16310 if ((servername == NULL) || (*servername == 0)) {; 16311 DEBUG_TRACE(""%s"", ""SSL connection not supporting SNI"");; 16312 mg_lock_context(conn->phys_ctx);; 16313 SSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);; 16314 mg_unlock_context(conn->phys_ctx);; 16315 return SSL_TLSEXT_ERR_NOACK;; 16316 }; 16317 ; 16318 DEBUG_TRACE(""TLS connection to host %s"", servername);; 16319 ; 16320 while (conn->dom_ctx) {; 16321 if (!mg_strcasecmp(servername,; 16322 conn->dom_ctx->config[AUTHENTICATION_DOMAIN])) {; 16323 /* Found matching domain */; 16324 DEBUG_TRACE(""TLS domain %s found"",; 16325 conn->dom_ctx->config[AUTHENTICATION_DOMAIN]);; 16326 break;; 16327 }; 16328 mg_lock_context(conn->phys_ctx);; 16329 conn->dom_ctx = conn->dom_ctx->next;; 16330 mg_unlock_context(conn->phys_ctx);; 16331 }; 16332 ; 16333 if (conn->dom_ctx == NULL) {; 16334 /* Default domain */; 16335 DEBUG_TRACE(""TLS default domain %s used"",; 16336 conn->phys_ctx->dd.config[AUTHENTICATION_DOMAIN]);; 16337 conn->dom_ctx = &(conn->phys_ctx->dd);; 16338 }; 16339 mg_lock_context(conn->phys_ctx);; 16340 SSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);; 16341 mg_unlock_context(conn->phys_ctx);; 16342 return SSL_TLSEXT_ERR_OK;; 16343}; 16344 ; 16345 ; 16346#if defined(USE_ALPN); 16347static const char alpn_proto_list[] = ""\x02h2\x08http/1.1\x08http/1.0"";; 16348static const char *alpn_proto_order_http1[] = {alpn_proto_list + 3,; 16349 alpn_proto_list + 3 + 8,; 16350 NULL};; 16351#if defined(USE",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:482646,Modifiability,config,config,482646,"94 ; 16295 (void)ad;; 16296 (void)arg;; 16297 ; 16298 if ((conn == NULL) || (conn->phys_ctx == NULL)) {; 16299 DEBUG_ASSERT(0);; 16300 return SSL_TLSEXT_ERR_NOACK;; 16301 }; 16302 conn->dom_ctx = &(conn->phys_ctx->dd);; 16303 ; 16304 /* Old clients (Win XP) will not support SNI. Then, there; 16305 * is no server name available in the request - we can; 16306 * only work with the default certificate.; 16307 * Multiple HTTPS hosts on one IP+port are only possible; 16308 * with a certificate containing all alternative names.; 16309 */; 16310 if ((servername == NULL) || (*servername == 0)) {; 16311 DEBUG_TRACE(""%s"", ""SSL connection not supporting SNI"");; 16312 mg_lock_context(conn->phys_ctx);; 16313 SSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);; 16314 mg_unlock_context(conn->phys_ctx);; 16315 return SSL_TLSEXT_ERR_NOACK;; 16316 }; 16317 ; 16318 DEBUG_TRACE(""TLS connection to host %s"", servername);; 16319 ; 16320 while (conn->dom_ctx) {; 16321 if (!mg_strcasecmp(servername,; 16322 conn->dom_ctx->config[AUTHENTICATION_DOMAIN])) {; 16323 /* Found matching domain */; 16324 DEBUG_TRACE(""TLS domain %s found"",; 16325 conn->dom_ctx->config[AUTHENTICATION_DOMAIN]);; 16326 break;; 16327 }; 16328 mg_lock_context(conn->phys_ctx);; 16329 conn->dom_ctx = conn->dom_ctx->next;; 16330 mg_unlock_context(conn->phys_ctx);; 16331 }; 16332 ; 16333 if (conn->dom_ctx == NULL) {; 16334 /* Default domain */; 16335 DEBUG_TRACE(""TLS default domain %s used"",; 16336 conn->phys_ctx->dd.config[AUTHENTICATION_DOMAIN]);; 16337 conn->dom_ctx = &(conn->phys_ctx->dd);; 16338 }; 16339 mg_lock_context(conn->phys_ctx);; 16340 SSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);; 16341 mg_unlock_context(conn->phys_ctx);; 16342 return SSL_TLSEXT_ERR_OK;; 16343}; 16344 ; 16345 ; 16346#if defined(USE_ALPN); 16347static const char alpn_proto_list[] = ""\x02h2\x08http/1.1\x08http/1.0"";; 16348static const char *alpn_proto_order_http1[] = {alpn_proto_list + 3,; 16349 alpn_proto_list + 3 + 8,; 16350 NULL};; 16351#if defined(USE",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:482983,Modifiability,config,config,482983,"6312 mg_lock_context(conn->phys_ctx);; 16313 SSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);; 16314 mg_unlock_context(conn->phys_ctx);; 16315 return SSL_TLSEXT_ERR_NOACK;; 16316 }; 16317 ; 16318 DEBUG_TRACE(""TLS connection to host %s"", servername);; 16319 ; 16320 while (conn->dom_ctx) {; 16321 if (!mg_strcasecmp(servername,; 16322 conn->dom_ctx->config[AUTHENTICATION_DOMAIN])) {; 16323 /* Found matching domain */; 16324 DEBUG_TRACE(""TLS domain %s found"",; 16325 conn->dom_ctx->config[AUTHENTICATION_DOMAIN]);; 16326 break;; 16327 }; 16328 mg_lock_context(conn->phys_ctx);; 16329 conn->dom_ctx = conn->dom_ctx->next;; 16330 mg_unlock_context(conn->phys_ctx);; 16331 }; 16332 ; 16333 if (conn->dom_ctx == NULL) {; 16334 /* Default domain */; 16335 DEBUG_TRACE(""TLS default domain %s used"",; 16336 conn->phys_ctx->dd.config[AUTHENTICATION_DOMAIN]);; 16337 conn->dom_ctx = &(conn->phys_ctx->dd);; 16338 }; 16339 mg_lock_context(conn->phys_ctx);; 16340 SSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);; 16341 mg_unlock_context(conn->phys_ctx);; 16342 return SSL_TLSEXT_ERR_OK;; 16343}; 16344 ; 16345 ; 16346#if defined(USE_ALPN); 16347static const char alpn_proto_list[] = ""\x02h2\x08http/1.1\x08http/1.0"";; 16348static const char *alpn_proto_order_http1[] = {alpn_proto_list + 3,; 16349 alpn_proto_list + 3 + 8,; 16350 NULL};; 16351#if defined(USE_HTTP2); 16352static const char *alpn_proto_order_http2[] = {alpn_proto_list,; 16353 alpn_proto_list + 3,; 16354 alpn_proto_list + 3 + 8,; 16355 NULL};; 16356#endif; 16357 ; 16358static int; 16359alpn_select_cb(SSL *ssl,; 16360 const unsigned char **out,; 16361 unsigned char *outlen,; 16362 const unsigned char *in,; 16363 unsigned int inlen,; 16364 void *arg); 16365{; 16366 struct mg_domain_context *dom_ctx = (struct mg_domain_context *)arg;; 16367 unsigned int i, j, enable_http2 = 0;; 16368 const char **alpn_proto_order = alpn_proto_order_http1;; 16369 ; 16370 struct mg_workerTLS *tls =; 16371 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 163",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:484475,Modifiability,config,config,484475,"50 NULL};; 16351#if defined(USE_HTTP2); 16352static const char *alpn_proto_order_http2[] = {alpn_proto_list,; 16353 alpn_proto_list + 3,; 16354 alpn_proto_list + 3 + 8,; 16355 NULL};; 16356#endif; 16357 ; 16358static int; 16359alpn_select_cb(SSL *ssl,; 16360 const unsigned char **out,; 16361 unsigned char *outlen,; 16362 const unsigned char *in,; 16363 unsigned int inlen,; 16364 void *arg); 16365{; 16366 struct mg_domain_context *dom_ctx = (struct mg_domain_context *)arg;; 16367 unsigned int i, j, enable_http2 = 0;; 16368 const char **alpn_proto_order = alpn_proto_order_http1;; 16369 ; 16370 struct mg_workerTLS *tls =; 16371 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 16372 ; 16373 (void)ssl;; 16374 ; 16375 if (tls == NULL) {; 16376 /* Need to store protocol in Thread Local Storage */; 16377 /* If there is no Thread Local Storage, don't use ALPN */; 16378 return SSL_TLSEXT_ERR_NOACK;; 16379 }; 16380 ; 16381#if defined(USE_HTTP2); 16382 enable_http2 = (0 == strcmp(dom_ctx->config[ENABLE_HTTP2], ""yes""));; 16383 if (enable_http2) {; 16384 alpn_proto_order = alpn_proto_order_http2;; 16385 }; 16386#endif; 16387 ; 16388 for (j = 0; alpn_proto_order[j] != NULL; j++) {; 16389 /* check all accepted protocols in this order */; 16390 const char *alpn_proto = alpn_proto_order[j];; 16391 /* search input for matching protocol */; 16392 for (i = 0; i < inlen; i++) {; 16393 if (!memcmp(in + i, alpn_proto, (unsigned char)alpn_proto[0])) {; 16394 *out = in + i + 1;; 16395 *outlen = in[i];; 16396 tls->alpn_proto = alpn_proto;; 16397 return SSL_TLSEXT_ERR_OK;; 16398 }; 16399 }; 16400 }; 16401 ; 16402 /* Nothing found */; 16403 return SSL_TLSEXT_ERR_NOACK;; 16404}; 16405 ; 16406 ; 16407static int; 16408next_protos_advertised_cb(SSL *ssl,; 16409 const unsigned char **data,; 16410 unsigned int *len,; 16411 void *arg); 16412{; 16413 struct mg_domain_context *dom_ctx = (struct mg_domain_context *)arg;; 16414 *data = (const unsigned char *)alpn_proto_list;; 16415 *len = (unsigned in",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:487977,Modifiability,config,config,487977,"ruct timespec now_mt;; 16465 md5_byte_t ssl_context_id[16];; 16466 md5_state_t md5state;; 16467 int protocol_ver;; 16468 int ssl_cache_timeout;; 16469 ; 16470#if (defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0)) \; 16471 && !defined(NO_SSL_DL); 16472 if ((dom_ctx->ssl_ctx = SSL_CTX_new(TLS_server_method())) == NULL) {; 16473 mg_cry_ctx_internal(phys_ctx,; 16474 ""SSL_CTX_new (server) error: %s"",; 16475 ssl_error());; 16476 return 0;; 16477 }; 16478#else; 16479 if ((dom_ctx->ssl_ctx = SSL_CTX_new(SSLv23_server_method())) == NULL) {; 16480 mg_cry_ctx_internal(phys_ctx,; 16481 ""SSL_CTX_new (server) error: %s"",; 16482 ssl_error());; 16483 return 0;; 16484 }; 16485#endif /* OPENSSL_API_1_1 || OPENSSL_API_3_0 */; 16486 ; 16487#if defined(SSL_OP_NO_TLSv1_3); 16488 SSL_CTX_clear_options(dom_ctx->ssl_ctx,; 16489 SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1; 16490 | SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1_2; 16491 | SSL_OP_NO_TLSv1_3);; 16492#else; 16493 SSL_CTX_clear_options(dom_ctx->ssl_ctx,; 16494 SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1; 16495 | SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1_2);; 16496#endif; 16497 ; 16498 protocol_ver = atoi(dom_ctx->config[SSL_PROTOCOL_VERSION]);; 16499 SSL_CTX_set_options(dom_ctx->ssl_ctx, ssl_get_protocol(protocol_ver));; 16500 SSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_SINGLE_DH_USE);; 16501 SSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);; 16502 SSL_CTX_set_options(dom_ctx->ssl_ctx,; 16503 SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);; 16504 SSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_NO_COMPRESSION);; 16505 ; 16506#if defined(SSL_OP_NO_RENEGOTIATION); 16507 SSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_NO_RENEGOTIATION);; 16508#endif; 16509 ; 16510#if !defined(NO_SSL_DL); 16511 SSL_CTX_set_ecdh_auto(dom_ctx->ssl_ctx, 1);; 16512#endif /* NO_SSL_DL */; 16513 ; 16514 /* In SSL documentation examples callback defined without const; 16515 * specifier 'void (*)(SSL *, int, int)' See:; 16516 * https://www.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:490510,Modifiability,config,config,490510,"x,; 16530 ssl_servername_callback);; 16531 ; 16532 /* If a callback has been specified, call it. */; 16533 callback_ret = (phys_ctx->callbacks.init_ssl == NULL); 16534 ? 0; 16535 : (phys_ctx->callbacks.init_ssl(dom_ctx->ssl_ctx,; 16536 phys_ctx->user_data));; 16537 ; 16538 /* If callback returns 0, civetweb sets up the SSL certificate.; 16539 * If it returns 1, civetweb assumes the calback already did this.; 16540 * If it returns -1, initializing ssl fails. */; 16541 if (callback_ret < 0) {; 16542 mg_cry_ctx_internal(phys_ctx,; 16543 ""SSL callback returned error: %i"",; 16544 callback_ret);; 16545 return 0;; 16546 }; 16547 if (callback_ret > 0) {; 16548 /* Callback did everything. */; 16549 return 1;; 16550 }; 16551 ; 16552 /* If a domain callback has been specified, call it. */; 16553 callback_ret = (phys_ctx->callbacks.init_ssl_domain == NULL); 16554 ? 0; 16555 : (phys_ctx->callbacks.init_ssl_domain(; 16556 dom_ctx->config[AUTHENTICATION_DOMAIN],; 16557 dom_ctx->ssl_ctx,; 16558 phys_ctx->user_data));; 16559 ; 16560 /* If domain callback returns 0, civetweb sets up the SSL certificate.; 16561 * If it returns 1, civetweb assumes the calback already did this.; 16562 * If it returns -1, initializing ssl fails. */; 16563 if (callback_ret < 0) {; 16564 mg_cry_ctx_internal(phys_ctx,; 16565 ""Domain SSL callback returned error: %i"",; 16566 callback_ret);; 16567 return 0;; 16568 }; 16569 if (callback_ret > 0) {; 16570 /* Domain callback did everything. */; 16571 return 1;; 16572 }; 16573 ; 16574 /* Use some combination of start time, domain and port as a SSL; 16575 * context ID. This should be unique on the current machine. */; 16576 md5_init(&md5state);; 16577 clock_gettime(CLOCK_MONOTONIC, &now_mt);; 16578 md5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));; 16579 md5_append(&md5state,; 16580 (const md5_byte_t *)phys_ctx->dd.config[LISTENING_PORTS],; 16581 strlen(phys_ctx->dd.config[LISTENING_PORTS]));; 16582 md5_append(&md5state,; 16583 (const md5_byte_t *",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:491445,Modifiability,config,config,491445,"backs.init_ssl_domain(; 16556 dom_ctx->config[AUTHENTICATION_DOMAIN],; 16557 dom_ctx->ssl_ctx,; 16558 phys_ctx->user_data));; 16559 ; 16560 /* If domain callback returns 0, civetweb sets up the SSL certificate.; 16561 * If it returns 1, civetweb assumes the calback already did this.; 16562 * If it returns -1, initializing ssl fails. */; 16563 if (callback_ret < 0) {; 16564 mg_cry_ctx_internal(phys_ctx,; 16565 ""Domain SSL callback returned error: %i"",; 16566 callback_ret);; 16567 return 0;; 16568 }; 16569 if (callback_ret > 0) {; 16570 /* Domain callback did everything. */; 16571 return 1;; 16572 }; 16573 ; 16574 /* Use some combination of start time, domain and port as a SSL; 16575 * context ID. This should be unique on the current machine. */; 16576 md5_init(&md5state);; 16577 clock_gettime(CLOCK_MONOTONIC, &now_mt);; 16578 md5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));; 16579 md5_append(&md5state,; 16580 (const md5_byte_t *)phys_ctx->dd.config[LISTENING_PORTS],; 16581 strlen(phys_ctx->dd.config[LISTENING_PORTS]));; 16582 md5_append(&md5state,; 16583 (const md5_byte_t *)dom_ctx->config[AUTHENTICATION_DOMAIN],; 16584 strlen(dom_ctx->config[AUTHENTICATION_DOMAIN]));; 16585 md5_append(&md5state, (const md5_byte_t *)phys_ctx, sizeof(*phys_ctx));; 16586 md5_append(&md5state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16587 md5_finish(&md5state, ssl_context_id);; 16588 ; 16589 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16590 (unsigned char *)ssl_context_id,; 16591 sizeof(ssl_context_id));; 16592 ; 16593 if (pem != NULL) {; 16594 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16595 return 0;; 16596 }; 16597 }; 16598 ; 16599 /* Should we support client certificates? */; 16600 /* Default is ""no"". */; 16601 should_verify_peer = 0;; 16602 peer_certificate_optional = 0;; 16603 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16604 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16605 /* Yes, they are mandato",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:491497,Modifiability,config,config,491497,"al(phys_ctx,; 16565 ""Domain SSL callback returned error: %i"",; 16566 callback_ret);; 16567 return 0;; 16568 }; 16569 if (callback_ret > 0) {; 16570 /* Domain callback did everything. */; 16571 return 1;; 16572 }; 16573 ; 16574 /* Use some combination of start time, domain and port as a SSL; 16575 * context ID. This should be unique on the current machine. */; 16576 md5_init(&md5state);; 16577 clock_gettime(CLOCK_MONOTONIC, &now_mt);; 16578 md5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));; 16579 md5_append(&md5state,; 16580 (const md5_byte_t *)phys_ctx->dd.config[LISTENING_PORTS],; 16581 strlen(phys_ctx->dd.config[LISTENING_PORTS]));; 16582 md5_append(&md5state,; 16583 (const md5_byte_t *)dom_ctx->config[AUTHENTICATION_DOMAIN],; 16584 strlen(dom_ctx->config[AUTHENTICATION_DOMAIN]));; 16585 md5_append(&md5state, (const md5_byte_t *)phys_ctx, sizeof(*phys_ctx));; 16586 md5_append(&md5state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16587 md5_finish(&md5state, ssl_context_id);; 16588 ; 16589 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16590 (unsigned char *)ssl_context_id,; 16591 sizeof(ssl_context_id));; 16592 ; 16593 if (pem != NULL) {; 16594 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16595 return 0;; 16596 }; 16597 }; 16598 ; 16599 /* Should we support client certificates? */; 16600 /* Default is ""no"". */; 16601 should_verify_peer = 0;; 16602 peer_certificate_optional = 0;; 16603 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16604 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16605 /* Yes, they are mandatory */; 16606 should_verify_peer = 1;; 16607 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16608 ""optional""); 16609 == 0) {; 16610 /* Yes, they are optional */; 16611 should_verify_peer = 1;; 16612 peer_certificate_optional = 1;; 16613 }; 16614 }; 16615 ; 16616 use_default_verify_paths =; 16617 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16618 && (mg_strcasecmp(dom_c",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:491589,Modifiability,config,config,491589,"al(phys_ctx,; 16565 ""Domain SSL callback returned error: %i"",; 16566 callback_ret);; 16567 return 0;; 16568 }; 16569 if (callback_ret > 0) {; 16570 /* Domain callback did everything. */; 16571 return 1;; 16572 }; 16573 ; 16574 /* Use some combination of start time, domain and port as a SSL; 16575 * context ID. This should be unique on the current machine. */; 16576 md5_init(&md5state);; 16577 clock_gettime(CLOCK_MONOTONIC, &now_mt);; 16578 md5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));; 16579 md5_append(&md5state,; 16580 (const md5_byte_t *)phys_ctx->dd.config[LISTENING_PORTS],; 16581 strlen(phys_ctx->dd.config[LISTENING_PORTS]));; 16582 md5_append(&md5state,; 16583 (const md5_byte_t *)dom_ctx->config[AUTHENTICATION_DOMAIN],; 16584 strlen(dom_ctx->config[AUTHENTICATION_DOMAIN]));; 16585 md5_append(&md5state, (const md5_byte_t *)phys_ctx, sizeof(*phys_ctx));; 16586 md5_append(&md5state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16587 md5_finish(&md5state, ssl_context_id);; 16588 ; 16589 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16590 (unsigned char *)ssl_context_id,; 16591 sizeof(ssl_context_id));; 16592 ; 16593 if (pem != NULL) {; 16594 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16595 return 0;; 16596 }; 16597 }; 16598 ; 16599 /* Should we support client certificates? */; 16600 /* Default is ""no"". */; 16601 should_verify_peer = 0;; 16602 peer_certificate_optional = 0;; 16603 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16604 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16605 /* Yes, they are mandatory */; 16606 should_verify_peer = 1;; 16607 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16608 ""optional""); 16609 == 0) {; 16610 /* Yes, they are optional */; 16611 should_verify_peer = 1;; 16612 peer_certificate_optional = 1;; 16613 }; 16614 }; 16615 ; 16616 use_default_verify_paths =; 16617 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16618 && (mg_strcasecmp(dom_c",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:491643,Modifiability,config,config,491643,"al(phys_ctx,; 16565 ""Domain SSL callback returned error: %i"",; 16566 callback_ret);; 16567 return 0;; 16568 }; 16569 if (callback_ret > 0) {; 16570 /* Domain callback did everything. */; 16571 return 1;; 16572 }; 16573 ; 16574 /* Use some combination of start time, domain and port as a SSL; 16575 * context ID. This should be unique on the current machine. */; 16576 md5_init(&md5state);; 16577 clock_gettime(CLOCK_MONOTONIC, &now_mt);; 16578 md5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));; 16579 md5_append(&md5state,; 16580 (const md5_byte_t *)phys_ctx->dd.config[LISTENING_PORTS],; 16581 strlen(phys_ctx->dd.config[LISTENING_PORTS]));; 16582 md5_append(&md5state,; 16583 (const md5_byte_t *)dom_ctx->config[AUTHENTICATION_DOMAIN],; 16584 strlen(dom_ctx->config[AUTHENTICATION_DOMAIN]));; 16585 md5_append(&md5state, (const md5_byte_t *)phys_ctx, sizeof(*phys_ctx));; 16586 md5_append(&md5state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16587 md5_finish(&md5state, ssl_context_id);; 16588 ; 16589 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16590 (unsigned char *)ssl_context_id,; 16591 sizeof(ssl_context_id));; 16592 ; 16593 if (pem != NULL) {; 16594 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16595 return 0;; 16596 }; 16597 }; 16598 ; 16599 /* Should we support client certificates? */; 16600 /* Default is ""no"". */; 16601 should_verify_peer = 0;; 16602 peer_certificate_optional = 0;; 16603 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16604 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16605 /* Yes, they are mandatory */; 16606 should_verify_peer = 1;; 16607 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16608 ""optional""); 16609 == 0) {; 16610 /* Yes, they are optional */; 16611 should_verify_peer = 1;; 16612 peer_certificate_optional = 1;; 16613 }; 16614 }; 16615 ; 16616 use_default_verify_paths =; 16617 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16618 && (mg_strcasecmp(dom_c",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:492325,Modifiability,config,config,492325,"state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16587 md5_finish(&md5state, ssl_context_id);; 16588 ; 16589 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16590 (unsigned char *)ssl_context_id,; 16591 sizeof(ssl_context_id));; 16592 ; 16593 if (pem != NULL) {; 16594 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16595 return 0;; 16596 }; 16597 }; 16598 ; 16599 /* Should we support client certificates? */; 16600 /* Default is ""no"". */; 16601 should_verify_peer = 0;; 16602 peer_certificate_optional = 0;; 16603 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16604 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16605 /* Yes, they are mandatory */; 16606 should_verify_peer = 1;; 16607 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16608 ""optional""); 16609 == 0) {; 16610 /* Yes, they are optional */; 16611 should_verify_peer = 1;; 16612 peer_certificate_optional = 1;; 16613 }; 16614 }; 16615 ; 16616 use_default_verify_paths =; 16617 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16618 && (mg_strcasecmp(dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS], ""yes""); 16619 == 0);; 16620 ; 16621 if (should_verify_peer) {; 16622 ca_path = dom_ctx->config[SSL_CA_PATH];; 16623 ca_file = dom_ctx->config[SSL_CA_FILE];; 16624 if (SSL_CTX_load_verify_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16625 != 1) {; 16626 mg_cry_ctx_internal(phys_ctx,; 16627 ""SSL_CTX_load_verify_locations error: %s ""; 16628 ""ssl_verify_peer requires setting ""; 16629 ""either ssl_ca_path or ssl_ca_file. ""; 16630 ""Is any of them present in the ""; 16631 "".conf file?"",; 16632 ssl_error());; 16633 return 0;; 16634 }; 16635 ; 16636 if (peer_certificate_optional) {; 16637 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16638 } else {; 16639 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16640 SSL_VERIFY_PEER; 16641 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16642 NULL);; 16643 }; 16644 ; 16645 if (use_default_verify_paths; 16646 && (SSL_CTX_set_default_veri",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:492397,Modifiability,config,config,492397,"state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16587 md5_finish(&md5state, ssl_context_id);; 16588 ; 16589 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16590 (unsigned char *)ssl_context_id,; 16591 sizeof(ssl_context_id));; 16592 ; 16593 if (pem != NULL) {; 16594 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16595 return 0;; 16596 }; 16597 }; 16598 ; 16599 /* Should we support client certificates? */; 16600 /* Default is ""no"". */; 16601 should_verify_peer = 0;; 16602 peer_certificate_optional = 0;; 16603 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16604 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16605 /* Yes, they are mandatory */; 16606 should_verify_peer = 1;; 16607 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16608 ""optional""); 16609 == 0) {; 16610 /* Yes, they are optional */; 16611 should_verify_peer = 1;; 16612 peer_certificate_optional = 1;; 16613 }; 16614 }; 16615 ; 16616 use_default_verify_paths =; 16617 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16618 && (mg_strcasecmp(dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS], ""yes""); 16619 == 0);; 16620 ; 16621 if (should_verify_peer) {; 16622 ca_path = dom_ctx->config[SSL_CA_PATH];; 16623 ca_file = dom_ctx->config[SSL_CA_FILE];; 16624 if (SSL_CTX_load_verify_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16625 != 1) {; 16626 mg_cry_ctx_internal(phys_ctx,; 16627 ""SSL_CTX_load_verify_locations error: %s ""; 16628 ""ssl_verify_peer requires setting ""; 16629 ""either ssl_ca_path or ssl_ca_file. ""; 16630 ""Is any of them present in the ""; 16631 "".conf file?"",; 16632 ssl_error());; 16633 return 0;; 16634 }; 16635 ; 16636 if (peer_certificate_optional) {; 16637 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16638 } else {; 16639 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16640 SSL_VERIFY_PEER; 16641 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16642 NULL);; 16643 }; 16644 ; 16645 if (use_default_verify_paths; 16646 && (SSL_CTX_set_default_veri",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:492549,Modifiability,config,config,492549,"state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16587 md5_finish(&md5state, ssl_context_id);; 16588 ; 16589 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16590 (unsigned char *)ssl_context_id,; 16591 sizeof(ssl_context_id));; 16592 ; 16593 if (pem != NULL) {; 16594 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16595 return 0;; 16596 }; 16597 }; 16598 ; 16599 /* Should we support client certificates? */; 16600 /* Default is ""no"". */; 16601 should_verify_peer = 0;; 16602 peer_certificate_optional = 0;; 16603 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16604 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16605 /* Yes, they are mandatory */; 16606 should_verify_peer = 1;; 16607 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16608 ""optional""); 16609 == 0) {; 16610 /* Yes, they are optional */; 16611 should_verify_peer = 1;; 16612 peer_certificate_optional = 1;; 16613 }; 16614 }; 16615 ; 16616 use_default_verify_paths =; 16617 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16618 && (mg_strcasecmp(dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS], ""yes""); 16619 == 0);; 16620 ; 16621 if (should_verify_peer) {; 16622 ca_path = dom_ctx->config[SSL_CA_PATH];; 16623 ca_file = dom_ctx->config[SSL_CA_FILE];; 16624 if (SSL_CTX_load_verify_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16625 != 1) {; 16626 mg_cry_ctx_internal(phys_ctx,; 16627 ""SSL_CTX_load_verify_locations error: %s ""; 16628 ""ssl_verify_peer requires setting ""; 16629 ""either ssl_ca_path or ssl_ca_file. ""; 16630 ""Is any of them present in the ""; 16631 "".conf file?"",; 16632 ssl_error());; 16633 return 0;; 16634 }; 16635 ; 16636 if (peer_certificate_optional) {; 16637 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16638 } else {; 16639 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16640 SSL_VERIFY_PEER; 16641 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16642 NULL);; 16643 }; 16644 ; 16645 if (use_default_verify_paths; 16646 && (SSL_CTX_set_default_veri",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:492793,Modifiability,config,config,492793,"state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16587 md5_finish(&md5state, ssl_context_id);; 16588 ; 16589 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16590 (unsigned char *)ssl_context_id,; 16591 sizeof(ssl_context_id));; 16592 ; 16593 if (pem != NULL) {; 16594 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16595 return 0;; 16596 }; 16597 }; 16598 ; 16599 /* Should we support client certificates? */; 16600 /* Default is ""no"". */; 16601 should_verify_peer = 0;; 16602 peer_certificate_optional = 0;; 16603 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16604 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16605 /* Yes, they are mandatory */; 16606 should_verify_peer = 1;; 16607 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16608 ""optional""); 16609 == 0) {; 16610 /* Yes, they are optional */; 16611 should_verify_peer = 1;; 16612 peer_certificate_optional = 1;; 16613 }; 16614 }; 16615 ; 16616 use_default_verify_paths =; 16617 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16618 && (mg_strcasecmp(dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS], ""yes""); 16619 == 0);; 16620 ; 16621 if (should_verify_peer) {; 16622 ca_path = dom_ctx->config[SSL_CA_PATH];; 16623 ca_file = dom_ctx->config[SSL_CA_FILE];; 16624 if (SSL_CTX_load_verify_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16625 != 1) {; 16626 mg_cry_ctx_internal(phys_ctx,; 16627 ""SSL_CTX_load_verify_locations error: %s ""; 16628 ""ssl_verify_peer requires setting ""; 16629 ""either ssl_ca_path or ssl_ca_file. ""; 16630 ""Is any of them present in the ""; 16631 "".conf file?"",; 16632 ssl_error());; 16633 return 0;; 16634 }; 16635 ; 16636 if (peer_certificate_optional) {; 16637 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16638 } else {; 16639 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16640 SSL_VERIFY_PEER; 16641 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16642 NULL);; 16643 }; 16644 ; 16645 if (use_default_verify_paths; 16646 && (SSL_CTX_set_default_veri",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:492869,Modifiability,config,config,492869,"state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16587 md5_finish(&md5state, ssl_context_id);; 16588 ; 16589 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16590 (unsigned char *)ssl_context_id,; 16591 sizeof(ssl_context_id));; 16592 ; 16593 if (pem != NULL) {; 16594 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16595 return 0;; 16596 }; 16597 }; 16598 ; 16599 /* Should we support client certificates? */; 16600 /* Default is ""no"". */; 16601 should_verify_peer = 0;; 16602 peer_certificate_optional = 0;; 16603 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16604 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16605 /* Yes, they are mandatory */; 16606 should_verify_peer = 1;; 16607 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16608 ""optional""); 16609 == 0) {; 16610 /* Yes, they are optional */; 16611 should_verify_peer = 1;; 16612 peer_certificate_optional = 1;; 16613 }; 16614 }; 16615 ; 16616 use_default_verify_paths =; 16617 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16618 && (mg_strcasecmp(dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS], ""yes""); 16619 == 0);; 16620 ; 16621 if (should_verify_peer) {; 16622 ca_path = dom_ctx->config[SSL_CA_PATH];; 16623 ca_file = dom_ctx->config[SSL_CA_FILE];; 16624 if (SSL_CTX_load_verify_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16625 != 1) {; 16626 mg_cry_ctx_internal(phys_ctx,; 16627 ""SSL_CTX_load_verify_locations error: %s ""; 16628 ""ssl_verify_peer requires setting ""; 16629 ""either ssl_ca_path or ssl_ca_file. ""; 16630 ""Is any of them present in the ""; 16631 "".conf file?"",; 16632 ssl_error());; 16633 return 0;; 16634 }; 16635 ; 16636 if (peer_certificate_optional) {; 16637 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16638 } else {; 16639 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16640 SSL_VERIFY_PEER; 16641 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16642 NULL);; 16643 }; 16644 ; 16645 if (use_default_verify_paths; 16646 && (SSL_CTX_set_default_veri",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:492991,Modifiability,config,config,492991,"state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16587 md5_finish(&md5state, ssl_context_id);; 16588 ; 16589 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16590 (unsigned char *)ssl_context_id,; 16591 sizeof(ssl_context_id));; 16592 ; 16593 if (pem != NULL) {; 16594 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16595 return 0;; 16596 }; 16597 }; 16598 ; 16599 /* Should we support client certificates? */; 16600 /* Default is ""no"". */; 16601 should_verify_peer = 0;; 16602 peer_certificate_optional = 0;; 16603 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16604 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16605 /* Yes, they are mandatory */; 16606 should_verify_peer = 1;; 16607 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16608 ""optional""); 16609 == 0) {; 16610 /* Yes, they are optional */; 16611 should_verify_peer = 1;; 16612 peer_certificate_optional = 1;; 16613 }; 16614 }; 16615 ; 16616 use_default_verify_paths =; 16617 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16618 && (mg_strcasecmp(dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS], ""yes""); 16619 == 0);; 16620 ; 16621 if (should_verify_peer) {; 16622 ca_path = dom_ctx->config[SSL_CA_PATH];; 16623 ca_file = dom_ctx->config[SSL_CA_FILE];; 16624 if (SSL_CTX_load_verify_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16625 != 1) {; 16626 mg_cry_ctx_internal(phys_ctx,; 16627 ""SSL_CTX_load_verify_locations error: %s ""; 16628 ""ssl_verify_peer requires setting ""; 16629 ""either ssl_ca_path or ssl_ca_file. ""; 16630 ""Is any of them present in the ""; 16631 "".conf file?"",; 16632 ssl_error());; 16633 return 0;; 16634 }; 16635 ; 16636 if (peer_certificate_optional) {; 16637 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16638 } else {; 16639 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16640 SSL_VERIFY_PEER; 16641 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16642 NULL);; 16643 }; 16644 ; 16645 if (use_default_verify_paths; 16646 && (SSL_CTX_set_default_veri",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:493038,Modifiability,config,config,493038,"state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16587 md5_finish(&md5state, ssl_context_id);; 16588 ; 16589 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16590 (unsigned char *)ssl_context_id,; 16591 sizeof(ssl_context_id));; 16592 ; 16593 if (pem != NULL) {; 16594 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16595 return 0;; 16596 }; 16597 }; 16598 ; 16599 /* Should we support client certificates? */; 16600 /* Default is ""no"". */; 16601 should_verify_peer = 0;; 16602 peer_certificate_optional = 0;; 16603 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16604 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16605 /* Yes, they are mandatory */; 16606 should_verify_peer = 1;; 16607 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16608 ""optional""); 16609 == 0) {; 16610 /* Yes, they are optional */; 16611 should_verify_peer = 1;; 16612 peer_certificate_optional = 1;; 16613 }; 16614 }; 16615 ; 16616 use_default_verify_paths =; 16617 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16618 && (mg_strcasecmp(dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS], ""yes""); 16619 == 0);; 16620 ; 16621 if (should_verify_peer) {; 16622 ca_path = dom_ctx->config[SSL_CA_PATH];; 16623 ca_file = dom_ctx->config[SSL_CA_FILE];; 16624 if (SSL_CTX_load_verify_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16625 != 1) {; 16626 mg_cry_ctx_internal(phys_ctx,; 16627 ""SSL_CTX_load_verify_locations error: %s ""; 16628 ""ssl_verify_peer requires setting ""; 16629 ""either ssl_ca_path or ssl_ca_file. ""; 16630 ""Is any of them present in the ""; 16631 "".conf file?"",; 16632 ssl_error());; 16633 return 0;; 16634 }; 16635 ; 16636 if (peer_certificate_optional) {; 16637 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16638 } else {; 16639 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16640 SSL_VERIFY_PEER; 16641 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16642 NULL);; 16643 }; 16644 ; 16645 if (use_default_verify_paths; 16646 && (SSL_CTX_set_default_veri",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:493979,Modifiability,config,config,493979,"y_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16625 != 1) {; 16626 mg_cry_ctx_internal(phys_ctx,; 16627 ""SSL_CTX_load_verify_locations error: %s ""; 16628 ""ssl_verify_peer requires setting ""; 16629 ""either ssl_ca_path or ssl_ca_file. ""; 16630 ""Is any of them present in the ""; 16631 "".conf file?"",; 16632 ssl_error());; 16633 return 0;; 16634 }; 16635 ; 16636 if (peer_certificate_optional) {; 16637 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16638 } else {; 16639 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16640 SSL_VERIFY_PEER; 16641 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16642 NULL);; 16643 }; 16644 ; 16645 if (use_default_verify_paths; 16646 && (SSL_CTX_set_default_verify_paths(dom_ctx->ssl_ctx) != 1)) {; 16647 mg_cry_ctx_internal(phys_ctx,; 16648 ""SSL_CTX_set_default_verify_paths error: %s"",; 16649 ssl_error());; 16650 return 0;; 16651 }; 16652 ; 16653 if (dom_ctx->config[SSL_VERIFY_DEPTH]) {; 16654 verify_depth = atoi(dom_ctx->config[SSL_VERIFY_DEPTH]);; 16655 SSL_CTX_set_verify_depth(dom_ctx->ssl_ctx, verify_depth);; 16656 }; 16657 }; 16658 ; 16659 if (dom_ctx->config[SSL_CIPHER_LIST] != NULL) {; 16660 if (SSL_CTX_set_cipher_list(dom_ctx->ssl_ctx,; 16661 dom_ctx->config[SSL_CIPHER_LIST]); 16662 != 1) {; 16663 mg_cry_ctx_internal(phys_ctx,; 16664 ""SSL_CTX_set_cipher_list error: %s"",; 16665 ssl_error());; 16666 }; 16667 }; 16668 ; 16669 /* SSL session caching */; 16670 ssl_cache_timeout = ((dom_ctx->config[SSL_CACHE_TIMEOUT] != NULL); 16671 ? atoi(dom_ctx->config[SSL_CACHE_TIMEOUT]); 16672 : 0);; 16673 if (ssl_cache_timeout > 0) {; 16674 SSL_CTX_set_session_cache_mode(dom_ctx->ssl_ctx, SSL_SESS_CACHE_BOTH);; 16675 /* SSL_CTX_sess_set_cache_size(dom_ctx->ssl_ctx, 10000); ... use; 16676 * default */; 16677 SSL_CTX_set_timeout(dom_ctx->ssl_ctx, (long)ssl_cache_timeout);; 16678 }; 16679 ; 16680#if defined(USE_ALPN); 16681 /* Initialize ALPN only of TLS library (OpenSSL version) supports ALPN */; 16682#if !defined(NO_SSL_DL); 16683 if (!tls_feature_missing[T",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:494043,Modifiability,config,config,494043,"y_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16625 != 1) {; 16626 mg_cry_ctx_internal(phys_ctx,; 16627 ""SSL_CTX_load_verify_locations error: %s ""; 16628 ""ssl_verify_peer requires setting ""; 16629 ""either ssl_ca_path or ssl_ca_file. ""; 16630 ""Is any of them present in the ""; 16631 "".conf file?"",; 16632 ssl_error());; 16633 return 0;; 16634 }; 16635 ; 16636 if (peer_certificate_optional) {; 16637 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16638 } else {; 16639 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16640 SSL_VERIFY_PEER; 16641 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16642 NULL);; 16643 }; 16644 ; 16645 if (use_default_verify_paths; 16646 && (SSL_CTX_set_default_verify_paths(dom_ctx->ssl_ctx) != 1)) {; 16647 mg_cry_ctx_internal(phys_ctx,; 16648 ""SSL_CTX_set_default_verify_paths error: %s"",; 16649 ssl_error());; 16650 return 0;; 16651 }; 16652 ; 16653 if (dom_ctx->config[SSL_VERIFY_DEPTH]) {; 16654 verify_depth = atoi(dom_ctx->config[SSL_VERIFY_DEPTH]);; 16655 SSL_CTX_set_verify_depth(dom_ctx->ssl_ctx, verify_depth);; 16656 }; 16657 }; 16658 ; 16659 if (dom_ctx->config[SSL_CIPHER_LIST] != NULL) {; 16660 if (SSL_CTX_set_cipher_list(dom_ctx->ssl_ctx,; 16661 dom_ctx->config[SSL_CIPHER_LIST]); 16662 != 1) {; 16663 mg_cry_ctx_internal(phys_ctx,; 16664 ""SSL_CTX_set_cipher_list error: %s"",; 16665 ssl_error());; 16666 }; 16667 }; 16668 ; 16669 /* SSL session caching */; 16670 ssl_cache_timeout = ((dom_ctx->config[SSL_CACHE_TIMEOUT] != NULL); 16671 ? atoi(dom_ctx->config[SSL_CACHE_TIMEOUT]); 16672 : 0);; 16673 if (ssl_cache_timeout > 0) {; 16674 SSL_CTX_set_session_cache_mode(dom_ctx->ssl_ctx, SSL_SESS_CACHE_BOTH);; 16675 /* SSL_CTX_sess_set_cache_size(dom_ctx->ssl_ctx, 10000); ... use; 16676 * default */; 16677 SSL_CTX_set_timeout(dom_ctx->ssl_ctx, (long)ssl_cache_timeout);; 16678 }; 16679 ; 16680#if defined(USE_ALPN); 16681 /* Initialize ALPN only of TLS library (OpenSSL version) supports ALPN */; 16682#if !defined(NO_SSL_DL); 16683 if (!tls_feature_missing[T",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:494181,Modifiability,config,config,494181,"y_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16625 != 1) {; 16626 mg_cry_ctx_internal(phys_ctx,; 16627 ""SSL_CTX_load_verify_locations error: %s ""; 16628 ""ssl_verify_peer requires setting ""; 16629 ""either ssl_ca_path or ssl_ca_file. ""; 16630 ""Is any of them present in the ""; 16631 "".conf file?"",; 16632 ssl_error());; 16633 return 0;; 16634 }; 16635 ; 16636 if (peer_certificate_optional) {; 16637 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16638 } else {; 16639 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16640 SSL_VERIFY_PEER; 16641 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16642 NULL);; 16643 }; 16644 ; 16645 if (use_default_verify_paths; 16646 && (SSL_CTX_set_default_verify_paths(dom_ctx->ssl_ctx) != 1)) {; 16647 mg_cry_ctx_internal(phys_ctx,; 16648 ""SSL_CTX_set_default_verify_paths error: %s"",; 16649 ssl_error());; 16650 return 0;; 16651 }; 16652 ; 16653 if (dom_ctx->config[SSL_VERIFY_DEPTH]) {; 16654 verify_depth = atoi(dom_ctx->config[SSL_VERIFY_DEPTH]);; 16655 SSL_CTX_set_verify_depth(dom_ctx->ssl_ctx, verify_depth);; 16656 }; 16657 }; 16658 ; 16659 if (dom_ctx->config[SSL_CIPHER_LIST] != NULL) {; 16660 if (SSL_CTX_set_cipher_list(dom_ctx->ssl_ctx,; 16661 dom_ctx->config[SSL_CIPHER_LIST]); 16662 != 1) {; 16663 mg_cry_ctx_internal(phys_ctx,; 16664 ""SSL_CTX_set_cipher_list error: %s"",; 16665 ssl_error());; 16666 }; 16667 }; 16668 ; 16669 /* SSL session caching */; 16670 ssl_cache_timeout = ((dom_ctx->config[SSL_CACHE_TIMEOUT] != NULL); 16671 ? atoi(dom_ctx->config[SSL_CACHE_TIMEOUT]); 16672 : 0);; 16673 if (ssl_cache_timeout > 0) {; 16674 SSL_CTX_set_session_cache_mode(dom_ctx->ssl_ctx, SSL_SESS_CACHE_BOTH);; 16675 /* SSL_CTX_sess_set_cache_size(dom_ctx->ssl_ctx, 10000); ... use; 16676 * default */; 16677 SSL_CTX_set_timeout(dom_ctx->ssl_ctx, (long)ssl_cache_timeout);; 16678 }; 16679 ; 16680#if defined(USE_ALPN); 16681 /* Initialize ALPN only of TLS library (OpenSSL version) supports ALPN */; 16682#if !defined(NO_SSL_DL); 16683 if (!tls_feature_missing[T",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:494285,Modifiability,config,config,494285,"y_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16625 != 1) {; 16626 mg_cry_ctx_internal(phys_ctx,; 16627 ""SSL_CTX_load_verify_locations error: %s ""; 16628 ""ssl_verify_peer requires setting ""; 16629 ""either ssl_ca_path or ssl_ca_file. ""; 16630 ""Is any of them present in the ""; 16631 "".conf file?"",; 16632 ssl_error());; 16633 return 0;; 16634 }; 16635 ; 16636 if (peer_certificate_optional) {; 16637 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16638 } else {; 16639 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16640 SSL_VERIFY_PEER; 16641 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16642 NULL);; 16643 }; 16644 ; 16645 if (use_default_verify_paths; 16646 && (SSL_CTX_set_default_verify_paths(dom_ctx->ssl_ctx) != 1)) {; 16647 mg_cry_ctx_internal(phys_ctx,; 16648 ""SSL_CTX_set_default_verify_paths error: %s"",; 16649 ssl_error());; 16650 return 0;; 16651 }; 16652 ; 16653 if (dom_ctx->config[SSL_VERIFY_DEPTH]) {; 16654 verify_depth = atoi(dom_ctx->config[SSL_VERIFY_DEPTH]);; 16655 SSL_CTX_set_verify_depth(dom_ctx->ssl_ctx, verify_depth);; 16656 }; 16657 }; 16658 ; 16659 if (dom_ctx->config[SSL_CIPHER_LIST] != NULL) {; 16660 if (SSL_CTX_set_cipher_list(dom_ctx->ssl_ctx,; 16661 dom_ctx->config[SSL_CIPHER_LIST]); 16662 != 1) {; 16663 mg_cry_ctx_internal(phys_ctx,; 16664 ""SSL_CTX_set_cipher_list error: %s"",; 16665 ssl_error());; 16666 }; 16667 }; 16668 ; 16669 /* SSL session caching */; 16670 ssl_cache_timeout = ((dom_ctx->config[SSL_CACHE_TIMEOUT] != NULL); 16671 ? atoi(dom_ctx->config[SSL_CACHE_TIMEOUT]); 16672 : 0);; 16673 if (ssl_cache_timeout > 0) {; 16674 SSL_CTX_set_session_cache_mode(dom_ctx->ssl_ctx, SSL_SESS_CACHE_BOTH);; 16675 /* SSL_CTX_sess_set_cache_size(dom_ctx->ssl_ctx, 10000); ... use; 16676 * default */; 16677 SSL_CTX_set_timeout(dom_ctx->ssl_ctx, (long)ssl_cache_timeout);; 16678 }; 16679 ; 16680#if defined(USE_ALPN); 16681 /* Initialize ALPN only of TLS library (OpenSSL version) supports ALPN */; 16682#if !defined(NO_SSL_DL); 16683 if (!tls_feature_missing[T",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:494524,Modifiability,config,config,494524,"y_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16625 != 1) {; 16626 mg_cry_ctx_internal(phys_ctx,; 16627 ""SSL_CTX_load_verify_locations error: %s ""; 16628 ""ssl_verify_peer requires setting ""; 16629 ""either ssl_ca_path or ssl_ca_file. ""; 16630 ""Is any of them present in the ""; 16631 "".conf file?"",; 16632 ssl_error());; 16633 return 0;; 16634 }; 16635 ; 16636 if (peer_certificate_optional) {; 16637 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16638 } else {; 16639 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16640 SSL_VERIFY_PEER; 16641 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16642 NULL);; 16643 }; 16644 ; 16645 if (use_default_verify_paths; 16646 && (SSL_CTX_set_default_verify_paths(dom_ctx->ssl_ctx) != 1)) {; 16647 mg_cry_ctx_internal(phys_ctx,; 16648 ""SSL_CTX_set_default_verify_paths error: %s"",; 16649 ssl_error());; 16650 return 0;; 16651 }; 16652 ; 16653 if (dom_ctx->config[SSL_VERIFY_DEPTH]) {; 16654 verify_depth = atoi(dom_ctx->config[SSL_VERIFY_DEPTH]);; 16655 SSL_CTX_set_verify_depth(dom_ctx->ssl_ctx, verify_depth);; 16656 }; 16657 }; 16658 ; 16659 if (dom_ctx->config[SSL_CIPHER_LIST] != NULL) {; 16660 if (SSL_CTX_set_cipher_list(dom_ctx->ssl_ctx,; 16661 dom_ctx->config[SSL_CIPHER_LIST]); 16662 != 1) {; 16663 mg_cry_ctx_internal(phys_ctx,; 16664 ""SSL_CTX_set_cipher_list error: %s"",; 16665 ssl_error());; 16666 }; 16667 }; 16668 ; 16669 /* SSL session caching */; 16670 ssl_cache_timeout = ((dom_ctx->config[SSL_CACHE_TIMEOUT] != NULL); 16671 ? atoi(dom_ctx->config[SSL_CACHE_TIMEOUT]); 16672 : 0);; 16673 if (ssl_cache_timeout > 0) {; 16674 SSL_CTX_set_session_cache_mode(dom_ctx->ssl_ctx, SSL_SESS_CACHE_BOTH);; 16675 /* SSL_CTX_sess_set_cache_size(dom_ctx->ssl_ctx, 10000); ... use; 16676 * default */; 16677 SSL_CTX_set_timeout(dom_ctx->ssl_ctx, (long)ssl_cache_timeout);; 16678 }; 16679 ; 16680#if defined(USE_ALPN); 16681 /* Initialize ALPN only of TLS library (OpenSSL version) supports ALPN */; 16682#if !defined(NO_SSL_DL); 16683 if (!tls_feature_missing[T",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:494582,Modifiability,config,config,494582,"y_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16625 != 1) {; 16626 mg_cry_ctx_internal(phys_ctx,; 16627 ""SSL_CTX_load_verify_locations error: %s ""; 16628 ""ssl_verify_peer requires setting ""; 16629 ""either ssl_ca_path or ssl_ca_file. ""; 16630 ""Is any of them present in the ""; 16631 "".conf file?"",; 16632 ssl_error());; 16633 return 0;; 16634 }; 16635 ; 16636 if (peer_certificate_optional) {; 16637 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16638 } else {; 16639 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16640 SSL_VERIFY_PEER; 16641 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16642 NULL);; 16643 }; 16644 ; 16645 if (use_default_verify_paths; 16646 && (SSL_CTX_set_default_verify_paths(dom_ctx->ssl_ctx) != 1)) {; 16647 mg_cry_ctx_internal(phys_ctx,; 16648 ""SSL_CTX_set_default_verify_paths error: %s"",; 16649 ssl_error());; 16650 return 0;; 16651 }; 16652 ; 16653 if (dom_ctx->config[SSL_VERIFY_DEPTH]) {; 16654 verify_depth = atoi(dom_ctx->config[SSL_VERIFY_DEPTH]);; 16655 SSL_CTX_set_verify_depth(dom_ctx->ssl_ctx, verify_depth);; 16656 }; 16657 }; 16658 ; 16659 if (dom_ctx->config[SSL_CIPHER_LIST] != NULL) {; 16660 if (SSL_CTX_set_cipher_list(dom_ctx->ssl_ctx,; 16661 dom_ctx->config[SSL_CIPHER_LIST]); 16662 != 1) {; 16663 mg_cry_ctx_internal(phys_ctx,; 16664 ""SSL_CTX_set_cipher_list error: %s"",; 16665 ssl_error());; 16666 }; 16667 }; 16668 ; 16669 /* SSL session caching */; 16670 ssl_cache_timeout = ((dom_ctx->config[SSL_CACHE_TIMEOUT] != NULL); 16671 ? atoi(dom_ctx->config[SSL_CACHE_TIMEOUT]); 16672 : 0);; 16673 if (ssl_cache_timeout > 0) {; 16674 SSL_CTX_set_session_cache_mode(dom_ctx->ssl_ctx, SSL_SESS_CACHE_BOTH);; 16675 /* SSL_CTX_sess_set_cache_size(dom_ctx->ssl_ctx, 10000); ... use; 16676 * default */; 16677 SSL_CTX_set_timeout(dom_ctx->ssl_ctx, (long)ssl_cache_timeout);; 16678 }; 16679 ; 16680#if defined(USE_ALPN); 16681 /* Initialize ALPN only of TLS library (OpenSSL version) supports ALPN */; 16682#if !defined(NO_SSL_DL); 16683 if (!tls_feature_missing[T",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:495763,Modifiability,config,config,495763,"nfig[SSL_CACHE_TIMEOUT]); 16672 : 0);; 16673 if (ssl_cache_timeout > 0) {; 16674 SSL_CTX_set_session_cache_mode(dom_ctx->ssl_ctx, SSL_SESS_CACHE_BOTH);; 16675 /* SSL_CTX_sess_set_cache_size(dom_ctx->ssl_ctx, 10000); ... use; 16676 * default */; 16677 SSL_CTX_set_timeout(dom_ctx->ssl_ctx, (long)ssl_cache_timeout);; 16678 }; 16679 ; 16680#if defined(USE_ALPN); 16681 /* Initialize ALPN only of TLS library (OpenSSL version) supports ALPN */; 16682#if !defined(NO_SSL_DL); 16683 if (!tls_feature_missing[TLS_ALPN]); 16684#endif; 16685 {; 16686 init_alpn(phys_ctx, dom_ctx);; 16687 }; 16688#endif; 16689 ; 16690 return 1;; 16691}; 16692 ; 16693 ; 16694/* Check if SSL is required.; 16695 * If so, dynamically load SSL library; 16696 * and set up ctx->ssl_ctx pointer. */; 16697static int; 16698init_ssl_ctx(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx); 16699{; 16700 void *ssl_ctx = 0;; 16701 int callback_ret;; 16702 const char *pem;; 16703 const char *chain;; 16704 char ebuf[128];; 16705 ; 16706 if (!phys_ctx) {; 16707 return 0;; 16708 }; 16709 ; 16710 if (!dom_ctx) {; 16711 dom_ctx = &(phys_ctx->dd);; 16712 }; 16713 ; 16714 if (!is_ssl_port_used(dom_ctx->config[LISTENING_PORTS])) {; 16715 /* No SSL port is set. No need to setup SSL. */; 16716 return 1;; 16717 }; 16718 ; 16719 /* Check for external SSL_CTX */; 16720 callback_ret =; 16721 (phys_ctx->callbacks.external_ssl_ctx == NULL); 16722 ? 0; 16723 : (phys_ctx->callbacks.external_ssl_ctx(&ssl_ctx,; 16724 phys_ctx->user_data));; 16725 ; 16726 if (callback_ret < 0) {; 16727 /* Callback exists and returns <0: Initializing failed. */; 16728 mg_cry_ctx_internal(phys_ctx,; 16729 ""external_ssl_ctx callback returned error: %i"",; 16730 callback_ret);; 16731 return 0;; 16732 } else if (callback_ret > 0) {; 16733 /* Callback exists and returns >0: Initializing complete,; 16734 * civetweb should not modify the SSL context. */; 16735 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16736 if (!initialize_openssl(ebuf, sizeof(ebuf))",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:497053,Modifiability,config,config,497053,"26 if (callback_ret < 0) {; 16727 /* Callback exists and returns <0: Initializing failed. */; 16728 mg_cry_ctx_internal(phys_ctx,; 16729 ""external_ssl_ctx callback returned error: %i"",; 16730 callback_ret);; 16731 return 0;; 16732 } else if (callback_ret > 0) {; 16733 /* Callback exists and returns >0: Initializing complete,; 16734 * civetweb should not modify the SSL context. */; 16735 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16736 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16737 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16738 return 0;; 16739 }; 16740 return 1;; 16741 }; 16742 /* If the callback does not exist or return 0, civetweb must initialize; 16743 * the SSL context. Handle ""domain"" callback next. */; 16744 ; 16745 /* Check for external domain SSL_CTX callback. */; 16746 callback_ret = (phys_ctx->callbacks.external_ssl_ctx_domain == NULL); 16747 ? 0; 16748 : (phys_ctx->callbacks.external_ssl_ctx_domain(; 16749 dom_ctx->config[AUTHENTICATION_DOMAIN],; 16750 &ssl_ctx,; 16751 phys_ctx->user_data));; 16752 ; 16753 if (callback_ret < 0) {; 16754 /* Callback < 0: Error. Abort init. */; 16755 mg_cry_ctx_internal(; 16756 phys_ctx,; 16757 ""external_ssl_ctx_domain callback returned error: %i"",; 16758 callback_ret);; 16759 return 0;; 16760 } else if (callback_ret > 0) {; 16761 /* Callback > 0: Consider init done. */; 16762 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16763 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16764 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16765 return 0;; 16766 }; 16767 return 1;; 16768 }; 16769 /* else: external_ssl_ctx/external_ssl_ctx_domain do not exist or return; 16770 * 0, CivetWeb should continue initializing SSL */; 16771 ; 16772 /* If PEM file is not specified and the init_ssl callbacks; 16773 * are not specified, setup will fail. */; 16774 if (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL); 16775 && (phys_ctx->callbacks.init_ssl == NULL); 16776 && (phys_ctx->callbacks.init_ssl_domain == NULL)) {; 16777 /* No certificate and",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:497936,Modifiability,config,config,497936,"tx_domain == NULL); 16747 ? 0; 16748 : (phys_ctx->callbacks.external_ssl_ctx_domain(; 16749 dom_ctx->config[AUTHENTICATION_DOMAIN],; 16750 &ssl_ctx,; 16751 phys_ctx->user_data));; 16752 ; 16753 if (callback_ret < 0) {; 16754 /* Callback < 0: Error. Abort init. */; 16755 mg_cry_ctx_internal(; 16756 phys_ctx,; 16757 ""external_ssl_ctx_domain callback returned error: %i"",; 16758 callback_ret);; 16759 return 0;; 16760 } else if (callback_ret > 0) {; 16761 /* Callback > 0: Consider init done. */; 16762 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16763 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16764 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16765 return 0;; 16766 }; 16767 return 1;; 16768 }; 16769 /* else: external_ssl_ctx/external_ssl_ctx_domain do not exist or return; 16770 * 0, CivetWeb should continue initializing SSL */; 16771 ; 16772 /* If PEM file is not specified and the init_ssl callbacks; 16773 * are not specified, setup will fail. */; 16774 if (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL); 16775 && (phys_ctx->callbacks.init_ssl == NULL); 16776 && (phys_ctx->callbacks.init_ssl_domain == NULL)) {; 16777 /* No certificate and no init_ssl callbacks:; 16778 * Essential data to set up TLS is missing.; 16779 */; 16780 mg_cry_ctx_internal(phys_ctx,; 16781 ""Initializing SSL failed: -%s is not set"",; 16782 config_options[SSL_CERTIFICATE].name);; 16783 return 0;; 16784 }; 16785 ; 16786 /* If a certificate chain is configured, use it. */; 16787 chain = dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 16788 if (chain == NULL) {; 16789 /* Default: certificate chain in PEM file */; 16790 chain = pem;; 16791 }; 16792 if ((chain != NULL) && (*chain == 0)) {; 16793 /* If the chain is an empty string, don't use it. */; 16794 chain = NULL;; 16795 }; 16796 ; 16797 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16798 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16799 return 0;; 16800 }; 16801 ; 16802 return init_ssl_ctx_impl(phys_ctx, dom_ctx, pem, chain);; 16803}; 16804 ; 16805 ; 1",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:498393,Modifiability,config,configured,498393,"6760 } else if (callback_ret > 0) {; 16761 /* Callback > 0: Consider init done. */; 16762 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16763 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16764 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16765 return 0;; 16766 }; 16767 return 1;; 16768 }; 16769 /* else: external_ssl_ctx/external_ssl_ctx_domain do not exist or return; 16770 * 0, CivetWeb should continue initializing SSL */; 16771 ; 16772 /* If PEM file is not specified and the init_ssl callbacks; 16773 * are not specified, setup will fail. */; 16774 if (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL); 16775 && (phys_ctx->callbacks.init_ssl == NULL); 16776 && (phys_ctx->callbacks.init_ssl_domain == NULL)) {; 16777 /* No certificate and no init_ssl callbacks:; 16778 * Essential data to set up TLS is missing.; 16779 */; 16780 mg_cry_ctx_internal(phys_ctx,; 16781 ""Initializing SSL failed: -%s is not set"",; 16782 config_options[SSL_CERTIFICATE].name);; 16783 return 0;; 16784 }; 16785 ; 16786 /* If a certificate chain is configured, use it. */; 16787 chain = dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 16788 if (chain == NULL) {; 16789 /* Default: certificate chain in PEM file */; 16790 chain = pem;; 16791 }; 16792 if ((chain != NULL) && (*chain == 0)) {; 16793 /* If the chain is an empty string, don't use it. */; 16794 chain = NULL;; 16795 }; 16796 ; 16797 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16798 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16799 return 0;; 16800 }; 16801 ; 16802 return init_ssl_ctx_impl(phys_ctx, dom_ctx, pem, chain);; 16803}; 16804 ; 16805 ; 16806static void; 16807uninitialize_openssl(void); 16808{; 16809#if defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0); 16810 ; 16811 if (mg_atomic_dec(&cryptolib_users) == 0) {; 16812 ; 16813 /* Shutdown according to; 16814 * https://wiki.openssl.org/index.php/Library_Initialization#Cleanup; 16815 * http://stackoverflow.com/questions/29845527/how-to-properly-uninitialize-openssl; 16816 */; 16817 CONF_modul",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:498440,Modifiability,config,config,498440," 16764 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16765 return 0;; 16766 }; 16767 return 1;; 16768 }; 16769 /* else: external_ssl_ctx/external_ssl_ctx_domain do not exist or return; 16770 * 0, CivetWeb should continue initializing SSL */; 16771 ; 16772 /* If PEM file is not specified and the init_ssl callbacks; 16773 * are not specified, setup will fail. */; 16774 if (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL); 16775 && (phys_ctx->callbacks.init_ssl == NULL); 16776 && (phys_ctx->callbacks.init_ssl_domain == NULL)) {; 16777 /* No certificate and no init_ssl callbacks:; 16778 * Essential data to set up TLS is missing.; 16779 */; 16780 mg_cry_ctx_internal(phys_ctx,; 16781 ""Initializing SSL failed: -%s is not set"",; 16782 config_options[SSL_CERTIFICATE].name);; 16783 return 0;; 16784 }; 16785 ; 16786 /* If a certificate chain is configured, use it. */; 16787 chain = dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 16788 if (chain == NULL) {; 16789 /* Default: certificate chain in PEM file */; 16790 chain = pem;; 16791 }; 16792 if ((chain != NULL) && (*chain == 0)) {; 16793 /* If the chain is an empty string, don't use it. */; 16794 chain = NULL;; 16795 }; 16796 ; 16797 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16798 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16799 return 0;; 16800 }; 16801 ; 16802 return init_ssl_ctx_impl(phys_ctx, dom_ctx, pem, chain);; 16803}; 16804 ; 16805 ; 16806static void; 16807uninitialize_openssl(void); 16808{; 16809#if defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0); 16810 ; 16811 if (mg_atomic_dec(&cryptolib_users) == 0) {; 16812 ; 16813 /* Shutdown according to; 16814 * https://wiki.openssl.org/index.php/Library_Initialization#Cleanup; 16815 * http://stackoverflow.com/questions/29845527/how-to-properly-uninitialize-openssl; 16816 */; 16817 CONF_modules_unload(1);; 16818#else; 16819 int i;; 16820 ; 16821 if (mg_atomic_dec(&cryptolib_users) == 0) {; 16822 ; 16823 /* Shutdown according to; 16824 * https://wiki.openssl.org/index.php/L",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:500625,Modifiability,config,config,500625,"14 * https://wiki.openssl.org/index.php/Library_Initialization#Cleanup; 16815 * http://stackoverflow.com/questions/29845527/how-to-properly-uninitialize-openssl; 16816 */; 16817 CONF_modules_unload(1);; 16818#else; 16819 int i;; 16820 ; 16821 if (mg_atomic_dec(&cryptolib_users) == 0) {; 16822 ; 16823 /* Shutdown according to; 16824 * https://wiki.openssl.org/index.php/Library_Initialization#Cleanup; 16825 * http://stackoverflow.com/questions/29845527/how-to-properly-uninitialize-openssl; 16826 */; 16827 CRYPTO_set_locking_callback(NULL);; 16828 CRYPTO_set_id_callback(NULL);; 16829 ENGINE_cleanup();; 16830 CONF_modules_unload(1);; 16831 ERR_free_strings();; 16832 EVP_cleanup();; 16833 CRYPTO_cleanup_all_ex_data();; 16834 OPENSSL_REMOVE_THREAD_STATE();; 16835 ; 16836 for (i = 0; i < CRYPTO_num_locks(); i++) {; 16837 pthread_mutex_destroy(&ssl_mutexes[i]);; 16838 }; 16839 mg_free(ssl_mutexes);; 16840 ssl_mutexes = NULL;; 16841#endif /* OPENSSL_API_1_1 || OPENSSL_API_3_0 */; 16842 }; 16843}; 16844#endif /* !defined(NO_SSL) && !defined(USE_MBEDTLS) */; 16845 ; 16846 ; 16847#if !defined(NO_FILESYSTEMS); 16848static int; 16849set_gpass_option(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx); 16850{; 16851 if (phys_ctx) {; 16852 struct mg_file file = STRUCT_FILE_INITIALIZER;; 16853 const char *path;; 16854 struct mg_connection fc;; 16855 if (!dom_ctx) {; 16856 dom_ctx = &(phys_ctx->dd);; 16857 }; 16858 path = dom_ctx->config[GLOBAL_PASSWORDS_FILE];; 16859 if ((path != NULL); 16860 && !mg_stat(fake_connection(&fc, phys_ctx), path, &file.stat)) {; 16861 mg_cry_ctx_internal(phys_ctx,; 16862 ""Cannot open %s: %s"",; 16863 path,; 16864 strerror(ERRNO));; 16865 return 0;; 16866 }; 16867 return 1;; 16868 }; 16869 return 0;; 16870}; 16871#endif /* NO_FILESYSTEMS */; 16872 ; 16873 ; 16874static int; 16875set_acl_option(struct mg_context *phys_ctx); 16876{; 16877 union usa sa;; 16878 memset(&sa, 0, sizeof(sa));; 16879#if defined(USE_IPV6); 16880 sa.sin6.sin6_family = AF_I",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:504442,Modifiability,config,config,504442,"16967 ; 16968 /* http://msdn.microsoft.com/en-us/library/ms739165(v=vs.85).aspx:; 16969 * ""Note that enabling a nonzero timeout on a nonblocking socket; 16970 * is not recommended."", so set it to blocking now */; 16971 set_blocking_mode(conn->client.sock);; 16972 ; 16973 /* Send FIN to the client */; 16974 shutdown(conn->client.sock, SHUTDOWN_WR);; 16975 ; 16976 ; 16977#if defined(_WIN32); 16978 /* Read and discard pending incoming data. If we do not do that and; 16979 * close; 16980 * the socket, the data in the send buffer may be discarded. This; 16981 * behaviour is seen on Windows, when client keeps sending data; 16982 * when server decides to close the connection; then when client; 16983 * does recv() it gets no data back. */; 16984 do {; 16985 n = pull_inner(NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);; 16986 } while (n > 0);; 16987#endif; 16988 ; 16989 if (conn->dom_ctx->config[LINGER_TIMEOUT]) {; 16990 linger_timeout = atoi(conn->dom_ctx->config[LINGER_TIMEOUT]);; 16991 }; 16992 ; 16993 /* Set linger option according to configuration */; 16994 if (linger_timeout >= 0) {; 16995 /* Set linger option to avoid socket hanging out after close. This; 16996 * prevent ephemeral port exhaust problem under high QPS. */; 16997 linger.l_onoff = 1;; 16998 ; 16999#if defined(_MSC_VER); 17000#pragma warning(push); 17001#pragma warning(disable : 4244); 17002#endif; 17003#if defined(GCC_DIAGNOSTIC); 17004#pragma GCC diagnostic push; 17005#pragma GCC diagnostic ignored ""-Wconversion""; 17006#endif; 17007 /* Data type of linger structure elements may differ,; 17008 * so we don't know what cast we need here.; 17009 * Disable type conversion warnings. */; 17010 ; 17011 linger.l_linger = (linger_timeout + 999) / 1000;; 17012 ; 17013#if defined(GCC_DIAGNOSTIC); 17014#pragma GCC diagnostic pop; 17015#endif; 17016#if defined(_MSC_VER); 17017#pragma warning(pop); 17018#endif; 17019 ; 17020 } else {; 17021 linger.l_onoff = 0;; 17022 linger.l_linger = 0;; 17023 }; 17024 ; 17025",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:504512,Modifiability,config,config,504512,"16967 ; 16968 /* http://msdn.microsoft.com/en-us/library/ms739165(v=vs.85).aspx:; 16969 * ""Note that enabling a nonzero timeout on a nonblocking socket; 16970 * is not recommended."", so set it to blocking now */; 16971 set_blocking_mode(conn->client.sock);; 16972 ; 16973 /* Send FIN to the client */; 16974 shutdown(conn->client.sock, SHUTDOWN_WR);; 16975 ; 16976 ; 16977#if defined(_WIN32); 16978 /* Read and discard pending incoming data. If we do not do that and; 16979 * close; 16980 * the socket, the data in the send buffer may be discarded. This; 16981 * behaviour is seen on Windows, when client keeps sending data; 16982 * when server decides to close the connection; then when client; 16983 * does recv() it gets no data back. */; 16984 do {; 16985 n = pull_inner(NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);; 16986 } while (n > 0);; 16987#endif; 16988 ; 16989 if (conn->dom_ctx->config[LINGER_TIMEOUT]) {; 16990 linger_timeout = atoi(conn->dom_ctx->config[LINGER_TIMEOUT]);; 16991 }; 16992 ; 16993 /* Set linger option according to configuration */; 16994 if (linger_timeout >= 0) {; 16995 /* Set linger option to avoid socket hanging out after close. This; 16996 * prevent ephemeral port exhaust problem under high QPS. */; 16997 linger.l_onoff = 1;; 16998 ; 16999#if defined(_MSC_VER); 17000#pragma warning(push); 17001#pragma warning(disable : 4244); 17002#endif; 17003#if defined(GCC_DIAGNOSTIC); 17004#pragma GCC diagnostic push; 17005#pragma GCC diagnostic ignored ""-Wconversion""; 17006#endif; 17007 /* Data type of linger structure elements may differ,; 17008 * so we don't know what cast we need here.; 17009 * Disable type conversion warnings. */; 17010 ; 17011 linger.l_linger = (linger_timeout + 999) / 1000;; 17012 ; 17013#if defined(GCC_DIAGNOSTIC); 17014#pragma GCC diagnostic pop; 17015#endif; 17016#if defined(_MSC_VER); 17017#pragma warning(pop); 17018#endif; 17019 ; 17020 } else {; 17021 linger.l_onoff = 0;; 17022 linger.l_linger = 0;; 17023 }; 17024 ; 17025",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:504595,Modifiability,config,configuration,504595,"16967 ; 16968 /* http://msdn.microsoft.com/en-us/library/ms739165(v=vs.85).aspx:; 16969 * ""Note that enabling a nonzero timeout on a nonblocking socket; 16970 * is not recommended."", so set it to blocking now */; 16971 set_blocking_mode(conn->client.sock);; 16972 ; 16973 /* Send FIN to the client */; 16974 shutdown(conn->client.sock, SHUTDOWN_WR);; 16975 ; 16976 ; 16977#if defined(_WIN32); 16978 /* Read and discard pending incoming data. If we do not do that and; 16979 * close; 16980 * the socket, the data in the send buffer may be discarded. This; 16981 * behaviour is seen on Windows, when client keeps sending data; 16982 * when server decides to close the connection; then when client; 16983 * does recv() it gets no data back. */; 16984 do {; 16985 n = pull_inner(NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);; 16986 } while (n > 0);; 16987#endif; 16988 ; 16989 if (conn->dom_ctx->config[LINGER_TIMEOUT]) {; 16990 linger_timeout = atoi(conn->dom_ctx->config[LINGER_TIMEOUT]);; 16991 }; 16992 ; 16993 /* Set linger option according to configuration */; 16994 if (linger_timeout >= 0) {; 16995 /* Set linger option to avoid socket hanging out after close. This; 16996 * prevent ephemeral port exhaust problem under high QPS. */; 16997 linger.l_onoff = 1;; 16998 ; 16999#if defined(_MSC_VER); 17000#pragma warning(push); 17001#pragma warning(disable : 4244); 17002#endif; 17003#if defined(GCC_DIAGNOSTIC); 17004#pragma GCC diagnostic push; 17005#pragma GCC diagnostic ignored ""-Wconversion""; 17006#endif; 17007 /* Data type of linger structure elements may differ,; 17008 * so we don't know what cast we need here.; 17009 * Disable type conversion warnings. */; 17010 ; 17011 linger.l_linger = (linger_timeout + 999) / 1000;; 17012 ; 17013#if defined(GCC_DIAGNOSTIC); 17014#pragma GCC diagnostic pop; 17015#endif; 17016#if defined(_MSC_VER); 17017#pragma warning(pop); 17018#endif; 17019 ; 17020 } else {; 17021 linger.l_onoff = 0;; 17022 linger.l_linger = 0;; 17023 }; 17024 ; 17025",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:505594,Modifiability,config,configure,505594,"according to configuration */; 16994 if (linger_timeout >= 0) {; 16995 /* Set linger option to avoid socket hanging out after close. This; 16996 * prevent ephemeral port exhaust problem under high QPS. */; 16997 linger.l_onoff = 1;; 16998 ; 16999#if defined(_MSC_VER); 17000#pragma warning(push); 17001#pragma warning(disable : 4244); 17002#endif; 17003#if defined(GCC_DIAGNOSTIC); 17004#pragma GCC diagnostic push; 17005#pragma GCC diagnostic ignored ""-Wconversion""; 17006#endif; 17007 /* Data type of linger structure elements may differ,; 17008 * so we don't know what cast we need here.; 17009 * Disable type conversion warnings. */; 17010 ; 17011 linger.l_linger = (linger_timeout + 999) / 1000;; 17012 ; 17013#if defined(GCC_DIAGNOSTIC); 17014#pragma GCC diagnostic pop; 17015#endif; 17016#if defined(_MSC_VER); 17017#pragma warning(pop); 17018#endif; 17019 ; 17020 } else {; 17021 linger.l_onoff = 0;; 17022 linger.l_linger = 0;; 17023 }; 17024 ; 17025 if (linger_timeout < -1) {; 17026 /* Default: don't configure any linger */; 17027 } else if (getsockopt(conn->client.sock,; 17028 SOL_SOCKET,; 17029 SO_ERROR,; 17030#if defined(_WIN32) /* WinSock uses different data type here */; 17031 (char *)&error_code,; 17032#else; 17033 &error_code,; 17034#endif; 17035 &opt_len); 17036 != 0) {; 17037 /* Cannot determine if socket is already closed. This should; 17038 * not occur and never did in a test. Log an error message; 17039 * and continue. */; 17040 mg_cry_internal(conn,; 17041 ""%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s"",; 17042 __func__,; 17043 strerror(ERRNO));; 17044#if defined(_WIN32); 17045 } else if (error_code == WSAECONNRESET) {; 17046#else; 17047 } else if (error_code == ECONNRESET) {; 17048#endif; 17049 /* Socket already closed by client/peer, close socket without linger; 17050 */; 17051 } else {; 17052 ; 17053 /* Set linger timeout */; 17054 if (setsockopt(conn->client.sock,; 17055 SOL_SOCKET,; 17056 SO_LINGER,; 17057 (char *)&linger,; 17058 sizeof(linger)); 1705",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:523781,Modifiability,config,config,523781," it is; 17590 * addressing the current server. So civetweb can also be used; 17591 * as a proxy server. */; 17592 for (i = 0; abs_uri_protocols[i].proto != NULL; i++) {; 17593 if (mg_strncasecmp(uri,; 17594 abs_uri_protocols[i].proto,; 17595 abs_uri_protocols[i].proto_len); 17596 == 0) {; 17597 ; 17598 hostend = strchr(uri + abs_uri_protocols[i].proto_len, '/');; 17599 if (!hostend) {; 17600 return 0;; 17601 }; 17602 portbegin = strchr(uri + abs_uri_protocols[i].proto_len, ':');; 17603 if (!portbegin) {; 17604 return 3;; 17605 }; 17606 ; 17607 port = strtoul(portbegin + 1, &portend, 10);; 17608 if ((portend != hostend) || (port <= 0) || !is_valid_port(port)) {; 17609 return 0;; 17610 }; 17611 ; 17612 return 4;; 17613 }; 17614 }; 17615 ; 17616 return 0;; 17617}; 17618 ; 17619 ; 17620/* Return NULL or the relative uri at the current server */; 17621static const char *; 17622get_rel_url_at_current_server(const char *uri, const struct mg_connection *conn); 17623{; 17624 const char *server_domain;; 17625 size_t server_domain_len;; 17626 size_t request_domain_len = 0;; 17627 unsigned long port = 0;; 17628 int i, auth_domain_check_enabled;; 17629 const char *hostbegin = NULL;; 17630 const char *hostend = NULL;; 17631 const char *portbegin;; 17632 char *portend;; 17633 ; 17634 auth_domain_check_enabled =; 17635 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK], ""yes"");; 17636 ; 17637 /* DNS is case insensitive, so use case insensitive string compare here; 17638 */; 17639 for (i = 0; abs_uri_protocols[i].proto != NULL; i++) {; 17640 if (mg_strncasecmp(uri,; 17641 abs_uri_protocols[i].proto,; 17642 abs_uri_protocols[i].proto_len); 17643 == 0) {; 17644 ; 17645 hostbegin = uri + abs_uri_protocols[i].proto_len;; 17646 hostend = strchr(hostbegin, '/');; 17647 if (!hostend) {; 17648 return 0;; 17649 }; 17650 portbegin = strchr(hostbegin, ':');; 17651 if ((!portbegin) || (portbegin > hostend)) {; 17652 port = abs_uri_protocols[i].default_port;; 17653 request_domain_len ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:525673,Modifiability,config,config,525673,"7668 /* port remains 0 if the protocol is not found */; 17669 return 0;; 17670 }; 17671 ; 17672 /* Check if the request is directed to a different server. */; 17673 /* First check if the port is the same. */; 17674 if (ntohs(USA_IN_PORT_UNSAFE(&conn->client.lsa)) != port) {; 17675 /* Request is directed to a different port */; 17676 return 0;; 17677 }; 17678 ; 17679 /* Finally check if the server corresponds to the authentication; 17680 * domain of the server (the server domain).; 17681 * Allow full matches (like http://mydomain.com/path/file.ext), and; 17682 * allow subdomain matches (like http://www.mydomain.com/path/file.ext),; 17683 * but do not allow substrings (like; 17684 * http://notmydomain.com/path/file.ext; 17685 * or http://mydomain.com.fake/path/file.ext).; 17686 */; 17687 if (auth_domain_check_enabled) {; 17688 server_domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 17689 server_domain_len = strlen(server_domain);; 17690 if ((server_domain_len == 0) || (hostbegin == NULL)) {; 17691 return 0;; 17692 }; 17693 if ((request_domain_len == server_domain_len); 17694 && (!memcmp(server_domain, hostbegin, server_domain_len))) {; 17695 /* Request is directed to this server - full name match. */; 17696 } else {; 17697 if (request_domain_len < (server_domain_len + 2)) {; 17698 /* Request is directed to another server: The server name; 17699 * is longer than the request name.; 17700 * Drop this case here to avoid overflows in the; 17701 * following checks. */; 17702 return 0;; 17703 }; 17704 if (hostbegin[request_domain_len - server_domain_len - 1] != '.') {; 17705 /* Request is directed to another server: It could be a; 17706 * substring; 17707 * like notmyserver.com */; 17708 return 0;; 17709 }; 17710 if (0; 17711 != memcmp(server_domain,; 17712 hostbegin + request_domain_len - server_domain_len,; 17713 server_domain_len)) {; 17714 /* Request is directed to another server:; 17715 * The server name is different. */; 17716 return 0;; 17717 }; 17718 }; 17719 ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:534542,Modifiability,config,config,534542,"code == 304) {; 17960 conn->content_len = 0;; 17961 }; 17962 } else {; 17963 /* TODO: we should also consider HEAD method */; 17964 if (((conn->response_info.status_code >= 100); 17965 && (conn->response_info.status_code <= 199)); 17966 || (conn->response_info.status_code == 204); 17967 || (conn->response_info.status_code == 304)) {; 17968 conn->content_len = 0;; 17969 } else {; 17970 conn->content_len = -1; /* unknown content length */; 17971 }; 17972 }; 17973 ; 17974 return 1;; 17975}; 17976 ; 17977 ; 17978int; 17979mg_get_response(struct mg_connection *conn,; 17980 char *ebuf,; 17981 size_t ebuf_len,; 17982 int timeout); 17983{; 17984 int err, ret;; 17985 char txt[32]; /* will not overflow */; 17986 char *save_timeout;; 17987 char *new_timeout;; 17988 ; 17989 if (ebuf_len > 0) {; 17990 ebuf[0] = '\0';; 17991 }; 17992 ; 17993 if (!conn) {; 17994 mg_snprintf(conn,; 17995 NULL, /* No truncation check for ebuf */; 17996 ebuf,; 17997 ebuf_len,; 17998 ""%s"",; 17999 ""Parameter error"");; 18000 return -1;; 18001 }; 18002 ; 18003 /* Reset the previous responses */; 18004 conn->data_len = 0;; 18005 ; 18006 /* Implementation of API function for HTTP clients */; 18007 save_timeout = conn->dom_ctx->config[REQUEST_TIMEOUT];; 18008 ; 18009 if (timeout >= 0) {; 18010 mg_snprintf(conn, NULL, txt, sizeof(txt), ""%i"", timeout);; 18011 new_timeout = txt;; 18012 } else {; 18013 new_timeout = NULL;; 18014 }; 18015 ; 18016 conn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;; 18017 ret = get_response(conn, ebuf, ebuf_len, &err);; 18018 conn->dom_ctx->config[REQUEST_TIMEOUT] = save_timeout;; 18019 ; 18020 /* TODO: here, the URI is the http response code */; 18021 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18022 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18023 ; 18024 /* TODO (mid): Define proper return values - maybe return length?; 18025 * For the first test use <0 for error and >0 for OK */; 18026 return (ret == 0) ? -1 : +1;; 18027}; 1802",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:534775,Modifiability,config,config,534775,"code == 304) {; 17960 conn->content_len = 0;; 17961 }; 17962 } else {; 17963 /* TODO: we should also consider HEAD method */; 17964 if (((conn->response_info.status_code >= 100); 17965 && (conn->response_info.status_code <= 199)); 17966 || (conn->response_info.status_code == 204); 17967 || (conn->response_info.status_code == 304)) {; 17968 conn->content_len = 0;; 17969 } else {; 17970 conn->content_len = -1; /* unknown content length */; 17971 }; 17972 }; 17973 ; 17974 return 1;; 17975}; 17976 ; 17977 ; 17978int; 17979mg_get_response(struct mg_connection *conn,; 17980 char *ebuf,; 17981 size_t ebuf_len,; 17982 int timeout); 17983{; 17984 int err, ret;; 17985 char txt[32]; /* will not overflow */; 17986 char *save_timeout;; 17987 char *new_timeout;; 17988 ; 17989 if (ebuf_len > 0) {; 17990 ebuf[0] = '\0';; 17991 }; 17992 ; 17993 if (!conn) {; 17994 mg_snprintf(conn,; 17995 NULL, /* No truncation check for ebuf */; 17996 ebuf,; 17997 ebuf_len,; 17998 ""%s"",; 17999 ""Parameter error"");; 18000 return -1;; 18001 }; 18002 ; 18003 /* Reset the previous responses */; 18004 conn->data_len = 0;; 18005 ; 18006 /* Implementation of API function for HTTP clients */; 18007 save_timeout = conn->dom_ctx->config[REQUEST_TIMEOUT];; 18008 ; 18009 if (timeout >= 0) {; 18010 mg_snprintf(conn, NULL, txt, sizeof(txt), ""%i"", timeout);; 18011 new_timeout = txt;; 18012 } else {; 18013 new_timeout = NULL;; 18014 }; 18015 ; 18016 conn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;; 18017 ret = get_response(conn, ebuf, ebuf_len, &err);; 18018 conn->dom_ctx->config[REQUEST_TIMEOUT] = save_timeout;; 18019 ; 18020 /* TODO: here, the URI is the http response code */; 18021 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18022 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18023 ; 18024 /* TODO (mid): Define proper return values - maybe return length?; 18025 * For the first test use <0 for error and >0 for OK */; 18026 return (ret == 0) ? -1 : +1;; 18027}; 1802",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:534891,Modifiability,config,config,534891,"code == 304) {; 17960 conn->content_len = 0;; 17961 }; 17962 } else {; 17963 /* TODO: we should also consider HEAD method */; 17964 if (((conn->response_info.status_code >= 100); 17965 && (conn->response_info.status_code <= 199)); 17966 || (conn->response_info.status_code == 204); 17967 || (conn->response_info.status_code == 304)) {; 17968 conn->content_len = 0;; 17969 } else {; 17970 conn->content_len = -1; /* unknown content length */; 17971 }; 17972 }; 17973 ; 17974 return 1;; 17975}; 17976 ; 17977 ; 17978int; 17979mg_get_response(struct mg_connection *conn,; 17980 char *ebuf,; 17981 size_t ebuf_len,; 17982 int timeout); 17983{; 17984 int err, ret;; 17985 char txt[32]; /* will not overflow */; 17986 char *save_timeout;; 17987 char *new_timeout;; 17988 ; 17989 if (ebuf_len > 0) {; 17990 ebuf[0] = '\0';; 17991 }; 17992 ; 17993 if (!conn) {; 17994 mg_snprintf(conn,; 17995 NULL, /* No truncation check for ebuf */; 17996 ebuf,; 17997 ebuf_len,; 17998 ""%s"",; 17999 ""Parameter error"");; 18000 return -1;; 18001 }; 18002 ; 18003 /* Reset the previous responses */; 18004 conn->data_len = 0;; 18005 ; 18006 /* Implementation of API function for HTTP clients */; 18007 save_timeout = conn->dom_ctx->config[REQUEST_TIMEOUT];; 18008 ; 18009 if (timeout >= 0) {; 18010 mg_snprintf(conn, NULL, txt, sizeof(txt), ""%i"", timeout);; 18011 new_timeout = txt;; 18012 } else {; 18013 new_timeout = NULL;; 18014 }; 18015 ; 18016 conn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;; 18017 ret = get_response(conn, ebuf, ebuf_len, &err);; 18018 conn->dom_ctx->config[REQUEST_TIMEOUT] = save_timeout;; 18019 ; 18020 /* TODO: here, the URI is the http response code */; 18021 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18022 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18023 ; 18024 /* TODO (mid): Define proper return values - maybe return length?; 18025 * For the first test use <0 for error and >0 for OK */; 18026 return (ret == 0) ? -1 : +1;; 18027}; 1802",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:548066,Modifiability,config,config,548066,"ar *extensions,; 18428 mg_websocket_data_handler data_func,; 18429 mg_websocket_close_handler close_func,; 18430 void *user_data); 18431{; 18432 struct mg_client_options client_options;; 18433 memset(&client_options, 0, sizeof(client_options));; 18434 client_options.host = host;; 18435 client_options.port = port;; 18436 ; 18437 return mg_connect_websocket_client_impl(&client_options,; 18438 use_ssl,; 18439 error_buffer,; 18440 error_buffer_size,; 18441 path,; 18442 origin,; 18443 extensions,; 18444 data_func,; 18445 close_func,; 18446 user_data);; 18447}; 18448 ; 18449struct mg_connection *; 18450mg_connect_websocket_client_secure_extensions(; 18451 const struct mg_client_options *client_options,; 18452 char *error_buffer,; 18453 size_t error_buffer_size,; 18454 const char *path,; 18455 const char *origin,; 18456 const char *extensions,; 18457 mg_websocket_data_handler data_func,; 18458 mg_websocket_close_handler close_func,; 18459 void *user_data); 18460{; 18461 if (!client_options) {; 18462 return NULL;; 18463 }; 18464 return mg_connect_websocket_client_impl(client_options,; 18465 1,; 18466 error_buffer,; 18467 error_buffer_size,; 18468 path,; 18469 origin,; 18470 extensions,; 18471 data_func,; 18472 close_func,; 18473 user_data);; 18474}; 18475 ; 18476/* Prepare connection data structure */; 18477static void; 18478init_connection(struct mg_connection *conn); 18479{; 18480 /* Is keep alive allowed by the server */; 18481 int keep_alive_enabled =; 18482 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_KEEP_ALIVE], ""yes"");; 18483 ; 18484 if (!keep_alive_enabled) {; 18485 conn->must_close = 1;; 18486 }; 18487 ; 18488 /* Important: on new connection, reset the receiving buffer. Credit; 18489 * goes to crule42. */; 18490 conn->data_len = 0;; 18491 conn->handled_requests = 0;; 18492 conn->connection_type = CONNECTION_TYPE_INVALID;; 18493 mg_set_user_connection_data(conn, NULL);; 18494 ; 18495#if defined(USE_SERVER_STATS); 18496 conn->conn_state = 2; /* init */; 18497#endif; 1",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:571450,Modifiability,config,config,571450,"n forever. With; 19144 * TCP keep-alive, next keep-alive handshake will figure out that; 19145 * the client is down and will close the server end.; 19146 * Thanks to Igor Klopov who suggested the patch. */; 19147 if (setsockopt(so.sock,; 19148 SOL_SOCKET,; 19149 SO_KEEPALIVE,; 19150 (SOCK_OPT_TYPE)&on,; 19151 sizeof(on)); 19152 != 0) {; 19153 mg_cry_ctx_internal(; 19154 ctx,; 19155 ""%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s"",; 19156 __func__,; 19157 strerror(ERRNO));; 19158 }; 19159 }; 19160#endif; 19161 ; 19162 /* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced; 19163 * to effectively fill up the underlying IP packet payload and; 19164 * reduce the overhead of sending lots of small buffers. However; 19165 * this hurts the server's throughput (ie. operations per second); 19166 * when HTTP 1.1 persistent connections are used and the responses; 19167 * are relatively small (eg. less than 1400 bytes).; 19168 */; 19169 if ((ctx->dd.config[CONFIG_TCP_NODELAY] != NULL); 19170 && (!strcmp(ctx->dd.config[CONFIG_TCP_NODELAY], ""1""))) {; 19171 if (set_tcp_nodelay(&so, 1) != 0) {; 19172 mg_cry_ctx_internal(; 19173 ctx,; 19174 ""%s: setsockopt(IPPROTO_TCP TCP_NODELAY) failed: %s"",; 19175 __func__,; 19176 strerror(ERRNO));; 19177 }; 19178 }; 19179 ; 19180 /* The ""non blocking"" property should already be; 19181 * inherited from the parent socket. Set it for; 19182 * non-compliant socket implementations. */; 19183 set_non_blocking_mode(so.sock);; 19184 ; 19185 so.in_use = 0;; 19186 produce_socket(ctx, &so);; 19187 }; 19188}; 19189 ; 19190 ; 19191static void; 19192master_thread_run(struct mg_context *ctx); 19193{; 19194 struct mg_workerTLS tls;; 19195 struct mg_pollfd *pfd;; 19196 unsigned int i;; 19197 unsigned int workerthreadcount;; 19198 ; 19199 if (!ctx) {; 19200 return;; 19201 }; 19202 ; 19203 mg_set_thread_name(""master"");; 19204 ; 19205 /* Increase priority of the master thread */; 19206#if defined(_WIN32); 19207 SetThreadPriority(GetCurrentThread(), ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:571513,Modifiability,config,config,571513,"; 19147 if (setsockopt(so.sock,; 19148 SOL_SOCKET,; 19149 SO_KEEPALIVE,; 19150 (SOCK_OPT_TYPE)&on,; 19151 sizeof(on)); 19152 != 0) {; 19153 mg_cry_ctx_internal(; 19154 ctx,; 19155 ""%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s"",; 19156 __func__,; 19157 strerror(ERRNO));; 19158 }; 19159 }; 19160#endif; 19161 ; 19162 /* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced; 19163 * to effectively fill up the underlying IP packet payload and; 19164 * reduce the overhead of sending lots of small buffers. However; 19165 * this hurts the server's throughput (ie. operations per second); 19166 * when HTTP 1.1 persistent connections are used and the responses; 19167 * are relatively small (eg. less than 1400 bytes).; 19168 */; 19169 if ((ctx->dd.config[CONFIG_TCP_NODELAY] != NULL); 19170 && (!strcmp(ctx->dd.config[CONFIG_TCP_NODELAY], ""1""))) {; 19171 if (set_tcp_nodelay(&so, 1) != 0) {; 19172 mg_cry_ctx_internal(; 19173 ctx,; 19174 ""%s: setsockopt(IPPROTO_TCP TCP_NODELAY) failed: %s"",; 19175 __func__,; 19176 strerror(ERRNO));; 19177 }; 19178 }; 19179 ; 19180 /* The ""non blocking"" property should already be; 19181 * inherited from the parent socket. Set it for; 19182 * non-compliant socket implementations. */; 19183 set_non_blocking_mode(so.sock);; 19184 ; 19185 so.in_use = 0;; 19186 produce_socket(ctx, &so);; 19187 }; 19188}; 19189 ; 19190 ; 19191static void; 19192master_thread_run(struct mg_context *ctx); 19193{; 19194 struct mg_workerTLS tls;; 19195 struct mg_pollfd *pfd;; 19196 unsigned int i;; 19197 unsigned int workerthreadcount;; 19198 ; 19199 if (!ctx) {; 19200 return;; 19201 }; 19202 ; 19203 mg_set_thread_name(""master"");; 19204 ; 19205 /* Increase priority of the master thread */; 19206#if defined(_WIN32); 19207 SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);; 19208#elif defined(USE_MASTER_THREAD_PRIORITY); 19209 int min_prio = sched_get_priority_min(SCHED_RR);; 19210 int max_prio = sched_get_priority_max(SCHED_RR);; 19211 if ((mi",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:571827,Modifiability,inherit,inherited,571827,"; 19147 if (setsockopt(so.sock,; 19148 SOL_SOCKET,; 19149 SO_KEEPALIVE,; 19150 (SOCK_OPT_TYPE)&on,; 19151 sizeof(on)); 19152 != 0) {; 19153 mg_cry_ctx_internal(; 19154 ctx,; 19155 ""%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s"",; 19156 __func__,; 19157 strerror(ERRNO));; 19158 }; 19159 }; 19160#endif; 19161 ; 19162 /* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced; 19163 * to effectively fill up the underlying IP packet payload and; 19164 * reduce the overhead of sending lots of small buffers. However; 19165 * this hurts the server's throughput (ie. operations per second); 19166 * when HTTP 1.1 persistent connections are used and the responses; 19167 * are relatively small (eg. less than 1400 bytes).; 19168 */; 19169 if ((ctx->dd.config[CONFIG_TCP_NODELAY] != NULL); 19170 && (!strcmp(ctx->dd.config[CONFIG_TCP_NODELAY], ""1""))) {; 19171 if (set_tcp_nodelay(&so, 1) != 0) {; 19172 mg_cry_ctx_internal(; 19173 ctx,; 19174 ""%s: setsockopt(IPPROTO_TCP TCP_NODELAY) failed: %s"",; 19175 __func__,; 19176 strerror(ERRNO));; 19177 }; 19178 }; 19179 ; 19180 /* The ""non blocking"" property should already be; 19181 * inherited from the parent socket. Set it for; 19182 * non-compliant socket implementations. */; 19183 set_non_blocking_mode(so.sock);; 19184 ; 19185 so.in_use = 0;; 19186 produce_socket(ctx, &so);; 19187 }; 19188}; 19189 ; 19190 ; 19191static void; 19192master_thread_run(struct mg_context *ctx); 19193{; 19194 struct mg_workerTLS tls;; 19195 struct mg_pollfd *pfd;; 19196 unsigned int i;; 19197 unsigned int workerthreadcount;; 19198 ; 19199 if (!ctx) {; 19200 return;; 19201 }; 19202 ; 19203 mg_set_thread_name(""master"");; 19204 ; 19205 /* Increase priority of the master thread */; 19206#if defined(_WIN32); 19207 SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);; 19208#elif defined(USE_MASTER_THREAD_PRIORITY); 19209 int min_prio = sched_get_priority_min(SCHED_RR);; 19210 int max_prio = sched_get_priority_max(SCHED_RR);; 19211 if ((mi",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:579743,Modifiability,config,config,579743,"SIGPIPE, &sa, NULL);; 19387#endif; 19388 ; 19389 master_thread_run((struct mg_context *)thread_func_param);; 19390 return NULL;; 19391}; 19392#endif /* _WIN32 */; 19393 ; 19394 ; 19395static void; 19396free_context(struct mg_context *ctx); 19397{; 19398 int i;; 19399 struct mg_handler_info *tmp_rh;; 19400 ; 19401 if (ctx == NULL) {; 19402 return;; 19403 }; 19404 ; 19405 /* Call user callback */; 19406 if (ctx->callbacks.exit_context) {; 19407 ctx->callbacks.exit_context(ctx);; 19408 }; 19409 ; 19410 /* All threads exited, no sync is needed. Destroy thread mutex and; 19411 * condvars; 19412 */; 19413 (void)pthread_mutex_destroy(&ctx->thread_mutex);; 19414 ; 19415#if defined(ALTERNATIVE_QUEUE); 19416 mg_free(ctx->client_socks);; 19417 if (ctx->client_wait_events != NULL) {; 19418 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 19419 event_destroy(ctx->client_wait_events[i]);; 19420 }; 19421 mg_free(ctx->client_wait_events);; 19422 }; 19423#else; 19424 (void)pthread_cond_destroy(&ctx->sq_empty);; 19425 (void)pthread_cond_destroy(&ctx->sq_full);; 19426 mg_free(ctx->squeue);; 19427#endif; 19428 ; 19429 /* Destroy other context global data structures mutex */; 19430 (void)pthread_mutex_destroy(&ctx->nonce_mutex);; 19431 ; 19432#if defined(USE_LUA); 19433 (void)pthread_mutex_destroy(&ctx->lua_bg_mutex);; 19434#endif; 19435 ; 19436 /* Deallocate config parameters */; 19437 for (i = 0; i < NUM_OPTIONS; i++) {; 19438 if (ctx->dd.config[i] != NULL) {; 19439#if defined(_MSC_VER); 19440#pragma warning(suppress : 6001); 19441#endif; 19442 mg_free(ctx->dd.config[i]);; 19443 }; 19444 }; 19445 ; 19446 /* Deallocate request handlers */; 19447 while (ctx->dd.handlers) {; 19448 tmp_rh = ctx->dd.handlers;; 19449 ctx->dd.handlers = tmp_rh->next;; 19450 mg_free(tmp_rh->uri);; 19451 mg_free(tmp_rh);; 19452 }; 19453 ; 19454#if defined(USE_MBEDTLS); 19455 if (ctx->dd.ssl_ctx != NULL) {; 19456 mbed_sslctx_uninit(ctx->dd.ssl_ctx);; 19457 mg_free(ctx->dd.ssl_ctx);; 19458 ctx->dd.ssl_",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:579826,Modifiability,config,config,579826,"ads exited, no sync is needed. Destroy thread mutex and; 19411 * condvars; 19412 */; 19413 (void)pthread_mutex_destroy(&ctx->thread_mutex);; 19414 ; 19415#if defined(ALTERNATIVE_QUEUE); 19416 mg_free(ctx->client_socks);; 19417 if (ctx->client_wait_events != NULL) {; 19418 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 19419 event_destroy(ctx->client_wait_events[i]);; 19420 }; 19421 mg_free(ctx->client_wait_events);; 19422 }; 19423#else; 19424 (void)pthread_cond_destroy(&ctx->sq_empty);; 19425 (void)pthread_cond_destroy(&ctx->sq_full);; 19426 mg_free(ctx->squeue);; 19427#endif; 19428 ; 19429 /* Destroy other context global data structures mutex */; 19430 (void)pthread_mutex_destroy(&ctx->nonce_mutex);; 19431 ; 19432#if defined(USE_LUA); 19433 (void)pthread_mutex_destroy(&ctx->lua_bg_mutex);; 19434#endif; 19435 ; 19436 /* Deallocate config parameters */; 19437 for (i = 0; i < NUM_OPTIONS; i++) {; 19438 if (ctx->dd.config[i] != NULL) {; 19439#if defined(_MSC_VER); 19440#pragma warning(suppress : 6001); 19441#endif; 19442 mg_free(ctx->dd.config[i]);; 19443 }; 19444 }; 19445 ; 19446 /* Deallocate request handlers */; 19447 while (ctx->dd.handlers) {; 19448 tmp_rh = ctx->dd.handlers;; 19449 ctx->dd.handlers = tmp_rh->next;; 19450 mg_free(tmp_rh->uri);; 19451 mg_free(tmp_rh);; 19452 }; 19453 ; 19454#if defined(USE_MBEDTLS); 19455 if (ctx->dd.ssl_ctx != NULL) {; 19456 mbed_sslctx_uninit(ctx->dd.ssl_ctx);; 19457 mg_free(ctx->dd.ssl_ctx);; 19458 ctx->dd.ssl_ctx = NULL;; 19459 }; 19460 ; 19461#elif !defined(NO_SSL); 19462 /* Deallocate SSL context */; 19463 if (ctx->dd.ssl_ctx != NULL) {; 19464 void *ssl_ctx = (void *)ctx->dd.ssl_ctx;; 19465 int callback_ret =; 19466 (ctx->callbacks.external_ssl_ctx == NULL); 19467 ? 0; 19468 : (ctx->callbacks.external_ssl_ctx(&ssl_ctx, ctx->user_data));; 19469 ; 19470 if (callback_ret == 0) {; 19471 SSL_CTX_free(ctx->dd.ssl_ctx);; 19472 }; 19473 /* else: ignore error and ommit SSL_CTX_free in case; 19474 * callback_ret is 1 */; 19",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:579950,Modifiability,config,config,579950,"estroy(&ctx->thread_mutex);; 19414 ; 19415#if defined(ALTERNATIVE_QUEUE); 19416 mg_free(ctx->client_socks);; 19417 if (ctx->client_wait_events != NULL) {; 19418 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 19419 event_destroy(ctx->client_wait_events[i]);; 19420 }; 19421 mg_free(ctx->client_wait_events);; 19422 }; 19423#else; 19424 (void)pthread_cond_destroy(&ctx->sq_empty);; 19425 (void)pthread_cond_destroy(&ctx->sq_full);; 19426 mg_free(ctx->squeue);; 19427#endif; 19428 ; 19429 /* Destroy other context global data structures mutex */; 19430 (void)pthread_mutex_destroy(&ctx->nonce_mutex);; 19431 ; 19432#if defined(USE_LUA); 19433 (void)pthread_mutex_destroy(&ctx->lua_bg_mutex);; 19434#endif; 19435 ; 19436 /* Deallocate config parameters */; 19437 for (i = 0; i < NUM_OPTIONS; i++) {; 19438 if (ctx->dd.config[i] != NULL) {; 19439#if defined(_MSC_VER); 19440#pragma warning(suppress : 6001); 19441#endif; 19442 mg_free(ctx->dd.config[i]);; 19443 }; 19444 }; 19445 ; 19446 /* Deallocate request handlers */; 19447 while (ctx->dd.handlers) {; 19448 tmp_rh = ctx->dd.handlers;; 19449 ctx->dd.handlers = tmp_rh->next;; 19450 mg_free(tmp_rh->uri);; 19451 mg_free(tmp_rh);; 19452 }; 19453 ; 19454#if defined(USE_MBEDTLS); 19455 if (ctx->dd.ssl_ctx != NULL) {; 19456 mbed_sslctx_uninit(ctx->dd.ssl_ctx);; 19457 mg_free(ctx->dd.ssl_ctx);; 19458 ctx->dd.ssl_ctx = NULL;; 19459 }; 19460 ; 19461#elif !defined(NO_SSL); 19462 /* Deallocate SSL context */; 19463 if (ctx->dd.ssl_ctx != NULL) {; 19464 void *ssl_ctx = (void *)ctx->dd.ssl_ctx;; 19465 int callback_ret =; 19466 (ctx->callbacks.external_ssl_ctx == NULL); 19467 ? 0; 19468 : (ctx->callbacks.external_ssl_ctx(&ssl_ctx, ctx->user_data));; 19469 ; 19470 if (callback_ret == 0) {; 19471 SSL_CTX_free(ctx->dd.ssl_ctx);; 19472 }; 19473 /* else: ignore error and ommit SSL_CTX_free in case; 19474 * callback_ret is 1 */; 19475 }; 19476#endif /* !NO_SSL */; 19477 ; 19478 /* Deallocate worker thread ID array */; 19479 mg_free(ctx->worke",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:588885,Modifiability,config,configuration,588885,"19712 exit_callback = init->callbacks->exit_context;; 19713 /* The exit callback is activated once the context is successfully; 19714 * created. It should not be called, if an incomplete context object; 19715 * is deleted during a failed initialization. */; 19716 ctx->callbacks.exit_context = 0;; 19717 }; 19718 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19719 ctx->dd.handlers = NULL;; 19720 ctx->dd.next = NULL;; 19721 ; 19722#if defined(USE_LUA); 19723 lua_ctx_init(ctx);; 19724#endif; 19725 ; 19726 /* Store options */; 19727 while (options && (name = *options++) != NULL) {; 19728 if ((idx = get_option_index(name)) == -1) {; 19729 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19730 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19731 mg_snprintf(NULL,; 19732 NULL, /* No truncation check for error buffers */; 19733 error->text,; 19734 error->text_buffer_size,; 19735 ""Invalid configuration option: %s"",; 19736 name);; 19737 }; 19738 free_context(ctx);; 19739 pthread_setspecific(sTlsKey, NULL);; 19740 return NULL;; 19741 } else if ((value = *options++) == NULL) {; 19742 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19743 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19744 mg_snprintf(NULL,; 19745 NULL, /* No truncation check for error buffers */; 19746 error->text,; 19747 error->text_buffer_size,; 19748 ""Invalid configuration option value: %s"",; 19749 name);; 19750 }; 19751 free_context(ctx);; 19752 pthread_setspecific(sTlsKey, NULL);; 19753 return NULL;; 19754 }; 19755 if (ctx->dd.config[idx] != NULL) {; 19756 /* A duplicate configuration option is not an error - the last; 19757 * option value will be used. */; 19758 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19759 mg_free(ctx->dd.config[idx]);; 19760 }; 19761 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19762 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19763 }; 19764 ; 19765 /* Set default value if needed */; 19766 for ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:589361,Modifiability,config,configuration,589361,"19712 exit_callback = init->callbacks->exit_context;; 19713 /* The exit callback is activated once the context is successfully; 19714 * created. It should not be called, if an incomplete context object; 19715 * is deleted during a failed initialization. */; 19716 ctx->callbacks.exit_context = 0;; 19717 }; 19718 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19719 ctx->dd.handlers = NULL;; 19720 ctx->dd.next = NULL;; 19721 ; 19722#if defined(USE_LUA); 19723 lua_ctx_init(ctx);; 19724#endif; 19725 ; 19726 /* Store options */; 19727 while (options && (name = *options++) != NULL) {; 19728 if ((idx = get_option_index(name)) == -1) {; 19729 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19730 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19731 mg_snprintf(NULL,; 19732 NULL, /* No truncation check for error buffers */; 19733 error->text,; 19734 error->text_buffer_size,; 19735 ""Invalid configuration option: %s"",; 19736 name);; 19737 }; 19738 free_context(ctx);; 19739 pthread_setspecific(sTlsKey, NULL);; 19740 return NULL;; 19741 } else if ((value = *options++) == NULL) {; 19742 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19743 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19744 mg_snprintf(NULL,; 19745 NULL, /* No truncation check for error buffers */; 19746 error->text,; 19747 error->text_buffer_size,; 19748 ""Invalid configuration option value: %s"",; 19749 name);; 19750 }; 19751 free_context(ctx);; 19752 pthread_setspecific(sTlsKey, NULL);; 19753 return NULL;; 19754 }; 19755 if (ctx->dd.config[idx] != NULL) {; 19756 /* A duplicate configuration option is not an error - the last; 19757 * option value will be used. */; 19758 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19759 mg_free(ctx->dd.config[idx]);; 19760 }; 19761 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19762 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19763 }; 19764 ; 19765 /* Set default value if needed */; 19766 for ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:589534,Modifiability,config,config,589534,"e)) == -1) {; 19729 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19730 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19731 mg_snprintf(NULL,; 19732 NULL, /* No truncation check for error buffers */; 19733 error->text,; 19734 error->text_buffer_size,; 19735 ""Invalid configuration option: %s"",; 19736 name);; 19737 }; 19738 free_context(ctx);; 19739 pthread_setspecific(sTlsKey, NULL);; 19740 return NULL;; 19741 } else if ((value = *options++) == NULL) {; 19742 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19743 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19744 mg_snprintf(NULL,; 19745 NULL, /* No truncation check for error buffers */; 19746 error->text,; 19747 error->text_buffer_size,; 19748 ""Invalid configuration option value: %s"",; 19749 name);; 19750 }; 19751 free_context(ctx);; 19752 pthread_setspecific(sTlsKey, NULL);; 19753 return NULL;; 19754 }; 19755 if (ctx->dd.config[idx] != NULL) {; 19756 /* A duplicate configuration option is not an error - the last; 19757 * option value will be used. */; 19758 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19759 mg_free(ctx->dd.config[idx]);; 19760 }; 19761 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19762 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19763 }; 19764 ; 19765 /* Set default value if needed */; 19766 for (i = 0; config_options[i].name != NULL; i++) {; 19767 default_value = config_options[i].default_value;; 19768 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19769 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19770 }; 19771 }; 19772 ; 19773 /* Request size option */; 19774 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19775 if (itmp < 1024) {; 19776 mg_cry_ctx_internal(ctx,; 19777 ""%s too small"",; 19778 config_options[MAX_REQUEST_SIZE].name);; 19779 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19780 mg_snprintf(NULL,; 19781 NULL, /* No truncation check for error buffers */; 19782 error->text,;",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:589579,Modifiability,config,configuration,589579,"e)) == -1) {; 19729 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19730 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19731 mg_snprintf(NULL,; 19732 NULL, /* No truncation check for error buffers */; 19733 error->text,; 19734 error->text_buffer_size,; 19735 ""Invalid configuration option: %s"",; 19736 name);; 19737 }; 19738 free_context(ctx);; 19739 pthread_setspecific(sTlsKey, NULL);; 19740 return NULL;; 19741 } else if ((value = *options++) == NULL) {; 19742 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19743 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19744 mg_snprintf(NULL,; 19745 NULL, /* No truncation check for error buffers */; 19746 error->text,; 19747 error->text_buffer_size,; 19748 ""Invalid configuration option value: %s"",; 19749 name);; 19750 }; 19751 free_context(ctx);; 19752 pthread_setspecific(sTlsKey, NULL);; 19753 return NULL;; 19754 }; 19755 if (ctx->dd.config[idx] != NULL) {; 19756 /* A duplicate configuration option is not an error - the last; 19757 * option value will be used. */; 19758 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19759 mg_free(ctx->dd.config[idx]);; 19760 }; 19761 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19762 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19763 }; 19764 ; 19765 /* Set default value if needed */; 19766 for (i = 0; config_options[i].name != NULL; i++) {; 19767 default_value = config_options[i].default_value;; 19768 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19769 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19770 }; 19771 }; 19772 ; 19773 /* Request size option */; 19774 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19775 if (itmp < 1024) {; 19776 mg_cry_ctx_internal(ctx,; 19777 ""%s too small"",; 19778 config_options[MAX_REQUEST_SIZE].name);; 19779 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19780 mg_snprintf(NULL,; 19781 NULL, /* No truncation check for error buffers */; 19782 error->text,;",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:589761,Modifiability,config,config,589761,"runcation check for error buffers */; 19733 error->text,; 19734 error->text_buffer_size,; 19735 ""Invalid configuration option: %s"",; 19736 name);; 19737 }; 19738 free_context(ctx);; 19739 pthread_setspecific(sTlsKey, NULL);; 19740 return NULL;; 19741 } else if ((value = *options++) == NULL) {; 19742 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19743 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19744 mg_snprintf(NULL,; 19745 NULL, /* No truncation check for error buffers */; 19746 error->text,; 19747 error->text_buffer_size,; 19748 ""Invalid configuration option value: %s"",; 19749 name);; 19750 }; 19751 free_context(ctx);; 19752 pthread_setspecific(sTlsKey, NULL);; 19753 return NULL;; 19754 }; 19755 if (ctx->dd.config[idx] != NULL) {; 19756 /* A duplicate configuration option is not an error - the last; 19757 * option value will be used. */; 19758 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19759 mg_free(ctx->dd.config[idx]);; 19760 }; 19761 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19762 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19763 }; 19764 ; 19765 /* Set default value if needed */; 19766 for (i = 0; config_options[i].name != NULL; i++) {; 19767 default_value = config_options[i].default_value;; 19768 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19769 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19770 }; 19771 }; 19772 ; 19773 /* Request size option */; 19774 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19775 if (itmp < 1024) {; 19776 mg_cry_ctx_internal(ctx,; 19777 ""%s too small"",; 19778 config_options[MAX_REQUEST_SIZE].name);; 19779 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19780 mg_snprintf(NULL,; 19781 NULL, /* No truncation check for error buffers */; 19782 error->text,; 19783 error->text_buffer_size,; 19784 ""Invalid configuration option value: %s"",; 19785 config_options[MAX_REQUEST_SIZE].name);; 19786 }; 19787 free_context(ctx);; 19788 pthread_sets",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:589799,Modifiability,config,config,589799,"uration option: %s"",; 19736 name);; 19737 }; 19738 free_context(ctx);; 19739 pthread_setspecific(sTlsKey, NULL);; 19740 return NULL;; 19741 } else if ((value = *options++) == NULL) {; 19742 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19743 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19744 mg_snprintf(NULL,; 19745 NULL, /* No truncation check for error buffers */; 19746 error->text,; 19747 error->text_buffer_size,; 19748 ""Invalid configuration option value: %s"",; 19749 name);; 19750 }; 19751 free_context(ctx);; 19752 pthread_setspecific(sTlsKey, NULL);; 19753 return NULL;; 19754 }; 19755 if (ctx->dd.config[idx] != NULL) {; 19756 /* A duplicate configuration option is not an error - the last; 19757 * option value will be used. */; 19758 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19759 mg_free(ctx->dd.config[idx]);; 19760 }; 19761 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19762 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19763 }; 19764 ; 19765 /* Set default value if needed */; 19766 for (i = 0; config_options[i].name != NULL; i++) {; 19767 default_value = config_options[i].default_value;; 19768 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19769 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19770 }; 19771 }; 19772 ; 19773 /* Request size option */; 19774 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19775 if (itmp < 1024) {; 19776 mg_cry_ctx_internal(ctx,; 19777 ""%s too small"",; 19778 config_options[MAX_REQUEST_SIZE].name);; 19779 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19780 mg_snprintf(NULL,; 19781 NULL, /* No truncation check for error buffers */; 19782 error->text,; 19783 error->text_buffer_size,; 19784 ""Invalid configuration option value: %s"",; 19785 config_options[MAX_REQUEST_SIZE].name);; 19786 }; 19787 free_context(ctx);; 19788 pthread_setspecific(sTlsKey, NULL);; 19789 return NULL;; 19790 }; 19791 ctx->max_request_size = (unsigned)itmp;; 19792 ; 197",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:590081,Modifiability,config,config,590081,"tion value cannot be NULL"", name);; 19743 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19744 mg_snprintf(NULL,; 19745 NULL, /* No truncation check for error buffers */; 19746 error->text,; 19747 error->text_buffer_size,; 19748 ""Invalid configuration option value: %s"",; 19749 name);; 19750 }; 19751 free_context(ctx);; 19752 pthread_setspecific(sTlsKey, NULL);; 19753 return NULL;; 19754 }; 19755 if (ctx->dd.config[idx] != NULL) {; 19756 /* A duplicate configuration option is not an error - the last; 19757 * option value will be used. */; 19758 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19759 mg_free(ctx->dd.config[idx]);; 19760 }; 19761 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19762 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19763 }; 19764 ; 19765 /* Set default value if needed */; 19766 for (i = 0; config_options[i].name != NULL; i++) {; 19767 default_value = config_options[i].default_value;; 19768 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19769 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19770 }; 19771 }; 19772 ; 19773 /* Request size option */; 19774 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19775 if (itmp < 1024) {; 19776 mg_cry_ctx_internal(ctx,; 19777 ""%s too small"",; 19778 config_options[MAX_REQUEST_SIZE].name);; 19779 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19780 mg_snprintf(NULL,; 19781 NULL, /* No truncation check for error buffers */; 19782 error->text,; 19783 error->text_buffer_size,; 19784 ""Invalid configuration option value: %s"",; 19785 config_options[MAX_REQUEST_SIZE].name);; 19786 }; 19787 free_context(ctx);; 19788 pthread_setspecific(sTlsKey, NULL);; 19789 return NULL;; 19790 }; 19791 ctx->max_request_size = (unsigned)itmp;; 19792 ; 19793 /* Queue length */; 19794#if !defined(ALTERNATIVE_QUEUE); 19795 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19796 if (itmp < 1) {; 19797 mg_cry_ctx_internal(ctx,; 19798 ""%s too small"",; 19799 config_options[CO",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:590145,Modifiability,config,config,590145," 19744 mg_snprintf(NULL,; 19745 NULL, /* No truncation check for error buffers */; 19746 error->text,; 19747 error->text_buffer_size,; 19748 ""Invalid configuration option value: %s"",; 19749 name);; 19750 }; 19751 free_context(ctx);; 19752 pthread_setspecific(sTlsKey, NULL);; 19753 return NULL;; 19754 }; 19755 if (ctx->dd.config[idx] != NULL) {; 19756 /* A duplicate configuration option is not an error - the last; 19757 * option value will be used. */; 19758 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19759 mg_free(ctx->dd.config[idx]);; 19760 }; 19761 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19762 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19763 }; 19764 ; 19765 /* Set default value if needed */; 19766 for (i = 0; config_options[i].name != NULL; i++) {; 19767 default_value = config_options[i].default_value;; 19768 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19769 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19770 }; 19771 }; 19772 ; 19773 /* Request size option */; 19774 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19775 if (itmp < 1024) {; 19776 mg_cry_ctx_internal(ctx,; 19777 ""%s too small"",; 19778 config_options[MAX_REQUEST_SIZE].name);; 19779 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19780 mg_snprintf(NULL,; 19781 NULL, /* No truncation check for error buffers */; 19782 error->text,; 19783 error->text_buffer_size,; 19784 ""Invalid configuration option value: %s"",; 19785 config_options[MAX_REQUEST_SIZE].name);; 19786 }; 19787 free_context(ctx);; 19788 pthread_setspecific(sTlsKey, NULL);; 19789 return NULL;; 19790 }; 19791 ctx->max_request_size = (unsigned)itmp;; 19792 ; 19793 /* Queue length */; 19794#if !defined(ALTERNATIVE_QUEUE); 19795 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19796 if (itmp < 1) {; 19797 mg_cry_ctx_internal(ctx,; 19798 ""%s too small"",; 19799 config_options[CONNECTION_QUEUE_SIZE].name);; 19800 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19801 m",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:590278,Modifiability,config,config,590278,"""Invalid configuration option value: %s"",; 19749 name);; 19750 }; 19751 free_context(ctx);; 19752 pthread_setspecific(sTlsKey, NULL);; 19753 return NULL;; 19754 }; 19755 if (ctx->dd.config[idx] != NULL) {; 19756 /* A duplicate configuration option is not an error - the last; 19757 * option value will be used. */; 19758 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19759 mg_free(ctx->dd.config[idx]);; 19760 }; 19761 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19762 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19763 }; 19764 ; 19765 /* Set default value if needed */; 19766 for (i = 0; config_options[i].name != NULL; i++) {; 19767 default_value = config_options[i].default_value;; 19768 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19769 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19770 }; 19771 }; 19772 ; 19773 /* Request size option */; 19774 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19775 if (itmp < 1024) {; 19776 mg_cry_ctx_internal(ctx,; 19777 ""%s too small"",; 19778 config_options[MAX_REQUEST_SIZE].name);; 19779 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19780 mg_snprintf(NULL,; 19781 NULL, /* No truncation check for error buffers */; 19782 error->text,; 19783 error->text_buffer_size,; 19784 ""Invalid configuration option value: %s"",; 19785 config_options[MAX_REQUEST_SIZE].name);; 19786 }; 19787 free_context(ctx);; 19788 pthread_setspecific(sTlsKey, NULL);; 19789 return NULL;; 19790 }; 19791 ctx->max_request_size = (unsigned)itmp;; 19792 ; 19793 /* Queue length */; 19794#if !defined(ALTERNATIVE_QUEUE); 19795 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19796 if (itmp < 1) {; 19797 mg_cry_ctx_internal(ctx,; 19798 ""%s too small"",; 19799 config_options[CONNECTION_QUEUE_SIZE].name);; 19800 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19801 mg_snprintf(NULL,; 19802 NULL, /* No truncation check for error buffers */; 19803 error->text,; 19804 error->text_buffer_size,; 19805 ""Invali",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:590646,Modifiability,config,configuration,590646,"licate configuration option is not an error - the last; 19757 * option value will be used. */; 19758 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19759 mg_free(ctx->dd.config[idx]);; 19760 }; 19761 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19762 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19763 }; 19764 ; 19765 /* Set default value if needed */; 19766 for (i = 0; config_options[i].name != NULL; i++) {; 19767 default_value = config_options[i].default_value;; 19768 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19769 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19770 }; 19771 }; 19772 ; 19773 /* Request size option */; 19774 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19775 if (itmp < 1024) {; 19776 mg_cry_ctx_internal(ctx,; 19777 ""%s too small"",; 19778 config_options[MAX_REQUEST_SIZE].name);; 19779 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19780 mg_snprintf(NULL,; 19781 NULL, /* No truncation check for error buffers */; 19782 error->text,; 19783 error->text_buffer_size,; 19784 ""Invalid configuration option value: %s"",; 19785 config_options[MAX_REQUEST_SIZE].name);; 19786 }; 19787 free_context(ctx);; 19788 pthread_setspecific(sTlsKey, NULL);; 19789 return NULL;; 19790 }; 19791 ctx->max_request_size = (unsigned)itmp;; 19792 ; 19793 /* Queue length */; 19794#if !defined(ALTERNATIVE_QUEUE); 19795 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19796 if (itmp < 1) {; 19797 mg_cry_ctx_internal(ctx,; 19798 ""%s too small"",; 19799 config_options[CONNECTION_QUEUE_SIZE].name);; 19800 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19801 mg_snprintf(NULL,; 19802 NULL, /* No truncation check for error buffers */; 19803 error->text,; 19804 error->text_buffer_size,; 19805 ""Invalid configuration option value: %s"",; 19806 config_options[CONNECTION_QUEUE_SIZE].name);; 19807 }; 19808 free_context(ctx);; 19809 pthread_setspecific(sTlsKey, NULL);; 19810 return NULL;; 19811 }; 19812 ctx->squeue =; 19813",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:590979,Modifiability,config,config,590979,"lue;; 19768 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19769 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19770 }; 19771 }; 19772 ; 19773 /* Request size option */; 19774 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19775 if (itmp < 1024) {; 19776 mg_cry_ctx_internal(ctx,; 19777 ""%s too small"",; 19778 config_options[MAX_REQUEST_SIZE].name);; 19779 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19780 mg_snprintf(NULL,; 19781 NULL, /* No truncation check for error buffers */; 19782 error->text,; 19783 error->text_buffer_size,; 19784 ""Invalid configuration option value: %s"",; 19785 config_options[MAX_REQUEST_SIZE].name);; 19786 }; 19787 free_context(ctx);; 19788 pthread_setspecific(sTlsKey, NULL);; 19789 return NULL;; 19790 }; 19791 ctx->max_request_size = (unsigned)itmp;; 19792 ; 19793 /* Queue length */; 19794#if !defined(ALTERNATIVE_QUEUE); 19795 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19796 if (itmp < 1) {; 19797 mg_cry_ctx_internal(ctx,; 19798 ""%s too small"",; 19799 config_options[CONNECTION_QUEUE_SIZE].name);; 19800 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19801 mg_snprintf(NULL,; 19802 NULL, /* No truncation check for error buffers */; 19803 error->text,; 19804 error->text_buffer_size,; 19805 ""Invalid configuration option value: %s"",; 19806 config_options[CONNECTION_QUEUE_SIZE].name);; 19807 }; 19808 free_context(ctx);; 19809 pthread_setspecific(sTlsKey, NULL);; 19810 return NULL;; 19811 }; 19812 ctx->squeue =; 19813 (struct socket *)mg_calloc((unsigned int)itmp, sizeof(struct socket));; 19814 if (ctx->squeue == NULL) {; 19815 mg_cry_ctx_internal(ctx,; 19816 ""Out of memory: Cannot allocate %s"",; 19817 config_options[CONNECTION_QUEUE_SIZE].name);; 19818 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19819 mg_snprintf(NULL,; 19820 NULL, /* No truncation check for error buffers */; 19821 error->text,; 19822 error->text_buffer_size,; 19823 ""Out of memory: Cannot allocate %s"",; 19824 co",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:591354,Modifiability,config,configuration,591354,"g[MAX_REQUEST_SIZE]);; 19775 if (itmp < 1024) {; 19776 mg_cry_ctx_internal(ctx,; 19777 ""%s too small"",; 19778 config_options[MAX_REQUEST_SIZE].name);; 19779 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19780 mg_snprintf(NULL,; 19781 NULL, /* No truncation check for error buffers */; 19782 error->text,; 19783 error->text_buffer_size,; 19784 ""Invalid configuration option value: %s"",; 19785 config_options[MAX_REQUEST_SIZE].name);; 19786 }; 19787 free_context(ctx);; 19788 pthread_setspecific(sTlsKey, NULL);; 19789 return NULL;; 19790 }; 19791 ctx->max_request_size = (unsigned)itmp;; 19792 ; 19793 /* Queue length */; 19794#if !defined(ALTERNATIVE_QUEUE); 19795 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19796 if (itmp < 1) {; 19797 mg_cry_ctx_internal(ctx,; 19798 ""%s too small"",; 19799 config_options[CONNECTION_QUEUE_SIZE].name);; 19800 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19801 mg_snprintf(NULL,; 19802 NULL, /* No truncation check for error buffers */; 19803 error->text,; 19804 error->text_buffer_size,; 19805 ""Invalid configuration option value: %s"",; 19806 config_options[CONNECTION_QUEUE_SIZE].name);; 19807 }; 19808 free_context(ctx);; 19809 pthread_setspecific(sTlsKey, NULL);; 19810 return NULL;; 19811 }; 19812 ctx->squeue =; 19813 (struct socket *)mg_calloc((unsigned int)itmp, sizeof(struct socket));; 19814 if (ctx->squeue == NULL) {; 19815 mg_cry_ctx_internal(ctx,; 19816 ""Out of memory: Cannot allocate %s"",; 19817 config_options[CONNECTION_QUEUE_SIZE].name);; 19818 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19819 mg_snprintf(NULL,; 19820 NULL, /* No truncation check for error buffers */; 19821 error->text,; 19822 error->text_buffer_size,; 19823 ""Out of memory: Cannot allocate %s"",; 19824 config_options[CONNECTION_QUEUE_SIZE].name);; 19825 }; 19826 free_context(ctx);; 19827 pthread_setspecific(sTlsKey, NULL);; 19828 return NULL;; 19829 }; 19830 ctx->sq_size = itmp;; 19831#endif; 19832 ; 19833 /* Worker thread cou",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:592336,Modifiability,config,config,592336," socket));; 19814 if (ctx->squeue == NULL) {; 19815 mg_cry_ctx_internal(ctx,; 19816 ""Out of memory: Cannot allocate %s"",; 19817 config_options[CONNECTION_QUEUE_SIZE].name);; 19818 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19819 mg_snprintf(NULL,; 19820 NULL, /* No truncation check for error buffers */; 19821 error->text,; 19822 error->text_buffer_size,; 19823 ""Out of memory: Cannot allocate %s"",; 19824 config_options[CONNECTION_QUEUE_SIZE].name);; 19825 }; 19826 free_context(ctx);; 19827 pthread_setspecific(sTlsKey, NULL);; 19828 return NULL;; 19829 }; 19830 ctx->sq_size = itmp;; 19831#endif; 19832 ; 19833 /* Worker thread count option */; 19834 workerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);; 19835 ; 19836 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19837 if (workerthreadcount <= 0) {; 19838 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19839 } else {; 19840 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19841 }; 19842 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19843 mg_snprintf(NULL,; 19844 NULL, /* No truncation check for error buffers */; 19845 error->text,; 19846 error->text_buffer_size,; 19847 ""Invalid configuration option value: %s"",; 19848 config_options[NUM_THREADS].name);; 19849 }; 19850 free_context(ctx);; 19851 pthread_setspecific(sTlsKey, NULL);; 19852 return NULL;; 19853 }; 19854 ; 19855 /* Document root */; 19856#if defined(NO_FILES); 19857 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19858 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19859 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19860 mg_snprintf(NULL,; 19861 NULL, /* No truncation check for error buffers */; 19862 error->text,; 19863 error->text_buffer_size,; 19864 ""Invalid configuration option value: %s"",; 19865 config_options[DOCUMENT_ROOT].name);; 19866 }; 19867 free_context(ctx);; 19868 pthread_setspecific(sTlsKey, NULL);; 19869 return NULL;; 19870 }; 198",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:592865,Modifiability,config,configuration,592865," socket));; 19814 if (ctx->squeue == NULL) {; 19815 mg_cry_ctx_internal(ctx,; 19816 ""Out of memory: Cannot allocate %s"",; 19817 config_options[CONNECTION_QUEUE_SIZE].name);; 19818 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19819 mg_snprintf(NULL,; 19820 NULL, /* No truncation check for error buffers */; 19821 error->text,; 19822 error->text_buffer_size,; 19823 ""Out of memory: Cannot allocate %s"",; 19824 config_options[CONNECTION_QUEUE_SIZE].name);; 19825 }; 19826 free_context(ctx);; 19827 pthread_setspecific(sTlsKey, NULL);; 19828 return NULL;; 19829 }; 19830 ctx->sq_size = itmp;; 19831#endif; 19832 ; 19833 /* Worker thread count option */; 19834 workerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);; 19835 ; 19836 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19837 if (workerthreadcount <= 0) {; 19838 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19839 } else {; 19840 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19841 }; 19842 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19843 mg_snprintf(NULL,; 19844 NULL, /* No truncation check for error buffers */; 19845 error->text,; 19846 error->text_buffer_size,; 19847 ""Invalid configuration option value: %s"",; 19848 config_options[NUM_THREADS].name);; 19849 }; 19850 free_context(ctx);; 19851 pthread_setspecific(sTlsKey, NULL);; 19852 return NULL;; 19853 }; 19854 ; 19855 /* Document root */; 19856#if defined(NO_FILES); 19857 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19858 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19859 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19860 mg_snprintf(NULL,; 19861 NULL, /* No truncation check for error buffers */; 19862 error->text,; 19863 error->text_buffer_size,; 19864 ""Invalid configuration option value: %s"",; 19865 config_options[DOCUMENT_ROOT].name);; 19866 }; 19867 free_context(ctx);; 19868 pthread_setspecific(sTlsKey, NULL);; 19869 return NULL;; 19870 }; 198",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:593129,Modifiability,config,config,593129,"atoi(ctx->dd.config[NUM_THREADS]);; 19835 ; 19836 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19837 if (workerthreadcount <= 0) {; 19838 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19839 } else {; 19840 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19841 }; 19842 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19843 mg_snprintf(NULL,; 19844 NULL, /* No truncation check for error buffers */; 19845 error->text,; 19846 error->text_buffer_size,; 19847 ""Invalid configuration option value: %s"",; 19848 config_options[NUM_THREADS].name);; 19849 }; 19850 free_context(ctx);; 19851 pthread_setspecific(sTlsKey, NULL);; 19852 return NULL;; 19853 }; 19854 ; 19855 /* Document root */; 19856#if defined(NO_FILES); 19857 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19858 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19859 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19860 mg_snprintf(NULL,; 19861 NULL, /* No truncation check for error buffers */; 19862 error->text,; 19863 error->text_buffer_size,; 19864 ""Invalid configuration option value: %s"",; 19865 config_options[DOCUMENT_ROOT].name);; 19866 }; 19867 free_context(ctx);; 19868 pthread_setspecific(sTlsKey, NULL);; 19869 return NULL;; 19870 }; 19871#endif; 19872 ; 19873 get_system_name(&ctx->systemName);; 19874 ; 19875#if defined(USE_LUA); 19876 /* If a Lua background script has been configured, start it. */; 19877 ctx->lua_bg_log_available = 0;; 19878 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19879 char ebuf[256];; 19880 struct vec opt_vec;; 19881 struct vec eq_vec;; 19882 const char *sparams;; 19883 ; 19884 memset(ebuf, 0, sizeof(ebuf));; 19885 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19886 ; 19887 /* Create a Lua state, load all standard libraries and the mg table */; 19888 lua_State *state = mg_lua_context_script_prepare(; 19889 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19890 if (!s",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:593447,Modifiability,config,configuration,593447,"atoi(ctx->dd.config[NUM_THREADS]);; 19835 ; 19836 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19837 if (workerthreadcount <= 0) {; 19838 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19839 } else {; 19840 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19841 }; 19842 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19843 mg_snprintf(NULL,; 19844 NULL, /* No truncation check for error buffers */; 19845 error->text,; 19846 error->text_buffer_size,; 19847 ""Invalid configuration option value: %s"",; 19848 config_options[NUM_THREADS].name);; 19849 }; 19850 free_context(ctx);; 19851 pthread_setspecific(sTlsKey, NULL);; 19852 return NULL;; 19853 }; 19854 ; 19855 /* Document root */; 19856#if defined(NO_FILES); 19857 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19858 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19859 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19860 mg_snprintf(NULL,; 19861 NULL, /* No truncation check for error buffers */; 19862 error->text,; 19863 error->text_buffer_size,; 19864 ""Invalid configuration option value: %s"",; 19865 config_options[DOCUMENT_ROOT].name);; 19866 }; 19867 free_context(ctx);; 19868 pthread_setspecific(sTlsKey, NULL);; 19869 return NULL;; 19870 }; 19871#endif; 19872 ; 19873 get_system_name(&ctx->systemName);; 19874 ; 19875#if defined(USE_LUA); 19876 /* If a Lua background script has been configured, start it. */; 19877 ctx->lua_bg_log_available = 0;; 19878 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19879 char ebuf[256];; 19880 struct vec opt_vec;; 19881 struct vec eq_vec;; 19882 const char *sparams;; 19883 ; 19884 memset(ebuf, 0, sizeof(ebuf));; 19885 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19886 ; 19887 /* Create a Lua state, load all standard libraries and the mg table */; 19888 lua_State *state = mg_lua_context_script_prepare(; 19889 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19890 if (!s",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:593775,Modifiability,config,configured,593775,"42 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19843 mg_snprintf(NULL,; 19844 NULL, /* No truncation check for error buffers */; 19845 error->text,; 19846 error->text_buffer_size,; 19847 ""Invalid configuration option value: %s"",; 19848 config_options[NUM_THREADS].name);; 19849 }; 19850 free_context(ctx);; 19851 pthread_setspecific(sTlsKey, NULL);; 19852 return NULL;; 19853 }; 19854 ; 19855 /* Document root */; 19856#if defined(NO_FILES); 19857 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19858 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19859 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19860 mg_snprintf(NULL,; 19861 NULL, /* No truncation check for error buffers */; 19862 error->text,; 19863 error->text_buffer_size,; 19864 ""Invalid configuration option value: %s"",; 19865 config_options[DOCUMENT_ROOT].name);; 19866 }; 19867 free_context(ctx);; 19868 pthread_setspecific(sTlsKey, NULL);; 19869 return NULL;; 19870 }; 19871#endif; 19872 ; 19873 get_system_name(&ctx->systemName);; 19874 ; 19875#if defined(USE_LUA); 19876 /* If a Lua background script has been configured, start it. */; 19877 ctx->lua_bg_log_available = 0;; 19878 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19879 char ebuf[256];; 19880 struct vec opt_vec;; 19881 struct vec eq_vec;; 19882 const char *sparams;; 19883 ; 19884 memset(ebuf, 0, sizeof(ebuf));; 19885 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19886 ; 19887 /* Create a Lua state, load all standard libraries and the mg table */; 19888 lua_State *state = mg_lua_context_script_prepare(; 19889 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19890 if (!state) {; 19891 mg_cry_ctx_internal(ctx,; 19892 ""lua_background_script load error: %s"",; 19893 ebuf);; 19894 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19895 mg_snprintf(NULL,; 19896 NULL, /* No truncation check for error buffers */; 19897 error->text,; 19898 error->text_buffer_size,; 19899 ""Error in script %s: %s"",; 19",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:593857,Modifiability,config,config,593857," 19855 /* Document root */; 19856#if defined(NO_FILES); 19857 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19858 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19859 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19860 mg_snprintf(NULL,; 19861 NULL, /* No truncation check for error buffers */; 19862 error->text,; 19863 error->text_buffer_size,; 19864 ""Invalid configuration option value: %s"",; 19865 config_options[DOCUMENT_ROOT].name);; 19866 }; 19867 free_context(ctx);; 19868 pthread_setspecific(sTlsKey, NULL);; 19869 return NULL;; 19870 }; 19871#endif; 19872 ; 19873 get_system_name(&ctx->systemName);; 19874 ; 19875#if defined(USE_LUA); 19876 /* If a Lua background script has been configured, start it. */; 19877 ctx->lua_bg_log_available = 0;; 19878 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19879 char ebuf[256];; 19880 struct vec opt_vec;; 19881 struct vec eq_vec;; 19882 const char *sparams;; 19883 ; 19884 memset(ebuf, 0, sizeof(ebuf));; 19885 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19886 ; 19887 /* Create a Lua state, load all standard libraries and the mg table */; 19888 lua_State *state = mg_lua_context_script_prepare(; 19889 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19890 if (!state) {; 19891 mg_cry_ctx_internal(ctx,; 19892 ""lua_background_script load error: %s"",; 19893 ebuf);; 19894 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19895 mg_snprintf(NULL,; 19896 NULL, /* No truncation check for error buffers */; 19897 error->text,; 19898 error->text_buffer_size,; 19899 ""Error in script %s: %s"",; 19900 config_options[LUA_BACKGROUND_SCRIPT].name,; 19901 ebuf);; 19902 }; 19903 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19904 ; 19905 free_context(ctx);; 19906 pthread_setspecific(sTlsKey, NULL);; 19907 return NULL;; 19908 }; 19909 ; 19910 /* Add a table with parameters into mg.params */; 19911 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19912 if (sparams && sparams[0]) {; 19913 lu",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:594253,Modifiability,config,config,594253,"s"",; 19865 config_options[DOCUMENT_ROOT].name);; 19866 }; 19867 free_context(ctx);; 19868 pthread_setspecific(sTlsKey, NULL);; 19869 return NULL;; 19870 }; 19871#endif; 19872 ; 19873 get_system_name(&ctx->systemName);; 19874 ; 19875#if defined(USE_LUA); 19876 /* If a Lua background script has been configured, start it. */; 19877 ctx->lua_bg_log_available = 0;; 19878 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19879 char ebuf[256];; 19880 struct vec opt_vec;; 19881 struct vec eq_vec;; 19882 const char *sparams;; 19883 ; 19884 memset(ebuf, 0, sizeof(ebuf));; 19885 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19886 ; 19887 /* Create a Lua state, load all standard libraries and the mg table */; 19888 lua_State *state = mg_lua_context_script_prepare(; 19889 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19890 if (!state) {; 19891 mg_cry_ctx_internal(ctx,; 19892 ""lua_background_script load error: %s"",; 19893 ebuf);; 19894 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19895 mg_snprintf(NULL,; 19896 NULL, /* No truncation check for error buffers */; 19897 error->text,; 19898 error->text_buffer_size,; 19899 ""Error in script %s: %s"",; 19900 config_options[LUA_BACKGROUND_SCRIPT].name,; 19901 ebuf);; 19902 }; 19903 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19904 ; 19905 free_context(ctx);; 19906 pthread_setspecific(sTlsKey, NULL);; 19907 return NULL;; 19908 }; 19909 ; 19910 /* Add a table with parameters into mg.params */; 19911 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19912 if (sparams && sparams[0]) {; 19913 lua_getglobal(state, ""mg"");; 19914 lua_pushstring(state, ""params"");; 19915 lua_newtable(state);; 19916 ; 19917 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19918 != NULL) {; 19919 reg_llstring(; 19920 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19921 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19922 break;; 19923 }; 19924 lua_rawset(state, -3);; 19925 lua_pop(state, 1);; 19",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:594972,Modifiability,config,config,594972,"ate, load all standard libraries and the mg table */; 19888 lua_State *state = mg_lua_context_script_prepare(; 19889 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19890 if (!state) {; 19891 mg_cry_ctx_internal(ctx,; 19892 ""lua_background_script load error: %s"",; 19893 ebuf);; 19894 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19895 mg_snprintf(NULL,; 19896 NULL, /* No truncation check for error buffers */; 19897 error->text,; 19898 error->text_buffer_size,; 19899 ""Error in script %s: %s"",; 19900 config_options[LUA_BACKGROUND_SCRIPT].name,; 19901 ebuf);; 19902 }; 19903 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19904 ; 19905 free_context(ctx);; 19906 pthread_setspecific(sTlsKey, NULL);; 19907 return NULL;; 19908 }; 19909 ; 19910 /* Add a table with parameters into mg.params */; 19911 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19912 if (sparams && sparams[0]) {; 19913 lua_getglobal(state, ""mg"");; 19914 lua_pushstring(state, ""params"");; 19915 lua_newtable(state);; 19916 ; 19917 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19918 != NULL) {; 19919 reg_llstring(; 19920 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19921 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19922 break;; 19923 }; 19924 lua_rawset(state, -3);; 19925 lua_pop(state, 1);; 19926 }; 19927 ; 19928 /* Call script */; 19929 state = mg_lua_context_script_run(state,; 19930 ctx->dd.config[LUA_BACKGROUND_SCRIPT],; 19931 ctx,; 19932 ebuf,; 19933 sizeof(ebuf));; 19934 if (!state) {; 19935 mg_cry_ctx_internal(ctx,; 19936 ""lua_background_script start error: %s"",; 19937 ebuf);; 19938 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19939 mg_snprintf(NULL,; 19940 NULL, /* No truncation check for error buffers */; 19941 error->text,; 19942 error->text_buffer_size,; 19943 ""Error in script %s: %s"",; 19944 config_options[DOCUMENT_ROOT].name,; 19945 ebuf);; 19946 }; 19947 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19948 ; 199",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:595578,Modifiability,config,config,595578,");; 19906 pthread_setspecific(sTlsKey, NULL);; 19907 return NULL;; 19908 }; 19909 ; 19910 /* Add a table with parameters into mg.params */; 19911 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19912 if (sparams && sparams[0]) {; 19913 lua_getglobal(state, ""mg"");; 19914 lua_pushstring(state, ""params"");; 19915 lua_newtable(state);; 19916 ; 19917 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19918 != NULL) {; 19919 reg_llstring(; 19920 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19921 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19922 break;; 19923 }; 19924 lua_rawset(state, -3);; 19925 lua_pop(state, 1);; 19926 }; 19927 ; 19928 /* Call script */; 19929 state = mg_lua_context_script_run(state,; 19930 ctx->dd.config[LUA_BACKGROUND_SCRIPT],; 19931 ctx,; 19932 ebuf,; 19933 sizeof(ebuf));; 19934 if (!state) {; 19935 mg_cry_ctx_internal(ctx,; 19936 ""lua_background_script start error: %s"",; 19937 ebuf);; 19938 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19939 mg_snprintf(NULL,; 19940 NULL, /* No truncation check for error buffers */; 19941 error->text,; 19942 error->text_buffer_size,; 19943 ""Error in script %s: %s"",; 19944 config_options[DOCUMENT_ROOT].name,; 19945 ebuf);; 19946 }; 19947 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19948 ; 19949 free_context(ctx);; 19950 pthread_setspecific(sTlsKey, NULL);; 19951 return NULL;; 19952 }; 19953 ; 19954 /* state remains valid */; 19955 ctx->lua_background_state = (void *)state;; 19956 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19957 ; 19958 } else {; 19959 ctx->lua_background_state = 0;; 19960 }; 19961#endif; 19962 ; 19963 /* Step by step initialization of ctx - depending on build options */; 19964#if !defined(NO_FILESYSTEMS); 19965 if (!set_gpass_option(ctx, NULL)) {; 19966 const char *err_msg = ""Invalid global password file"";; 19967 /* Fatal error - abort start. */; 19968 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19969 ; 19970 if ((error != NULL) && (error->text",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:598953,Modifiability,config,configured,598953,"efined(NO_SSL); 20004 if (!init_ssl_ctx(ctx, NULL)) {; 20005 const char *err_msg = ""Error initializing SSL context"";; 20006 /* Fatal error - abort start. */; 20007 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20008 ; 20009 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20010 mg_snprintf(NULL,; 20011 NULL, /* No truncation check for error buffers */; 20012 error->text,; 20013 error->text_buffer_size,; 20014 ""%s"",; 20015 err_msg);; 20016 }; 20017 free_context(ctx);; 20018 pthread_setspecific(sTlsKey, NULL);; 20019 return NULL;; 20020 }; 20021#endif; 20022 ; 20023 if (!set_ports_option(ctx)) {; 20024 const char *err_msg = ""Failed to setup server ports"";; 20025 /* Fatal error - abort start. */; 20026 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20027 ; 20028 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20029 mg_snprintf(NULL,; 20030 NULL, /* No truncation check for error buffers */; 20031 error->text,; 20032 error->text_buffer_size,; 20033 ""%s"",; 20034 err_msg);; 20035 }; 20036 free_context(ctx);; 20037 pthread_setspecific(sTlsKey, NULL);; 20038 return NULL;; 20039 }; 20040 ; 20041 ; 20042#if !defined(_WIN32) && !defined(__ZEPHYR__); 20043 if (!set_uid_option(ctx)) {; 20044 const char *err_msg = ""Failed to run as configured user"";; 20045 /* Fatal error - abort start. */; 20046 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20047 ; 20048 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20049 mg_snprintf(NULL,; 20050 NULL, /* No truncation check for error buffers */; 20051 error->text,; 20052 error->text_buffer_size,; 20053 ""%s"",; 20054 err_msg);; 20055 }; 20056 free_context(ctx);; 20057 pthread_setspecific(sTlsKey, NULL);; 20058 return NULL;; 20059 }; 20060#endif; 20061 ; 20062 if (!set_acl_option(ctx)) {; 20063 const char *err_msg = ""Failed to setup access control list"";; 20064 /* Fatal error - abort start. */; 20065 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20066 ; 20067 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20068 mg_snprintf(NULL,;",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:609347,Modifiability,config,config,609347,"k for error buffers */; 20321 error->text,; 20322 error->text_buffer_size,; 20323 ""%s"",; 20324 ""Invalid parameters"");; 20325 }; 20326 return -1;; 20327 }; 20328 ; 20329 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 20330 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20331 mg_snprintf(NULL,; 20332 NULL, /* No truncation check for error buffers */; 20333 error->text,; 20334 error->text_buffer_size,; 20335 ""%s"",; 20336 ""Server already stopped"");; 20337 }; 20338 return -1;; 20339 }; 20340 ; 20341 new_dom = (struct mg_domain_context *); 20342 mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);; 20343 ; 20344 if (!new_dom) {; 20345 /* Out of memory */; 20346 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20347 mg_snprintf(NULL,; 20348 NULL, /* No truncation check for error buffers */; 20349 error->text,; 20350 error->text_buffer_size,; 20351 ""%s"",; 20352 ""Out or memory"");; 20353 }; 20354 return -6;; 20355 }; 20356 ; 20357 /* Store options - TODO: unite duplicate code */; 20358 while (options && (name = *options++) != NULL) {; 20359 if ((idx = get_option_index(name)) == -1) {; 20360 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 20361 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20362 mg_snprintf(NULL,; 20363 NULL, /* No truncation check for error buffers */; 20364 error->text,; 20365 error->text_buffer_size,; 20366 ""Invalid option: %s"",; 20367 name);; 20368 }; 20369 mg_free(new_dom);; 20370 return -2;; 20371 } else if ((value = *options++) == NULL) {; 20372 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20373 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20374 mg_snprintf(NULL,; 20375 NULL, /* No truncation check for error buffers */; 20376 error->text,; 20377 error->text_buffer_size,; 20378 ""Invalid option value: %s"",; 20379 name);; 20380 }; 20381 mg_free(new_dom);; 20382 return -2;; 20383 }; 20384 if (new_dom->config[idx] != NULL) {; 20385 /* Duplicate option: Later values overwrite earlier ones.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:609534,Modifiability,config,config,609534,"nvalid option: %s"",; 20367 name);; 20368 }; 20369 mg_free(new_dom);; 20370 return -2;; 20371 } else if ((value = *options++) == NULL) {; 20372 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20373 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20374 mg_snprintf(NULL,; 20375 NULL, /* No truncation check for error buffers */; 20376 error->text,; 20377 error->text_buffer_size,; 20378 ""Invalid option value: %s"",; 20379 name);; 20380 }; 20381 mg_free(new_dom);; 20382 return -2;; 20383 }; 20384 if (new_dom->config[idx] != NULL) {; 20385 /* Duplicate option: Later values overwrite earlier ones. */; 20386 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 20387 mg_free(new_dom->config[idx]);; 20388 }; 20389 new_dom->config[idx] = mg_strdup_ctx(value, ctx);; 20390 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 20391 }; 20392 ; 20393 /* Authentication domain is mandatory */; 20394 /* TODO: Maybe use a new option hostname? */; 20395 if (!new_dom->config[AUTHENTICATION_DOMAIN]) {; 20396 mg_cry_ctx_internal(ctx, ""%s"", ""authentication domain required"");; 20397 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20398 mg_snprintf(NULL,; 20399 NULL, /* No truncation check for error buffers */; 20400 error->text,; 20401 error->text_buffer_size,; 20402 ""Mandatory option %s missing"",; 20403 config_options[AUTHENTICATION_DOMAIN].name);; 20404 }; 20405 mg_free(new_dom);; 20406 return -4;; 20407 }; 20408 ; 20409 /* Set default value if needed. Take the config value from; 20410 * ctx as a default value. */; 20411 for (i = 0; config_options[i].name != NULL; i++) {; 20412 default_value = ctx->dd.config[i];; 20413 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20414 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20415 }; 20416 }; 20417 ; 20418 new_dom->handlers = NULL;; 20419 new_dom->next = NULL;; 20420 new_dom->nonce_count = 0;; 20421 new_dom->auth_nonce_mask =; 20422 (uint64_t)get_random() ^ ((uint64_t)get_random() <<",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:609573,Modifiability,config,config,609573,"nvalid option: %s"",; 20367 name);; 20368 }; 20369 mg_free(new_dom);; 20370 return -2;; 20371 } else if ((value = *options++) == NULL) {; 20372 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20373 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20374 mg_snprintf(NULL,; 20375 NULL, /* No truncation check for error buffers */; 20376 error->text,; 20377 error->text_buffer_size,; 20378 ""Invalid option value: %s"",; 20379 name);; 20380 }; 20381 mg_free(new_dom);; 20382 return -2;; 20383 }; 20384 if (new_dom->config[idx] != NULL) {; 20385 /* Duplicate option: Later values overwrite earlier ones. */; 20386 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 20387 mg_free(new_dom->config[idx]);; 20388 }; 20389 new_dom->config[idx] = mg_strdup_ctx(value, ctx);; 20390 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 20391 }; 20392 ; 20393 /* Authentication domain is mandatory */; 20394 /* TODO: Maybe use a new option hostname? */; 20395 if (!new_dom->config[AUTHENTICATION_DOMAIN]) {; 20396 mg_cry_ctx_internal(ctx, ""%s"", ""authentication domain required"");; 20397 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20398 mg_snprintf(NULL,; 20399 NULL, /* No truncation check for error buffers */; 20400 error->text,; 20401 error->text_buffer_size,; 20402 ""Mandatory option %s missing"",; 20403 config_options[AUTHENTICATION_DOMAIN].name);; 20404 }; 20405 mg_free(new_dom);; 20406 return -4;; 20407 }; 20408 ; 20409 /* Set default value if needed. Take the config value from; 20410 * ctx as a default value. */; 20411 for (i = 0; config_options[i].name != NULL; i++) {; 20412 default_value = ctx->dd.config[i];; 20413 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20414 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20415 }; 20416 }; 20417 ; 20418 new_dom->handlers = NULL;; 20419 new_dom->next = NULL;; 20420 new_dom->nonce_count = 0;; 20421 new_dom->auth_nonce_mask =; 20422 (uint64_t)get_random() ^ ((uint64_t)get_random() <<",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:609801,Modifiability,config,config,609801,"nvalid option: %s"",; 20367 name);; 20368 }; 20369 mg_free(new_dom);; 20370 return -2;; 20371 } else if ((value = *options++) == NULL) {; 20372 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20373 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20374 mg_snprintf(NULL,; 20375 NULL, /* No truncation check for error buffers */; 20376 error->text,; 20377 error->text_buffer_size,; 20378 ""Invalid option value: %s"",; 20379 name);; 20380 }; 20381 mg_free(new_dom);; 20382 return -2;; 20383 }; 20384 if (new_dom->config[idx] != NULL) {; 20385 /* Duplicate option: Later values overwrite earlier ones. */; 20386 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 20387 mg_free(new_dom->config[idx]);; 20388 }; 20389 new_dom->config[idx] = mg_strdup_ctx(value, ctx);; 20390 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 20391 }; 20392 ; 20393 /* Authentication domain is mandatory */; 20394 /* TODO: Maybe use a new option hostname? */; 20395 if (!new_dom->config[AUTHENTICATION_DOMAIN]) {; 20396 mg_cry_ctx_internal(ctx, ""%s"", ""authentication domain required"");; 20397 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20398 mg_snprintf(NULL,; 20399 NULL, /* No truncation check for error buffers */; 20400 error->text,; 20401 error->text_buffer_size,; 20402 ""Mandatory option %s missing"",; 20403 config_options[AUTHENTICATION_DOMAIN].name);; 20404 }; 20405 mg_free(new_dom);; 20406 return -4;; 20407 }; 20408 ; 20409 /* Set default value if needed. Take the config value from; 20410 * ctx as a default value. */; 20411 for (i = 0; config_options[i].name != NULL; i++) {; 20412 default_value = ctx->dd.config[i];; 20413 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20414 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20415 }; 20416 }; 20417 ; 20418 new_dom->handlers = NULL;; 20419 new_dom->next = NULL;; 20420 new_dom->nonce_count = 0;; 20421 new_dom->auth_nonce_mask =; 20422 (uint64_t)get_random() ^ ((uint64_t)get_random() <<",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:610311,Modifiability,config,config,610311,"84 if (new_dom->config[idx] != NULL) {; 20385 /* Duplicate option: Later values overwrite earlier ones. */; 20386 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 20387 mg_free(new_dom->config[idx]);; 20388 }; 20389 new_dom->config[idx] = mg_strdup_ctx(value, ctx);; 20390 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 20391 }; 20392 ; 20393 /* Authentication domain is mandatory */; 20394 /* TODO: Maybe use a new option hostname? */; 20395 if (!new_dom->config[AUTHENTICATION_DOMAIN]) {; 20396 mg_cry_ctx_internal(ctx, ""%s"", ""authentication domain required"");; 20397 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20398 mg_snprintf(NULL,; 20399 NULL, /* No truncation check for error buffers */; 20400 error->text,; 20401 error->text_buffer_size,; 20402 ""Mandatory option %s missing"",; 20403 config_options[AUTHENTICATION_DOMAIN].name);; 20404 }; 20405 mg_free(new_dom);; 20406 return -4;; 20407 }; 20408 ; 20409 /* Set default value if needed. Take the config value from; 20410 * ctx as a default value. */; 20411 for (i = 0; config_options[i].name != NULL; i++) {; 20412 default_value = ctx->dd.config[i];; 20413 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20414 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20415 }; 20416 }; 20417 ; 20418 new_dom->handlers = NULL;; 20419 new_dom->next = NULL;; 20420 new_dom->nonce_count = 0;; 20421 new_dom->auth_nonce_mask =; 20422 (uint64_t)get_random() ^ ((uint64_t)get_random() << 31);; 20423 ; 20424#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20425 new_dom->shared_lua_websockets = NULL;; 20426#endif; 20427 ; 20428#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20429 if (!init_ssl_ctx(ctx, new_dom)) {; 20430 /* Init SSL failed */; 20431 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20432 mg_snprintf(NULL,; 20433 NULL, /* No truncation check for error buffers */; 20434 error->text,; 20435 error->text_buffer_size,; 20436 ""%s"",; 20437 ""Initializing SSL context failed"");; 20438 }; ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:610454,Modifiability,config,config,610454,"xt_buffer_size > 0)) {; 20398 mg_snprintf(NULL,; 20399 NULL, /* No truncation check for error buffers */; 20400 error->text,; 20401 error->text_buffer_size,; 20402 ""Mandatory option %s missing"",; 20403 config_options[AUTHENTICATION_DOMAIN].name);; 20404 }; 20405 mg_free(new_dom);; 20406 return -4;; 20407 }; 20408 ; 20409 /* Set default value if needed. Take the config value from; 20410 * ctx as a default value. */; 20411 for (i = 0; config_options[i].name != NULL; i++) {; 20412 default_value = ctx->dd.config[i];; 20413 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20414 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20415 }; 20416 }; 20417 ; 20418 new_dom->handlers = NULL;; 20419 new_dom->next = NULL;; 20420 new_dom->nonce_count = 0;; 20421 new_dom->auth_nonce_mask =; 20422 (uint64_t)get_random() ^ ((uint64_t)get_random() << 31);; 20423 ; 20424#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20425 new_dom->shared_lua_websockets = NULL;; 20426#endif; 20427 ; 20428#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20429 if (!init_ssl_ctx(ctx, new_dom)) {; 20430 /* Init SSL failed */; 20431 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20432 mg_snprintf(NULL,; 20433 NULL, /* No truncation check for error buffers */; 20434 error->text,; 20435 error->text_buffer_size,; 20436 ""%s"",; 20437 ""Initializing SSL context failed"");; 20438 }; 20439 mg_free(new_dom);; 20440 return -3;; 20441 }; 20442#endif; 20443 ; 20444 /* Add element to linked list. */; 20445 mg_lock_context(ctx);; 20446 ; 20447 idx = 0;; 20448 dom = &(ctx->dd);; 20449 for (;;) {; 20450 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20451 dom->config[AUTHENTICATION_DOMAIN])) {; 20452 /* Domain collision */; 20453 mg_cry_ctx_internal(ctx,; 20454 ""domain %s already in use"",; 20455 new_dom->config[AUTHENTICATION_DOMAIN]);; 20456 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20457 mg_snprintf(NULL,; 20458 NULL, /* No truncation check for error buffers */; 2045",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:610486,Modifiability,config,config,610486,"xt_buffer_size > 0)) {; 20398 mg_snprintf(NULL,; 20399 NULL, /* No truncation check for error buffers */; 20400 error->text,; 20401 error->text_buffer_size,; 20402 ""Mandatory option %s missing"",; 20403 config_options[AUTHENTICATION_DOMAIN].name);; 20404 }; 20405 mg_free(new_dom);; 20406 return -4;; 20407 }; 20408 ; 20409 /* Set default value if needed. Take the config value from; 20410 * ctx as a default value. */; 20411 for (i = 0; config_options[i].name != NULL; i++) {; 20412 default_value = ctx->dd.config[i];; 20413 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20414 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20415 }; 20416 }; 20417 ; 20418 new_dom->handlers = NULL;; 20419 new_dom->next = NULL;; 20420 new_dom->nonce_count = 0;; 20421 new_dom->auth_nonce_mask =; 20422 (uint64_t)get_random() ^ ((uint64_t)get_random() << 31);; 20423 ; 20424#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20425 new_dom->shared_lua_websockets = NULL;; 20426#endif; 20427 ; 20428#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20429 if (!init_ssl_ctx(ctx, new_dom)) {; 20430 /* Init SSL failed */; 20431 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20432 mg_snprintf(NULL,; 20433 NULL, /* No truncation check for error buffers */; 20434 error->text,; 20435 error->text_buffer_size,; 20436 ""%s"",; 20437 ""Initializing SSL context failed"");; 20438 }; 20439 mg_free(new_dom);; 20440 return -3;; 20441 }; 20442#endif; 20443 ; 20444 /* Add element to linked list. */; 20445 mg_lock_context(ctx);; 20446 ; 20447 idx = 0;; 20448 dom = &(ctx->dd);; 20449 for (;;) {; 20450 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20451 dom->config[AUTHENTICATION_DOMAIN])) {; 20452 /* Domain collision */; 20453 mg_cry_ctx_internal(ctx,; 20454 ""domain %s already in use"",; 20455 new_dom->config[AUTHENTICATION_DOMAIN]);; 20456 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20457 mg_snprintf(NULL,; 20458 NULL, /* No truncation check for error buffers */; 2045",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:610551,Modifiability,config,config,610551,"xt_buffer_size > 0)) {; 20398 mg_snprintf(NULL,; 20399 NULL, /* No truncation check for error buffers */; 20400 error->text,; 20401 error->text_buffer_size,; 20402 ""Mandatory option %s missing"",; 20403 config_options[AUTHENTICATION_DOMAIN].name);; 20404 }; 20405 mg_free(new_dom);; 20406 return -4;; 20407 }; 20408 ; 20409 /* Set default value if needed. Take the config value from; 20410 * ctx as a default value. */; 20411 for (i = 0; config_options[i].name != NULL; i++) {; 20412 default_value = ctx->dd.config[i];; 20413 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20414 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20415 }; 20416 }; 20417 ; 20418 new_dom->handlers = NULL;; 20419 new_dom->next = NULL;; 20420 new_dom->nonce_count = 0;; 20421 new_dom->auth_nonce_mask =; 20422 (uint64_t)get_random() ^ ((uint64_t)get_random() << 31);; 20423 ; 20424#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20425 new_dom->shared_lua_websockets = NULL;; 20426#endif; 20427 ; 20428#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20429 if (!init_ssl_ctx(ctx, new_dom)) {; 20430 /* Init SSL failed */; 20431 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20432 mg_snprintf(NULL,; 20433 NULL, /* No truncation check for error buffers */; 20434 error->text,; 20435 error->text_buffer_size,; 20436 ""%s"",; 20437 ""Initializing SSL context failed"");; 20438 }; 20439 mg_free(new_dom);; 20440 return -3;; 20441 }; 20442#endif; 20443 ; 20444 /* Add element to linked list. */; 20445 mg_lock_context(ctx);; 20446 ; 20447 idx = 0;; 20448 dom = &(ctx->dd);; 20449 for (;;) {; 20450 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20451 dom->config[AUTHENTICATION_DOMAIN])) {; 20452 /* Domain collision */; 20453 mg_cry_ctx_internal(ctx,; 20454 ""domain %s already in use"",; 20455 new_dom->config[AUTHENTICATION_DOMAIN]);; 20456 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20457 mg_snprintf(NULL,; 20458 NULL, /* No truncation check for error buffers */; 2045",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:611575,Modifiability,config,config,611575,"t64_t)get_random() << 31);; 20423 ; 20424#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20425 new_dom->shared_lua_websockets = NULL;; 20426#endif; 20427 ; 20428#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20429 if (!init_ssl_ctx(ctx, new_dom)) {; 20430 /* Init SSL failed */; 20431 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20432 mg_snprintf(NULL,; 20433 NULL, /* No truncation check for error buffers */; 20434 error->text,; 20435 error->text_buffer_size,; 20436 ""%s"",; 20437 ""Initializing SSL context failed"");; 20438 }; 20439 mg_free(new_dom);; 20440 return -3;; 20441 }; 20442#endif; 20443 ; 20444 /* Add element to linked list. */; 20445 mg_lock_context(ctx);; 20446 ; 20447 idx = 0;; 20448 dom = &(ctx->dd);; 20449 for (;;) {; 20450 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20451 dom->config[AUTHENTICATION_DOMAIN])) {; 20452 /* Domain collision */; 20453 mg_cry_ctx_internal(ctx,; 20454 ""domain %s already in use"",; 20455 new_dom->config[AUTHENTICATION_DOMAIN]);; 20456 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20457 mg_snprintf(NULL,; 20458 NULL, /* No truncation check for error buffers */; 20459 error->text,; 20460 error->text_buffer_size,; 20461 ""Domain %s specified by %s is already in use"",; 20462 new_dom->config[AUTHENTICATION_DOMAIN],; 20463 config_options[AUTHENTICATION_DOMAIN].name);; 20464 }; 20465 mg_free(new_dom);; 20466 mg_unlock_context(ctx);; 20467 return -5;; 20468 }; 20469 ; 20470 /* Count number of domains */; 20471 idx++;; 20472 ; 20473 if (dom->next == NULL) {; 20474 dom->next = new_dom;; 20475 break;; 20476 }; 20477 dom = dom->next;; 20478 }; 20479 ; 20480 mg_unlock_context(ctx);; 20481 ; 20482 /* Return domain number */; 20483 return idx;; 20484}; 20485 ; 20486 ; 20487int; 20488mg_start_domain(struct mg_context *ctx, const char **options); 20489{; 20490 return mg_start_domain2(ctx, options, NULL);; 20491}; 20492 ; 20493 ; 20494/* Feature check API function */; 20495unsigned; 20496mg_check_feature(unsig",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:611618,Modifiability,config,config,611618,"t64_t)get_random() << 31);; 20423 ; 20424#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20425 new_dom->shared_lua_websockets = NULL;; 20426#endif; 20427 ; 20428#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20429 if (!init_ssl_ctx(ctx, new_dom)) {; 20430 /* Init SSL failed */; 20431 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20432 mg_snprintf(NULL,; 20433 NULL, /* No truncation check for error buffers */; 20434 error->text,; 20435 error->text_buffer_size,; 20436 ""%s"",; 20437 ""Initializing SSL context failed"");; 20438 }; 20439 mg_free(new_dom);; 20440 return -3;; 20441 }; 20442#endif; 20443 ; 20444 /* Add element to linked list. */; 20445 mg_lock_context(ctx);; 20446 ; 20447 idx = 0;; 20448 dom = &(ctx->dd);; 20449 for (;;) {; 20450 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20451 dom->config[AUTHENTICATION_DOMAIN])) {; 20452 /* Domain collision */; 20453 mg_cry_ctx_internal(ctx,; 20454 ""domain %s already in use"",; 20455 new_dom->config[AUTHENTICATION_DOMAIN]);; 20456 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20457 mg_snprintf(NULL,; 20458 NULL, /* No truncation check for error buffers */; 20459 error->text,; 20460 error->text_buffer_size,; 20461 ""Domain %s specified by %s is already in use"",; 20462 new_dom->config[AUTHENTICATION_DOMAIN],; 20463 config_options[AUTHENTICATION_DOMAIN].name);; 20464 }; 20465 mg_free(new_dom);; 20466 mg_unlock_context(ctx);; 20467 return -5;; 20468 }; 20469 ; 20470 /* Count number of domains */; 20471 idx++;; 20472 ; 20473 if (dom->next == NULL) {; 20474 dom->next = new_dom;; 20475 break;; 20476 }; 20477 dom = dom->next;; 20478 }; 20479 ; 20480 mg_unlock_context(ctx);; 20481 ; 20482 /* Return domain number */; 20483 return idx;; 20484}; 20485 ; 20486 ; 20487int; 20488mg_start_domain(struct mg_context *ctx, const char **options); 20489{; 20490 return mg_start_domain2(ctx, options, NULL);; 20491}; 20492 ; 20493 ; 20494/* Feature check API function */; 20495unsigned; 20496mg_check_feature(unsig",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:611765,Modifiability,config,config,611765,"t64_t)get_random() << 31);; 20423 ; 20424#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20425 new_dom->shared_lua_websockets = NULL;; 20426#endif; 20427 ; 20428#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20429 if (!init_ssl_ctx(ctx, new_dom)) {; 20430 /* Init SSL failed */; 20431 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20432 mg_snprintf(NULL,; 20433 NULL, /* No truncation check for error buffers */; 20434 error->text,; 20435 error->text_buffer_size,; 20436 ""%s"",; 20437 ""Initializing SSL context failed"");; 20438 }; 20439 mg_free(new_dom);; 20440 return -3;; 20441 }; 20442#endif; 20443 ; 20444 /* Add element to linked list. */; 20445 mg_lock_context(ctx);; 20446 ; 20447 idx = 0;; 20448 dom = &(ctx->dd);; 20449 for (;;) {; 20450 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20451 dom->config[AUTHENTICATION_DOMAIN])) {; 20452 /* Domain collision */; 20453 mg_cry_ctx_internal(ctx,; 20454 ""domain %s already in use"",; 20455 new_dom->config[AUTHENTICATION_DOMAIN]);; 20456 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20457 mg_snprintf(NULL,; 20458 NULL, /* No truncation check for error buffers */; 20459 error->text,; 20460 error->text_buffer_size,; 20461 ""Domain %s specified by %s is already in use"",; 20462 new_dom->config[AUTHENTICATION_DOMAIN],; 20463 config_options[AUTHENTICATION_DOMAIN].name);; 20464 }; 20465 mg_free(new_dom);; 20466 mg_unlock_context(ctx);; 20467 return -5;; 20468 }; 20469 ; 20470 /* Count number of domains */; 20471 idx++;; 20472 ; 20473 if (dom->next == NULL) {; 20474 dom->next = new_dom;; 20475 break;; 20476 }; 20477 dom = dom->next;; 20478 }; 20479 ; 20480 mg_unlock_context(ctx);; 20481 ; 20482 /* Return domain number */; 20483 return idx;; 20484}; 20485 ; 20486 ; 20487int; 20488mg_start_domain(struct mg_context *ctx, const char **options); 20489{; 20490 return mg_start_domain2(ctx, options, NULL);; 20491}; 20492 ; 20493 ; 20494/* Feature check API function */; 20495unsigned; 20496mg_check_feature(unsig",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:612064,Modifiability,config,config,612064,"t64_t)get_random() << 31);; 20423 ; 20424#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20425 new_dom->shared_lua_websockets = NULL;; 20426#endif; 20427 ; 20428#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20429 if (!init_ssl_ctx(ctx, new_dom)) {; 20430 /* Init SSL failed */; 20431 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20432 mg_snprintf(NULL,; 20433 NULL, /* No truncation check for error buffers */; 20434 error->text,; 20435 error->text_buffer_size,; 20436 ""%s"",; 20437 ""Initializing SSL context failed"");; 20438 }; 20439 mg_free(new_dom);; 20440 return -3;; 20441 }; 20442#endif; 20443 ; 20444 /* Add element to linked list. */; 20445 mg_lock_context(ctx);; 20446 ; 20447 idx = 0;; 20448 dom = &(ctx->dd);; 20449 for (;;) {; 20450 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20451 dom->config[AUTHENTICATION_DOMAIN])) {; 20452 /* Domain collision */; 20453 mg_cry_ctx_internal(ctx,; 20454 ""domain %s already in use"",; 20455 new_dom->config[AUTHENTICATION_DOMAIN]);; 20456 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20457 mg_snprintf(NULL,; 20458 NULL, /* No truncation check for error buffers */; 20459 error->text,; 20460 error->text_buffer_size,; 20461 ""Domain %s specified by %s is already in use"",; 20462 new_dom->config[AUTHENTICATION_DOMAIN],; 20463 config_options[AUTHENTICATION_DOMAIN].name);; 20464 }; 20465 mg_free(new_dom);; 20466 mg_unlock_context(ctx);; 20467 return -5;; 20468 }; 20469 ; 20470 /* Count number of domains */; 20471 idx++;; 20472 ; 20473 if (dom->next == NULL) {; 20474 dom->next = new_dom;; 20475 break;; 20476 }; 20477 dom = dom->next;; 20478 }; 20479 ; 20480 mg_unlock_context(ctx);; 20481 ; 20482 /* Return domain number */; 20483 return idx;; 20484}; 20485 ; 20486 ; 20487int; 20488mg_start_domain(struct mg_context *ctx, const char **options); 20489{; 20490 return mg_start_domain2(ctx, options, NULL);; 20491}; 20492 ; 20493 ; 20494/* Feature check API function */; 20495unsigned; 20496mg_check_feature(unsig",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:626260,Modifiability,variab,variables,626260,"0907/* Get context information. It can be printed or stored by the caller.; 20908 * Return the size of available information. */; 20909int; 20910mg_get_context_info(const struct mg_context *ctx, char *buffer, int buflen); 20911{; 20912#if defined(USE_SERVER_STATS); 20913 char *end, *append_eoobj = NULL, block[256];; 20914 size_t context_info_length = 0;; 20915 ; 20916#if defined(_WIN32); 20917 static const char eol[] = ""\r\n"", eoobj[] = ""\r\n}\r\n"";; 20918#else; 20919 static const char eol[] = ""\n"", eoobj[] = ""\n}\n"";; 20920#endif; 20921 struct mg_memory_stat *ms = get_memory_stat((struct mg_context *)ctx);; 20922 ; 20923 if ((buffer == NULL) || (buflen < 1)) {; 20924 buflen = 0;; 20925 end = buffer;; 20926 } else {; 20927 *buffer = 0;; 20928 end = buffer + buflen;; 20929 }; 20930 if (buflen > (int)(sizeof(eoobj) - 1)) {; 20931 /* has enough space to append eoobj */; 20932 append_eoobj = buffer;; 20933 end -= sizeof(eoobj) - 1;; 20934 }; 20935 ; 20936 context_info_length += mg_str_append(&buffer, end, ""{"");; 20937 ; 20938 if (ms) { /* <-- should be always true */; 20939 /* Memory information */; 20940 int blockCount = (int)ms->blockCount;; 20941 int64_t totalMemUsed = ms->totalMemUsed;; 20942 int64_t maxMemUsed = ms->maxMemUsed;; 20943 if (totalMemUsed > maxMemUsed) {; 20944 maxMemUsed = totalMemUsed;; 20945 }; 20946 ; 20947 mg_snprintf(NULL,; 20948 NULL,; 20949 block,; 20950 sizeof(block),; 20951 ""%s\""memory\"" : {%s""; 20952 ""\""blocks\"" : %i,%s""; 20953 ""\""used\"" : %"" INT64_FMT "",%s""; 20954 ""\""maxUsed\"" : %"" INT64_FMT ""%s""; 20955 ""}"",; 20956 eol,; 20957 eol,; 20958 blockCount,; 20959 eol,; 20960 totalMemUsed,; 20961 eol,; 20962 maxMemUsed,; 20963 eol);; 20964 context_info_length += mg_str_append(&buffer, end, block);; 20965 }; 20966 ; 20967 if (ctx) {; 20968 /* Declare all variables at begin of the block, to comply; 20969 * with old C standards. */; 20970 char start_time_str[64] = {0};; 20971 char now_str[64] = {0};; 20972 time_t start_time = ctx->start_time;; 20973 t",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:631747,Modifiability,variab,variables,631747,,MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:707346,Modifiability,config,configchar,707346,hread_mutexpthread_mutex_t thread_mutexDefinition civetweb.c:2340; mg_context::callbacksstruct mg_callbacks callbacksDefinition civetweb.c:2395; mg_context::ddstruct mg_domain_context ddDefinition civetweb.c:2405; mg_context::listening_socket_fdsstruct pollfd * listening_socket_fdsDefinition civetweb.c:2323; mg_context::sq_fullpthread_cond_t sq_fullDefinition civetweb.c:2357; mg_context::sq_tailvolatile int sq_tailDefinition civetweb.c:2356; mg_context::num_listening_socketsunsigned int num_listening_socketsDefinition civetweb.c:2324; mg_context::sq_sizeint sq_sizeDefinition civetweb.c:2360; mg_context::max_request_sizeunsigned int max_request_sizeDefinition civetweb.c:2367; mg_context::cfg_worker_threadsunsigned int cfg_worker_threadsDefinition civetweb.c:2344; mg_context::nonce_mutexpthread_mutex_t nonce_mutexDefinition civetweb.c:2390; mg_context::sq_blockedvolatile int sq_blockedDefinition civetweb.c:2359; mg_domain_contextDefinition civetweb.c:2251; mg_domain_context::configchar * config[NUM_OPTIONS]Definition civetweb.c:2253; mg_domain_context::nonce_countunsigned long nonce_countDefinition civetweb.c:2259; mg_domain_context::ssl_cert_last_mtimeint64_t ssl_cert_last_mtimeDefinition civetweb.c:2255; mg_domain_context::auth_nonce_maskuint64_t auth_nonce_maskDefinition civetweb.c:2258; mg_domain_context::nextstruct mg_domain_context * nextDefinition civetweb.c:2267; mg_domain_context::ssl_ctxSSL_CTX * ssl_ctxDefinition civetweb.c:2252; mg_domain_context::handlersstruct mg_handler_info * handlersDefinition civetweb.c:2254; mg_error_dataDefinition civetweb.h:1671; mg_error_data::codeunsigned * codeDefinition civetweb.h:1672; mg_error_data::text_buffer_sizesize_t text_buffer_sizeDefinition civetweb.h:1674; mg_error_data::textchar * textDefinition civetweb.h:1673; mg_file_accessDefinition civetweb.c:1871; mg_file_access::fpFILE * fpDefinition civetweb.c:1873; mg_file_statDefinition civetweb.c:1860; mg_file_stat::sizeuint64_t sizeDefinition civetweb.c:1862; mg_file_sta,MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:707359,Modifiability,config,config,707359,hread_mutexpthread_mutex_t thread_mutexDefinition civetweb.c:2340; mg_context::callbacksstruct mg_callbacks callbacksDefinition civetweb.c:2395; mg_context::ddstruct mg_domain_context ddDefinition civetweb.c:2405; mg_context::listening_socket_fdsstruct pollfd * listening_socket_fdsDefinition civetweb.c:2323; mg_context::sq_fullpthread_cond_t sq_fullDefinition civetweb.c:2357; mg_context::sq_tailvolatile int sq_tailDefinition civetweb.c:2356; mg_context::num_listening_socketsunsigned int num_listening_socketsDefinition civetweb.c:2324; mg_context::sq_sizeint sq_sizeDefinition civetweb.c:2360; mg_context::max_request_sizeunsigned int max_request_sizeDefinition civetweb.c:2367; mg_context::cfg_worker_threadsunsigned int cfg_worker_threadsDefinition civetweb.c:2344; mg_context::nonce_mutexpthread_mutex_t nonce_mutexDefinition civetweb.c:2390; mg_context::sq_blockedvolatile int sq_blockedDefinition civetweb.c:2359; mg_domain_contextDefinition civetweb.c:2251; mg_domain_context::configchar * config[NUM_OPTIONS]Definition civetweb.c:2253; mg_domain_context::nonce_countunsigned long nonce_countDefinition civetweb.c:2259; mg_domain_context::ssl_cert_last_mtimeint64_t ssl_cert_last_mtimeDefinition civetweb.c:2255; mg_domain_context::auth_nonce_maskuint64_t auth_nonce_maskDefinition civetweb.c:2258; mg_domain_context::nextstruct mg_domain_context * nextDefinition civetweb.c:2267; mg_domain_context::ssl_ctxSSL_CTX * ssl_ctxDefinition civetweb.c:2252; mg_domain_context::handlersstruct mg_handler_info * handlersDefinition civetweb.c:2254; mg_error_dataDefinition civetweb.h:1671; mg_error_data::codeunsigned * codeDefinition civetweb.h:1672; mg_error_data::text_buffer_sizesize_t text_buffer_sizeDefinition civetweb.h:1674; mg_error_data::textchar * textDefinition civetweb.h:1673; mg_file_accessDefinition civetweb.c:1871; mg_file_access::fpFILE * fpDefinition civetweb.c:1873; mg_file_statDefinition civetweb.c:1860; mg_file_stat::sizeuint64_t sizeDefinition civetweb.c:1862; mg_file_sta,MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:5487,Performance,queue,queue,5487,"ing C99 support */; 103#pragma warning(disable : 4204); 104/* padding added after data member */; 105#pragma warning(disable : 4820); 106/* not defined as a preprocessor macro, replacing with '0' for '#if/#elif' */; 107#pragma warning(disable : 4668); 108/* no function prototype given: converting '()' to '(void)' */; 109#pragma warning(disable : 4255); 110/* function has been selected for automatic inline expansion */; 111#pragma warning(disable : 4711); 112#endif; 113 ; 114 ; 115/* This code uses static_assert to check some conditions.; 116 * Unfortunately some compilers still do not support it, so we have a; 117 * replacement function here. */; 118#if defined(__STDC_VERSION__) && __STDC_VERSION__ > 201100L; 119#define mg_static_assert _Static_assert; 120#elif defined(__cplusplus) && __cplusplus >= 201103L; 121#define mg_static_assert static_assert; 122#else; 123char static_assert_replacement[1];; 124#define mg_static_assert(cond, txt) \; 125 extern char static_assert_replacement[(cond) ? 1 : -1]; 126#endif; 127 ; 128mg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,; 129 ""int data type size check"");; 130mg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,; 131 ""pointer data type size check"");; 132mg_static_assert(sizeof(void *) >= sizeof(int), ""data type size check"");; 133 ; 134 ; 135/* Select queue implementation. Diagnosis features originally only implemented; 136 * for the ""ALTERNATIVE_QUEUE"" have been ported to the previous queue; 137 * implementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEU",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:5624,Performance,queue,queue,5624,"ning(disable : 4711); 112#endif; 113 ; 114 ; 115/* This code uses static_assert to check some conditions.; 116 * Unfortunately some compilers still do not support it, so we have a; 117 * replacement function here. */; 118#if defined(__STDC_VERSION__) && __STDC_VERSION__ > 201100L; 119#define mg_static_assert _Static_assert; 120#elif defined(__cplusplus) && __cplusplus >= 201103L; 121#define mg_static_assert static_assert; 122#else; 123char static_assert_replacement[1];; 124#define mg_static_assert(cond, txt) \; 125 extern char static_assert_replacement[(cond) ? 1 : -1]; 126#endif; 127 ; 128mg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,; 129 ""int data type size check"");; 130mg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,; 131 ""pointer data type size check"");; 132mg_static_assert(sizeof(void *) >= sizeof(int), ""data type size check"");; 133 ; 134 ; 135/* Select queue implementation. Diagnosis features originally only implemented; 136 * for the ""ALTERNATIVE_QUEUE"" have been ported to the previous queue; 137 * implementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read acce",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:5778,Performance,queue,queue,5778,"18#if defined(__STDC_VERSION__) && __STDC_VERSION__ > 201100L; 119#define mg_static_assert _Static_assert; 120#elif defined(__cplusplus) && __cplusplus >= 201103L; 121#define mg_static_assert static_assert; 122#else; 123char static_assert_replacement[1];; 124#define mg_static_assert(cond, txt) \; 125 extern char static_assert_replacement[(cond) ? 1 : -1]; 126#endif; 127 ; 128mg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,; 129 ""int data type size check"");; 130mg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,; 131 ""pointer data type size check"");; 132mg_static_assert(sizeof(void *) >= sizeof(int), ""data type size check"");; 133 ; 134 ; 135/* Select queue implementation. Diagnosis features originally only implemented; 136 * for the ""ALTERNATIVE_QUEUE"" have been ported to the previous queue; 137 * implementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping be",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:5817,Performance,queue,queue,5817,"18#if defined(__STDC_VERSION__) && __STDC_VERSION__ > 201100L; 119#define mg_static_assert _Static_assert; 120#elif defined(__cplusplus) && __cplusplus >= 201103L; 121#define mg_static_assert static_assert; 122#else; 123char static_assert_replacement[1];; 124#define mg_static_assert(cond, txt) \; 125 extern char static_assert_replacement[(cond) ? 1 : -1]; 126#endif; 127 ; 128mg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,; 129 ""int data type size check"");; 130mg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,; 131 ""pointer data type size check"");; 132mg_static_assert(sizeof(void *) >= sizeof(int), ""data type size check"");; 133 ; 134 ; 135/* Select queue implementation. Diagnosis features originally only implemented; 136 * for the ""ALTERNATIVE_QUEUE"" have been ported to the previous queue; 137 * implementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping be",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:5907,Performance,queue,queue,5907,"18#if defined(__STDC_VERSION__) && __STDC_VERSION__ > 201100L; 119#define mg_static_assert _Static_assert; 120#elif defined(__cplusplus) && __cplusplus >= 201103L; 121#define mg_static_assert static_assert; 122#else; 123char static_assert_replacement[1];; 124#define mg_static_assert(cond, txt) \; 125 extern char static_assert_replacement[(cond) ? 1 : -1]; 126#endif; 127 ; 128mg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,; 129 ""int data type size check"");; 130mg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,; 131 ""pointer data type size check"");; 132mg_static_assert(sizeof(void *) >= sizeof(int), ""data type size check"");; 133 ; 134 ; 135/* Select queue implementation. Diagnosis features originally only implemented; 136 * for the ""ALTERNATIVE_QUEUE"" have been ported to the previous queue; 137 * implementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping be",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:6041,Performance,queue,queues,6041,"rt; 122#else; 123char static_assert_replacement[1];; 124#define mg_static_assert(cond, txt) \; 125 extern char static_assert_replacement[(cond) ? 1 : -1]; 126#endif; 127 ; 128mg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,; 129 ""int data type size check"");; 130mg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,; 131 ""pointer data type size check"");; 132mg_static_assert(sizeof(void *) >= sizeof(int), ""data type size check"");; 133 ; 134 ; 135/* Select queue implementation. Diagnosis features originally only implemented; 136 * for the ""ALTERNATIVE_QUEUE"" have been ported to the previous queue; 137 * implementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping between URLs and local; 161 * file names.; 162 * NO_FILESYSTEM = do not access any file at all. Useful for embedded; 163 * devices without file system. Logging to files in not available; 164 * (use callba",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:15703,Performance,optimiz,optimize,15703,"mebase_ifo.denom);; 412 ; 413 t->tv_sec = now / 1000000000;; 414 t->tv_nsec = now % 1000000000;; 415 return 0;; 416 }; 417 return -1; /* EINVAL - Clock ID is unknown */; 418}; 419 ; 420/* if clock_gettime is declared, then __CLOCK_AVAILABILITY will be defined */; 421#if defined(__CLOCK_AVAILABILITY); 422/* If we compiled with Mac OSX 10.12 or later, then clock_gettime will be; 423 * declared but it may be NULL at runtime. So we need to check before using; 424 * it. */; 425static int; 426_civet_safe_clock_gettime(int clk_id, struct timespec *t); 427{; 428 if (clock_gettime) {; 429 return clock_gettime(clk_id, t);; 430 }; 431 return _civet_clock_gettime(clk_id, t);; 432}; 433#define clock_gettime _civet_safe_clock_gettime; 434#else; 435#define clock_gettime _civet_clock_gettime; 436#endif; 437 ; 438#endif; 439 ; 440 ; 441#if !defined(_WIN32); 442/* Unix might return different error codes indicating to try again.; 443 * For Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; 444 * decades ago, but better check both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOU",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:34980,Performance,load,load,34980,"endif /* defined(GCC_DIAGNOSTIC) */; 1080#if defined(__clang__); 1081/* Show no warning in case system functions are not used. */; 1082#pragma clang diagnostic push; 1083#pragma clang diagnostic ignored ""-Wunused-function""; 1084#endif; 1085 ; 1086static pthread_mutex_t global_lock_mutex;; 1087 ; 1088 ; 1089FUNCTION_MAY_BE_UNUSED; 1090static void; 1091mg_global_lock(void); 1092{; 1093 (void)pthread_mutex_lock(&global_lock_mutex);; 1094}; 1095 ; 1096 ; 1097FUNCTION_MAY_BE_UNUSED; 1098static void; 1099mg_global_unlock(void); 1100{; 1101 (void)pthread_mutex_unlock(&global_lock_mutex);; 1102}; 1103 ; 1104 ; 1105#if defined(_WIN64); 1106mg_static_assert(SIZE_MAX == 0xFFFFFFFFFFFFFFFFu, ""Mismatch for atomic types"");; 1107#elif defined(_WIN32); 1108mg_static_assert(SIZE_MAX == 0xFFFFFFFFu, ""Mismatch for atomic types"");; 1109#endif; 1110 ; 1111 ; 1112/* Atomic functions working on ptrdiff_t (""signed size_t"").; 1113 * Operations: Increment, Decrement, Add, Maximum.; 1114 * Up to size_t, they do not an atomic ""load"" operation.; 1115 */; 1116FUNCTION_MAY_BE_UNUSED; 1117static ptrdiff_t; 1118mg_atomic_inc(volatile ptrdiff_t *addr); 1119{; 1120 ptrdiff_t ret;; 1121 ; 1122#if defined(_WIN64) && !defined(NO_ATOMICS); 1123 ret = InterlockedIncrement64(addr);; 1124#elif defined(_WIN32) && !defined(NO_ATOMICS); 1125 ret = InterlockedIncrement(addr);; 1126#elif defined(__GNUC__) \; 1127 && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0))) \; 1128 && !defined(NO_ATOMICS); 1129 ret = __sync_add_and_fetch(addr, 1);; 1130#else; 1131 mg_global_lock();; 1132 ret = (++(*addr));; 1133 mg_global_unlock();; 1134#endif; 1135 return ret;; 1136}; 1137 ; 1138 ; 1139FUNCTION_MAY_BE_UNUSED; 1140static ptrdiff_t; 1141mg_atomic_dec(volatile ptrdiff_t *addr); 1142{; 1143 ptrdiff_t ret;; 1144 ; 1145#if defined(_WIN64) && !defined(NO_ATOMICS); 1146 ret = InterlockedDecrement64(addr);; 1147#elif defined(_WIN32) && !defined(NO_ATOMICS); 1148 ret = InterlockedDecrement(addr);; 1149#elif defined(__",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:53351,Performance,load,loading,53351,"snow.tv_sec,; 1702 (unsigned long)tsnow.tv_nsec,; 1703 thread_id,; 1704 func,; 1705 line);; 1706 va_start(args, fmt);; 1707 vfprintf(DEBUG_TRACE_STREAM, fmt, args);; 1708 va_end(args);; 1709 putc('\n', DEBUG_TRACE_STREAM);; 1710 fflush(DEBUG_TRACE_STREAM);; 1711 funlockfile(DEBUG_TRACE_STREAM);; 1712}; 1713#endif /* NEED_DEBUG_TRACE_FUNC */; 1714 ; 1715 ; 1716#define MD5_STATIC static; 1717#include ""md5.inl""; 1718 ; 1719/* Darwin prior to 7.0 and Win32 do not have socklen_t */; 1720#if defined(NO_SOCKLEN_T); 1721typedef int socklen_t;; 1722#endif /* NO_SOCKLEN_T */; 1723 ; 1724#define IP_ADDR_STR_LEN (50) /* IPv6 hex string is 46 chars */; 1725 ; 1726#if !defined(MSG_NOSIGNAL); 1727#define MSG_NOSIGNAL (0); 1728#endif; 1729 ; 1730 ; 1731/* SSL: mbedTLS vs. no-ssl vs. OpenSSL */; 1732#if defined(USE_MBEDTLS); 1733/* mbedTLS */; 1734#include ""mod_mbedtls.inl""; 1735 ; 1736#elif defined(NO_SSL); 1737/* no SSL */; 1738typedef struct SSL SSL; /* dummy for SSL argument to push/pull */; 1739typedef struct SSL_CTX SSL_CTX;; 1740 ; 1741#elif defined(NO_SSL_DL); 1742/* OpenSSL without dynamic loading */; 1743#include <openssl/bn.h>; 1744#include <openssl/conf.h>; 1745#include <openssl/crypto.h>; 1746#include <openssl/dh.h>; 1747#include <openssl/err.h>; 1748#include <openssl/opensslv.h>; 1749#include <openssl/pem.h>; 1750#include <openssl/ssl.h>; 1751#include <openssl/tls1.h>; 1752#include <openssl/x509.h>; 1753 ; 1754#if defined(WOLFSSL_VERSION); 1755/* Additional defines for WolfSSL, see; 1756 * https://github.com/civetweb/civetweb/issues/583 */; 1757#include ""wolfssl_extras.inl""; 1758#endif; 1759 ; 1760#if defined(OPENSSL_IS_BORINGSSL); 1761/* From boringssl/src/include/openssl/mem.h:; 1762 *; 1763 * OpenSSL has, historically, had a complex set of malloc debugging options.; 1764 * However, that was written in a time before Valgrind and ASAN. Since we now; 1765 * have those tools, the OpenSSL allocation functions are simply macros around; 1766 * the standard memory functions.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:55106,Performance,load,loaded,55106,"L, see; 1756 * https://github.com/civetweb/civetweb/issues/583 */; 1757#include ""wolfssl_extras.inl""; 1758#endif; 1759 ; 1760#if defined(OPENSSL_IS_BORINGSSL); 1761/* From boringssl/src/include/openssl/mem.h:; 1762 *; 1763 * OpenSSL has, historically, had a complex set of malloc debugging options.; 1764 * However, that was written in a time before Valgrind and ASAN. Since we now; 1765 * have those tools, the OpenSSL allocation functions are simply macros around; 1766 * the standard memory functions.; 1767 *; 1768 * #define OPENSSL_free free */; 1769#define free free; 1770// disable for boringssl; 1771#define CONF_modules_unload(a) ((void)0); 1772#define ENGINE_cleanup() ((void)0); 1773#endif; 1774 ; 1775/* If OpenSSL headers are included, automatically select the API version */; 1776#if (OPENSSL_VERSION_NUMBER >= 0x30000000L); 1777#if !defined(OPENSSL_API_3_0); 1778#define OPENSSL_API_3_0; 1779#endif; 1780#define OPENSSL_REMOVE_THREAD_STATE(); 1781#else; 1782#if (OPENSSL_VERSION_NUMBER >= 0x10100000L); 1783#if !defined(OPENSSL_API_1_1); 1784#define OPENSSL_API_1_1; 1785#endif; 1786#define OPENSSL_REMOVE_THREAD_STATE(); 1787#else; 1788#if !defined(OPENSSL_API_1_0); 1789#define OPENSSL_API_1_0; 1790#endif; 1791#define OPENSSL_REMOVE_THREAD_STATE() ERR_remove_thread_state(NULL); 1792#endif; 1793#endif; 1794 ; 1795 ; 1796#else; 1797/* SSL loaded dynamically from DLL / shared object */; 1798/* Add all prototypes here, to be independent from OpenSSL source; 1799 * installation. */; 1800#include ""openssl_dl.inl""; 1801 ; 1802#endif /* Various SSL bindings */; 1803 ; 1804 ; 1805#if !defined(NO_CACHING); 1806static const char month_names[][4] = {""Jan"",; 1807 ""Feb"",; 1808 ""Mar"",; 1809 ""Apr"",; 1810 ""May"",; 1811 ""Jun"",; 1812 ""Jul"",; 1813 ""Aug"",; 1814 ""Sep"",; 1815 ""Oct"",; 1816 ""Nov"",; 1817 ""Dec""};; 1818#endif /* !NO_CACHING */; 1819 ; 1820 ; 1821/* Unified socket address. For IPv6 support, add IPv6 address structure in; 1822 * the union u. */; 1823union usa {; 1824 struct sockadd",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:57514,Performance,queue,queued,57514,"{; 1838 if (s->sa.sa_family == AF_INET); 1839 return s->sin.sin_port;; 1840#if defined(USE_IPV6); 1841 if (s->sa.sa_family == AF_INET6); 1842 return s->sin6.sin6_port;; 1843#endif; 1844 return 0;; 1845}; 1846#endif; 1847#if defined(USE_IPV6); 1848#define USA_IN_PORT_UNSAFE(s) \; 1849 (((s)->sa.sa_family == AF_INET6) ? (s)->sin6.sin6_port : (s)->sin.sin_port); 1850#else; 1851#define USA_IN_PORT_UNSAFE(s) ((s)->sin.sin_port); 1852#endif; 1853 ; 1854/* Describes a string (chunk of memory). */; 1855struct vec {; 1856 const char *ptr;; 1857 size_t len;; 1858};; 1859 ; 1860struct mg_file_stat {; 1861 /* File properties filled by mg_stat: */; 1862 uint64_t size;; 1863 time_t last_modified;; 1864 int is_directory; /* Set to 1 if mg_stat is called for a directory */; 1865 int is_gzipped; /* Set to 1 if the content is gzipped, in which; 1866 * case we need a ""Content-Eencoding: gzip"" header */; 1867 int location; /* 0 = nowhere, 1 = on disk, 2 = in memory */; 1868};; 1869 ; 1870 ; 1871struct mg_file_access {; 1872 /* File properties filled by mg_fopen: */; 1873 FILE *fp;; 1874};; 1875 ; 1876struct mg_file {; 1877 struct mg_file_stat stat;; 1878 struct mg_file_access access;; 1879};; 1880 ; 1881 ; 1882#define STRUCT_FILE_INITIALIZER \; 1883 { \; 1884 {(uint64_t)0, (time_t)0, 0, 0, 0}, \; 1885 { \; 1886 (FILE *)NULL \; 1887 } \; 1888 }; 1889 ; 1890 ; 1891/* Describes listening socket, or socket which was accept()-ed by the master; 1892 * thread and queued for future handling by the worker thread. */; 1893struct socket {; 1894 SOCKET sock; /* Listening socket */; 1895 union usa lsa; /* Local socket address */; 1896 union usa rsa; /* Remote socket address */; 1897 unsigned char is_ssl; /* Is port SSL-ed */; 1898 unsigned char ssl_redir; /* Is port supposed to redirect everything to SSL; 1899 * port */; 1900 unsigned char in_use; /* 0: invalid, 1: valid, 2: free */; 1901};; 1902 ; 1903 ; 1904/* Enum const for all options must be in sync with; 1905 * static struct mg_option config_",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:62233,Performance,throttle,throttle,62233," name, config types, default value.; 2047 * Must be in the same order as the enum const above.; 2048 */; 2049static const struct mg_option config_options[] = {; 2050 ; 2051 /* Once for each server */; 2052 {""listening_ports"", MG_CONFIG_TYPE_STRING_LIST, ""8080""},; 2053 {""num_threads"", MG_CONFIG_TYPE_NUMBER, ""50""},; 2054 {""run_as_user"", MG_CONFIG_TYPE_STRING, NULL},; 2055 {""tcp_nodelay"", MG_CONFIG_TYPE_NUMBER, ""0""},; 2056 {""max_request_size"", MG_CONFIG_TYPE_NUMBER, ""16384""},; 2057 {""linger_timeout_ms"", MG_CONFIG_TYPE_NUMBER, NULL},; 2058 {""connection_queue"", MG_CONFIG_TYPE_NUMBER, ""20""},; 2059 {""listen_backlog"", MG_CONFIG_TYPE_NUMBER, ""200""},; 2060#if defined(__linux__); 2061 {""allow_sendfile_call"", MG_CONFIG_TYPE_BOOLEAN, ""yes""},; 2062#endif; 2063#if defined(_WIN32); 2064 {""case_sensitive"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2065#endif; 2066 {""throttle"", MG_CONFIG_TYPE_STRING_LIST, NULL},; 2067 {""enable_keep_alive"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2068 {""request_timeout_ms"", MG_CONFIG_TYPE_NUMBER, ""30000""},; 2069 {""keep_alive_timeout_ms"", MG_CONFIG_TYPE_NUMBER, ""500""},; 2070#if defined(USE_WEBSOCKET); 2071 {""websocket_timeout_ms"", MG_CONFIG_TYPE_NUMBER, NULL},; 2072 {""enable_websocket_ping_pong"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2073#endif; 2074 {""decode_url"", MG_CONFIG_TYPE_BOOLEAN, ""yes""},; 2075 {""decode_query_string"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2076#if defined(USE_LUA); 2077 {""lua_background_script"", MG_CONFIG_TYPE_FILE, NULL},; 2078 {""lua_background_script_params"", MG_CONFIG_TYPE_STRING_LIST, NULL},; 2079#endif; 2080#if defined(USE_HTTP2); 2081 {""enable_http2"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2082#endif; 2083 ; 2084 /* Once for each domain */; 2085 {""document_root"", MG_CONFIG_TYPE_DIRECTORY, NULL},; 2086 ; 2087 {""access_log_file"", MG_CONFIG_TYPE_FILE, NULL},; 2088 {""error_log_file"", MG_CONFIG_TYPE_FILE, NULL},; 2089 ; 2090 {""cgi_pattern"", MG_CONFIG_TYPE_EXT_PATTERN, ""**.cgi$|**.pl$|**.php$""},; 2091 {""cgi_environment"", MG_CONFIG_TYPE_STRING_LIST, NULL},; 2092 {""cg",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:72340,Performance,queue,queue,72340,"2299}; 2300 ; 2301#else /* STOP_FLAG_NEEDS_LOCK */; 2302 ; 2303typedef int volatile stop_flag_t;; 2304#define STOP_FLAG_IS_ZERO(f) ((*(f)) == 0); 2305#define STOP_FLAG_IS_TWO(f) ((*(f)) == 2); 2306#define STOP_FLAG_ASSIGN(f, v) ((*(f)) = (v)); 2307 ; 2308#endif /* STOP_FLAG_NEEDS_LOCK */; 2309 ; 2310 ; 2311struct mg_context {; 2312 ; 2313 /* Part 1 - Physical context:; 2314 * This holds threads, ports, timeouts, ...; 2315 * set for the entire server, independent from the; 2316 * addressed hostname.; 2317 */; 2318 ; 2319 /* Connection related */; 2320 int context_type; /* See CONTEXT_* above */; 2321 ; 2322 struct socket *listening_sockets;; 2323 struct mg_pollfd *listening_socket_fds;; 2324 unsigned int num_listening_sockets;; 2325 ; 2326 struct mg_connection *worker_connections; /* The connection struct, pre-; 2327 * allocated for each worker */; 2328 ; 2329#if defined(USE_SERVER_STATS); 2330 volatile ptrdiff_t active_connections;; 2331 volatile ptrdiff_t max_active_connections;; 2332 volatile ptrdiff_t total_connections;; 2333 volatile ptrdiff_t total_requests;; 2334 volatile int64_t total_data_read;; 2335 volatile int64_t total_data_written;; 2336#endif; 2337 ; 2338 /* Thread related */; 2339 stop_flag_t stop_flag; /* Should we stop event loop */; 2340 pthread_mutex_t thread_mutex; /* Protects client_socks or queue */; 2341 ; 2342 pthread_t masterthreadid; /* The master thread ID */; 2343 unsigned int; 2344 cfg_worker_threads; /* The number of configured worker threads. */; 2345 pthread_t *worker_threadids; /* The worker thread IDs */; 2346 unsigned long starter_thread_idx; /* thread index which called mg_start */; 2347 ; 2348 /* Connection to thread dispatching */; 2349#if defined(ALTERNATIVE_QUEUE); 2350 struct socket *client_socks;; 2351 void **client_wait_events;; 2352#else; 2353 struct socket *squeue; /* Socket queue (sq) : accepted sockets waiting for a; 2354 worker thread */; 2355 volatile int sq_head; /* Head of the socket queue */; 2356 volatile int sq_t",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:72857,Performance,queue,queue,72857,";; 2336#endif; 2337 ; 2338 /* Thread related */; 2339 stop_flag_t stop_flag; /* Should we stop event loop */; 2340 pthread_mutex_t thread_mutex; /* Protects client_socks or queue */; 2341 ; 2342 pthread_t masterthreadid; /* The master thread ID */; 2343 unsigned int; 2344 cfg_worker_threads; /* The number of configured worker threads. */; 2345 pthread_t *worker_threadids; /* The worker thread IDs */; 2346 unsigned long starter_thread_idx; /* thread index which called mg_start */; 2347 ; 2348 /* Connection to thread dispatching */; 2349#if defined(ALTERNATIVE_QUEUE); 2350 struct socket *client_socks;; 2351 void **client_wait_events;; 2352#else; 2353 struct socket *squeue; /* Socket queue (sq) : accepted sockets waiting for a; 2354 worker thread */; 2355 volatile int sq_head; /* Head of the socket queue */; 2356 volatile int sq_tail; /* Tail of the socket queue */; 2357 pthread_cond_t sq_full; /* Signaled when socket is produced */; 2358 pthread_cond_t sq_empty; /* Signaled when socket is consumed */; 2359 volatile int sq_blocked; /* Status information: sq is full */; 2360 int sq_size; /* No of elements in socket queue */; 2361#if defined(USE_SERVER_STATS); 2362 int sq_max_fill;; 2363#endif /* USE_SERVER_STATS */; 2364#endif /* ALTERNATIVE_QUEUE */; 2365 ; 2366 /* Memory related */; 2367 unsigned int max_request_size; /* The max request size */; 2368 ; 2369#if defined(USE_SERVER_STATS); 2370 struct mg_memory_stat ctx_memory;; 2371#endif; 2372 ; 2373 /* Operating system related */; 2374 char *systemName; /* What operating system is running */; 2375 time_t start_time; /* Server start time, used for authentication; 2376 * and for diagnstics. */; 2377 ; 2378#if defined(USE_TIMERS); 2379 struct ttimers *timers;; 2380#endif; 2381 ; 2382 /* Lua specific: Background operations and shared websockets */; 2383#if defined(USE_LUA); 2384 void *lua_background_state; /* lua_State (here as void *) */; 2385 pthread_mutex_t lua_bg_mutex; /* Protect background state */; 2386 int lua_bg_",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:72974,Performance,queue,queue,72974,";; 2336#endif; 2337 ; 2338 /* Thread related */; 2339 stop_flag_t stop_flag; /* Should we stop event loop */; 2340 pthread_mutex_t thread_mutex; /* Protects client_socks or queue */; 2341 ; 2342 pthread_t masterthreadid; /* The master thread ID */; 2343 unsigned int; 2344 cfg_worker_threads; /* The number of configured worker threads. */; 2345 pthread_t *worker_threadids; /* The worker thread IDs */; 2346 unsigned long starter_thread_idx; /* thread index which called mg_start */; 2347 ; 2348 /* Connection to thread dispatching */; 2349#if defined(ALTERNATIVE_QUEUE); 2350 struct socket *client_socks;; 2351 void **client_wait_events;; 2352#else; 2353 struct socket *squeue; /* Socket queue (sq) : accepted sockets waiting for a; 2354 worker thread */; 2355 volatile int sq_head; /* Head of the socket queue */; 2356 volatile int sq_tail; /* Tail of the socket queue */; 2357 pthread_cond_t sq_full; /* Signaled when socket is produced */; 2358 pthread_cond_t sq_empty; /* Signaled when socket is consumed */; 2359 volatile int sq_blocked; /* Status information: sq is full */; 2360 int sq_size; /* No of elements in socket queue */; 2361#if defined(USE_SERVER_STATS); 2362 int sq_max_fill;; 2363#endif /* USE_SERVER_STATS */; 2364#endif /* ALTERNATIVE_QUEUE */; 2365 ; 2366 /* Memory related */; 2367 unsigned int max_request_size; /* The max request size */; 2368 ; 2369#if defined(USE_SERVER_STATS); 2370 struct mg_memory_stat ctx_memory;; 2371#endif; 2372 ; 2373 /* Operating system related */; 2374 char *systemName; /* What operating system is running */; 2375 time_t start_time; /* Server start time, used for authentication; 2376 * and for diagnstics. */; 2377 ; 2378#if defined(USE_TIMERS); 2379 struct ttimers *timers;; 2380#endif; 2381 ; 2382 /* Lua specific: Background operations and shared websockets */; 2383#if defined(USE_LUA); 2384 void *lua_background_state; /* lua_State (here as void *) */; 2385 pthread_mutex_t lua_bg_mutex; /* Protect background state */; 2386 int lua_bg_",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:73033,Performance,queue,queue,73033,";; 2336#endif; 2337 ; 2338 /* Thread related */; 2339 stop_flag_t stop_flag; /* Should we stop event loop */; 2340 pthread_mutex_t thread_mutex; /* Protects client_socks or queue */; 2341 ; 2342 pthread_t masterthreadid; /* The master thread ID */; 2343 unsigned int; 2344 cfg_worker_threads; /* The number of configured worker threads. */; 2345 pthread_t *worker_threadids; /* The worker thread IDs */; 2346 unsigned long starter_thread_idx; /* thread index which called mg_start */; 2347 ; 2348 /* Connection to thread dispatching */; 2349#if defined(ALTERNATIVE_QUEUE); 2350 struct socket *client_socks;; 2351 void **client_wait_events;; 2352#else; 2353 struct socket *squeue; /* Socket queue (sq) : accepted sockets waiting for a; 2354 worker thread */; 2355 volatile int sq_head; /* Head of the socket queue */; 2356 volatile int sq_tail; /* Tail of the socket queue */; 2357 pthread_cond_t sq_full; /* Signaled when socket is produced */; 2358 pthread_cond_t sq_empty; /* Signaled when socket is consumed */; 2359 volatile int sq_blocked; /* Status information: sq is full */; 2360 int sq_size; /* No of elements in socket queue */; 2361#if defined(USE_SERVER_STATS); 2362 int sq_max_fill;; 2363#endif /* USE_SERVER_STATS */; 2364#endif /* ALTERNATIVE_QUEUE */; 2365 ; 2366 /* Memory related */; 2367 unsigned int max_request_size; /* The max request size */; 2368 ; 2369#if defined(USE_SERVER_STATS); 2370 struct mg_memory_stat ctx_memory;; 2371#endif; 2372 ; 2373 /* Operating system related */; 2374 char *systemName; /* What operating system is running */; 2375 time_t start_time; /* Server start time, used for authentication; 2376 * and for diagnstics. */; 2377 ; 2378#if defined(USE_TIMERS); 2379 struct ttimers *timers;; 2380#endif; 2381 ; 2382 /* Lua specific: Background operations and shared websockets */; 2383#if defined(USE_LUA); 2384 void *lua_background_state; /* lua_State (here as void *) */; 2385 pthread_mutex_t lua_bg_mutex; /* Protect background state */; 2386 int lua_bg_",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:73296,Performance,queue,queue,73296,";; 2336#endif; 2337 ; 2338 /* Thread related */; 2339 stop_flag_t stop_flag; /* Should we stop event loop */; 2340 pthread_mutex_t thread_mutex; /* Protects client_socks or queue */; 2341 ; 2342 pthread_t masterthreadid; /* The master thread ID */; 2343 unsigned int; 2344 cfg_worker_threads; /* The number of configured worker threads. */; 2345 pthread_t *worker_threadids; /* The worker thread IDs */; 2346 unsigned long starter_thread_idx; /* thread index which called mg_start */; 2347 ; 2348 /* Connection to thread dispatching */; 2349#if defined(ALTERNATIVE_QUEUE); 2350 struct socket *client_socks;; 2351 void **client_wait_events;; 2352#else; 2353 struct socket *squeue; /* Socket queue (sq) : accepted sockets waiting for a; 2354 worker thread */; 2355 volatile int sq_head; /* Head of the socket queue */; 2356 volatile int sq_tail; /* Tail of the socket queue */; 2357 pthread_cond_t sq_full; /* Signaled when socket is produced */; 2358 pthread_cond_t sq_empty; /* Signaled when socket is consumed */; 2359 volatile int sq_blocked; /* Status information: sq is full */; 2360 int sq_size; /* No of elements in socket queue */; 2361#if defined(USE_SERVER_STATS); 2362 int sq_max_fill;; 2363#endif /* USE_SERVER_STATS */; 2364#endif /* ALTERNATIVE_QUEUE */; 2365 ; 2366 /* Memory related */; 2367 unsigned int max_request_size; /* The max request size */; 2368 ; 2369#if defined(USE_SERVER_STATS); 2370 struct mg_memory_stat ctx_memory;; 2371#endif; 2372 ; 2373 /* Operating system related */; 2374 char *systemName; /* What operating system is running */; 2375 time_t start_time; /* Server start time, used for authentication; 2376 * and for diagnstics. */; 2377 ; 2378#if defined(USE_TIMERS); 2379 struct ttimers *timers;; 2380#endif; 2381 ; 2382 /* Lua specific: Background operations and shared websockets */; 2383#if defined(USE_LUA); 2384 void *lua_background_state; /* lua_State (here as void *) */; 2385 pthread_mutex_t lua_bg_mutex; /* Protect background state */; 2386 int lua_bg_",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:79056,Performance,throttle,throttle,79056,"; 2502#if defined(USE_WEBSOCKET); 2503 int in_websocket_handling; /* 1 if in read_websocket */; 2504#endif; 2505#if defined(USE_ZLIB) && defined(USE_WEBSOCKET) \; 2506 && defined(MG_EXPERIMENTAL_INTERFACES); 2507 /* Parameters for websocket data compression according to rfc7692 */; 2508 int websocket_deflate_server_max_windows_bits;; 2509 int websocket_deflate_client_max_windows_bits;; 2510 int websocket_deflate_server_no_context_takeover;; 2511 int websocket_deflate_client_no_context_takeover;; 2512 int websocket_deflate_initialized;; 2513 int websocket_deflate_flush;; 2514 z_stream websocket_deflate_state;; 2515 z_stream websocket_inflate_state;; 2516#endif; 2517 int handled_requests; /* Number of requests handled by this connection; 2518 */; 2519 int buf_size; /* Buffer size */; 2520 int request_len; /* Size of the request + headers in a buffer */; 2521 int data_len; /* Total size of data in a buffer */; 2522 int status_code; /* HTTP reply status code, e.g. 200 */; 2523 int throttle; /* Throttling, bytes/sec. <= 0 means no; 2524 * throttle */; 2525 ; 2526 time_t last_throttle_time; /* Last time throttled data was sent */; 2527 int last_throttle_bytes; /* Bytes sent this second */; 2528 pthread_mutex_t mutex; /* Used by mg_(un)lock_connection to ensure; 2529 * atomic transmissions for websockets */; 2530#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2531 void *lua_websocket_state; /* Lua_State for a websocket connection */; 2532#endif; 2533 ; 2534 void *tls_user_ptr; /* User defined pointer in thread local storage,; 2535 * for quick access */; 2536};; 2537 ; 2538 ; 2539/* Directory entry */; 2540struct de {; 2541 struct mg_connection *conn;; 2542 char *file_name;; 2543 struct mg_file_stat file;; 2544};; 2545 ; 2546 ; 2547#define mg_cry_internal(conn, fmt, ...) \; 2548 mg_cry_internal_wrap(conn, NULL, __func__, __LINE__, fmt, __VA_ARGS__); 2549 ; 2550#define mg_cry_ctx_internal(ctx, fmt, ...) \; 2551 mg_cry_internal_wrap(NULL, ctx, __func__, __LINE__, fmt, __VA_ARG",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:79114,Performance,throttle,throttle,79114,"deflate_server_no_context_takeover;; 2511 int websocket_deflate_client_no_context_takeover;; 2512 int websocket_deflate_initialized;; 2513 int websocket_deflate_flush;; 2514 z_stream websocket_deflate_state;; 2515 z_stream websocket_inflate_state;; 2516#endif; 2517 int handled_requests; /* Number of requests handled by this connection; 2518 */; 2519 int buf_size; /* Buffer size */; 2520 int request_len; /* Size of the request + headers in a buffer */; 2521 int data_len; /* Total size of data in a buffer */; 2522 int status_code; /* HTTP reply status code, e.g. 200 */; 2523 int throttle; /* Throttling, bytes/sec. <= 0 means no; 2524 * throttle */; 2525 ; 2526 time_t last_throttle_time; /* Last time throttled data was sent */; 2527 int last_throttle_bytes; /* Bytes sent this second */; 2528 pthread_mutex_t mutex; /* Used by mg_(un)lock_connection to ensure; 2529 * atomic transmissions for websockets */; 2530#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2531 void *lua_websocket_state; /* Lua_State for a websocket connection */; 2532#endif; 2533 ; 2534 void *tls_user_ptr; /* User defined pointer in thread local storage,; 2535 * for quick access */; 2536};; 2537 ; 2538 ; 2539/* Directory entry */; 2540struct de {; 2541 struct mg_connection *conn;; 2542 char *file_name;; 2543 struct mg_file_stat file;; 2544};; 2545 ; 2546 ; 2547#define mg_cry_internal(conn, fmt, ...) \; 2548 mg_cry_internal_wrap(conn, NULL, __func__, __LINE__, fmt, __VA_ARGS__); 2549 ; 2550#define mg_cry_ctx_internal(ctx, fmt, ...) \; 2551 mg_cry_internal_wrap(NULL, ctx, __func__, __LINE__, fmt, __VA_ARGS__); 2552 ; 2553static void mg_cry_internal_wrap(const struct mg_connection *conn,; 2554 struct mg_context *ctx,; 2555 const char *func,; 2556 unsigned line,; 2557 const char *fmt,; 2558 ...) PRINTF_ARGS(5, 6);; 2559 ; 2560 ; 2561#if !defined(NO_THREAD_NAME); 2562#if defined(_WIN32) && defined(_MSC_VER); 2563/* Set the thread name for debugging purposes in Visual Studio; 2564 * http://msdn.microsoft.com/",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:79179,Performance,throttle,throttled,79179,"deflate_server_no_context_takeover;; 2511 int websocket_deflate_client_no_context_takeover;; 2512 int websocket_deflate_initialized;; 2513 int websocket_deflate_flush;; 2514 z_stream websocket_deflate_state;; 2515 z_stream websocket_inflate_state;; 2516#endif; 2517 int handled_requests; /* Number of requests handled by this connection; 2518 */; 2519 int buf_size; /* Buffer size */; 2520 int request_len; /* Size of the request + headers in a buffer */; 2521 int data_len; /* Total size of data in a buffer */; 2522 int status_code; /* HTTP reply status code, e.g. 200 */; 2523 int throttle; /* Throttling, bytes/sec. <= 0 means no; 2524 * throttle */; 2525 ; 2526 time_t last_throttle_time; /* Last time throttled data was sent */; 2527 int last_throttle_bytes; /* Bytes sent this second */; 2528 pthread_mutex_t mutex; /* Used by mg_(un)lock_connection to ensure; 2529 * atomic transmissions for websockets */; 2530#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2531 void *lua_websocket_state; /* Lua_State for a websocket connection */; 2532#endif; 2533 ; 2534 void *tls_user_ptr; /* User defined pointer in thread local storage,; 2535 * for quick access */; 2536};; 2537 ; 2538 ; 2539/* Directory entry */; 2540struct de {; 2541 struct mg_connection *conn;; 2542 char *file_name;; 2543 struct mg_file_stat file;; 2544};; 2545 ; 2546 ; 2547#define mg_cry_internal(conn, fmt, ...) \; 2548 mg_cry_internal_wrap(conn, NULL, __func__, __LINE__, fmt, __VA_ARGS__); 2549 ; 2550#define mg_cry_ctx_internal(ctx, fmt, ...) \; 2551 mg_cry_internal_wrap(NULL, ctx, __func__, __LINE__, fmt, __VA_ARGS__); 2552 ; 2553static void mg_cry_internal_wrap(const struct mg_connection *conn,; 2554 struct mg_context *ctx,; 2555 const char *func,; 2556 unsigned line,; 2557 const char *fmt,; 2558 ...) PRINTF_ARGS(5, 6);; 2559 ; 2560 ; 2561#if !defined(NO_THREAD_NAME); 2562#if defined(_WIN32) && defined(_MSC_VER); 2563/* Set the thread name for debugging purposes in Visual Studio; 2564 * http://msdn.microsoft.com/",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:119776,Performance,cache,cache,119776,"rsion, ""1.1""))) {; 4008 /* HTTP 1.1 default is keep alive */; 4009 return 1;; 4010 }; 4011 ; 4012 /* HTTP 1.0 (and earlier) default is to close the connection */; 4013 return 0;; 4014}; 4015 ; 4016 ; 4017static int; 4018should_decode_url(const struct mg_connection *conn); 4019{; 4020 if (!conn || !conn->dom_ctx) {; 4021 return 0;; 4022 }; 4023 ; 4024 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_URL], ""yes"") == 0);; 4025}; 4026 ; 4027 ; 4028static int; 4029should_decode_query_string(const struct mg_connection *conn); 4030{; 4031 if (!conn || !conn->dom_ctx) {; 4032 return 0;; 4033 }; 4034 ; 4035 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_QUERY_STRING], ""yes""); 4036 == 0);; 4037}; 4038 ; 4039 ; 4040static const char *; 4041suggest_connection_header(const struct mg_connection *conn); 4042{; 4043 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4044}; 4045 ; 4046 ; 4047#include ""response.inl""; 4048 ; 4049 ; 4050static void; 4051send_no_cache_header(struct mg_connection *conn); 4052{; 4053 /* Send all current and obsolete cache opt-out directives. */; 4054 mg_response_header_add(conn,; 4055 ""Cache-Control"",; 4056 ""no-cache, no-store, ""; 4057 ""must-revalidate, private, max-age=0"",; 4058 -1);; 4059 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4060 ; 4061 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4062 /* Obsolete, but still send it for HTTP/1.0 */; 4063 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4064 }; 4065}; 4066 ; 4067 ; 4068static void; 4069send_static_cache_header(struct mg_connection *conn); 4070{; 4071#if !defined(NO_CACHING); 4072 int max_age;; 4073 char val[64];; 4074 ; 4075 const char *cache_control =; 4076 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4077 ; 4078 /* If there is a full cache-control option configured,0 use it */; 4079 if (cache_control != NULL) {; 4080 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4081 return;; 4082 }; 4083 ; 4084 /* Read the server config to check how lo",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:119873,Performance,cache,cache,119873,"const struct mg_connection *conn); 4019{; 4020 if (!conn || !conn->dom_ctx) {; 4021 return 0;; 4022 }; 4023 ; 4024 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_URL], ""yes"") == 0);; 4025}; 4026 ; 4027 ; 4028static int; 4029should_decode_query_string(const struct mg_connection *conn); 4030{; 4031 if (!conn || !conn->dom_ctx) {; 4032 return 0;; 4033 }; 4034 ; 4035 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_QUERY_STRING], ""yes""); 4036 == 0);; 4037}; 4038 ; 4039 ; 4040static const char *; 4041suggest_connection_header(const struct mg_connection *conn); 4042{; 4043 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4044}; 4045 ; 4046 ; 4047#include ""response.inl""; 4048 ; 4049 ; 4050static void; 4051send_no_cache_header(struct mg_connection *conn); 4052{; 4053 /* Send all current and obsolete cache opt-out directives. */; 4054 mg_response_header_add(conn,; 4055 ""Cache-Control"",; 4056 ""no-cache, no-store, ""; 4057 ""must-revalidate, private, max-age=0"",; 4058 -1);; 4059 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4060 ; 4061 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4062 /* Obsolete, but still send it for HTTP/1.0 */; 4063 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4064 }; 4065}; 4066 ; 4067 ; 4068static void; 4069send_static_cache_header(struct mg_connection *conn); 4070{; 4071#if !defined(NO_CACHING); 4072 int max_age;; 4073 char val[64];; 4074 ; 4075 const char *cache_control =; 4076 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4077 ; 4078 /* If there is a full cache-control option configured,0 use it */; 4079 if (cache_control != NULL) {; 4080 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4081 return;; 4082 }; 4083 ; 4084 /* Read the server config to check how long a file may be cached.; 4085 * The configuration is in seconds. */; 4086 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4087 if (max_age <= 0) {; 4088 /* 0 means ""do not cache"". All values <0 are reserved; 4089 * and may ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:120169,Performance,cache,cache,120169,"039 ; 4040static const char *; 4041suggest_connection_header(const struct mg_connection *conn); 4042{; 4043 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4044}; 4045 ; 4046 ; 4047#include ""response.inl""; 4048 ; 4049 ; 4050static void; 4051send_no_cache_header(struct mg_connection *conn); 4052{; 4053 /* Send all current and obsolete cache opt-out directives. */; 4054 mg_response_header_add(conn,; 4055 ""Cache-Control"",; 4056 ""no-cache, no-store, ""; 4057 ""must-revalidate, private, max-age=0"",; 4058 -1);; 4059 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4060 ; 4061 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4062 /* Obsolete, but still send it for HTTP/1.0 */; 4063 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4064 }; 4065}; 4066 ; 4067 ; 4068static void; 4069send_static_cache_header(struct mg_connection *conn); 4070{; 4071#if !defined(NO_CACHING); 4072 int max_age;; 4073 char val[64];; 4074 ; 4075 const char *cache_control =; 4076 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4077 ; 4078 /* If there is a full cache-control option configured,0 use it */; 4079 if (cache_control != NULL) {; 4080 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4081 return;; 4082 }; 4083 ; 4084 /* Read the server config to check how long a file may be cached.; 4085 * The configuration is in seconds. */; 4086 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4087 if (max_age <= 0) {; 4088 /* 0 means ""do not cache"". All values <0 are reserved; 4089 * and may be used differently in the future. */; 4090 /* If a file should not be cached, do not only send; 4091 * max-age=0, but also pragmas and Expires headers. */; 4092 send_no_cache_header(conn);; 4093 return;; 4094 }; 4095 ; 4096 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4097 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4098 /* See also https://www.mnot.net/cache_docs/ */; 4099 /* According to RFC 2616, Section 14.21, caching t",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:120494,Performance,cache,cache-control,120494,"039 ; 4040static const char *; 4041suggest_connection_header(const struct mg_connection *conn); 4042{; 4043 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4044}; 4045 ; 4046 ; 4047#include ""response.inl""; 4048 ; 4049 ; 4050static void; 4051send_no_cache_header(struct mg_connection *conn); 4052{; 4053 /* Send all current and obsolete cache opt-out directives. */; 4054 mg_response_header_add(conn,; 4055 ""Cache-Control"",; 4056 ""no-cache, no-store, ""; 4057 ""must-revalidate, private, max-age=0"",; 4058 -1);; 4059 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4060 ; 4061 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4062 /* Obsolete, but still send it for HTTP/1.0 */; 4063 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4064 }; 4065}; 4066 ; 4067 ; 4068static void; 4069send_static_cache_header(struct mg_connection *conn); 4070{; 4071#if !defined(NO_CACHING); 4072 int max_age;; 4073 char val[64];; 4074 ; 4075 const char *cache_control =; 4076 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4077 ; 4078 /* If there is a full cache-control option configured,0 use it */; 4079 if (cache_control != NULL) {; 4080 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4081 return;; 4082 }; 4083 ; 4084 /* Read the server config to check how long a file may be cached.; 4085 * The configuration is in seconds. */; 4086 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4087 if (max_age <= 0) {; 4088 /* 0 means ""do not cache"". All values <0 are reserved; 4089 * and may be used differently in the future. */; 4090 /* If a file should not be cached, do not only send; 4091 * max-age=0, but also pragmas and Expires headers. */; 4092 send_no_cache_header(conn);; 4093 return;; 4094 }; 4095 ; 4096 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4097 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4098 /* See also https://www.mnot.net/cache_docs/ */; 4099 /* According to RFC 2616, Section 14.21, caching t",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:120738,Performance,cache,cached,120738,"039 ; 4040static const char *; 4041suggest_connection_header(const struct mg_connection *conn); 4042{; 4043 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4044}; 4045 ; 4046 ; 4047#include ""response.inl""; 4048 ; 4049 ; 4050static void; 4051send_no_cache_header(struct mg_connection *conn); 4052{; 4053 /* Send all current and obsolete cache opt-out directives. */; 4054 mg_response_header_add(conn,; 4055 ""Cache-Control"",; 4056 ""no-cache, no-store, ""; 4057 ""must-revalidate, private, max-age=0"",; 4058 -1);; 4059 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4060 ; 4061 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4062 /* Obsolete, but still send it for HTTP/1.0 */; 4063 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4064 }; 4065}; 4066 ; 4067 ; 4068static void; 4069send_static_cache_header(struct mg_connection *conn); 4070{; 4071#if !defined(NO_CACHING); 4072 int max_age;; 4073 char val[64];; 4074 ; 4075 const char *cache_control =; 4076 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4077 ; 4078 /* If there is a full cache-control option configured,0 use it */; 4079 if (cache_control != NULL) {; 4080 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4081 return;; 4082 }; 4083 ; 4084 /* Read the server config to check how long a file may be cached.; 4085 * The configuration is in seconds. */; 4086 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4087 if (max_age <= 0) {; 4088 /* 0 means ""do not cache"". All values <0 are reserved; 4089 * and may be used differently in the future. */; 4090 /* If a file should not be cached, do not only send; 4091 * max-age=0, but also pragmas and Expires headers. */; 4092 send_no_cache_header(conn);; 4093 return;; 4094 }; 4095 ; 4096 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4097 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4098 /* See also https://www.mnot.net/cache_docs/ */; 4099 /* According to RFC 2616, Section 14.21, caching t",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:120907,Performance,cache,cache,120907,"he-Control"",; 4056 ""no-cache, no-store, ""; 4057 ""must-revalidate, private, max-age=0"",; 4058 -1);; 4059 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4060 ; 4061 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4062 /* Obsolete, but still send it for HTTP/1.0 */; 4063 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4064 }; 4065}; 4066 ; 4067 ; 4068static void; 4069send_static_cache_header(struct mg_connection *conn); 4070{; 4071#if !defined(NO_CACHING); 4072 int max_age;; 4073 char val[64];; 4074 ; 4075 const char *cache_control =; 4076 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4077 ; 4078 /* If there is a full cache-control option configured,0 use it */; 4079 if (cache_control != NULL) {; 4080 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4081 return;; 4082 }; 4083 ; 4084 /* Read the server config to check how long a file may be cached.; 4085 * The configuration is in seconds. */; 4086 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4087 if (max_age <= 0) {; 4088 /* 0 means ""do not cache"". All values <0 are reserved; 4089 * and may be used differently in the future. */; 4090 /* If a file should not be cached, do not only send; 4091 * max-age=0, but also pragmas and Expires headers. */; 4092 send_no_cache_header(conn);; 4093 return;; 4094 }; 4095 ; 4096 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4097 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4098 /* See also https://www.mnot.net/cache_docs/ */; 4099 /* According to RFC 2616, Section 14.21, caching times should not exceed; 4100 * one year. A year with 365 days corresponds to 31536000 seconds, a; 4101 * leap; 4102 * year to 31622400 seconds. For the moment, we just send whatever has; 4103 * been configured, still the behavior for >1 year should be considered; 4104 * as undefined. */; 4105 mg_snprintf(; 4106 conn, NULL, val, sizeof(val), ""max-age=%lu"", (unsigned long)max_age);; 4107 mg_response_header_add(conn, ""C",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:121029,Performance,cache,cached,121029,"L_TYPE_HTTP1) {; 4062 /* Obsolete, but still send it for HTTP/1.0 */; 4063 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4064 }; 4065}; 4066 ; 4067 ; 4068static void; 4069send_static_cache_header(struct mg_connection *conn); 4070{; 4071#if !defined(NO_CACHING); 4072 int max_age;; 4073 char val[64];; 4074 ; 4075 const char *cache_control =; 4076 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4077 ; 4078 /* If there is a full cache-control option configured,0 use it */; 4079 if (cache_control != NULL) {; 4080 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4081 return;; 4082 }; 4083 ; 4084 /* Read the server config to check how long a file may be cached.; 4085 * The configuration is in seconds. */; 4086 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4087 if (max_age <= 0) {; 4088 /* 0 means ""do not cache"". All values <0 are reserved; 4089 * and may be used differently in the future. */; 4090 /* If a file should not be cached, do not only send; 4091 * max-age=0, but also pragmas and Expires headers. */; 4092 send_no_cache_header(conn);; 4093 return;; 4094 }; 4095 ; 4096 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4097 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4098 /* See also https://www.mnot.net/cache_docs/ */; 4099 /* According to RFC 2616, Section 14.21, caching times should not exceed; 4100 * one year. A year with 365 days corresponds to 31536000 seconds, a; 4101 * leap; 4102 * year to 31622400 seconds. For the moment, we just send whatever has; 4103 * been configured, still the behavior for >1 year should be considered; 4104 * as undefined. */; 4105 mg_snprintf(; 4106 conn, NULL, val, sizeof(val), ""max-age=%lu"", (unsigned long)max_age);; 4107 mg_response_header_add(conn, ""Cache-Control"", val, -1);; 4108 ; 4109#else /* NO_CACHING */; 4110 ; 4111 send_no_cache_header(conn);; 4112#endif /* !NO_CACHING */; 4113}; 4114 ; 4115 ; 4116static void; 4117send_additional_header(stru",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:154289,Performance,queue,queue,154289,"t;; 5138}; 5139 ; 5140 ; 5141FUNCTION_MAY_BE_UNUSED; 5142static struct dirent *; 5143mg_readdir(DIR *dir); 5144{; 5145 struct dirent *result = 0;; 5146 ; 5147 if (dir) {; 5148 if (dir->handle != INVALID_HANDLE_VALUE) {; 5149 result = &dir->result;; 5150 (void)WideCharToMultiByte(CP_UTF8,; 5151 0,; 5152 dir->info.cFileName,; 5153 -1,; 5154 result->d_name,; 5155 sizeof(result->d_name),; 5156 NULL,; 5157 NULL);; 5158 ; 5159 if (!FindNextFileW(dir->handle, &dir->info)) {; 5160 (void)FindClose(dir->handle);; 5161 dir->handle = INVALID_HANDLE_VALUE;; 5162 }; 5163 ; 5164 } else {; 5165 SetLastError(ERROR_FILE_NOT_FOUND);; 5166 }; 5167 } else {; 5168 SetLastError(ERROR_BAD_ARGUMENTS);; 5169 }; 5170 ; 5171 return result;; 5172}; 5173 ; 5174 ; 5175#if !defined(HAVE_POLL); 5176#undef POLLIN; 5177#undef POLLPRI; 5178#undef POLLOUT; 5179#undef POLLERR; 5180#define POLLIN (1) /* Data ready - read will not block. */; 5181#define POLLPRI (2) /* Priority data ready. */; 5182#define POLLOUT (4) /* Send queue not full - write will not block. */; 5183#define POLLERR (8) /* Error event */; 5184 ; 5185FUNCTION_MAY_BE_UNUSED; 5186static int; 5187poll(struct mg_pollfd *pfd, unsigned int n, int milliseconds); 5188{; 5189 struct timeval tv;; 5190 fd_set rset;; 5191 fd_set wset;; 5192 fd_set eset;; 5193 unsigned int i;; 5194 int result;; 5195 SOCKET maxfd = 0;; 5196 ; 5197 memset(&tv, 0, sizeof(tv));; 5198 tv.tv_sec = milliseconds / 1000;; 5199 tv.tv_usec = (milliseconds % 1000) * 1000;; 5200 FD_ZERO(&rset);; 5201 FD_ZERO(&wset);; 5202 FD_ZERO(&eset);; 5203 ; 5204 for (i = 0; i < n; i++) {; 5205 if (pfd[i].events & (POLLIN | POLLOUT | POLLERR)) {; 5206 if (pfd[i].events & POLLIN) {; 5207 FD_SET(pfd[i].fd, &rset);; 5208 }; 5209 if (pfd[i].events & POLLOUT) {; 5210 FD_SET(pfd[i].fd, &wset);; 5211 }; 5212 /* Check for errors for any FD in the set */; 5213 FD_SET(pfd[i].fd, &eset);; 5214 }; 5215 pfd[i].revents = 0;; 5216 ; 5217 if (pfd[i].fd > maxfd) {; 5218 maxfd = pfd[i].fd;; 5219 }; 5220 }; 522",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:158209,Performance,load,loaded,158209,"read((void(__cdecl *)(void *))f, 0, p) == ((uintptr_t)(-1L))); 5280 ? -1; 5281 : 0);; 5282#endif /* defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1) */; 5283}; 5284 ; 5285 ; 5286/* Start a thread storing the thread context. */; 5287static int; 5288mg_start_thread_with_id(unsigned(__stdcall *f)(void *),; 5289 void *p,; 5290 pthread_t *threadidptr); 5291{; 5292 uintptr_t uip;; 5293 HANDLE threadhandle;; 5294 int result = -1;; 5295 ; 5296 uip = _beginthreadex(NULL, 0, f, p, 0, NULL);; 5297 threadhandle = (HANDLE)uip;; 5298 if ((uip != 0) && (threadidptr != NULL)) {; 5299 *threadidptr = threadhandle;; 5300 result = 0;; 5301 }; 5302 ; 5303 return result;; 5304}; 5305 ; 5306 ; 5307/* Wait for a thread to finish. */; 5308static int; 5309mg_join_thread(pthread_t threadid); 5310{; 5311 int result;; 5312 DWORD dwevent;; 5313 ; 5314 result = -1;; 5315 dwevent = WaitForSingleObject(threadid, (DWORD)INFINITE);; 5316 if (dwevent == WAIT_FAILED) {; 5317 DEBUG_TRACE(""WaitForSingleObject() failed, error %d"", ERRNO);; 5318 } else {; 5319 if (dwevent == WAIT_OBJECT_0) {; 5320 CloseHandle(threadid);; 5321 result = 0;; 5322 }; 5323 }; 5324 ; 5325 return result;; 5326}; 5327 ; 5328#if !defined(NO_SSL_DL) && !defined(NO_SSL); 5329/* If SSL is loaded dynamically, dlopen/dlclose is required. */; 5330/* Create substitutes for POSIX functions in Win32. */; 5331 ; 5332#if defined(GCC_DIAGNOSTIC); 5333/* Show no warning in case system functions are not used. */; 5334#pragma GCC diagnostic push; 5335#pragma GCC diagnostic ignored ""-Wunused-function""; 5336#endif; 5337 ; 5338 ; 5339FUNCTION_MAY_BE_UNUSED; 5340static HANDLE; 5341dlopen(const char *dll_name, int flags); 5342{; 5343 wchar_t wbuf[UTF16_PATH_MAX];; 5344 (void)flags;; 5345 path_to_unicode(NULL, dll_name, wbuf, ARRAY_SIZE(wbuf));; 5346 return LoadLibraryW(wbuf);; 5347}; 5348 ; 5349 ; 5350FUNCTION_MAY_BE_UNUSED; 5351static int; 5352dlclose(void *handle); 5353{; 5354 int result;; 5355 ; 5356 if (FreeLibrary((HMODULE)handle) != 0) {; 5357 re",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:194839,Performance,throttle,throttle,194839,"7 }; 6648 if ((i > 0) && (lenbuf[i] == '\r'); 6649 && (lenbuf[i - 1] != '\r')) {; 6650 continue;; 6651 }; 6652 if ((i > 1) && (lenbuf[i] == '\n'); 6653 && (lenbuf[i - 1] == '\r')) {; 6654 lenbuf[i + 1] = 0;; 6655 chunkSize = strtoul(lenbuf, &end, 16);; 6656 if (chunkSize == 0) {; 6657 /* regular end of content */; 6658 conn->is_chunked = 3;; 6659 }; 6660 break;; 6661 }; 6662 if (!isxdigit((unsigned char)lenbuf[i])) {; 6663 /* illegal character for chunk length */; 6664 conn->is_chunked = 2;; 6665 return -1;; 6666 }; 6667 }; 6668 if ((end == NULL) || (*end != '\r')) {; 6669 /* chunksize not set correctly */; 6670 conn->is_chunked = 2;; 6671 return -1;; 6672 }; 6673 if (chunkSize == 0) {; 6674 /* try discarding trailer for keep-alive */; 6675 conn->content_len += 2;; 6676 if ((mg_read_inner(conn, lenbuf, 2) == 2); 6677 && (lenbuf[0] == '\r') && (lenbuf[1] == '\n')) {; 6678 conn->is_chunked = 4;; 6679 }; 6680 break;; 6681 }; 6682 ; 6683 /* append a new chunk */; 6684 conn->content_len += (int64_t)chunkSize;; 6685 }; 6686 }; 6687 ; 6688 return (int)all_read;; 6689 }; 6690 return mg_read_inner(conn, buf, len);; 6691}; 6692 ; 6693 ; 6694int; 6695mg_write(struct mg_connection *conn, const void *buf, size_t len); 6696{; 6697 time_t now;; 6698 int n, total, allowed;; 6699 ; 6700 if (conn == NULL) {; 6701 return 0;; 6702 }; 6703 if (len > INT_MAX) {; 6704 return -1;; 6705 }; 6706 ; 6707 /* Mark connection as ""data sent"" */; 6708 conn->request_state = 10;; 6709#if defined(USE_HTTP2); 6710 if (conn->protocol_type == PROTOCOL_TYPE_HTTP2) {; 6711 http2_data_frame_head(conn, len, 0);; 6712 }; 6713#endif; 6714 ; 6715 if (conn->throttle > 0) {; 6716 if ((now = time(NULL)) != conn->last_throttle_time) {; 6717 conn->last_throttle_time = now;; 6718 conn->last_throttle_bytes = 0;; 6719 }; 6720 allowed = conn->throttle - conn->last_throttle_bytes;; 6721 if (allowed > (int)len) {; 6722 allowed = (int)len;; 6723 }; 6724 ; 6725 total = push_all(conn->phys_ctx,; 6726 NULL,; 6727 conn->client.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:195020,Performance,throttle,throttle,195020,"7 }; 6648 if ((i > 0) && (lenbuf[i] == '\r'); 6649 && (lenbuf[i - 1] != '\r')) {; 6650 continue;; 6651 }; 6652 if ((i > 1) && (lenbuf[i] == '\n'); 6653 && (lenbuf[i - 1] == '\r')) {; 6654 lenbuf[i + 1] = 0;; 6655 chunkSize = strtoul(lenbuf, &end, 16);; 6656 if (chunkSize == 0) {; 6657 /* regular end of content */; 6658 conn->is_chunked = 3;; 6659 }; 6660 break;; 6661 }; 6662 if (!isxdigit((unsigned char)lenbuf[i])) {; 6663 /* illegal character for chunk length */; 6664 conn->is_chunked = 2;; 6665 return -1;; 6666 }; 6667 }; 6668 if ((end == NULL) || (*end != '\r')) {; 6669 /* chunksize not set correctly */; 6670 conn->is_chunked = 2;; 6671 return -1;; 6672 }; 6673 if (chunkSize == 0) {; 6674 /* try discarding trailer for keep-alive */; 6675 conn->content_len += 2;; 6676 if ((mg_read_inner(conn, lenbuf, 2) == 2); 6677 && (lenbuf[0] == '\r') && (lenbuf[1] == '\n')) {; 6678 conn->is_chunked = 4;; 6679 }; 6680 break;; 6681 }; 6682 ; 6683 /* append a new chunk */; 6684 conn->content_len += (int64_t)chunkSize;; 6685 }; 6686 }; 6687 ; 6688 return (int)all_read;; 6689 }; 6690 return mg_read_inner(conn, buf, len);; 6691}; 6692 ; 6693 ; 6694int; 6695mg_write(struct mg_connection *conn, const void *buf, size_t len); 6696{; 6697 time_t now;; 6698 int n, total, allowed;; 6699 ; 6700 if (conn == NULL) {; 6701 return 0;; 6702 }; 6703 if (len > INT_MAX) {; 6704 return -1;; 6705 }; 6706 ; 6707 /* Mark connection as ""data sent"" */; 6708 conn->request_state = 10;; 6709#if defined(USE_HTTP2); 6710 if (conn->protocol_type == PROTOCOL_TYPE_HTTP2) {; 6711 http2_data_frame_head(conn, len, 0);; 6712 }; 6713#endif; 6714 ; 6715 if (conn->throttle > 0) {; 6716 if ((now = time(NULL)) != conn->last_throttle_time) {; 6717 conn->last_throttle_time = now;; 6718 conn->last_throttle_bytes = 0;; 6719 }; 6720 allowed = conn->throttle - conn->last_throttle_bytes;; 6721 if (allowed > (int)len) {; 6722 allowed = (int)len;; 6723 }; 6724 ; 6725 total = push_all(conn->phys_ctx,; 6726 NULL,; 6727 conn->client.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:195503,Performance,throttle,throttle,195503,"6{; 6697 time_t now;; 6698 int n, total, allowed;; 6699 ; 6700 if (conn == NULL) {; 6701 return 0;; 6702 }; 6703 if (len > INT_MAX) {; 6704 return -1;; 6705 }; 6706 ; 6707 /* Mark connection as ""data sent"" */; 6708 conn->request_state = 10;; 6709#if defined(USE_HTTP2); 6710 if (conn->protocol_type == PROTOCOL_TYPE_HTTP2) {; 6711 http2_data_frame_head(conn, len, 0);; 6712 }; 6713#endif; 6714 ; 6715 if (conn->throttle > 0) {; 6716 if ((now = time(NULL)) != conn->last_throttle_time) {; 6717 conn->last_throttle_time = now;; 6718 conn->last_throttle_bytes = 0;; 6719 }; 6720 allowed = conn->throttle - conn->last_throttle_bytes;; 6721 if (allowed > (int)len) {; 6722 allowed = (int)len;; 6723 }; 6724 ; 6725 total = push_all(conn->phys_ctx,; 6726 NULL,; 6727 conn->client.sock,; 6728 conn->ssl,; 6729 (const char *)buf,; 6730 allowed);; 6731 ; 6732 if (total == allowed) {; 6733 ; 6734 buf = (const char *)buf + total;; 6735 conn->last_throttle_bytes += total;; 6736 while ((total < (int)len); 6737 && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6738 allowed = (conn->throttle > ((int)len - total)); 6739 ? (int)len - total; 6740 : conn->throttle;; 6741 ; 6742 n = push_all(conn->phys_ctx,; 6743 NULL,; 6744 conn->client.sock,; 6745 conn->ssl,; 6746 (const char *)buf,; 6747 allowed);; 6748 ; 6749 if (n != allowed) {; 6750 break;; 6751 }; 6752 sleep(1);; 6753 conn->last_throttle_bytes = allowed;; 6754 conn->last_throttle_time = time(NULL);; 6755 buf = (const char *)buf + n;; 6756 total += n;; 6757 }; 6758 }; 6759 } else {; 6760 total = push_all(conn->phys_ctx,; 6761 NULL,; 6762 conn->client.sock,; 6763 conn->ssl,; 6764 (const char *)buf,; 6765 (int)len);; 6766 }; 6767 if (total > 0) {; 6768 conn->num_bytes_sent += total;; 6769 }; 6770 return total;; 6771}; 6772 ; 6773 ; 6774/* Send a chunk, if ""Transfer-Encoding: chunked"" is used */; 6775int; 6776mg_send_chunk(struct mg_connection *conn,; 6777 const char *chunk,; 6778 unsigned int chunk_len); 6779{; 6780 char lenbuf[16];; 6781 siz",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:195573,Performance,throttle,throttle,195573,"6{; 6697 time_t now;; 6698 int n, total, allowed;; 6699 ; 6700 if (conn == NULL) {; 6701 return 0;; 6702 }; 6703 if (len > INT_MAX) {; 6704 return -1;; 6705 }; 6706 ; 6707 /* Mark connection as ""data sent"" */; 6708 conn->request_state = 10;; 6709#if defined(USE_HTTP2); 6710 if (conn->protocol_type == PROTOCOL_TYPE_HTTP2) {; 6711 http2_data_frame_head(conn, len, 0);; 6712 }; 6713#endif; 6714 ; 6715 if (conn->throttle > 0) {; 6716 if ((now = time(NULL)) != conn->last_throttle_time) {; 6717 conn->last_throttle_time = now;; 6718 conn->last_throttle_bytes = 0;; 6719 }; 6720 allowed = conn->throttle - conn->last_throttle_bytes;; 6721 if (allowed > (int)len) {; 6722 allowed = (int)len;; 6723 }; 6724 ; 6725 total = push_all(conn->phys_ctx,; 6726 NULL,; 6727 conn->client.sock,; 6728 conn->ssl,; 6729 (const char *)buf,; 6730 allowed);; 6731 ; 6732 if (total == allowed) {; 6733 ; 6734 buf = (const char *)buf + total;; 6735 conn->last_throttle_bytes += total;; 6736 while ((total < (int)len); 6737 && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6738 allowed = (conn->throttle > ((int)len - total)); 6739 ? (int)len - total; 6740 : conn->throttle;; 6741 ; 6742 n = push_all(conn->phys_ctx,; 6743 NULL,; 6744 conn->client.sock,; 6745 conn->ssl,; 6746 (const char *)buf,; 6747 allowed);; 6748 ; 6749 if (n != allowed) {; 6750 break;; 6751 }; 6752 sleep(1);; 6753 conn->last_throttle_bytes = allowed;; 6754 conn->last_throttle_time = time(NULL);; 6755 buf = (const char *)buf + n;; 6756 total += n;; 6757 }; 6758 }; 6759 } else {; 6760 total = push_all(conn->phys_ctx,; 6761 NULL,; 6762 conn->client.sock,; 6763 conn->ssl,; 6764 (const char *)buf,; 6765 (int)len);; 6766 }; 6767 if (total > 0) {; 6768 conn->num_bytes_sent += total;; 6769 }; 6770 return total;; 6771}; 6772 ; 6773 ; 6774/* Send a chunk, if ""Transfer-Encoding: chunked"" is used */; 6775int; 6776mg_send_chunk(struct mg_connection *conn,; 6777 const char *chunk,; 6778 unsigned int chunk_len); 6779{; 6780 char lenbuf[16];; 6781 siz",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:279213,Performance,throttle,throttle,279213,"ntries[i].file_name);; 9716 }; 9717 mg_free(data.entries);; 9718 }; 9719 ; 9720 mg_printf(conn, ""%s"", ""</table></pre></body></html>"");; 9721 conn->status_code = 200;; 9722}; 9723#endif /* NO_FILESYSTEMS */; 9724 ; 9725 ; 9726/* Send len bytes from the opened file to the client. */; 9727static void; 9728send_file_data(struct mg_connection *conn,; 9729 struct mg_file *filep,; 9730 int64_t offset,; 9731 int64_t len); 9732{; 9733 char buf[MG_BUF_LEN];; 9734 int to_read, num_read, num_written;; 9735 int64_t size;; 9736 ; 9737 if (!filep || !conn) {; 9738 return;; 9739 }; 9740 ; 9741 /* Sanity check the offset */; 9742 size = (filep->stat.size > INT64_MAX) ? INT64_MAX; 9743 : (int64_t)(filep->stat.size);; 9744 offset = (offset < 0) ? 0 : ((offset > size) ? size : offset);; 9745 ; 9746 if (len > 0 && filep->access.fp != NULL) {; 9747 /* file stored on disk */; 9748#if defined(__linux__); 9749 /* sendfile is only available for Linux */; 9750 if ((conn->ssl == 0) && (conn->throttle == 0); 9751 && (!mg_strcasecmp(conn->dom_ctx->config[ALLOW_SENDFILE_CALL],; 9752 ""yes""))) {; 9753 off_t sf_offs = (off_t)offset;; 9754 ssize_t sf_sent;; 9755 int sf_file = fileno(filep->access.fp);; 9756 int loop_cnt = 0;; 9757 ; 9758 do {; 9759 /* 2147479552 (0x7FFFF000) is a limit found by experiment on; 9760 * 64 bit Linux (2^31 minus one memory page of 4k?). */; 9761 size_t sf_tosend =; 9762 (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);; 9763 sf_sent =; 9764 sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);; 9765 if (sf_sent > 0) {; 9766 len -= sf_sent;; 9767 offset += sf_sent;; 9768 } else if (loop_cnt == 0) {; 9769 /* This file can not be sent using sendfile.; 9770 * This might be the case for pseudo-files in the; 9771 * /sys/ and /proc/ file system.; 9772 * Use the regular user mode copy code instead. */; 9773 break;; 9774 } else if (sf_sent == 0) {; 9775 /* No error, but 0 bytes sent. May be EOF? */; 9776 return;; 9777 }; 9778 loop_cnt++;; 9779 ; 9780 } while ((len > 0) && (sf_",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:302238,Performance,cache,cached,302238,"o {; 10498 const char *name;; 10499 int request_has_body;; 10500 int response_has_body;; 10501 int is_safe;; 10502 int is_idempotent;; 10503 int is_cacheable;; 10504};; 10505 ; 10506 ; 10507/* https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods */; 10508static const struct mg_http_method_info http_methods[] = {; 10509 /* HTTP (RFC 2616) */; 10510 {""GET"", 0, 1, 1, 1, 1},; 10511 {""POST"", 1, 1, 0, 0, 0},; 10512 {""PUT"", 1, 0, 0, 1, 0},; 10513 {""DELETE"", 0, 0, 0, 1, 0},; 10514 {""HEAD"", 0, 0, 1, 1, 1},; 10515 {""OPTIONS"", 0, 0, 1, 1, 0},; 10516 {""CONNECT"", 1, 1, 0, 0, 0},; 10517 /* TRACE method (RFC 2616) is not supported for security reasons */; 10518 ; 10519 /* PATCH method (RFC 5789) */; 10520 {""PATCH"", 1, 0, 0, 0, 0},; 10521 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10522 ; 10523 /* WEBDAV (RFC 2518) */; 10524 {""PROPFIND"", 0, 1, 1, 1, 0},; 10525 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10526 * Some PROPFIND results MAY be cached, with care,; 10527 * as there is no cache validation mechanism for; 10528 * most properties. This method is both safe and; 10529 * idempotent (see Section 9.1 of [RFC2616]). */; 10530 {""MKCOL"", 0, 0, 0, 1, 0},; 10531 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10532 * When MKCOL is invoked without a request body,; 10533 * the newly created collection SHOULD have no; 10534 * members. A MKCOL request message may contain; 10535 * a message body. The precise behavior of a MKCOL; 10536 * request when the body is present is undefined,; 10537 * ... ==> We do not support MKCOL with body data.; 10538 * This method is idempotent, but not safe (see; 10539 * Section 9.1 of [RFC2616]). Responses to this; 10540 * method MUST NOT be cached. */; 10541 ; 10542 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10543 {""LOCK"", 1, 1, 0, 0, 0},; 10544 {""UNLOCK"", 1, 0, 0, 0, 0},; 10545 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10546 ; 10547 /* Unsupported WEBDAV Methods: */; 10548 /* COPY, MOVE (RFC 2518) */; 10549 /* + 1",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:302281,Performance,cache,cache,302281,"o {; 10498 const char *name;; 10499 int request_has_body;; 10500 int response_has_body;; 10501 int is_safe;; 10502 int is_idempotent;; 10503 int is_cacheable;; 10504};; 10505 ; 10506 ; 10507/* https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods */; 10508static const struct mg_http_method_info http_methods[] = {; 10509 /* HTTP (RFC 2616) */; 10510 {""GET"", 0, 1, 1, 1, 1},; 10511 {""POST"", 1, 1, 0, 0, 0},; 10512 {""PUT"", 1, 0, 0, 1, 0},; 10513 {""DELETE"", 0, 0, 0, 1, 0},; 10514 {""HEAD"", 0, 0, 1, 1, 1},; 10515 {""OPTIONS"", 0, 0, 1, 1, 0},; 10516 {""CONNECT"", 1, 1, 0, 0, 0},; 10517 /* TRACE method (RFC 2616) is not supported for security reasons */; 10518 ; 10519 /* PATCH method (RFC 5789) */; 10520 {""PATCH"", 1, 0, 0, 0, 0},; 10521 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10522 ; 10523 /* WEBDAV (RFC 2518) */; 10524 {""PROPFIND"", 0, 1, 1, 1, 0},; 10525 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10526 * Some PROPFIND results MAY be cached, with care,; 10527 * as there is no cache validation mechanism for; 10528 * most properties. This method is both safe and; 10529 * idempotent (see Section 9.1 of [RFC2616]). */; 10530 {""MKCOL"", 0, 0, 0, 1, 0},; 10531 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10532 * When MKCOL is invoked without a request body,; 10533 * the newly created collection SHOULD have no; 10534 * members. A MKCOL request message may contain; 10535 * a message body. The precise behavior of a MKCOL; 10536 * request when the body is present is undefined,; 10537 * ... ==> We do not support MKCOL with body data.; 10538 * This method is idempotent, but not safe (see; 10539 * Section 9.1 of [RFC2616]). Responses to this; 10540 * method MUST NOT be cached. */; 10541 ; 10542 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10543 {""LOCK"", 1, 1, 0, 0, 0},; 10544 {""UNLOCK"", 1, 0, 0, 0, 0},; 10545 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10546 ; 10547 /* Unsupported WEBDAV Methods: */; 10548 /* COPY, MOVE (RFC 2518) */; 10549 /* + 1",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:302980,Performance,cache,cached,302980,") */; 10520 {""PATCH"", 1, 0, 0, 0, 0},; 10521 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10522 ; 10523 /* WEBDAV (RFC 2518) */; 10524 {""PROPFIND"", 0, 1, 1, 1, 0},; 10525 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10526 * Some PROPFIND results MAY be cached, with care,; 10527 * as there is no cache validation mechanism for; 10528 * most properties. This method is both safe and; 10529 * idempotent (see Section 9.1 of [RFC2616]). */; 10530 {""MKCOL"", 0, 0, 0, 1, 0},; 10531 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10532 * When MKCOL is invoked without a request body,; 10533 * the newly created collection SHOULD have no; 10534 * members. A MKCOL request message may contain; 10535 * a message body. The precise behavior of a MKCOL; 10536 * request when the body is present is undefined,; 10537 * ... ==> We do not support MKCOL with body data.; 10538 * This method is idempotent, but not safe (see; 10539 * Section 9.1 of [RFC2616]). Responses to this; 10540 * method MUST NOT be cached. */; 10541 ; 10542 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10543 {""LOCK"", 1, 1, 0, 0, 0},; 10544 {""UNLOCK"", 1, 0, 0, 0, 0},; 10545 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10546 ; 10547 /* Unsupported WEBDAV Methods: */; 10548 /* COPY, MOVE (RFC 2518) */; 10549 /* + 11 methods from RFC 3253 */; 10550 /* ORDERPATCH (RFC 3648) */; 10551 /* ACL (RFC 3744) */; 10552 /* SEARCH (RFC 5323) */; 10553 /* + MicroSoft extensions; 10554 * https://msdn.microsoft.com/en-us/library/aa142917.aspx */; 10555 ; 10556 /* REPORT method (RFC 3253) */; 10557 {""REPORT"", 1, 1, 1, 1, 1},; 10558 /* REPORT method only allowed for CGI/Lua/LSP and callbacks. */; 10559 /* It was defined for WEBDAV in RFC 3253, Sec. 3.6; 10560 * (https://tools.ietf.org/html/rfc3253#section-3.6), but seems; 10561 * to be useful for REST in case a ""GET request with body"" is; 10562 * required. */; 10563 ; 10564 {NULL, 0, 0, 0, 0, 0}; 10565 /* end of list */; 10566};; 10567 ; 10568 ; 10569static con",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:359769,Performance,queue,queue,359769,"r\n"",; 12388 b64_sha);; 12389 ; 12390#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 12391 // Send negotiated compression extension parameters; 12392 websocket_deflate_response(conn);; 12393#endif; 12394 ; 12395 if (conn->request_info.acceptedWebSocketSubprotocol) {; 12396 mg_printf(conn,; 12397 ""Sec-WebSocket-Protocol: %s\r\n\r\n"",; 12398 conn->request_info.acceptedWebSocketSubprotocol);; 12399 } else {; 12400 mg_printf(conn, ""%s"", ""\r\n"");; 12401 }; 12402 ; 12403 return 1;; 12404}; 12405 ; 12406 ; 12407#if !defined(MG_MAX_UNANSWERED_PING); 12408/* Configuration of the maximum number of websocket PINGs that might; 12409 * stay unanswered before the connection is considered broken.; 12410 * Note: The name of this define may still change (until it is; 12411 * defined as a compile parameter in a documentation).; 12412 */; 12413#define MG_MAX_UNANSWERED_PING (5); 12414#endif; 12415 ; 12416 ; 12417static void; 12418read_websocket(struct mg_connection *conn,; 12419 mg_websocket_data_handler ws_data_handler,; 12420 void *callback_data); 12421{; 12422 /* Pointer to the beginning of the portion of the incoming websocket; 12423 * message queue.; 12424 * The original websocket upgrade request is never removed, so the queue; 12425 * begins after it. */; 12426 unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;; 12427 int n, error, exit_by_callback;; 12428 int ret;; 12429 ; 12430 /* body_len is the length of the entire queue in bytes; 12431 * len is the length of the current message; 12432 * data_len is the length of the current message's data payload; 12433 * header_len is the length of the current message's header */; 12434 size_t i, len, mask_len = 0, header_len, body_len;; 12435 uint64_t data_len = 0;; 12436 ; 12437 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12438 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12439 */; 12440 unsigned char mask[4];; 12441 ; 12442 /* data points to th",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:359849,Performance,queue,queue,359849," 12395 if (conn->request_info.acceptedWebSocketSubprotocol) {; 12396 mg_printf(conn,; 12397 ""Sec-WebSocket-Protocol: %s\r\n\r\n"",; 12398 conn->request_info.acceptedWebSocketSubprotocol);; 12399 } else {; 12400 mg_printf(conn, ""%s"", ""\r\n"");; 12401 }; 12402 ; 12403 return 1;; 12404}; 12405 ; 12406 ; 12407#if !defined(MG_MAX_UNANSWERED_PING); 12408/* Configuration of the maximum number of websocket PINGs that might; 12409 * stay unanswered before the connection is considered broken.; 12410 * Note: The name of this define may still change (until it is; 12411 * defined as a compile parameter in a documentation).; 12412 */; 12413#define MG_MAX_UNANSWERED_PING (5); 12414#endif; 12415 ; 12416 ; 12417static void; 12418read_websocket(struct mg_connection *conn,; 12419 mg_websocket_data_handler ws_data_handler,; 12420 void *callback_data); 12421{; 12422 /* Pointer to the beginning of the portion of the incoming websocket; 12423 * message queue.; 12424 * The original websocket upgrade request is never removed, so the queue; 12425 * begins after it. */; 12426 unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;; 12427 int n, error, exit_by_callback;; 12428 int ret;; 12429 ; 12430 /* body_len is the length of the entire queue in bytes; 12431 * len is the length of the current message; 12432 * data_len is the length of the current message's data payload; 12433 * header_len is the length of the current message's header */; 12434 size_t i, len, mask_len = 0, header_len, body_len;; 12435 uint64_t data_len = 0;; 12436 ; 12437 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12438 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12439 */; 12440 unsigned char mask[4];; 12441 ; 12442 /* data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:360070,Performance,queue,queue,360070,"PING); 12408/* Configuration of the maximum number of websocket PINGs that might; 12409 * stay unanswered before the connection is considered broken.; 12410 * Note: The name of this define may still change (until it is; 12411 * defined as a compile parameter in a documentation).; 12412 */; 12413#define MG_MAX_UNANSWERED_PING (5); 12414#endif; 12415 ; 12416 ; 12417static void; 12418read_websocket(struct mg_connection *conn,; 12419 mg_websocket_data_handler ws_data_handler,; 12420 void *callback_data); 12421{; 12422 /* Pointer to the beginning of the portion of the incoming websocket; 12423 * message queue.; 12424 * The original websocket upgrade request is never removed, so the queue; 12425 * begins after it. */; 12426 unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;; 12427 int n, error, exit_by_callback;; 12428 int ret;; 12429 ; 12430 /* body_len is the length of the entire queue in bytes; 12431 * len is the length of the current message; 12432 * data_len is the length of the current message's data payload; 12433 * header_len is the length of the current message's header */; 12434 size_t i, len, mask_len = 0, header_len, body_len;; 12435 uint64_t data_len = 0;; 12436 ; 12437 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12438 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12439 */; 12440 unsigned char mask[4];; 12441 ; 12442 /* data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];; 12446 unsigned char mop; /* mask flag and opcode */; 12447 ; 12448 ; 12449 /* Variables used for connection monitoring */; 12450 double timeout = -1.0;; 12451 int enable_ping_pong = 0;; 12452 int ping_count = 0;; 12453 ; 12454 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12455 enable_ping_pong =; 12456 !mg_strcasecmp(c",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:363868,Performance,queue,queue,363868,"ader_len = 0;; 12482 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12483 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12484 len = buf[1] & 127;; 12485 mask_len = (buf[1] & 128) ? 4 : 0;; 12486 if ((len < 126) && (body_len >= mask_len)) {; 12487 /* inline 7-bit length field */; 12488 data_len = len;; 12489 header_len = 2 + mask_len;; 12490 } else if ((len == 126) && (body_len >= (4 + mask_len))) {; 12491 /* 16-bit length field */; 12492 header_len = 4 + mask_len;; 12493 data_len = ((((size_t)buf[2]) << 8) + buf[3]);; 12494 } else if (body_len >= (10 + mask_len)) {; 12495 /* 64-bit length field */; 12496 uint32_t l1, l2;; 12497 memcpy(&l1, &buf[2], 4); /* Use memcpy for alignment */; 12498 memcpy(&l2, &buf[6], 4);; 12499 header_len = 10 + mask_len;; 12500 data_len = (((uint64_t)ntohl(l1)) << 32) + ntohl(l2);; 12501 ; 12502 if (data_len > (uint64_t)0x7FFF0000ul) {; 12503 /* no can do */; 12504 mg_cry_internal(; 12505 conn,; 12506 ""%s"",; 12507 ""websocket out of memory; closing connection"");; 12508 break;; 12509 }; 12510 }; 12511 }; 12512 ; 12513 if ((header_len > 0) && (body_len >= header_len)) {; 12514 /* Allocate space to hold websocket payload */; 12515 unsigned char *data = mem;; 12516 ; 12517 if ((size_t)data_len > (size_t)sizeof(mem)) {; 12518 data = (unsigned char *)mg_malloc_ctx((size_t)data_len,; 12519 conn->phys_ctx);; 12520 if (data == NULL) {; 12521 /* Allocation failed, exit the loop and then close the; 12522 * connection */; 12523 mg_cry_internal(; 12524 conn,; 12525 ""%s"",; 12526 ""websocket out of memory; closing connection"");; 12527 break;; 12528 }; 12529 }; 12530 ; 12531 /* Copy the mask before we shift the queue and destroy it */; 12532 if (mask_len > 0) {; 12533 memcpy(mask, buf + header_len - mask_len, sizeof(mask));; 12534 } else {; 12535 memset(mask, 0, sizeof(mask));; 12536 }; 12537 ; 12538 /* Read frame payload from the first message in the queue into; 12539 * data and advance the queue by moving the memory in place.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:364113,Performance,queue,queue,364113,"ader_len = 0;; 12482 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12483 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12484 len = buf[1] & 127;; 12485 mask_len = (buf[1] & 128) ? 4 : 0;; 12486 if ((len < 126) && (body_len >= mask_len)) {; 12487 /* inline 7-bit length field */; 12488 data_len = len;; 12489 header_len = 2 + mask_len;; 12490 } else if ((len == 126) && (body_len >= (4 + mask_len))) {; 12491 /* 16-bit length field */; 12492 header_len = 4 + mask_len;; 12493 data_len = ((((size_t)buf[2]) << 8) + buf[3]);; 12494 } else if (body_len >= (10 + mask_len)) {; 12495 /* 64-bit length field */; 12496 uint32_t l1, l2;; 12497 memcpy(&l1, &buf[2], 4); /* Use memcpy for alignment */; 12498 memcpy(&l2, &buf[6], 4);; 12499 header_len = 10 + mask_len;; 12500 data_len = (((uint64_t)ntohl(l1)) << 32) + ntohl(l2);; 12501 ; 12502 if (data_len > (uint64_t)0x7FFF0000ul) {; 12503 /* no can do */; 12504 mg_cry_internal(; 12505 conn,; 12506 ""%s"",; 12507 ""websocket out of memory; closing connection"");; 12508 break;; 12509 }; 12510 }; 12511 }; 12512 ; 12513 if ((header_len > 0) && (body_len >= header_len)) {; 12514 /* Allocate space to hold websocket payload */; 12515 unsigned char *data = mem;; 12516 ; 12517 if ((size_t)data_len > (size_t)sizeof(mem)) {; 12518 data = (unsigned char *)mg_malloc_ctx((size_t)data_len,; 12519 conn->phys_ctx);; 12520 if (data == NULL) {; 12521 /* Allocation failed, exit the loop and then close the; 12522 * connection */; 12523 mg_cry_internal(; 12524 conn,; 12525 ""%s"",; 12526 ""websocket out of memory; closing connection"");; 12527 break;; 12528 }; 12529 }; 12530 ; 12531 /* Copy the mask before we shift the queue and destroy it */; 12532 if (mask_len > 0) {; 12533 memcpy(mask, buf + header_len - mask_len, sizeof(mask));; 12534 } else {; 12535 memset(mask, 0, sizeof(mask));; 12536 }; 12537 ; 12538 /* Read frame payload from the first message in the queue into; 12539 * data and advance the queue by moving the memory in place.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:364154,Performance,queue,queue,364154,"ader_len = 0;; 12482 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12483 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12484 len = buf[1] & 127;; 12485 mask_len = (buf[1] & 128) ? 4 : 0;; 12486 if ((len < 126) && (body_len >= mask_len)) {; 12487 /* inline 7-bit length field */; 12488 data_len = len;; 12489 header_len = 2 + mask_len;; 12490 } else if ((len == 126) && (body_len >= (4 + mask_len))) {; 12491 /* 16-bit length field */; 12492 header_len = 4 + mask_len;; 12493 data_len = ((((size_t)buf[2]) << 8) + buf[3]);; 12494 } else if (body_len >= (10 + mask_len)) {; 12495 /* 64-bit length field */; 12496 uint32_t l1, l2;; 12497 memcpy(&l1, &buf[2], 4); /* Use memcpy for alignment */; 12498 memcpy(&l2, &buf[6], 4);; 12499 header_len = 10 + mask_len;; 12500 data_len = (((uint64_t)ntohl(l1)) << 32) + ntohl(l2);; 12501 ; 12502 if (data_len > (uint64_t)0x7FFF0000ul) {; 12503 /* no can do */; 12504 mg_cry_internal(; 12505 conn,; 12506 ""%s"",; 12507 ""websocket out of memory; closing connection"");; 12508 break;; 12509 }; 12510 }; 12511 }; 12512 ; 12513 if ((header_len > 0) && (body_len >= header_len)) {; 12514 /* Allocate space to hold websocket payload */; 12515 unsigned char *data = mem;; 12516 ; 12517 if ((size_t)data_len > (size_t)sizeof(mem)) {; 12518 data = (unsigned char *)mg_malloc_ctx((size_t)data_len,; 12519 conn->phys_ctx);; 12520 if (data == NULL) {; 12521 /* Allocation failed, exit the loop and then close the; 12522 * connection */; 12523 mg_cry_internal(; 12524 conn,; 12525 ""%s"",; 12526 ""websocket out of memory; closing connection"");; 12527 break;; 12528 }; 12529 }; 12530 ; 12531 /* Copy the mask before we shift the queue and destroy it */; 12532 if (mask_len > 0) {; 12533 memcpy(mask, buf + header_len - mask_len, sizeof(mask));; 12534 } else {; 12535 memset(mask, 0, sizeof(mask));; 12536 }; 12537 ; 12538 /* Read frame payload from the first message in the queue into; 12539 * data and advance the queue by moving the memory in place.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:365303,Performance,queue,queue,365303,"t of memory; closing connection"");; 12527 break;; 12528 }; 12529 }; 12530 ; 12531 /* Copy the mask before we shift the queue and destroy it */; 12532 if (mask_len > 0) {; 12533 memcpy(mask, buf + header_len - mask_len, sizeof(mask));; 12534 } else {; 12535 memset(mask, 0, sizeof(mask));; 12536 }; 12537 ; 12538 /* Read frame payload from the first message in the queue into; 12539 * data and advance the queue by moving the memory in place. */; 12540 DEBUG_ASSERT(body_len >= header_len);; 12541 if (data_len + (uint64_t)header_len > (uint64_t)body_len) {; 12542 mop = buf[0]; /* current mask and opcode */; 12543 /* Overflow case */; 12544 len = body_len - header_len;; 12545 memcpy(data, buf + header_len, len);; 12546 error = 0;; 12547 while ((uint64_t)len < data_len) {; 12548 n = pull_inner(NULL,; 12549 conn,; 12550 (char *)(data + len),; 12551 (int)(data_len - len),; 12552 timeout);; 12553 if (n <= -2) {; 12554 error = 1;; 12555 break;; 12556 } else if (n > 0) {; 12557 len += (size_t)n;; 12558 } else {; 12559 /* Timeout: should retry */; 12560 /* TODO: retry condition */; 12561 }; 12562 }; 12563 if (error) {; 12564 mg_cry_internal(; 12565 conn,; 12566 ""%s"",; 12567 ""Websocket pull failed; closing connection"");; 12568 if (data != mem) {; 12569 mg_free(data);; 12570 }; 12571 break;; 12572 }; 12573 ; 12574 conn->data_len = conn->request_len;; 12575 ; 12576 } else {; 12577 ; 12578 mop = buf[0]; /* current mask and opcode, overwritten by; 12579 * memmove() */; 12580 ; 12581 /* Length of the message being read at the front of the; 12582 * queue. Cast to 31 bit is OK, since we limited; 12583 * data_len before. */; 12584 len = (size_t)data_len + header_len;; 12585 ; 12586 /* Copy the data payload into the data pointer for the; 12587 * callback. Cast to 31 bit is OK, since we; 12588 * limited data_len */; 12589 memcpy(data, buf + header_len, (size_t)data_len);; 12590 ; 12591 /* Move the queue forward len bytes */; 12592 memmove(buf, buf + len, body_len - len);; 12593 ; 12594 /* Ma",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:365655,Performance,queue,queue,365655,"3 if (error) {; 12564 mg_cry_internal(; 12565 conn,; 12566 ""%s"",; 12567 ""Websocket pull failed; closing connection"");; 12568 if (data != mem) {; 12569 mg_free(data);; 12570 }; 12571 break;; 12572 }; 12573 ; 12574 conn->data_len = conn->request_len;; 12575 ; 12576 } else {; 12577 ; 12578 mop = buf[0]; /* current mask and opcode, overwritten by; 12579 * memmove() */; 12580 ; 12581 /* Length of the message being read at the front of the; 12582 * queue. Cast to 31 bit is OK, since we limited; 12583 * data_len before. */; 12584 len = (size_t)data_len + header_len;; 12585 ; 12586 /* Copy the data payload into the data pointer for the; 12587 * callback. Cast to 31 bit is OK, since we; 12588 * limited data_len */; 12589 memcpy(data, buf + header_len, (size_t)data_len);; 12590 ; 12591 /* Move the queue forward len bytes */; 12592 memmove(buf, buf + len, body_len - len);; 12593 ; 12594 /* Mark the queue as advanced */; 12595 conn->data_len -= (int)len;; 12596 }; 12597 ; 12598 /* Apply mask if necessary */; 12599 if (mask_len > 0) {; 12600 for (i = 0; i < (size_t)data_len; i++) {; 12601 data[i] ^= mask[i & 3];; 12602 }; 12603 }; 12604 ; 12605 exit_by_callback = 0;; 12606 if (enable_ping_pong && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PONG)) {; 12607 /* filter PONG messages */; 12608 DEBUG_TRACE(""PONG from %s:%u"",; 12609 conn->request_info.remote_addr,; 12610 conn->request_info.remote_port);; 12611 /* No unanwered PINGs left */; 12612 ping_count = 0;; 12613 } else if (enable_ping_pong; 12614 && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PING)) {; 12615 /* reply PING messages */; 12616 DEBUG_TRACE(""Reply PING from %s:%u"",; 12617 conn->request_info.remote_addr,; 12618 conn->request_info.remote_port);; 12619 ret = mg_websocket_write(conn,; 12620 MG_WEBSOCKET_OPCODE_PONG,; 12621 (char *)data,; 12622 (size_t)data_len);; 12623 if (ret <= 0) {; 12624 /* Error: send failed */; 12625 DEBUG_TRACE(""Reply PONG failed (%i)"", ret);; 12626 break;; 12627 }; 12628 ; 12629 ; 12630 } else {; 12631 /* Exit t",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:365757,Performance,queue,queue,365757,"3 if (error) {; 12564 mg_cry_internal(; 12565 conn,; 12566 ""%s"",; 12567 ""Websocket pull failed; closing connection"");; 12568 if (data != mem) {; 12569 mg_free(data);; 12570 }; 12571 break;; 12572 }; 12573 ; 12574 conn->data_len = conn->request_len;; 12575 ; 12576 } else {; 12577 ; 12578 mop = buf[0]; /* current mask and opcode, overwritten by; 12579 * memmove() */; 12580 ; 12581 /* Length of the message being read at the front of the; 12582 * queue. Cast to 31 bit is OK, since we limited; 12583 * data_len before. */; 12584 len = (size_t)data_len + header_len;; 12585 ; 12586 /* Copy the data payload into the data pointer for the; 12587 * callback. Cast to 31 bit is OK, since we; 12588 * limited data_len */; 12589 memcpy(data, buf + header_len, (size_t)data_len);; 12590 ; 12591 /* Move the queue forward len bytes */; 12592 memmove(buf, buf + len, body_len - len);; 12593 ; 12594 /* Mark the queue as advanced */; 12595 conn->data_len -= (int)len;; 12596 }; 12597 ; 12598 /* Apply mask if necessary */; 12599 if (mask_len > 0) {; 12600 for (i = 0; i < (size_t)data_len; i++) {; 12601 data[i] ^= mask[i & 3];; 12602 }; 12603 }; 12604 ; 12605 exit_by_callback = 0;; 12606 if (enable_ping_pong && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PONG)) {; 12607 /* filter PONG messages */; 12608 DEBUG_TRACE(""PONG from %s:%u"",; 12609 conn->request_info.remote_addr,; 12610 conn->request_info.remote_port);; 12611 /* No unanwered PINGs left */; 12612 ping_count = 0;; 12613 } else if (enable_ping_pong; 12614 && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PING)) {; 12615 /* reply PING messages */; 12616 DEBUG_TRACE(""Reply PING from %s:%u"",; 12617 conn->request_info.remote_addr,; 12618 conn->request_info.remote_port);; 12619 ret = mg_websocket_write(conn,; 12620 MG_WEBSOCKET_OPCODE_PONG,; 12621 (char *)data,; 12622 (size_t)data_len);; 12623 if (ret <= 0) {; 12624 /* Error: send failed */; 12625 DEBUG_TRACE(""Reply PONG failed (%i)"", ret);; 12626 break;; 12627 }; 12628 ; 12629 ; 12630 } else {; 12631 /* Exit t",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:370454,Performance,queue,queue,370454,"llback = 1;; 12709 }; 12710 mg_free(inflated);; 12711 }; 12712 } else; 12713#endif; 12714 if (!ws_data_handler(conn,; 12715 mop,; 12716 (char *)data,; 12717 (size_t)data_len,; 12718 callback_data)) {; 12719 exit_by_callback = 1;; 12720 }; 12721 }; 12722 }; 12723 ; 12724 /* It a buffer has been allocated, free it again */; 12725 if (data != mem) {; 12726 mg_free(data);; 12727 }; 12728 ; 12729 if (exit_by_callback) {; 12730 DEBUG_TRACE(""Callback requests to close connection from %s:%u"",; 12731 conn->request_info.remote_addr,; 12732 conn->request_info.remote_port);; 12733 break;; 12734 }; 12735 if ((mop & 0xf) == MG_WEBSOCKET_OPCODE_CONNECTION_CLOSE) {; 12736 /* Opcode == 8, connection close */; 12737 DEBUG_TRACE(""Message requests to close connection from %s:%u"",; 12738 conn->request_info.remote_addr,; 12739 conn->request_info.remote_port);; 12740 break;; 12741 }; 12742 ; 12743 /* Not breaking the loop, process next websocket frame. */; 12744 } else {; 12745 /* Read from the socket into the next available location in the; 12746 * message queue. */; 12747 n = pull_inner(NULL,; 12748 conn,; 12749 conn->buf + conn->data_len,; 12750 conn->buf_size - conn->data_len,; 12751 timeout);; 12752 if (n <= -2) {; 12753 /* Error, no bytes read */; 12754 DEBUG_TRACE(""PULL from %s:%u failed"",; 12755 conn->request_info.remote_addr,; 12756 conn->request_info.remote_port);; 12757 break;; 12758 }; 12759 if (n > 0) {; 12760 conn->data_len += n;; 12761 /* Reset open PING count */; 12762 ping_count = 0;; 12763 } else {; 12764 if (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12765 && (!conn->must_close)) {; 12766 if (ping_count > MG_MAX_UNANSWERED_PING) {; 12767 /* Stop sending PING */; 12768 DEBUG_TRACE(""Too many (%i) unanswered ping from %s:%u ""; 12769 ""- closing connection"",; 12770 ping_count,; 12771 conn->request_info.remote_addr,; 12772 conn->request_info.remote_port);; 12773 break;; 12774 }; 12775 if (enable_ping_pong) {; 12776 /* Send Websocket PING message */; 12777 DEBUG_TRACE(""PIN",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:391166,Performance,throttle,throttle,391166,"nsupported, at least two colons are needed */; 13339 while (isxdigit((unsigned char)*p) || (*p == '.') || (*p == ':')) {; 13340 if (*(p++) == ':') {; 13341 c++;; 13342 }; 13343 }; 13344 if ((*p == '\0') && (c >= 2)) {; 13345 struct sockaddr_in6 sin6;; 13346 unsigned int i;; 13347 ; 13348 /* for strict validation, an actual IPv6 argument is needed */; 13349 if (sa->sa.sa_family != AF_INET6) {; 13350 return 0;; 13351 }; 13352 if (mg_inet_pton(AF_INET6, ad, &sin6, sizeof(sin6), 0)) {; 13353 /* IPv6 format */; 13354 for (i = 0; i < 16; i++) {; 13355 uint8_t ip = sa->sin6.sin6_addr.s6_addr[i];; 13356 uint8_t net = sin6.sin6_addr.s6_addr[i];; 13357 uint8_t mask = 0;; 13358 ; 13359 if (8 * i + 8 < slash) {; 13360 mask = 0xFFu;; 13361 } else if (8 * i < slash) {; 13362 mask = (uint8_t)(0xFFu << (8 * i + 8 - slash));; 13363 }; 13364 if ((ip & mask) != net) {; 13365 return 0;; 13366 }; 13367 }; 13368 return 1;; 13369 }; 13370 }; 13371 }; 13372 }; 13373#else; 13374 (void)no_strict;; 13375#endif; 13376 ; 13377 /* malformed */; 13378 return -1;; 13379}; 13380 ; 13381 ; 13382static int; 13383set_throttle(const char *spec, const union usa *rsa, const char *uri); 13384{; 13385 int throttle = 0;; 13386 struct vec vec, val;; 13387 char mult;; 13388 double v;; 13389 ; 13390 while ((spec = next_option(spec, &vec, &val)) != NULL) {; 13391 mult = ',';; 13392 if ((val.ptr == NULL); 13393 || (sscanf(val.ptr, ""%lf%c"", &v, &mult); 13394 < 1) // NOLINT(cert-err34-c) 'sscanf' used to convert a string; 13395 // to an integer value, but function will not report; 13396 // conversion errors; consider using 'strtol' instead; 13397 || (v < 0); 13398 || ((lowercase(&mult) != 'k') && (lowercase(&mult) != 'm'); 13399 && (mult != ','))) {; 13400 continue;; 13401 }; 13402 v *= (lowercase(&mult) == 'k'); 13403 ? 1024; 13404 : ((lowercase(&mult) == 'm') ? 1048576 : 1);; 13405 if (vec.len == 1 && vec.ptr[0] == '*') {; 13406 throttle = (int)v;; 13407 } else {; 13408 int matched = parse_match_net(&vec, rsa, 0",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:391898,Performance,throttle,throttle,391898,"rmed */; 13378 return -1;; 13379}; 13380 ; 13381 ; 13382static int; 13383set_throttle(const char *spec, const union usa *rsa, const char *uri); 13384{; 13385 int throttle = 0;; 13386 struct vec vec, val;; 13387 char mult;; 13388 double v;; 13389 ; 13390 while ((spec = next_option(spec, &vec, &val)) != NULL) {; 13391 mult = ',';; 13392 if ((val.ptr == NULL); 13393 || (sscanf(val.ptr, ""%lf%c"", &v, &mult); 13394 < 1) // NOLINT(cert-err34-c) 'sscanf' used to convert a string; 13395 // to an integer value, but function will not report; 13396 // conversion errors; consider using 'strtol' instead; 13397 || (v < 0); 13398 || ((lowercase(&mult) != 'k') && (lowercase(&mult) != 'm'); 13399 && (mult != ','))) {; 13400 continue;; 13401 }; 13402 v *= (lowercase(&mult) == 'k'); 13403 ? 1024; 13404 : ((lowercase(&mult) == 'm') ? 1048576 : 1);; 13405 if (vec.len == 1 && vec.ptr[0] == '*') {; 13406 throttle = (int)v;; 13407 } else {; 13408 int matched = parse_match_net(&vec, rsa, 0);; 13409 if (matched >= 0) {; 13410 /* a valid IP subnet */; 13411 if (matched) {; 13412 throttle = (int)v;; 13413 }; 13414 } else if (match_prefix(vec.ptr, vec.len, uri) > 0) {; 13415 throttle = (int)v;; 13416 }; 13417 }; 13418 }; 13419 ; 13420 return throttle;; 13421}; 13422 ; 13423 ; 13424/* The mg_upload function is superseeded by mg_handle_form_request. */; 13425#include ""handle_form.inl""; 13426 ; 13427 ; 13428static int; 13429get_first_ssl_listener_index(const struct mg_context *ctx); 13430{; 13431 unsigned int i;; 13432 int idx = -1;; 13433 if (ctx) {; 13434 for (i = 0; ((idx == -1) && (i < ctx->num_listening_sockets)); i++) {; 13435 idx = ctx->listening_sockets[i].is_ssl ? ((int)(i)) : -1;; 13436 }; 13437 }; 13438 return idx;; 13439}; 13440 ; 13441 ; 13442/* Return host (without port) */; 13443static void; 13444get_host_from_request_info(struct vec *host, const struct mg_request_info *ri); 13445{; 13446 const char *host_header =; 13447 get_header(ri->http_headers, ri->num_headers, ""Host"");; 13448 ; ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:392072,Performance,throttle,throttle,392072,"rmed */; 13378 return -1;; 13379}; 13380 ; 13381 ; 13382static int; 13383set_throttle(const char *spec, const union usa *rsa, const char *uri); 13384{; 13385 int throttle = 0;; 13386 struct vec vec, val;; 13387 char mult;; 13388 double v;; 13389 ; 13390 while ((spec = next_option(spec, &vec, &val)) != NULL) {; 13391 mult = ',';; 13392 if ((val.ptr == NULL); 13393 || (sscanf(val.ptr, ""%lf%c"", &v, &mult); 13394 < 1) // NOLINT(cert-err34-c) 'sscanf' used to convert a string; 13395 // to an integer value, but function will not report; 13396 // conversion errors; consider using 'strtol' instead; 13397 || (v < 0); 13398 || ((lowercase(&mult) != 'k') && (lowercase(&mult) != 'm'); 13399 && (mult != ','))) {; 13400 continue;; 13401 }; 13402 v *= (lowercase(&mult) == 'k'); 13403 ? 1024; 13404 : ((lowercase(&mult) == 'm') ? 1048576 : 1);; 13405 if (vec.len == 1 && vec.ptr[0] == '*') {; 13406 throttle = (int)v;; 13407 } else {; 13408 int matched = parse_match_net(&vec, rsa, 0);; 13409 if (matched >= 0) {; 13410 /* a valid IP subnet */; 13411 if (matched) {; 13412 throttle = (int)v;; 13413 }; 13414 } else if (match_prefix(vec.ptr, vec.len, uri) > 0) {; 13415 throttle = (int)v;; 13416 }; 13417 }; 13418 }; 13419 ; 13420 return throttle;; 13421}; 13422 ; 13423 ; 13424/* The mg_upload function is superseeded by mg_handle_form_request. */; 13425#include ""handle_form.inl""; 13426 ; 13427 ; 13428static int; 13429get_first_ssl_listener_index(const struct mg_context *ctx); 13430{; 13431 unsigned int i;; 13432 int idx = -1;; 13433 if (ctx) {; 13434 for (i = 0; ((idx == -1) && (i < ctx->num_listening_sockets)); i++) {; 13435 idx = ctx->listening_sockets[i].is_ssl ? ((int)(i)) : -1;; 13436 }; 13437 }; 13438 return idx;; 13439}; 13440 ; 13441 ; 13442/* Return host (without port) */; 13443static void; 13444get_host_from_request_info(struct vec *host, const struct mg_request_info *ri); 13445{; 13446 const char *host_header =; 13447 get_header(ri->http_headers, ri->num_headers, ""Host"");; 13448 ; ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:392168,Performance,throttle,throttle,392168," 13389 ; 13390 while ((spec = next_option(spec, &vec, &val)) != NULL) {; 13391 mult = ',';; 13392 if ((val.ptr == NULL); 13393 || (sscanf(val.ptr, ""%lf%c"", &v, &mult); 13394 < 1) // NOLINT(cert-err34-c) 'sscanf' used to convert a string; 13395 // to an integer value, but function will not report; 13396 // conversion errors; consider using 'strtol' instead; 13397 || (v < 0); 13398 || ((lowercase(&mult) != 'k') && (lowercase(&mult) != 'm'); 13399 && (mult != ','))) {; 13400 continue;; 13401 }; 13402 v *= (lowercase(&mult) == 'k'); 13403 ? 1024; 13404 : ((lowercase(&mult) == 'm') ? 1048576 : 1);; 13405 if (vec.len == 1 && vec.ptr[0] == '*') {; 13406 throttle = (int)v;; 13407 } else {; 13408 int matched = parse_match_net(&vec, rsa, 0);; 13409 if (matched >= 0) {; 13410 /* a valid IP subnet */; 13411 if (matched) {; 13412 throttle = (int)v;; 13413 }; 13414 } else if (match_prefix(vec.ptr, vec.len, uri) > 0) {; 13415 throttle = (int)v;; 13416 }; 13417 }; 13418 }; 13419 ; 13420 return throttle;; 13421}; 13422 ; 13423 ; 13424/* The mg_upload function is superseeded by mg_handle_form_request. */; 13425#include ""handle_form.inl""; 13426 ; 13427 ; 13428static int; 13429get_first_ssl_listener_index(const struct mg_context *ctx); 13430{; 13431 unsigned int i;; 13432 int idx = -1;; 13433 if (ctx) {; 13434 for (i = 0; ((idx == -1) && (i < ctx->num_listening_sockets)); i++) {; 13435 idx = ctx->listening_sockets[i].is_ssl ? ((int)(i)) : -1;; 13436 }; 13437 }; 13438 return idx;; 13439}; 13440 ; 13441 ; 13442/* Return host (without port) */; 13443static void; 13444get_host_from_request_info(struct vec *host, const struct mg_request_info *ri); 13445{; 13446 const char *host_header =; 13447 get_header(ri->http_headers, ri->num_headers, ""Host"");; 13448 ; 13449 host->ptr = NULL;; 13450 host->len = 0;; 13451 ; 13452 if (host_header != NULL) {; 13453 const char *pos;; 13454 ; 13455 /* If the ""Host"" is an IPv6 address, like [::1], parse until ]; 13456 * is found. */; 13457 if (*host_header == ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:392236,Performance,throttle,throttle,392236," 13389 ; 13390 while ((spec = next_option(spec, &vec, &val)) != NULL) {; 13391 mult = ',';; 13392 if ((val.ptr == NULL); 13393 || (sscanf(val.ptr, ""%lf%c"", &v, &mult); 13394 < 1) // NOLINT(cert-err34-c) 'sscanf' used to convert a string; 13395 // to an integer value, but function will not report; 13396 // conversion errors; consider using 'strtol' instead; 13397 || (v < 0); 13398 || ((lowercase(&mult) != 'k') && (lowercase(&mult) != 'm'); 13399 && (mult != ','))) {; 13400 continue;; 13401 }; 13402 v *= (lowercase(&mult) == 'k'); 13403 ? 1024; 13404 : ((lowercase(&mult) == 'm') ? 1048576 : 1);; 13405 if (vec.len == 1 && vec.ptr[0] == '*') {; 13406 throttle = (int)v;; 13407 } else {; 13408 int matched = parse_match_net(&vec, rsa, 0);; 13409 if (matched >= 0) {; 13410 /* a valid IP subnet */; 13411 if (matched) {; 13412 throttle = (int)v;; 13413 }; 13414 } else if (match_prefix(vec.ptr, vec.len, uri) > 0) {; 13415 throttle = (int)v;; 13416 }; 13417 }; 13418 }; 13419 ; 13420 return throttle;; 13421}; 13422 ; 13423 ; 13424/* The mg_upload function is superseeded by mg_handle_form_request. */; 13425#include ""handle_form.inl""; 13426 ; 13427 ; 13428static int; 13429get_first_ssl_listener_index(const struct mg_context *ctx); 13430{; 13431 unsigned int i;; 13432 int idx = -1;; 13433 if (ctx) {; 13434 for (i = 0; ((idx == -1) && (i < ctx->num_listening_sockets)); i++) {; 13435 idx = ctx->listening_sockets[i].is_ssl ? ((int)(i)) : -1;; 13436 }; 13437 }; 13438 return idx;; 13439}; 13440 ; 13441 ; 13442/* Return host (without port) */; 13443static void; 13444get_host_from_request_info(struct vec *host, const struct mg_request_info *ri); 13445{; 13446 const char *host_header =; 13447 get_header(ri->http_headers, ri->num_headers, ""Host"");; 13448 ; 13449 host->ptr = NULL;; 13450 host->len = 0;; 13451 ; 13452 if (host_header != NULL) {; 13453 const char *pos;; 13454 ; 13455 /* If the ""Host"" is an IPv6 address, like [::1], parse until ]; 13456 * is found. */; 13457 if (*host_header == ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:413629,Performance,throttle,throttle,413629,"fo.query_string) {; 14079 if (should_decode_query_string(conn)) {; 14080 url_decode_in_place((char *)conn->request_info.query_string);; 14081 }; 14082 }; 14083 ; 14084 /* 1.4. clean URIs, so a path like allowed_dir/../forbidden_file is not; 14085 * possible. The fact that we cleaned the URI is stored in that the; 14086 * pointer to ri->local_ur and ri->local_uri_raw are now different.; 14087 * ri->local_uri_raw still points to memory allocated in; 14088 * worker_thread_run(). ri->local_uri is private to the request so we; 14089 * don't have to use preallocated memory here. */; 14090 tmp = mg_strdup(ri->local_uri_raw);; 14091 if (!tmp) {; 14092 /* Out of memory. We cannot do anything reasonable here. */; 14093 return;; 14094 }; 14095 remove_dot_segments(tmp);; 14096 ri->local_uri = tmp;; 14097 ; 14098 /* step 1. completed, the url is known now */; 14099 DEBUG_TRACE(""URL: %s"", ri->local_uri);; 14100 ; 14101 /* 2. if this ip has limited speed, set it for this connection */; 14102 conn->throttle = set_throttle(conn->dom_ctx->config[THROTTLE],; 14103 &conn->client.rsa,; 14104 ri->local_uri);; 14105 ; 14106 /* 3. call a ""handle everything"" callback, if registered */; 14107 if (conn->phys_ctx->callbacks.begin_request != NULL) {; 14108 /* Note that since V1.7 the ""begin_request"" function is called; 14109 * before an authorization check. If an authorization check is; 14110 * required, use a request_handler instead. */; 14111 i = conn->phys_ctx->callbacks.begin_request(conn);; 14112 if (i > 0) {; 14113 /* callback already processed the request. Store the; 14114 return value as a status code for the access log. */; 14115 conn->status_code = i;; 14116 if (!conn->must_close) {; 14117 discard_unread_request_data(conn);; 14118 }; 14119 return;; 14120 } else if (i == 0) {; 14121 /* civetweb should process the request */; 14122 } else {; 14123 /* unspecified - may change with the next version */; 14124 return;; 14125 }; 14126 }; 14127 ; 14128 /* request not yet handled by a handler ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:428888,Performance,cache,cached,428888,">request_method, ""HEAD""))) {; 14526 mg_send_http_error(conn,; 14527 405,; 14528 ""%s method not allowed"",; 14529 conn->request_info.request_method);; 14530 return;; 14531 }; 14532 ; 14533 /* 14. directories */; 14534 if (file.stat.is_directory) {; 14535 /* Substitute files have already been handled above. */; 14536 /* Here we can either generate and send a directory listing,; 14537 * or send an ""access denied"" error. */; 14538 if (!mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],; 14539 ""yes"")) {; 14540 handle_directory_request(conn, path);; 14541 } else {; 14542 mg_send_http_error(conn,; 14543 403,; 14544 ""%s"",; 14545 ""Error: Directory listing denied"");; 14546 }; 14547 return;; 14548 }; 14549 ; 14550 /* 15. Files with search/replace patterns: LSP and SSI */; 14551 if (is_template_text_file) {; 14552 HTTP1_only;; 14553 handle_file_based_request(conn, path, &file);; 14554 return;; 14555 }; 14556 ; 14557 /* 16. Static file - maybe cached */; 14558#if !defined(NO_CACHING); 14559 if ((!conn->in_error_handler) && is_not_modified(conn, &file.stat)) {; 14560 /* Send 304 ""Not Modified"" - this must not send any body data */; 14561 handle_not_modified_static_file_request(conn, &file);; 14562 return;; 14563 }; 14564#endif /* !NO_CACHING */; 14565 ; 14566 /* 17. Static file - not cached */; 14567 handle_static_file_request(conn, path, &file, NULL, NULL);; 14568 ; 14569#endif /* !defined(NO_FILES) */; 14570}; 14571 ; 14572 ; 14573#if !defined(NO_FILESYSTEMS); 14574static void; 14575handle_file_based_request(struct mg_connection *conn,; 14576 const char *path,; 14577 struct mg_file *file); 14578{; 14579#if !defined(NO_CGI); 14580 unsigned char cgi_config_idx, inc, max;; 14581#endif; 14582 ; 14583 if (!conn || !conn->dom_ctx) {; 14584 return;; 14585 }; 14586 ; 14587#if defined(USE_LUA); 14588 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS],; 14589 path); 14590 > 0) {; 14591 if (is_in_script_path(conn, path)) {; 14592 /* Lua server page: an SS",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:429234,Performance,cache,cached,429234,"return;; 14548 }; 14549 ; 14550 /* 15. Files with search/replace patterns: LSP and SSI */; 14551 if (is_template_text_file) {; 14552 HTTP1_only;; 14553 handle_file_based_request(conn, path, &file);; 14554 return;; 14555 }; 14556 ; 14557 /* 16. Static file - maybe cached */; 14558#if !defined(NO_CACHING); 14559 if ((!conn->in_error_handler) && is_not_modified(conn, &file.stat)) {; 14560 /* Send 304 ""Not Modified"" - this must not send any body data */; 14561 handle_not_modified_static_file_request(conn, &file);; 14562 return;; 14563 }; 14564#endif /* !NO_CACHING */; 14565 ; 14566 /* 17. Static file - not cached */; 14567 handle_static_file_request(conn, path, &file, NULL, NULL);; 14568 ; 14569#endif /* !defined(NO_FILES) */; 14570}; 14571 ; 14572 ; 14573#if !defined(NO_FILESYSTEMS); 14574static void; 14575handle_file_based_request(struct mg_connection *conn,; 14576 const char *path,; 14577 struct mg_file *file); 14578{; 14579#if !defined(NO_CGI); 14580 unsigned char cgi_config_idx, inc, max;; 14581#endif; 14582 ; 14583 if (!conn || !conn->dom_ctx) {; 14584 return;; 14585 }; 14586 ; 14587#if defined(USE_LUA); 14588 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS],; 14589 path); 14590 > 0) {; 14591 if (is_in_script_path(conn, path)) {; 14592 /* Lua server page: an SSI like page containing mostly plain; 14593 * html code plus some tags with server generated contents. */; 14594 handle_lsp_request(conn, path, file, NULL);; 14595 } else {; 14596 /* Script was in an illegal path */; 14597 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14598 }; 14599 return;; 14600 }; 14601 ; 14602 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS], path); 14603 > 0) {; 14604 if (is_in_script_path(conn, path)) {; 14605 /* Lua in-server module script: a CGI like script used to; 14606 * generate the entire reply. */; 14607 mg_exec_lua_script(conn, path, NULL);; 14608 } else {; 14609 /* Script was in an illegal path */; 14610 mg_send_http_error(conn",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:471255,Performance,load,load,471255,";; 15901 return 1;; 15902 }; 15903 return 0;; 15904}; 15905 ; 15906 ; 15907#if defined(OPENSSL_API_1_1); 15908#else; 15909static void; 15910ssl_locking_callback(int mode, int mutex_num, const char *file, int line); 15911{; 15912 (void)line;; 15913 (void)file;; 15914 ; 15915 if (mode & 1) {; 15916 /* 1 is CRYPTO_LOCK */; 15917 (void)pthread_mutex_lock(&ssl_mutexes[mutex_num]);; 15918 } else {; 15919 (void)pthread_mutex_unlock(&ssl_mutexes[mutex_num]);; 15920 }; 15921}; 15922#endif /* OPENSSL_API_1_1 */; 15923 ; 15924 ; 15925#if !defined(NO_SSL_DL); 15926/* Load a DLL/Shared Object with a TLS/SSL implementation. */; 15927static void *; 15928load_tls_dll(char *ebuf,; 15929 size_t ebuf_len,; 15930 const char *dll_name,; 15931 struct ssl_func *sw,; 15932 int *feature_missing); 15933{; 15934 union {; 15935 void *p;; 15936 void (*fp)(void);; 15937 } u;; 15938 void *dll_handle;; 15939 struct ssl_func *fp;; 15940 int ok;; 15941 int truncated = 0;; 15942 ; 15943 if ((dll_handle = dlopen(dll_name, RTLD_LAZY)) == NULL) {; 15944 mg_snprintf(NULL,; 15945 NULL, /* No truncation check for ebuf */; 15946 ebuf,; 15947 ebuf_len,; 15948 ""%s: cannot load %s"",; 15949 __func__,; 15950 dll_name);; 15951 return NULL;; 15952 }; 15953 ; 15954 ok = 1;; 15955 for (fp = sw; fp->name != NULL; fp++) {; 15956#if defined(_WIN32); 15957 /* GetProcAddress() returns pointer to function */; 15958 u.fp = (void (*)(void))dlsym(dll_handle, fp->name);; 15959#else; 15960 /* dlsym() on UNIX returns void *. ISO C forbids casts of data; 15961 * pointers to function pointers. We need to use a union to make a; 15962 * cast. */; 15963 u.p = dlsym(dll_handle, fp->name);; 15964#endif /* _WIN32 */; 15965 ; 15966 /* Set pointer (might be NULL) */; 15967 fp->ptr = u.fp;; 15968 ; 15969 if (u.fp == NULL) {; 15970 DEBUG_TRACE(""Missing function: %s\n"", fp->name);; 15971 if (feature_missing) {; 15972 feature_missing[fp->required]++;; 15973 }; 15974 if (fp->required == TLS_Mandatory) {; 15975 /* Mandatory function is missing ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:474185,Performance,load,loading,474185,"tic void *ssllib_dll_handle; /* Store the ssl library handle. */; 16019static void *cryptolib_dll_handle; /* Store the crypto library handle. */; 16020 ; 16021#endif /* NO_SSL_DL */; 16022 ; 16023 ; 16024#if defined(SSL_ALREADY_INITIALIZED); 16025static volatile ptrdiff_t cryptolib_users =; 16026 1; /* Reference counter for crypto library. */; 16027#else; 16028static volatile ptrdiff_t cryptolib_users =; 16029 0; /* Reference counter for crypto library. */; 16030#endif; 16031 ; 16032 ; 16033static int; 16034initialize_openssl(char *ebuf, size_t ebuf_len); 16035{; 16036#if !defined(OPENSSL_API_1_1) && !defined(OPENSSL_API_3_0); 16037 int i, num_locks;; 16038 size_t size;; 16039#endif; 16040 ; 16041 if (ebuf_len > 0) {; 16042 ebuf[0] = 0;; 16043 }; 16044 ; 16045#if !defined(NO_SSL_DL); 16046 if (!cryptolib_dll_handle) {; 16047 memset(tls_feature_missing, 0, sizeof(tls_feature_missing));; 16048 cryptolib_dll_handle = load_tls_dll(; 16049 ebuf, ebuf_len, CRYPTO_LIB, crypto_sw, tls_feature_missing);; 16050 if (!cryptolib_dll_handle) {; 16051 mg_snprintf(NULL,; 16052 NULL, /* No truncation check for ebuf */; 16053 ebuf,; 16054 ebuf_len,; 16055 ""%s: error loading library %s"",; 16056 __func__,; 16057 CRYPTO_LIB);; 16058 DEBUG_TRACE(""%s"", ebuf);; 16059 return 0;; 16060 }; 16061 }; 16062#endif /* NO_SSL_DL */; 16063 ; 16064 if (mg_atomic_inc(&cryptolib_users) > 1) {; 16065 return 1;; 16066 }; 16067 ; 16068#if !defined(OPENSSL_API_1_1) && !defined(OPENSSL_API_3_0); 16069 /* Initialize locking callbacks, needed for thread safety.; 16070 * http://www.openssl.org/support/faq.html#PROG1; 16071 */; 16072 num_locks = CRYPTO_num_locks();; 16073 if (num_locks < 0) {; 16074 num_locks = 0;; 16075 }; 16076 size = sizeof(pthread_mutex_t) * ((size_t)(num_locks));; 16077 ; 16078 /* allocate mutex array, if required */; 16079 if (num_locks == 0) {; 16080 /* No mutex array required */; 16081 ssl_mutexes = NULL;; 16082 } else {; 16083 /* Mutex array required - allocate it */; 16084 ssl_mutexes",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:495291,Performance,load,load,495291,"ST]); 16662 != 1) {; 16663 mg_cry_ctx_internal(phys_ctx,; 16664 ""SSL_CTX_set_cipher_list error: %s"",; 16665 ssl_error());; 16666 }; 16667 }; 16668 ; 16669 /* SSL session caching */; 16670 ssl_cache_timeout = ((dom_ctx->config[SSL_CACHE_TIMEOUT] != NULL); 16671 ? atoi(dom_ctx->config[SSL_CACHE_TIMEOUT]); 16672 : 0);; 16673 if (ssl_cache_timeout > 0) {; 16674 SSL_CTX_set_session_cache_mode(dom_ctx->ssl_ctx, SSL_SESS_CACHE_BOTH);; 16675 /* SSL_CTX_sess_set_cache_size(dom_ctx->ssl_ctx, 10000); ... use; 16676 * default */; 16677 SSL_CTX_set_timeout(dom_ctx->ssl_ctx, (long)ssl_cache_timeout);; 16678 }; 16679 ; 16680#if defined(USE_ALPN); 16681 /* Initialize ALPN only of TLS library (OpenSSL version) supports ALPN */; 16682#if !defined(NO_SSL_DL); 16683 if (!tls_feature_missing[TLS_ALPN]); 16684#endif; 16685 {; 16686 init_alpn(phys_ctx, dom_ctx);; 16687 }; 16688#endif; 16689 ; 16690 return 1;; 16691}; 16692 ; 16693 ; 16694/* Check if SSL is required.; 16695 * If so, dynamically load SSL library; 16696 * and set up ctx->ssl_ctx pointer. */; 16697static int; 16698init_ssl_ctx(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx); 16699{; 16700 void *ssl_ctx = 0;; 16701 int callback_ret;; 16702 const char *pem;; 16703 const char *chain;; 16704 char ebuf[128];; 16705 ; 16706 if (!phys_ctx) {; 16707 return 0;; 16708 }; 16709 ; 16710 if (!dom_ctx) {; 16711 dom_ctx = &(phys_ctx->dd);; 16712 }; 16713 ; 16714 if (!is_ssl_port_used(dom_ctx->config[LISTENING_PORTS])) {; 16715 /* No SSL port is set. No need to setup SSL. */; 16716 return 1;; 16717 }; 16718 ; 16719 /* Check for external SSL_CTX */; 16720 callback_ret =; 16721 (phys_ctx->callbacks.external_ssl_ctx == NULL); 16722 ? 0; 16723 : (phys_ctx->callbacks.external_ssl_ctx(&ssl_ctx,; 16724 phys_ctx->user_data));; 16725 ; 16726 if (callback_ret < 0) {; 16727 /* Callback exists and returns <0: Initializing failed. */; 16728 mg_cry_ctx_internal(phys_ctx,; 16729 ""external_ssl_ctx callback returned error: %i"",; 16730 callback",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:501747,Performance,throttle,throttle,501747," mg_connection fc;; 16855 if (!dom_ctx) {; 16856 dom_ctx = &(phys_ctx->dd);; 16857 }; 16858 path = dom_ctx->config[GLOBAL_PASSWORDS_FILE];; 16859 if ((path != NULL); 16860 && !mg_stat(fake_connection(&fc, phys_ctx), path, &file.stat)) {; 16861 mg_cry_ctx_internal(phys_ctx,; 16862 ""Cannot open %s: %s"",; 16863 path,; 16864 strerror(ERRNO));; 16865 return 0;; 16866 }; 16867 return 1;; 16868 }; 16869 return 0;; 16870}; 16871#endif /* NO_FILESYSTEMS */; 16872 ; 16873 ; 16874static int; 16875set_acl_option(struct mg_context *phys_ctx); 16876{; 16877 union usa sa;; 16878 memset(&sa, 0, sizeof(sa));; 16879#if defined(USE_IPV6); 16880 sa.sin6.sin6_family = AF_INET6;; 16881#else; 16882 sa.sin.sin_family = AF_INET;; 16883#endif; 16884 return check_acl(phys_ctx, &sa) != -1;; 16885}; 16886 ; 16887 ; 16888static void; 16889reset_per_request_attributes(struct mg_connection *conn); 16890{; 16891 if (!conn) {; 16892 return;; 16893 }; 16894 ; 16895 conn->num_bytes_sent = conn->consumed_content = 0;; 16896 ; 16897 conn->path_info = NULL;; 16898 conn->status_code = -1;; 16899 conn->content_len = -1;; 16900 conn->is_chunked = 0;; 16901 conn->must_close = 0;; 16902 conn->request_len = 0;; 16903 conn->request_state = 0;; 16904 conn->throttle = 0;; 16905 conn->accept_gzip = 0;; 16906 ; 16907 conn->response_info.content_length = conn->request_info.content_length = -1;; 16908 conn->response_info.http_version = conn->request_info.http_version = NULL;; 16909 conn->response_info.num_headers = conn->request_info.num_headers = 0;; 16910 conn->response_info.status_text = NULL;; 16911 conn->response_info.status_code = 0;; 16912 ; 16913 conn->request_info.remote_user = NULL;; 16914 conn->request_info.request_method = NULL;; 16915 conn->request_info.request_uri = NULL;; 16916 ; 16917 /* Free cleaned local URI (if any) */; 16918 if (conn->request_info.local_uri != conn->request_info.local_uri_raw) {; 16919 mg_free((void *)conn->request_info.local_uri);; 16920 conn->request_info.local_uri = NULL;; 16921",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:556340,Performance,queue,queue,556340,">handled_requests);; 18700 mg_atomic_dec(&(conn->phys_ctx->active_connections));; 18701#endif; 18702}; 18703 ; 18704 ; 18705#if defined(ALTERNATIVE_QUEUE); 18706 ; 18707static void; 18708produce_socket(struct mg_context *ctx, const struct socket *sp); 18709{; 18710 unsigned int i;; 18711 ; 18712 while (!ctx->stop_flag) {; 18713 for (i = 0; i < ctx->cfg_worker_threads; i++) {; 18714 /* find a free worker slot and signal it */; 18715 if (ctx->client_socks[i].in_use == 2) {; 18716 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18717 if ((ctx->client_socks[i].in_use == 2) && !ctx->stop_flag) {; 18718 ctx->client_socks[i] = *sp;; 18719 ctx->client_socks[i].in_use = 1;; 18720 /* socket has been moved to the consumer */; 18721 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18722 (void)event_signal(ctx->client_wait_events[i]);; 18723 return;; 18724 }; 18725 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18726 }; 18727 }; 18728 /* queue is full */; 18729 mg_sleep(1);; 18730 }; 18731 /* must consume */; 18732 set_blocking_mode(sp->sock);; 18733 closesocket(sp->sock);; 18734}; 18735 ; 18736 ; 18737static int; 18738consume_socket(struct mg_context *ctx, struct socket *sp, int thread_index); 18739{; 18740 DEBUG_TRACE(""%s"", ""going idle"");; 18741 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18742 ctx->client_socks[thread_index].in_use = 2;; 18743 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18744 ; 18745 event_wait(ctx->client_wait_events[thread_index]);; 18746 ; 18747 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18748 *sp = ctx->client_socks[thread_index];; 18749 if (ctx->stop_flag) {; 18750 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18751 if (sp->in_use == 1) {; 18752 /* must consume */; 18753 set_blocking_mode(sp->sock);; 18754 closesocket(sp->sock);; 18755 }; 18756 return 0;; 18757 }; 18758 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18759 if (sp->in_use == 1) {; 18760 DEBUG_TRACE(""grabbed socket %d, going busy"", sp->sock);; 18761 return 1;; 18762 }; 1876",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:557584,Performance,queue,queue,557584,"ex);; 18726 }; 18727 }; 18728 /* queue is full */; 18729 mg_sleep(1);; 18730 }; 18731 /* must consume */; 18732 set_blocking_mode(sp->sock);; 18733 closesocket(sp->sock);; 18734}; 18735 ; 18736 ; 18737static int; 18738consume_socket(struct mg_context *ctx, struct socket *sp, int thread_index); 18739{; 18740 DEBUG_TRACE(""%s"", ""going idle"");; 18741 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18742 ctx->client_socks[thread_index].in_use = 2;; 18743 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18744 ; 18745 event_wait(ctx->client_wait_events[thread_index]);; 18746 ; 18747 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18748 *sp = ctx->client_socks[thread_index];; 18749 if (ctx->stop_flag) {; 18750 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18751 if (sp->in_use == 1) {; 18752 /* must consume */; 18753 set_blocking_mode(sp->sock);; 18754 closesocket(sp->sock);; 18755 }; 18756 return 0;; 18757 }; 18758 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18759 if (sp->in_use == 1) {; 18760 DEBUG_TRACE(""grabbed socket %d, going busy"", sp->sock);; 18761 return 1;; 18762 }; 18763 /* must not reach here */; 18764 DEBUG_ASSERT(0);; 18765 return 0;; 18766}; 18767 ; 18768#else /* ALTERNATIVE_QUEUE */; 18769 ; 18770/* Worker threads take accepted socket from the queue */; 18771static int; 18772consume_socket(struct mg_context *ctx, struct socket *sp, int thread_index); 18773{; 18774 (void)thread_index;; 18775 ; 18776 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18777 DEBUG_TRACE(""%s"", ""going idle"");; 18778 ; 18779 /* If the queue is empty, wait. We're idle at this point. */; 18780 while ((ctx->sq_head == ctx->sq_tail); 18781 && (STOP_FLAG_IS_ZERO(&ctx->stop_flag))) {; 18782 pthread_cond_wait(&ctx->sq_full, &ctx->thread_mutex);; 18783 }; 18784 ; 18785 /* If we're stopping, sq_head may be equal to sq_tail. */; 18786 if (ctx->sq_head > ctx->sq_tail) {; 18787 /* Copy socket from the queue and increment tail */; 18788 *sp = ctx->squeue[ctx->sq_tail % ctx->sq_size];; 18789 ctx",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:557853,Performance,queue,queue,557853,"ex);; 18726 }; 18727 }; 18728 /* queue is full */; 18729 mg_sleep(1);; 18730 }; 18731 /* must consume */; 18732 set_blocking_mode(sp->sock);; 18733 closesocket(sp->sock);; 18734}; 18735 ; 18736 ; 18737static int; 18738consume_socket(struct mg_context *ctx, struct socket *sp, int thread_index); 18739{; 18740 DEBUG_TRACE(""%s"", ""going idle"");; 18741 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18742 ctx->client_socks[thread_index].in_use = 2;; 18743 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18744 ; 18745 event_wait(ctx->client_wait_events[thread_index]);; 18746 ; 18747 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18748 *sp = ctx->client_socks[thread_index];; 18749 if (ctx->stop_flag) {; 18750 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18751 if (sp->in_use == 1) {; 18752 /* must consume */; 18753 set_blocking_mode(sp->sock);; 18754 closesocket(sp->sock);; 18755 }; 18756 return 0;; 18757 }; 18758 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18759 if (sp->in_use == 1) {; 18760 DEBUG_TRACE(""grabbed socket %d, going busy"", sp->sock);; 18761 return 1;; 18762 }; 18763 /* must not reach here */; 18764 DEBUG_ASSERT(0);; 18765 return 0;; 18766}; 18767 ; 18768#else /* ALTERNATIVE_QUEUE */; 18769 ; 18770/* Worker threads take accepted socket from the queue */; 18771static int; 18772consume_socket(struct mg_context *ctx, struct socket *sp, int thread_index); 18773{; 18774 (void)thread_index;; 18775 ; 18776 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18777 DEBUG_TRACE(""%s"", ""going idle"");; 18778 ; 18779 /* If the queue is empty, wait. We're idle at this point. */; 18780 while ((ctx->sq_head == ctx->sq_tail); 18781 && (STOP_FLAG_IS_ZERO(&ctx->stop_flag))) {; 18782 pthread_cond_wait(&ctx->sq_full, &ctx->thread_mutex);; 18783 }; 18784 ; 18785 /* If we're stopping, sq_head may be equal to sq_tail. */; 18786 if (ctx->sq_head > ctx->sq_tail) {; 18787 /* Copy socket from the queue and increment tail */; 18788 *sp = ctx->squeue[ctx->sq_tail % ctx->sq_size];; 18789 ctx",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:558215,Performance,queue,queue,558215,,MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:558828,Performance,queue,queue,558828,,MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:559103,Performance,queue,queue,559103,,MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:559691,Performance,queue,queue,559691,") {; 18795 ctx->sq_tail -= ctx->sq_size;; 18796 ctx->sq_head -= ctx->sq_size;; 18797 }; 18798 }; 18799 ; 18800 (void)pthread_cond_signal(&ctx->sq_empty);; 18801 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18802 ; 18803 return STOP_FLAG_IS_ZERO(&ctx->stop_flag);; 18804}; 18805 ; 18806 ; 18807/* Master thread adds accepted socket to a queue */; 18808static void; 18809produce_socket(struct mg_context *ctx, const struct socket *sp); 18810{; 18811 int queue_filled;; 18812 ; 18813 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18814 ; 18815 queue_filled = ctx->sq_head - ctx->sq_tail;; 18816 ; 18817 /* If the queue is full, wait */; 18818 while (STOP_FLAG_IS_ZERO(&ctx->stop_flag); 18819 && (queue_filled >= ctx->sq_size)) {; 18820 ctx->sq_blocked = 1; /* Status information: All threads busy */; 18821#if defined(USE_SERVER_STATS); 18822 if (queue_filled > ctx->sq_max_fill) {; 18823 ctx->sq_max_fill = queue_filled;; 18824 }; 18825#endif; 18826 (void)pthread_cond_wait(&ctx->sq_empty, &ctx->thread_mutex);; 18827 ctx->sq_blocked = 0; /* Not blocked now */; 18828 queue_filled = ctx->sq_head - ctx->sq_tail;; 18829 }; 18830 ; 18831 if (queue_filled < ctx->sq_size) {; 18832 /* Copy socket to the queue and increment head */; 18833 ctx->squeue[ctx->sq_head % ctx->sq_size] = *sp;; 18834 ctx->sq_head++;; 18835 DEBUG_TRACE(""queued socket %d"", sp ? sp->sock : -1);; 18836 }; 18837 ; 18838 queue_filled = ctx->sq_head - ctx->sq_tail;; 18839#if defined(USE_SERVER_STATS); 18840 if (queue_filled > ctx->sq_max_fill) {; 18841 ctx->sq_max_fill = queue_filled;; 18842 }; 18843#endif; 18844 ; 18845 (void)pthread_cond_signal(&ctx->sq_full);; 18846 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18847}; 18848#endif /* ALTERNATIVE_QUEUE */; 18849 ; 18850 ; 18851static void; 18852worker_thread_run(struct mg_connection *conn); 18853{; 18854 struct mg_context *ctx = conn->phys_ctx;; 18855 int thread_index;; 18856 struct mg_workerTLS tls;; 18857 ; 18858 mg_set_thread_name(""worker"");; 18859 ; 18860 tls.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:559817,Performance,queue,queued,559817,") {; 18795 ctx->sq_tail -= ctx->sq_size;; 18796 ctx->sq_head -= ctx->sq_size;; 18797 }; 18798 }; 18799 ; 18800 (void)pthread_cond_signal(&ctx->sq_empty);; 18801 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18802 ; 18803 return STOP_FLAG_IS_ZERO(&ctx->stop_flag);; 18804}; 18805 ; 18806 ; 18807/* Master thread adds accepted socket to a queue */; 18808static void; 18809produce_socket(struct mg_context *ctx, const struct socket *sp); 18810{; 18811 int queue_filled;; 18812 ; 18813 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18814 ; 18815 queue_filled = ctx->sq_head - ctx->sq_tail;; 18816 ; 18817 /* If the queue is full, wait */; 18818 while (STOP_FLAG_IS_ZERO(&ctx->stop_flag); 18819 && (queue_filled >= ctx->sq_size)) {; 18820 ctx->sq_blocked = 1; /* Status information: All threads busy */; 18821#if defined(USE_SERVER_STATS); 18822 if (queue_filled > ctx->sq_max_fill) {; 18823 ctx->sq_max_fill = queue_filled;; 18824 }; 18825#endif; 18826 (void)pthread_cond_wait(&ctx->sq_empty, &ctx->thread_mutex);; 18827 ctx->sq_blocked = 0; /* Not blocked now */; 18828 queue_filled = ctx->sq_head - ctx->sq_tail;; 18829 }; 18830 ; 18831 if (queue_filled < ctx->sq_size) {; 18832 /* Copy socket to the queue and increment head */; 18833 ctx->squeue[ctx->sq_head % ctx->sq_size] = *sp;; 18834 ctx->sq_head++;; 18835 DEBUG_TRACE(""queued socket %d"", sp ? sp->sock : -1);; 18836 }; 18837 ; 18838 queue_filled = ctx->sq_head - ctx->sq_tail;; 18839#if defined(USE_SERVER_STATS); 18840 if (queue_filled > ctx->sq_max_fill) {; 18841 ctx->sq_max_fill = queue_filled;; 18842 }; 18843#endif; 18844 ; 18845 (void)pthread_cond_signal(&ctx->sq_full);; 18846 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18847}; 18848#endif /* ALTERNATIVE_QUEUE */; 18849 ; 18850 ; 18851static void; 18852worker_thread_run(struct mg_connection *conn); 18853{; 18854 struct mg_context *ctx = conn->phys_ctx;; 18855 int thread_index;; 18856 struct mg_workerTLS tls;; 18857 ; 18858 mg_set_thread_name(""worker"");; 18859 ; 18860 tls.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:569733,Performance,queue,queue,569733,"4#endif; 19095 ; 19096 worker_thread_run((struct mg_connection *)thread_func_param);; 19097 return NULL;; 19098}; 19099#endif /* _WIN32 */; 19100 ; 19101 ; 19102/* This is an internal function, thus all arguments are expected to be; 19103 * valid - a NULL check is not required. */; 19104static void; 19105accept_new_connection(const struct socket *listener, struct mg_context *ctx); 19106{; 19107 struct socket so;; 19108 char src_addr[IP_ADDR_STR_LEN];; 19109 socklen_t len = sizeof(so.rsa);; 19110#if !defined(__ZEPHYR__); 19111 int on = 1;; 19112#endif; 19113 memset(&so, 0, sizeof(so));; 19114 ; 19115 if ((so.sock = accept(listener->sock, &so.rsa.sa, &len)); 19116 == INVALID_SOCKET) {; 19117 } else if (check_acl(ctx, &so.rsa) != 1) {; 19118 sockaddr_to_string(src_addr, sizeof(src_addr), &so.rsa);; 19119 mg_cry_ctx_internal(ctx,; 19120 ""%s: %s is not allowed to connect"",; 19121 __func__,; 19122 src_addr);; 19123 closesocket(so.sock);; 19124 } else {; 19125 /* Put so socket structure into the queue */; 19126 DEBUG_TRACE(""Accepted socket %d"", (int)so.sock);; 19127 set_close_on_exec(so.sock, NULL, ctx);; 19128 so.is_ssl = listener->is_ssl;; 19129 so.ssl_redir = listener->ssl_redir;; 19130 if (getsockname(so.sock, &so.lsa.sa, &len) != 0) {; 19131 mg_cry_ctx_internal(ctx,; 19132 ""%s: getsockname() failed: %s"",; 19133 __func__,; 19134 strerror(ERRNO));; 19135 }; 19136 ; 19137#if !defined(__ZEPHYR__); 19138 if ((so.lsa.sa.sa_family == AF_INET); 19139 || (so.lsa.sa.sa_family == AF_INET6)) {; 19140 /* Set TCP keep-alive for TCP sockets (IPv4 and IPv6).; 19141 * This is needed because if HTTP-level keep-alive; 19142 * is enabled, and client resets the connection, server won't get; 19143 * TCP FIN or RST and will keep the connection open forever. With; 19144 * TCP keep-alive, next keep-alive handshake will figure out that; 19145 * the client is down and will close the server end.; 19146 * Thanks to Igor Klopov who suggested the patch. */; 19147 if (setsockopt(so.sock,; 19148 SOL_",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:571250,Performance,throughput,throughput,571250,"9140 /* Set TCP keep-alive for TCP sockets (IPv4 and IPv6).; 19141 * This is needed because if HTTP-level keep-alive; 19142 * is enabled, and client resets the connection, server won't get; 19143 * TCP FIN or RST and will keep the connection open forever. With; 19144 * TCP keep-alive, next keep-alive handshake will figure out that; 19145 * the client is down and will close the server end.; 19146 * Thanks to Igor Klopov who suggested the patch. */; 19147 if (setsockopt(so.sock,; 19148 SOL_SOCKET,; 19149 SO_KEEPALIVE,; 19150 (SOCK_OPT_TYPE)&on,; 19151 sizeof(on)); 19152 != 0) {; 19153 mg_cry_ctx_internal(; 19154 ctx,; 19155 ""%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s"",; 19156 __func__,; 19157 strerror(ERRNO));; 19158 }; 19159 }; 19160#endif; 19161 ; 19162 /* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced; 19163 * to effectively fill up the underlying IP packet payload and; 19164 * reduce the overhead of sending lots of small buffers. However; 19165 * this hurts the server's throughput (ie. operations per second); 19166 * when HTTP 1.1 persistent connections are used and the responses; 19167 * are relatively small (eg. less than 1400 bytes).; 19168 */; 19169 if ((ctx->dd.config[CONFIG_TCP_NODELAY] != NULL); 19170 && (!strcmp(ctx->dd.config[CONFIG_TCP_NODELAY], ""1""))) {; 19171 if (set_tcp_nodelay(&so, 1) != 0) {; 19172 mg_cry_ctx_internal(; 19173 ctx,; 19174 ""%s: setsockopt(IPPROTO_TCP TCP_NODELAY) failed: %s"",; 19175 __func__,; 19176 strerror(ERRNO));; 19177 }; 19178 }; 19179 ; 19180 /* The ""non blocking"" property should already be; 19181 * inherited from the parent socket. Set it for; 19182 * non-compliant socket implementations. */; 19183 set_non_blocking_mode(so.sock);; 19184 ; 19185 so.in_use = 0;; 19186 produce_socket(ctx, &so);; 19187 }; 19188}; 19189 ; 19190 ; 19191static void; 19192master_thread_run(struct mg_context *ctx); 19193{; 19194 struct mg_workerTLS tls;; 19195 struct mg_pollfd *pfd;; 19196 unsigned int i;; 19197 unsigned int w",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:594133,Performance,load,load,594133," 19855 /* Document root */; 19856#if defined(NO_FILES); 19857 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19858 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19859 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19860 mg_snprintf(NULL,; 19861 NULL, /* No truncation check for error buffers */; 19862 error->text,; 19863 error->text_buffer_size,; 19864 ""Invalid configuration option value: %s"",; 19865 config_options[DOCUMENT_ROOT].name);; 19866 }; 19867 free_context(ctx);; 19868 pthread_setspecific(sTlsKey, NULL);; 19869 return NULL;; 19870 }; 19871#endif; 19872 ; 19873 get_system_name(&ctx->systemName);; 19874 ; 19875#if defined(USE_LUA); 19876 /* If a Lua background script has been configured, start it. */; 19877 ctx->lua_bg_log_available = 0;; 19878 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19879 char ebuf[256];; 19880 struct vec opt_vec;; 19881 struct vec eq_vec;; 19882 const char *sparams;; 19883 ; 19884 memset(ebuf, 0, sizeof(ebuf));; 19885 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19886 ; 19887 /* Create a Lua state, load all standard libraries and the mg table */; 19888 lua_State *state = mg_lua_context_script_prepare(; 19889 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19890 if (!state) {; 19891 mg_cry_ctx_internal(ctx,; 19892 ""lua_background_script load error: %s"",; 19893 ebuf);; 19894 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19895 mg_snprintf(NULL,; 19896 NULL, /* No truncation check for error buffers */; 19897 error->text,; 19898 error->text_buffer_size,; 19899 ""Error in script %s: %s"",; 19900 config_options[LUA_BACKGROUND_SCRIPT].name,; 19901 ebuf);; 19902 }; 19903 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19904 ; 19905 free_context(ctx);; 19906 pthread_setspecific(sTlsKey, NULL);; 19907 return NULL;; 19908 }; 19909 ; 19910 /* Add a table with parameters into mg.params */; 19911 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19912 if (sparams && sparams[0]) {; 19913 lu",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:594393,Performance,load,load,594393,"s"",; 19865 config_options[DOCUMENT_ROOT].name);; 19866 }; 19867 free_context(ctx);; 19868 pthread_setspecific(sTlsKey, NULL);; 19869 return NULL;; 19870 }; 19871#endif; 19872 ; 19873 get_system_name(&ctx->systemName);; 19874 ; 19875#if defined(USE_LUA); 19876 /* If a Lua background script has been configured, start it. */; 19877 ctx->lua_bg_log_available = 0;; 19878 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19879 char ebuf[256];; 19880 struct vec opt_vec;; 19881 struct vec eq_vec;; 19882 const char *sparams;; 19883 ; 19884 memset(ebuf, 0, sizeof(ebuf));; 19885 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19886 ; 19887 /* Create a Lua state, load all standard libraries and the mg table */; 19888 lua_State *state = mg_lua_context_script_prepare(; 19889 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19890 if (!state) {; 19891 mg_cry_ctx_internal(ctx,; 19892 ""lua_background_script load error: %s"",; 19893 ebuf);; 19894 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19895 mg_snprintf(NULL,; 19896 NULL, /* No truncation check for error buffers */; 19897 error->text,; 19898 error->text_buffer_size,; 19899 ""Error in script %s: %s"",; 19900 config_options[LUA_BACKGROUND_SCRIPT].name,; 19901 ebuf);; 19902 }; 19903 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19904 ; 19905 free_context(ctx);; 19906 pthread_setspecific(sTlsKey, NULL);; 19907 return NULL;; 19908 }; 19909 ; 19910 /* Add a table with parameters into mg.params */; 19911 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19912 if (sparams && sparams[0]) {; 19913 lua_getglobal(state, ""mg"");; 19914 lua_pushstring(state, ""params"");; 19915 lua_newtable(state);; 19916 ; 19917 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19918 != NULL) {; 19919 reg_llstring(; 19920 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19921 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19922 break;; 19923 }; 19924 lua_rawset(state, -3);; 19925 lua_pop(state, 1);; 19",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:627579,Performance,queue,queue,627579,"_connections;; 20976 int max_active_connections = (int)ctx->max_active_connections;; 20977 int total_connections = (int)ctx->total_connections;; 20978 if (active_connections > max_active_connections) {; 20979 max_active_connections = active_connections;; 20980 }; 20981 if (active_connections > total_connections) {; 20982 total_connections = active_connections;; 20983 }; 20984 ; 20985 /* Connections information */; 20986 mg_snprintf(NULL,; 20987 NULL,; 20988 block,; 20989 sizeof(block),; 20990 "",%s\""connections\"" : {%s""; 20991 ""\""active\"" : %i,%s""; 20992 ""\""maxActive\"" : %i,%s""; 20993 ""\""total\"" : %i%s""; 20994 ""}"",; 20995 eol,; 20996 eol,; 20997 active_connections,; 20998 eol,; 20999 max_active_connections,; 21000 eol,; 21001 total_connections,; 21002 eol);; 21003 context_info_length += mg_str_append(&buffer, end, block);; 21004 ; 21005 /* Queue information */; 21006#if !defined(ALTERNATIVE_QUEUE); 21007 mg_snprintf(NULL,; 21008 NULL,; 21009 block,; 21010 sizeof(block),; 21011 "",%s\""queue\"" : {%s""; 21012 ""\""length\"" : %i,%s""; 21013 ""\""filled\"" : %i,%s""; 21014 ""\""maxFilled\"" : %i,%s""; 21015 ""\""full\"" : %s%s""; 21016 ""}"",; 21017 eol,; 21018 eol,; 21019 ctx->sq_size,; 21020 eol,; 21021 ctx->sq_head - ctx->sq_tail,; 21022 eol,; 21023 ctx->sq_max_fill,; 21024 eol,; 21025 (ctx->sq_blocked ? ""true"" : ""false""),; 21026 eol);; 21027 context_info_length += mg_str_append(&buffer, end, block);; 21028#endif; 21029 ; 21030 /* Requests information */; 21031 mg_snprintf(NULL,; 21032 NULL,; 21033 block,; 21034 sizeof(block),; 21035 "",%s\""requests\"" : {%s""; 21036 ""\""total\"" : %lu%s""; 21037 ""}"",; 21038 eol,; 21039 eol,; 21040 (unsigned long)ctx->total_requests,; 21041 eol);; 21042 context_info_length += mg_str_append(&buffer, end, block);; 21043 ; 21044 /* Data information */; 21045 total_data_read =; 21046 mg_atomic_add64((volatile int64_t *)&ctx->total_data_read, 0);; 21047 total_data_written =; 21048 mg_atomic_add64((volatile int64_t *)&ctx->total_data_written, 0);; 21049 mg_snprintf(",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:703215,Performance,throttle,throttleint,703215,"*ssl_ctx, void *user_data)Definition civetweb.h:290; mg_client_certDefinition civetweb.h:206; mg_client_cert::issuerconst char * issuerDefinition civetweb.h:209; mg_client_cert::fingerconst char * fingerDefinition civetweb.h:211; mg_client_cert::peer_certvoid * peer_certDefinition civetweb.h:207; mg_client_cert::subjectconst char * subjectDefinition civetweb.h:208; mg_client_cert::serialconst char * serialDefinition civetweb.h:210; mg_client_optionsDefinition civetweb.h:1433; mg_client_options::host_nameconst char * host_nameDefinition civetweb.h:1438; mg_client_options::client_certconst char * client_certDefinition civetweb.h:1436; mg_client_options::portint portDefinition civetweb.h:1435; mg_client_options::server_certconst char * server_certDefinition civetweb.h:1437; mg_client_options::hostconst char * hostDefinition civetweb.h:1434; mg_connectionDefinition civetweb.c:2448; mg_connection::last_throttle_timetime_t last_throttle_timeDefinition civetweb.c:2526; mg_connection::throttleint throttleDefinition civetweb.c:2523; mg_connection::request_stateint request_stateDefinition civetweb.c:2451; mg_connection::content_lenint64_t content_lenDefinition civetweb.c:2481; mg_connection::req_timestruct timespec req_timeDefinition civetweb.c:2478; mg_connection::consumed_contentint64_t consumed_contentDefinition civetweb.c:2487; mg_connection::request_lenint request_lenDefinition civetweb.c:2520; mg_connection::path_infochar * path_infoDefinition civetweb.c:2496; mg_connection::is_chunkedint is_chunkedDefinition civetweb.c:2488; mg_connection::num_bytes_sentint64_t num_bytes_sentDefinition civetweb.c:2480; mg_connection::connection_typeint connection_typeDefinition civetweb.c:2449; mg_connection::buf_sizeint buf_sizeDefinition civetweb.c:2519; mg_connection::mutexpthread_mutex_t mutexDefinition civetweb.c:2528; mg_connection::clientstruct socket clientDefinition civetweb.c:2470; mg_connection::protocol_typeint protocol_typeDefinition civetweb.c:2450; mg_connection::must_clo",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:703227,Performance,throttle,throttleDefinition,703227,"*ssl_ctx, void *user_data)Definition civetweb.h:290; mg_client_certDefinition civetweb.h:206; mg_client_cert::issuerconst char * issuerDefinition civetweb.h:209; mg_client_cert::fingerconst char * fingerDefinition civetweb.h:211; mg_client_cert::peer_certvoid * peer_certDefinition civetweb.h:207; mg_client_cert::subjectconst char * subjectDefinition civetweb.h:208; mg_client_cert::serialconst char * serialDefinition civetweb.h:210; mg_client_optionsDefinition civetweb.h:1433; mg_client_options::host_nameconst char * host_nameDefinition civetweb.h:1438; mg_client_options::client_certconst char * client_certDefinition civetweb.h:1436; mg_client_options::portint portDefinition civetweb.h:1435; mg_client_options::server_certconst char * server_certDefinition civetweb.h:1437; mg_client_options::hostconst char * hostDefinition civetweb.h:1434; mg_connectionDefinition civetweb.c:2448; mg_connection::last_throttle_timetime_t last_throttle_timeDefinition civetweb.c:2526; mg_connection::throttleint throttleDefinition civetweb.c:2523; mg_connection::request_stateint request_stateDefinition civetweb.c:2451; mg_connection::content_lenint64_t content_lenDefinition civetweb.c:2481; mg_connection::req_timestruct timespec req_timeDefinition civetweb.c:2478; mg_connection::consumed_contentint64_t consumed_contentDefinition civetweb.c:2487; mg_connection::request_lenint request_lenDefinition civetweb.c:2520; mg_connection::path_infochar * path_infoDefinition civetweb.c:2496; mg_connection::is_chunkedint is_chunkedDefinition civetweb.c:2488; mg_connection::num_bytes_sentint64_t num_bytes_sentDefinition civetweb.c:2480; mg_connection::connection_typeint connection_typeDefinition civetweb.c:2449; mg_connection::buf_sizeint buf_sizeDefinition civetweb.c:2519; mg_connection::mutexpthread_mutex_t mutexDefinition civetweb.c:2528; mg_connection::clientstruct socket clientDefinition civetweb.c:2470; mg_connection::protocol_typeint protocol_typeDefinition civetweb.c:2450; mg_connection::must_clo",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:16509,Safety,timeout,timeouts,16509,"Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; 444 * decades ago, but better check both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#if !defined(CGI_ENVIRONMENT_SIZE); 486#define CGI_ENVIRONMENT_SIZE (4096) /* in bytes */; 487#endif; 488 ; 489/* Maximum number of environment variables. */; 490#if !defined(MAX_CGI_ENVIR_VARS); 491#define MAX_CGI_ENVIR_VARS (256) /* in variables (count) */; 492#endif; 493 ; 494/* General purpose buffer size. */; 49",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:16581,Safety,timeout,timeouts,16581,"Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; 444 * decades ago, but better check both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#if !defined(CGI_ENVIRONMENT_SIZE); 486#define CGI_ENVIRONMENT_SIZE (4096) /* in bytes */; 487#endif; 488 ; 489/* Maximum number of environment variables. */; 490#if !defined(MAX_CGI_ENVIR_VARS); 491#define MAX_CGI_ENVIR_VARS (256) /* in variables (count) */; 492#endif; 493 ; 494/* General purpose buffer size. */; 49",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:58318,Safety,avoid,avoid,58318,"; 1881 ; 1882#define STRUCT_FILE_INITIALIZER \; 1883 { \; 1884 {(uint64_t)0, (time_t)0, 0, 0, 0}, \; 1885 { \; 1886 (FILE *)NULL \; 1887 } \; 1888 }; 1889 ; 1890 ; 1891/* Describes listening socket, or socket which was accept()-ed by the master; 1892 * thread and queued for future handling by the worker thread. */; 1893struct socket {; 1894 SOCKET sock; /* Listening socket */; 1895 union usa lsa; /* Local socket address */; 1896 union usa rsa; /* Remote socket address */; 1897 unsigned char is_ssl; /* Is port SSL-ed */; 1898 unsigned char ssl_redir; /* Is port supposed to redirect everything to SSL; 1899 * port */; 1900 unsigned char in_use; /* 0: invalid, 1: valid, 2: free */; 1901};; 1902 ; 1903 ; 1904/* Enum const for all options must be in sync with; 1905 * static struct mg_option config_options[]; 1906 * This is tested in the unit test (test/private.c); 1907 * ""Private Config Options""; 1908 */; 1909enum {; 1910 /* Once for each server */; 1911 LISTENING_PORTS,; 1912 NUM_THREADS,; 1913 RUN_AS_USER,; 1914 CONFIG_TCP_NODELAY, /* Prepended CONFIG_ to avoid conflict with the; 1915 * socket option typedef TCP_NODELAY. */; 1916 MAX_REQUEST_SIZE,; 1917 LINGER_TIMEOUT,; 1918 CONNECTION_QUEUE_SIZE,; 1919 LISTEN_BACKLOG_SIZE,; 1920#if defined(__linux__); 1921 ALLOW_SENDFILE_CALL,; 1922#endif; 1923#if defined(_WIN32); 1924 CASE_SENSITIVE_FILES,; 1925#endif; 1926 THROTTLE,; 1927 ENABLE_KEEP_ALIVE,; 1928 REQUEST_TIMEOUT,; 1929 KEEP_ALIVE_TIMEOUT,; 1930#if defined(USE_WEBSOCKET); 1931 WEBSOCKET_TIMEOUT,; 1932 ENABLE_WEBSOCKET_PING_PONG,; 1933#endif; 1934 DECODE_URL,; 1935 DECODE_QUERY_STRING,; 1936#if defined(USE_LUA); 1937 LUA_BACKGROUND_SCRIPT,; 1938 LUA_BACKGROUND_SCRIPT_PARAMS,; 1939#endif; 1940#if defined(USE_HTTP2); 1941 ENABLE_HTTP2,; 1942#endif; 1943 ; 1944 /* Once for each domain */; 1945 DOCUMENT_ROOT,; 1946 ; 1947 ACCESS_LOG_FILE,; 1948 ERROR_LOG_FILE,; 1949 ; 1950 CGI_EXTENSIONS,; 1951 CGI_ENVIRONMENT,; 1952 CGI_INTERPRETER,; 1953 CGI_INTERPRETER_ARGS,; 1954#if def",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:71412,Safety,timeout,timeouts,71412," used for authentication */; 2260 ; 2261#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2262 /* linked list of shared lua websockets */; 2263 struct mg_shared_lua_websocket_list *shared_lua_websockets;; 2264#endif; 2265 ; 2266 /* Linked list of domains */; 2267 struct mg_domain_context *next;; 2268};; 2269 ; 2270 ; 2271/* Stop flag can be ""volatile"" or require a lock.; 2272 * MSDN uses volatile for ""Interlocked"" operations, but also explicitly; 2273 * states a read operation for int is always atomic. */; 2274#if defined(STOP_FLAG_NEEDS_LOCK); 2275 ; 2276typedef ptrdiff_t volatile stop_flag_t;; 2277 ; 2278static int; 2279STOP_FLAG_IS_ZERO(stop_flag_t *f); 2280{; 2281 stop_flag_t sf = mg_atomic_add(f, 0);; 2282 return (sf == 0);; 2283}; 2284 ; 2285static int; 2286STOP_FLAG_IS_TWO(stop_flag_t *f); 2287{; 2288 stop_flag_t sf = mg_atomic_add(f, 0);; 2289 return (sf == 2);; 2290}; 2291 ; 2292static void; 2293STOP_FLAG_ASSIGN(stop_flag_t *f, stop_flag_t v); 2294{; 2295 stop_flag_t sf;; 2296 do {; 2297 sf = mg_atomic_compare_and_swap(f, *f, v);; 2298 } while (sf != v);; 2299}; 2300 ; 2301#else /* STOP_FLAG_NEEDS_LOCK */; 2302 ; 2303typedef int volatile stop_flag_t;; 2304#define STOP_FLAG_IS_ZERO(f) ((*(f)) == 0); 2305#define STOP_FLAG_IS_TWO(f) ((*(f)) == 2); 2306#define STOP_FLAG_ASSIGN(f, v) ((*(f)) = (v)); 2307 ; 2308#endif /* STOP_FLAG_NEEDS_LOCK */; 2309 ; 2310 ; 2311struct mg_context {; 2312 ; 2313 /* Part 1 - Physical context:; 2314 * This holds threads, ports, timeouts, ...; 2315 * set for the entire server, independent from the; 2316 * addressed hostname.; 2317 */; 2318 ; 2319 /* Connection related */; 2320 int context_type; /* See CONTEXT_* above */; 2321 ; 2322 struct socket *listening_sockets;; 2323 struct mg_pollfd *listening_socket_fds;; 2324 unsigned int num_listening_sockets;; 2325 ; 2326 struct mg_connection *worker_connections; /* The connection struct, pre-; 2327 * allocated for each worker */; 2328 ; 2329#if defined(USE_SERVER_STATS); 2330 volatile ptrdif",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:104100,Safety,safe,safe,104100,"9 va_list ap;; 3470 va_start(ap, fmt);; 3471 mg_cry_internal_impl(conn, ""user"", 0, fmt, ap);; 3472 va_end(ap);; 3473}; 3474 ; 3475 ; 3476#define mg_cry DO_NOT_USE_THIS_FUNCTION__USE_mg_cry_internal; 3477 ; 3478 ; 3479const char *; 3480mg_version(void); 3481{; 3482 return CIVETWEB_VERSION;; 3483}; 3484 ; 3485 ; 3486const struct mg_request_info *; 3487mg_get_request_info(const struct mg_connection *conn); 3488{; 3489 if (!conn) {; 3490 return NULL;; 3491 }; 3492#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE); 3493 if (conn->connection_type == CONNECTION_TYPE_RESPONSE) {; 3494 char txt[16];; 3495 struct mg_workerTLS *tls =; 3496 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 3497 ; 3498 sprintf(txt, ""%03i"", conn->response_info.status_code);; 3499 if (strlen(txt) == 3) {; 3500 memcpy(tls->txtbuf, txt, 4);; 3501 } else {; 3502 strcpy(tls->txtbuf, ""ERR"");; 3503 }; 3504 ; 3505 ((struct mg_connection *)conn)->request_info.local_uri =; 3506 tls->txtbuf; /* use thread safe buffer */; 3507 ((struct mg_connection *)conn)->request_info.local_uri_raw =; 3508 tls->txtbuf; /* use the same thread safe buffer */; 3509 ((struct mg_connection *)conn)->request_info.request_uri =; 3510 tls->txtbuf; /* use the same thread safe buffer */; 3511 ; 3512 ((struct mg_connection *)conn)->request_info.num_headers =; 3513 conn->response_info.num_headers;; 3514 memcpy(((struct mg_connection *)conn)->request_info.http_headers,; 3515 conn->response_info.http_headers,; 3516 sizeof(conn->response_info.http_headers));; 3517 } else; 3518#endif; 3519 if (conn->connection_type != CONNECTION_TYPE_REQUEST) {; 3520 return NULL;; 3521 }; 3522 return &conn->request_info;; 3523}; 3524 ; 3525 ; 3526const struct mg_response_info *; 3527mg_get_response_info(const struct mg_connection *conn); 3528{; 3529 if (!conn) {; 3530 return NULL;; 3531 }; 3532 if (conn->connection_type != CONNECTION_TYPE_RESPONSE) {; 3533 return NULL;; 3534 }; 3535 return &conn->response_info;; 3536}; 3537 ; 3538 ; 3539static c",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:104224,Safety,safe,safe,104224," 3474 ; 3475 ; 3476#define mg_cry DO_NOT_USE_THIS_FUNCTION__USE_mg_cry_internal; 3477 ; 3478 ; 3479const char *; 3480mg_version(void); 3481{; 3482 return CIVETWEB_VERSION;; 3483}; 3484 ; 3485 ; 3486const struct mg_request_info *; 3487mg_get_request_info(const struct mg_connection *conn); 3488{; 3489 if (!conn) {; 3490 return NULL;; 3491 }; 3492#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE); 3493 if (conn->connection_type == CONNECTION_TYPE_RESPONSE) {; 3494 char txt[16];; 3495 struct mg_workerTLS *tls =; 3496 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 3497 ; 3498 sprintf(txt, ""%03i"", conn->response_info.status_code);; 3499 if (strlen(txt) == 3) {; 3500 memcpy(tls->txtbuf, txt, 4);; 3501 } else {; 3502 strcpy(tls->txtbuf, ""ERR"");; 3503 }; 3504 ; 3505 ((struct mg_connection *)conn)->request_info.local_uri =; 3506 tls->txtbuf; /* use thread safe buffer */; 3507 ((struct mg_connection *)conn)->request_info.local_uri_raw =; 3508 tls->txtbuf; /* use the same thread safe buffer */; 3509 ((struct mg_connection *)conn)->request_info.request_uri =; 3510 tls->txtbuf; /* use the same thread safe buffer */; 3511 ; 3512 ((struct mg_connection *)conn)->request_info.num_headers =; 3513 conn->response_info.num_headers;; 3514 memcpy(((struct mg_connection *)conn)->request_info.http_headers,; 3515 conn->response_info.http_headers,; 3516 sizeof(conn->response_info.http_headers));; 3517 } else; 3518#endif; 3519 if (conn->connection_type != CONNECTION_TYPE_REQUEST) {; 3520 return NULL;; 3521 }; 3522 return &conn->request_info;; 3523}; 3524 ; 3525 ; 3526const struct mg_response_info *; 3527mg_get_response_info(const struct mg_connection *conn); 3528{; 3529 if (!conn) {; 3530 return NULL;; 3531 }; 3532 if (conn->connection_type != CONNECTION_TYPE_RESPONSE) {; 3533 return NULL;; 3534 }; 3535 return &conn->response_info;; 3536}; 3537 ; 3538 ; 3539static const char *; 3540get_proto_name(const struct mg_connection *conn); 3541{; 3542#if defined(__clang__); 3543#pragma cla",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:104346,Safety,safe,safe,104346,"n(void); 3481{; 3482 return CIVETWEB_VERSION;; 3483}; 3484 ; 3485 ; 3486const struct mg_request_info *; 3487mg_get_request_info(const struct mg_connection *conn); 3488{; 3489 if (!conn) {; 3490 return NULL;; 3491 }; 3492#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE); 3493 if (conn->connection_type == CONNECTION_TYPE_RESPONSE) {; 3494 char txt[16];; 3495 struct mg_workerTLS *tls =; 3496 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 3497 ; 3498 sprintf(txt, ""%03i"", conn->response_info.status_code);; 3499 if (strlen(txt) == 3) {; 3500 memcpy(tls->txtbuf, txt, 4);; 3501 } else {; 3502 strcpy(tls->txtbuf, ""ERR"");; 3503 }; 3504 ; 3505 ((struct mg_connection *)conn)->request_info.local_uri =; 3506 tls->txtbuf; /* use thread safe buffer */; 3507 ((struct mg_connection *)conn)->request_info.local_uri_raw =; 3508 tls->txtbuf; /* use the same thread safe buffer */; 3509 ((struct mg_connection *)conn)->request_info.request_uri =; 3510 tls->txtbuf; /* use the same thread safe buffer */; 3511 ; 3512 ((struct mg_connection *)conn)->request_info.num_headers =; 3513 conn->response_info.num_headers;; 3514 memcpy(((struct mg_connection *)conn)->request_info.http_headers,; 3515 conn->response_info.http_headers,; 3516 sizeof(conn->response_info.http_headers));; 3517 } else; 3518#endif; 3519 if (conn->connection_type != CONNECTION_TYPE_REQUEST) {; 3520 return NULL;; 3521 }; 3522 return &conn->request_info;; 3523}; 3524 ; 3525 ; 3526const struct mg_response_info *; 3527mg_get_response_info(const struct mg_connection *conn); 3528{; 3529 if (!conn) {; 3530 return NULL;; 3531 }; 3532 if (conn->connection_type != CONNECTION_TYPE_RESPONSE) {; 3533 return NULL;; 3534 }; 3535 return &conn->response_info;; 3536}; 3537 ; 3538 ; 3539static const char *; 3540get_proto_name(const struct mg_connection *conn); 3541{; 3542#if defined(__clang__); 3543#pragma clang diagnostic push; 3544#pragma clang diagnostic ignored ""-Wunreachable-code""; 3545 /* Depending on USE_WEBSOCKET and NO_SSL, s",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:131409,Safety,avoid,avoid,131409,"7 ; 4368 if ((conn == NULL) || (fmt == NULL)) {; 4369 return -2;; 4370 }; 4371 ; 4372 /* Set status (for log) */; 4373 conn->status_code = status;; 4374 ; 4375 /* Errors 1xx, 204 and 304 MUST NOT send a body */; 4376 has_body = ((status > 199) && (status != 204) && (status != 304));; 4377 ; 4378 /* Prepare message in buf, if required */; 4379 if (has_body; 4380 || (!conn->in_error_handler; 4381 && (conn->phys_ctx->callbacks.http_error != NULL))) {; 4382 /* Store error message in errmsg_buf */; 4383 va_copy(ap, args);; 4384 mg_vsnprintf(conn, NULL, errmsg_buf, sizeof(errmsg_buf), fmt, ap);; 4385 va_end(ap);; 4386 /* In a debug build, print all html errors */; 4387 DEBUG_TRACE(""Error %i - [%s]"", status, errmsg_buf);; 4388 }; 4389 ; 4390 /* If there is a http_error callback, call it.; 4391 * But don't do it recursively, if callback calls mg_send_http_error again.; 4392 */; 4393 if (!conn->in_error_handler; 4394 && (conn->phys_ctx->callbacks.http_error != NULL)) {; 4395 /* Mark in_error_handler to avoid recursion and call user callback. */; 4396 conn->in_error_handler = 1;; 4397 handled_by_callback =; 4398 (conn->phys_ctx->callbacks.http_error(conn, status, errmsg_buf); 4399 == 0);; 4400 conn->in_error_handler = 0;; 4401 }; 4402 ; 4403 if (!handled_by_callback) {; 4404 /* Check for recursion */; 4405 if (conn->in_error_handler) {; 4406 DEBUG_TRACE(; 4407 ""Recursion when handling error %u - fall back to default"",; 4408 status);; 4409#if !defined(NO_FILESYSTEMS); 4410 } else {; 4411 /* Send user defined error pages, if defined */; 4412 error_handler = conn->dom_ctx->config[ERROR_PAGES];; 4413 error_page_file_ext = conn->dom_ctx->config[INDEX_FILES];; 4414 page_handler_found = 0;; 4415 ; 4416 if (error_handler != NULL) {; 4417 for (scope = 1; (scope <= 3) && !page_handler_found; scope++) {; 4418 switch (scope) {; 4419 case 1: /* Handler for specific error, e.g. 404 error */; 4420 mg_snprintf(conn,; 4421 &truncated,; 4422 path_buf,; 4423 sizeof(path_buf) - 32,; 4424 ""%serro",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:133150,Safety,redund,redundant,133150," && !page_handler_found; scope++) {; 4418 switch (scope) {; 4419 case 1: /* Handler for specific error, e.g. 404 error */; 4420 mg_snprintf(conn,; 4421 &truncated,; 4422 path_buf,; 4423 sizeof(path_buf) - 32,; 4424 ""%serror%03u."",; 4425 error_handler,; 4426 status);; 4427 break;; 4428 case 2: /* Handler for error group, e.g., 5xx error; 4429 * handler; 4430 * for all server errors (500-599) */; 4431 mg_snprintf(conn,; 4432 &truncated,; 4433 path_buf,; 4434 sizeof(path_buf) - 32,; 4435 ""%serror%01uxx."",; 4436 error_handler,; 4437 status / 100);; 4438 break;; 4439 default: /* Handler for all errors */; 4440 mg_snprintf(conn,; 4441 &truncated,; 4442 path_buf,; 4443 sizeof(path_buf) - 32,; 4444 ""%serror."",; 4445 error_handler);; 4446 break;; 4447 }; 4448 ; 4449 /* String truncation in buf may only occur if; 4450 * error_handler is too long. This string is; 4451 * from the config, not from a client. */; 4452 (void)truncated;; 4453 ; 4454 /* The following code is redundant, but it should avoid; 4455 * false positives in static source code analyzers and; 4456 * vulnerability scanners.; 4457 */; 4458 path_buf[sizeof(path_buf) - 32] = 0;; 4459 len = (int)strlen(path_buf);; 4460 if (len > (int)sizeof(path_buf) - 32) {; 4461 len = (int)sizeof(path_buf) - 32;; 4462 }; 4463 ; 4464 /* Start with the file extenstion from the configuration. */; 4465 tstr = strchr(error_page_file_ext, '.');; 4466 ; 4467 while (tstr) {; 4468 for (i = 1;; 4469 (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');; 4470 i++) {; 4471 /* buffer overrun is not possible here, since; 4472 * (i < 32) && (len < sizeof(path_buf) - 32); 4473 * ==> (i + len) < sizeof(path_buf) */; 4474 path_buf[len + i - 1] = tstr[i];; 4475 }; 4476 /* buffer overrun is not possible here, since; 4477 * (i <= 32) && (len < sizeof(path_buf) - 32); 4478 * ==> (i + len) <= sizeof(path_buf) */; 4479 path_buf[len + i - 1] = 0;; 4480 ; 4481 if (mg_stat(conn, path_buf, &error_page_file.stat)) {; 4482 DEBUG_TRACE(""Check error page %s - found"",; ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:133175,Safety,avoid,avoid,133175," && !page_handler_found; scope++) {; 4418 switch (scope) {; 4419 case 1: /* Handler for specific error, e.g. 404 error */; 4420 mg_snprintf(conn,; 4421 &truncated,; 4422 path_buf,; 4423 sizeof(path_buf) - 32,; 4424 ""%serror%03u."",; 4425 error_handler,; 4426 status);; 4427 break;; 4428 case 2: /* Handler for error group, e.g., 5xx error; 4429 * handler; 4430 * for all server errors (500-599) */; 4431 mg_snprintf(conn,; 4432 &truncated,; 4433 path_buf,; 4434 sizeof(path_buf) - 32,; 4435 ""%serror%01uxx."",; 4436 error_handler,; 4437 status / 100);; 4438 break;; 4439 default: /* Handler for all errors */; 4440 mg_snprintf(conn,; 4441 &truncated,; 4442 path_buf,; 4443 sizeof(path_buf) - 32,; 4444 ""%serror."",; 4445 error_handler);; 4446 break;; 4447 }; 4448 ; 4449 /* String truncation in buf may only occur if; 4450 * error_handler is too long. This string is; 4451 * from the config, not from a client. */; 4452 (void)truncated;; 4453 ; 4454 /* The following code is redundant, but it should avoid; 4455 * false positives in static source code analyzers and; 4456 * vulnerability scanners.; 4457 */; 4458 path_buf[sizeof(path_buf) - 32] = 0;; 4459 len = (int)strlen(path_buf);; 4460 if (len > (int)sizeof(path_buf) - 32) {; 4461 len = (int)sizeof(path_buf) - 32;; 4462 }; 4463 ; 4464 /* Start with the file extenstion from the configuration. */; 4465 tstr = strchr(error_page_file_ext, '.');; 4466 ; 4467 while (tstr) {; 4468 for (i = 1;; 4469 (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');; 4470 i++) {; 4471 /* buffer overrun is not possible here, since; 4472 * (i < 32) && (len < sizeof(path_buf) - 32); 4473 * ==> (i + len) < sizeof(path_buf) */; 4474 path_buf[len + i - 1] = tstr[i];; 4475 }; 4476 /* buffer overrun is not possible here, since; 4477 * (i <= 32) && (len < sizeof(path_buf) - 32); 4478 * ==> (i + len) <= sizeof(path_buf) */; 4479 path_buf[len + i - 1] = 0;; 4480 ; 4481 if (mg_stat(conn, path_buf, &error_page_file.stat)) {; 4482 DEBUG_TRACE(""Check error page %s - found"",; ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:155810,Safety,timeout,timeout,155810,"00;; 5199 tv.tv_usec = (milliseconds % 1000) * 1000;; 5200 FD_ZERO(&rset);; 5201 FD_ZERO(&wset);; 5202 FD_ZERO(&eset);; 5203 ; 5204 for (i = 0; i < n; i++) {; 5205 if (pfd[i].events & (POLLIN | POLLOUT | POLLERR)) {; 5206 if (pfd[i].events & POLLIN) {; 5207 FD_SET(pfd[i].fd, &rset);; 5208 }; 5209 if (pfd[i].events & POLLOUT) {; 5210 FD_SET(pfd[i].fd, &wset);; 5211 }; 5212 /* Check for errors for any FD in the set */; 5213 FD_SET(pfd[i].fd, &eset);; 5214 }; 5215 pfd[i].revents = 0;; 5216 ; 5217 if (pfd[i].fd > maxfd) {; 5218 maxfd = pfd[i].fd;; 5219 }; 5220 }; 5221 ; 5222 if ((result = select((int)maxfd + 1, &rset, &wset, &eset, &tv)) > 0) {; 5223 for (i = 0; i < n; i++) {; 5224 if (FD_ISSET(pfd[i].fd, &rset)) {; 5225 pfd[i].revents |= POLLIN;; 5226 }; 5227 if (FD_ISSET(pfd[i].fd, &wset)) {; 5228 pfd[i].revents |= POLLOUT;; 5229 }; 5230 if (FD_ISSET(pfd[i].fd, &eset)) {; 5231 pfd[i].revents |= POLLERR;; 5232 }; 5233 }; 5234 }; 5235 ; 5236 /* We should subtract the time used in select from remaining; 5237 * ""milliseconds"", in particular if called from mg_poll with a; 5238 * timeout quantum.; 5239 * Unfortunately, the remaining time is not stored in ""tv"" in all; 5240 * implementations, so the result in ""tv"" must be considered undefined.; 5241 * See http://man7.org/linux/man-pages/man2/select.2.html */; 5242 ; 5243 return result;; 5244}; 5245#endif /* HAVE_POLL */; 5246 ; 5247 ; 5248#if defined(GCC_DIAGNOSTIC); 5249/* Enable unused function warning again */; 5250#pragma GCC diagnostic pop; 5251#endif; 5252 ; 5253 ; 5254static void; 5255set_close_on_exec(SOCKET sock,; 5256 const struct mg_connection *conn /* may be null */,; 5257 struct mg_context *ctx /* may be null */); 5258{; 5259 (void)conn; /* Unused. */; 5260 (void)ctx;; 5261 ; 5262 (void)SetHandleInformation((HANDLE)(intptr_t)sock, HANDLE_FLAG_INHERIT, 0);; 5263}; 5264 ; 5265 ; 5266int; 5267mg_start_thread(mg_thread_func_t f, void *p); 5268{; 5269#if defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1); 5270 /* Compile",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:159647,Safety,timeout,timeout,159647,"_t wbuf[UTF16_PATH_MAX];; 5344 (void)flags;; 5345 path_to_unicode(NULL, dll_name, wbuf, ARRAY_SIZE(wbuf));; 5346 return LoadLibraryW(wbuf);; 5347}; 5348 ; 5349 ; 5350FUNCTION_MAY_BE_UNUSED; 5351static int; 5352dlclose(void *handle); 5353{; 5354 int result;; 5355 ; 5356 if (FreeLibrary((HMODULE)handle) != 0) {; 5357 result = 0;; 5358 } else {; 5359 result = -1;; 5360 }; 5361 ; 5362 return result;; 5363}; 5364 ; 5365 ; 5366#if defined(GCC_DIAGNOSTIC); 5367/* Enable unused function warning again */; 5368#pragma GCC diagnostic pop; 5369#endif; 5370 ; 5371#endif; 5372 ; 5373 ; 5374#if !defined(NO_CGI); 5375#define SIGKILL (0); 5376 ; 5377 ; 5378static int; 5379kill(pid_t pid, int sig_num); 5380{; 5381 (void)TerminateProcess((HANDLE)pid, (UINT)sig_num);; 5382 (void)CloseHandle((HANDLE)pid);; 5383 return 0;; 5384}; 5385 ; 5386 ; 5387#if !defined(WNOHANG); 5388#define WNOHANG (1); 5389#endif; 5390 ; 5391 ; 5392static pid_t; 5393waitpid(pid_t pid, int *status, int flags); 5394{; 5395 DWORD timeout = INFINITE;; 5396 DWORD waitres;; 5397 ; 5398 (void)status; /* Currently not used by any client here */; 5399 ; 5400 if ((flags | WNOHANG) == WNOHANG) {; 5401 timeout = 0;; 5402 }; 5403 ; 5404 waitres = WaitForSingleObject((HANDLE)pid, timeout);; 5405 if (waitres == WAIT_OBJECT_0) {; 5406 return pid;; 5407 }; 5408 if (waitres == WAIT_TIMEOUT) {; 5409 return 0;; 5410 }; 5411 return (pid_t)-1;; 5412}; 5413 ; 5414 ; 5415static void; 5416trim_trailing_whitespaces(char *s); 5417{; 5418 char *e = s + strlen(s);; 5419 while ((e > s) && isspace((unsigned char)e[-1])) {; 5420 *(--e) = '\0';; 5421 }; 5422}; 5423 ; 5424 ; 5425static pid_t; 5426spawn_process(struct mg_connection *conn,; 5427 const char *prog,; 5428 char *envblk,; 5429 char *envp[],; 5430 int fdin[2],; 5431 int fdout[2],; 5432 int fderr[2],; 5433 const char *dir,; 5434 unsigned char cgi_config_idx); 5435{; 5436 HANDLE me;; 5437 char *interp;; 5438 char *interp_arg = 0;; 5439 char full_dir[UTF8_PATH_MAX], cmdline[UTF8_PATH_MAX],",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:159814,Safety,timeout,timeout,159814,"UNCTION_MAY_BE_UNUSED; 5351static int; 5352dlclose(void *handle); 5353{; 5354 int result;; 5355 ; 5356 if (FreeLibrary((HMODULE)handle) != 0) {; 5357 result = 0;; 5358 } else {; 5359 result = -1;; 5360 }; 5361 ; 5362 return result;; 5363}; 5364 ; 5365 ; 5366#if defined(GCC_DIAGNOSTIC); 5367/* Enable unused function warning again */; 5368#pragma GCC diagnostic pop; 5369#endif; 5370 ; 5371#endif; 5372 ; 5373 ; 5374#if !defined(NO_CGI); 5375#define SIGKILL (0); 5376 ; 5377 ; 5378static int; 5379kill(pid_t pid, int sig_num); 5380{; 5381 (void)TerminateProcess((HANDLE)pid, (UINT)sig_num);; 5382 (void)CloseHandle((HANDLE)pid);; 5383 return 0;; 5384}; 5385 ; 5386 ; 5387#if !defined(WNOHANG); 5388#define WNOHANG (1); 5389#endif; 5390 ; 5391 ; 5392static pid_t; 5393waitpid(pid_t pid, int *status, int flags); 5394{; 5395 DWORD timeout = INFINITE;; 5396 DWORD waitres;; 5397 ; 5398 (void)status; /* Currently not used by any client here */; 5399 ; 5400 if ((flags | WNOHANG) == WNOHANG) {; 5401 timeout = 0;; 5402 }; 5403 ; 5404 waitres = WaitForSingleObject((HANDLE)pid, timeout);; 5405 if (waitres == WAIT_OBJECT_0) {; 5406 return pid;; 5407 }; 5408 if (waitres == WAIT_TIMEOUT) {; 5409 return 0;; 5410 }; 5411 return (pid_t)-1;; 5412}; 5413 ; 5414 ; 5415static void; 5416trim_trailing_whitespaces(char *s); 5417{; 5418 char *e = s + strlen(s);; 5419 while ((e > s) && isspace((unsigned char)e[-1])) {; 5420 *(--e) = '\0';; 5421 }; 5422}; 5423 ; 5424 ; 5425static pid_t; 5426spawn_process(struct mg_connection *conn,; 5427 const char *prog,; 5428 char *envblk,; 5429 char *envp[],; 5430 int fdin[2],; 5431 int fdout[2],; 5432 int fderr[2],; 5433 const char *dir,; 5434 unsigned char cgi_config_idx); 5435{; 5436 HANDLE me;; 5437 char *interp;; 5438 char *interp_arg = 0;; 5439 char full_dir[UTF8_PATH_MAX], cmdline[UTF8_PATH_MAX], buf[UTF8_PATH_MAX];; 5440 int truncated;; 5441 struct mg_file file = STRUCT_FILE_INITIALIZER;; 5442 STARTUPINFOA si;; 5443 PROCESS_INFORMATION pi = {0};; 5444 ; 5445 ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:159891,Safety,timeout,timeout,159891,"le); 5353{; 5354 int result;; 5355 ; 5356 if (FreeLibrary((HMODULE)handle) != 0) {; 5357 result = 0;; 5358 } else {; 5359 result = -1;; 5360 }; 5361 ; 5362 return result;; 5363}; 5364 ; 5365 ; 5366#if defined(GCC_DIAGNOSTIC); 5367/* Enable unused function warning again */; 5368#pragma GCC diagnostic pop; 5369#endif; 5370 ; 5371#endif; 5372 ; 5373 ; 5374#if !defined(NO_CGI); 5375#define SIGKILL (0); 5376 ; 5377 ; 5378static int; 5379kill(pid_t pid, int sig_num); 5380{; 5381 (void)TerminateProcess((HANDLE)pid, (UINT)sig_num);; 5382 (void)CloseHandle((HANDLE)pid);; 5383 return 0;; 5384}; 5385 ; 5386 ; 5387#if !defined(WNOHANG); 5388#define WNOHANG (1); 5389#endif; 5390 ; 5391 ; 5392static pid_t; 5393waitpid(pid_t pid, int *status, int flags); 5394{; 5395 DWORD timeout = INFINITE;; 5396 DWORD waitres;; 5397 ; 5398 (void)status; /* Currently not used by any client here */; 5399 ; 5400 if ((flags | WNOHANG) == WNOHANG) {; 5401 timeout = 0;; 5402 }; 5403 ; 5404 waitres = WaitForSingleObject((HANDLE)pid, timeout);; 5405 if (waitres == WAIT_OBJECT_0) {; 5406 return pid;; 5407 }; 5408 if (waitres == WAIT_TIMEOUT) {; 5409 return 0;; 5410 }; 5411 return (pid_t)-1;; 5412}; 5413 ; 5414 ; 5415static void; 5416trim_trailing_whitespaces(char *s); 5417{; 5418 char *e = s + strlen(s);; 5419 while ((e > s) && isspace((unsigned char)e[-1])) {; 5420 *(--e) = '\0';; 5421 }; 5422}; 5423 ; 5424 ; 5425static pid_t; 5426spawn_process(struct mg_connection *conn,; 5427 const char *prog,; 5428 char *envblk,; 5429 char *envp[],; 5430 int fdin[2],; 5431 int fdout[2],; 5432 int fderr[2],; 5433 const char *dir,; 5434 unsigned char cgi_config_idx); 5435{; 5436 HANDLE me;; 5437 char *interp;; 5438 char *interp_arg = 0;; 5439 char full_dir[UTF8_PATH_MAX], cmdline[UTF8_PATH_MAX], buf[UTF8_PATH_MAX];; 5440 int truncated;; 5441 struct mg_file file = STRUCT_FILE_INITIALIZER;; 5442 STARTUPINFOA si;; 5443 PROCESS_INFORMATION pi = {0};; 5444 ; 5445 (void)envp;; 5446 ; 5447 memset(&si, 0, sizeof(si));; 5448 si.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:173700,Safety,timeout,timeout,173700,"84 ; 5885 if (lfsr == 0) {; 5886 /* lfsr will be only 0 if has not been initialized,; 5887 * so this code is called only once. */; 5888 lfsr = mg_get_current_time_ns();; 5889 lcg = mg_get_current_time_ns();; 5890 } else {; 5891 /* Get the next step of both random number generators. */; 5892 lfsr = (lfsr >> 1); 5893 | ((((lfsr >> 0) ^ (lfsr >> 1) ^ (lfsr >> 3) ^ (lfsr >> 4)) & 1); 5894 << 63);; 5895 lcg = lcg * 6364136223846793005LL + 1442695040888963407LL;; 5896 }; 5897 ; 5898 /* Combining two pseudo-random number generators and a high resolution; 5899 * part; 5900 * of the current server time will make it hard (impossible?) to guess; 5901 * the; 5902 * next number. */; 5903 return (lfsr ^ lcg ^ now);; 5904}; 5905 ; 5906 ; 5907static int; 5908mg_poll(struct mg_pollfd *pfd,; 5909 unsigned int n,; 5910 int milliseconds,; 5911 const stop_flag_t *stop_flag); 5912{; 5913 /* Call poll, but only for a maximum time of a few seconds.; 5914 * This will allow to stop the server after some seconds, instead; 5915 * of having to wait for a long socket timeout. */; 5916 int ms_now = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5917 ; 5918 int check_pollerr = 0;; 5919 if ((n == 1) && ((pfd[0].events & POLLERR) == 0)) {; 5920 /* If we wait for only one file descriptor, wait on error as well */; 5921 pfd[0].events |= POLLERR;; 5922 check_pollerr = 1;; 5923 }; 5924 ; 5925 do {; 5926 int result;; 5927 ; 5928 if (!STOP_FLAG_IS_ZERO(&*stop_flag)) {; 5929 /* Shut down signal */; 5930 return -2;; 5931 }; 5932 ; 5933 if ((milliseconds >= 0) && (milliseconds < ms_now)) {; 5934 ms_now = milliseconds;; 5935 }; 5936 ; 5937 result = poll(pfd, n, ms_now);; 5938 if (result != 0) {; 5939 /* Poll returned either success (1) or error (-1).; 5940 * Forward both to the caller. */; 5941 if ((check_pollerr); 5942 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5943 == POLLERR)) {; 5944 /* One and only file descriptor returned error */; 5945 return -1;; 5946 }; 5947 return result;; 5948 }; 5949",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:174671,Safety,timeout,timeout,174671,"seconds.; 5914 * This will allow to stop the server after some seconds, instead; 5915 * of having to wait for a long socket timeout. */; 5916 int ms_now = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5917 ; 5918 int check_pollerr = 0;; 5919 if ((n == 1) && ((pfd[0].events & POLLERR) == 0)) {; 5920 /* If we wait for only one file descriptor, wait on error as well */; 5921 pfd[0].events |= POLLERR;; 5922 check_pollerr = 1;; 5923 }; 5924 ; 5925 do {; 5926 int result;; 5927 ; 5928 if (!STOP_FLAG_IS_ZERO(&*stop_flag)) {; 5929 /* Shut down signal */; 5930 return -2;; 5931 }; 5932 ; 5933 if ((milliseconds >= 0) && (milliseconds < ms_now)) {; 5934 ms_now = milliseconds;; 5935 }; 5936 ; 5937 result = poll(pfd, n, ms_now);; 5938 if (result != 0) {; 5939 /* Poll returned either success (1) or error (-1).; 5940 * Forward both to the caller. */; 5941 if ((check_pollerr); 5942 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5943 == POLLERR)) {; 5944 /* One and only file descriptor returned error */; 5945 return -1;; 5946 }; 5947 return result;; 5948 }; 5949 ; 5950 /* Poll returned timeout (0). */; 5951 if (milliseconds > 0) {; 5952 milliseconds -= ms_now;; 5953 }; 5954 ; 5955 } while (milliseconds > 0);; 5956 ; 5957 /* timeout: return 0 */; 5958 return 0;; 5959}; 5960 ; 5961 ; 5962/* Write data to the IO channel - opened file descriptor, socket or SSL; 5963 * descriptor.; 5964 * Return value:; 5965 * >=0 .. number of bytes successfully written; 5966 * -1 .. timeout; 5967 * -2 .. error; 5968 */; 5969static int; 5970push_inner(struct mg_context *ctx,; 5971 FILE *fp,; 5972 SOCKET sock,; 5973 SSL *ssl,; 5974 const char *buf,; 5975 int len,; 5976 double timeout); 5977{; 5978 uint64_t start = 0, now = 0, timeout_ns = 0;; 5979 int n, err;; 5980 unsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5981 ; 5982#if defined(_WIN32); 5983 typedef int len_t;; 5984#else; 5985 typedef size_t len_t;; 5986#endif; 5987 ; 5988 if (timeout > 0) {; 5989 now = mg_get_current_",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:174812,Safety,timeout,timeout,174812,"f ((n == 1) && ((pfd[0].events & POLLERR) == 0)) {; 5920 /* If we wait for only one file descriptor, wait on error as well */; 5921 pfd[0].events |= POLLERR;; 5922 check_pollerr = 1;; 5923 }; 5924 ; 5925 do {; 5926 int result;; 5927 ; 5928 if (!STOP_FLAG_IS_ZERO(&*stop_flag)) {; 5929 /* Shut down signal */; 5930 return -2;; 5931 }; 5932 ; 5933 if ((milliseconds >= 0) && (milliseconds < ms_now)) {; 5934 ms_now = milliseconds;; 5935 }; 5936 ; 5937 result = poll(pfd, n, ms_now);; 5938 if (result != 0) {; 5939 /* Poll returned either success (1) or error (-1).; 5940 * Forward both to the caller. */; 5941 if ((check_pollerr); 5942 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5943 == POLLERR)) {; 5944 /* One and only file descriptor returned error */; 5945 return -1;; 5946 }; 5947 return result;; 5948 }; 5949 ; 5950 /* Poll returned timeout (0). */; 5951 if (milliseconds > 0) {; 5952 milliseconds -= ms_now;; 5953 }; 5954 ; 5955 } while (milliseconds > 0);; 5956 ; 5957 /* timeout: return 0 */; 5958 return 0;; 5959}; 5960 ; 5961 ; 5962/* Write data to the IO channel - opened file descriptor, socket or SSL; 5963 * descriptor.; 5964 * Return value:; 5965 * >=0 .. number of bytes successfully written; 5966 * -1 .. timeout; 5967 * -2 .. error; 5968 */; 5969static int; 5970push_inner(struct mg_context *ctx,; 5971 FILE *fp,; 5972 SOCKET sock,; 5973 SSL *ssl,; 5974 const char *buf,; 5975 int len,; 5976 double timeout); 5977{; 5978 uint64_t start = 0, now = 0, timeout_ns = 0;; 5979 int n, err;; 5980 unsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5981 ; 5982#if defined(_WIN32); 5983 typedef int len_t;; 5984#else; 5985 typedef size_t len_t;; 5986#endif; 5987 ; 5988 if (timeout > 0) {; 5989 now = mg_get_current_time_ns();; 5990 start = now;; 5991 timeout_ns = (uint64_t)(timeout * 1.0E9);; 5992 }; 5993 ; 5994 if (ctx == NULL) {; 5995 return -2;; 5996 }; 5997 ; 5998#if defined(NO_SSL) && !defined(USE_MBEDTLS); 5999 if (ssl) {; 6000 return -2;; 6001 }; 6002#",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:175055,Safety,timeout,timeout,175055,"if (!STOP_FLAG_IS_ZERO(&*stop_flag)) {; 5929 /* Shut down signal */; 5930 return -2;; 5931 }; 5932 ; 5933 if ((milliseconds >= 0) && (milliseconds < ms_now)) {; 5934 ms_now = milliseconds;; 5935 }; 5936 ; 5937 result = poll(pfd, n, ms_now);; 5938 if (result != 0) {; 5939 /* Poll returned either success (1) or error (-1).; 5940 * Forward both to the caller. */; 5941 if ((check_pollerr); 5942 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5943 == POLLERR)) {; 5944 /* One and only file descriptor returned error */; 5945 return -1;; 5946 }; 5947 return result;; 5948 }; 5949 ; 5950 /* Poll returned timeout (0). */; 5951 if (milliseconds > 0) {; 5952 milliseconds -= ms_now;; 5953 }; 5954 ; 5955 } while (milliseconds > 0);; 5956 ; 5957 /* timeout: return 0 */; 5958 return 0;; 5959}; 5960 ; 5961 ; 5962/* Write data to the IO channel - opened file descriptor, socket or SSL; 5963 * descriptor.; 5964 * Return value:; 5965 * >=0 .. number of bytes successfully written; 5966 * -1 .. timeout; 5967 * -2 .. error; 5968 */; 5969static int; 5970push_inner(struct mg_context *ctx,; 5971 FILE *fp,; 5972 SOCKET sock,; 5973 SSL *ssl,; 5974 const char *buf,; 5975 int len,; 5976 double timeout); 5977{; 5978 uint64_t start = 0, now = 0, timeout_ns = 0;; 5979 int n, err;; 5980 unsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5981 ; 5982#if defined(_WIN32); 5983 typedef int len_t;; 5984#else; 5985 typedef size_t len_t;; 5986#endif; 5987 ; 5988 if (timeout > 0) {; 5989 now = mg_get_current_time_ns();; 5990 start = now;; 5991 timeout_ns = (uint64_t)(timeout * 1.0E9);; 5992 }; 5993 ; 5994 if (ctx == NULL) {; 5995 return -2;; 5996 }; 5997 ; 5998#if defined(NO_SSL) && !defined(USE_MBEDTLS); 5999 if (ssl) {; 6000 return -2;; 6001 }; 6002#endif; 6003 ; 6004 /* Try to read until it succeeds, fails, times out, or the server; 6005 * shuts down. */; 6006 for (;;) {; 6007 ; 6008#if defined(USE_MBEDTLS); 6009 if (ssl != NULL) {; 6010 n = mbed_ssl_write(ssl, (const unsigned char *)",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:175250,Safety,timeout,timeout,175250,"ccess (1) or error (-1).; 5940 * Forward both to the caller. */; 5941 if ((check_pollerr); 5942 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5943 == POLLERR)) {; 5944 /* One and only file descriptor returned error */; 5945 return -1;; 5946 }; 5947 return result;; 5948 }; 5949 ; 5950 /* Poll returned timeout (0). */; 5951 if (milliseconds > 0) {; 5952 milliseconds -= ms_now;; 5953 }; 5954 ; 5955 } while (milliseconds > 0);; 5956 ; 5957 /* timeout: return 0 */; 5958 return 0;; 5959}; 5960 ; 5961 ; 5962/* Write data to the IO channel - opened file descriptor, socket or SSL; 5963 * descriptor.; 5964 * Return value:; 5965 * >=0 .. number of bytes successfully written; 5966 * -1 .. timeout; 5967 * -2 .. error; 5968 */; 5969static int; 5970push_inner(struct mg_context *ctx,; 5971 FILE *fp,; 5972 SOCKET sock,; 5973 SSL *ssl,; 5974 const char *buf,; 5975 int len,; 5976 double timeout); 5977{; 5978 uint64_t start = 0, now = 0, timeout_ns = 0;; 5979 int n, err;; 5980 unsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5981 ; 5982#if defined(_WIN32); 5983 typedef int len_t;; 5984#else; 5985 typedef size_t len_t;; 5986#endif; 5987 ; 5988 if (timeout > 0) {; 5989 now = mg_get_current_time_ns();; 5990 start = now;; 5991 timeout_ns = (uint64_t)(timeout * 1.0E9);; 5992 }; 5993 ; 5994 if (ctx == NULL) {; 5995 return -2;; 5996 }; 5997 ; 5998#if defined(NO_SSL) && !defined(USE_MBEDTLS); 5999 if (ssl) {; 6000 return -2;; 6001 }; 6002#endif; 6003 ; 6004 /* Try to read until it succeeds, fails, times out, or the server; 6005 * shuts down. */; 6006 for (;;) {; 6007 ; 6008#if defined(USE_MBEDTLS); 6009 if (ssl != NULL) {; 6010 n = mbed_ssl_write(ssl, (const unsigned char *)buf, len);; 6011 if (n <= 0) {; 6012 if ((n == MBEDTLS_ERR_SSL_WANT_READ); 6013 || (n == MBEDTLS_ERR_SSL_WANT_WRITE); 6014 || n == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6015 n = 0;; 6016 } else {; 6017 fprintf(stderr, ""SSL write failed, error %d\n"", n);; 6018 return -2;; 6019 }; 6020 } else {; 602",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:175535,Safety,timeout,timeout,175535,"ccess (1) or error (-1).; 5940 * Forward both to the caller. */; 5941 if ((check_pollerr); 5942 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5943 == POLLERR)) {; 5944 /* One and only file descriptor returned error */; 5945 return -1;; 5946 }; 5947 return result;; 5948 }; 5949 ; 5950 /* Poll returned timeout (0). */; 5951 if (milliseconds > 0) {; 5952 milliseconds -= ms_now;; 5953 }; 5954 ; 5955 } while (milliseconds > 0);; 5956 ; 5957 /* timeout: return 0 */; 5958 return 0;; 5959}; 5960 ; 5961 ; 5962/* Write data to the IO channel - opened file descriptor, socket or SSL; 5963 * descriptor.; 5964 * Return value:; 5965 * >=0 .. number of bytes successfully written; 5966 * -1 .. timeout; 5967 * -2 .. error; 5968 */; 5969static int; 5970push_inner(struct mg_context *ctx,; 5971 FILE *fp,; 5972 SOCKET sock,; 5973 SSL *ssl,; 5974 const char *buf,; 5975 int len,; 5976 double timeout); 5977{; 5978 uint64_t start = 0, now = 0, timeout_ns = 0;; 5979 int n, err;; 5980 unsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5981 ; 5982#if defined(_WIN32); 5983 typedef int len_t;; 5984#else; 5985 typedef size_t len_t;; 5986#endif; 5987 ; 5988 if (timeout > 0) {; 5989 now = mg_get_current_time_ns();; 5990 start = now;; 5991 timeout_ns = (uint64_t)(timeout * 1.0E9);; 5992 }; 5993 ; 5994 if (ctx == NULL) {; 5995 return -2;; 5996 }; 5997 ; 5998#if defined(NO_SSL) && !defined(USE_MBEDTLS); 5999 if (ssl) {; 6000 return -2;; 6001 }; 6002#endif; 6003 ; 6004 /* Try to read until it succeeds, fails, times out, or the server; 6005 * shuts down. */; 6006 for (;;) {; 6007 ; 6008#if defined(USE_MBEDTLS); 6009 if (ssl != NULL) {; 6010 n = mbed_ssl_write(ssl, (const unsigned char *)buf, len);; 6011 if (n <= 0) {; 6012 if ((n == MBEDTLS_ERR_SSL_WANT_READ); 6013 || (n == MBEDTLS_ERR_SSL_WANT_WRITE); 6014 || n == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6015 n = 0;; 6016 } else {; 6017 fprintf(stderr, ""SSL write failed, error %d\n"", n);; 6018 return -2;; 6019 }; 6020 } else {; 602",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:175637,Safety,timeout,timeout,175637,"ccess (1) or error (-1).; 5940 * Forward both to the caller. */; 5941 if ((check_pollerr); 5942 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5943 == POLLERR)) {; 5944 /* One and only file descriptor returned error */; 5945 return -1;; 5946 }; 5947 return result;; 5948 }; 5949 ; 5950 /* Poll returned timeout (0). */; 5951 if (milliseconds > 0) {; 5952 milliseconds -= ms_now;; 5953 }; 5954 ; 5955 } while (milliseconds > 0);; 5956 ; 5957 /* timeout: return 0 */; 5958 return 0;; 5959}; 5960 ; 5961 ; 5962/* Write data to the IO channel - opened file descriptor, socket or SSL; 5963 * descriptor.; 5964 * Return value:; 5965 * >=0 .. number of bytes successfully written; 5966 * -1 .. timeout; 5967 * -2 .. error; 5968 */; 5969static int; 5970push_inner(struct mg_context *ctx,; 5971 FILE *fp,; 5972 SOCKET sock,; 5973 SSL *ssl,; 5974 const char *buf,; 5975 int len,; 5976 double timeout); 5977{; 5978 uint64_t start = 0, now = 0, timeout_ns = 0;; 5979 int n, err;; 5980 unsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5981 ; 5982#if defined(_WIN32); 5983 typedef int len_t;; 5984#else; 5985 typedef size_t len_t;; 5986#endif; 5987 ; 5988 if (timeout > 0) {; 5989 now = mg_get_current_time_ns();; 5990 start = now;; 5991 timeout_ns = (uint64_t)(timeout * 1.0E9);; 5992 }; 5993 ; 5994 if (ctx == NULL) {; 5995 return -2;; 5996 }; 5997 ; 5998#if defined(NO_SSL) && !defined(USE_MBEDTLS); 5999 if (ssl) {; 6000 return -2;; 6001 }; 6002#endif; 6003 ; 6004 /* Try to read until it succeeds, fails, times out, or the server; 6005 * shuts down. */; 6006 for (;;) {; 6007 ; 6008#if defined(USE_MBEDTLS); 6009 if (ssl != NULL) {; 6010 n = mbed_ssl_write(ssl, (const unsigned char *)buf, len);; 6011 if (n <= 0) {; 6012 if ((n == MBEDTLS_ERR_SSL_WANT_READ); 6013 || (n == MBEDTLS_ERR_SSL_WANT_WRITE); 6014 || n == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6015 n = 0;; 6016 } else {; 6017 fprintf(stderr, ""SSL write failed, error %d\n"", n);; 6018 return -2;; 6019 }; 6020 } else {; 602",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:178204,Safety,timeout,timeout,178204,"059 if (err == WSAEWOULDBLOCK) {; 6060 err = 0;; 6061 n = 0;; 6062 }; 6063#else; 6064 if (ERROR_TRY_AGAIN(err)) {; 6065 err = 0;; 6066 n = 0;; 6067 }; 6068#endif; 6069 if (n < 0) {; 6070 /* shutdown of the socket at client side */; 6071 return -2;; 6072 }; 6073 }; 6074 ; 6075 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6076 return -2;; 6077 }; 6078 ; 6079 if ((n > 0) || ((n == 0) && (len == 0))) {; 6080 /* some data has been read, or no data was requested */; 6081 return n;; 6082 }; 6083 if (n < 0) {; 6084 /* socket error - check errno */; 6085 DEBUG_TRACE(""send() failed, error %d"", err);; 6086 ; 6087 /* TODO (mid): error handling depending on the error code.; 6088 * These codes are different between Windows and Linux.; 6089 * Currently there is no problem with failing send calls,; 6090 * if there is a reproducible situation, it should be; 6091 * investigated in detail.; 6092 */; 6093 return -2;; 6094 }; 6095 ; 6096 /* Only in case n=0 (timeout), repeat calling the write function */; 6097 ; 6098 /* If send failed, wait before retry */; 6099 if (fp != NULL) {; 6100 /* For files, just wait a fixed time.; 6101 * Maybe it helps, maybe not. */; 6102 mg_sleep(5);; 6103 } else {; 6104 /* For sockets, wait for the socket using poll */; 6105 struct mg_pollfd pfd[1];; 6106 int pollres;; 6107 ; 6108 pfd[0].fd = sock;; 6109 pfd[0].events = POLLOUT;; 6110 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6111 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6112 return -2;; 6113 }; 6114 if (pollres > 0) {; 6115 continue;; 6116 }; 6117 }; 6118 ; 6119 if (timeout > 0) {; 6120 now = mg_get_current_time_ns();; 6121 if ((now - start) > timeout_ns) {; 6122 /* Timeout */; 6123 break;; 6124 }; 6125 }; 6126 }; 6127 ; 6128 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6129 used */; 6130 ; 6131 return -1;; 6132}; 6133 ; 6134 ; 6135static int; 6136push_all(struct mg_context *ctx,; 6137 FILE *fp,; 6138 SOCKET sock,; 6139 SSL *ssl,; 6140 const char *buf,;",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:178828,Safety,timeout,timeout,178828,"fferent between Windows and Linux.; 6089 * Currently there is no problem with failing send calls,; 6090 * if there is a reproducible situation, it should be; 6091 * investigated in detail.; 6092 */; 6093 return -2;; 6094 }; 6095 ; 6096 /* Only in case n=0 (timeout), repeat calling the write function */; 6097 ; 6098 /* If send failed, wait before retry */; 6099 if (fp != NULL) {; 6100 /* For files, just wait a fixed time.; 6101 * Maybe it helps, maybe not. */; 6102 mg_sleep(5);; 6103 } else {; 6104 /* For sockets, wait for the socket using poll */; 6105 struct mg_pollfd pfd[1];; 6106 int pollres;; 6107 ; 6108 pfd[0].fd = sock;; 6109 pfd[0].events = POLLOUT;; 6110 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6111 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6112 return -2;; 6113 }; 6114 if (pollres > 0) {; 6115 continue;; 6116 }; 6117 }; 6118 ; 6119 if (timeout > 0) {; 6120 now = mg_get_current_time_ns();; 6121 if ((now - start) > timeout_ns) {; 6122 /* Timeout */; 6123 break;; 6124 }; 6125 }; 6126 }; 6127 ; 6128 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6129 used */; 6130 ; 6131 return -1;; 6132}; 6133 ; 6134 ; 6135static int; 6136push_all(struct mg_context *ctx,; 6137 FILE *fp,; 6138 SOCKET sock,; 6139 SSL *ssl,; 6140 const char *buf,; 6141 int len); 6142{; 6143 double timeout = -1.0;; 6144 int n, nwritten = 0;; 6145 ; 6146 if (ctx == NULL) {; 6147 return -1;; 6148 }; 6149 ; 6150 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6151 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6152 }; 6153 if (timeout <= 0.0) {; 6154 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6155 / 1000.0;; 6156 }; 6157 ; 6158 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6159 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6160 if (n < 0) {; 6161 if (nwritten == 0) {; 6162 nwritten = -1; /* Propagate the error */; 6163 }; 6164 break;; 6165 } else if (n == 0) {; 6166 break; /* No more ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:179288,Safety,timeout,timeout,179288,"fferent between Windows and Linux.; 6089 * Currently there is no problem with failing send calls,; 6090 * if there is a reproducible situation, it should be; 6091 * investigated in detail.; 6092 */; 6093 return -2;; 6094 }; 6095 ; 6096 /* Only in case n=0 (timeout), repeat calling the write function */; 6097 ; 6098 /* If send failed, wait before retry */; 6099 if (fp != NULL) {; 6100 /* For files, just wait a fixed time.; 6101 * Maybe it helps, maybe not. */; 6102 mg_sleep(5);; 6103 } else {; 6104 /* For sockets, wait for the socket using poll */; 6105 struct mg_pollfd pfd[1];; 6106 int pollres;; 6107 ; 6108 pfd[0].fd = sock;; 6109 pfd[0].events = POLLOUT;; 6110 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6111 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6112 return -2;; 6113 }; 6114 if (pollres > 0) {; 6115 continue;; 6116 }; 6117 }; 6118 ; 6119 if (timeout > 0) {; 6120 now = mg_get_current_time_ns();; 6121 if ((now - start) > timeout_ns) {; 6122 /* Timeout */; 6123 break;; 6124 }; 6125 }; 6126 }; 6127 ; 6128 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6129 used */; 6130 ; 6131 return -1;; 6132}; 6133 ; 6134 ; 6135static int; 6136push_all(struct mg_context *ctx,; 6137 FILE *fp,; 6138 SOCKET sock,; 6139 SSL *ssl,; 6140 const char *buf,; 6141 int len); 6142{; 6143 double timeout = -1.0;; 6144 int n, nwritten = 0;; 6145 ; 6146 if (ctx == NULL) {; 6147 return -1;; 6148 }; 6149 ; 6150 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6151 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6152 }; 6153 if (timeout <= 0.0) {; 6154 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6155 / 1000.0;; 6156 }; 6157 ; 6158 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6159 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6160 if (n < 0) {; 6161 if (nwritten == 0) {; 6162 nwritten = -1; /* Propagate the error */; 6163 }; 6164 break;; 6165 } else if (n == 0) {; 6166 break; /* No more ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:179446,Safety,timeout,timeout,179446," {; 6104 /* For sockets, wait for the socket using poll */; 6105 struct mg_pollfd pfd[1];; 6106 int pollres;; 6107 ; 6108 pfd[0].fd = sock;; 6109 pfd[0].events = POLLOUT;; 6110 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6111 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6112 return -2;; 6113 }; 6114 if (pollres > 0) {; 6115 continue;; 6116 }; 6117 }; 6118 ; 6119 if (timeout > 0) {; 6120 now = mg_get_current_time_ns();; 6121 if ((now - start) > timeout_ns) {; 6122 /* Timeout */; 6123 break;; 6124 }; 6125 }; 6126 }; 6127 ; 6128 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6129 used */; 6130 ; 6131 return -1;; 6132}; 6133 ; 6134 ; 6135static int; 6136push_all(struct mg_context *ctx,; 6137 FILE *fp,; 6138 SOCKET sock,; 6139 SSL *ssl,; 6140 const char *buf,; 6141 int len); 6142{; 6143 double timeout = -1.0;; 6144 int n, nwritten = 0;; 6145 ; 6146 if (ctx == NULL) {; 6147 return -1;; 6148 }; 6149 ; 6150 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6151 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6152 }; 6153 if (timeout <= 0.0) {; 6154 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6155 / 1000.0;; 6156 }; 6157 ; 6158 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6159 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6160 if (n < 0) {; 6161 if (nwritten == 0) {; 6162 nwritten = -1; /* Propagate the error */; 6163 }; 6164 break;; 6165 } else if (n == 0) {; 6166 break; /* No more data to write */; 6167 } else {; 6168 nwritten += n;; 6169 len -= n;; 6170 }; 6171 }; 6172 ; 6173 return nwritten;; 6174}; 6175 ; 6176 ; 6177/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6178 * Return value:; 6179 * >=0 .. number of bytes successfully read; 6180 * -1 .. timeout; 6181 * -2 .. error; 6182 */; 6183static int; 6184pull_inner(FILE *fp,; 6185 struct mg_connection *conn,; 6186 char *buf,; 6187 int len,; 6188 double timeout); 6189{; 6190 int nread,",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:179522,Safety,timeout,timeout,179522,"llfd pfd[1];; 6106 int pollres;; 6107 ; 6108 pfd[0].fd = sock;; 6109 pfd[0].events = POLLOUT;; 6110 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6111 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6112 return -2;; 6113 }; 6114 if (pollres > 0) {; 6115 continue;; 6116 }; 6117 }; 6118 ; 6119 if (timeout > 0) {; 6120 now = mg_get_current_time_ns();; 6121 if ((now - start) > timeout_ns) {; 6122 /* Timeout */; 6123 break;; 6124 }; 6125 }; 6126 }; 6127 ; 6128 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6129 used */; 6130 ; 6131 return -1;; 6132}; 6133 ; 6134 ; 6135static int; 6136push_all(struct mg_context *ctx,; 6137 FILE *fp,; 6138 SOCKET sock,; 6139 SSL *ssl,; 6140 const char *buf,; 6141 int len); 6142{; 6143 double timeout = -1.0;; 6144 int n, nwritten = 0;; 6145 ; 6146 if (ctx == NULL) {; 6147 return -1;; 6148 }; 6149 ; 6150 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6151 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6152 }; 6153 if (timeout <= 0.0) {; 6154 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6155 / 1000.0;; 6156 }; 6157 ; 6158 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6159 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6160 if (n < 0) {; 6161 if (nwritten == 0) {; 6162 nwritten = -1; /* Propagate the error */; 6163 }; 6164 break;; 6165 } else if (n == 0) {; 6166 break; /* No more data to write */; 6167 } else {; 6168 nwritten += n;; 6169 len -= n;; 6170 }; 6171 }; 6172 ; 6173 return nwritten;; 6174}; 6175 ; 6176 ; 6177/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6178 * Return value:; 6179 * >=0 .. number of bytes successfully read; 6180 * -1 .. timeout; 6181 * -2 .. error; 6182 */; 6183static int; 6184pull_inner(FILE *fp,; 6185 struct mg_connection *conn,; 6186 char *buf,; 6187 int len,; 6188 double timeout); 6189{; 6190 int nread, err = 0;; 6191 ; 6192#if defined(_WIN32); 6193 typedef int len_t;; 6194#else",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:179546,Safety,timeout,timeout,179546,"d[0].fd = sock;; 6109 pfd[0].events = POLLOUT;; 6110 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6111 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6112 return -2;; 6113 }; 6114 if (pollres > 0) {; 6115 continue;; 6116 }; 6117 }; 6118 ; 6119 if (timeout > 0) {; 6120 now = mg_get_current_time_ns();; 6121 if ((now - start) > timeout_ns) {; 6122 /* Timeout */; 6123 break;; 6124 }; 6125 }; 6126 }; 6127 ; 6128 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6129 used */; 6130 ; 6131 return -1;; 6132}; 6133 ; 6134 ; 6135static int; 6136push_all(struct mg_context *ctx,; 6137 FILE *fp,; 6138 SOCKET sock,; 6139 SSL *ssl,; 6140 const char *buf,; 6141 int len); 6142{; 6143 double timeout = -1.0;; 6144 int n, nwritten = 0;; 6145 ; 6146 if (ctx == NULL) {; 6147 return -1;; 6148 }; 6149 ; 6150 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6151 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6152 }; 6153 if (timeout <= 0.0) {; 6154 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6155 / 1000.0;; 6156 }; 6157 ; 6158 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6159 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6160 if (n < 0) {; 6161 if (nwritten == 0) {; 6162 nwritten = -1; /* Propagate the error */; 6163 }; 6164 break;; 6165 } else if (n == 0) {; 6166 break; /* No more data to write */; 6167 } else {; 6168 nwritten += n;; 6169 len -= n;; 6170 }; 6171 }; 6172 ; 6173 return nwritten;; 6174}; 6175 ; 6176 ; 6177/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6178 * Return value:; 6179 * >=0 .. number of bytes successfully read; 6180 * -1 .. timeout; 6181 * -2 .. error; 6182 */; 6183static int; 6184pull_inner(FILE *fp,; 6185 struct mg_connection *conn,; 6186 char *buf,; 6187 int len,; 6188 double timeout); 6189{; 6190 int nread, err = 0;; 6191 ; 6192#if defined(_WIN32); 6193 typedef int len_t;; 6194#else; 6195 typedef size_t len_t;; 6196#endif; 6197 ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:179773,Safety,timeout,timeout,179773," start) > timeout_ns) {; 6122 /* Timeout */; 6123 break;; 6124 }; 6125 }; 6126 }; 6127 ; 6128 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6129 used */; 6130 ; 6131 return -1;; 6132}; 6133 ; 6134 ; 6135static int; 6136push_all(struct mg_context *ctx,; 6137 FILE *fp,; 6138 SOCKET sock,; 6139 SSL *ssl,; 6140 const char *buf,; 6141 int len); 6142{; 6143 double timeout = -1.0;; 6144 int n, nwritten = 0;; 6145 ; 6146 if (ctx == NULL) {; 6147 return -1;; 6148 }; 6149 ; 6150 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6151 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6152 }; 6153 if (timeout <= 0.0) {; 6154 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6155 / 1000.0;; 6156 }; 6157 ; 6158 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6159 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6160 if (n < 0) {; 6161 if (nwritten == 0) {; 6162 nwritten = -1; /* Propagate the error */; 6163 }; 6164 break;; 6165 } else if (n == 0) {; 6166 break; /* No more data to write */; 6167 } else {; 6168 nwritten += n;; 6169 len -= n;; 6170 }; 6171 }; 6172 ; 6173 return nwritten;; 6174}; 6175 ; 6176 ; 6177/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6178 * Return value:; 6179 * >=0 .. number of bytes successfully read; 6180 * -1 .. timeout; 6181 * -2 .. error; 6182 */; 6183static int; 6184pull_inner(FILE *fp,; 6185 struct mg_connection *conn,; 6186 char *buf,; 6187 int len,; 6188 double timeout); 6189{; 6190 int nread, err = 0;; 6191 ; 6192#if defined(_WIN32); 6193 typedef int len_t;; 6194#else; 6195 typedef size_t len_t;; 6196#endif; 6197 ; 6198 /* We need an additional wait loop around this, because in some cases; 6199 * with TLSwe may get data from the socket but not from SSL_read.; 6200 * In this case we need to repeat at least once.; 6201 */; 6202 ; 6203 if (fp != NULL) {; 6204 /* Use read() instead of fread(), because if we're reading from the; 6205 * CGI pipe",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:180251,Safety,timeout,timeout,180251,"nt len); 6142{; 6143 double timeout = -1.0;; 6144 int n, nwritten = 0;; 6145 ; 6146 if (ctx == NULL) {; 6147 return -1;; 6148 }; 6149 ; 6150 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6151 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6152 }; 6153 if (timeout <= 0.0) {; 6154 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6155 / 1000.0;; 6156 }; 6157 ; 6158 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6159 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6160 if (n < 0) {; 6161 if (nwritten == 0) {; 6162 nwritten = -1; /* Propagate the error */; 6163 }; 6164 break;; 6165 } else if (n == 0) {; 6166 break; /* No more data to write */; 6167 } else {; 6168 nwritten += n;; 6169 len -= n;; 6170 }; 6171 }; 6172 ; 6173 return nwritten;; 6174}; 6175 ; 6176 ; 6177/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6178 * Return value:; 6179 * >=0 .. number of bytes successfully read; 6180 * -1 .. timeout; 6181 * -2 .. error; 6182 */; 6183static int; 6184pull_inner(FILE *fp,; 6185 struct mg_connection *conn,; 6186 char *buf,; 6187 int len,; 6188 double timeout); 6189{; 6190 int nread, err = 0;; 6191 ; 6192#if defined(_WIN32); 6193 typedef int len_t;; 6194#else; 6195 typedef size_t len_t;; 6196#endif; 6197 ; 6198 /* We need an additional wait loop around this, because in some cases; 6199 * with TLSwe may get data from the socket but not from SSL_read.; 6200 * In this case we need to repeat at least once.; 6201 */; 6202 ; 6203 if (fp != NULL) {; 6204 /* Use read() instead of fread(), because if we're reading from the; 6205 * CGI pipe, fread() may block until IO buffer is filled up. We; 6206 * cannot afford to block and must pass all read bytes immediately; 6207 * to the client. */; 6208 nread = (int)read(fileno(fp), buf, (size_t)len);; 6209 ; 6210 err = (nread < 0) ? ERRNO : 0;; 6211 if ((nread == 0) && (len > 0)) {; 6212 /* Should get data, but got EOL */; 6213 return -2;; 6214 }; 6215 ; 6",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:180409,Safety,timeout,timeout,180409,") / 1000.0;; 6152 }; 6153 if (timeout <= 0.0) {; 6154 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6155 / 1000.0;; 6156 }; 6157 ; 6158 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6159 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6160 if (n < 0) {; 6161 if (nwritten == 0) {; 6162 nwritten = -1; /* Propagate the error */; 6163 }; 6164 break;; 6165 } else if (n == 0) {; 6166 break; /* No more data to write */; 6167 } else {; 6168 nwritten += n;; 6169 len -= n;; 6170 }; 6171 }; 6172 ; 6173 return nwritten;; 6174}; 6175 ; 6176 ; 6177/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6178 * Return value:; 6179 * >=0 .. number of bytes successfully read; 6180 * -1 .. timeout; 6181 * -2 .. error; 6182 */; 6183static int; 6184pull_inner(FILE *fp,; 6185 struct mg_connection *conn,; 6186 char *buf,; 6187 int len,; 6188 double timeout); 6189{; 6190 int nread, err = 0;; 6191 ; 6192#if defined(_WIN32); 6193 typedef int len_t;; 6194#else; 6195 typedef size_t len_t;; 6196#endif; 6197 ; 6198 /* We need an additional wait loop around this, because in some cases; 6199 * with TLSwe may get data from the socket but not from SSL_read.; 6200 * In this case we need to repeat at least once.; 6201 */; 6202 ; 6203 if (fp != NULL) {; 6204 /* Use read() instead of fread(), because if we're reading from the; 6205 * CGI pipe, fread() may block until IO buffer is filled up. We; 6206 * cannot afford to block and must pass all read bytes immediately; 6207 * to the client. */; 6208 nread = (int)read(fileno(fp), buf, (size_t)len);; 6209 ; 6210 err = (nread < 0) ? ERRNO : 0;; 6211 if ((nread == 0) && (len > 0)) {; 6212 /* Should get data, but got EOL */; 6213 return -2;; 6214 }; 6215 ; 6216#if defined(USE_MBEDTLS); 6217 } else if (conn->ssl != NULL) {; 6218 struct mg_pollfd pfd[1];; 6219 int to_read;; 6220 int pollres;; 6221 ; 6222 to_read = mbedtls_ssl_get_bytes_avail(conn->ssl);; 6223 ; 6224 if (to_read > 0) {; ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:181901,Safety,timeout,timeout,181901," we're reading from the; 6205 * CGI pipe, fread() may block until IO buffer is filled up. We; 6206 * cannot afford to block and must pass all read bytes immediately; 6207 * to the client. */; 6208 nread = (int)read(fileno(fp), buf, (size_t)len);; 6209 ; 6210 err = (nread < 0) ? ERRNO : 0;; 6211 if ((nread == 0) && (len > 0)) {; 6212 /* Should get data, but got EOL */; 6213 return -2;; 6214 }; 6215 ; 6216#if defined(USE_MBEDTLS); 6217 } else if (conn->ssl != NULL) {; 6218 struct mg_pollfd pfd[1];; 6219 int to_read;; 6220 int pollres;; 6221 ; 6222 to_read = mbedtls_ssl_get_bytes_avail(conn->ssl);; 6223 ; 6224 if (to_read > 0) {; 6225 /* We already know there is no more data buffered in conn->buf; 6226 * but there is more available in the SSL layer. So don't poll; 6227 * conn->client.sock yet. */; 6228 ; 6229 pollres = 1;; 6230 if (to_read > len); 6231 to_read = len;; 6232 } else {; 6233 pfd[0].fd = conn->client.sock;; 6234 pfd[0].events = POLLIN;; 6235 ; 6236 to_read = len;; 6237 ; 6238 pollres = mg_poll(pfd,; 6239 1,; 6240 (int)(timeout * 1000.0),; 6241 &(conn->phys_ctx->stop_flag));; 6242 ; 6243 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6244 return -2;; 6245 }; 6246 }; 6247 ; 6248 if (pollres > 0) {; 6249 nread = mbed_ssl_read(conn->ssl, (unsigned char *)buf, to_read);; 6250 if (nread <= 0) {; 6251 if ((nread == MBEDTLS_ERR_SSL_WANT_READ); 6252 || (nread == MBEDTLS_ERR_SSL_WANT_WRITE); 6253 || nread == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6254 nread = 0;; 6255 } else {; 6256 fprintf(stderr, ""SSL read failed, error %d\n"", nread);; 6257 return -2;; 6258 }; 6259 } else {; 6260 err = 0;; 6261 }; 6262 ; 6263 } else if (pollres < 0) {; 6264 /* Error */; 6265 return -2;; 6266 } else {; 6267 /* pollres = 0 means timeout */; 6268 nread = 0;; 6269 }; 6270 ; 6271#elif !defined(NO_SSL); 6272 } else if (conn->ssl != NULL) {; 6273 int ssl_pending;; 6274 struct mg_pollfd pfd[1];; 6275 int pollres;; 6276 ; 6277 if ((ssl_pending = SSL_pending(conn->ssl)) > 0) {; 6278 /*",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:182605,Safety,timeout,timeout,182605,"il(conn->ssl);; 6223 ; 6224 if (to_read > 0) {; 6225 /* We already know there is no more data buffered in conn->buf; 6226 * but there is more available in the SSL layer. So don't poll; 6227 * conn->client.sock yet. */; 6228 ; 6229 pollres = 1;; 6230 if (to_read > len); 6231 to_read = len;; 6232 } else {; 6233 pfd[0].fd = conn->client.sock;; 6234 pfd[0].events = POLLIN;; 6235 ; 6236 to_read = len;; 6237 ; 6238 pollres = mg_poll(pfd,; 6239 1,; 6240 (int)(timeout * 1000.0),; 6241 &(conn->phys_ctx->stop_flag));; 6242 ; 6243 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6244 return -2;; 6245 }; 6246 }; 6247 ; 6248 if (pollres > 0) {; 6249 nread = mbed_ssl_read(conn->ssl, (unsigned char *)buf, to_read);; 6250 if (nread <= 0) {; 6251 if ((nread == MBEDTLS_ERR_SSL_WANT_READ); 6252 || (nread == MBEDTLS_ERR_SSL_WANT_WRITE); 6253 || nread == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6254 nread = 0;; 6255 } else {; 6256 fprintf(stderr, ""SSL read failed, error %d\n"", nread);; 6257 return -2;; 6258 }; 6259 } else {; 6260 err = 0;; 6261 }; 6262 ; 6263 } else if (pollres < 0) {; 6264 /* Error */; 6265 return -2;; 6266 } else {; 6267 /* pollres = 0 means timeout */; 6268 nread = 0;; 6269 }; 6270 ; 6271#elif !defined(NO_SSL); 6272 } else if (conn->ssl != NULL) {; 6273 int ssl_pending;; 6274 struct mg_pollfd pfd[1];; 6275 int pollres;; 6276 ; 6277 if ((ssl_pending = SSL_pending(conn->ssl)) > 0) {; 6278 /* We already know there is no more data buffered in conn->buf; 6279 * but there is more available in the SSL layer. So don't poll; 6280 * conn->client.sock yet. */; 6281 if (ssl_pending > len) {; 6282 ssl_pending = len;; 6283 }; 6284 pollres = 1;; 6285 } else {; 6286 pfd[0].fd = conn->client.sock;; 6287 pfd[0].events = POLLIN;; 6288 pollres = mg_poll(pfd,; 6289 1,; 6290 (int)(timeout * 1000.0),; 6291 &(conn->phys_ctx->stop_flag));; 6292 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6293 return -2;; 6294 }; 6295 }; 6296 if (pollres > 0) {; 6297 ERR_clear_error();; 6298 nre",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:183236,Safety,timeout,timeout,183236,"S_ERR_SSL_WANT_READ); 6252 || (nread == MBEDTLS_ERR_SSL_WANT_WRITE); 6253 || nread == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6254 nread = 0;; 6255 } else {; 6256 fprintf(stderr, ""SSL read failed, error %d\n"", nread);; 6257 return -2;; 6258 }; 6259 } else {; 6260 err = 0;; 6261 }; 6262 ; 6263 } else if (pollres < 0) {; 6264 /* Error */; 6265 return -2;; 6266 } else {; 6267 /* pollres = 0 means timeout */; 6268 nread = 0;; 6269 }; 6270 ; 6271#elif !defined(NO_SSL); 6272 } else if (conn->ssl != NULL) {; 6273 int ssl_pending;; 6274 struct mg_pollfd pfd[1];; 6275 int pollres;; 6276 ; 6277 if ((ssl_pending = SSL_pending(conn->ssl)) > 0) {; 6278 /* We already know there is no more data buffered in conn->buf; 6279 * but there is more available in the SSL layer. So don't poll; 6280 * conn->client.sock yet. */; 6281 if (ssl_pending > len) {; 6282 ssl_pending = len;; 6283 }; 6284 pollres = 1;; 6285 } else {; 6286 pfd[0].fd = conn->client.sock;; 6287 pfd[0].events = POLLIN;; 6288 pollres = mg_poll(pfd,; 6289 1,; 6290 (int)(timeout * 1000.0),; 6291 &(conn->phys_ctx->stop_flag));; 6292 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6293 return -2;; 6294 }; 6295 }; 6296 if (pollres > 0) {; 6297 ERR_clear_error();; 6298 nread =; 6299 SSL_read(conn->ssl, buf, (ssl_pending > 0) ? ssl_pending : len);; 6300 if (nread <= 0) {; 6301 err = SSL_get_error(conn->ssl, nread);; 6302 if ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {; 6303 err = ERRNO;; 6304 } else if ((err == SSL_ERROR_WANT_READ); 6305 || (err == SSL_ERROR_WANT_WRITE)) {; 6306 nread = 0;; 6307 } else {; 6308 /* All errors should return -2 */; 6309 DEBUG_TRACE(""SSL_read() failed, error %d"", err);; 6310 ERR_clear_error();; 6311 return -2;; 6312 }; 6313 ERR_clear_error();; 6314 } else {; 6315 err = 0;; 6316 }; 6317 } else if (pollres < 0) {; 6318 /* Error */; 6319 return -2;; 6320 } else {; 6321 /* pollres = 0 means timeout */; 6322 nread = 0;; 6323 }; 6324#endif; 6325 ; 6326 } else {; 6327 struct mg_pollfd pfd[1];; 6328 i",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:184102,Safety,timeout,timeout,184102,"uct mg_pollfd pfd[1];; 6275 int pollres;; 6276 ; 6277 if ((ssl_pending = SSL_pending(conn->ssl)) > 0) {; 6278 /* We already know there is no more data buffered in conn->buf; 6279 * but there is more available in the SSL layer. So don't poll; 6280 * conn->client.sock yet. */; 6281 if (ssl_pending > len) {; 6282 ssl_pending = len;; 6283 }; 6284 pollres = 1;; 6285 } else {; 6286 pfd[0].fd = conn->client.sock;; 6287 pfd[0].events = POLLIN;; 6288 pollres = mg_poll(pfd,; 6289 1,; 6290 (int)(timeout * 1000.0),; 6291 &(conn->phys_ctx->stop_flag));; 6292 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6293 return -2;; 6294 }; 6295 }; 6296 if (pollres > 0) {; 6297 ERR_clear_error();; 6298 nread =; 6299 SSL_read(conn->ssl, buf, (ssl_pending > 0) ? ssl_pending : len);; 6300 if (nread <= 0) {; 6301 err = SSL_get_error(conn->ssl, nread);; 6302 if ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {; 6303 err = ERRNO;; 6304 } else if ((err == SSL_ERROR_WANT_READ); 6305 || (err == SSL_ERROR_WANT_WRITE)) {; 6306 nread = 0;; 6307 } else {; 6308 /* All errors should return -2 */; 6309 DEBUG_TRACE(""SSL_read() failed, error %d"", err);; 6310 ERR_clear_error();; 6311 return -2;; 6312 }; 6313 ERR_clear_error();; 6314 } else {; 6315 err = 0;; 6316 }; 6317 } else if (pollres < 0) {; 6318 /* Error */; 6319 return -2;; 6320 } else {; 6321 /* pollres = 0 means timeout */; 6322 nread = 0;; 6323 }; 6324#endif; 6325 ; 6326 } else {; 6327 struct mg_pollfd pfd[1];; 6328 int pollres;; 6329 ; 6330 pfd[0].fd = conn->client.sock;; 6331 pfd[0].events = POLLIN;; 6332 pollres = mg_poll(pfd,; 6333 1,; 6334 (int)(timeout * 1000.0),; 6335 &(conn->phys_ctx->stop_flag));; 6336 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6337 return -2;; 6338 }; 6339 if (pollres > 0) {; 6340 nread = (int)recv(conn->client.sock, buf, (len_t)len, 0);; 6341 err = (nread < 0) ? ERRNO : 0;; 6342 if (nread <= 0) {; 6343 /* shutdown of the socket at client side */; 6344 return -2;; 6345 }; 6346 } else if (pollres < 0) {; 63",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:184346,Safety,timeout,timeout,184346,"(&conn->phys_ctx->stop_flag)) {; 6293 return -2;; 6294 }; 6295 }; 6296 if (pollres > 0) {; 6297 ERR_clear_error();; 6298 nread =; 6299 SSL_read(conn->ssl, buf, (ssl_pending > 0) ? ssl_pending : len);; 6300 if (nread <= 0) {; 6301 err = SSL_get_error(conn->ssl, nread);; 6302 if ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {; 6303 err = ERRNO;; 6304 } else if ((err == SSL_ERROR_WANT_READ); 6305 || (err == SSL_ERROR_WANT_WRITE)) {; 6306 nread = 0;; 6307 } else {; 6308 /* All errors should return -2 */; 6309 DEBUG_TRACE(""SSL_read() failed, error %d"", err);; 6310 ERR_clear_error();; 6311 return -2;; 6312 }; 6313 ERR_clear_error();; 6314 } else {; 6315 err = 0;; 6316 }; 6317 } else if (pollres < 0) {; 6318 /* Error */; 6319 return -2;; 6320 } else {; 6321 /* pollres = 0 means timeout */; 6322 nread = 0;; 6323 }; 6324#endif; 6325 ; 6326 } else {; 6327 struct mg_pollfd pfd[1];; 6328 int pollres;; 6329 ; 6330 pfd[0].fd = conn->client.sock;; 6331 pfd[0].events = POLLIN;; 6332 pollres = mg_poll(pfd,; 6333 1,; 6334 (int)(timeout * 1000.0),; 6335 &(conn->phys_ctx->stop_flag));; 6336 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6337 return -2;; 6338 }; 6339 if (pollres > 0) {; 6340 nread = (int)recv(conn->client.sock, buf, (len_t)len, 0);; 6341 err = (nread < 0) ? ERRNO : 0;; 6342 if (nread <= 0) {; 6343 /* shutdown of the socket at client side */; 6344 return -2;; 6345 }; 6346 } else if (pollres < 0) {; 6347 /* error callint poll */; 6348 return -2;; 6349 } else {; 6350 /* pollres = 0 means timeout */; 6351 nread = 0;; 6352 }; 6353 }; 6354 ; 6355 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6356 return -2;; 6357 }; 6358 ; 6359 if ((nread > 0) || ((nread == 0) && (len == 0))) {; 6360 /* some data has been read, or no data was requested */; 6361 return nread;; 6362 }; 6363 ; 6364 if (nread < 0) {; 6365 /* socket error - check errno */; 6366#if defined(_WIN32); 6367 if (err == WSAEWOULDBLOCK) {; 6368 /* TODO (low): check if this is still required */; 6369 /* st",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:184834,Safety,timeout,timeout,184834,"pollres = 0 means timeout */; 6322 nread = 0;; 6323 }; 6324#endif; 6325 ; 6326 } else {; 6327 struct mg_pollfd pfd[1];; 6328 int pollres;; 6329 ; 6330 pfd[0].fd = conn->client.sock;; 6331 pfd[0].events = POLLIN;; 6332 pollres = mg_poll(pfd,; 6333 1,; 6334 (int)(timeout * 1000.0),; 6335 &(conn->phys_ctx->stop_flag));; 6336 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6337 return -2;; 6338 }; 6339 if (pollres > 0) {; 6340 nread = (int)recv(conn->client.sock, buf, (len_t)len, 0);; 6341 err = (nread < 0) ? ERRNO : 0;; 6342 if (nread <= 0) {; 6343 /* shutdown of the socket at client side */; 6344 return -2;; 6345 }; 6346 } else if (pollres < 0) {; 6347 /* error callint poll */; 6348 return -2;; 6349 } else {; 6350 /* pollres = 0 means timeout */; 6351 nread = 0;; 6352 }; 6353 }; 6354 ; 6355 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6356 return -2;; 6357 }; 6358 ; 6359 if ((nread > 0) || ((nread == 0) && (len == 0))) {; 6360 /* some data has been read, or no data was requested */; 6361 return nread;; 6362 }; 6363 ; 6364 if (nread < 0) {; 6365 /* socket error - check errno */; 6366#if defined(_WIN32); 6367 if (err == WSAEWOULDBLOCK) {; 6368 /* TODO (low): check if this is still required */; 6369 /* standard case if called from close_socket_gracefully */; 6370 return -2;; 6371 } else if (err == WSAETIMEDOUT) {; 6372 /* TODO (low): check if this is still required */; 6373 /* timeout is handled by the while loop */; 6374 return 0;; 6375 } else if (err == WSAECONNABORTED) {; 6376 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6377 return -2;; 6378 } else {; 6379 DEBUG_TRACE(""recv() failed, error %d"", err);; 6380 return -2;; 6381 }; 6382#else; 6383 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6384 * if the timeout is reached and if the socket was set to non-; 6385 * blocking in close_socket_gracefully, so we can not distinguish; 6386 * here. We have to wait for the timeout in both cases for now.; 6387 */; 6388 if (ERROR_TRY_AGAIN",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:185496,Safety,timeout,timeout,185496,"pollres = 0 means timeout */; 6322 nread = 0;; 6323 }; 6324#endif; 6325 ; 6326 } else {; 6327 struct mg_pollfd pfd[1];; 6328 int pollres;; 6329 ; 6330 pfd[0].fd = conn->client.sock;; 6331 pfd[0].events = POLLIN;; 6332 pollres = mg_poll(pfd,; 6333 1,; 6334 (int)(timeout * 1000.0),; 6335 &(conn->phys_ctx->stop_flag));; 6336 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6337 return -2;; 6338 }; 6339 if (pollres > 0) {; 6340 nread = (int)recv(conn->client.sock, buf, (len_t)len, 0);; 6341 err = (nread < 0) ? ERRNO : 0;; 6342 if (nread <= 0) {; 6343 /* shutdown of the socket at client side */; 6344 return -2;; 6345 }; 6346 } else if (pollres < 0) {; 6347 /* error callint poll */; 6348 return -2;; 6349 } else {; 6350 /* pollres = 0 means timeout */; 6351 nread = 0;; 6352 }; 6353 }; 6354 ; 6355 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6356 return -2;; 6357 }; 6358 ; 6359 if ((nread > 0) || ((nread == 0) && (len == 0))) {; 6360 /* some data has been read, or no data was requested */; 6361 return nread;; 6362 }; 6363 ; 6364 if (nread < 0) {; 6365 /* socket error - check errno */; 6366#if defined(_WIN32); 6367 if (err == WSAEWOULDBLOCK) {; 6368 /* TODO (low): check if this is still required */; 6369 /* standard case if called from close_socket_gracefully */; 6370 return -2;; 6371 } else if (err == WSAETIMEDOUT) {; 6372 /* TODO (low): check if this is still required */; 6373 /* timeout is handled by the while loop */; 6374 return 0;; 6375 } else if (err == WSAECONNABORTED) {; 6376 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6377 return -2;; 6378 } else {; 6379 DEBUG_TRACE(""recv() failed, error %d"", err);; 6380 return -2;; 6381 }; 6382#else; 6383 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6384 * if the timeout is reached and if the socket was set to non-; 6385 * blocking in close_socket_gracefully, so we can not distinguish; 6386 * here. We have to wait for the timeout in both cases for now.; 6387 */; 6388 if (ERROR_TRY_AGAIN",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:185858,Safety,timeout,timeout,185858,"lres = 0 means timeout */; 6351 nread = 0;; 6352 }; 6353 }; 6354 ; 6355 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6356 return -2;; 6357 }; 6358 ; 6359 if ((nread > 0) || ((nread == 0) && (len == 0))) {; 6360 /* some data has been read, or no data was requested */; 6361 return nread;; 6362 }; 6363 ; 6364 if (nread < 0) {; 6365 /* socket error - check errno */; 6366#if defined(_WIN32); 6367 if (err == WSAEWOULDBLOCK) {; 6368 /* TODO (low): check if this is still required */; 6369 /* standard case if called from close_socket_gracefully */; 6370 return -2;; 6371 } else if (err == WSAETIMEDOUT) {; 6372 /* TODO (low): check if this is still required */; 6373 /* timeout is handled by the while loop */; 6374 return 0;; 6375 } else if (err == WSAECONNABORTED) {; 6376 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6377 return -2;; 6378 } else {; 6379 DEBUG_TRACE(""recv() failed, error %d"", err);; 6380 return -2;; 6381 }; 6382#else; 6383 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6384 * if the timeout is reached and if the socket was set to non-; 6385 * blocking in close_socket_gracefully, so we can not distinguish; 6386 * here. We have to wait for the timeout in both cases for now.; 6387 */; 6388 if (ERROR_TRY_AGAIN(err)) {; 6389 /* TODO (low): check if this is still required */; 6390 /* EAGAIN/EWOULDBLOCK:; 6391 * standard case if called from close_socket_gracefully; 6392 * => should return -1 */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:186020,Safety,timeout,timeout,186020,"n == 0))) {; 6360 /* some data has been read, or no data was requested */; 6361 return nread;; 6362 }; 6363 ; 6364 if (nread < 0) {; 6365 /* socket error - check errno */; 6366#if defined(_WIN32); 6367 if (err == WSAEWOULDBLOCK) {; 6368 /* TODO (low): check if this is still required */; 6369 /* standard case if called from close_socket_gracefully */; 6370 return -2;; 6371 } else if (err == WSAETIMEDOUT) {; 6372 /* TODO (low): check if this is still required */; 6373 /* timeout is handled by the while loop */; 6374 return 0;; 6375 } else if (err == WSAECONNABORTED) {; 6376 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6377 return -2;; 6378 } else {; 6379 DEBUG_TRACE(""recv() failed, error %d"", err);; 6380 return -2;; 6381 }; 6382#else; 6383 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6384 * if the timeout is reached and if the socket was set to non-; 6385 * blocking in close_socket_gracefully, so we can not distinguish; 6386 * here. We have to wait for the timeout in both cases for now.; 6387 */; 6388 if (ERROR_TRY_AGAIN(err)) {; 6389 /* TODO (low): check if this is still required */; 6390 /* EAGAIN/EWOULDBLOCK:; 6391 * standard case if called from close_socket_gracefully; 6392 * => should return -1 */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:186283,Safety,timeout,timeout,186283,"f this is still required */; 6369 /* standard case if called from close_socket_gracefully */; 6370 return -2;; 6371 } else if (err == WSAETIMEDOUT) {; 6372 /* TODO (low): check if this is still required */; 6373 /* timeout is handled by the while loop */; 6374 return 0;; 6375 } else if (err == WSAECONNABORTED) {; 6376 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6377 return -2;; 6378 } else {; 6379 DEBUG_TRACE(""recv() failed, error %d"", err);; 6380 return -2;; 6381 }; 6382#else; 6383 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6384 * if the timeout is reached and if the socket was set to non-; 6385 * blocking in close_socket_gracefully, so we can not distinguish; 6386 * here. We have to wait for the timeout in both cases for now.; 6387 */; 6388 if (ERROR_TRY_AGAIN(err)) {; 6389 /* TODO (low): check if this is still required */; 6390 /* EAGAIN/EWOULDBLOCK:; 6391 * standard case if called from close_socket_gracefully; 6392 * => should return -1 */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6420 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6421 }; 6422 if (timeout <= 0.0) {; 6423 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6424 / 1000.0;; 6425 }; 6426 start_time = mg_get_current_time_ns();; 6427 t",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:186409,Safety,timeout,timeout,186409,"f this is still required */; 6369 /* standard case if called from close_socket_gracefully */; 6370 return -2;; 6371 } else if (err == WSAETIMEDOUT) {; 6372 /* TODO (low): check if this is still required */; 6373 /* timeout is handled by the while loop */; 6374 return 0;; 6375 } else if (err == WSAECONNABORTED) {; 6376 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6377 return -2;; 6378 } else {; 6379 DEBUG_TRACE(""recv() failed, error %d"", err);; 6380 return -2;; 6381 }; 6382#else; 6383 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6384 * if the timeout is reached and if the socket was set to non-; 6385 * blocking in close_socket_gracefully, so we can not distinguish; 6386 * here. We have to wait for the timeout in both cases for now.; 6387 */; 6388 if (ERROR_TRY_AGAIN(err)) {; 6389 /* TODO (low): check if this is still required */; 6390 /* EAGAIN/EWOULDBLOCK:; 6391 * standard case if called from close_socket_gracefully; 6392 * => should return -1 */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6420 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6421 }; 6422 if (timeout <= 0.0) {; 6423 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6424 / 1000.0;; 6425 }; 6426 start_time = mg_get_current_time_ns();; 6427 t",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:186891,Safety,timeout,timeout,186891,"IN or EWOULDBLOCK in both cases,; 6384 * if the timeout is reached and if the socket was set to non-; 6385 * blocking in close_socket_gracefully, so we can not distinguish; 6386 * here. We have to wait for the timeout in both cases for now.; 6387 */; 6388 if (ERROR_TRY_AGAIN(err)) {; 6389 /* TODO (low): check if this is still required */; 6390 /* EAGAIN/EWOULDBLOCK:; 6391 * standard case if called from close_socket_gracefully; 6392 * => should return -1 */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6420 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6421 }; 6422 if (timeout <= 0.0) {; 6423 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6424 / 1000.0;; 6425 }; 6426 start_time = mg_get_current_time_ns();; 6427 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6428 ; 6429 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6430 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6431 if (n == -2) {; 6432 if (nread == 0) {; 6433 nread = -1; /* Propagate the error */; 6434 }; 6435 break;; 6436 } else if (n == -1) {; 6437 /* timeout */; 6438 if (timeout >= 0.0) {; 6439 now = mg_get_current_time_ns();; 6440 if ((now - start_time) <= timeout_ns) {; 6441 continue;; 6442 }; 6443 }; 6444 break;; 6445 } else if (n == 0) {; 6446 ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:187028,Safety,timeout,timeout,187028,"e have to wait for the timeout in both cases for now.; 6387 */; 6388 if (ERROR_TRY_AGAIN(err)) {; 6389 /* TODO (low): check if this is still required */; 6390 /* EAGAIN/EWOULDBLOCK:; 6391 * standard case if called from close_socket_gracefully; 6392 * => should return -1 */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6420 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6421 }; 6422 if (timeout <= 0.0) {; 6423 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6424 / 1000.0;; 6425 }; 6426 start_time = mg_get_current_time_ns();; 6427 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6428 ; 6429 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6430 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6431 if (n == -2) {; 6432 if (nread == 0) {; 6433 nread = -1; /* Propagate the error */; 6434 }; 6435 break;; 6436 } else if (n == -1) {; 6437 /* timeout */; 6438 if (timeout >= 0.0) {; 6439 now = mg_get_current_time_ns();; 6440 if ((now - start_time) <= timeout_ns) {; 6441 continue;; 6442 }; 6443 }; 6444 break;; 6445 } else if (n == 0) {; 6446 break; /* No more data to read */; 6447 } else {; 6448 nread += n;; 6449 len -= n;; 6450 }; 6451 }; 6452 ; 6453 return nread;; 6454}; 6455 ; 6456 ; 6457static void; 6458discard_unread_re",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:187111,Safety,timeout,timeout,187111," (low): check if this is still required */; 6390 /* EAGAIN/EWOULDBLOCK:; 6391 * standard case if called from close_socket_gracefully; 6392 * => should return -1 */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6420 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6421 }; 6422 if (timeout <= 0.0) {; 6423 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6424 / 1000.0;; 6425 }; 6426 start_time = mg_get_current_time_ns();; 6427 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6428 ; 6429 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6430 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6431 if (n == -2) {; 6432 if (nread == 0) {; 6433 nread = -1; /* Propagate the error */; 6434 }; 6435 break;; 6436 } else if (n == -1) {; 6437 /* timeout */; 6438 if (timeout >= 0.0) {; 6439 now = mg_get_current_time_ns();; 6440 if ((now - start_time) <= timeout_ns) {; 6441 continue;; 6442 }; 6443 }; 6444 break;; 6445 } else if (n == 0) {; 6446 break; /* No more data to read */; 6447 } else {; 6448 nread += n;; 6449 len -= n;; 6450 }; 6451 }; 6452 ; 6453 return nread;; 6454}; 6455 ; 6456 ; 6457static void; 6458discard_unread_request_data(struct mg_connection *conn); 6459{; 6460 char buf[MG_BUF_LEN];; 6461 ; 6462 while (mg_read(conn, bu",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:187135,Safety,timeout,timeout,187135,"0 /* EAGAIN/EWOULDBLOCK:; 6391 * standard case if called from close_socket_gracefully; 6392 * => should return -1 */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6420 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6421 }; 6422 if (timeout <= 0.0) {; 6423 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6424 / 1000.0;; 6425 }; 6426 start_time = mg_get_current_time_ns();; 6427 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6428 ; 6429 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6430 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6431 if (n == -2) {; 6432 if (nread == 0) {; 6433 nread = -1; /* Propagate the error */; 6434 }; 6435 break;; 6436 } else if (n == -1) {; 6437 /* timeout */; 6438 if (timeout >= 0.0) {; 6439 now = mg_get_current_time_ns();; 6440 if ((now - start_time) <= timeout_ns) {; 6441 continue;; 6442 }; 6443 }; 6444 break;; 6445 } else if (n == 0) {; 6446 break; /* No more data to read */; 6447 } else {; 6448 nread += n;; 6449 len -= n;; 6450 }; 6451 }; 6452 ; 6453 return nread;; 6454}; 6455 ; 6456 ; 6457static void; 6458discard_unread_request_data(struct mg_connection *conn); 6459{; 6460 char buf[MG_BUF_LEN];; 6461 ; 6462 while (mg_read(conn, buf, sizeof(buf)) > 0); 6463 ;; 6464}; 6465 ; 646",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:187304,Safety,timeout,timeout,187304," */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6420 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6421 }; 6422 if (timeout <= 0.0) {; 6423 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6424 / 1000.0;; 6425 }; 6426 start_time = mg_get_current_time_ns();; 6427 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6428 ; 6429 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6430 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6431 if (n == -2) {; 6432 if (nread == 0) {; 6433 nread = -1; /* Propagate the error */; 6434 }; 6435 break;; 6436 } else if (n == -1) {; 6437 /* timeout */; 6438 if (timeout >= 0.0) {; 6439 now = mg_get_current_time_ns();; 6440 if ((now - start_time) <= timeout_ns) {; 6441 continue;; 6442 }; 6443 }; 6444 break;; 6445 } else if (n == 0) {; 6446 break; /* No more data to read */; 6447 } else {; 6448 nread += n;; 6449 len -= n;; 6450 }; 6451 }; 6452 ; 6453 return nread;; 6454}; 6455 ; 6456 ; 6457static void; 6458discard_unread_request_data(struct mg_connection *conn); 6459{; 6460 char buf[MG_BUF_LEN];; 6461 ; 6462 while (mg_read(conn, buf, sizeof(buf)) > 0); 6463 ;; 6464}; 6465 ; 6466 ; 6467static int; 6468mg_read_inner(struct mg_connection *conn, void *buf, size_t len); 6469{; 6470 int64_t con",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:187453,Safety,timeout,timeout,187453,"signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6420 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6421 }; 6422 if (timeout <= 0.0) {; 6423 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6424 / 1000.0;; 6425 }; 6426 start_time = mg_get_current_time_ns();; 6427 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6428 ; 6429 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6430 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6431 if (n == -2) {; 6432 if (nread == 0) {; 6433 nread = -1; /* Propagate the error */; 6434 }; 6435 break;; 6436 } else if (n == -1) {; 6437 /* timeout */; 6438 if (timeout >= 0.0) {; 6439 now = mg_get_current_time_ns();; 6440 if ((now - start_time) <= timeout_ns) {; 6441 continue;; 6442 }; 6443 }; 6444 break;; 6445 } else if (n == 0) {; 6446 break; /* No more data to read */; 6447 } else {; 6448 nread += n;; 6449 len -= n;; 6450 }; 6451 }; 6452 ; 6453 return nread;; 6454}; 6455 ; 6456 ; 6457static void; 6458discard_unread_request_data(struct mg_connection *conn); 6459{; 6460 char buf[MG_BUF_LEN];; 6461 ; 6462 while (mg_read(conn, buf, sizeof(buf)) > 0); 6463 ;; 6464}; 6465 ; 6466 ; 6467static int; 6468mg_read_inner(struct mg_connection *conn, void *buf, size_t len); 6469{; 6470 int64_t content_len, n, buffered_len, nread;; 6471 int64_t len64 =; 6472 (int64_t)((len > INT_MAX) ? INT_MAX : len); /* since the return value is; 6473 * int, we may not read more; 6474 * bytes */; 6475 const char *body;; 64",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:187610,Safety,timeout,timeout,187610,"signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6420 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6421 }; 6422 if (timeout <= 0.0) {; 6423 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6424 / 1000.0;; 6425 }; 6426 start_time = mg_get_current_time_ns();; 6427 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6428 ; 6429 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6430 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6431 if (n == -2) {; 6432 if (nread == 0) {; 6433 nread = -1; /* Propagate the error */; 6434 }; 6435 break;; 6436 } else if (n == -1) {; 6437 /* timeout */; 6438 if (timeout >= 0.0) {; 6439 now = mg_get_current_time_ns();; 6440 if ((now - start_time) <= timeout_ns) {; 6441 continue;; 6442 }; 6443 }; 6444 break;; 6445 } else if (n == 0) {; 6446 break; /* No more data to read */; 6447 } else {; 6448 nread += n;; 6449 len -= n;; 6450 }; 6451 }; 6452 ; 6453 return nread;; 6454}; 6455 ; 6456 ; 6457static void; 6458discard_unread_request_data(struct mg_connection *conn); 6459{; 6460 char buf[MG_BUF_LEN];; 6461 ; 6462 while (mg_read(conn, buf, sizeof(buf)) > 0); 6463 ;; 6464}; 6465 ; 6466 ; 6467static int; 6468mg_read_inner(struct mg_connection *conn, void *buf, size_t len); 6469{; 6470 int64_t content_len, n, buffered_len, nread;; 6471 int64_t len64 =; 6472 (int64_t)((len > INT_MAX) ? INT_MAX : len); /* since the return value is; 6473 * int, we may not read more; 6474 * bytes */; 6475 const char *body;; 64",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:187631,Safety,timeout,timeout,187631,"signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6420 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6421 }; 6422 if (timeout <= 0.0) {; 6423 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6424 / 1000.0;; 6425 }; 6426 start_time = mg_get_current_time_ns();; 6427 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6428 ; 6429 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6430 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6431 if (n == -2) {; 6432 if (nread == 0) {; 6433 nread = -1; /* Propagate the error */; 6434 }; 6435 break;; 6436 } else if (n == -1) {; 6437 /* timeout */; 6438 if (timeout >= 0.0) {; 6439 now = mg_get_current_time_ns();; 6440 if ((now - start_time) <= timeout_ns) {; 6441 continue;; 6442 }; 6443 }; 6444 break;; 6445 } else if (n == 0) {; 6446 break; /* No more data to read */; 6447 } else {; 6448 nread += n;; 6449 len -= n;; 6450 }; 6451 }; 6452 ; 6453 return nread;; 6454}; 6455 ; 6456 ; 6457static void; 6458discard_unread_request_data(struct mg_connection *conn); 6459{; 6460 char buf[MG_BUF_LEN];; 6461 ; 6462 while (mg_read(conn, buf, sizeof(buf)) > 0); 6463 ;; 6464}; 6465 ; 6466 ; 6467static int; 6468mg_read_inner(struct mg_connection *conn, void *buf, size_t len); 6469{; 6470 int64_t content_len, n, buffered_len, nread;; 6471 int64_t len64 =; 6472 (int64_t)((len > INT_MAX) ? INT_MAX : len); /* since the return value is; 6473 * int, we may not read more; 6474 * bytes */; 6475 const char *body;; 64",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:224434,Safety,abort,abort,224434,"d(NO_FILES) */; 7735 return;; 7736 ; 7737#if !defined(NO_FILES); 7738/* Reset all outputs */; 7739interpret_cleanup:; 7740 memset(filestat, 0, sizeof(*filestat));; 7741 *filename = 0;; 7742 *is_found = 0;; 7743 *is_script_resource = 0;; 7744 *is_websocket_request = 0;; 7745 *is_put_or_delete_request = 0;; 7746#endif /* !defined(NO_FILES) */; 7747}; 7748 ; 7749 ; 7750/* Check whether full request is buffered. Return:; 7751 * -1 if request or response is malformed; 7752 * 0 if request or response is not yet fully buffered; 7753 * >0 actual request length, including last \r\n\r\n */; 7754static int; 7755get_http_header_len(const char *buf, int buflen); 7756{; 7757 int i;; 7758 for (i = 0; i < buflen; i++) {; 7759 /* Do an unsigned comparison in some conditions below */; 7760 const unsigned char c = (unsigned char)buf[i];; 7761 ; 7762 if ((c < 128) && ((char)c != '\r') && ((char)c != '\n'); 7763 && !isprint(c)) {; 7764 /* abort scan as soon as one malformed character is found */; 7765 return -1;; 7766 }; 7767 ; 7768 if (i < buflen - 1) {; 7769 if ((buf[i] == '\n') && (buf[i + 1] == '\n')) {; 7770 /* Two newline, no carriage return - not standard compliant,; 7771 * but it should be accepted */; 7772 return i + 2;; 7773 }; 7774 }; 7775 ; 7776 if (i < buflen - 3) {; 7777 if ((buf[i] == '\r') && (buf[i + 1] == '\n') && (buf[i + 2] == '\r'); 7778 && (buf[i + 3] == '\n')) {; 7779 /* Two \r\n - standard compliant */; 7780 return i + 4;; 7781 }; 7782 }; 7783 }; 7784 ; 7785 return 0;; 7786}; 7787 ; 7788 ; 7789#if !defined(NO_CACHING); 7790/* Convert month to the month number. Return -1 on error, or month number */; 7791static int; 7792get_month_index(const char *s); 7793{; 7794 size_t i;; 7795 ; 7796 for (i = 0; i < ARRAY_SIZE(month_names); i++) {; 7797 if (!strcmp(s, month_names[i])) {; 7798 return (int)i;; 7799 }; 7800 }; 7801 ; 7802 return -1;; 7803}; 7804 ; 7805 ; 7806/* Parse UTC date-time string, and return the corresponding time_t value. */; 7807static time_t; 7808parse_d",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:263940,Safety,timeout,timeout,263940,"uncation check for ebuf */; 9137 ebuf,; 9138 ebuf_len,; 9139 ""socket(): %s"",; 9140 strerror(ERRNO));; 9141 return 0;; 9142 }; 9143 ; 9144 if (0 != set_non_blocking_mode(*sock)) {; 9145 mg_snprintf(NULL,; 9146 NULL, /* No truncation check for ebuf */; 9147 ebuf,; 9148 ebuf_len,; 9149 ""Cannot set socket to non-blocking: %s"",; 9150 strerror(ERRNO));; 9151 closesocket(*sock);; 9152 *sock = INVALID_SOCKET;; 9153 return 0;; 9154 }; 9155 ; 9156 set_close_on_exec(*sock, NULL, ctx);; 9157 ; 9158 if (ip_ver == 4) {; 9159 /* connected with IPv4 */; 9160 conn_ret = connect(*sock,; 9161 (struct sockaddr *)((void *)&sa->sin),; 9162 sizeof(sa->sin));; 9163 }; 9164#if defined(USE_IPV6); 9165 else if (ip_ver == 6) {; 9166 /* connected with IPv6 */; 9167 conn_ret = connect(*sock,; 9168 (struct sockaddr *)((void *)&sa->sin6),; 9169 sizeof(sa->sin6));; 9170 }; 9171#endif; 9172#if defined(USE_X_DOM_SOCKET); 9173 else if (ip_ver == -99) {; 9174 /* connected to domain socket */; 9175 conn_ret = connect(*sock,; 9176 (struct sockaddr *)((void *)&sa->sun),; 9177 sizeof(sa->sun));; 9178 }; 9179#endif; 9180 ; 9181 if (conn_ret != 0) {; 9182 sockerr = ERRNO;; 9183 }; 9184 ; 9185#if defined(_WIN32); 9186 if ((conn_ret != 0) && (sockerr == WSAEWOULDBLOCK)) {; 9187#else; 9188 if ((conn_ret != 0) && (sockerr == EINPROGRESS)) {; 9189#endif; 9190 /* Data for getsockopt */; 9191 void *psockerr = &sockerr;; 9192 int ret;; 9193 ; 9194#if defined(_WIN32); 9195 int len = (int)sizeof(sockerr);; 9196#else; 9197 socklen_t len = (socklen_t)sizeof(sockerr);; 9198#endif; 9199 ; 9200 /* Data for poll */; 9201 struct mg_pollfd pfd[1];; 9202 int pollres;; 9203 int ms_wait = 10000; /* 10 second timeout */; 9204 stop_flag_t nonstop;; 9205 STOP_FLAG_ASSIGN(&nonstop, 0);; 9206 ; 9207 /* For a non-blocking socket, the connect sequence is:; 9208 * 1) call connect (will not block); 9209 * 2) wait until the socket is ready for writing (select or poll); 9210 * 3) check connection state with getsockopt; 9211 */; 9212 pfd[0].",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:264569,Safety,timeout,timeout,264569,"fd[1];; 9202 int pollres;; 9203 int ms_wait = 10000; /* 10 second timeout */; 9204 stop_flag_t nonstop;; 9205 STOP_FLAG_ASSIGN(&nonstop, 0);; 9206 ; 9207 /* For a non-blocking socket, the connect sequence is:; 9208 * 1) call connect (will not block); 9209 * 2) wait until the socket is ready for writing (select or poll); 9210 * 3) check connection state with getsockopt; 9211 */; 9212 pfd[0].fd = *sock;; 9213 pfd[0].events = POLLOUT;; 9214 pollres = mg_poll(pfd, 1, ms_wait, ctx ? &(ctx->stop_flag) : &nonstop);; 9215 ; 9216 if (pollres != 1) {; 9217 /* Not connected */; 9218 mg_snprintf(NULL,; 9219 NULL, /* No truncation check for ebuf */; 9220 ebuf,; 9221 ebuf_len,; 9222 ""connect(%s:%d): timeout"",; 9223 host,; 9224 port);; 9225 closesocket(*sock);; 9226 *sock = INVALID_SOCKET;; 9227 return 0;; 9228 }; 9229 ; 9230#if defined(_WIN32); 9231 ret = getsockopt(*sock, SOL_SOCKET, SO_ERROR, (char *)psockerr, &len);; 9232#else; 9233 ret = getsockopt(*sock, SOL_SOCKET, SO_ERROR, psockerr, &len);; 9234#endif; 9235 ; 9236 if ((ret == 0) && (sockerr == 0)) {; 9237 conn_ret = 0;; 9238 }; 9239 }; 9240 ; 9241 if (conn_ret != 0) {; 9242 /* Not connected */; 9243 mg_snprintf(NULL,; 9244 NULL, /* No truncation check for ebuf */; 9245 ebuf,; 9246 ebuf_len,; 9247 ""connect(%s:%d): error %s"",; 9248 host,; 9249 port,; 9250 strerror(sockerr));; 9251 closesocket(*sock);; 9252 *sock = INVALID_SOCKET;; 9253 return 0;; 9254 }; 9255 ; 9256 return 1;; 9257}; 9258 ; 9259 ; 9260int; 9261mg_url_encode(const char *src, char *dst, size_t dst_len); 9262{; 9263 static const char *dont_escape = ""._-$,;~()"";; 9264 static const char *hex = ""0123456789abcdef"";; 9265 char *pos = dst;; 9266 const char *end = dst + dst_len - 1;; 9267 ; 9268 for (; ((*src != '\0') && (pos < end)); src++, pos++) {; 9269 if (isalnum((unsigned char)*src); 9270 || (strchr(dont_escape, *src) != NULL)) {; 9271 *pos = *src;; 9272 } else if (pos + 2 < end) {; 9273 pos[0] = '%';; 9274 pos[1] = hex[(unsigned char)*src >> 4];; 9275 pos[2] = ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:302358,Safety,safe,safe,302358,"safe;; 10502 int is_idempotent;; 10503 int is_cacheable;; 10504};; 10505 ; 10506 ; 10507/* https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods */; 10508static const struct mg_http_method_info http_methods[] = {; 10509 /* HTTP (RFC 2616) */; 10510 {""GET"", 0, 1, 1, 1, 1},; 10511 {""POST"", 1, 1, 0, 0, 0},; 10512 {""PUT"", 1, 0, 0, 1, 0},; 10513 {""DELETE"", 0, 0, 0, 1, 0},; 10514 {""HEAD"", 0, 0, 1, 1, 1},; 10515 {""OPTIONS"", 0, 0, 1, 1, 0},; 10516 {""CONNECT"", 1, 1, 0, 0, 0},; 10517 /* TRACE method (RFC 2616) is not supported for security reasons */; 10518 ; 10519 /* PATCH method (RFC 5789) */; 10520 {""PATCH"", 1, 0, 0, 0, 0},; 10521 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10522 ; 10523 /* WEBDAV (RFC 2518) */; 10524 {""PROPFIND"", 0, 1, 1, 1, 0},; 10525 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10526 * Some PROPFIND results MAY be cached, with care,; 10527 * as there is no cache validation mechanism for; 10528 * most properties. This method is both safe and; 10529 * idempotent (see Section 9.1 of [RFC2616]). */; 10530 {""MKCOL"", 0, 0, 0, 1, 0},; 10531 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10532 * When MKCOL is invoked without a request body,; 10533 * the newly created collection SHOULD have no; 10534 * members. A MKCOL request message may contain; 10535 * a message body. The precise behavior of a MKCOL; 10536 * request when the body is present is undefined,; 10537 * ... ==> We do not support MKCOL with body data.; 10538 * This method is idempotent, but not safe (see; 10539 * Section 9.1 of [RFC2616]). Responses to this; 10540 * method MUST NOT be cached. */; 10541 ; 10542 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10543 {""LOCK"", 1, 1, 0, 0, 0},; 10544 {""UNLOCK"", 1, 0, 0, 0, 0},; 10545 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10546 ; 10547 /* Unsupported WEBDAV Methods: */; 10548 /* COPY, MOVE (RFC 2518) */; 10549 /* + 11 methods from RFC 3253 */; 10550 /* ORDERPATCH (RFC 3648) */; 10551 /* ACL (RFC 3744) */; 10552 /* SEA",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:302888,Safety,safe,safe,302888,"s not supported for security reasons */; 10518 ; 10519 /* PATCH method (RFC 5789) */; 10520 {""PATCH"", 1, 0, 0, 0, 0},; 10521 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10522 ; 10523 /* WEBDAV (RFC 2518) */; 10524 {""PROPFIND"", 0, 1, 1, 1, 0},; 10525 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10526 * Some PROPFIND results MAY be cached, with care,; 10527 * as there is no cache validation mechanism for; 10528 * most properties. This method is both safe and; 10529 * idempotent (see Section 9.1 of [RFC2616]). */; 10530 {""MKCOL"", 0, 0, 0, 1, 0},; 10531 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10532 * When MKCOL is invoked without a request body,; 10533 * the newly created collection SHOULD have no; 10534 * members. A MKCOL request message may contain; 10535 * a message body. The precise behavior of a MKCOL; 10536 * request when the body is present is undefined,; 10537 * ... ==> We do not support MKCOL with body data.; 10538 * This method is idempotent, but not safe (see; 10539 * Section 9.1 of [RFC2616]). Responses to this; 10540 * method MUST NOT be cached. */; 10541 ; 10542 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10543 {""LOCK"", 1, 1, 0, 0, 0},; 10544 {""UNLOCK"", 1, 0, 0, 0, 0},; 10545 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10546 ; 10547 /* Unsupported WEBDAV Methods: */; 10548 /* COPY, MOVE (RFC 2518) */; 10549 /* + 11 methods from RFC 3253 */; 10550 /* ORDERPATCH (RFC 3648) */; 10551 /* ACL (RFC 3744) */; 10552 /* SEARCH (RFC 5323) */; 10553 /* + MicroSoft extensions; 10554 * https://msdn.microsoft.com/en-us/library/aa142917.aspx */; 10555 ; 10556 /* REPORT method (RFC 3253) */; 10557 {""REPORT"", 1, 1, 1, 1, 1},; 10558 /* REPORT method only allowed for CGI/Lua/LSP and callbacks. */; 10559 /* It was defined for WEBDAV in RFC 3253, Sec. 3.6; 10560 * (https://tools.ietf.org/html/rfc3253#section-3.6), but seems; 10561 * to be useful for REST in case a ""GET request with body"" is; 10562 * required. */; 10563 ; 10564 {NULL, 0",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:326602,Safety,timeout,timeout,326602," /* Wait until process is terminated (don't leave zombies) */; 11260 while (waitpid(proc->pid, &status, 0) != (pid_t)-1) /* nop */; 11261 ;; 11262 } else {; 11263 DEBUG_TRACE(""CGI timer: Child process %d already stopped\n"", proc->pid);; 11264 }; 11265 /* Dec reference counter */; 11266 refs = mg_atomic_dec(&proc->references);; 11267 if (refs == 0) {; 11268 /* no more references - free data */; 11269 mg_free(data);; 11270 }; 11271 ; 11272 return 0;; 11273}; 11274 ; 11275 ; 11276/* Local (static) function assumes all arguments are valid. */; 11277static void; 11278handle_cgi_request(struct mg_connection *conn,; 11279 const char *prog,; 11280 unsigned char cgi_config_idx); 11281{; 11282 char *buf;; 11283 size_t buflen;; 11284 int headers_len, data_len, i, truncated;; 11285 int fdin[2] = {-1, -1}, fdout[2] = {-1, -1}, fderr[2] = {-1, -1};; 11286 const char *status, *status_text, *connection_state;; 11287 char *pbuf, dir[UTF8_PATH_MAX], *p;; 11288 struct mg_request_info ri;; 11289 struct cgi_environment blk;; 11290 FILE *in = NULL, *out = NULL, *err = NULL;; 11291 struct mg_file fout = STRUCT_FILE_INITIALIZER;; 11292 pid_t pid = (pid_t)-1;; 11293 struct process_control_data *proc = NULL;; 11294 ; 11295#if defined(USE_TIMERS); 11296 double cgi_timeout;; 11297 if (conn->dom_ctx->config[CGI_TIMEOUT + cgi_config_idx]) {; 11298 /* Get timeout in seconds */; 11299 cgi_timeout =; 11300 atof(conn->dom_ctx->config[CGI_TIMEOUT + cgi_config_idx]) * 0.001;; 11301 } else {; 11302 cgi_timeout =; 11303 atof(config_options[REQUEST_TIMEOUT].default_value) * 0.001;; 11304 }; 11305 ; 11306#endif; 11307 ; 11308 buf = NULL;; 11309 buflen = conn->phys_ctx->max_request_size;; 11310 i = prepare_cgi_environment(conn, prog, &blk, cgi_config_idx);; 11311 if (i != 0) {; 11312 blk.buf = NULL;; 11313 blk.var = NULL;; 11314 goto done;; 11315 }; 11316 ; 11317 /* CGI must be executed in its own directory. 'dir' must point to the; 11318 * directory containing executable program, 'p' must point to the; 11",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:333011,Safety,abort,abort,333011,"n, buf, (int)buflen);; 11472 if (i > 0) {; 11473 /* CGI program explicitly sent an error */; 11474 /* Write the error message to the internal log */; 11475 mg_cry_internal(conn,; 11476 ""Error: CGI program \""%s\"" sent error ""; 11477 ""message: [%.*s]"",; 11478 prog,; 11479 i,; 11480 buf);; 11481 /* Don't send the error message back to the client */; 11482 mg_send_http_error(conn,; 11483 500,; 11484 ""Error: CGI program \""%s\"" failed."",; 11485 prog);; 11486 } else {; 11487 /* CGI program did not explicitly send an error, but a broken; 11488 * respon header */; 11489 mg_cry_internal(conn,; 11490 ""Error: CGI program sent malformed or too big ""; 11491 ""(>%u bytes) HTTP headers: [%.*s]"",; 11492 (unsigned)buflen,; 11493 data_len,; 11494 buf);; 11495 ; 11496 mg_send_http_error(conn,; 11497 500,; 11498 ""Error: CGI program sent malformed or too big ""; 11499 ""(>%u bytes) HTTP headers: [%.*s]"",; 11500 (unsigned)buflen,; 11501 data_len,; 11502 buf);; 11503 }; 11504 ; 11505 /* in both cases, abort processing CGI */; 11506 goto done;; 11507 }; 11508 ; 11509 pbuf = buf;; 11510 buf[headers_len - 1] = '\0';; 11511 ri.num_headers = parse_http_headers(&pbuf, ri.http_headers);; 11512 ; 11513 /* Make up and send the status line */; 11514 status_text = ""OK"";; 11515 if ((status = get_header(ri.http_headers, ri.num_headers, ""Status"")); 11516 != NULL) {; 11517 conn->status_code = atoi(status);; 11518 status_text = status;; 11519 while (isdigit((unsigned char)*status_text) || *status_text == ' ') {; 11520 status_text++;; 11521 }; 11522 } else if (get_header(ri.http_headers, ri.num_headers, ""Location""); 11523 != NULL) {; 11524 conn->status_code = 307;; 11525 } else {; 11526 conn->status_code = 200;; 11527 }; 11528 connection_state =; 11529 get_header(ri.http_headers, ri.num_headers, ""Connection"");; 11530 if (!header_has_option(connection_state, ""keep-alive"")) {; 11531 conn->must_close = 1;; 11532 }; 11533 ; 11534 DEBUG_TRACE(""CGI: response %u %s"", conn->status_code, status_text);; 11535 ; 11536 (v",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:343697,Safety,safe,safe,343697,"; 11825 mg_send_http_error(; 11826 conn,; 11827 403,; 11828 ""Error: Delete not possible\nDeleting %s is not allowed"",; 11829 path);; 11830 return;; 11831 }; 11832 ; 11833 /* Try to delete it. */; 11834 if (mg_remove(conn, path) == 0) {; 11835 /* Delete was successful: Return 204 without content. */; 11836 mg_response_header_start(conn, 204);; 11837 send_no_cache_header(conn);; 11838 send_additional_header(conn);; 11839 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11840 mg_response_header_send(conn);; 11841 ; 11842 } else {; 11843 /* Delete not successful (file locked). */; 11844 mg_send_http_error(conn,; 11845 423,; 11846 ""Error: Cannot delete file\nremove(%s): %s"",; 11847 path,; 11848 strerror(ERRNO));; 11849 }; 11850}; 11851#endif /* !NO_FILES */; 11852 ; 11853 ; 11854#if !defined(NO_FILESYSTEMS); 11855static void; 11856send_ssi_file(struct mg_connection *, const char *, struct mg_file *, int);; 11857 ; 11858 ; 11859static void; 11860do_ssi_include(struct mg_connection *conn,; 11861 const char *ssi,; 11862 char *tag,; 11863 int include_level); 11864{; 11865 char file_name[MG_BUF_LEN], path[512], *p;; 11866 struct mg_file file = STRUCT_FILE_INITIALIZER;; 11867 size_t len;; 11868 int truncated = 0;; 11869 ; 11870 if (conn == NULL) {; 11871 return;; 11872 }; 11873 ; 11874 /* sscanf() is safe here, since send_ssi_file() also uses buffer; 11875 * of size MG_BUF_LEN to get the tag. So strlen(tag) is; 11876 * always < MG_BUF_LEN. */; 11877 if (sscanf(tag, "" virtual=\""%511[^\""]\"""", file_name) == 1) {; 11878 /* File name is relative to the webserver root */; 11879 file_name[511] = 0;; 11880 (void)mg_snprintf(conn,; 11881 &truncated,; 11882 path,; 11883 sizeof(path),; 11884 ""%s/%s"",; 11885 conn->dom_ctx->config[DOCUMENT_ROOT],; 11886 file_name);; 11887 ; 11888 } else if (sscanf(tag, "" abspath=\""%511[^\""]\"""", file_name) == 1) {; 11889 /* File name is relative to the webserver working directory; 11890 * or it is absolute system path */; 11891 file_name[511] = 0;; ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:360966,Safety,timeout,timeout,360966,"2426 unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;; 12427 int n, error, exit_by_callback;; 12428 int ret;; 12429 ; 12430 /* body_len is the length of the entire queue in bytes; 12431 * len is the length of the current message; 12432 * data_len is the length of the current message's data payload; 12433 * header_len is the length of the current message's header */; 12434 size_t i, len, mask_len = 0, header_len, body_len;; 12435 uint64_t data_len = 0;; 12436 ; 12437 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12438 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12439 */; 12440 unsigned char mask[4];; 12441 ; 12442 /* data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];; 12446 unsigned char mop; /* mask flag and opcode */; 12447 ; 12448 ; 12449 /* Variables used for connection monitoring */; 12450 double timeout = -1.0;; 12451 int enable_ping_pong = 0;; 12452 int ping_count = 0;; 12453 ; 12454 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12455 enable_ping_pong =; 12456 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12457 ""yes"");; 12458 }; 12459 ; 12460 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12461 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12462 }; 12463 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12464 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12465 }; 12466 if (timeout <= 0.0) {; 12467 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12468 }; 12469 ; 12470 /* Enter data processing loop */; 12471 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12472 conn->request_info.remote_addr,; 12473 conn->request_info.remote_port);; 12474 conn->in_websocket_h",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:361307,Safety,timeout,timeout,361307,"urrent message's data payload; 12433 * header_len is the length of the current message's header */; 12434 size_t i, len, mask_len = 0, header_len, body_len;; 12435 uint64_t data_len = 0;; 12436 ; 12437 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12438 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12439 */; 12440 unsigned char mask[4];; 12441 ; 12442 /* data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];; 12446 unsigned char mop; /* mask flag and opcode */; 12447 ; 12448 ; 12449 /* Variables used for connection monitoring */; 12450 double timeout = -1.0;; 12451 int enable_ping_pong = 0;; 12452 int ping_count = 0;; 12453 ; 12454 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12455 enable_ping_pong =; 12456 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12457 ""yes"");; 12458 }; 12459 ; 12460 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12461 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12462 }; 12463 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12464 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12465 }; 12466 if (timeout <= 0.0) {; 12467 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12468 }; 12469 ; 12470 /* Enter data processing loop */; 12471 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12472 conn->request_info.remote_addr,; 12473 conn->request_info.remote_port);; 12474 conn->in_websocket_handling = 1;; 12475 mg_set_thread_name(""wsock"");; 12476 ; 12477 /* Loop continuously, reading messages from the socket, invoking the; 12478 * callback, and waiting repeatedly until an error occurs. */; 12479 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12480 && (!conn->must_close",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:361395,Safety,timeout,timeout,361395,"ing key is a 32-bit value chosen at random by the client.""; 12438 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12439 */; 12440 unsigned char mask[4];; 12441 ; 12442 /* data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];; 12446 unsigned char mop; /* mask flag and opcode */; 12447 ; 12448 ; 12449 /* Variables used for connection monitoring */; 12450 double timeout = -1.0;; 12451 int enable_ping_pong = 0;; 12452 int ping_count = 0;; 12453 ; 12454 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12455 enable_ping_pong =; 12456 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12457 ""yes"");; 12458 }; 12459 ; 12460 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12461 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12462 }; 12463 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12464 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12465 }; 12466 if (timeout <= 0.0) {; 12467 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12468 }; 12469 ; 12470 /* Enter data processing loop */; 12471 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12472 conn->request_info.remote_addr,; 12473 conn->request_info.remote_port);; 12474 conn->in_websocket_handling = 1;; 12475 mg_set_thread_name(""wsock"");; 12476 ; 12477 /* Loop continuously, reading messages from the socket, invoking the; 12478 * callback, and waiting repeatedly until an error occurs. */; 12479 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12480 && (!conn->must_close)) {; 12481 header_len = 0;; 12482 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12483 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12484 len = buf[1] & 127;; 12485 mask_len = (buf[1]",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:361465,Safety,timeout,timeout,361465,"ls.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12439 */; 12440 unsigned char mask[4];; 12441 ; 12442 /* data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];; 12446 unsigned char mop; /* mask flag and opcode */; 12447 ; 12448 ; 12449 /* Variables used for connection monitoring */; 12450 double timeout = -1.0;; 12451 int enable_ping_pong = 0;; 12452 int ping_count = 0;; 12453 ; 12454 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12455 enable_ping_pong =; 12456 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12457 ""yes"");; 12458 }; 12459 ; 12460 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12461 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12462 }; 12463 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12464 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12465 }; 12466 if (timeout <= 0.0) {; 12467 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12468 }; 12469 ; 12470 /* Enter data processing loop */; 12471 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12472 conn->request_info.remote_addr,; 12473 conn->request_info.remote_port);; 12474 conn->in_websocket_handling = 1;; 12475 mg_set_thread_name(""wsock"");; 12476 ; 12477 /* Loop continuously, reading messages from the socket, invoking the; 12478 * callback, and waiting repeatedly until an error occurs. */; 12479 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12480 && (!conn->must_close)) {; 12481 header_len = 0;; 12482 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12483 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12484 len = buf[1] & 127;; 12485 mask_len = (buf[1] & 128) ? 4 : 0;; 12486 if ((len < 126) && (body_len >= mask_len)) {; 12487 /*",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:361550,Safety,timeout,timeout,361550,"12440 unsigned char mask[4];; 12441 ; 12442 /* data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];; 12446 unsigned char mop; /* mask flag and opcode */; 12447 ; 12448 ; 12449 /* Variables used for connection monitoring */; 12450 double timeout = -1.0;; 12451 int enable_ping_pong = 0;; 12452 int ping_count = 0;; 12453 ; 12454 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12455 enable_ping_pong =; 12456 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12457 ""yes"");; 12458 }; 12459 ; 12460 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12461 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12462 }; 12463 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12464 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12465 }; 12466 if (timeout <= 0.0) {; 12467 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12468 }; 12469 ; 12470 /* Enter data processing loop */; 12471 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12472 conn->request_info.remote_addr,; 12473 conn->request_info.remote_port);; 12474 conn->in_websocket_handling = 1;; 12475 mg_set_thread_name(""wsock"");; 12476 ; 12477 /* Loop continuously, reading messages from the socket, invoking the; 12478 * callback, and waiting repeatedly until an error occurs. */; 12479 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12480 && (!conn->must_close)) {; 12481 header_len = 0;; 12482 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12483 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12484 len = buf[1] & 127;; 12485 mask_len = (buf[1] & 128) ? 4 : 0;; 12486 if ((len < 126) && (body_len >= mask_len)) {; 12487 /* inline 7-bit length field */; 12488 data_len = len;; 12489 header_len = 2 + ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:361575,Safety,timeout,timeout,361575,"data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];; 12446 unsigned char mop; /* mask flag and opcode */; 12447 ; 12448 ; 12449 /* Variables used for connection monitoring */; 12450 double timeout = -1.0;; 12451 int enable_ping_pong = 0;; 12452 int ping_count = 0;; 12453 ; 12454 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12455 enable_ping_pong =; 12456 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12457 ""yes"");; 12458 }; 12459 ; 12460 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12461 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12462 }; 12463 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12464 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12465 }; 12466 if (timeout <= 0.0) {; 12467 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12468 }; 12469 ; 12470 /* Enter data processing loop */; 12471 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12472 conn->request_info.remote_addr,; 12473 conn->request_info.remote_port);; 12474 conn->in_websocket_handling = 1;; 12475 mg_set_thread_name(""wsock"");; 12476 ; 12477 /* Loop continuously, reading messages from the socket, invoking the; 12478 * callback, and waiting repeatedly until an error occurs. */; 12479 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12480 && (!conn->must_close)) {; 12481 header_len = 0;; 12482 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12483 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12484 len = buf[1] & 127;; 12485 mask_len = (buf[1] & 128) ? 4 : 0;; 12486 if ((len < 126) && (body_len >= mask_len)) {; 12487 /* inline 7-bit length field */; 12488 data_len = len;; 12489 header_len = 2 + mask_len;; 12490 } else if ((len == 126) && (bod",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:364631,Safety,timeout,timeout,364631,"t of memory; closing connection"");; 12527 break;; 12528 }; 12529 }; 12530 ; 12531 /* Copy the mask before we shift the queue and destroy it */; 12532 if (mask_len > 0) {; 12533 memcpy(mask, buf + header_len - mask_len, sizeof(mask));; 12534 } else {; 12535 memset(mask, 0, sizeof(mask));; 12536 }; 12537 ; 12538 /* Read frame payload from the first message in the queue into; 12539 * data and advance the queue by moving the memory in place. */; 12540 DEBUG_ASSERT(body_len >= header_len);; 12541 if (data_len + (uint64_t)header_len > (uint64_t)body_len) {; 12542 mop = buf[0]; /* current mask and opcode */; 12543 /* Overflow case */; 12544 len = body_len - header_len;; 12545 memcpy(data, buf + header_len, len);; 12546 error = 0;; 12547 while ((uint64_t)len < data_len) {; 12548 n = pull_inner(NULL,; 12549 conn,; 12550 (char *)(data + len),; 12551 (int)(data_len - len),; 12552 timeout);; 12553 if (n <= -2) {; 12554 error = 1;; 12555 break;; 12556 } else if (n > 0) {; 12557 len += (size_t)n;; 12558 } else {; 12559 /* Timeout: should retry */; 12560 /* TODO: retry condition */; 12561 }; 12562 }; 12563 if (error) {; 12564 mg_cry_internal(; 12565 conn,; 12566 ""%s"",; 12567 ""Websocket pull failed; closing connection"");; 12568 if (data != mem) {; 12569 mg_free(data);; 12570 }; 12571 break;; 12572 }; 12573 ; 12574 conn->data_len = conn->request_len;; 12575 ; 12576 } else {; 12577 ; 12578 mop = buf[0]; /* current mask and opcode, overwritten by; 12579 * memmove() */; 12580 ; 12581 /* Length of the message being read at the front of the; 12582 * queue. Cast to 31 bit is OK, since we limited; 12583 * data_len before. */; 12584 len = (size_t)data_len + header_len;; 12585 ; 12586 /* Copy the data payload into the data pointer for the; 12587 * callback. Cast to 31 bit is OK, since we; 12588 * limited data_len */; 12589 memcpy(data, buf + header_len, (size_t)data_len);; 12590 ; 12591 /* Move the queue forward len bytes */; 12592 memmove(buf, buf + len, body_len - len);; 12593 ; 12594 /* Ma",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:370587,Safety,timeout,timeout,370587,"k_data)) {; 12719 exit_by_callback = 1;; 12720 }; 12721 }; 12722 }; 12723 ; 12724 /* It a buffer has been allocated, free it again */; 12725 if (data != mem) {; 12726 mg_free(data);; 12727 }; 12728 ; 12729 if (exit_by_callback) {; 12730 DEBUG_TRACE(""Callback requests to close connection from %s:%u"",; 12731 conn->request_info.remote_addr,; 12732 conn->request_info.remote_port);; 12733 break;; 12734 }; 12735 if ((mop & 0xf) == MG_WEBSOCKET_OPCODE_CONNECTION_CLOSE) {; 12736 /* Opcode == 8, connection close */; 12737 DEBUG_TRACE(""Message requests to close connection from %s:%u"",; 12738 conn->request_info.remote_addr,; 12739 conn->request_info.remote_port);; 12740 break;; 12741 }; 12742 ; 12743 /* Not breaking the loop, process next websocket frame. */; 12744 } else {; 12745 /* Read from the socket into the next available location in the; 12746 * message queue. */; 12747 n = pull_inner(NULL,; 12748 conn,; 12749 conn->buf + conn->data_len,; 12750 conn->buf_size - conn->data_len,; 12751 timeout);; 12752 if (n <= -2) {; 12753 /* Error, no bytes read */; 12754 DEBUG_TRACE(""PULL from %s:%u failed"",; 12755 conn->request_info.remote_addr,; 12756 conn->request_info.remote_port);; 12757 break;; 12758 }; 12759 if (n > 0) {; 12760 conn->data_len += n;; 12761 /* Reset open PING count */; 12762 ping_count = 0;; 12763 } else {; 12764 if (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12765 && (!conn->must_close)) {; 12766 if (ping_count > MG_MAX_UNANSWERED_PING) {; 12767 /* Stop sending PING */; 12768 DEBUG_TRACE(""Too many (%i) unanswered ping from %s:%u ""; 12769 ""- closing connection"",; 12770 ping_count,; 12771 conn->request_info.remote_addr,; 12772 conn->request_info.remote_port);; 12773 break;; 12774 }; 12775 if (enable_ping_pong) {; 12776 /* Send Websocket PING message */; 12777 DEBUG_TRACE(""PING to %s:%u"",; 12778 conn->request_info.remote_addr,; 12779 conn->request_info.remote_port);; 12780 ret = mg_websocket_write(conn,; 12781 MG_WEBSOCKET_OPCODE_PING,; 12782 NULL,; 12783 0);; 1",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:371820,Safety,timeout,timeout,371820,"break;; 12758 }; 12759 if (n > 0) {; 12760 conn->data_len += n;; 12761 /* Reset open PING count */; 12762 ping_count = 0;; 12763 } else {; 12764 if (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12765 && (!conn->must_close)) {; 12766 if (ping_count > MG_MAX_UNANSWERED_PING) {; 12767 /* Stop sending PING */; 12768 DEBUG_TRACE(""Too many (%i) unanswered ping from %s:%u ""; 12769 ""- closing connection"",; 12770 ping_count,; 12771 conn->request_info.remote_addr,; 12772 conn->request_info.remote_port);; 12773 break;; 12774 }; 12775 if (enable_ping_pong) {; 12776 /* Send Websocket PING message */; 12777 DEBUG_TRACE(""PING to %s:%u"",; 12778 conn->request_info.remote_addr,; 12779 conn->request_info.remote_port);; 12780 ret = mg_websocket_write(conn,; 12781 MG_WEBSOCKET_OPCODE_PING,; 12782 NULL,; 12783 0);; 12784 ; 12785 if (ret <= 0) {; 12786 /* Error: send failed */; 12787 DEBUG_TRACE(""Send PING failed (%i)"", ret);; 12788 break;; 12789 }; 12790 ping_count++;; 12791 }; 12792 }; 12793 /* Timeout: should retry */; 12794 /* TODO: get timeout def */; 12795 }; 12796 }; 12797 }; 12798 ; 12799 /* Leave data processing loop */; 12800 mg_set_thread_name(""worker"");; 12801 conn->in_websocket_handling = 0;; 12802 DEBUG_TRACE(""Websocket connection %s:%u left data processing loop"",; 12803 conn->request_info.remote_addr,; 12804 conn->request_info.remote_port);; 12805}; 12806 ; 12807 ; 12808static int; 12809mg_websocket_write_exec(struct mg_connection *conn,; 12810 int opcode,; 12811 const char *data,; 12812 size_t dataLen,; 12813 uint32_t masking_key); 12814{; 12815 unsigned char header[14];; 12816 size_t headerLen;; 12817 int retval;; 12818 ; 12819#if defined(GCC_DIAGNOSTIC); 12820 /* Disable spurious conversion warning for GCC */; 12821#pragma GCC diagnostic push; 12822#pragma GCC diagnostic ignored ""-Wconversion""; 12823#endif; 12824 ; 12825 /* Note that POSIX/Winsock's send() is threadsafe; 12826 * http://stackoverflow.com/questions/1981372/are-parallel-calls-to-send-recv-on-the-same-socke",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:441457,Safety,detect,detected,441457,"en < vec->len) ? vec->ptr[len] : '\0';; 14885 so->is_ssl = (ch == 's');; 14886 so->ssl_redir = (ch == 'r');; 14887 if ((ch == '\0') || (ch == 's') || (ch == 'r')) {; 14888 return 1;; 14889 }; 14890 }; 14891 ; 14892 /* Reset ip_version to 0 if there is an error */; 14893 *ip_version = 0;; 14894 return 0;; 14895}; 14896 ; 14897 ; 14898/* Is there any SSL port in use? */; 14899static int; 14900is_ssl_port_used(const char *ports); 14901{; 14902 if (ports) {; 14903 /* There are several different allowed syntax variants:; 14904 * - ""80"" for a single port using every network interface; 14905 * - ""localhost:80"" for a single port using only localhost; 14906 * - ""80,localhost:8080"" for two ports, one bound to localhost; 14907 * - ""80,127.0.0.1:8084,[::1]:8086"" for three ports, one bound; 14908 * to IPv4 localhost, one to IPv6 localhost; 14909 * - ""+80"" use port 80 for IPv4 and IPv6; 14910 * - ""+80r,+443s"" port 80 (HTTP) is a redirect to port 443 (HTTPS),; 14911 * for both: IPv4 and IPv4; 14912 * - ""+443s,localhost:8080"" port 443 (HTTPS) for every interface,; 14913 * additionally port 8080 bound to localhost connections; 14914 *; 14915 * If we just look for 's' anywhere in the string, ""localhost:80""; 14916 * will be detected as SSL (false positive).; 14917 * Looking for 's' after a digit may cause false positives in; 14918 * ""my24service:8080"".; 14919 * Looking from 's' backward if there are only ':' and numbers; 14920 * before will not work for ""24service:8080"" (non SSL, port 8080); 14921 * or ""24s"" (SSL, port 24).; 14922 *; 14923 * Remark: Initially hostnames were not allowed to start with a; 14924 * digit (according to RFC 952), this was allowed later (RFC 1123,; 14925 * Section 2.1).; 14926 *; 14927 * To get this correct, the entire string must be parsed as a whole,; 14928 * reading it as a list element for element and parsing with an; 14929 * algorithm equivalent to parse_port_string.; 14930 *; 14931 * In fact, we use local interface names here, not arbitrary; 14932 * hos",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:445274,Safety,abort,abort,445274,"st of protocol numbers (e.g., TCP==6) see:; 15013 * https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml; 15014 */; 15015 if ((so.sock =; 15016 socket(so.lsa.sa.sa_family,; 15017 SOCK_STREAM,; 15018 (ip_version == 99) ? (/* LOCAL */ 0) : (/* TCP */ 6))); 15019 == INVALID_SOCKET) {; 15020 ; 15021 mg_cry_ctx_internal(phys_ctx,; 15022 ""cannot create socket (entry %i)"",; 15023 portsTotal);; 15024 continue;; 15025 }; 15026 ; 15027#if defined(_WIN32); 15028 /* Windows SO_REUSEADDR lets many procs binds to a; 15029 * socket, SO_EXCLUSIVEADDRUSE makes the bind fail; 15030 * if someone already has the socket -- DTL */; 15031 /* NOTE: If SO_EXCLUSIVEADDRUSE is used,; 15032 * Windows might need a few seconds before; 15033 * the same port can be used again in the; 15034 * same process, so a short Sleep may be; 15035 * required between mg_stop and mg_start.; 15036 */; 15037 if (setsockopt(so.sock,; 15038 SOL_SOCKET,; 15039 SO_EXCLUSIVEADDRUSE,; 15040 (SOCK_OPT_TYPE)&on,; 15041 sizeof(on)); 15042 != 0) {; 15043 ; 15044 /* Set reuse option, but don't abort on errors. */; 15045 mg_cry_ctx_internal(; 15046 phys_ctx,; 15047 ""cannot set socket option SO_EXCLUSIVEADDRUSE (entry %i)"",; 15048 portsTotal);; 15049 }; 15050#else; 15051 if (setsockopt(so.sock,; 15052 SOL_SOCKET,; 15053 SO_REUSEADDR,; 15054 (SOCK_OPT_TYPE)&on,; 15055 sizeof(on)); 15056 != 0) {; 15057 ; 15058 /* Set reuse option, but don't abort on errors. */; 15059 mg_cry_ctx_internal(; 15060 phys_ctx,; 15061 ""cannot set socket option SO_REUSEADDR (entry %i)"",; 15062 portsTotal);; 15063 }; 15064#endif; 15065 ; 15066#if defined(USE_X_DOM_SOCKET); 15067 if (ip_version == 99) {; 15068 /* Unix domain socket */; 15069 } else; 15070#endif; 15071 ; 15072 if (ip_version > 4) {; 15073 /* Could be 6 for IPv6 onlyor 10 (4+6) for IPv4+IPv6 */; 15074#if defined(USE_IPV6); 15075 if (ip_version > 6) {; 15076 if (so.lsa.sa.sa_family == AF_INET6; 15077 && setsockopt(so.sock,; 15078 IPPROTO_IPV6,; 15079 IPV6_V6ONLY,; 15080 ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:445624,Safety,abort,abort,445624," ""cannot create socket (entry %i)"",; 15023 portsTotal);; 15024 continue;; 15025 }; 15026 ; 15027#if defined(_WIN32); 15028 /* Windows SO_REUSEADDR lets many procs binds to a; 15029 * socket, SO_EXCLUSIVEADDRUSE makes the bind fail; 15030 * if someone already has the socket -- DTL */; 15031 /* NOTE: If SO_EXCLUSIVEADDRUSE is used,; 15032 * Windows might need a few seconds before; 15033 * the same port can be used again in the; 15034 * same process, so a short Sleep may be; 15035 * required between mg_stop and mg_start.; 15036 */; 15037 if (setsockopt(so.sock,; 15038 SOL_SOCKET,; 15039 SO_EXCLUSIVEADDRUSE,; 15040 (SOCK_OPT_TYPE)&on,; 15041 sizeof(on)); 15042 != 0) {; 15043 ; 15044 /* Set reuse option, but don't abort on errors. */; 15045 mg_cry_ctx_internal(; 15046 phys_ctx,; 15047 ""cannot set socket option SO_EXCLUSIVEADDRUSE (entry %i)"",; 15048 portsTotal);; 15049 }; 15050#else; 15051 if (setsockopt(so.sock,; 15052 SOL_SOCKET,; 15053 SO_REUSEADDR,; 15054 (SOCK_OPT_TYPE)&on,; 15055 sizeof(on)); 15056 != 0) {; 15057 ; 15058 /* Set reuse option, but don't abort on errors. */; 15059 mg_cry_ctx_internal(; 15060 phys_ctx,; 15061 ""cannot set socket option SO_REUSEADDR (entry %i)"",; 15062 portsTotal);; 15063 }; 15064#endif; 15065 ; 15066#if defined(USE_X_DOM_SOCKET); 15067 if (ip_version == 99) {; 15068 /* Unix domain socket */; 15069 } else; 15070#endif; 15071 ; 15072 if (ip_version > 4) {; 15073 /* Could be 6 for IPv6 onlyor 10 (4+6) for IPv4+IPv6 */; 15074#if defined(USE_IPV6); 15075 if (ip_version > 6) {; 15076 if (so.lsa.sa.sa_family == AF_INET6; 15077 && setsockopt(so.sock,; 15078 IPPROTO_IPV6,; 15079 IPV6_V6ONLY,; 15080 (void *)&off,; 15081 sizeof(off)); 15082 != 0) {; 15083 ; 15084 /* Set IPv6 only option, but don't abort on errors. */; 15085 mg_cry_ctx_internal(phys_ctx,; 15086 ""cannot set socket option ""; 15087 ""IPV6_V6ONLY=off (entry %i)"",; 15088 portsTotal);; 15089 }; 15090 } else {; 15091 if (so.lsa.sa.sa_family == AF_INET6; 15092 && setsockopt(so.sock,; 15093 I",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:446301,Safety,abort,abort,446301,"43 ; 15044 /* Set reuse option, but don't abort on errors. */; 15045 mg_cry_ctx_internal(; 15046 phys_ctx,; 15047 ""cannot set socket option SO_EXCLUSIVEADDRUSE (entry %i)"",; 15048 portsTotal);; 15049 }; 15050#else; 15051 if (setsockopt(so.sock,; 15052 SOL_SOCKET,; 15053 SO_REUSEADDR,; 15054 (SOCK_OPT_TYPE)&on,; 15055 sizeof(on)); 15056 != 0) {; 15057 ; 15058 /* Set reuse option, but don't abort on errors. */; 15059 mg_cry_ctx_internal(; 15060 phys_ctx,; 15061 ""cannot set socket option SO_REUSEADDR (entry %i)"",; 15062 portsTotal);; 15063 }; 15064#endif; 15065 ; 15066#if defined(USE_X_DOM_SOCKET); 15067 if (ip_version == 99) {; 15068 /* Unix domain socket */; 15069 } else; 15070#endif; 15071 ; 15072 if (ip_version > 4) {; 15073 /* Could be 6 for IPv6 onlyor 10 (4+6) for IPv4+IPv6 */; 15074#if defined(USE_IPV6); 15075 if (ip_version > 6) {; 15076 if (so.lsa.sa.sa_family == AF_INET6; 15077 && setsockopt(so.sock,; 15078 IPPROTO_IPV6,; 15079 IPV6_V6ONLY,; 15080 (void *)&off,; 15081 sizeof(off)); 15082 != 0) {; 15083 ; 15084 /* Set IPv6 only option, but don't abort on errors. */; 15085 mg_cry_ctx_internal(phys_ctx,; 15086 ""cannot set socket option ""; 15087 ""IPV6_V6ONLY=off (entry %i)"",; 15088 portsTotal);; 15089 }; 15090 } else {; 15091 if (so.lsa.sa.sa_family == AF_INET6; 15092 && setsockopt(so.sock,; 15093 IPPROTO_IPV6,; 15094 IPV6_V6ONLY,; 15095 (void *)&on,; 15096 sizeof(on)); 15097 != 0) {; 15098 ; 15099 /* Set IPv6 only option, but don't abort on errors. */; 15100 mg_cry_ctx_internal(phys_ctx,; 15101 ""cannot set socket option ""; 15102 ""IPV6_V6ONLY=on (entry %i)"",; 15103 portsTotal);; 15104 }; 15105 }; 15106#else; 15107 mg_cry_ctx_internal(phys_ctx, ""%s"", ""IPv6 not available"");; 15108 closesocket(so.sock);; 15109 so.sock = INVALID_SOCKET;; 15110 continue;; 15111#endif; 15112 }; 15113 ; 15114 if (so.lsa.sa.sa_family == AF_INET) {; 15115 ; 15116 len = sizeof(so.lsa.sin);; 15117 if (bind(so.sock, &so.lsa.sa, len) != 0) {; 15118 mg_cry_ctx_internal(phys_ctx,; 15119 ""cannot",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:446693,Safety,abort,abort,446693,"bort on errors. */; 15059 mg_cry_ctx_internal(; 15060 phys_ctx,; 15061 ""cannot set socket option SO_REUSEADDR (entry %i)"",; 15062 portsTotal);; 15063 }; 15064#endif; 15065 ; 15066#if defined(USE_X_DOM_SOCKET); 15067 if (ip_version == 99) {; 15068 /* Unix domain socket */; 15069 } else; 15070#endif; 15071 ; 15072 if (ip_version > 4) {; 15073 /* Could be 6 for IPv6 onlyor 10 (4+6) for IPv4+IPv6 */; 15074#if defined(USE_IPV6); 15075 if (ip_version > 6) {; 15076 if (so.lsa.sa.sa_family == AF_INET6; 15077 && setsockopt(so.sock,; 15078 IPPROTO_IPV6,; 15079 IPV6_V6ONLY,; 15080 (void *)&off,; 15081 sizeof(off)); 15082 != 0) {; 15083 ; 15084 /* Set IPv6 only option, but don't abort on errors. */; 15085 mg_cry_ctx_internal(phys_ctx,; 15086 ""cannot set socket option ""; 15087 ""IPV6_V6ONLY=off (entry %i)"",; 15088 portsTotal);; 15089 }; 15090 } else {; 15091 if (so.lsa.sa.sa_family == AF_INET6; 15092 && setsockopt(so.sock,; 15093 IPPROTO_IPV6,; 15094 IPV6_V6ONLY,; 15095 (void *)&on,; 15096 sizeof(on)); 15097 != 0) {; 15098 ; 15099 /* Set IPv6 only option, but don't abort on errors. */; 15100 mg_cry_ctx_internal(phys_ctx,; 15101 ""cannot set socket option ""; 15102 ""IPV6_V6ONLY=on (entry %i)"",; 15103 portsTotal);; 15104 }; 15105 }; 15106#else; 15107 mg_cry_ctx_internal(phys_ctx, ""%s"", ""IPv6 not available"");; 15108 closesocket(so.sock);; 15109 so.sock = INVALID_SOCKET;; 15110 continue;; 15111#endif; 15112 }; 15113 ; 15114 if (so.lsa.sa.sa_family == AF_INET) {; 15115 ; 15116 len = sizeof(so.lsa.sin);; 15117 if (bind(so.sock, &so.lsa.sa, len) != 0) {; 15118 mg_cry_ctx_internal(phys_ctx,; 15119 ""cannot bind to %.*s: %d (%s)"",; 15120 (int)vec.len,; 15121 vec.ptr,; 15122 (int)ERRNO,; 15123 strerror(errno));; 15124 closesocket(so.sock);; 15125 so.sock = INVALID_SOCKET;; 15126 continue;; 15127 }; 15128 }; 15129#if defined(USE_IPV6); 15130 else if (so.lsa.sa.sa_family == AF_INET6) {; 15131 ; 15132 len = sizeof(so.lsa.sin6);; 15133 if (bind(so.sock, &so.lsa.sa, len) != 0) {; 15134 mg_cry_ctx_i",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:463056,Safety,timeout,timeout,463056,"lock_context(conn->phys_ctx);; 15640 mg_cry_ctx_internal(; 15641 conn->phys_ctx,; 15642 ""SSL_CTX_load_verify_locations error: %s ""; 15643 ""ssl_verify_peer requires setting ""; 15644 ""either ssl_ca_path or ssl_ca_file. Is any of them ""; 15645 ""present in ""; 15646 ""the .conf file?"",; 15647 ssl_error());; 15648 return 0;; 15649 }; 15650 }; 15651 ; 15652 if (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain) == 0) {; 15653 mg_unlock_context(conn->phys_ctx);; 15654 return 0;; 15655 }; 15656 }; 15657 mg_unlock_context(conn->phys_ctx);; 15658 ; 15659 return 1;; 15660}; 15661 ; 15662#if defined(OPENSSL_API_1_1); 15663#else; 15664static pthread_mutex_t *ssl_mutexes;; 15665#endif /* OPENSSL_API_1_1 */; 15666 ; 15667static int; 15668sslize(struct mg_connection *conn,; 15669 int (*func)(SSL *),; 15670 const struct mg_client_options *client_options); 15671{; 15672 int ret, err;; 15673 int short_trust;; 15674 unsigned timeout = 1024;; 15675 unsigned i;; 15676 ; 15677 if (!conn) {; 15678 return 0;; 15679 }; 15680 ; 15681 short_trust =; 15682 (conn->dom_ctx->config[SSL_SHORT_TRUST] != NULL); 15683 && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], ""yes"") == 0);; 15684 ; 15685 if (short_trust) {; 15686 int trust_ret = refresh_trust(conn);; 15687 if (!trust_ret) {; 15688 return trust_ret;; 15689 }; 15690 }; 15691 ; 15692 mg_lock_context(conn->phys_ctx);; 15693 conn->ssl = SSL_new(conn->dom_ctx->ssl_ctx);; 15694 mg_unlock_context(conn->phys_ctx);; 15695 if (conn->ssl == NULL) {; 15696 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15697 OPENSSL_REMOVE_THREAD_STATE();; 15698 return 0;; 15699 }; 15700 SSL_set_app_data(conn->ssl, (char *)conn);; 15701 ; 15702 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15703 if (ret != 1) {; 15704 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15705 SSL_free(conn->ssl);; 15706 conn->ssl = NULL;; 15707 OPENSSL_REMOVE_THREAD_STATE();; 15708 return 0;; 15709 }; 15710 ; 15711 if (client_options) {; 15712 if (client_opt",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:464274,Safety,timeout,timeout,464274,"nn->dom_ctx->config[SSL_SHORT_TRUST] != NULL); 15683 && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], ""yes"") == 0);; 15684 ; 15685 if (short_trust) {; 15686 int trust_ret = refresh_trust(conn);; 15687 if (!trust_ret) {; 15688 return trust_ret;; 15689 }; 15690 }; 15691 ; 15692 mg_lock_context(conn->phys_ctx);; 15693 conn->ssl = SSL_new(conn->dom_ctx->ssl_ctx);; 15694 mg_unlock_context(conn->phys_ctx);; 15695 if (conn->ssl == NULL) {; 15696 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15697 OPENSSL_REMOVE_THREAD_STATE();; 15698 return 0;; 15699 }; 15700 SSL_set_app_data(conn->ssl, (char *)conn);; 15701 ; 15702 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15703 if (ret != 1) {; 15704 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15705 SSL_free(conn->ssl);; 15706 conn->ssl = NULL;; 15707 OPENSSL_REMOVE_THREAD_STATE();; 15708 return 0;; 15709 }; 15710 ; 15711 if (client_options) {; 15712 if (client_options->host_name) {; 15713 SSL_set_tlsext_host_name(conn->ssl, client_options->host_name);; 15714 }; 15715 }; 15716 ; 15717 /* Reuse the request timeout for the SSL_Accept/SSL_connect timeout */; 15718 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 15719 /* NOTE: The loop below acts as a back-off, so we can end; 15720 * up sleeping for more (or less) than the REQUEST_TIMEOUT. */; 15721 int to = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]);; 15722 if (to >= 0) {; 15723 timeout = (unsigned)to;; 15724 }; 15725 }; 15726 ; 15727 /* SSL functions may fail and require to be called again:; 15728 * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html; 15729 * Here ""func"" could be SSL_connect or SSL_accept. */; 15730 for (i = 0; i <= timeout; i += 50) {; 15731 ERR_clear_error();; 15732 /* conn->dom_ctx may be changed here (see ssl_servername_callback) */; 15733 ret = func(conn->ssl);; 15734 if (ret != 1) {; 15735 err = SSL_get_error(conn->ssl, ret);; 15736 if ((err == SSL_ERROR_WANT_CONNECT); 15737 || (err == SSL_ERROR_WANT_ACCEPT); 1573",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:464313,Safety,timeout,timeout,464313,"nn->dom_ctx->config[SSL_SHORT_TRUST] != NULL); 15683 && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], ""yes"") == 0);; 15684 ; 15685 if (short_trust) {; 15686 int trust_ret = refresh_trust(conn);; 15687 if (!trust_ret) {; 15688 return trust_ret;; 15689 }; 15690 }; 15691 ; 15692 mg_lock_context(conn->phys_ctx);; 15693 conn->ssl = SSL_new(conn->dom_ctx->ssl_ctx);; 15694 mg_unlock_context(conn->phys_ctx);; 15695 if (conn->ssl == NULL) {; 15696 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15697 OPENSSL_REMOVE_THREAD_STATE();; 15698 return 0;; 15699 }; 15700 SSL_set_app_data(conn->ssl, (char *)conn);; 15701 ; 15702 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15703 if (ret != 1) {; 15704 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15705 SSL_free(conn->ssl);; 15706 conn->ssl = NULL;; 15707 OPENSSL_REMOVE_THREAD_STATE();; 15708 return 0;; 15709 }; 15710 ; 15711 if (client_options) {; 15712 if (client_options->host_name) {; 15713 SSL_set_tlsext_host_name(conn->ssl, client_options->host_name);; 15714 }; 15715 }; 15716 ; 15717 /* Reuse the request timeout for the SSL_Accept/SSL_connect timeout */; 15718 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 15719 /* NOTE: The loop below acts as a back-off, so we can end; 15720 * up sleeping for more (or less) than the REQUEST_TIMEOUT. */; 15721 int to = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]);; 15722 if (to >= 0) {; 15723 timeout = (unsigned)to;; 15724 }; 15725 }; 15726 ; 15727 /* SSL functions may fail and require to be called again:; 15728 * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html; 15729 * Here ""func"" could be SSL_connect or SSL_accept. */; 15730 for (i = 0; i <= timeout; i += 50) {; 15731 ERR_clear_error();; 15732 /* conn->dom_ctx may be changed here (see ssl_servername_callback) */; 15733 ret = func(conn->ssl);; 15734 if (ret != 1) {; 15735 err = SSL_get_error(conn->ssl, ret);; 15736 if ((err == SSL_ERROR_WANT_CONNECT); 15737 || (err == SSL_ERROR_WANT_ACCEPT); 1573",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:464602,Safety,timeout,timeout,464602,"L) {; 15696 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15697 OPENSSL_REMOVE_THREAD_STATE();; 15698 return 0;; 15699 }; 15700 SSL_set_app_data(conn->ssl, (char *)conn);; 15701 ; 15702 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15703 if (ret != 1) {; 15704 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15705 SSL_free(conn->ssl);; 15706 conn->ssl = NULL;; 15707 OPENSSL_REMOVE_THREAD_STATE();; 15708 return 0;; 15709 }; 15710 ; 15711 if (client_options) {; 15712 if (client_options->host_name) {; 15713 SSL_set_tlsext_host_name(conn->ssl, client_options->host_name);; 15714 }; 15715 }; 15716 ; 15717 /* Reuse the request timeout for the SSL_Accept/SSL_connect timeout */; 15718 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 15719 /* NOTE: The loop below acts as a back-off, so we can end; 15720 * up sleeping for more (or less) than the REQUEST_TIMEOUT. */; 15721 int to = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]);; 15722 if (to >= 0) {; 15723 timeout = (unsigned)to;; 15724 }; 15725 }; 15726 ; 15727 /* SSL functions may fail and require to be called again:; 15728 * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html; 15729 * Here ""func"" could be SSL_connect or SSL_accept. */; 15730 for (i = 0; i <= timeout; i += 50) {; 15731 ERR_clear_error();; 15732 /* conn->dom_ctx may be changed here (see ssl_servername_callback) */; 15733 ret = func(conn->ssl);; 15734 if (ret != 1) {; 15735 err = SSL_get_error(conn->ssl, ret);; 15736 if ((err == SSL_ERROR_WANT_CONNECT); 15737 || (err == SSL_ERROR_WANT_ACCEPT); 15738 || (err == SSL_ERROR_WANT_READ) || (err == SSL_ERROR_WANT_WRITE); 15739 || (err == SSL_ERROR_WANT_X509_LOOKUP)) {; 15740 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 15741 /* Don't wait if the server is going to be stopped. */; 15742 break;; 15743 }; 15744 if (err == SSL_ERROR_WANT_X509_LOOKUP) {; 15745 /* Simply retry the function call. */; 15746 mg_sleep(50);; 15747 } else {; 15748 /* Need to retry the function call ""later",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:464876,Safety,timeout,timeout,464876,"->host_name) {; 15713 SSL_set_tlsext_host_name(conn->ssl, client_options->host_name);; 15714 }; 15715 }; 15716 ; 15717 /* Reuse the request timeout for the SSL_Accept/SSL_connect timeout */; 15718 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 15719 /* NOTE: The loop below acts as a back-off, so we can end; 15720 * up sleeping for more (or less) than the REQUEST_TIMEOUT. */; 15721 int to = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]);; 15722 if (to >= 0) {; 15723 timeout = (unsigned)to;; 15724 }; 15725 }; 15726 ; 15727 /* SSL functions may fail and require to be called again:; 15728 * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html; 15729 * Here ""func"" could be SSL_connect or SSL_accept. */; 15730 for (i = 0; i <= timeout; i += 50) {; 15731 ERR_clear_error();; 15732 /* conn->dom_ctx may be changed here (see ssl_servername_callback) */; 15733 ret = func(conn->ssl);; 15734 if (ret != 1) {; 15735 err = SSL_get_error(conn->ssl, ret);; 15736 if ((err == SSL_ERROR_WANT_CONNECT); 15737 || (err == SSL_ERROR_WANT_ACCEPT); 15738 || (err == SSL_ERROR_WANT_READ) || (err == SSL_ERROR_WANT_WRITE); 15739 || (err == SSL_ERROR_WANT_X509_LOOKUP)) {; 15740 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 15741 /* Don't wait if the server is going to be stopped. */; 15742 break;; 15743 }; 15744 if (err == SSL_ERROR_WANT_X509_LOOKUP) {; 15745 /* Simply retry the function call. */; 15746 mg_sleep(50);; 15747 } else {; 15748 /* Need to retry the function call ""later"".; 15749 * See https://linux.die.net/man/3/ssl_get_error; 15750 * This is typical for non-blocking sockets. */; 15751 struct mg_pollfd pfd;; 15752 int pollres;; 15753 pfd.fd = conn->client.sock;; 15754 pfd.events = ((err == SSL_ERROR_WANT_CONNECT); 15755 || (err == SSL_ERROR_WANT_WRITE)); 15756 ? POLLOUT; 15757 : POLLIN;; 15758 pollres =; 15759 mg_poll(&pfd, 1, 50, &(conn->phys_ctx->stop_flag));; 15760 if (pollres < 0) {; 15761 /* Break if error occured (-1); 15762 * or server shutdown (-2) */; 15763 br",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:474554,Safety,safe,safety,474554,"tic void *ssllib_dll_handle; /* Store the ssl library handle. */; 16019static void *cryptolib_dll_handle; /* Store the crypto library handle. */; 16020 ; 16021#endif /* NO_SSL_DL */; 16022 ; 16023 ; 16024#if defined(SSL_ALREADY_INITIALIZED); 16025static volatile ptrdiff_t cryptolib_users =; 16026 1; /* Reference counter for crypto library. */; 16027#else; 16028static volatile ptrdiff_t cryptolib_users =; 16029 0; /* Reference counter for crypto library. */; 16030#endif; 16031 ; 16032 ; 16033static int; 16034initialize_openssl(char *ebuf, size_t ebuf_len); 16035{; 16036#if !defined(OPENSSL_API_1_1) && !defined(OPENSSL_API_3_0); 16037 int i, num_locks;; 16038 size_t size;; 16039#endif; 16040 ; 16041 if (ebuf_len > 0) {; 16042 ebuf[0] = 0;; 16043 }; 16044 ; 16045#if !defined(NO_SSL_DL); 16046 if (!cryptolib_dll_handle) {; 16047 memset(tls_feature_missing, 0, sizeof(tls_feature_missing));; 16048 cryptolib_dll_handle = load_tls_dll(; 16049 ebuf, ebuf_len, CRYPTO_LIB, crypto_sw, tls_feature_missing);; 16050 if (!cryptolib_dll_handle) {; 16051 mg_snprintf(NULL,; 16052 NULL, /* No truncation check for ebuf */; 16053 ebuf,; 16054 ebuf_len,; 16055 ""%s: error loading library %s"",; 16056 __func__,; 16057 CRYPTO_LIB);; 16058 DEBUG_TRACE(""%s"", ebuf);; 16059 return 0;; 16060 }; 16061 }; 16062#endif /* NO_SSL_DL */; 16063 ; 16064 if (mg_atomic_inc(&cryptolib_users) > 1) {; 16065 return 1;; 16066 }; 16067 ; 16068#if !defined(OPENSSL_API_1_1) && !defined(OPENSSL_API_3_0); 16069 /* Initialize locking callbacks, needed for thread safety.; 16070 * http://www.openssl.org/support/faq.html#PROG1; 16071 */; 16072 num_locks = CRYPTO_num_locks();; 16073 if (num_locks < 0) {; 16074 num_locks = 0;; 16075 }; 16076 size = sizeof(pthread_mutex_t) * ((size_t)(num_locks));; 16077 ; 16078 /* allocate mutex array, if required */; 16079 if (num_locks == 0) {; 16080 /* No mutex array required */; 16081 ssl_mutexes = NULL;; 16082 } else {; 16083 /* Mutex array required - allocate it */; 16084 ssl_mutexes",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:503660,Safety,timeout,timeout,503660,"928 ; 16929 ; 16930static int; 16931set_tcp_nodelay(const struct socket *so, int nodelay_on); 16932{; 16933 if ((so->lsa.sa.sa_family == AF_INET); 16934 || (so->lsa.sa.sa_family == AF_INET6)) {; 16935 /* Only for TCP sockets */; 16936 if (setsockopt(so->sock,; 16937 IPPROTO_TCP,; 16938 TCP_NODELAY,; 16939 (SOCK_OPT_TYPE)&nodelay_on,; 16940 sizeof(nodelay_on)); 16941 != 0) {; 16942 /* Error */; 16943 return 1;; 16944 }; 16945 }; 16946 /* OK */; 16947 return 0;; 16948}; 16949 ; 16950 ; 16951#if !defined(__ZEPHYR__); 16952static void; 16953close_socket_gracefully(struct mg_connection *conn); 16954{; 16955#if defined(_WIN32); 16956 char buf[MG_BUF_LEN];; 16957 int n;; 16958#endif; 16959 struct linger linger;; 16960 int error_code = 0;; 16961 int linger_timeout = -2;; 16962 socklen_t opt_len = sizeof(error_code);; 16963 ; 16964 if (!conn) {; 16965 return;; 16966 }; 16967 ; 16968 /* http://msdn.microsoft.com/en-us/library/ms739165(v=vs.85).aspx:; 16969 * ""Note that enabling a nonzero timeout on a nonblocking socket; 16970 * is not recommended."", so set it to blocking now */; 16971 set_blocking_mode(conn->client.sock);; 16972 ; 16973 /* Send FIN to the client */; 16974 shutdown(conn->client.sock, SHUTDOWN_WR);; 16975 ; 16976 ; 16977#if defined(_WIN32); 16978 /* Read and discard pending incoming data. If we do not do that and; 16979 * close; 16980 * the socket, the data in the send buffer may be discarded. This; 16981 * behaviour is seen on Windows, when client keeps sending data; 16982 * when server decides to close the connection; then when client; 16983 * does recv() it gets no data back. */; 16984 do {; 16985 n = pull_inner(NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);; 16986 } while (n > 0);; 16987#endif; 16988 ; 16989 if (conn->dom_ctx->config[LINGER_TIMEOUT]) {; 16990 linger_timeout = atoi(conn->dom_ctx->config[LINGER_TIMEOUT]);; 16991 }; 16992 ; 16993 /* Set linger option according to configuration */; 16994 if (linger_timeout >= 0) {; 16995 /* Set linger o",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:504677,Safety,avoid,avoid,504677,"16967 ; 16968 /* http://msdn.microsoft.com/en-us/library/ms739165(v=vs.85).aspx:; 16969 * ""Note that enabling a nonzero timeout on a nonblocking socket; 16970 * is not recommended."", so set it to blocking now */; 16971 set_blocking_mode(conn->client.sock);; 16972 ; 16973 /* Send FIN to the client */; 16974 shutdown(conn->client.sock, SHUTDOWN_WR);; 16975 ; 16976 ; 16977#if defined(_WIN32); 16978 /* Read and discard pending incoming data. If we do not do that and; 16979 * close; 16980 * the socket, the data in the send buffer may be discarded. This; 16981 * behaviour is seen on Windows, when client keeps sending data; 16982 * when server decides to close the connection; then when client; 16983 * does recv() it gets no data back. */; 16984 do {; 16985 n = pull_inner(NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);; 16986 } while (n > 0);; 16987#endif; 16988 ; 16989 if (conn->dom_ctx->config[LINGER_TIMEOUT]) {; 16990 linger_timeout = atoi(conn->dom_ctx->config[LINGER_TIMEOUT]);; 16991 }; 16992 ; 16993 /* Set linger option according to configuration */; 16994 if (linger_timeout >= 0) {; 16995 /* Set linger option to avoid socket hanging out after close. This; 16996 * prevent ephemeral port exhaust problem under high QPS. */; 16997 linger.l_onoff = 1;; 16998 ; 16999#if defined(_MSC_VER); 17000#pragma warning(push); 17001#pragma warning(disable : 4244); 17002#endif; 17003#if defined(GCC_DIAGNOSTIC); 17004#pragma GCC diagnostic push; 17005#pragma GCC diagnostic ignored ""-Wconversion""; 17006#endif; 17007 /* Data type of linger structure elements may differ,; 17008 * so we don't know what cast we need here.; 17009 * Disable type conversion warnings. */; 17010 ; 17011 linger.l_linger = (linger_timeout + 999) / 1000;; 17012 ; 17013#if defined(GCC_DIAGNOSTIC); 17014#pragma GCC diagnostic pop; 17015#endif; 17016#if defined(_MSC_VER); 17017#pragma warning(pop); 17018#endif; 17019 ; 17020 } else {; 17021 linger.l_onoff = 0;; 17022 linger.l_linger = 0;; 17023 }; 17024 ; 17025",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:506441,Safety,timeout,timeout,506441,"_timeout + 999) / 1000;; 17012 ; 17013#if defined(GCC_DIAGNOSTIC); 17014#pragma GCC diagnostic pop; 17015#endif; 17016#if defined(_MSC_VER); 17017#pragma warning(pop); 17018#endif; 17019 ; 17020 } else {; 17021 linger.l_onoff = 0;; 17022 linger.l_linger = 0;; 17023 }; 17024 ; 17025 if (linger_timeout < -1) {; 17026 /* Default: don't configure any linger */; 17027 } else if (getsockopt(conn->client.sock,; 17028 SOL_SOCKET,; 17029 SO_ERROR,; 17030#if defined(_WIN32) /* WinSock uses different data type here */; 17031 (char *)&error_code,; 17032#else; 17033 &error_code,; 17034#endif; 17035 &opt_len); 17036 != 0) {; 17037 /* Cannot determine if socket is already closed. This should; 17038 * not occur and never did in a test. Log an error message; 17039 * and continue. */; 17040 mg_cry_internal(conn,; 17041 ""%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s"",; 17042 __func__,; 17043 strerror(ERRNO));; 17044#if defined(_WIN32); 17045 } else if (error_code == WSAECONNRESET) {; 17046#else; 17047 } else if (error_code == ECONNRESET) {; 17048#endif; 17049 /* Socket already closed by client/peer, close socket without linger; 17050 */; 17051 } else {; 17052 ; 17053 /* Set linger timeout */; 17054 if (setsockopt(conn->client.sock,; 17055 SOL_SOCKET,; 17056 SO_LINGER,; 17057 (char *)&linger,; 17058 sizeof(linger)); 17059 != 0) {; 17060 mg_cry_internal(; 17061 conn,; 17062 ""%s: setsockopt(SOL_SOCKET SO_LINGER(%i,%i)) failed: %s"",; 17063 __func__,; 17064 linger.l_onoff,; 17065 linger.l_linger,; 17066 strerror(ERRNO));; 17067 }; 17068 }; 17069 ; 17070 /* Now we know that our FIN is ACK-ed, safe to close */; 17071 closesocket(conn->client.sock);; 17072 conn->client.sock = INVALID_SOCKET;; 17073}; 17074#endif; 17075 ; 17076 ; 17077static void; 17078close_connection(struct mg_connection *conn); 17079{; 17080#if defined(USE_SERVER_STATS); 17081 conn->conn_state = 6; /* to close */; 17082#endif; 17083 ; 17084#if defined(USE_LUA) && defined(USE_WEBSOCKET); 17085 if (conn->lua_websocket_state) ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:506855,Safety,safe,safe,506855,"code,; 17034#endif; 17035 &opt_len); 17036 != 0) {; 17037 /* Cannot determine if socket is already closed. This should; 17038 * not occur and never did in a test. Log an error message; 17039 * and continue. */; 17040 mg_cry_internal(conn,; 17041 ""%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s"",; 17042 __func__,; 17043 strerror(ERRNO));; 17044#if defined(_WIN32); 17045 } else if (error_code == WSAECONNRESET) {; 17046#else; 17047 } else if (error_code == ECONNRESET) {; 17048#endif; 17049 /* Socket already closed by client/peer, close socket without linger; 17050 */; 17051 } else {; 17052 ; 17053 /* Set linger timeout */; 17054 if (setsockopt(conn->client.sock,; 17055 SOL_SOCKET,; 17056 SO_LINGER,; 17057 (char *)&linger,; 17058 sizeof(linger)); 17059 != 0) {; 17060 mg_cry_internal(; 17061 conn,; 17062 ""%s: setsockopt(SOL_SOCKET SO_LINGER(%i,%i)) failed: %s"",; 17063 __func__,; 17064 linger.l_onoff,; 17065 linger.l_linger,; 17066 strerror(ERRNO));; 17067 }; 17068 }; 17069 ; 17070 /* Now we know that our FIN is ACK-ed, safe to close */; 17071 closesocket(conn->client.sock);; 17072 conn->client.sock = INVALID_SOCKET;; 17073}; 17074#endif; 17075 ; 17076 ; 17077static void; 17078close_connection(struct mg_connection *conn); 17079{; 17080#if defined(USE_SERVER_STATS); 17081 conn->conn_state = 6; /* to close */; 17082#endif; 17083 ; 17084#if defined(USE_LUA) && defined(USE_WEBSOCKET); 17085 if (conn->lua_websocket_state) {; 17086 lua_websocket_close(conn, conn->lua_websocket_state);; 17087 conn->lua_websocket_state = NULL;; 17088 }; 17089#endif; 17090 ; 17091 mg_lock_connection(conn);; 17092 ; 17093 /* Set close flag, so keep-alive loops will stop */; 17094 conn->must_close = 1;; 17095 ; 17096 /* call the connection_close callback if assigned */; 17097 if (conn->phys_ctx->callbacks.connection_close != NULL) {; 17098 if (conn->phys_ctx->context_type == CONTEXT_SERVER) {; 17099 conn->phys_ctx->callbacks.connection_close(conn);; 17100 }; 17101 }; 17102 ; 17103 /* Reset user data,",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:510068,Safety,timeout,timeouts,510068,"7141 }; 17142 }; 17143 ; 17144 mg_unlock_connection(conn);; 17145 ; 17146#if defined(USE_SERVER_STATS); 17147 conn->conn_state = 8; /* closed */; 17148#endif; 17149}; 17150 ; 17151 ; 17152void; 17153mg_close_connection(struct mg_connection *conn); 17154{; 17155 if ((conn == NULL) || (conn->phys_ctx == NULL)) {; 17156 return;; 17157 }; 17158 ; 17159#if defined(USE_WEBSOCKET); 17160 if (conn->phys_ctx->context_type == CONTEXT_SERVER) {; 17161 if (conn->in_websocket_handling) {; 17162 /* Set close flag, so the server thread can exit. */; 17163 conn->must_close = 1;; 17164 return;; 17165 }; 17166 }; 17167 if (conn->phys_ctx->context_type == CONTEXT_WS_CLIENT) {; 17168 ; 17169 unsigned int i;; 17170 ; 17171 /* client context: loops must end */; 17172 STOP_FLAG_ASSIGN(&conn->phys_ctx->stop_flag, 1);; 17173 conn->must_close = 1;; 17174 ; 17175 /* We need to get the client thread out of the select/recv call; 17176 * here. */; 17177 /* Since we use a sleep quantum of some seconds to check for recv; 17178 * timeouts, we will just wait a few seconds in mg_join_thread. */; 17179 ; 17180 /* join worker thread */; 17181 for (i = 0; i < conn->phys_ctx->cfg_worker_threads; i++) {; 17182 mg_join_thread(conn->phys_ctx->worker_threadids[i]);; 17183 }; 17184 }; 17185#endif /* defined(USE_WEBSOCKET) */; 17186 ; 17187 close_connection(conn);; 17188 ; 17189#if !defined(NO_SSL) && !defined(USE_MBEDTLS) // TODO: mbedTLS client; 17190 if (((conn->phys_ctx->context_type == CONTEXT_HTTP_CLIENT); 17191 || (conn->phys_ctx->context_type == CONTEXT_WS_CLIENT)); 17192 && (conn->phys_ctx->dd.ssl_ctx != NULL)) {; 17193 SSL_CTX_free(conn->phys_ctx->dd.ssl_ctx);; 17194 }; 17195#endif; 17196 ; 17197#if defined(USE_WEBSOCKET); 17198 if (conn->phys_ctx->context_type == CONTEXT_WS_CLIENT) {; 17199 mg_free(conn->phys_ctx->worker_threadids);; 17200 (void)pthread_mutex_destroy(&conn->mutex);; 17201 mg_free(conn);; 17202 } else if (conn->phys_ctx->context_type == CONTEXT_HTTP_CLIENT) {; 17203 (void)pthread_mut",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:526244,Safety,avoid,avoid,526244,"in of the server (the server domain).; 17681 * Allow full matches (like http://mydomain.com/path/file.ext), and; 17682 * allow subdomain matches (like http://www.mydomain.com/path/file.ext),; 17683 * but do not allow substrings (like; 17684 * http://notmydomain.com/path/file.ext; 17685 * or http://mydomain.com.fake/path/file.ext).; 17686 */; 17687 if (auth_domain_check_enabled) {; 17688 server_domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 17689 server_domain_len = strlen(server_domain);; 17690 if ((server_domain_len == 0) || (hostbegin == NULL)) {; 17691 return 0;; 17692 }; 17693 if ((request_domain_len == server_domain_len); 17694 && (!memcmp(server_domain, hostbegin, server_domain_len))) {; 17695 /* Request is directed to this server - full name match. */; 17696 } else {; 17697 if (request_domain_len < (server_domain_len + 2)) {; 17698 /* Request is directed to another server: The server name; 17699 * is longer than the request name.; 17700 * Drop this case here to avoid overflows in the; 17701 * following checks. */; 17702 return 0;; 17703 }; 17704 if (hostbegin[request_domain_len - server_domain_len - 1] != '.') {; 17705 /* Request is directed to another server: It could be a; 17706 * substring; 17707 * like notmyserver.com */; 17708 return 0;; 17709 }; 17710 if (0; 17711 != memcmp(server_domain,; 17712 hostbegin + request_domain_len - server_domain_len,; 17713 server_domain_len)) {; 17714 /* Request is directed to another server:; 17715 * The server name is different. */; 17716 return 0;; 17717 }; 17718 }; 17719 }; 17720 ; 17721 return hostend;; 17722}; 17723 ; 17724 ; 17725static int; 17726get_message(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err); 17727{; 17728 if (ebuf_len > 0) {; 17729 ebuf[0] = '\0';; 17730 }; 17731 *err = 0;; 17732 ; 17733 reset_per_request_attributes(conn);; 17734 ; 17735 if (!conn) {; 17736 mg_snprintf(conn,; 17737 NULL, /* No truncation check for ebuf */; 17738 ebuf,; 17739 ebuf_len,; 17740 ""%s"",; 17741 ""I",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:527410,Safety,timeout,timeouts,527410,") {; 17705 /* Request is directed to another server: It could be a; 17706 * substring; 17707 * like notmyserver.com */; 17708 return 0;; 17709 }; 17710 if (0; 17711 != memcmp(server_domain,; 17712 hostbegin + request_domain_len - server_domain_len,; 17713 server_domain_len)) {; 17714 /* Request is directed to another server:; 17715 * The server name is different. */; 17716 return 0;; 17717 }; 17718 }; 17719 }; 17720 ; 17721 return hostend;; 17722}; 17723 ; 17724 ; 17725static int; 17726get_message(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err); 17727{; 17728 if (ebuf_len > 0) {; 17729 ebuf[0] = '\0';; 17730 }; 17731 *err = 0;; 17732 ; 17733 reset_per_request_attributes(conn);; 17734 ; 17735 if (!conn) {; 17736 mg_snprintf(conn,; 17737 NULL, /* No truncation check for ebuf */; 17738 ebuf,; 17739 ebuf_len,; 17740 ""%s"",; 17741 ""Internal error"");; 17742 *err = 500;; 17743 return 0;; 17744 }; 17745 ; 17746 /* Set the time the request was received. This value should be used for; 17747 * timeouts. */; 17748 clock_gettime(CLOCK_MONOTONIC, &(conn->req_time));; 17749 ; 17750 conn->request_len =; 17751 read_message(NULL, conn, conn->buf, conn->buf_size, &conn->data_len);; 17752 DEBUG_ASSERT(conn->request_len < 0 || conn->data_len >= conn->request_len);; 17753 if ((conn->request_len >= 0) && (conn->data_len < conn->request_len)) {; 17754 mg_snprintf(conn,; 17755 NULL, /* No truncation check for ebuf */; 17756 ebuf,; 17757 ebuf_len,; 17758 ""%s"",; 17759 ""Invalid message size"");; 17760 *err = 500;; 17761 return 0;; 17762 }; 17763 ; 17764 if ((conn->request_len == 0) && (conn->data_len == conn->buf_size)) {; 17765 mg_snprintf(conn,; 17766 NULL, /* No truncation check for ebuf */; 17767 ebuf,; 17768 ebuf_len,; 17769 ""%s"",; 17770 ""Message too large"");; 17771 *err = 413;; 17772 return 0;; 17773 }; 17774 ; 17775 if (conn->request_len <= 0) {; 17776 if (conn->data_len > 0) {; 17777 mg_snprintf(conn,; 17778 NULL, /* No truncation check for ebuf */; 17779 ebuf,; 17780 e",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:533958,Safety,timeout,timeout,533958,"code == 304) {; 17960 conn->content_len = 0;; 17961 }; 17962 } else {; 17963 /* TODO: we should also consider HEAD method */; 17964 if (((conn->response_info.status_code >= 100); 17965 && (conn->response_info.status_code <= 199)); 17966 || (conn->response_info.status_code == 204); 17967 || (conn->response_info.status_code == 304)) {; 17968 conn->content_len = 0;; 17969 } else {; 17970 conn->content_len = -1; /* unknown content length */; 17971 }; 17972 }; 17973 ; 17974 return 1;; 17975}; 17976 ; 17977 ; 17978int; 17979mg_get_response(struct mg_connection *conn,; 17980 char *ebuf,; 17981 size_t ebuf_len,; 17982 int timeout); 17983{; 17984 int err, ret;; 17985 char txt[32]; /* will not overflow */; 17986 char *save_timeout;; 17987 char *new_timeout;; 17988 ; 17989 if (ebuf_len > 0) {; 17990 ebuf[0] = '\0';; 17991 }; 17992 ; 17993 if (!conn) {; 17994 mg_snprintf(conn,; 17995 NULL, /* No truncation check for ebuf */; 17996 ebuf,; 17997 ebuf_len,; 17998 ""%s"",; 17999 ""Parameter error"");; 18000 return -1;; 18001 }; 18002 ; 18003 /* Reset the previous responses */; 18004 conn->data_len = 0;; 18005 ; 18006 /* Implementation of API function for HTTP clients */; 18007 save_timeout = conn->dom_ctx->config[REQUEST_TIMEOUT];; 18008 ; 18009 if (timeout >= 0) {; 18010 mg_snprintf(conn, NULL, txt, sizeof(txt), ""%i"", timeout);; 18011 new_timeout = txt;; 18012 } else {; 18013 new_timeout = NULL;; 18014 }; 18015 ; 18016 conn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;; 18017 ret = get_response(conn, ebuf, ebuf_len, &err);; 18018 conn->dom_ctx->config[REQUEST_TIMEOUT] = save_timeout;; 18019 ; 18020 /* TODO: here, the URI is the http response code */; 18021 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18022 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18023 ; 18024 /* TODO (mid): Define proper return values - maybe return length?; 18025 * For the first test use <0 for error and >0 for OK */; 18026 return (ret == 0) ? -1 : +1;; 18027}; 1802",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:534586,Safety,timeout,timeout,534586,"code == 304) {; 17960 conn->content_len = 0;; 17961 }; 17962 } else {; 17963 /* TODO: we should also consider HEAD method */; 17964 if (((conn->response_info.status_code >= 100); 17965 && (conn->response_info.status_code <= 199)); 17966 || (conn->response_info.status_code == 204); 17967 || (conn->response_info.status_code == 304)) {; 17968 conn->content_len = 0;; 17969 } else {; 17970 conn->content_len = -1; /* unknown content length */; 17971 }; 17972 }; 17973 ; 17974 return 1;; 17975}; 17976 ; 17977 ; 17978int; 17979mg_get_response(struct mg_connection *conn,; 17980 char *ebuf,; 17981 size_t ebuf_len,; 17982 int timeout); 17983{; 17984 int err, ret;; 17985 char txt[32]; /* will not overflow */; 17986 char *save_timeout;; 17987 char *new_timeout;; 17988 ; 17989 if (ebuf_len > 0) {; 17990 ebuf[0] = '\0';; 17991 }; 17992 ; 17993 if (!conn) {; 17994 mg_snprintf(conn,; 17995 NULL, /* No truncation check for ebuf */; 17996 ebuf,; 17997 ebuf_len,; 17998 ""%s"",; 17999 ""Parameter error"");; 18000 return -1;; 18001 }; 18002 ; 18003 /* Reset the previous responses */; 18004 conn->data_len = 0;; 18005 ; 18006 /* Implementation of API function for HTTP clients */; 18007 save_timeout = conn->dom_ctx->config[REQUEST_TIMEOUT];; 18008 ; 18009 if (timeout >= 0) {; 18010 mg_snprintf(conn, NULL, txt, sizeof(txt), ""%i"", timeout);; 18011 new_timeout = txt;; 18012 } else {; 18013 new_timeout = NULL;; 18014 }; 18015 ; 18016 conn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;; 18017 ret = get_response(conn, ebuf, ebuf_len, &err);; 18018 conn->dom_ctx->config[REQUEST_TIMEOUT] = save_timeout;; 18019 ; 18020 /* TODO: here, the URI is the http response code */; 18021 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18022 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18023 ; 18024 /* TODO (mid): Define proper return values - maybe return length?; 18025 * For the first test use <0 for error and >0 for OK */; 18026 return (ret == 0) ? -1 : +1;; 18027}; 1802",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:534657,Safety,timeout,timeout,534657,"code == 304) {; 17960 conn->content_len = 0;; 17961 }; 17962 } else {; 17963 /* TODO: we should also consider HEAD method */; 17964 if (((conn->response_info.status_code >= 100); 17965 && (conn->response_info.status_code <= 199)); 17966 || (conn->response_info.status_code == 204); 17967 || (conn->response_info.status_code == 304)) {; 17968 conn->content_len = 0;; 17969 } else {; 17970 conn->content_len = -1; /* unknown content length */; 17971 }; 17972 }; 17973 ; 17974 return 1;; 17975}; 17976 ; 17977 ; 17978int; 17979mg_get_response(struct mg_connection *conn,; 17980 char *ebuf,; 17981 size_t ebuf_len,; 17982 int timeout); 17983{; 17984 int err, ret;; 17985 char txt[32]; /* will not overflow */; 17986 char *save_timeout;; 17987 char *new_timeout;; 17988 ; 17989 if (ebuf_len > 0) {; 17990 ebuf[0] = '\0';; 17991 }; 17992 ; 17993 if (!conn) {; 17994 mg_snprintf(conn,; 17995 NULL, /* No truncation check for ebuf */; 17996 ebuf,; 17997 ebuf_len,; 17998 ""%s"",; 17999 ""Parameter error"");; 18000 return -1;; 18001 }; 18002 ; 18003 /* Reset the previous responses */; 18004 conn->data_len = 0;; 18005 ; 18006 /* Implementation of API function for HTTP clients */; 18007 save_timeout = conn->dom_ctx->config[REQUEST_TIMEOUT];; 18008 ; 18009 if (timeout >= 0) {; 18010 mg_snprintf(conn, NULL, txt, sizeof(txt), ""%i"", timeout);; 18011 new_timeout = txt;; 18012 } else {; 18013 new_timeout = NULL;; 18014 }; 18015 ; 18016 conn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;; 18017 ret = get_response(conn, ebuf, ebuf_len, &err);; 18018 conn->dom_ctx->config[REQUEST_TIMEOUT] = save_timeout;; 18019 ; 18020 /* TODO: here, the URI is the http response code */; 18021 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18022 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18023 ; 18024 /* TODO (mid): Define proper return values - maybe return length?; 18025 * For the first test use <0 for error and >0 for OK */; 18026 return (ret == 0) ? -1 : +1;; 18027}; 1802",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:550293,Safety,timeout,timeout,550293,"and; 18513 * conn->phys_ctx must be valid).; 18514 */; 18515static void; 18516process_new_connection(struct mg_connection *conn); 18517{; 18518 struct mg_request_info *ri = &conn->request_info;; 18519 int keep_alive, discard_len;; 18520 char ebuf[100];; 18521 const char *hostend;; 18522 int reqerr, uri_type;; 18523 ; 18524#if defined(USE_SERVER_STATS); 18525 ptrdiff_t mcon = mg_atomic_inc(&(conn->phys_ctx->active_connections));; 18526 mg_atomic_add(&(conn->phys_ctx->total_connections), 1);; 18527 mg_atomic_max(&(conn->phys_ctx->max_active_connections), mcon);; 18528#endif; 18529 ; 18530 DEBUG_TRACE(""Start processing connection from %s"",; 18531 conn->request_info.remote_addr);; 18532 ; 18533 /* Loop over multiple requests sent using the same connection; 18534 * (while ""keep alive""). */; 18535 do {; 18536 DEBUG_TRACE(""calling get_request (%i times for this connection)"",; 18537 conn->handled_requests + 1);; 18538 ; 18539#if defined(USE_SERVER_STATS); 18540 conn->conn_state = 3; /* ready */; 18541#endif; 18542 ; 18543 if (!get_request(conn, ebuf, sizeof(ebuf), &reqerr)) {; 18544 /* The request sent by the client could not be understood by; 18545 * the server, or it was incomplete or a timeout. Send an; 18546 * error message and close the connection. */; 18547 if (reqerr > 0) {; 18548 DEBUG_ASSERT(ebuf[0] != '\0');; 18549 mg_send_http_error(conn, reqerr, ""%s"", ebuf);; 18550 }; 18551 ; 18552 } else if (strcmp(ri->http_version, ""1.0""); 18553 && strcmp(ri->http_version, ""1.1"")) {; 18554 /* HTTP/2 is not allowed here */; 18555 mg_snprintf(conn,; 18556 NULL, /* No truncation check for ebuf */; 18557 ebuf,; 18558 sizeof(ebuf),; 18559 ""Bad HTTP version: [%s]"",; 18560 ri->http_version);; 18561 mg_send_http_error(conn, 505, ""%s"", ebuf);; 18562 }; 18563 ; 18564 if (ebuf[0] == '\0') {; 18565 uri_type = get_uri_type(conn->request_info.request_uri);; 18566 switch (uri_type) {; 18567 case 1:; 18568 /* Asterisk */; 18569 conn->request_info.local_uri_raw = 0;; 18570 /* TODO: Deal with '",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:576157,Safety,avoid,avoid,576157," 0) {; 19283 for (i = 0; i < ctx->num_listening_sockets; i++) {; 19284 /* NOTE(lsm): on QNX, poll() returns POLLRDNORM after the; 19285 * successful poll, and POLLIN is defined as; 19286 * (POLLRDNORM | POLLRDBAND); 19287 * Therefore, we're checking pfd[i].revents & POLLIN, not; 19288 * pfd[i].revents == POLLIN. */; 19289 if (STOP_FLAG_IS_ZERO(&ctx->stop_flag); 19290 && (pfd[i].revents & POLLIN)) {; 19291 accept_new_connection(&ctx->listening_sockets[i], ctx);; 19292 }; 19293 }; 19294 }; 19295 }; 19296 ; 19297 /* Here stop_flag is 1 - Initiate shutdown. */; 19298 DEBUG_TRACE(""%s"", ""stopping workers"");; 19299 ; 19300 /* Stop signal received: somebody called mg_stop. Quit. */; 19301 close_all_listening_sockets(ctx);; 19302 ; 19303 /* Wakeup workers that are waiting for connections to handle. */; 19304#if defined(ALTERNATIVE_QUEUE); 19305 for (i = 0; i < ctx->cfg_worker_threads; i++) {; 19306 event_signal(ctx->client_wait_events[i]);; 19307 }; 19308#else; 19309 (void)pthread_mutex_lock(&ctx->thread_mutex);; 19310 pthread_cond_broadcast(&ctx->sq_full);; 19311 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 19312#endif; 19313 ; 19314 /* Join all worker threads to avoid leaking threads. */; 19315 workerthreadcount = ctx->cfg_worker_threads;; 19316 for (i = 0; i < workerthreadcount; i++) {; 19317 if (ctx->worker_threadids[i] != 0) {; 19318 mg_join_thread(ctx->worker_threadids[i]);; 19319 }; 19320 }; 19321 ; 19322#if defined(USE_LUA); 19323 /* Free Lua state of lua background task */; 19324 if (ctx->lua_background_state) {; 19325 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 19326 ctx->lua_bg_log_available = 0;; 19327 ; 19328 /* call ""stop()"" in Lua */; 19329 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19330 lua_getglobal(lstate, ""stop"");; 19331 if (lua_type(lstate, -1) == LUA_TFUNCTION) {; 19332 int ret = lua_pcall(lstate, /* args */ 0, /* results */ 0, 0);; 19333 if (ret != 0) {; 19334 struct mg_connection fc;; 19335 lua_cry(fake_connection(&fc, ctx),; 19336 ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:587323,Safety,abort,abort,587323,"9659 }; 19660 return NULL;; 19661 }; 19662 ; 19663 /* Random number generator will initialize at the first call */; 19664 ctx->dd.auth_nonce_mask =; 19665 (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);; 19666 ; 19667 /* Save started thread index to reuse in other external API calls; 19668 * For the sake of thread synchronization all non-civetweb threads; 19669 * can be considered as single external thread */; 19670 ctx->starter_thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);; 19671 tls.is_master = -1; /* Thread calling mg_start */; 19672 tls.thread_idx = ctx->starter_thread_idx;; 19673#if defined(_WIN32); 19674 tls.pthread_cond_helper_mutex = NULL;; 19675#endif; 19676 pthread_setspecific(sTlsKey, &tls);; 19677 ; 19678 ok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));; 19679#if !defined(ALTERNATIVE_QUEUE); 19680 ok &= (0 == pthread_cond_init(&ctx->sq_empty, NULL));; 19681 ok &= (0 == pthread_cond_init(&ctx->sq_full, NULL));; 19682 ctx->sq_blocked = 0;; 19683#endif; 19684 ok &= (0 == pthread_mutex_init(&ctx->nonce_mutex, &pthread_mutex_attr));; 19685#if defined(USE_LUA); 19686 ok &= (0 == pthread_mutex_init(&ctx->lua_bg_mutex, &pthread_mutex_attr));; 19687#endif; 19688 if (!ok) {; 19689 const char *err_msg =; 19690 ""Cannot initialize thread synchronization objects"";; 19691 /* Fatal error - abort start. However, this situation should never; 19692 * occur in practice. */; 19693 ; 19694 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19695 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19696 mg_snprintf(NULL,; 19697 NULL, /* No truncation check for error buffers */; 19698 error->text,; 19699 error->text_buffer_size,; 19700 ""%s"",; 19701 err_msg);; 19702 }; 19703 ; 19704 mg_free(ctx);; 19705 pthread_setspecific(sTlsKey, NULL);; 19706 return NULL;; 19707 }; 19708 ; 19709 if ((init != NULL) && (init->callbacks != NULL)) {; 19710 /* Set all callbacks except exit_context. */; 19711 ctx->callbacks = *init->callbacks;; 19712 exit_callba",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:596694,Safety,abort,abort,596694,"r, opt_vec.len) == 0); 19922 break;; 19923 }; 19924 lua_rawset(state, -3);; 19925 lua_pop(state, 1);; 19926 }; 19927 ; 19928 /* Call script */; 19929 state = mg_lua_context_script_run(state,; 19930 ctx->dd.config[LUA_BACKGROUND_SCRIPT],; 19931 ctx,; 19932 ebuf,; 19933 sizeof(ebuf));; 19934 if (!state) {; 19935 mg_cry_ctx_internal(ctx,; 19936 ""lua_background_script start error: %s"",; 19937 ebuf);; 19938 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19939 mg_snprintf(NULL,; 19940 NULL, /* No truncation check for error buffers */; 19941 error->text,; 19942 error->text_buffer_size,; 19943 ""Error in script %s: %s"",; 19944 config_options[DOCUMENT_ROOT].name,; 19945 ebuf);; 19946 }; 19947 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19948 ; 19949 free_context(ctx);; 19950 pthread_setspecific(sTlsKey, NULL);; 19951 return NULL;; 19952 }; 19953 ; 19954 /* state remains valid */; 19955 ctx->lua_background_state = (void *)state;; 19956 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19957 ; 19958 } else {; 19959 ctx->lua_background_state = 0;; 19960 }; 19961#endif; 19962 ; 19963 /* Step by step initialization of ctx - depending on build options */; 19964#if !defined(NO_FILESYSTEMS); 19965 if (!set_gpass_option(ctx, NULL)) {; 19966 const char *err_msg = ""Invalid global password file"";; 19967 /* Fatal error - abort start. */; 19968 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19969 ; 19970 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19971 mg_snprintf(NULL,; 19972 NULL, /* No truncation check for error buffers */; 19973 error->text,; 19974 error->text_buffer_size,; 19975 ""%s"",; 19976 err_msg);; 19977 }; 19978 free_context(ctx);; 19979 pthread_setspecific(sTlsKey, NULL);; 19980 return NULL;; 19981 }; 19982#endif; 19983 ; 19984#if defined(USE_MBEDTLS); 19985 if (!mg_sslctx_init(ctx, NULL)) {; 19986 const char *err_msg = ""Error initializing SSL context"";; 19987 /* Fatal error - abort start. */; 19988 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19989 ; 19990 if ((error !=",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:597280,Safety,abort,abort,597280,",; 19944 config_options[DOCUMENT_ROOT].name,; 19945 ebuf);; 19946 }; 19947 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19948 ; 19949 free_context(ctx);; 19950 pthread_setspecific(sTlsKey, NULL);; 19951 return NULL;; 19952 }; 19953 ; 19954 /* state remains valid */; 19955 ctx->lua_background_state = (void *)state;; 19956 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19957 ; 19958 } else {; 19959 ctx->lua_background_state = 0;; 19960 }; 19961#endif; 19962 ; 19963 /* Step by step initialization of ctx - depending on build options */; 19964#if !defined(NO_FILESYSTEMS); 19965 if (!set_gpass_option(ctx, NULL)) {; 19966 const char *err_msg = ""Invalid global password file"";; 19967 /* Fatal error - abort start. */; 19968 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19969 ; 19970 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19971 mg_snprintf(NULL,; 19972 NULL, /* No truncation check for error buffers */; 19973 error->text,; 19974 error->text_buffer_size,; 19975 ""%s"",; 19976 err_msg);; 19977 }; 19978 free_context(ctx);; 19979 pthread_setspecific(sTlsKey, NULL);; 19980 return NULL;; 19981 }; 19982#endif; 19983 ; 19984#if defined(USE_MBEDTLS); 19985 if (!mg_sslctx_init(ctx, NULL)) {; 19986 const char *err_msg = ""Error initializing SSL context"";; 19987 /* Fatal error - abort start. */; 19988 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19989 ; 19990 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19991 mg_snprintf(NULL,; 19992 NULL, /* No truncation check for error buffers */; 19993 error->text,; 19994 error->text_buffer_size,; 19995 ""%s"",; 19996 err_msg);; 19997 }; 19998 free_context(ctx);; 19999 pthread_setspecific(sTlsKey, NULL);; 20000 return NULL;; 20001 }; 20002 ; 20003#elif !defined(NO_SSL); 20004 if (!init_ssl_ctx(ctx, NULL)) {; 20005 const char *err_msg = ""Error initializing SSL context"";; 20006 /* Fatal error - abort start. */; 20007 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20008 ; 20009 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20010 mg_snpri",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:597849,Safety,abort,abort,597849,"(!set_gpass_option(ctx, NULL)) {; 19966 const char *err_msg = ""Invalid global password file"";; 19967 /* Fatal error - abort start. */; 19968 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19969 ; 19970 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19971 mg_snprintf(NULL,; 19972 NULL, /* No truncation check for error buffers */; 19973 error->text,; 19974 error->text_buffer_size,; 19975 ""%s"",; 19976 err_msg);; 19977 }; 19978 free_context(ctx);; 19979 pthread_setspecific(sTlsKey, NULL);; 19980 return NULL;; 19981 }; 19982#endif; 19983 ; 19984#if defined(USE_MBEDTLS); 19985 if (!mg_sslctx_init(ctx, NULL)) {; 19986 const char *err_msg = ""Error initializing SSL context"";; 19987 /* Fatal error - abort start. */; 19988 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19989 ; 19990 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19991 mg_snprintf(NULL,; 19992 NULL, /* No truncation check for error buffers */; 19993 error->text,; 19994 error->text_buffer_size,; 19995 ""%s"",; 19996 err_msg);; 19997 }; 19998 free_context(ctx);; 19999 pthread_setspecific(sTlsKey, NULL);; 20000 return NULL;; 20001 }; 20002 ; 20003#elif !defined(NO_SSL); 20004 if (!init_ssl_ctx(ctx, NULL)) {; 20005 const char *err_msg = ""Error initializing SSL context"";; 20006 /* Fatal error - abort start. */; 20007 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20008 ; 20009 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20010 mg_snprintf(NULL,; 20011 NULL, /* No truncation check for error buffers */; 20012 error->text,; 20013 error->text_buffer_size,; 20014 ""%s"",; 20015 err_msg);; 20016 }; 20017 free_context(ctx);; 20018 pthread_setspecific(sTlsKey, NULL);; 20019 return NULL;; 20020 }; 20021#endif; 20022 ; 20023 if (!set_ports_option(ctx)) {; 20024 const char *err_msg = ""Failed to setup server ports"";; 20025 /* Fatal error - abort start. */; 20026 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20027 ; 20028 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20029 mg_snprintf(NULL,; 20030 NULL, /* No ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:598398,Safety,abort,abort,598398,"ned(USE_MBEDTLS); 19985 if (!mg_sslctx_init(ctx, NULL)) {; 19986 const char *err_msg = ""Error initializing SSL context"";; 19987 /* Fatal error - abort start. */; 19988 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19989 ; 19990 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19991 mg_snprintf(NULL,; 19992 NULL, /* No truncation check for error buffers */; 19993 error->text,; 19994 error->text_buffer_size,; 19995 ""%s"",; 19996 err_msg);; 19997 }; 19998 free_context(ctx);; 19999 pthread_setspecific(sTlsKey, NULL);; 20000 return NULL;; 20001 }; 20002 ; 20003#elif !defined(NO_SSL); 20004 if (!init_ssl_ctx(ctx, NULL)) {; 20005 const char *err_msg = ""Error initializing SSL context"";; 20006 /* Fatal error - abort start. */; 20007 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20008 ; 20009 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20010 mg_snprintf(NULL,; 20011 NULL, /* No truncation check for error buffers */; 20012 error->text,; 20013 error->text_buffer_size,; 20014 ""%s"",; 20015 err_msg);; 20016 }; 20017 free_context(ctx);; 20018 pthread_setspecific(sTlsKey, NULL);; 20019 return NULL;; 20020 }; 20021#endif; 20022 ; 20023 if (!set_ports_option(ctx)) {; 20024 const char *err_msg = ""Failed to setup server ports"";; 20025 /* Fatal error - abort start. */; 20026 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20027 ; 20028 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20029 mg_snprintf(NULL,; 20030 NULL, /* No truncation check for error buffers */; 20031 error->text,; 20032 error->text_buffer_size,; 20033 ""%s"",; 20034 err_msg);; 20035 }; 20036 free_context(ctx);; 20037 pthread_setspecific(sTlsKey, NULL);; 20038 return NULL;; 20039 }; 20040 ; 20041 ; 20042#if !defined(_WIN32) && !defined(__ZEPHYR__); 20043 if (!set_uid_option(ctx)) {; 20044 const char *err_msg = ""Failed to run as configured user"";; 20045 /* Fatal error - abort start. */; 20046 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20047 ; 20048 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20049",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:598995,Safety,abort,abort,598995,"efined(NO_SSL); 20004 if (!init_ssl_ctx(ctx, NULL)) {; 20005 const char *err_msg = ""Error initializing SSL context"";; 20006 /* Fatal error - abort start. */; 20007 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20008 ; 20009 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20010 mg_snprintf(NULL,; 20011 NULL, /* No truncation check for error buffers */; 20012 error->text,; 20013 error->text_buffer_size,; 20014 ""%s"",; 20015 err_msg);; 20016 }; 20017 free_context(ctx);; 20018 pthread_setspecific(sTlsKey, NULL);; 20019 return NULL;; 20020 }; 20021#endif; 20022 ; 20023 if (!set_ports_option(ctx)) {; 20024 const char *err_msg = ""Failed to setup server ports"";; 20025 /* Fatal error - abort start. */; 20026 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20027 ; 20028 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20029 mg_snprintf(NULL,; 20030 NULL, /* No truncation check for error buffers */; 20031 error->text,; 20032 error->text_buffer_size,; 20033 ""%s"",; 20034 err_msg);; 20035 }; 20036 free_context(ctx);; 20037 pthread_setspecific(sTlsKey, NULL);; 20038 return NULL;; 20039 }; 20040 ; 20041 ; 20042#if !defined(_WIN32) && !defined(__ZEPHYR__); 20043 if (!set_uid_option(ctx)) {; 20044 const char *err_msg = ""Failed to run as configured user"";; 20045 /* Fatal error - abort start. */; 20046 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20047 ; 20048 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20049 mg_snprintf(NULL,; 20050 NULL, /* No truncation check for error buffers */; 20051 error->text,; 20052 error->text_buffer_size,; 20053 ""%s"",; 20054 err_msg);; 20055 }; 20056 free_context(ctx);; 20057 pthread_setspecific(sTlsKey, NULL);; 20058 return NULL;; 20059 }; 20060#endif; 20061 ; 20062 if (!set_acl_option(ctx)) {; 20063 const char *err_msg = ""Failed to setup access control list"";; 20064 /* Fatal error - abort start. */; 20065 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20066 ; 20067 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20068 mg_snprintf(NULL,;",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:599549,Safety,abort,abort,599549,"f (!set_ports_option(ctx)) {; 20024 const char *err_msg = ""Failed to setup server ports"";; 20025 /* Fatal error - abort start. */; 20026 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20027 ; 20028 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20029 mg_snprintf(NULL,; 20030 NULL, /* No truncation check for error buffers */; 20031 error->text,; 20032 error->text_buffer_size,; 20033 ""%s"",; 20034 err_msg);; 20035 }; 20036 free_context(ctx);; 20037 pthread_setspecific(sTlsKey, NULL);; 20038 return NULL;; 20039 }; 20040 ; 20041 ; 20042#if !defined(_WIN32) && !defined(__ZEPHYR__); 20043 if (!set_uid_option(ctx)) {; 20044 const char *err_msg = ""Failed to run as configured user"";; 20045 /* Fatal error - abort start. */; 20046 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20047 ; 20048 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20049 mg_snprintf(NULL,; 20050 NULL, /* No truncation check for error buffers */; 20051 error->text,; 20052 error->text_buffer_size,; 20053 ""%s"",; 20054 err_msg);; 20055 }; 20056 free_context(ctx);; 20057 pthread_setspecific(sTlsKey, NULL);; 20058 return NULL;; 20059 }; 20060#endif; 20061 ; 20062 if (!set_acl_option(ctx)) {; 20063 const char *err_msg = ""Failed to setup access control list"";; 20064 /* Fatal error - abort start. */; 20065 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20066 ; 20067 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20068 mg_snprintf(NULL,; 20069 NULL, /* No truncation check for error buffers */; 20070 error->text,; 20071 error->text_buffer_size,; 20072 ""%s"",; 20073 err_msg);; 20074 }; 20075 free_context(ctx);; 20076 pthread_setspecific(sTlsKey, NULL);; 20077 return NULL;; 20078 }; 20079 ; 20080 ctx->cfg_worker_threads = ((unsigned int)(workerthreadcount));; 20081 ctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20082 sizeof(pthread_t),; 20083 ctx);; 20084 ; 20085 if (ctx->worker_threadids == NULL) {; 20086 const char *err_msg = ""Not enough memory for worker thread ID array"";;",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:636615,Safety,safe,safe,636615,"ntf(NULL,; 21331 NULL,; 21332 block,; 21333 sizeof(block),; 21334 ""%s%s\""data\"" : {%s""; 21335 ""\""read\"" : %"" INT64_FMT "",%s""; 21336 ""\""written\"" : %"" INT64_FMT ""%s""; 21337 ""}"",; 21338 (connection_info_length > 1 ? "","" : """"),; 21339 eol,; 21340 eol,; 21341 conn->consumed_content,; 21342 eol,; 21343 conn->num_bytes_sent,; 21344 eol);; 21345 connection_info_length += mg_str_append(&buffer, end, block);; 21346 }; 21347 ; 21348 /* State */; 21349 mg_snprintf(NULL,; 21350 NULL,; 21351 block,; 21352 sizeof(block),; 21353 ""%s%s\""state\"" : \""%s\"""",; 21354 (connection_info_length > 1 ? "","" : """"),; 21355 eol,; 21356 state_str);; 21357 connection_info_length += mg_str_append(&buffer, end, block);; 21358 ; 21359 /* Terminate string */; 21360 if (append_eoobj) {; 21361 strcat(append_eoobj, eoobj);; 21362 }; 21363 connection_info_length += sizeof(eoobj) - 1;; 21364 ; 21365 return (int)connection_info_length;; 21366}; 21367#endif; 21368 ; 21369 ; 21370/* Initialize this library. This function does not need to be thread safe.; 21371 */; 21372unsigned; 21373mg_init_library(unsigned features); 21374{; 21375 unsigned features_to_init = mg_check_feature(features & 0xFFu);; 21376 unsigned features_inited = features_to_init;; 21377 ; 21378 if (mg_init_library_called <= 0) {; 21379 /* Not initialized yet */; 21380 if (0 != pthread_mutex_init(&global_lock_mutex, NULL)) {; 21381 return 0;; 21382 }; 21383 }; 21384 ; 21385 mg_global_lock();; 21386 ; 21387 if (mg_init_library_called <= 0) {; 21388#if defined(_WIN32); 21389 int file_mutex_init = 1;; 21390 int wsa = 1;; 21391#else; 21392 int mutexattr_init = 1;; 21393#endif; 21394 int failed = 1;; 21395 int key_create = pthread_key_create(&sTlsKey, tls_dtor);; 21396 ; 21397 if (key_create == 0) {; 21398#if defined(_WIN32); 21399 file_mutex_init =; 21400 pthread_mutex_init(&global_log_file_lock, &pthread_mutex_attr);; 21401 if (file_mutex_init == 0) {; 21402 /* Start WinSock */; 21403 WSADATA data;; 21404 failed = wsa = WSAStartup(MAKEWORD(2, 2), &",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:659511,Safety,timeout,timeout,659511,"finition civetweb.c:486; parse_http_headersstatic int parse_http_headers(char **buf, struct mg_header hdr[(64)])Definition civetweb.c:10420; mg_get_option#define mg_get_optionDefinition civetweb.c:3149; ssl_get_protocolstatic long ssl_get_protocol(int version_id)Definition civetweb.c:16230; mg_get_user_context_datavoid * mg_get_user_context_data(const struct mg_connection *conn)Definition civetweb.c:3166; mg_init_library_calledstatic int mg_init_library_calledDefinition civetweb.c:1549; mg_store_bodylong long mg_store_body(struct mg_connection *conn, const char *path)Definition civetweb.c:10317; mg_downloadstruct mg_connection * mg_download(const char *host, int port, int use_ssl, char *ebuf, size_t ebuf_len, const char *fmt,...)Definition civetweb.c:18031; DEBUG_ASSERT#define DEBUG_ASSERT(cond)Definition civetweb.c:260; mg_str_appendstatic size_t mg_str_append(char **dst, char *end, const char *src)Definition civetweb.c:20559; pull_innerstatic int pull_inner(FILE *fp, struct mg_connection *conn, char *buf, int len, double timeout)Definition civetweb.c:6184; INT64_FMT#define INT64_FMTDefinition civetweb.c:923; mg_get_responseint mg_get_response(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int timeout)Definition civetweb.c:17979; MG_FILE_COMPRESSION_SIZE_LIMIT#define MG_FILE_COMPRESSION_SIZE_LIMITDefinition civetweb.c:476; USA_IN_PORT_UNSAFE#define USA_IN_PORT_UNSAFE(s)Definition civetweb.c:1851; mg_connect_client_implstatic struct mg_connection * mg_connect_client_impl(const struct mg_client_options *client_options, int use_ssl, char *ebuf, size_t ebuf_len)Definition civetweb.c:17216; mg_check_featureunsigned mg_check_feature(unsigned feature)Definition civetweb.c:20496; mg_read_innerstatic int mg_read_inner(struct mg_connection *conn, void *buf, size_t len)Definition civetweb.c:6468; mg_send_http_error_implstatic int mg_send_http_error_impl(struct mg_connection *conn, int status, const char *fmt, va_list args)Definition civetweb.c:4350; mg_startstruct m",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:659696,Safety,timeout,timeout,659696,"civetweb.c:3149; ssl_get_protocolstatic long ssl_get_protocol(int version_id)Definition civetweb.c:16230; mg_get_user_context_datavoid * mg_get_user_context_data(const struct mg_connection *conn)Definition civetweb.c:3166; mg_init_library_calledstatic int mg_init_library_calledDefinition civetweb.c:1549; mg_store_bodylong long mg_store_body(struct mg_connection *conn, const char *path)Definition civetweb.c:10317; mg_downloadstruct mg_connection * mg_download(const char *host, int port, int use_ssl, char *ebuf, size_t ebuf_len, const char *fmt,...)Definition civetweb.c:18031; DEBUG_ASSERT#define DEBUG_ASSERT(cond)Definition civetweb.c:260; mg_str_appendstatic size_t mg_str_append(char **dst, char *end, const char *src)Definition civetweb.c:20559; pull_innerstatic int pull_inner(FILE *fp, struct mg_connection *conn, char *buf, int len, double timeout)Definition civetweb.c:6184; INT64_FMT#define INT64_FMTDefinition civetweb.c:923; mg_get_responseint mg_get_response(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int timeout)Definition civetweb.c:17979; MG_FILE_COMPRESSION_SIZE_LIMIT#define MG_FILE_COMPRESSION_SIZE_LIMITDefinition civetweb.c:476; USA_IN_PORT_UNSAFE#define USA_IN_PORT_UNSAFE(s)Definition civetweb.c:1851; mg_connect_client_implstatic struct mg_connection * mg_connect_client_impl(const struct mg_client_options *client_options, int use_ssl, char *ebuf, size_t ebuf_len)Definition civetweb.c:17216; mg_check_featureunsigned mg_check_feature(unsigned feature)Definition civetweb.c:20496; mg_read_innerstatic int mg_read_inner(struct mg_connection *conn, void *buf, size_t len)Definition civetweb.c:6468; mg_send_http_error_implstatic int mg_send_http_error_impl(struct mg_connection *conn, int status, const char *fmt, va_list args)Definition civetweb.c:4350; mg_startstruct mg_context * mg_start(const struct mg_callbacks *callbacks, void *user_data, const char **options)Definition civetweb.c:20284; MG_FOPEN_MODE_READ#define MG_FOPEN_MODE_READDefinition civetw",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:689655,Safety,timeout,timeout,689655,"RPRETER@ CGI2_INTERPRETERDefinition civetweb.c:1960; INDEX_FILES@ INDEX_FILESDefinition civetweb.c:1991; EXTRA_MIME_TYPES@ EXTRA_MIME_TYPESDefinition civetweb.c:1993; initialize_opensslstatic int initialize_openssl(char *ebuf, size_t ebuf_len)Definition civetweb.c:16034; substitute_index_filestatic int substitute_index_file(struct mg_connection *conn, char *path, size_t path_len, struct mg_file_stat *filestat)Definition civetweb.c:7389; mg_stopvoid mg_stop(struct mg_context *ctx)Definition civetweb.c:19493; STRUCT_FILE_INITIALIZER#define STRUCT_FILE_INITIALIZERDefinition civetweb.c:1882; thread_idx_maxstatic volatile ptrdiff_t thread_idx_maxDefinition civetweb.c:1573; mg_get_user_datavoid * mg_get_user_data(const struct mg_context *ctx)Definition civetweb.c:3159; scan_directorystatic int scan_directory(struct mg_connection *conn, const char *dir, void *data, int(*cb)(struct de *, void *))Definition civetweb.c:9449; push_innerstatic int push_inner(struct mg_context *ctx, FILE *fp, SOCKET sock, SSL *ssl, const char *buf, int len, double timeout)Definition civetweb.c:5970; mg_versionconst char * mg_version(void)Definition civetweb.c:3480; get_randomstatic uint64_t get_random(void)Definition civetweb.c:5879; mg_lock_connectionvoid mg_lock_connection(struct mg_connection *conn)Definition civetweb.c:12306; mg_send_file_bodyint mg_send_file_body(struct mg_connection *conn, const char *path)Definition civetweb.c:10146; mg_cry#define mg_cryDefinition civetweb.c:3476; is_valid_http_methodstatic int is_valid_http_method(const char *method)Definition civetweb.c:10589; url_decode_in_placestatic void url_decode_in_place(char *buf)Definition civetweb.c:6982; civetweb.h; mg_websocket_client_writeint mg_websocket_client_write(struct mg_connection *conn, int opcode, const char *data, size_t data_len); MG_MAX_HEADERS#define MG_MAX_HEADERSDefinition civetweb.h:141; mg_response_header_addint mg_response_header_add(struct mg_connection *conn, const char *header, const char *value, int va",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:3528,Security,expose,expose,3528,"ARNINGS /* Disable deprecation warning in VS2005 */; 51#endif; 52#if !defined(_WIN32_WINNT) /* defined for tdm-gcc so we can use getnameinfo */; 53#define _WIN32_WINNT 0x0502; 54#endif; 55#else; 56#if !defined(_GNU_SOURCE); 57#define _GNU_SOURCE /* for setgroups(), pthread_setname_np() */; 58#endif; 59#if defined(__linux__) && !defined(_XOPEN_SOURCE); 60#define _XOPEN_SOURCE 600 /* For flockfile() on Linux */; 61#endif; 62#if defined(__LSB_VERSION__) || defined(__sun); 63#define NEED_TIMEGM; 64#define NO_THREAD_NAME; 65#endif; 66#if !defined(_LARGEFILE_SOURCE); 67#define _LARGEFILE_SOURCE /* For fseeko(), ftello() */; 68#endif; 69#if !defined(_FILE_OFFSET_BITS); 70#define _FILE_OFFSET_BITS 64 /* Use 64-bit file offsets by default */; 71#endif; 72#if !defined(__STDC_FORMAT_MACROS); 73#define __STDC_FORMAT_MACROS /* <inttypes.h> wants this for C++ */; 74#endif; 75#if !defined(__STDC_LIMIT_MACROS); 76#define __STDC_LIMIT_MACROS /* C++ wants that for INT64_MAX */; 77#endif; 78#if !defined(_DARWIN_UNLIMITED_SELECT); 79#define _DARWIN_UNLIMITED_SELECT; 80#endif; 81#if defined(__sun); 82#define __EXTENSIONS__ /* to expose flockfile and friends in stdio.h */; 83#define __inline inline /* not recognized on older compiler versions */; 84#endif; 85#endif; 86 ; 87#if defined(__clang__); 88/* Enable reserved-id-macro warning again. */; 89#pragma GCC diagnostic pop; 90#endif; 91 ; 92 ; 93#if defined(USE_LUA); 94#define USE_TIMERS; 95#endif; 96 ; 97#if defined(_MSC_VER); 98/* 'type cast' : conversion from 'int' to 'HANDLE' of greater size */; 99#pragma warning(disable : 4306); 100/* conditional expression is constant: introduced by FD_SET(..) */; 101#pragma warning(disable : 4127); 102/* non-constant aggregate initializer: issued due to missing C99 support */; 103#pragma warning(disable : 4204); 104/* padding added after data member */; 105#pragma warning(disable : 4820); 106/* not defined as a preprocessor macro, replacing with '0' for '#if/#elif' */; 107#pragma warning(disable :",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:6436,Security,access,access,6436,"zeof(void *) == 4 || sizeof(void *) == 8,; 131 ""pointer data type size check"");; 132mg_static_assert(sizeof(void *) >= sizeof(int), ""data type size check"");; 133 ; 134 ; 135/* Select queue implementation. Diagnosis features originally only implemented; 136 * for the ""ALTERNATIVE_QUEUE"" have been ported to the previous queue; 137 * implementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping between URLs and local; 161 * file names.; 162 * NO_FILESYSTEM = do not access any file at all. Useful for embedded; 163 * devices without file system. Logging to files in not available; 164 * (use callbacks instead) and API functions like mg_send_file are not; 165 * available.; 166 * If NO_FILESYSTEM is set, NO_FILES must be set as well.; 167 */; 168#error ""Inconsistent build flags, NO_FILESYSTEMS requires NO_FILES""; 169#endif; 170 ; 171/* DTL -- including winsock2.h works better if le",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:6592,Security,access,access,6592,"lementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping between URLs and local; 161 * file names.; 162 * NO_FILESYSTEM = do not access any file at all. Useful for embedded; 163 * devices without file system. Logging to files in not available; 164 * (use callbacks instead) and API functions like mg_send_file are not; 165 * available.; 166 * If NO_FILESYSTEM is set, NO_FILES must be set as well.; 167 */; 168#error ""Inconsistent build flags, NO_FILESYSTEMS requires NO_FILES""; 169#endif; 170 ; 171/* DTL -- including winsock2.h works better if lean and mean */; 172#if !defined(WIN32_LEAN_AND_MEAN); 173#define WIN32_LEAN_AND_MEAN; 174#endif; 175 ; 176#if defined(__SYMBIAN32__); 177/* According to https://en.wikipedia.org/wiki/Symbian#History,; 178 * Symbian is no longer maintained since 2014-01-01.; 179 * Support for Symbian has been removed from CivetWeb; 180 */; 181#error ""S",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:6885,Security,access,access,6885,"eads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping between URLs and local; 161 * file names.; 162 * NO_FILESYSTEM = do not access any file at all. Useful for embedded; 163 * devices without file system. Logging to files in not available; 164 * (use callbacks instead) and API functions like mg_send_file are not; 165 * available.; 166 * If NO_FILESYSTEM is set, NO_FILES must be set as well.; 167 */; 168#error ""Inconsistent build flags, NO_FILESYSTEMS requires NO_FILES""; 169#endif; 170 ; 171/* DTL -- including winsock2.h works better if lean and mean */; 172#if !defined(WIN32_LEAN_AND_MEAN); 173#define WIN32_LEAN_AND_MEAN; 174#endif; 175 ; 176#if defined(__SYMBIAN32__); 177/* According to https://en.wikipedia.org/wiki/Symbian#History,; 178 * Symbian is no longer maintained since 2014-01-01.; 179 * Support for Symbian has been removed from CivetWeb; 180 */; 181#error ""Symbian is no longer maintained. CivetWeb no longer supports Symbian.""; 182#endif /* __SYMBIAN32__ */; 183 ; 184#if defined(__ZEPHYR__); 185#include <time.h>; 186 ; 187#include <ctype.h>; 188#include <net/socket.h>; 189#include <posix/pthread",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:21923,Security,access,access,21923,,MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:57228,Security,access,access,57228,"{; 1838 if (s->sa.sa_family == AF_INET); 1839 return s->sin.sin_port;; 1840#if defined(USE_IPV6); 1841 if (s->sa.sa_family == AF_INET6); 1842 return s->sin6.sin6_port;; 1843#endif; 1844 return 0;; 1845}; 1846#endif; 1847#if defined(USE_IPV6); 1848#define USA_IN_PORT_UNSAFE(s) \; 1849 (((s)->sa.sa_family == AF_INET6) ? (s)->sin6.sin6_port : (s)->sin.sin_port); 1850#else; 1851#define USA_IN_PORT_UNSAFE(s) ((s)->sin.sin_port); 1852#endif; 1853 ; 1854/* Describes a string (chunk of memory). */; 1855struct vec {; 1856 const char *ptr;; 1857 size_t len;; 1858};; 1859 ; 1860struct mg_file_stat {; 1861 /* File properties filled by mg_stat: */; 1862 uint64_t size;; 1863 time_t last_modified;; 1864 int is_directory; /* Set to 1 if mg_stat is called for a directory */; 1865 int is_gzipped; /* Set to 1 if the content is gzipped, in which; 1866 * case we need a ""Content-Eencoding: gzip"" header */; 1867 int location; /* 0 = nowhere, 1 = on disk, 2 = in memory */; 1868};; 1869 ; 1870 ; 1871struct mg_file_access {; 1872 /* File properties filled by mg_fopen: */; 1873 FILE *fp;; 1874};; 1875 ; 1876struct mg_file {; 1877 struct mg_file_stat stat;; 1878 struct mg_file_access access;; 1879};; 1880 ; 1881 ; 1882#define STRUCT_FILE_INITIALIZER \; 1883 { \; 1884 {(uint64_t)0, (time_t)0, 0, 0, 0}, \; 1885 { \; 1886 (FILE *)NULL \; 1887 } \; 1888 }; 1889 ; 1890 ; 1891/* Describes listening socket, or socket which was accept()-ed by the master; 1892 * thread and queued for future handling by the worker thread. */; 1893struct socket {; 1894 SOCKET sock; /* Listening socket */; 1895 union usa lsa; /* Local socket address */; 1896 union usa rsa; /* Remote socket address */; 1897 unsigned char is_ssl; /* Is port SSL-ed */; 1898 unsigned char ssl_redir; /* Is port supposed to redirect everything to SSL; 1899 * port */; 1900 unsigned char in_use; /* 0: invalid, 1: valid, 2: free */; 1901};; 1902 ; 1903 ; 1904/* Enum const for all options must be in sync with; 1905 * static struct mg_option config_",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:68623,Security,authoriz,authorization,68623,", MG_CONFIG_TYPE_DIRECTORY, NULL},; 2187#if !defined(NO_CACHING); 2188 {""static_file_max_age"", MG_CONFIG_TYPE_NUMBER, ""3600""},; 2189 {""static_file_cache_control"", MG_CONFIG_TYPE_STRING, NULL},; 2190#endif; 2191#if !defined(NO_SSL); 2192 {""strict_transport_security_max_age"", MG_CONFIG_TYPE_NUMBER, NULL},; 2193#endif; 2194 {""additional_header"", MG_CONFIG_TYPE_STRING_MULTILINE, NULL},; 2195 {""allow_index_script_resource"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2196 ; 2197 {NULL, MG_CONFIG_TYPE_UNKNOWN, NULL}};; 2198 ; 2199 ; 2200/* Check if the config_options and the corresponding enum have compatible; 2201 * sizes. */; 2202mg_static_assert((sizeof(config_options) / sizeof(config_options[0])); 2203 == (NUM_OPTIONS + 1),; 2204 ""config_options and enum not sync"");; 2205 ; 2206 ; 2207enum { REQUEST_HANDLER, WEBSOCKET_HANDLER, AUTH_HANDLER };; 2208 ; 2209 ; 2210struct mg_handler_info {; 2211 /* Name/Pattern of the URI. */; 2212 char *uri;; 2213 size_t uri_len;; 2214 ; 2215 /* handler type */; 2216 int handler_type;; 2217 ; 2218 /* Handler for http/https or authorization requests. */; 2219 mg_request_handler handler;; 2220 unsigned int refcount;; 2221 int removing;; 2222 ; 2223 /* Handler for ws/wss (websocket) requests. */; 2224 mg_websocket_connect_handler connect_handler;; 2225 mg_websocket_ready_handler ready_handler;; 2226 mg_websocket_data_handler data_handler;; 2227 mg_websocket_close_handler close_handler;; 2228 ; 2229 /* accepted subprotocols for ws/wss requests. */; 2230 struct mg_websocket_subprotocols *subprotocols;; 2231 ; 2232 /* Handler for authorization requests */; 2233 mg_authorization_handler auth_handler;; 2234 ; 2235 /* User supplied argument for the handler function. */; 2236 void *cbdata;; 2237 ; 2238 /* next handler in a linked list */; 2239 struct mg_handler_info *next;; 2240};; 2241 ; 2242 ; 2243enum {; 2244 CONTEXT_INVALID,; 2245 CONTEXT_SERVER,; 2246 CONTEXT_HTTP_CLIENT,; 2247 CONTEXT_WS_CLIENT; 2248};; 2249 ; 2250 ; 2251struct mg_domain_context {; 2252",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:69131,Security,authoriz,authorization,69131,"patible; 2201 * sizes. */; 2202mg_static_assert((sizeof(config_options) / sizeof(config_options[0])); 2203 == (NUM_OPTIONS + 1),; 2204 ""config_options and enum not sync"");; 2205 ; 2206 ; 2207enum { REQUEST_HANDLER, WEBSOCKET_HANDLER, AUTH_HANDLER };; 2208 ; 2209 ; 2210struct mg_handler_info {; 2211 /* Name/Pattern of the URI. */; 2212 char *uri;; 2213 size_t uri_len;; 2214 ; 2215 /* handler type */; 2216 int handler_type;; 2217 ; 2218 /* Handler for http/https or authorization requests. */; 2219 mg_request_handler handler;; 2220 unsigned int refcount;; 2221 int removing;; 2222 ; 2223 /* Handler for ws/wss (websocket) requests. */; 2224 mg_websocket_connect_handler connect_handler;; 2225 mg_websocket_ready_handler ready_handler;; 2226 mg_websocket_data_handler data_handler;; 2227 mg_websocket_close_handler close_handler;; 2228 ; 2229 /* accepted subprotocols for ws/wss requests. */; 2230 struct mg_websocket_subprotocols *subprotocols;; 2231 ; 2232 /* Handler for authorization requests */; 2233 mg_authorization_handler auth_handler;; 2234 ; 2235 /* User supplied argument for the handler function. */; 2236 void *cbdata;; 2237 ; 2238 /* next handler in a linked list */; 2239 struct mg_handler_info *next;; 2240};; 2241 ; 2242 ; 2243enum {; 2244 CONTEXT_INVALID,; 2245 CONTEXT_SERVER,; 2246 CONTEXT_HTTP_CLIENT,; 2247 CONTEXT_WS_CLIENT; 2248};; 2249 ; 2250 ; 2251struct mg_domain_context {; 2252 SSL_CTX *ssl_ctx; /* SSL context */; 2253 char *config[NUM_OPTIONS]; /* Civetweb configuration parameters */; 2254 struct mg_handler_info *handlers; /* linked list of uri handlers */; 2255 int64_t ssl_cert_last_mtime;; 2256 ; 2257 /* Server nonce */; 2258 uint64_t auth_nonce_mask; /* Mask for all nonce values */; 2259 unsigned long nonce_count; /* Used nonces, used for authentication */; 2260 ; 2261#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2262 /* linked list of shared lua websockets */; 2263 struct mg_shared_lua_websocket_list *shared_lua_websockets;; 2264#endif; 2265 ; 2266 /*",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:69937,Security,authenticat,authentication,69937,"equests. */; 2224 mg_websocket_connect_handler connect_handler;; 2225 mg_websocket_ready_handler ready_handler;; 2226 mg_websocket_data_handler data_handler;; 2227 mg_websocket_close_handler close_handler;; 2228 ; 2229 /* accepted subprotocols for ws/wss requests. */; 2230 struct mg_websocket_subprotocols *subprotocols;; 2231 ; 2232 /* Handler for authorization requests */; 2233 mg_authorization_handler auth_handler;; 2234 ; 2235 /* User supplied argument for the handler function. */; 2236 void *cbdata;; 2237 ; 2238 /* next handler in a linked list */; 2239 struct mg_handler_info *next;; 2240};; 2241 ; 2242 ; 2243enum {; 2244 CONTEXT_INVALID,; 2245 CONTEXT_SERVER,; 2246 CONTEXT_HTTP_CLIENT,; 2247 CONTEXT_WS_CLIENT; 2248};; 2249 ; 2250 ; 2251struct mg_domain_context {; 2252 SSL_CTX *ssl_ctx; /* SSL context */; 2253 char *config[NUM_OPTIONS]; /* Civetweb configuration parameters */; 2254 struct mg_handler_info *handlers; /* linked list of uri handlers */; 2255 int64_t ssl_cert_last_mtime;; 2256 ; 2257 /* Server nonce */; 2258 uint64_t auth_nonce_mask; /* Mask for all nonce values */; 2259 unsigned long nonce_count; /* Used nonces, used for authentication */; 2260 ; 2261#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2262 /* linked list of shared lua websockets */; 2263 struct mg_shared_lua_websocket_list *shared_lua_websockets;; 2264#endif; 2265 ; 2266 /* Linked list of domains */; 2267 struct mg_domain_context *next;; 2268};; 2269 ; 2270 ; 2271/* Stop flag can be ""volatile"" or require a lock.; 2272 * MSDN uses volatile for ""Interlocked"" operations, but also explicitly; 2273 * states a read operation for int is always atomic. */; 2274#if defined(STOP_FLAG_NEEDS_LOCK); 2275 ; 2276typedef ptrdiff_t volatile stop_flag_t;; 2277 ; 2278static int; 2279STOP_FLAG_IS_ZERO(stop_flag_t *f); 2280{; 2281 stop_flag_t sf = mg_atomic_add(f, 0);; 2282 return (sf == 0);; 2283}; 2284 ; 2285static int; 2286STOP_FLAG_IS_TWO(stop_flag_t *f); 2287{; 2288 stop_flag_t sf = mg_atomic_add(f, 0);",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:73789,Security,authenticat,authentication,73789,";; 2336#endif; 2337 ; 2338 /* Thread related */; 2339 stop_flag_t stop_flag; /* Should we stop event loop */; 2340 pthread_mutex_t thread_mutex; /* Protects client_socks or queue */; 2341 ; 2342 pthread_t masterthreadid; /* The master thread ID */; 2343 unsigned int; 2344 cfg_worker_threads; /* The number of configured worker threads. */; 2345 pthread_t *worker_threadids; /* The worker thread IDs */; 2346 unsigned long starter_thread_idx; /* thread index which called mg_start */; 2347 ; 2348 /* Connection to thread dispatching */; 2349#if defined(ALTERNATIVE_QUEUE); 2350 struct socket *client_socks;; 2351 void **client_wait_events;; 2352#else; 2353 struct socket *squeue; /* Socket queue (sq) : accepted sockets waiting for a; 2354 worker thread */; 2355 volatile int sq_head; /* Head of the socket queue */; 2356 volatile int sq_tail; /* Tail of the socket queue */; 2357 pthread_cond_t sq_full; /* Signaled when socket is produced */; 2358 pthread_cond_t sq_empty; /* Signaled when socket is consumed */; 2359 volatile int sq_blocked; /* Status information: sq is full */; 2360 int sq_size; /* No of elements in socket queue */; 2361#if defined(USE_SERVER_STATS); 2362 int sq_max_fill;; 2363#endif /* USE_SERVER_STATS */; 2364#endif /* ALTERNATIVE_QUEUE */; 2365 ; 2366 /* Memory related */; 2367 unsigned int max_request_size; /* The max request size */; 2368 ; 2369#if defined(USE_SERVER_STATS); 2370 struct mg_memory_stat ctx_memory;; 2371#endif; 2372 ; 2373 /* Operating system related */; 2374 char *systemName; /* What operating system is running */; 2375 time_t start_time; /* Server start time, used for authentication; 2376 * and for diagnstics. */; 2377 ; 2378#if defined(USE_TIMERS); 2379 struct ttimers *timers;; 2380#endif; 2381 ; 2382 /* Lua specific: Background operations and shared websockets */; 2383#if defined(USE_LUA); 2384 void *lua_background_state; /* lua_State (here as void *) */; 2385 pthread_mutex_t lua_bg_mutex; /* Protect background state */; 2386 int lua_bg_",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:74214,Security,access,access,74214,"60 int sq_size; /* No of elements in socket queue */; 2361#if defined(USE_SERVER_STATS); 2362 int sq_max_fill;; 2363#endif /* USE_SERVER_STATS */; 2364#endif /* ALTERNATIVE_QUEUE */; 2365 ; 2366 /* Memory related */; 2367 unsigned int max_request_size; /* The max request size */; 2368 ; 2369#if defined(USE_SERVER_STATS); 2370 struct mg_memory_stat ctx_memory;; 2371#endif; 2372 ; 2373 /* Operating system related */; 2374 char *systemName; /* What operating system is running */; 2375 time_t start_time; /* Server start time, used for authentication; 2376 * and for diagnstics. */; 2377 ; 2378#if defined(USE_TIMERS); 2379 struct ttimers *timers;; 2380#endif; 2381 ; 2382 /* Lua specific: Background operations and shared websockets */; 2383#if defined(USE_LUA); 2384 void *lua_background_state; /* lua_State (here as void *) */; 2385 pthread_mutex_t lua_bg_mutex; /* Protect background state */; 2386 int lua_bg_log_available; /* Use Lua background state for access log */; 2387#endif; 2388 ; 2389 /* Server nonce */; 2390 pthread_mutex_t nonce_mutex; /* Protects ssl_ctx, handlers,; 2391 * ssl_cert_last_mtime, nonce_count, and; 2392 * next (linked list) */; 2393 ; 2394 /* Server callbacks */; 2395 struct mg_callbacks callbacks; /* User-defined callback function */; 2396 void *user_data; /* User-defined data */; 2397 ; 2398 /* Part 2 - Logical domain:; 2399 * This holds hostname, TLS certificate, document root, ...; 2400 * set for a domain hosted at the server.; 2401 * There may be multiple domains hosted at one physical server.; 2402 * The default domain ""dd"" is the first element of a list of; 2403 * domains.; 2404 */; 2405 struct mg_domain_context dd; /* default domain */; 2406};; 2407 ; 2408 ; 2409#if defined(USE_SERVER_STATS); 2410static struct mg_memory_stat mg_common_memory = {0, 0, 0};; 2411 ; 2412static struct mg_memory_stat *; 2413get_memory_stat(struct mg_context *ctx); 2414{; 2415 if (ctx) {; 2416 return &(ctx->ctx_memory);; 2417 }; 2418 return &mg_common_memory;; 2419}",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:74645,Security,certificate,certificate,74645,"60 int sq_size; /* No of elements in socket queue */; 2361#if defined(USE_SERVER_STATS); 2362 int sq_max_fill;; 2363#endif /* USE_SERVER_STATS */; 2364#endif /* ALTERNATIVE_QUEUE */; 2365 ; 2366 /* Memory related */; 2367 unsigned int max_request_size; /* The max request size */; 2368 ; 2369#if defined(USE_SERVER_STATS); 2370 struct mg_memory_stat ctx_memory;; 2371#endif; 2372 ; 2373 /* Operating system related */; 2374 char *systemName; /* What operating system is running */; 2375 time_t start_time; /* Server start time, used for authentication; 2376 * and for diagnstics. */; 2377 ; 2378#if defined(USE_TIMERS); 2379 struct ttimers *timers;; 2380#endif; 2381 ; 2382 /* Lua specific: Background operations and shared websockets */; 2383#if defined(USE_LUA); 2384 void *lua_background_state; /* lua_State (here as void *) */; 2385 pthread_mutex_t lua_bg_mutex; /* Protect background state */; 2386 int lua_bg_log_available; /* Use Lua background state for access log */; 2387#endif; 2388 ; 2389 /* Server nonce */; 2390 pthread_mutex_t nonce_mutex; /* Protects ssl_ctx, handlers,; 2391 * ssl_cert_last_mtime, nonce_count, and; 2392 * next (linked list) */; 2393 ; 2394 /* Server callbacks */; 2395 struct mg_callbacks callbacks; /* User-defined callback function */; 2396 void *user_data; /* User-defined data */; 2397 ; 2398 /* Part 2 - Logical domain:; 2399 * This holds hostname, TLS certificate, document root, ...; 2400 * set for a domain hosted at the server.; 2401 * There may be multiple domains hosted at one physical server.; 2402 * The default domain ""dd"" is the first element of a list of; 2403 * domains.; 2404 */; 2405 struct mg_domain_context dd; /* default domain */; 2406};; 2407 ; 2408 ; 2409#if defined(USE_SERVER_STATS); 2410static struct mg_memory_stat mg_common_memory = {0, 0, 0};; 2411 ; 2412static struct mg_memory_stat *; 2413get_memory_stat(struct mg_context *ctx); 2414{; 2415 if (ctx) {; 2416 return &(ctx->ctx_memory);; 2417 }; 2418 return &mg_common_memory;; 2419}",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:79626,Security,access,access,79626,"deflate_server_no_context_takeover;; 2511 int websocket_deflate_client_no_context_takeover;; 2512 int websocket_deflate_initialized;; 2513 int websocket_deflate_flush;; 2514 z_stream websocket_deflate_state;; 2515 z_stream websocket_inflate_state;; 2516#endif; 2517 int handled_requests; /* Number of requests handled by this connection; 2518 */; 2519 int buf_size; /* Buffer size */; 2520 int request_len; /* Size of the request + headers in a buffer */; 2521 int data_len; /* Total size of data in a buffer */; 2522 int status_code; /* HTTP reply status code, e.g. 200 */; 2523 int throttle; /* Throttling, bytes/sec. <= 0 means no; 2524 * throttle */; 2525 ; 2526 time_t last_throttle_time; /* Last time throttled data was sent */; 2527 int last_throttle_bytes; /* Bytes sent this second */; 2528 pthread_mutex_t mutex; /* Used by mg_(un)lock_connection to ensure; 2529 * atomic transmissions for websockets */; 2530#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2531 void *lua_websocket_state; /* Lua_State for a websocket connection */; 2532#endif; 2533 ; 2534 void *tls_user_ptr; /* User defined pointer in thread local storage,; 2535 * for quick access */; 2536};; 2537 ; 2538 ; 2539/* Directory entry */; 2540struct de {; 2541 struct mg_connection *conn;; 2542 char *file_name;; 2543 struct mg_file_stat file;; 2544};; 2545 ; 2546 ; 2547#define mg_cry_internal(conn, fmt, ...) \; 2548 mg_cry_internal_wrap(conn, NULL, __func__, __LINE__, fmt, __VA_ARGS__); 2549 ; 2550#define mg_cry_ctx_internal(ctx, fmt, ...) \; 2551 mg_cry_internal_wrap(NULL, ctx, __func__, __LINE__, fmt, __VA_ARGS__); 2552 ; 2553static void mg_cry_internal_wrap(const struct mg_connection *conn,; 2554 struct mg_context *ctx,; 2555 const char *func,; 2556 unsigned line,; 2557 const char *fmt,; 2558 ...) PRINTF_ARGS(5, 6);; 2559 ; 2560 ; 2561#if !defined(NO_THREAD_NAME); 2562#if defined(_WIN32) && defined(_MSC_VER); 2563/* Set the thread name for debugging purposes in Visual Studio; 2564 * http://msdn.microsoft.com/",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:86255,Security,access,access,86255,,MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:88342,Security,access,access,88342,"; 2844 ; 2845#if defined(_WIN32); 2846 while (*c) {; 2847 if (*c < 32) {; 2848 /* Control character */; 2849 return 1;; 2850 }; 2851 if ((*c == '>') || (*c == '<') || (*c == '|')) {; 2852 /* stdin/stdout redirection character */; 2853 return 1;; 2854 }; 2855 if ((*c == '*') || (*c == '?')) {; 2856 /* Wildcard character */; 2857 return 1;; 2858 }; 2859 if (*c == '""') {; 2860 /* Windows quotation */; 2861 return 1;; 2862 }; 2863 c++;; 2864 }; 2865#endif; 2866 ; 2867 /* Nothing suspicious found */; 2868 return 0;; 2869}; 2870 ; 2871 ; 2872/* mg_fopen will open a file either in memory or on the disk.; 2873 * The input parameter path is a string in UTF-8 encoding.; 2874 * The input parameter mode is MG_FOPEN_MODE_*; 2875 * On success, fp will be set in the output struct mg_file.; 2876 * All status members will also be set.; 2877 * The function returns 1 on success, 0 on error. */; 2878static int; 2879mg_fopen(const struct mg_connection *conn,; 2880 const char *path,; 2881 int mode,; 2882 struct mg_file *filep); 2883{; 2884 int found;; 2885 ; 2886 if (!filep) {; 2887 return 0;; 2888 }; 2889 filep->access.fp = NULL;; 2890 ; 2891 if (mg_path_suspicious(conn, path)) {; 2892 return 0;; 2893 }; 2894 ; 2895 /* filep is initialized in mg_stat: all fields with memset to,; 2896 * some fields like size and modification date with values */; 2897 found = mg_stat(conn, path, &(filep->stat));; 2898 ; 2899 if ((mode == MG_FOPEN_MODE_READ) && (!found)) {; 2900 /* file does not exist and will not be created */; 2901 return 0;; 2902 }; 2903 ; 2904#if defined(_WIN32); 2905 {; 2906 wchar_t wbuf[UTF16_PATH_MAX];; 2907 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2908 switch (mode) {; 2909 case MG_FOPEN_MODE_READ:; 2910 filep->access.fp = _wfopen(wbuf, L""rb"");; 2911 break;; 2912 case MG_FOPEN_MODE_WRITE:; 2913 filep->access.fp = _wfopen(wbuf, L""wb"");; 2914 break;; 2915 case MG_FOPEN_MODE_APPEND:; 2916 filep->access.fp = _wfopen(wbuf, L""ab"");; 2917 break;; 2918 }; 2919 }; 2920#else; 29",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:88971,Security,access,access,88971," c++;; 2864 }; 2865#endif; 2866 ; 2867 /* Nothing suspicious found */; 2868 return 0;; 2869}; 2870 ; 2871 ; 2872/* mg_fopen will open a file either in memory or on the disk.; 2873 * The input parameter path is a string in UTF-8 encoding.; 2874 * The input parameter mode is MG_FOPEN_MODE_*; 2875 * On success, fp will be set in the output struct mg_file.; 2876 * All status members will also be set.; 2877 * The function returns 1 on success, 0 on error. */; 2878static int; 2879mg_fopen(const struct mg_connection *conn,; 2880 const char *path,; 2881 int mode,; 2882 struct mg_file *filep); 2883{; 2884 int found;; 2885 ; 2886 if (!filep) {; 2887 return 0;; 2888 }; 2889 filep->access.fp = NULL;; 2890 ; 2891 if (mg_path_suspicious(conn, path)) {; 2892 return 0;; 2893 }; 2894 ; 2895 /* filep is initialized in mg_stat: all fields with memset to,; 2896 * some fields like size and modification date with values */; 2897 found = mg_stat(conn, path, &(filep->stat));; 2898 ; 2899 if ((mode == MG_FOPEN_MODE_READ) && (!found)) {; 2900 /* file does not exist and will not be created */; 2901 return 0;; 2902 }; 2903 ; 2904#if defined(_WIN32); 2905 {; 2906 wchar_t wbuf[UTF16_PATH_MAX];; 2907 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2908 switch (mode) {; 2909 case MG_FOPEN_MODE_READ:; 2910 filep->access.fp = _wfopen(wbuf, L""rb"");; 2911 break;; 2912 case MG_FOPEN_MODE_WRITE:; 2913 filep->access.fp = _wfopen(wbuf, L""wb"");; 2914 break;; 2915 case MG_FOPEN_MODE_APPEND:; 2916 filep->access.fp = _wfopen(wbuf, L""ab"");; 2917 break;; 2918 }; 2919 }; 2920#else; 2921 /* Linux et al already use unicode. No need to convert. */; 2922 switch (mode) {; 2923 case MG_FOPEN_MODE_READ:; 2924 filep->access.fp = fopen(path, ""r"");; 2925 break;; 2926 case MG_FOPEN_MODE_WRITE:; 2927 filep->access.fp = fopen(path, ""w"");; 2928 break;; 2929 case MG_FOPEN_MODE_APPEND:; 2930 filep->access.fp = fopen(path, ""a"");; 2931 break;; 2932 }; 2933 ; 2934#endif; 2935 if (!found) {; 2936 /* File did not exist before f",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:89063,Security,access,access,89063,"* All status members will also be set.; 2877 * The function returns 1 on success, 0 on error. */; 2878static int; 2879mg_fopen(const struct mg_connection *conn,; 2880 const char *path,; 2881 int mode,; 2882 struct mg_file *filep); 2883{; 2884 int found;; 2885 ; 2886 if (!filep) {; 2887 return 0;; 2888 }; 2889 filep->access.fp = NULL;; 2890 ; 2891 if (mg_path_suspicious(conn, path)) {; 2892 return 0;; 2893 }; 2894 ; 2895 /* filep is initialized in mg_stat: all fields with memset to,; 2896 * some fields like size and modification date with values */; 2897 found = mg_stat(conn, path, &(filep->stat));; 2898 ; 2899 if ((mode == MG_FOPEN_MODE_READ) && (!found)) {; 2900 /* file does not exist and will not be created */; 2901 return 0;; 2902 }; 2903 ; 2904#if defined(_WIN32); 2905 {; 2906 wchar_t wbuf[UTF16_PATH_MAX];; 2907 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2908 switch (mode) {; 2909 case MG_FOPEN_MODE_READ:; 2910 filep->access.fp = _wfopen(wbuf, L""rb"");; 2911 break;; 2912 case MG_FOPEN_MODE_WRITE:; 2913 filep->access.fp = _wfopen(wbuf, L""wb"");; 2914 break;; 2915 case MG_FOPEN_MODE_APPEND:; 2916 filep->access.fp = _wfopen(wbuf, L""ab"");; 2917 break;; 2918 }; 2919 }; 2920#else; 2921 /* Linux et al already use unicode. No need to convert. */; 2922 switch (mode) {; 2923 case MG_FOPEN_MODE_READ:; 2924 filep->access.fp = fopen(path, ""r"");; 2925 break;; 2926 case MG_FOPEN_MODE_WRITE:; 2927 filep->access.fp = fopen(path, ""w"");; 2928 break;; 2929 case MG_FOPEN_MODE_APPEND:; 2930 filep->access.fp = fopen(path, ""a"");; 2931 break;; 2932 }; 2933 ; 2934#endif; 2935 if (!found) {; 2936 /* File did not exist before fopen was called.; 2937 * Maybe it has been created now. Get stat info; 2938 * like creation time now. */; 2939 found = mg_stat(conn, path, &(filep->stat));; 2940 (void)found;; 2941 }; 2942 ; 2943 /* return OK if file is opened */; 2944 return (filep->access.fp != NULL);; 2945}; 2946 ; 2947 ; 2948/* return 0 on success, just like fclose */; 2949static int; 29",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:89156,Security,access,access,89156,". */; 2878static int; 2879mg_fopen(const struct mg_connection *conn,; 2880 const char *path,; 2881 int mode,; 2882 struct mg_file *filep); 2883{; 2884 int found;; 2885 ; 2886 if (!filep) {; 2887 return 0;; 2888 }; 2889 filep->access.fp = NULL;; 2890 ; 2891 if (mg_path_suspicious(conn, path)) {; 2892 return 0;; 2893 }; 2894 ; 2895 /* filep is initialized in mg_stat: all fields with memset to,; 2896 * some fields like size and modification date with values */; 2897 found = mg_stat(conn, path, &(filep->stat));; 2898 ; 2899 if ((mode == MG_FOPEN_MODE_READ) && (!found)) {; 2900 /* file does not exist and will not be created */; 2901 return 0;; 2902 }; 2903 ; 2904#if defined(_WIN32); 2905 {; 2906 wchar_t wbuf[UTF16_PATH_MAX];; 2907 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2908 switch (mode) {; 2909 case MG_FOPEN_MODE_READ:; 2910 filep->access.fp = _wfopen(wbuf, L""rb"");; 2911 break;; 2912 case MG_FOPEN_MODE_WRITE:; 2913 filep->access.fp = _wfopen(wbuf, L""wb"");; 2914 break;; 2915 case MG_FOPEN_MODE_APPEND:; 2916 filep->access.fp = _wfopen(wbuf, L""ab"");; 2917 break;; 2918 }; 2919 }; 2920#else; 2921 /* Linux et al already use unicode. No need to convert. */; 2922 switch (mode) {; 2923 case MG_FOPEN_MODE_READ:; 2924 filep->access.fp = fopen(path, ""r"");; 2925 break;; 2926 case MG_FOPEN_MODE_WRITE:; 2927 filep->access.fp = fopen(path, ""w"");; 2928 break;; 2929 case MG_FOPEN_MODE_APPEND:; 2930 filep->access.fp = fopen(path, ""a"");; 2931 break;; 2932 }; 2933 ; 2934#endif; 2935 if (!found) {; 2936 /* File did not exist before fopen was called.; 2937 * Maybe it has been created now. Get stat info; 2938 * like creation time now. */; 2939 found = mg_stat(conn, path, &(filep->stat));; 2940 (void)found;; 2941 }; 2942 ; 2943 /* return OK if file is opened */; 2944 return (filep->access.fp != NULL);; 2945}; 2946 ; 2947 ; 2948/* return 0 on success, just like fclose */; 2949static int; 2950mg_fclose(struct mg_file_access *fileacc); 2951{; 2952 int ret = -1;; 2953 if (fileacc != N",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:89361,Security,access,access,89361," 2889 filep->access.fp = NULL;; 2890 ; 2891 if (mg_path_suspicious(conn, path)) {; 2892 return 0;; 2893 }; 2894 ; 2895 /* filep is initialized in mg_stat: all fields with memset to,; 2896 * some fields like size and modification date with values */; 2897 found = mg_stat(conn, path, &(filep->stat));; 2898 ; 2899 if ((mode == MG_FOPEN_MODE_READ) && (!found)) {; 2900 /* file does not exist and will not be created */; 2901 return 0;; 2902 }; 2903 ; 2904#if defined(_WIN32); 2905 {; 2906 wchar_t wbuf[UTF16_PATH_MAX];; 2907 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2908 switch (mode) {; 2909 case MG_FOPEN_MODE_READ:; 2910 filep->access.fp = _wfopen(wbuf, L""rb"");; 2911 break;; 2912 case MG_FOPEN_MODE_WRITE:; 2913 filep->access.fp = _wfopen(wbuf, L""wb"");; 2914 break;; 2915 case MG_FOPEN_MODE_APPEND:; 2916 filep->access.fp = _wfopen(wbuf, L""ab"");; 2917 break;; 2918 }; 2919 }; 2920#else; 2921 /* Linux et al already use unicode. No need to convert. */; 2922 switch (mode) {; 2923 case MG_FOPEN_MODE_READ:; 2924 filep->access.fp = fopen(path, ""r"");; 2925 break;; 2926 case MG_FOPEN_MODE_WRITE:; 2927 filep->access.fp = fopen(path, ""w"");; 2928 break;; 2929 case MG_FOPEN_MODE_APPEND:; 2930 filep->access.fp = fopen(path, ""a"");; 2931 break;; 2932 }; 2933 ; 2934#endif; 2935 if (!found) {; 2936 /* File did not exist before fopen was called.; 2937 * Maybe it has been created now. Get stat info; 2938 * like creation time now. */; 2939 found = mg_stat(conn, path, &(filep->stat));; 2940 (void)found;; 2941 }; 2942 ; 2943 /* return OK if file is opened */; 2944 return (filep->access.fp != NULL);; 2945}; 2946 ; 2947 ; 2948/* return 0 on success, just like fclose */; 2949static int; 2950mg_fclose(struct mg_file_access *fileacc); 2951{; 2952 int ret = -1;; 2953 if (fileacc != NULL) {; 2954 if (fileacc->fp != NULL) {; 2955 ret = fclose(fileacc->fp);; 2956 }; 2957 /* reset all members of fileacc */; 2958 memset(fileacc, 0, sizeof(*fileacc));; 2959 }; 2960 return ret;; 2961}; 2962#endif /*",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:89449,Security,access,access,89449,"2892 return 0;; 2893 }; 2894 ; 2895 /* filep is initialized in mg_stat: all fields with memset to,; 2896 * some fields like size and modification date with values */; 2897 found = mg_stat(conn, path, &(filep->stat));; 2898 ; 2899 if ((mode == MG_FOPEN_MODE_READ) && (!found)) {; 2900 /* file does not exist and will not be created */; 2901 return 0;; 2902 }; 2903 ; 2904#if defined(_WIN32); 2905 {; 2906 wchar_t wbuf[UTF16_PATH_MAX];; 2907 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2908 switch (mode) {; 2909 case MG_FOPEN_MODE_READ:; 2910 filep->access.fp = _wfopen(wbuf, L""rb"");; 2911 break;; 2912 case MG_FOPEN_MODE_WRITE:; 2913 filep->access.fp = _wfopen(wbuf, L""wb"");; 2914 break;; 2915 case MG_FOPEN_MODE_APPEND:; 2916 filep->access.fp = _wfopen(wbuf, L""ab"");; 2917 break;; 2918 }; 2919 }; 2920#else; 2921 /* Linux et al already use unicode. No need to convert. */; 2922 switch (mode) {; 2923 case MG_FOPEN_MODE_READ:; 2924 filep->access.fp = fopen(path, ""r"");; 2925 break;; 2926 case MG_FOPEN_MODE_WRITE:; 2927 filep->access.fp = fopen(path, ""w"");; 2928 break;; 2929 case MG_FOPEN_MODE_APPEND:; 2930 filep->access.fp = fopen(path, ""a"");; 2931 break;; 2932 }; 2933 ; 2934#endif; 2935 if (!found) {; 2936 /* File did not exist before fopen was called.; 2937 * Maybe it has been created now. Get stat info; 2938 * like creation time now. */; 2939 found = mg_stat(conn, path, &(filep->stat));; 2940 (void)found;; 2941 }; 2942 ; 2943 /* return OK if file is opened */; 2944 return (filep->access.fp != NULL);; 2945}; 2946 ; 2947 ; 2948/* return 0 on success, just like fclose */; 2949static int; 2950mg_fclose(struct mg_file_access *fileacc); 2951{; 2952 int ret = -1;; 2953 if (fileacc != NULL) {; 2954 if (fileacc->fp != NULL) {; 2955 ret = fclose(fileacc->fp);; 2956 }; 2957 /* reset all members of fileacc */; 2958 memset(fileacc, 0, sizeof(*fileacc));; 2959 }; 2960 return ret;; 2961}; 2962#endif /* NO_FILESYSTEMS */; 2963 ; 2964 ; 2965static void; 2966mg_strlcpy(char *dst, const",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:89538,Security,access,access,89538,"memset to,; 2896 * some fields like size and modification date with values */; 2897 found = mg_stat(conn, path, &(filep->stat));; 2898 ; 2899 if ((mode == MG_FOPEN_MODE_READ) && (!found)) {; 2900 /* file does not exist and will not be created */; 2901 return 0;; 2902 }; 2903 ; 2904#if defined(_WIN32); 2905 {; 2906 wchar_t wbuf[UTF16_PATH_MAX];; 2907 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2908 switch (mode) {; 2909 case MG_FOPEN_MODE_READ:; 2910 filep->access.fp = _wfopen(wbuf, L""rb"");; 2911 break;; 2912 case MG_FOPEN_MODE_WRITE:; 2913 filep->access.fp = _wfopen(wbuf, L""wb"");; 2914 break;; 2915 case MG_FOPEN_MODE_APPEND:; 2916 filep->access.fp = _wfopen(wbuf, L""ab"");; 2917 break;; 2918 }; 2919 }; 2920#else; 2921 /* Linux et al already use unicode. No need to convert. */; 2922 switch (mode) {; 2923 case MG_FOPEN_MODE_READ:; 2924 filep->access.fp = fopen(path, ""r"");; 2925 break;; 2926 case MG_FOPEN_MODE_WRITE:; 2927 filep->access.fp = fopen(path, ""w"");; 2928 break;; 2929 case MG_FOPEN_MODE_APPEND:; 2930 filep->access.fp = fopen(path, ""a"");; 2931 break;; 2932 }; 2933 ; 2934#endif; 2935 if (!found) {; 2936 /* File did not exist before fopen was called.; 2937 * Maybe it has been created now. Get stat info; 2938 * like creation time now. */; 2939 found = mg_stat(conn, path, &(filep->stat));; 2940 (void)found;; 2941 }; 2942 ; 2943 /* return OK if file is opened */; 2944 return (filep->access.fp != NULL);; 2945}; 2946 ; 2947 ; 2948/* return 0 on success, just like fclose */; 2949static int; 2950mg_fclose(struct mg_file_access *fileacc); 2951{; 2952 int ret = -1;; 2953 if (fileacc != NULL) {; 2954 if (fileacc->fp != NULL) {; 2955 ret = fclose(fileacc->fp);; 2956 }; 2957 /* reset all members of fileacc */; 2958 memset(fileacc, 0, sizeof(*fileacc));; 2959 }; 2960 return ret;; 2961}; 2962#endif /* NO_FILESYSTEMS */; 2963 ; 2964 ; 2965static void; 2966mg_strlcpy(char *dst, const char *src, size_t n); 2967{; 2968 for (; *src != '\0' && n > 1; n--) {; 2969 *dst++ = *s",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:89915,Security,access,access,89915,"];; 2907 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2908 switch (mode) {; 2909 case MG_FOPEN_MODE_READ:; 2910 filep->access.fp = _wfopen(wbuf, L""rb"");; 2911 break;; 2912 case MG_FOPEN_MODE_WRITE:; 2913 filep->access.fp = _wfopen(wbuf, L""wb"");; 2914 break;; 2915 case MG_FOPEN_MODE_APPEND:; 2916 filep->access.fp = _wfopen(wbuf, L""ab"");; 2917 break;; 2918 }; 2919 }; 2920#else; 2921 /* Linux et al already use unicode. No need to convert. */; 2922 switch (mode) {; 2923 case MG_FOPEN_MODE_READ:; 2924 filep->access.fp = fopen(path, ""r"");; 2925 break;; 2926 case MG_FOPEN_MODE_WRITE:; 2927 filep->access.fp = fopen(path, ""w"");; 2928 break;; 2929 case MG_FOPEN_MODE_APPEND:; 2930 filep->access.fp = fopen(path, ""a"");; 2931 break;; 2932 }; 2933 ; 2934#endif; 2935 if (!found) {; 2936 /* File did not exist before fopen was called.; 2937 * Maybe it has been created now. Get stat info; 2938 * like creation time now. */; 2939 found = mg_stat(conn, path, &(filep->stat));; 2940 (void)found;; 2941 }; 2942 ; 2943 /* return OK if file is opened */; 2944 return (filep->access.fp != NULL);; 2945}; 2946 ; 2947 ; 2948/* return 0 on success, just like fclose */; 2949static int; 2950mg_fclose(struct mg_file_access *fileacc); 2951{; 2952 int ret = -1;; 2953 if (fileacc != NULL) {; 2954 if (fileacc->fp != NULL) {; 2955 ret = fclose(fileacc->fp);; 2956 }; 2957 /* reset all members of fileacc */; 2958 memset(fileacc, 0, sizeof(*fileacc));; 2959 }; 2960 return ret;; 2961}; 2962#endif /* NO_FILESYSTEMS */; 2963 ; 2964 ; 2965static void; 2966mg_strlcpy(char *dst, const char *src, size_t n); 2967{; 2968 for (; *src != '\0' && n > 1; n--) {; 2969 *dst++ = *src++;; 2970 }; 2971 *dst = '\0';; 2972}; 2973 ; 2974 ; 2975static int; 2976lowercase(const char *s); 2977{; 2978 return tolower((unsigned char)*s);; 2979}; 2980 ; 2981 ; 2982int; 2983mg_strncasecmp(const char *s1, const char *s2, size_t len); 2984{; 2985 int diff = 0;; 2986 ; 2987 if (len > 0) {; 2988 do {; 2989 diff = lowercase(s1++) - lowe",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:95135,Security,access,access,95135,"urn i;; 3130 }; 3131 }; 3132 return -1;; 3133}; 3134 ; 3135 ; 3136const char *; 3137mg_get_option(const struct mg_context *ctx, const char *name); 3138{; 3139 int i;; 3140 if ((i = get_option_index(name)) == -1) {; 3141 return NULL;; 3142 } else if (!ctx || ctx->dd.config[i] == NULL) {; 3143 return """";; 3144 } else {; 3145 return ctx->dd.config[i];; 3146 }; 3147}; 3148 ; 3149#define mg_get_option DO_NOT_USE_THIS_FUNCTION_INTERNALLY__access_directly; 3150 ; 3151struct mg_context *; 3152mg_get_context(const struct mg_connection *conn); 3153{; 3154 return (conn == NULL) ? (struct mg_context *)NULL : (conn->phys_ctx);; 3155}; 3156 ; 3157 ; 3158void *; 3159mg_get_user_data(const struct mg_context *ctx); 3160{; 3161 return (ctx == NULL) ? NULL : ctx->user_data;; 3162}; 3163 ; 3164 ; 3165void *; 3166mg_get_user_context_data(const struct mg_connection *conn); 3167{; 3168 return mg_get_user_data(mg_get_context(conn));; 3169}; 3170 ; 3171 ; 3172void *; 3173mg_get_thread_pointer(const struct mg_connection *conn); 3174{; 3175 /* both methods should return the same pointer */; 3176 if (conn) {; 3177 /* quick access, in case conn is known */; 3178 return conn->tls_user_ptr;; 3179 } else {; 3180 /* otherwise get pointer from thread local storage (TLS) */; 3181 struct mg_workerTLS *tls =; 3182 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 3183 return tls->user_ptr;; 3184 }; 3185}; 3186 ; 3187 ; 3188void; 3189mg_set_user_connection_data(const struct mg_connection *const_conn, void *data); 3190{; 3191 if (const_conn != NULL) {; 3192 /* Const cast, since ""const struct mg_connection *"" does not mean; 3193 * the connection object is not modified. Here ""const"" is used,; 3194 * to indicate mg_read/mg_write/mg_send/.. must not be called. */; 3195 struct mg_connection *conn = (struct mg_connection *)const_conn;; 3196 conn->request_info.conn_data = data;; 3197 }; 3198}; 3199 ; 3200 ; 3201void *; 3202mg_get_user_connection_data(const struct mg_connection *conn); 3203{; 3204 if (conn !=",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:101059,Security,access,access,101059,";; 3361 ; 3362#if defined(GCC_DIAGNOSTIC); 3363#pragma GCC diagnostic push; 3364#pragma GCC diagnostic ignored ""-Wformat-nonliteral""; 3365#endif; 3366 ; 3367 IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));; 3368 ; 3369#if defined(GCC_DIAGNOSTIC); 3370#pragma GCC diagnostic pop; 3371#endif; 3372 ; 3373 buf[sizeof(buf) - 1] = 0;; 3374 ; 3375 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3376 ; 3377 if (!conn) {; 3378 puts(buf);; 3379 return;; 3380 }; 3381 ; 3382 /* Do not lock when getting the callback value, here and below.; 3383 * I suppose this is fine, since function cannot disappear in the; 3384 * same way string option can. */; 3385 if ((conn->phys_ctx->callbacks.log_message == NULL); 3386 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3387 ; 3388 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3389 if (mg_fopen(conn,; 3390 conn->dom_ctx->config[ERROR_LOG_FILE],; 3391 MG_FOPEN_MODE_APPEND,; 3392 &fi); 3393 == 0) {; 3394 fi.access.fp = NULL;; 3395 }; 3396 } else {; 3397 fi.access.fp = NULL;; 3398 }; 3399 ; 3400 if (fi.access.fp != NULL) {; 3401 flockfile(fi.access.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endi",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:101109,Security,access,access,101109,"agma GCC diagnostic push; 3364#pragma GCC diagnostic ignored ""-Wformat-nonliteral""; 3365#endif; 3366 ; 3367 IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));; 3368 ; 3369#if defined(GCC_DIAGNOSTIC); 3370#pragma GCC diagnostic pop; 3371#endif; 3372 ; 3373 buf[sizeof(buf) - 1] = 0;; 3374 ; 3375 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3376 ; 3377 if (!conn) {; 3378 puts(buf);; 3379 return;; 3380 }; 3381 ; 3382 /* Do not lock when getting the callback value, here and below.; 3383 * I suppose this is fine, since function cannot disappear in the; 3384 * same way string option can. */; 3385 if ((conn->phys_ctx->callbacks.log_message == NULL); 3386 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3387 ; 3388 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3389 if (mg_fopen(conn,; 3390 conn->dom_ctx->config[ERROR_LOG_FILE],; 3391 MG_FOPEN_MODE_APPEND,; 3392 &fi); 3393 == 0) {; 3394 fi.access.fp = NULL;; 3395 }; 3396 } else {; 3397 fi.access.fp = NULL;; 3398 }; 3399 ; 3400 if (fi.access.fp != NULL) {; 3401 flockfile(fi.access.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endif /* Externally provided function */; 3431 ; 3432 ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:101155,Security,access,access,101155,"nostic ignored ""-Wformat-nonliteral""; 3365#endif; 3366 ; 3367 IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));; 3368 ; 3369#if defined(GCC_DIAGNOSTIC); 3370#pragma GCC diagnostic pop; 3371#endif; 3372 ; 3373 buf[sizeof(buf) - 1] = 0;; 3374 ; 3375 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3376 ; 3377 if (!conn) {; 3378 puts(buf);; 3379 return;; 3380 }; 3381 ; 3382 /* Do not lock when getting the callback value, here and below.; 3383 * I suppose this is fine, since function cannot disappear in the; 3384 * same way string option can. */; 3385 if ((conn->phys_ctx->callbacks.log_message == NULL); 3386 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3387 ; 3388 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3389 if (mg_fopen(conn,; 3390 conn->dom_ctx->config[ERROR_LOG_FILE],; 3391 MG_FOPEN_MODE_APPEND,; 3392 &fi); 3393 == 0) {; 3394 fi.access.fp = NULL;; 3395 }; 3396 } else {; 3397 fi.access.fp = NULL;; 3398 }; 3399 ; 3400 if (fi.access.fp != NULL) {; 3401 flockfile(fi.access.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endif /* Externally provided function */; 3431 ; 3432 ; 3433/* Construct fake connection structure. ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:101195,Security,access,access,101195,"65#endif; 3366 ; 3367 IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));; 3368 ; 3369#if defined(GCC_DIAGNOSTIC); 3370#pragma GCC diagnostic pop; 3371#endif; 3372 ; 3373 buf[sizeof(buf) - 1] = 0;; 3374 ; 3375 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3376 ; 3377 if (!conn) {; 3378 puts(buf);; 3379 return;; 3380 }; 3381 ; 3382 /* Do not lock when getting the callback value, here and below.; 3383 * I suppose this is fine, since function cannot disappear in the; 3384 * same way string option can. */; 3385 if ((conn->phys_ctx->callbacks.log_message == NULL); 3386 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3387 ; 3388 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3389 if (mg_fopen(conn,; 3390 conn->dom_ctx->config[ERROR_LOG_FILE],; 3391 MG_FOPEN_MODE_APPEND,; 3392 &fi); 3393 == 0) {; 3394 fi.access.fp = NULL;; 3395 }; 3396 } else {; 3397 fi.access.fp = NULL;; 3398 }; 3399 ; 3400 if (fi.access.fp != NULL) {; 3401 flockfile(fi.access.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endif /* Externally provided function */; 3431 ; 3432 ; 3433/* Construct fake connection structure. Used for logging, if connection; 3434 * ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:101334,Security,access,access,101334," GCC diagnostic pop; 3371#endif; 3372 ; 3373 buf[sizeof(buf) - 1] = 0;; 3374 ; 3375 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3376 ; 3377 if (!conn) {; 3378 puts(buf);; 3379 return;; 3380 }; 3381 ; 3382 /* Do not lock when getting the callback value, here and below.; 3383 * I suppose this is fine, since function cannot disappear in the; 3384 * same way string option can. */; 3385 if ((conn->phys_ctx->callbacks.log_message == NULL); 3386 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3387 ; 3388 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3389 if (mg_fopen(conn,; 3390 conn->dom_ctx->config[ERROR_LOG_FILE],; 3391 MG_FOPEN_MODE_APPEND,; 3392 &fi); 3393 == 0) {; 3394 fi.access.fp = NULL;; 3395 }; 3396 } else {; 3397 fi.access.fp = NULL;; 3398 }; 3399 ; 3400 if (fi.access.fp != NULL) {; 3401 flockfile(fi.access.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endif /* Externally provided function */; 3431 ; 3432 ; 3433/* Construct fake connection structure. Used for logging, if connection; 3434 * is not applicable at the moment of logging. */; 3435static struct mg_connection *; 3436fake_connection(struct mg_connection *fc, struct mg_",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:101512,Security,access,access,101512,"puts(buf);; 3379 return;; 3380 }; 3381 ; 3382 /* Do not lock when getting the callback value, here and below.; 3383 * I suppose this is fine, since function cannot disappear in the; 3384 * same way string option can. */; 3385 if ((conn->phys_ctx->callbacks.log_message == NULL); 3386 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3387 ; 3388 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3389 if (mg_fopen(conn,; 3390 conn->dom_ctx->config[ERROR_LOG_FILE],; 3391 MG_FOPEN_MODE_APPEND,; 3392 &fi); 3393 == 0) {; 3394 fi.access.fp = NULL;; 3395 }; 3396 } else {; 3397 fi.access.fp = NULL;; 3398 }; 3399 ; 3400 if (fi.access.fp != NULL) {; 3401 flockfile(fi.access.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endif /* Externally provided function */; 3431 ; 3432 ; 3433/* Construct fake connection structure. Used for logging, if connection; 3434 * is not applicable at the moment of logging. */; 3435static struct mg_connection *; 3436fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3437{; 3438 static const struct mg_connection conn_zero = {0};; 3439 *fc = conn_zero;; 3440 fc->phys_ctx = ctx;; 3441 fc->dom_ctx = &(ctx->dd);; 3442 return fc;; 3",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:101702,Security,access,access,101702,"ame way string option can. */; 3385 if ((conn->phys_ctx->callbacks.log_message == NULL); 3386 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3387 ; 3388 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3389 if (mg_fopen(conn,; 3390 conn->dom_ctx->config[ERROR_LOG_FILE],; 3391 MG_FOPEN_MODE_APPEND,; 3392 &fi); 3393 == 0) {; 3394 fi.access.fp = NULL;; 3395 }; 3396 } else {; 3397 fi.access.fp = NULL;; 3398 }; 3399 ; 3400 if (fi.access.fp != NULL) {; 3401 flockfile(fi.access.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endif /* Externally provided function */; 3431 ; 3432 ; 3433/* Construct fake connection structure. Used for logging, if connection; 3434 * is not applicable at the moment of logging. */; 3435static struct mg_connection *; 3436fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3437{; 3438 static const struct mg_connection conn_zero = {0};; 3439 *fc = conn_zero;; 3440 fc->phys_ctx = ctx;; 3441 fc->dom_ctx = &(ctx->dd);; 3442 return fc;; 3443}; 3444 ; 3445 ; 3446static void; 3447mg_cry_internal_wrap(const struct mg_connection *conn,; 3448 struct mg_context *ctx,; 3449 const char *func,; 3450 unsigned line,; 3451 const char *f",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:101746,Security,access,access,101746,"n->phys_ctx->callbacks.log_message == NULL); 3386 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3387 ; 3388 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3389 if (mg_fopen(conn,; 3390 conn->dom_ctx->config[ERROR_LOG_FILE],; 3391 MG_FOPEN_MODE_APPEND,; 3392 &fi); 3393 == 0) {; 3394 fi.access.fp = NULL;; 3395 }; 3396 } else {; 3397 fi.access.fp = NULL;; 3398 }; 3399 ; 3400 if (fi.access.fp != NULL) {; 3401 flockfile(fi.access.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endif /* Externally provided function */; 3431 ; 3432 ; 3433/* Construct fake connection structure. Used for logging, if connection; 3434 * is not applicable at the moment of logging. */; 3435static struct mg_connection *; 3436fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3437{; 3438 static const struct mg_connection conn_zero = {0};; 3439 *fc = conn_zero;; 3440 fc->phys_ctx = ctx;; 3441 fc->dom_ctx = &(ctx->dd);; 3442 return fc;; 3443}; 3444 ; 3445 ; 3446static void; 3447mg_cry_internal_wrap(const struct mg_connection *conn,; 3448 struct mg_context *ctx,; 3449 const char *func,; 3450 unsigned line,; 3451 const char *fmt,; 3452 ...); 3453{; 3454 va_list ap;; 345",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:101774,Security,access,access,101774,"essage == NULL); 3386 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3387 ; 3388 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3389 if (mg_fopen(conn,; 3390 conn->dom_ctx->config[ERROR_LOG_FILE],; 3391 MG_FOPEN_MODE_APPEND,; 3392 &fi); 3393 == 0) {; 3394 fi.access.fp = NULL;; 3395 }; 3396 } else {; 3397 fi.access.fp = NULL;; 3398 }; 3399 ; 3400 if (fi.access.fp != NULL) {; 3401 flockfile(fi.access.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endif /* Externally provided function */; 3431 ; 3432 ; 3433/* Construct fake connection structure. Used for logging, if connection; 3434 * is not applicable at the moment of logging. */; 3435static struct mg_connection *; 3436fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3437{; 3438 static const struct mg_connection conn_zero = {0};; 3439 *fc = conn_zero;; 3440 fc->phys_ctx = ctx;; 3441 fc->dom_ctx = &(ctx->dd);; 3442 return fc;; 3443}; 3444 ; 3445 ; 3446static void; 3447mg_cry_internal_wrap(const struct mg_connection *conn,; 3448 struct mg_context *ctx,; 3449 const char *func,; 3450 unsigned line,; 3451 const char *fmt,; 3452 ...); 3453{; 3454 va_list ap;; 3455 va_start(ap, fmt);; 3456 i",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:101807,Security,access,access,101807,"hys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3387 ; 3388 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3389 if (mg_fopen(conn,; 3390 conn->dom_ctx->config[ERROR_LOG_FILE],; 3391 MG_FOPEN_MODE_APPEND,; 3392 &fi); 3393 == 0) {; 3394 fi.access.fp = NULL;; 3395 }; 3396 } else {; 3397 fi.access.fp = NULL;; 3398 }; 3399 ; 3400 if (fi.access.fp != NULL) {; 3401 flockfile(fi.access.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endif /* Externally provided function */; 3431 ; 3432 ; 3433/* Construct fake connection structure. Used for logging, if connection; 3434 * is not applicable at the moment of logging. */; 3435static struct mg_connection *; 3436fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3437{; 3438 static const struct mg_connection conn_zero = {0};; 3439 *fc = conn_zero;; 3440 fc->phys_ctx = ctx;; 3441 fc->dom_ctx = &(ctx->dd);; 3442 return fc;; 3443}; 3444 ; 3445 ; 3446static void; 3447mg_cry_internal_wrap(const struct mg_connection *conn,; 3448 struct mg_context *ctx,; 3449 const char *func,; 3450 unsigned line,; 3451 const char *fmt,; 3452 ...); 3453{; 3454 va_list ap;; 3455 va_start(ap, fmt);; 3456 if (!conn && ctx) {; 3457 struct m",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:101845,Security,access,access,101845," {; 3387 ; 3388 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3389 if (mg_fopen(conn,; 3390 conn->dom_ctx->config[ERROR_LOG_FILE],; 3391 MG_FOPEN_MODE_APPEND,; 3392 &fi); 3393 == 0) {; 3394 fi.access.fp = NULL;; 3395 }; 3396 } else {; 3397 fi.access.fp = NULL;; 3398 }; 3399 ; 3400 if (fi.access.fp != NULL) {; 3401 flockfile(fi.access.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endif /* Externally provided function */; 3431 ; 3432 ; 3433/* Construct fake connection structure. Used for logging, if connection; 3434 * is not applicable at the moment of logging. */; 3435static struct mg_connection *; 3436fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3437{; 3438 static const struct mg_connection conn_zero = {0};; 3439 *fc = conn_zero;; 3440 fc->phys_ctx = ctx;; 3441 fc->dom_ctx = &(ctx->dd);; 3442 return fc;; 3443}; 3444 ; 3445 ; 3446static void; 3447mg_cry_internal_wrap(const struct mg_connection *conn,; 3448 struct mg_context *ctx,; 3449 const char *func,; 3450 unsigned line,; 3451 const char *fmt,; 3452 ...); 3453{; 3454 va_list ap;; 3455 va_start(ap, fmt);; 3456 if (!conn && ctx) {; 3457 struct mg_connection fc;; 3458 mg_cry_internal_impl(fak",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:162987,Security,access,access,162987," for additional arguments; 5494 */; 5495 interp_arg =; 5496 conn->dom_ctx->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5497 } else {; 5498 /* Otherwise, the interpreter must be stated in the first line of the; 5499 * CGI script file, after a #! (shebang) mark. */; 5500 buf[0] = buf[1] = '\0';; 5501 ; 5502 /* Get the full script path */; 5503 mg_snprintf(; 5504 conn, &truncated, cmdline, sizeof(cmdline), ""%s/%s"", dir, prog);; 5505 ; 5506 if (truncated) {; 5507 pi.hProcess = (pid_t)-1;; 5508 goto spawn_cleanup;; 5509 }; 5510 ; 5511 /* Open the script file, to read the first line */; 5512 if (mg_fopen(conn, cmdline, MG_FOPEN_MODE_READ, &file)) {; 5513 ; 5514 /* Read the first line of the script into the buffer */; 5515 mg_fgets(buf, sizeof(buf), &file);; 5516 (void)mg_fclose(&file.access); /* ignore error on read only file */; 5517 buf[sizeof(buf) - 1] = '\0';; 5518 }; 5519 ; 5520 if ((buf[0] == '#') && (buf[1] == '!')) {; 5521 trim_trailing_whitespaces(buf + 2);; 5522 } else {; 5523 buf[2] = '\0';; 5524 }; 5525 interp = buf + 2;; 5526 }; 5527 ; 5528 GetFullPathNameA(dir, sizeof(full_dir), full_dir, NULL);; 5529 ; 5530 if (interp[0] != '\0') {; 5531 /* This is an interpreted script file. We must call the interpreter. */; 5532 if ((interp_arg != 0) && (interp_arg[0] != 0)) {; 5533 mg_snprintf(conn,; 5534 &truncated,; 5535 cmdline,; 5536 sizeof(cmdline),; 5537 ""\""%s\"" %s \""%s\\%s\"""",; 5538 interp,; 5539 interp_arg,; 5540 full_dir,; 5541 prog);; 5542 } else {; 5543 mg_snprintf(conn,; 5544 &truncated,; 5545 cmdline,; 5546 sizeof(cmdline),; 5547 ""\""%s\"" \""%s\\%s\"""",; 5548 interp,; 5549 full_dir,; 5550 prog);; 5551 }; 5552 } else {; 5553 /* This is (probably) a compiled program. We call it directly. */; 5554 mg_snprintf(conn,; 5555 &truncated,; 5556 cmdline,; 5557 sizeof(cmdline),; 5558 ""\""%s\\%s\"""",; 5559 full_dir,; 5560 prog);; 5561 }; 5562 ; 5563 if (truncated) {; 5564 pi.hProcess = (pid_t)-1;; 5565 goto spawn_cleanup;; 5566 }; 5567 ; 5568 DEBUG_TRACE(""Running [%s]"", ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:190275,Security,access,access,190275,"ed_len = len64;; 6506 }; 6507 body = conn->buf + conn->request_len + conn->consumed_content;; 6508 memcpy(buf, body, (size_t)buffered_len);; 6509 len64 -= buffered_len;; 6510 conn->consumed_content += buffered_len;; 6511 nread += buffered_len;; 6512 buf = (char *)buf + buffered_len;; 6513 }; 6514 ; 6515 /* We have returned all buffered data. Read new data from the remote; 6516 * socket.; 6517 */; 6518 if ((n = pull_all(NULL, conn, (char *)buf, (int)len64)) >= 0) {; 6519 conn->consumed_content += n;; 6520 nread += n;; 6521 } else {; 6522 nread = ((nread > 0) ? nread : n);; 6523 }; 6524 }; 6525 return (int)nread;; 6526}; 6527 ; 6528 ; 6529/* Forward declarations */; 6530static void handle_request(struct mg_connection *);; 6531static void log_access(const struct mg_connection *);; 6532 ; 6533 ; 6534/* Handle request, update statistics and call access log */; 6535static void; 6536handle_request_stat_log(struct mg_connection *conn); 6537{; 6538#if defined(USE_SERVER_STATS); 6539 struct timespec tnow;; 6540 conn->conn_state = 4; /* processing */; 6541#endif; 6542 ; 6543 handle_request(conn);; 6544 ; 6545 ; 6546#if defined(USE_SERVER_STATS); 6547 conn->conn_state = 5; /* processed */; 6548 ; 6549 clock_gettime(CLOCK_MONOTONIC, &tnow);; 6550 conn->processing_time = mg_difftimespec(&tnow, &(conn->req_time));; 6551 ; 6552 mg_atomic_add64(&(conn->phys_ctx->total_data_read), conn->consumed_content);; 6553 mg_atomic_add64(&(conn->phys_ctx->total_data_written),; 6554 conn->num_bytes_sent);; 6555#endif; 6556 ; 6557 DEBUG_TRACE(""%s"", ""handle_request done"");; 6558 ; 6559 if (conn->phys_ctx->callbacks.end_request != NULL) {; 6560 conn->phys_ctx->callbacks.end_request(conn, conn->status_code);; 6561 DEBUG_TRACE(""%s"", ""end_request callback done"");; 6562 }; 6563 log_access(conn);; 6564}; 6565 ; 6566 ; 6567#if defined(USE_HTTP2); 6568#if defined(NO_SSL); 6569#error ""HTTP2 requires ALPN, APLN requires SSL/TLS""; 6570#endif; 6571#define USE_ALPN; 6572#include ""mod_http2.inl""; 6573/* Not sup",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:226792,Security,attack,attacks,226792,"5 if ((sscanf(datetime,; 7816 ""%d/%3s/%d %d:%d:%d"",; 7817 &day,; 7818 month_str,; 7819 &year,; 7820 &hour,; 7821 &minute,; 7822 &second); 7823 == 6); 7824 || (sscanf(datetime,; 7825 ""%d %3s %d %d:%d:%d"",; 7826 &day,; 7827 month_str,; 7828 &year,; 7829 &hour,; 7830 &minute,; 7831 &second); 7832 == 6); 7833 || (sscanf(datetime,; 7834 ""%*3s, %d %3s %d %d:%d:%d"",; 7835 &day,; 7836 month_str,; 7837 &year,; 7838 &hour,; 7839 &minute,; 7840 &second); 7841 == 6); 7842 || (sscanf(datetime,; 7843 ""%d-%3s-%d %d:%d:%d"",; 7844 &day,; 7845 month_str,; 7846 &year,; 7847 &hour,; 7848 &minute,; 7849 &second); 7850 == 6)) {; 7851 month = get_month_index(month_str);; 7852 if ((month >= 0) && (year >= 1970)) {; 7853 memset(&tm, 0, sizeof(tm));; 7854 tm.tm_year = year - 1900;; 7855 tm.tm_mon = month;; 7856 tm.tm_mday = day;; 7857 tm.tm_hour = hour;; 7858 tm.tm_min = minute;; 7859 tm.tm_sec = second;; 7860 result = timegm(&tm);; 7861 }; 7862 }; 7863 ; 7864 return result;; 7865}; 7866#endif /* !NO_CACHING */; 7867 ; 7868 ; 7869/* Pre-process URIs according to RFC + protect against directory disclosure; 7870 * attacks by removing '..', excessive '/' and '\' characters */; 7871static void; 7872remove_dot_segments(char *inout); 7873{; 7874 /* Windows backend protection; 7875 * (https://tools.ietf.org/html/rfc3986#section-7.3): Replace backslash; 7876 * in URI by slash */; 7877 char *out_end = inout;; 7878 char *in = inout;; 7879 ; 7880 if (!in) {; 7881 /* Param error. */; 7882 return;; 7883 }; 7884 ; 7885 while (*in) {; 7886 if (*in == '\\') {; 7887 *in = '/';; 7888 }; 7889 in++;; 7890 }; 7891 ; 7892 /* Algorithm ""remove_dot_segments"" from; 7893 * https://tools.ietf.org/html/rfc3986#section-5.2.4 */; 7894 /* Step 1:; 7895 * The input buffer is initialized.; 7896 * The output buffer is initialized to the empty string.; 7897 */; 7898 in = inout;; 7899 ; 7900 /* Step 2:; 7901 * While the input buffer is not empty, loop as follows:; 7902 */; 7903 /* Less than out_end of the inout buffer is used a",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:236947,Security,hash,hash,236947,"8162 ; 8163 path_len = strlen(path);; 8164 ; 8165 if ((conn == NULL) || (vec == NULL)) {; 8166 if (vec != NULL) {; 8167 memset(vec, '\0', sizeof(struct vec));; 8168 }; 8169 return;; 8170 }; 8171 ; 8172 /* Scan user-defined mime types first, in case user wants to; 8173 * override default mime types. */; 8174 list = conn->dom_ctx->config[EXTRA_MIME_TYPES];; 8175 while ((list = next_option(list, &ext_vec, &mime_vec)) != NULL) {; 8176 /* ext now points to the path suffix */; 8177 ext = path + path_len - ext_vec.len;; 8178 if (mg_strncasecmp(ext, ext_vec.ptr, ext_vec.len) == 0) {; 8179 *vec = mime_vec;; 8180 return;; 8181 }; 8182 }; 8183 ; 8184 vec->ptr = mg_get_builtin_mime_type(path);; 8185 vec->len = strlen(vec->ptr);; 8186}; 8187 ; 8188 ; 8189/* Stringify binary data. Output buffer must be twice as big as input,; 8190 * because each byte takes 2 bytes in string representation */; 8191static void; 8192bin2str(char *to, const unsigned char *p, size_t len); 8193{; 8194 static const char *hex = ""0123456789abcdef"";; 8195 ; 8196 for (; len--; p++) {; 8197 *to++ = hex[p[0] >> 4];; 8198 *to++ = hex[p[0] & 0x0f];; 8199 }; 8200 *to = '\0';; 8201}; 8202 ; 8203 ; 8204/* Return stringified MD5 hash for list of strings. Buffer must be 33 bytes.; 8205 */; 8206char *; 8207mg_md5(char buf[33], ...); 8208{; 8209 md5_byte_t hash[16];; 8210 const char *p;; 8211 va_list ap;; 8212 md5_state_t ctx;; 8213 ; 8214 md5_init(&ctx);; 8215 ; 8216 va_start(ap, buf);; 8217 while ((p = va_arg(ap, const char *)) != NULL) {; 8218 md5_append(&ctx, (const md5_byte_t *)p, strlen(p));; 8219 }; 8220 va_end(ap);; 8221 ; 8222 md5_finish(&ctx, hash);; 8223 bin2str(buf, hash, sizeof(hash));; 8224 return buf;; 8225}; 8226 ; 8227 ; 8228/* Check the user's password, return 1 if OK */; 8229static int; 8230check_password(const char *method,; 8231 const char *ha1,; 8232 const char *uri,; 8233 const char *nonce,; 8234 const char *nc,; 8235 const char *cnonce,; 8236 const char *qop,; 8237 const char *response); 8238{; ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:237074,Security,hash,hash,237074,"+ = hex[p[0] >> 4];; 8198 *to++ = hex[p[0] & 0x0f];; 8199 }; 8200 *to = '\0';; 8201}; 8202 ; 8203 ; 8204/* Return stringified MD5 hash for list of strings. Buffer must be 33 bytes.; 8205 */; 8206char *; 8207mg_md5(char buf[33], ...); 8208{; 8209 md5_byte_t hash[16];; 8210 const char *p;; 8211 va_list ap;; 8212 md5_state_t ctx;; 8213 ; 8214 md5_init(&ctx);; 8215 ; 8216 va_start(ap, buf);; 8217 while ((p = va_arg(ap, const char *)) != NULL) {; 8218 md5_append(&ctx, (const md5_byte_t *)p, strlen(p));; 8219 }; 8220 va_end(ap);; 8221 ; 8222 md5_finish(&ctx, hash);; 8223 bin2str(buf, hash, sizeof(hash));; 8224 return buf;; 8225}; 8226 ; 8227 ; 8228/* Check the user's password, return 1 if OK */; 8229static int; 8230check_password(const char *method,; 8231 const char *ha1,; 8232 const char *uri,; 8233 const char *nonce,; 8234 const char *nc,; 8235 const char *cnonce,; 8236 const char *qop,; 8237 const char *response); 8238{; 8239 char ha2[32 + 1], expected_response[32 + 1];; 8240 ; 8241 /* Some of the parameters may be NULL */; 8242 if ((method == NULL) || (nonce == NULL) || (nc == NULL) || (cnonce == NULL); 8243 || (qop == NULL) || (response == NULL)) {; 8244 return 0;; 8245 }; 8246 ; 8247 /* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */; 8248 if (strlen(response) != 32) {; 8249 return 0;; 8250 }; 8251 ; 8252 mg_md5(ha2, method, "":"", uri, NULL);; 8253 mg_md5(expected_response,; 8254 ha1,; 8255 "":"",; 8256 nonce,; 8257 "":"",; 8258 nc,; 8259 "":"",; 8260 cnonce,; 8261 "":"",; 8262 qop,; 8263 "":"",; 8264 ha2,; 8265 NULL);; 8266 ; 8267 return mg_strcasecmp(response, expected_response) == 0;; 8268}; 8269 ; 8270 ; 8271#if !defined(NO_FILESYSTEMS); 8272/* Use the global passwords file, if specified by auth_gpass option,; 8273 * or search for .htpasswd in the requested directory. */; 8274static void; 8275open_auth_file(struct mg_connection *conn,; 8276 const char *path,; 8277 struct mg_file *filep); 8278{; 8279 if ((conn != NULL) && (conn->dom_ctx != NULL)) {; 8280 char ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:237376,Security,hash,hash,237376,"+ = hex[p[0] >> 4];; 8198 *to++ = hex[p[0] & 0x0f];; 8199 }; 8200 *to = '\0';; 8201}; 8202 ; 8203 ; 8204/* Return stringified MD5 hash for list of strings. Buffer must be 33 bytes.; 8205 */; 8206char *; 8207mg_md5(char buf[33], ...); 8208{; 8209 md5_byte_t hash[16];; 8210 const char *p;; 8211 va_list ap;; 8212 md5_state_t ctx;; 8213 ; 8214 md5_init(&ctx);; 8215 ; 8216 va_start(ap, buf);; 8217 while ((p = va_arg(ap, const char *)) != NULL) {; 8218 md5_append(&ctx, (const md5_byte_t *)p, strlen(p));; 8219 }; 8220 va_end(ap);; 8221 ; 8222 md5_finish(&ctx, hash);; 8223 bin2str(buf, hash, sizeof(hash));; 8224 return buf;; 8225}; 8226 ; 8227 ; 8228/* Check the user's password, return 1 if OK */; 8229static int; 8230check_password(const char *method,; 8231 const char *ha1,; 8232 const char *uri,; 8233 const char *nonce,; 8234 const char *nc,; 8235 const char *cnonce,; 8236 const char *qop,; 8237 const char *response); 8238{; 8239 char ha2[32 + 1], expected_response[32 + 1];; 8240 ; 8241 /* Some of the parameters may be NULL */; 8242 if ((method == NULL) || (nonce == NULL) || (nc == NULL) || (cnonce == NULL); 8243 || (qop == NULL) || (response == NULL)) {; 8244 return 0;; 8245 }; 8246 ; 8247 /* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */; 8248 if (strlen(response) != 32) {; 8249 return 0;; 8250 }; 8251 ; 8252 mg_md5(ha2, method, "":"", uri, NULL);; 8253 mg_md5(expected_response,; 8254 ha1,; 8255 "":"",; 8256 nonce,; 8257 "":"",; 8258 nc,; 8259 "":"",; 8260 cnonce,; 8261 "":"",; 8262 qop,; 8263 "":"",; 8264 ha2,; 8265 NULL);; 8266 ; 8267 return mg_strcasecmp(response, expected_response) == 0;; 8268}; 8269 ; 8270 ; 8271#if !defined(NO_FILESYSTEMS); 8272/* Use the global passwords file, if specified by auth_gpass option,; 8273 * or search for .htpasswd in the requested directory. */; 8274static void; 8275open_auth_file(struct mg_connection *conn,; 8276 const char *path,; 8277 struct mg_file *filep); 8278{; 8279 if ((conn != NULL) && (conn->dom_ctx != NULL)) {; 8280 char ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:237402,Security,hash,hash,237402,"+ = hex[p[0] >> 4];; 8198 *to++ = hex[p[0] & 0x0f];; 8199 }; 8200 *to = '\0';; 8201}; 8202 ; 8203 ; 8204/* Return stringified MD5 hash for list of strings. Buffer must be 33 bytes.; 8205 */; 8206char *; 8207mg_md5(char buf[33], ...); 8208{; 8209 md5_byte_t hash[16];; 8210 const char *p;; 8211 va_list ap;; 8212 md5_state_t ctx;; 8213 ; 8214 md5_init(&ctx);; 8215 ; 8216 va_start(ap, buf);; 8217 while ((p = va_arg(ap, const char *)) != NULL) {; 8218 md5_append(&ctx, (const md5_byte_t *)p, strlen(p));; 8219 }; 8220 va_end(ap);; 8221 ; 8222 md5_finish(&ctx, hash);; 8223 bin2str(buf, hash, sizeof(hash));; 8224 return buf;; 8225}; 8226 ; 8227 ; 8228/* Check the user's password, return 1 if OK */; 8229static int; 8230check_password(const char *method,; 8231 const char *ha1,; 8232 const char *uri,; 8233 const char *nonce,; 8234 const char *nc,; 8235 const char *cnonce,; 8236 const char *qop,; 8237 const char *response); 8238{; 8239 char ha2[32 + 1], expected_response[32 + 1];; 8240 ; 8241 /* Some of the parameters may be NULL */; 8242 if ((method == NULL) || (nonce == NULL) || (nc == NULL) || (cnonce == NULL); 8243 || (qop == NULL) || (response == NULL)) {; 8244 return 0;; 8245 }; 8246 ; 8247 /* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */; 8248 if (strlen(response) != 32) {; 8249 return 0;; 8250 }; 8251 ; 8252 mg_md5(ha2, method, "":"", uri, NULL);; 8253 mg_md5(expected_response,; 8254 ha1,; 8255 "":"",; 8256 nonce,; 8257 "":"",; 8258 nc,; 8259 "":"",; 8260 cnonce,; 8261 "":"",; 8262 qop,; 8263 "":"",; 8264 ha2,; 8265 NULL);; 8266 ; 8267 return mg_strcasecmp(response, expected_response) == 0;; 8268}; 8269 ; 8270 ; 8271#if !defined(NO_FILESYSTEMS); 8272/* Use the global passwords file, if specified by auth_gpass option,; 8273 * or search for .htpasswd in the requested directory. */; 8274static void; 8275open_auth_file(struct mg_connection *conn,; 8276 const char *path,; 8277 struct mg_file *filep); 8278{; 8279 if ((conn != NULL) && (conn->dom_ctx != NULL)) {; 8280 char ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:237415,Security,hash,hash,237415,"+ = hex[p[0] >> 4];; 8198 *to++ = hex[p[0] & 0x0f];; 8199 }; 8200 *to = '\0';; 8201}; 8202 ; 8203 ; 8204/* Return stringified MD5 hash for list of strings. Buffer must be 33 bytes.; 8205 */; 8206char *; 8207mg_md5(char buf[33], ...); 8208{; 8209 md5_byte_t hash[16];; 8210 const char *p;; 8211 va_list ap;; 8212 md5_state_t ctx;; 8213 ; 8214 md5_init(&ctx);; 8215 ; 8216 va_start(ap, buf);; 8217 while ((p = va_arg(ap, const char *)) != NULL) {; 8218 md5_append(&ctx, (const md5_byte_t *)p, strlen(p));; 8219 }; 8220 va_end(ap);; 8221 ; 8222 md5_finish(&ctx, hash);; 8223 bin2str(buf, hash, sizeof(hash));; 8224 return buf;; 8225}; 8226 ; 8227 ; 8228/* Check the user's password, return 1 if OK */; 8229static int; 8230check_password(const char *method,; 8231 const char *ha1,; 8232 const char *uri,; 8233 const char *nonce,; 8234 const char *nc,; 8235 const char *cnonce,; 8236 const char *qop,; 8237 const char *response); 8238{; 8239 char ha2[32 + 1], expected_response[32 + 1];; 8240 ; 8241 /* Some of the parameters may be NULL */; 8242 if ((method == NULL) || (nonce == NULL) || (nc == NULL) || (cnonce == NULL); 8243 || (qop == NULL) || (response == NULL)) {; 8244 return 0;; 8245 }; 8246 ; 8247 /* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */; 8248 if (strlen(response) != 32) {; 8249 return 0;; 8250 }; 8251 ; 8252 mg_md5(ha2, method, "":"", uri, NULL);; 8253 mg_md5(expected_response,; 8254 ha1,; 8255 "":"",; 8256 nonce,; 8257 "":"",; 8258 nc,; 8259 "":"",; 8260 cnonce,; 8261 "":"",; 8262 qop,; 8263 "":"",; 8264 ha2,; 8265 NULL);; 8266 ; 8267 return mg_strcasecmp(response, expected_response) == 0;; 8268}; 8269 ; 8270 ; 8271#if !defined(NO_FILESYSTEMS); 8272/* Use the global passwords file, if specified by auth_gpass option,; 8273 * or search for .htpasswd in the requested directory. */; 8274static void; 8275open_auth_file(struct mg_connection *conn,; 8276 const char *path,; 8277 struct mg_file *filep); 8278{; 8279 if ((conn != NULL) && (conn->dom_ctx != NULL)) {; 8280 char ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:237487,Security,password,password,237487,"+ = hex[p[0] >> 4];; 8198 *to++ = hex[p[0] & 0x0f];; 8199 }; 8200 *to = '\0';; 8201}; 8202 ; 8203 ; 8204/* Return stringified MD5 hash for list of strings. Buffer must be 33 bytes.; 8205 */; 8206char *; 8207mg_md5(char buf[33], ...); 8208{; 8209 md5_byte_t hash[16];; 8210 const char *p;; 8211 va_list ap;; 8212 md5_state_t ctx;; 8213 ; 8214 md5_init(&ctx);; 8215 ; 8216 va_start(ap, buf);; 8217 while ((p = va_arg(ap, const char *)) != NULL) {; 8218 md5_append(&ctx, (const md5_byte_t *)p, strlen(p));; 8219 }; 8220 va_end(ap);; 8221 ; 8222 md5_finish(&ctx, hash);; 8223 bin2str(buf, hash, sizeof(hash));; 8224 return buf;; 8225}; 8226 ; 8227 ; 8228/* Check the user's password, return 1 if OK */; 8229static int; 8230check_password(const char *method,; 8231 const char *ha1,; 8232 const char *uri,; 8233 const char *nonce,; 8234 const char *nc,; 8235 const char *cnonce,; 8236 const char *qop,; 8237 const char *response); 8238{; 8239 char ha2[32 + 1], expected_response[32 + 1];; 8240 ; 8241 /* Some of the parameters may be NULL */; 8242 if ((method == NULL) || (nonce == NULL) || (nc == NULL) || (cnonce == NULL); 8243 || (qop == NULL) || (response == NULL)) {; 8244 return 0;; 8245 }; 8246 ; 8247 /* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */; 8248 if (strlen(response) != 32) {; 8249 return 0;; 8250 }; 8251 ; 8252 mg_md5(ha2, method, "":"", uri, NULL);; 8253 mg_md5(expected_response,; 8254 ha1,; 8255 "":"",; 8256 nonce,; 8257 "":"",; 8258 nc,; 8259 "":"",; 8260 cnonce,; 8261 "":"",; 8262 qop,; 8263 "":"",; 8264 ha2,; 8265 NULL);; 8266 ; 8267 return mg_strcasecmp(response, expected_response) == 0;; 8268}; 8269 ; 8270 ; 8271#if !defined(NO_FILESYSTEMS); 8272/* Use the global passwords file, if specified by auth_gpass option,; 8273 * or search for .htpasswd in the requested directory. */; 8274static void; 8275open_auth_file(struct mg_connection *conn,; 8276 const char *path,; 8277 struct mg_file *filep); 8278{; 8279 if ((conn != NULL) && (conn->dom_ctx != NULL)) {; 8280 char ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:238512,Security,password,passwords,238512,"+ = hex[p[0] >> 4];; 8198 *to++ = hex[p[0] & 0x0f];; 8199 }; 8200 *to = '\0';; 8201}; 8202 ; 8203 ; 8204/* Return stringified MD5 hash for list of strings. Buffer must be 33 bytes.; 8205 */; 8206char *; 8207mg_md5(char buf[33], ...); 8208{; 8209 md5_byte_t hash[16];; 8210 const char *p;; 8211 va_list ap;; 8212 md5_state_t ctx;; 8213 ; 8214 md5_init(&ctx);; 8215 ; 8216 va_start(ap, buf);; 8217 while ((p = va_arg(ap, const char *)) != NULL) {; 8218 md5_append(&ctx, (const md5_byte_t *)p, strlen(p));; 8219 }; 8220 va_end(ap);; 8221 ; 8222 md5_finish(&ctx, hash);; 8223 bin2str(buf, hash, sizeof(hash));; 8224 return buf;; 8225}; 8226 ; 8227 ; 8228/* Check the user's password, return 1 if OK */; 8229static int; 8230check_password(const char *method,; 8231 const char *ha1,; 8232 const char *uri,; 8233 const char *nonce,; 8234 const char *nc,; 8235 const char *cnonce,; 8236 const char *qop,; 8237 const char *response); 8238{; 8239 char ha2[32 + 1], expected_response[32 + 1];; 8240 ; 8241 /* Some of the parameters may be NULL */; 8242 if ((method == NULL) || (nonce == NULL) || (nc == NULL) || (cnonce == NULL); 8243 || (qop == NULL) || (response == NULL)) {; 8244 return 0;; 8245 }; 8246 ; 8247 /* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */; 8248 if (strlen(response) != 32) {; 8249 return 0;; 8250 }; 8251 ; 8252 mg_md5(ha2, method, "":"", uri, NULL);; 8253 mg_md5(expected_response,; 8254 ha1,; 8255 "":"",; 8256 nonce,; 8257 "":"",; 8258 nc,; 8259 "":"",; 8260 cnonce,; 8261 "":"",; 8262 qop,; 8263 "":"",; 8264 ha2,; 8265 NULL);; 8266 ; 8267 return mg_strcasecmp(response, expected_response) == 0;; 8268}; 8269 ; 8270 ; 8271#if !defined(NO_FILESYSTEMS); 8272/* Use the global passwords file, if specified by auth_gpass option,; 8273 * or search for .htpasswd in the requested directory. */; 8274static void; 8275open_auth_file(struct mg_connection *conn,; 8276 const char *path,; 8277 struct mg_file *filep); 8278{; 8279 if ((conn != NULL) && (conn->dom_ctx != NULL)) {; 8280 char ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:238999,Security,password,passwords,238999,"| (nc == NULL) || (cnonce == NULL); 8243 || (qop == NULL) || (response == NULL)) {; 8244 return 0;; 8245 }; 8246 ; 8247 /* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */; 8248 if (strlen(response) != 32) {; 8249 return 0;; 8250 }; 8251 ; 8252 mg_md5(ha2, method, "":"", uri, NULL);; 8253 mg_md5(expected_response,; 8254 ha1,; 8255 "":"",; 8256 nonce,; 8257 "":"",; 8258 nc,; 8259 "":"",; 8260 cnonce,; 8261 "":"",; 8262 qop,; 8263 "":"",; 8264 ha2,; 8265 NULL);; 8266 ; 8267 return mg_strcasecmp(response, expected_response) == 0;; 8268}; 8269 ; 8270 ; 8271#if !defined(NO_FILESYSTEMS); 8272/* Use the global passwords file, if specified by auth_gpass option,; 8273 * or search for .htpasswd in the requested directory. */; 8274static void; 8275open_auth_file(struct mg_connection *conn,; 8276 const char *path,; 8277 struct mg_file *filep); 8278{; 8279 if ((conn != NULL) && (conn->dom_ctx != NULL)) {; 8280 char name[UTF8_PATH_MAX];; 8281 const char *p, *e,; 8282 *gpass = conn->dom_ctx->config[GLOBAL_PASSWORDS_FILE];; 8283 int truncated;; 8284 ; 8285 if (gpass != NULL) {; 8286 /* Use global passwords file */; 8287 if (!mg_fopen(conn, gpass, MG_FOPEN_MODE_READ, filep)) {; 8288#if defined(DEBUG); 8289 /* Use mg_cry_internal here, since gpass has been; 8290 * configured. */; 8291 mg_cry_internal(conn, ""fopen(%s): %s"", gpass, strerror(ERRNO));; 8292#endif; 8293 }; 8294 /* Important: using local struct mg_file to test path for; 8295 * is_directory flag. If filep is used, mg_stat() makes it; 8296 * appear as if auth file was opened.; 8297 * TODO(mid): Check if this is still required after rewriting; 8298 * mg_stat */; 8299 } else if (mg_stat(conn, path, &filep->stat); 8300 && filep->stat.is_directory) {; 8301 mg_snprintf(conn,; 8302 &truncated,; 8303 name,; 8304 sizeof(name),; 8305 ""%s/%s"",; 8306 path,; 8307 PASSWORDS_FILE_NAME);; 8308 ; 8309 if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {; 8310#if defined(DEBUG); 8311 /* Don't use mg_cry_internal here, but onl",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:240002,Security,password,password,240002,"86 /* Use global passwords file */; 8287 if (!mg_fopen(conn, gpass, MG_FOPEN_MODE_READ, filep)) {; 8288#if defined(DEBUG); 8289 /* Use mg_cry_internal here, since gpass has been; 8290 * configured. */; 8291 mg_cry_internal(conn, ""fopen(%s): %s"", gpass, strerror(ERRNO));; 8292#endif; 8293 }; 8294 /* Important: using local struct mg_file to test path for; 8295 * is_directory flag. If filep is used, mg_stat() makes it; 8296 * appear as if auth file was opened.; 8297 * TODO(mid): Check if this is still required after rewriting; 8298 * mg_stat */; 8299 } else if (mg_stat(conn, path, &filep->stat); 8300 && filep->stat.is_directory) {; 8301 mg_snprintf(conn,; 8302 &truncated,; 8303 name,; 8304 sizeof(name),; 8305 ""%s/%s"",; 8306 path,; 8307 PASSWORDS_FILE_NAME);; 8308 ; 8309 if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {; 8310#if defined(DEBUG); 8311 /* Don't use mg_cry_internal here, but only a trace, since; 8312 * this is a typical case. It will occur for every directory; 8313 * without a password file. */; 8314 DEBUG_TRACE(""fopen(%s): %s"", name, strerror(ERRNO));; 8315#endif; 8316 }; 8317 } else {; 8318 /* Try to find .htpasswd in requested directory. */; 8319 for (p = path, e = p + strlen(p) - 1; e > p; e--) {; 8320 if (e[0] == '/') {; 8321 break;; 8322 }; 8323 }; 8324 mg_snprintf(conn,; 8325 &truncated,; 8326 name,; 8327 sizeof(name),; 8328 ""%.*s/%s"",; 8329 (int)(e - p),; 8330 p,; 8331 PASSWORDS_FILE_NAME);; 8332 ; 8333 if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {; 8334#if defined(DEBUG); 8335 /* Don't use mg_cry_internal here, but only a trace, since; 8336 * this is a typical case. It will occur for every directory; 8337 * without a password file. */; 8338 DEBUG_TRACE(""fopen(%s): %s"", name, strerror(ERRNO));; 8339#endif; 8340 }; 8341 }; 8342 }; 8343}; 8344#endif /* NO_FILESYSTEMS */; 8345 ; 8346 ; 8347/* Parsed Authorization header */; 8348struct ah {; 8349 char *user, *uri, *cnonce, *response, *qop, *nc, *nonce;; 8350};; 8",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:240687,Security,password,password,240687,"ame,; 8304 sizeof(name),; 8305 ""%s/%s"",; 8306 path,; 8307 PASSWORDS_FILE_NAME);; 8308 ; 8309 if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {; 8310#if defined(DEBUG); 8311 /* Don't use mg_cry_internal here, but only a trace, since; 8312 * this is a typical case. It will occur for every directory; 8313 * without a password file. */; 8314 DEBUG_TRACE(""fopen(%s): %s"", name, strerror(ERRNO));; 8315#endif; 8316 }; 8317 } else {; 8318 /* Try to find .htpasswd in requested directory. */; 8319 for (p = path, e = p + strlen(p) - 1; e > p; e--) {; 8320 if (e[0] == '/') {; 8321 break;; 8322 }; 8323 }; 8324 mg_snprintf(conn,; 8325 &truncated,; 8326 name,; 8327 sizeof(name),; 8328 ""%.*s/%s"",; 8329 (int)(e - p),; 8330 p,; 8331 PASSWORDS_FILE_NAME);; 8332 ; 8333 if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {; 8334#if defined(DEBUG); 8335 /* Don't use mg_cry_internal here, but only a trace, since; 8336 * this is a typical case. It will occur for every directory; 8337 * without a password file. */; 8338 DEBUG_TRACE(""fopen(%s): %s"", name, strerror(ERRNO));; 8339#endif; 8340 }; 8341 }; 8342 }; 8343}; 8344#endif /* NO_FILESYSTEMS */; 8345 ; 8346 ; 8347/* Parsed Authorization header */; 8348struct ah {; 8349 char *user, *uri, *cnonce, *response, *qop, *nc, *nonce;; 8350};; 8351 ; 8352 ; 8353/* Return 1 on success. Always initializes the ah structure. */; 8354static int; 8355parse_auth_header(struct mg_connection *conn,; 8356 char *buf,; 8357 size_t buf_size,; 8358 struct ah *ah); 8359{; 8360 char *name, *value, *s;; 8361 const char *auth_header;; 8362 uint64_t nonce;; 8363 ; 8364 if (!ah || !conn) {; 8365 return 0;; 8366 }; 8367 ; 8368 (void)memset(ah, 0, sizeof(*ah));; 8369 if (((auth_header = mg_get_header(conn, ""Authorization"")) == NULL); 8370 || mg_strncasecmp(auth_header, ""Digest "", 7) != 0) {; 8371 return 0;; 8372 }; 8373 ; 8374 /* Make modifiable copy of the auth header */; 8375 (void)mg_strlcpy(buf, auth_header + 7, buf_size);; 8376 s = b",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:241694,Security,authoriz,authorization,241694,"filep)) {; 8334#if defined(DEBUG); 8335 /* Don't use mg_cry_internal here, but only a trace, since; 8336 * this is a typical case. It will occur for every directory; 8337 * without a password file. */; 8338 DEBUG_TRACE(""fopen(%s): %s"", name, strerror(ERRNO));; 8339#endif; 8340 }; 8341 }; 8342 }; 8343}; 8344#endif /* NO_FILESYSTEMS */; 8345 ; 8346 ; 8347/* Parsed Authorization header */; 8348struct ah {; 8349 char *user, *uri, *cnonce, *response, *qop, *nc, *nonce;; 8350};; 8351 ; 8352 ; 8353/* Return 1 on success. Always initializes the ah structure. */; 8354static int; 8355parse_auth_header(struct mg_connection *conn,; 8356 char *buf,; 8357 size_t buf_size,; 8358 struct ah *ah); 8359{; 8360 char *name, *value, *s;; 8361 const char *auth_header;; 8362 uint64_t nonce;; 8363 ; 8364 if (!ah || !conn) {; 8365 return 0;; 8366 }; 8367 ; 8368 (void)memset(ah, 0, sizeof(*ah));; 8369 if (((auth_header = mg_get_header(conn, ""Authorization"")) == NULL); 8370 || mg_strncasecmp(auth_header, ""Digest "", 7) != 0) {; 8371 return 0;; 8372 }; 8373 ; 8374 /* Make modifiable copy of the auth header */; 8375 (void)mg_strlcpy(buf, auth_header + 7, buf_size);; 8376 s = buf;; 8377 ; 8378 /* Parse authorization header */; 8379 for (;;) {; 8380 /* Gobble initial spaces */; 8381 while (isspace((unsigned char)*s)) {; 8382 s++;; 8383 }; 8384 name = skip_quoted(&s, ""="", "" "", 0);; 8385 /* Value is either quote-delimited, or ends at first comma or space.; 8386 */; 8387 if (s[0] == '\""') {; 8388 s++;; 8389 value = skip_quoted(&s, ""\"""", "" "", '\\');; 8390 if (s[0] == ',') {; 8391 s++;; 8392 }; 8393 } else {; 8394 value = skip_quoted(&s, "", "", "" "", 0); /* IE uses commas, FF; 8395 * uses spaces */; 8396 }; 8397 if (*name == '\0') {; 8398 break;; 8399 }; 8400 ; 8401 if (!strcmp(name, ""username"")) {; 8402 ah->user = value;; 8403 } else if (!strcmp(name, ""cnonce"")) {; 8404 ah->cnonce = value;; 8405 } else if (!strcmp(name, ""response"")) {; 8406 ah->response = value;; 8407 } else if (!strcmp(name, ""uri"")) {; ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:243604,Security,access,access,243604,"->qop = value;; 8411 } else if (!strcmp(name, ""nc"")) {; 8412 ah->nc = value;; 8413 } else if (!strcmp(name, ""nonce"")) {; 8414 ah->nonce = value;; 8415 }; 8416 }; 8417 ; 8418#if !defined(NO_NONCE_CHECK); 8419 /* Read the nonce from the response. */; 8420 if (ah->nonce == NULL) {; 8421 return 0;; 8422 }; 8423 s = NULL;; 8424 nonce = strtoull(ah->nonce, &s, 10);; 8425 if ((s == NULL) || (*s != 0)) {; 8426 return 0;; 8427 }; 8428 ; 8429 /* Convert the nonce from the client to a number. */; 8430 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8431 ; 8432 /* The converted number corresponds to the time the nounce has been; 8433 * created. This should not be earlier than the server start. */; 8434 /* Server side nonce check is valuable in all situations but one:; 8435 * if the server restarts frequently, but the client should not see; 8436 * that, so the server should accept nonces from previous starts. */; 8437 /* However, the reasonable default is to not accept a nonce from a; 8438 * previous start, so if anyone changed the access rights between; 8439 * two restarts, a new login is required. */; 8440 if (nonce < (uint64_t)conn->phys_ctx->start_time) {; 8441 /* nonce is from a previous start of the server and no longer valid; 8442 * (replay attack?) */; 8443 return 0;; 8444 }; 8445 /* Check if the nonce is too high, so it has not (yet) been used by the; 8446 * server. */; 8447 if (nonce >= ((uint64_t)conn->phys_ctx->start_time; 8448 + conn->dom_ctx->nonce_count)) {; 8449 return 0;; 8450 }; 8451#else; 8452 (void)nonce;; 8453#endif; 8454 ; 8455 /* CGI needs it as REMOTE_USER */; 8456 if (ah->user != NULL) {; 8457 conn->request_info.remote_user =; 8458 mg_strdup_ctx(ah->user, conn->phys_ctx);; 8459 } else {; 8460 return 0;; 8461 }; 8462 ; 8463 return 1;; 8464}; 8465 ; 8466 ; 8467static const char *; 8468mg_fgets(char *buf, size_t size, struct mg_file *filep); 8469{; 8470 if (!filep) {; 8471 return NULL;; 8472 }; 8473 ; 8474 if (filep->access.fp != NULL) {; 8475 return fgets(buf, (",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:243824,Security,attack,attack,243824,"sponse. */; 8420 if (ah->nonce == NULL) {; 8421 return 0;; 8422 }; 8423 s = NULL;; 8424 nonce = strtoull(ah->nonce, &s, 10);; 8425 if ((s == NULL) || (*s != 0)) {; 8426 return 0;; 8427 }; 8428 ; 8429 /* Convert the nonce from the client to a number. */; 8430 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8431 ; 8432 /* The converted number corresponds to the time the nounce has been; 8433 * created. This should not be earlier than the server start. */; 8434 /* Server side nonce check is valuable in all situations but one:; 8435 * if the server restarts frequently, but the client should not see; 8436 * that, so the server should accept nonces from previous starts. */; 8437 /* However, the reasonable default is to not accept a nonce from a; 8438 * previous start, so if anyone changed the access rights between; 8439 * two restarts, a new login is required. */; 8440 if (nonce < (uint64_t)conn->phys_ctx->start_time) {; 8441 /* nonce is from a previous start of the server and no longer valid; 8442 * (replay attack?) */; 8443 return 0;; 8444 }; 8445 /* Check if the nonce is too high, so it has not (yet) been used by the; 8446 * server. */; 8447 if (nonce >= ((uint64_t)conn->phys_ctx->start_time; 8448 + conn->dom_ctx->nonce_count)) {; 8449 return 0;; 8450 }; 8451#else; 8452 (void)nonce;; 8453#endif; 8454 ; 8455 /* CGI needs it as REMOTE_USER */; 8456 if (ah->user != NULL) {; 8457 conn->request_info.remote_user =; 8458 mg_strdup_ctx(ah->user, conn->phys_ctx);; 8459 } else {; 8460 return 0;; 8461 }; 8462 ; 8463 return 1;; 8464}; 8465 ; 8466 ; 8467static const char *; 8468mg_fgets(char *buf, size_t size, struct mg_file *filep); 8469{; 8470 if (!filep) {; 8471 return NULL;; 8472 }; 8473 ; 8474 if (filep->access.fp != NULL) {; 8475 return fgets(buf, (int)size, filep->access.fp);; 8476 } else {; 8477 return NULL;; 8478 }; 8479}; 8480 ; 8481/* Define the initial recursion depth for procesesing htpasswd files that; 8482 * include other htpasswd; 8483 * (or even the same) files. It is not",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:244529,Security,access,access,244529,"but the client should not see; 8436 * that, so the server should accept nonces from previous starts. */; 8437 /* However, the reasonable default is to not accept a nonce from a; 8438 * previous start, so if anyone changed the access rights between; 8439 * two restarts, a new login is required. */; 8440 if (nonce < (uint64_t)conn->phys_ctx->start_time) {; 8441 /* nonce is from a previous start of the server and no longer valid; 8442 * (replay attack?) */; 8443 return 0;; 8444 }; 8445 /* Check if the nonce is too high, so it has not (yet) been used by the; 8446 * server. */; 8447 if (nonce >= ((uint64_t)conn->phys_ctx->start_time; 8448 + conn->dom_ctx->nonce_count)) {; 8449 return 0;; 8450 }; 8451#else; 8452 (void)nonce;; 8453#endif; 8454 ; 8455 /* CGI needs it as REMOTE_USER */; 8456 if (ah->user != NULL) {; 8457 conn->request_info.remote_user =; 8458 mg_strdup_ctx(ah->user, conn->phys_ctx);; 8459 } else {; 8460 return 0;; 8461 }; 8462 ; 8463 return 1;; 8464}; 8465 ; 8466 ; 8467static const char *; 8468mg_fgets(char *buf, size_t size, struct mg_file *filep); 8469{; 8470 if (!filep) {; 8471 return NULL;; 8472 }; 8473 ; 8474 if (filep->access.fp != NULL) {; 8475 return fgets(buf, (int)size, filep->access.fp);; 8476 } else {; 8477 return NULL;; 8478 }; 8479}; 8480 ; 8481/* Define the initial recursion depth for procesesing htpasswd files that; 8482 * include other htpasswd; 8483 * (or even the same) files. It is not difficult to provide a file or files; 8484 * s.t. they force civetweb; 8485 * to infinitely recurse and then crash.; 8486 */; 8487#define INITIAL_DEPTH 9; 8488#if INITIAL_DEPTH <= 0; 8489#error Bad INITIAL_DEPTH for recursion, set to at least 1; 8490#endif; 8491 ; 8492#if !defined(NO_FILESYSTEMS); 8493struct read_auth_file_struct {; 8494 struct mg_connection *conn;; 8495 struct ah ah;; 8496 const char *domain;; 8497 char buf[256 + 256 + 40];; 8498 const char *f_user;; 8499 const char *f_domain;; 8500 const char *f_ha1;; 8501};; 8502 ; 8503 ; 8504static int; 8",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:244592,Security,access,access,244592,"ious start, so if anyone changed the access rights between; 8439 * two restarts, a new login is required. */; 8440 if (nonce < (uint64_t)conn->phys_ctx->start_time) {; 8441 /* nonce is from a previous start of the server and no longer valid; 8442 * (replay attack?) */; 8443 return 0;; 8444 }; 8445 /* Check if the nonce is too high, so it has not (yet) been used by the; 8446 * server. */; 8447 if (nonce >= ((uint64_t)conn->phys_ctx->start_time; 8448 + conn->dom_ctx->nonce_count)) {; 8449 return 0;; 8450 }; 8451#else; 8452 (void)nonce;; 8453#endif; 8454 ; 8455 /* CGI needs it as REMOTE_USER */; 8456 if (ah->user != NULL) {; 8457 conn->request_info.remote_user =; 8458 mg_strdup_ctx(ah->user, conn->phys_ctx);; 8459 } else {; 8460 return 0;; 8461 }; 8462 ; 8463 return 1;; 8464}; 8465 ; 8466 ; 8467static const char *; 8468mg_fgets(char *buf, size_t size, struct mg_file *filep); 8469{; 8470 if (!filep) {; 8471 return NULL;; 8472 }; 8473 ; 8474 if (filep->access.fp != NULL) {; 8475 return fgets(buf, (int)size, filep->access.fp);; 8476 } else {; 8477 return NULL;; 8478 }; 8479}; 8480 ; 8481/* Define the initial recursion depth for procesesing htpasswd files that; 8482 * include other htpasswd; 8483 * (or even the same) files. It is not difficult to provide a file or files; 8484 * s.t. they force civetweb; 8485 * to infinitely recurse and then crash.; 8486 */; 8487#define INITIAL_DEPTH 9; 8488#if INITIAL_DEPTH <= 0; 8489#error Bad INITIAL_DEPTH for recursion, set to at least 1; 8490#endif; 8491 ; 8492#if !defined(NO_FILESYSTEMS); 8493struct read_auth_file_struct {; 8494 struct mg_connection *conn;; 8495 struct ah ah;; 8496 const char *domain;; 8497 char buf[256 + 256 + 40];; 8498 const char *f_user;; 8499 const char *f_domain;; 8500 const char *f_ha1;; 8501};; 8502 ; 8503 ; 8504static int; 8505read_auth_file(struct mg_file *filep,; 8506 struct read_auth_file_struct *workdata,; 8507 int depth); 8508{; 8509 int is_authorized = 0;; 8510 struct mg_file fp;; 8511 size_t l;; 8512 ; ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:245666,Security,password,passwords,245666,"r even the same) files. It is not difficult to provide a file or files; 8484 * s.t. they force civetweb; 8485 * to infinitely recurse and then crash.; 8486 */; 8487#define INITIAL_DEPTH 9; 8488#if INITIAL_DEPTH <= 0; 8489#error Bad INITIAL_DEPTH for recursion, set to at least 1; 8490#endif; 8491 ; 8492#if !defined(NO_FILESYSTEMS); 8493struct read_auth_file_struct {; 8494 struct mg_connection *conn;; 8495 struct ah ah;; 8496 const char *domain;; 8497 char buf[256 + 256 + 40];; 8498 const char *f_user;; 8499 const char *f_domain;; 8500 const char *f_ha1;; 8501};; 8502 ; 8503 ; 8504static int; 8505read_auth_file(struct mg_file *filep,; 8506 struct read_auth_file_struct *workdata,; 8507 int depth); 8508{; 8509 int is_authorized = 0;; 8510 struct mg_file fp;; 8511 size_t l;; 8512 ; 8513 if (!filep || !workdata || (0 == depth)) {; 8514 return 0;; 8515 }; 8516 ; 8517 /* Loop over passwords file */; 8518 while (mg_fgets(workdata->buf, sizeof(workdata->buf), filep) != NULL) {; 8519 l = strlen(workdata->buf);; 8520 while (l > 0) {; 8521 if (isspace((unsigned char)workdata->buf[l - 1]); 8522 || iscntrl((unsigned char)workdata->buf[l - 1])) {; 8523 l--;; 8524 workdata->buf[l] = 0;; 8525 } else; 8526 break;; 8527 }; 8528 if (l < 1) {; 8529 continue;; 8530 }; 8531 ; 8532 workdata->f_user = workdata->buf;; 8533 ; 8534 if (workdata->f_user[0] == ':') {; 8535 /* user names may not contain a ':' and may not be empty,; 8536 * so lines starting with ':' may be used for a special purpose; 8537 */; 8538 if (workdata->f_user[1] == '#') {; 8539 /* :# is a comment */; 8540 continue;; 8541 } else if (!strncmp(workdata->f_user + 1, ""include="", 8)) {; 8542 if (mg_fopen(workdata->conn,; 8543 workdata->f_user + 9,; 8544 MG_FOPEN_MODE_READ,; 8545 &fp)) {; 8546 is_authorized = read_auth_file(&fp, workdata, depth - 1);; 8547 (void)mg_fclose(; 8548 &fp.access); /* ignore error on read only file */; 8549 ; 8550 /* No need to continue processing files once we have a; 8551 * match, since nothing will r",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:246631,Security,access,access,246631,"f, sizeof(workdata->buf), filep) != NULL) {; 8519 l = strlen(workdata->buf);; 8520 while (l > 0) {; 8521 if (isspace((unsigned char)workdata->buf[l - 1]); 8522 || iscntrl((unsigned char)workdata->buf[l - 1])) {; 8523 l--;; 8524 workdata->buf[l] = 0;; 8525 } else; 8526 break;; 8527 }; 8528 if (l < 1) {; 8529 continue;; 8530 }; 8531 ; 8532 workdata->f_user = workdata->buf;; 8533 ; 8534 if (workdata->f_user[0] == ':') {; 8535 /* user names may not contain a ':' and may not be empty,; 8536 * so lines starting with ':' may be used for a special purpose; 8537 */; 8538 if (workdata->f_user[1] == '#') {; 8539 /* :# is a comment */; 8540 continue;; 8541 } else if (!strncmp(workdata->f_user + 1, ""include="", 8)) {; 8542 if (mg_fopen(workdata->conn,; 8543 workdata->f_user + 9,; 8544 MG_FOPEN_MODE_READ,; 8545 &fp)) {; 8546 is_authorized = read_auth_file(&fp, workdata, depth - 1);; 8547 (void)mg_fclose(; 8548 &fp.access); /* ignore error on read only file */; 8549 ; 8550 /* No need to continue processing files once we have a; 8551 * match, since nothing will reset it back; 8552 * to 0.; 8553 */; 8554 if (is_authorized) {; 8555 return is_authorized;; 8556 }; 8557 } else {; 8558 mg_cry_internal(workdata->conn,; 8559 ""%s: cannot open authorization file: %s"",; 8560 __func__,; 8561 workdata->buf);; 8562 }; 8563 continue;; 8564 }; 8565 /* everything is invalid for the moment (might change in the; 8566 * future) */; 8567 mg_cry_internal(workdata->conn,; 8568 ""%s: syntax error in authorization file: %s"",; 8569 __func__,; 8570 workdata->buf);; 8571 continue;; 8572 }; 8573 ; 8574 workdata->f_domain = strchr(workdata->f_user, ':');; 8575 if (workdata->f_domain == NULL) {; 8576 mg_cry_internal(workdata->conn,; 8577 ""%s: syntax error in authorization file: %s"",; 8578 __func__,; 8579 workdata->buf);; 8580 continue;; 8581 }; 8582 *(char *)(workdata->f_domain) = 0;; 8583 (workdata->f_domain)++;; 8584 ; 8585 workdata->f_ha1 = strchr(workdata->f_domain, ':');; 8586 if (workdata->f_ha1 == NULL) {; 8",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:246955,Security,authoriz,authorization,246955,"p(workdata->f_user + 1, ""include="", 8)) {; 8542 if (mg_fopen(workdata->conn,; 8543 workdata->f_user + 9,; 8544 MG_FOPEN_MODE_READ,; 8545 &fp)) {; 8546 is_authorized = read_auth_file(&fp, workdata, depth - 1);; 8547 (void)mg_fclose(; 8548 &fp.access); /* ignore error on read only file */; 8549 ; 8550 /* No need to continue processing files once we have a; 8551 * match, since nothing will reset it back; 8552 * to 0.; 8553 */; 8554 if (is_authorized) {; 8555 return is_authorized;; 8556 }; 8557 } else {; 8558 mg_cry_internal(workdata->conn,; 8559 ""%s: cannot open authorization file: %s"",; 8560 __func__,; 8561 workdata->buf);; 8562 }; 8563 continue;; 8564 }; 8565 /* everything is invalid for the moment (might change in the; 8566 * future) */; 8567 mg_cry_internal(workdata->conn,; 8568 ""%s: syntax error in authorization file: %s"",; 8569 __func__,; 8570 workdata->buf);; 8571 continue;; 8572 }; 8573 ; 8574 workdata->f_domain = strchr(workdata->f_user, ':');; 8575 if (workdata->f_domain == NULL) {; 8576 mg_cry_internal(workdata->conn,; 8577 ""%s: syntax error in authorization file: %s"",; 8578 __func__,; 8579 workdata->buf);; 8580 continue;; 8581 }; 8582 *(char *)(workdata->f_domain) = 0;; 8583 (workdata->f_domain)++;; 8584 ; 8585 workdata->f_ha1 = strchr(workdata->f_domain, ':');; 8586 if (workdata->f_ha1 == NULL) {; 8587 mg_cry_internal(workdata->conn,; 8588 ""%s: syntax error in authorization file: %s"",; 8589 __func__,; 8590 workdata->buf);; 8591 continue;; 8592 }; 8593 *(char *)(workdata->f_ha1) = 0;; 8594 (workdata->f_ha1)++;; 8595 ; 8596 if (!strcmp(workdata->ah.user, workdata->f_user); 8597 && !strcmp(workdata->domain, workdata->f_domain)) {; 8598 return check_password(workdata->conn->request_info.request_method,; 8599 workdata->f_ha1,; 8600 workdata->ah.uri,; 8601 workdata->ah.nonce,; 8602 workdata->ah.nc,; 8603 workdata->ah.cnonce,; 8604 workdata->ah.qop,; 8605 workdata->ah.response);; 8606 }; 8607 }; 8608 ; 8609 return is_authorized;; 8610}; 8611 ; 8612 ; 8613/* Autho",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:247201,Security,authoriz,authorization,247201,"p(workdata->f_user + 1, ""include="", 8)) {; 8542 if (mg_fopen(workdata->conn,; 8543 workdata->f_user + 9,; 8544 MG_FOPEN_MODE_READ,; 8545 &fp)) {; 8546 is_authorized = read_auth_file(&fp, workdata, depth - 1);; 8547 (void)mg_fclose(; 8548 &fp.access); /* ignore error on read only file */; 8549 ; 8550 /* No need to continue processing files once we have a; 8551 * match, since nothing will reset it back; 8552 * to 0.; 8553 */; 8554 if (is_authorized) {; 8555 return is_authorized;; 8556 }; 8557 } else {; 8558 mg_cry_internal(workdata->conn,; 8559 ""%s: cannot open authorization file: %s"",; 8560 __func__,; 8561 workdata->buf);; 8562 }; 8563 continue;; 8564 }; 8565 /* everything is invalid for the moment (might change in the; 8566 * future) */; 8567 mg_cry_internal(workdata->conn,; 8568 ""%s: syntax error in authorization file: %s"",; 8569 __func__,; 8570 workdata->buf);; 8571 continue;; 8572 }; 8573 ; 8574 workdata->f_domain = strchr(workdata->f_user, ':');; 8575 if (workdata->f_domain == NULL) {; 8576 mg_cry_internal(workdata->conn,; 8577 ""%s: syntax error in authorization file: %s"",; 8578 __func__,; 8579 workdata->buf);; 8580 continue;; 8581 }; 8582 *(char *)(workdata->f_domain) = 0;; 8583 (workdata->f_domain)++;; 8584 ; 8585 workdata->f_ha1 = strchr(workdata->f_domain, ':');; 8586 if (workdata->f_ha1 == NULL) {; 8587 mg_cry_internal(workdata->conn,; 8588 ""%s: syntax error in authorization file: %s"",; 8589 __func__,; 8590 workdata->buf);; 8591 continue;; 8592 }; 8593 *(char *)(workdata->f_ha1) = 0;; 8594 (workdata->f_ha1)++;; 8595 ; 8596 if (!strcmp(workdata->ah.user, workdata->f_user); 8597 && !strcmp(workdata->domain, workdata->f_domain)) {; 8598 return check_password(workdata->conn->request_info.request_method,; 8599 workdata->f_ha1,; 8600 workdata->ah.uri,; 8601 workdata->ah.nonce,; 8602 workdata->ah.nc,; 8603 workdata->ah.cnonce,; 8604 workdata->ah.qop,; 8605 workdata->ah.response);; 8606 }; 8607 }; 8608 ; 8609 return is_authorized;; 8610}; 8611 ; 8612 ; 8613/* Autho",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:247458,Security,authoriz,authorization,247458,"p(workdata->f_user + 1, ""include="", 8)) {; 8542 if (mg_fopen(workdata->conn,; 8543 workdata->f_user + 9,; 8544 MG_FOPEN_MODE_READ,; 8545 &fp)) {; 8546 is_authorized = read_auth_file(&fp, workdata, depth - 1);; 8547 (void)mg_fclose(; 8548 &fp.access); /* ignore error on read only file */; 8549 ; 8550 /* No need to continue processing files once we have a; 8551 * match, since nothing will reset it back; 8552 * to 0.; 8553 */; 8554 if (is_authorized) {; 8555 return is_authorized;; 8556 }; 8557 } else {; 8558 mg_cry_internal(workdata->conn,; 8559 ""%s: cannot open authorization file: %s"",; 8560 __func__,; 8561 workdata->buf);; 8562 }; 8563 continue;; 8564 }; 8565 /* everything is invalid for the moment (might change in the; 8566 * future) */; 8567 mg_cry_internal(workdata->conn,; 8568 ""%s: syntax error in authorization file: %s"",; 8569 __func__,; 8570 workdata->buf);; 8571 continue;; 8572 }; 8573 ; 8574 workdata->f_domain = strchr(workdata->f_user, ':');; 8575 if (workdata->f_domain == NULL) {; 8576 mg_cry_internal(workdata->conn,; 8577 ""%s: syntax error in authorization file: %s"",; 8578 __func__,; 8579 workdata->buf);; 8580 continue;; 8581 }; 8582 *(char *)(workdata->f_domain) = 0;; 8583 (workdata->f_domain)++;; 8584 ; 8585 workdata->f_ha1 = strchr(workdata->f_domain, ':');; 8586 if (workdata->f_ha1 == NULL) {; 8587 mg_cry_internal(workdata->conn,; 8588 ""%s: syntax error in authorization file: %s"",; 8589 __func__,; 8590 workdata->buf);; 8591 continue;; 8592 }; 8593 *(char *)(workdata->f_ha1) = 0;; 8594 (workdata->f_ha1)++;; 8595 ; 8596 if (!strcmp(workdata->ah.user, workdata->f_user); 8597 && !strcmp(workdata->domain, workdata->f_domain)) {; 8598 return check_password(workdata->conn->request_info.request_method,; 8599 workdata->f_ha1,; 8600 workdata->ah.uri,; 8601 workdata->ah.nonce,; 8602 workdata->ah.nc,; 8603 workdata->ah.cnonce,; 8604 workdata->ah.qop,; 8605 workdata->ah.response);; 8606 }; 8607 }; 8608 ; 8609 return is_authorized;; 8610}; 8611 ; 8612 ; 8613/* Autho",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:247782,Security,authoriz,authorization,247782,"p(workdata->f_user + 1, ""include="", 8)) {; 8542 if (mg_fopen(workdata->conn,; 8543 workdata->f_user + 9,; 8544 MG_FOPEN_MODE_READ,; 8545 &fp)) {; 8546 is_authorized = read_auth_file(&fp, workdata, depth - 1);; 8547 (void)mg_fclose(; 8548 &fp.access); /* ignore error on read only file */; 8549 ; 8550 /* No need to continue processing files once we have a; 8551 * match, since nothing will reset it back; 8552 * to 0.; 8553 */; 8554 if (is_authorized) {; 8555 return is_authorized;; 8556 }; 8557 } else {; 8558 mg_cry_internal(workdata->conn,; 8559 ""%s: cannot open authorization file: %s"",; 8560 __func__,; 8561 workdata->buf);; 8562 }; 8563 continue;; 8564 }; 8565 /* everything is invalid for the moment (might change in the; 8566 * future) */; 8567 mg_cry_internal(workdata->conn,; 8568 ""%s: syntax error in authorization file: %s"",; 8569 __func__,; 8570 workdata->buf);; 8571 continue;; 8572 }; 8573 ; 8574 workdata->f_domain = strchr(workdata->f_user, ':');; 8575 if (workdata->f_domain == NULL) {; 8576 mg_cry_internal(workdata->conn,; 8577 ""%s: syntax error in authorization file: %s"",; 8578 __func__,; 8579 workdata->buf);; 8580 continue;; 8581 }; 8582 *(char *)(workdata->f_domain) = 0;; 8583 (workdata->f_domain)++;; 8584 ; 8585 workdata->f_ha1 = strchr(workdata->f_domain, ':');; 8586 if (workdata->f_ha1 == NULL) {; 8587 mg_cry_internal(workdata->conn,; 8588 ""%s: syntax error in authorization file: %s"",; 8589 __func__,; 8590 workdata->buf);; 8591 continue;; 8592 }; 8593 *(char *)(workdata->f_ha1) = 0;; 8594 (workdata->f_ha1)++;; 8595 ; 8596 if (!strcmp(workdata->ah.user, workdata->f_user); 8597 && !strcmp(workdata->domain, workdata->f_domain)) {; 8598 return check_password(workdata->conn->request_info.request_method,; 8599 workdata->f_ha1,; 8600 workdata->ah.uri,; 8601 workdata->ah.nonce,; 8602 workdata->ah.nc,; 8603 workdata->ah.cnonce,; 8604 workdata->ah.qop,; 8605 workdata->ah.response);; 8606 }; 8607 }; 8608 ; 8609 return is_authorized;; 8610}; 8611 ; 8612 ; 8613/* Autho",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:248413,Security,password,passwords,248413,"f (workdata->f_domain == NULL) {; 8576 mg_cry_internal(workdata->conn,; 8577 ""%s: syntax error in authorization file: %s"",; 8578 __func__,; 8579 workdata->buf);; 8580 continue;; 8581 }; 8582 *(char *)(workdata->f_domain) = 0;; 8583 (workdata->f_domain)++;; 8584 ; 8585 workdata->f_ha1 = strchr(workdata->f_domain, ':');; 8586 if (workdata->f_ha1 == NULL) {; 8587 mg_cry_internal(workdata->conn,; 8588 ""%s: syntax error in authorization file: %s"",; 8589 __func__,; 8590 workdata->buf);; 8591 continue;; 8592 }; 8593 *(char *)(workdata->f_ha1) = 0;; 8594 (workdata->f_ha1)++;; 8595 ; 8596 if (!strcmp(workdata->ah.user, workdata->f_user); 8597 && !strcmp(workdata->domain, workdata->f_domain)) {; 8598 return check_password(workdata->conn->request_info.request_method,; 8599 workdata->f_ha1,; 8600 workdata->ah.uri,; 8601 workdata->ah.nonce,; 8602 workdata->ah.nc,; 8603 workdata->ah.cnonce,; 8604 workdata->ah.qop,; 8605 workdata->ah.response);; 8606 }; 8607 }; 8608 ; 8609 return is_authorized;; 8610}; 8611 ; 8612 ; 8613/* Authorize against the opened passwords file. Return 1 if authorized. */; 8614static int; 8615authorize(struct mg_connection *conn, struct mg_file *filep, const char *realm); 8616{; 8617 struct read_auth_file_struct workdata;; 8618 char buf[MG_BUF_LEN];; 8619 ; 8620 if (!conn || !conn->dom_ctx) {; 8621 return 0;; 8622 }; 8623 ; 8624 memset(&workdata, 0, sizeof(workdata));; 8625 workdata.conn = conn;; 8626 ; 8627 if (!parse_auth_header(conn, buf, sizeof(buf), &workdata.ah)) {; 8628 return 0;; 8629 }; 8630 ; 8631 if (realm) {; 8632 workdata.domain = realm;; 8633 } else {; 8634 workdata.domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8635 }; 8636 ; 8637 return read_auth_file(filep, &workdata, INITIAL_DEPTH);; 8638}; 8639 ; 8640 ; 8641/* Public function to check http digest authentication header */; 8642int; 8643mg_check_digest_access_authentication(struct mg_connection *conn,; 8644 const char *realm,; 8645 const char *filename); 8646{; 8647 struct mg_file fil",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:248441,Security,authoriz,authorized,248441,": syntax error in authorization file: %s"",; 8578 __func__,; 8579 workdata->buf);; 8580 continue;; 8581 }; 8582 *(char *)(workdata->f_domain) = 0;; 8583 (workdata->f_domain)++;; 8584 ; 8585 workdata->f_ha1 = strchr(workdata->f_domain, ':');; 8586 if (workdata->f_ha1 == NULL) {; 8587 mg_cry_internal(workdata->conn,; 8588 ""%s: syntax error in authorization file: %s"",; 8589 __func__,; 8590 workdata->buf);; 8591 continue;; 8592 }; 8593 *(char *)(workdata->f_ha1) = 0;; 8594 (workdata->f_ha1)++;; 8595 ; 8596 if (!strcmp(workdata->ah.user, workdata->f_user); 8597 && !strcmp(workdata->domain, workdata->f_domain)) {; 8598 return check_password(workdata->conn->request_info.request_method,; 8599 workdata->f_ha1,; 8600 workdata->ah.uri,; 8601 workdata->ah.nonce,; 8602 workdata->ah.nc,; 8603 workdata->ah.cnonce,; 8604 workdata->ah.qop,; 8605 workdata->ah.response);; 8606 }; 8607 }; 8608 ; 8609 return is_authorized;; 8610}; 8611 ; 8612 ; 8613/* Authorize against the opened passwords file. Return 1 if authorized. */; 8614static int; 8615authorize(struct mg_connection *conn, struct mg_file *filep, const char *realm); 8616{; 8617 struct read_auth_file_struct workdata;; 8618 char buf[MG_BUF_LEN];; 8619 ; 8620 if (!conn || !conn->dom_ctx) {; 8621 return 0;; 8622 }; 8623 ; 8624 memset(&workdata, 0, sizeof(workdata));; 8625 workdata.conn = conn;; 8626 ; 8627 if (!parse_auth_header(conn, buf, sizeof(buf), &workdata.ah)) {; 8628 return 0;; 8629 }; 8630 ; 8631 if (realm) {; 8632 workdata.domain = realm;; 8633 } else {; 8634 workdata.domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8635 }; 8636 ; 8637 return read_auth_file(filep, &workdata, INITIAL_DEPTH);; 8638}; 8639 ; 8640 ; 8641/* Public function to check http digest authentication header */; 8642int; 8643mg_check_digest_access_authentication(struct mg_connection *conn,; 8644 const char *realm,; 8645 const char *filename); 8646{; 8647 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8648 int auth;; 8649 ; 8650 if (!conn || !filenam",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:249172,Security,authenticat,authentication,249172,"06 }; 8607 }; 8608 ; 8609 return is_authorized;; 8610}; 8611 ; 8612 ; 8613/* Authorize against the opened passwords file. Return 1 if authorized. */; 8614static int; 8615authorize(struct mg_connection *conn, struct mg_file *filep, const char *realm); 8616{; 8617 struct read_auth_file_struct workdata;; 8618 char buf[MG_BUF_LEN];; 8619 ; 8620 if (!conn || !conn->dom_ctx) {; 8621 return 0;; 8622 }; 8623 ; 8624 memset(&workdata, 0, sizeof(workdata));; 8625 workdata.conn = conn;; 8626 ; 8627 if (!parse_auth_header(conn, buf, sizeof(buf), &workdata.ah)) {; 8628 return 0;; 8629 }; 8630 ; 8631 if (realm) {; 8632 workdata.domain = realm;; 8633 } else {; 8634 workdata.domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8635 }; 8636 ; 8637 return read_auth_file(filep, &workdata, INITIAL_DEPTH);; 8638}; 8639 ; 8640 ; 8641/* Public function to check http digest authentication header */; 8642int; 8643mg_check_digest_access_authentication(struct mg_connection *conn,; 8644 const char *realm,; 8645 const char *filename); 8646{; 8647 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8648 int auth;; 8649 ; 8650 if (!conn || !filename) {; 8651 return -1;; 8652 }; 8653 if (!mg_fopen(conn, filename, MG_FOPEN_MODE_READ, &file)) {; 8654 return -2;; 8655 }; 8656 ; 8657 auth = authorize(conn, &file, realm);; 8658 ; 8659 mg_fclose(&file.access);; 8660 ; 8661 return auth;; 8662}; 8663#endif /* NO_FILESYSTEMS */; 8664 ; 8665 ; 8666/* Return 1 if request is authorised, 0 otherwise. */; 8667static int; 8668check_authorization(struct mg_connection *conn, const char *path); 8669{; 8670#if !defined(NO_FILESYSTEMS); 8671 char fname[UTF8_PATH_MAX];; 8672 struct vec uri_vec, filename_vec;; 8673 const char *list;; 8674 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8675 int authorized = 1, truncated;; 8676 ; 8677 if (!conn || !conn->dom_ctx) {; 8678 return 0;; 8679 }; 8680 ; 8681 list = conn->dom_ctx->config[PROTECT_URI];; 8682 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 868",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:249581,Security,authoriz,authorize,249581,"06 }; 8607 }; 8608 ; 8609 return is_authorized;; 8610}; 8611 ; 8612 ; 8613/* Authorize against the opened passwords file. Return 1 if authorized. */; 8614static int; 8615authorize(struct mg_connection *conn, struct mg_file *filep, const char *realm); 8616{; 8617 struct read_auth_file_struct workdata;; 8618 char buf[MG_BUF_LEN];; 8619 ; 8620 if (!conn || !conn->dom_ctx) {; 8621 return 0;; 8622 }; 8623 ; 8624 memset(&workdata, 0, sizeof(workdata));; 8625 workdata.conn = conn;; 8626 ; 8627 if (!parse_auth_header(conn, buf, sizeof(buf), &workdata.ah)) {; 8628 return 0;; 8629 }; 8630 ; 8631 if (realm) {; 8632 workdata.domain = realm;; 8633 } else {; 8634 workdata.domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8635 }; 8636 ; 8637 return read_auth_file(filep, &workdata, INITIAL_DEPTH);; 8638}; 8639 ; 8640 ; 8641/* Public function to check http digest authentication header */; 8642int; 8643mg_check_digest_access_authentication(struct mg_connection *conn,; 8644 const char *realm,; 8645 const char *filename); 8646{; 8647 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8648 int auth;; 8649 ; 8650 if (!conn || !filename) {; 8651 return -1;; 8652 }; 8653 if (!mg_fopen(conn, filename, MG_FOPEN_MODE_READ, &file)) {; 8654 return -2;; 8655 }; 8656 ; 8657 auth = authorize(conn, &file, realm);; 8658 ; 8659 mg_fclose(&file.access);; 8660 ; 8661 return auth;; 8662}; 8663#endif /* NO_FILESYSTEMS */; 8664 ; 8665 ; 8666/* Return 1 if request is authorised, 0 otherwise. */; 8667static int; 8668check_authorization(struct mg_connection *conn, const char *path); 8669{; 8670#if !defined(NO_FILESYSTEMS); 8671 char fname[UTF8_PATH_MAX];; 8672 struct vec uri_vec, filename_vec;; 8673 const char *list;; 8674 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8675 int authorized = 1, truncated;; 8676 ; 8677 if (!conn || !conn->dom_ctx) {; 8678 return 0;; 8679 }; 8680 ; 8681 list = conn->dom_ctx->config[PROTECT_URI];; 8682 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 868",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:249641,Security,access,access,249641,"8624 memset(&workdata, 0, sizeof(workdata));; 8625 workdata.conn = conn;; 8626 ; 8627 if (!parse_auth_header(conn, buf, sizeof(buf), &workdata.ah)) {; 8628 return 0;; 8629 }; 8630 ; 8631 if (realm) {; 8632 workdata.domain = realm;; 8633 } else {; 8634 workdata.domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8635 }; 8636 ; 8637 return read_auth_file(filep, &workdata, INITIAL_DEPTH);; 8638}; 8639 ; 8640 ; 8641/* Public function to check http digest authentication header */; 8642int; 8643mg_check_digest_access_authentication(struct mg_connection *conn,; 8644 const char *realm,; 8645 const char *filename); 8646{; 8647 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8648 int auth;; 8649 ; 8650 if (!conn || !filename) {; 8651 return -1;; 8652 }; 8653 if (!mg_fopen(conn, filename, MG_FOPEN_MODE_READ, &file)) {; 8654 return -2;; 8655 }; 8656 ; 8657 auth = authorize(conn, &file, realm);; 8658 ; 8659 mg_fclose(&file.access);; 8660 ; 8661 return auth;; 8662}; 8663#endif /* NO_FILESYSTEMS */; 8664 ; 8665 ; 8666/* Return 1 if request is authorised, 0 otherwise. */; 8667static int; 8668check_authorization(struct mg_connection *conn, const char *path); 8669{; 8670#if !defined(NO_FILESYSTEMS); 8671 char fname[UTF8_PATH_MAX];; 8672 struct vec uri_vec, filename_vec;; 8673 const char *list;; 8674 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8675 int authorized = 1, truncated;; 8676 ; 8677 if (!conn || !conn->dom_ctx) {; 8678 return 0;; 8679 }; 8680 ; 8681 list = conn->dom_ctx->config[PROTECT_URI];; 8682 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 8683 if (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {; 8684 mg_snprintf(conn,; 8685 &truncated,; 8686 fname,; 8687 sizeof(fname),; 8688 ""%.*s"",; 8689 (int)filename_vec.len,; 8690 filename_vec.ptr);; 8691 ; 8692 if (truncated; 8693 || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {; 8694 mg_cry_internal(conn,; 8695 ""%s: cannot open %s: %s"",; 8696 __func__,; 8697 fname,; 8698 stre",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:250077,Security,authoriz,authorized,250077,"uth_file(filep, &workdata, INITIAL_DEPTH);; 8638}; 8639 ; 8640 ; 8641/* Public function to check http digest authentication header */; 8642int; 8643mg_check_digest_access_authentication(struct mg_connection *conn,; 8644 const char *realm,; 8645 const char *filename); 8646{; 8647 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8648 int auth;; 8649 ; 8650 if (!conn || !filename) {; 8651 return -1;; 8652 }; 8653 if (!mg_fopen(conn, filename, MG_FOPEN_MODE_READ, &file)) {; 8654 return -2;; 8655 }; 8656 ; 8657 auth = authorize(conn, &file, realm);; 8658 ; 8659 mg_fclose(&file.access);; 8660 ; 8661 return auth;; 8662}; 8663#endif /* NO_FILESYSTEMS */; 8664 ; 8665 ; 8666/* Return 1 if request is authorised, 0 otherwise. */; 8667static int; 8668check_authorization(struct mg_connection *conn, const char *path); 8669{; 8670#if !defined(NO_FILESYSTEMS); 8671 char fname[UTF8_PATH_MAX];; 8672 struct vec uri_vec, filename_vec;; 8673 const char *list;; 8674 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8675 int authorized = 1, truncated;; 8676 ; 8677 if (!conn || !conn->dom_ctx) {; 8678 return 0;; 8679 }; 8680 ; 8681 list = conn->dom_ctx->config[PROTECT_URI];; 8682 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 8683 if (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {; 8684 mg_snprintf(conn,; 8685 &truncated,; 8686 fname,; 8687 sizeof(fname),; 8688 ""%.*s"",; 8689 (int)filename_vec.len,; 8690 filename_vec.ptr);; 8691 ; 8692 if (truncated; 8693 || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {; 8694 mg_cry_internal(conn,; 8695 ""%s: cannot open %s: %s"",; 8696 __func__,; 8697 fname,; 8698 strerror(errno));; 8699 }; 8700 break;; 8701 }; 8702 }; 8703 ; 8704 if (!is_file_opened(&file.access)) {; 8705 open_auth_file(conn, path, &file);; 8706 }; 8707 ; 8708 if (is_file_opened(&file.access)) {; 8709 authorized = authorize(conn, &file, NULL);; 8710 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8711 }; 8712 ; 8713 return ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:250803,Security,access,access,250803,"conn, const char *path); 8669{; 8670#if !defined(NO_FILESYSTEMS); 8671 char fname[UTF8_PATH_MAX];; 8672 struct vec uri_vec, filename_vec;; 8673 const char *list;; 8674 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8675 int authorized = 1, truncated;; 8676 ; 8677 if (!conn || !conn->dom_ctx) {; 8678 return 0;; 8679 }; 8680 ; 8681 list = conn->dom_ctx->config[PROTECT_URI];; 8682 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 8683 if (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {; 8684 mg_snprintf(conn,; 8685 &truncated,; 8686 fname,; 8687 sizeof(fname),; 8688 ""%.*s"",; 8689 (int)filename_vec.len,; 8690 filename_vec.ptr);; 8691 ; 8692 if (truncated; 8693 || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {; 8694 mg_cry_internal(conn,; 8695 ""%s: cannot open %s: %s"",; 8696 __func__,; 8697 fname,; 8698 strerror(errno));; 8699 }; 8700 break;; 8701 }; 8702 }; 8703 ; 8704 if (!is_file_opened(&file.access)) {; 8705 open_auth_file(conn, path, &file);; 8706 }; 8707 ; 8708 if (is_file_opened(&file.access)) {; 8709 authorized = authorize(conn, &file, NULL);; 8710 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8711 }; 8712 ; 8713 return authorized;; 8714#else; 8715 (void)conn;; 8716 (void)path;; 8717 return 1;; 8718#endif /* NO_FILESYSTEMS */; 8719}; 8720 ; 8721 ; 8722/* Internal function. Assumes conn is valid */; 8723static void; 8724send_authorization_request(struct mg_connection *conn, const char *realm); 8725{; 8726 uint64_t nonce = (uint64_t)(conn->phys_ctx->start_time);; 8727 int trunc = 0;; 8728 char buf[128];; 8729 ; 8730 if (!realm) {; 8731 realm = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8732 }; 8733 ; 8734 mg_lock_context(conn->phys_ctx);; 8735 nonce += conn->dom_ctx->nonce_count;; 8736 ++conn->dom_ctx->nonce_count;; 8737 mg_unlock_context(conn->phys_ctx);; 8738 ; 8739 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8740 conn->must_close = 1;; 8741 ; 8742 /* Create 401 response */; 8743 mg_response_",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:250901,Security,access,access,250901,"AX];; 8672 struct vec uri_vec, filename_vec;; 8673 const char *list;; 8674 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8675 int authorized = 1, truncated;; 8676 ; 8677 if (!conn || !conn->dom_ctx) {; 8678 return 0;; 8679 }; 8680 ; 8681 list = conn->dom_ctx->config[PROTECT_URI];; 8682 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 8683 if (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {; 8684 mg_snprintf(conn,; 8685 &truncated,; 8686 fname,; 8687 sizeof(fname),; 8688 ""%.*s"",; 8689 (int)filename_vec.len,; 8690 filename_vec.ptr);; 8691 ; 8692 if (truncated; 8693 || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {; 8694 mg_cry_internal(conn,; 8695 ""%s: cannot open %s: %s"",; 8696 __func__,; 8697 fname,; 8698 strerror(errno));; 8699 }; 8700 break;; 8701 }; 8702 }; 8703 ; 8704 if (!is_file_opened(&file.access)) {; 8705 open_auth_file(conn, path, &file);; 8706 }; 8707 ; 8708 if (is_file_opened(&file.access)) {; 8709 authorized = authorize(conn, &file, NULL);; 8710 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8711 }; 8712 ; 8713 return authorized;; 8714#else; 8715 (void)conn;; 8716 (void)path;; 8717 return 1;; 8718#endif /* NO_FILESYSTEMS */; 8719}; 8720 ; 8721 ; 8722/* Internal function. Assumes conn is valid */; 8723static void; 8724send_authorization_request(struct mg_connection *conn, const char *realm); 8725{; 8726 uint64_t nonce = (uint64_t)(conn->phys_ctx->start_time);; 8727 int trunc = 0;; 8728 char buf[128];; 8729 ; 8730 if (!realm) {; 8731 realm = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8732 }; 8733 ; 8734 mg_lock_context(conn->phys_ctx);; 8735 nonce += conn->dom_ctx->nonce_count;; 8736 ++conn->dom_ctx->nonce_count;; 8737 mg_unlock_context(conn->phys_ctx);; 8738 ; 8739 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8740 conn->must_close = 1;; 8741 ; 8742 /* Create 401 response */; 8743 mg_response_header_start(conn, 401);; 8744 send_no_cache_header(conn);; 8745 send_additional_header(conn)",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:250918,Security,authoriz,authorized,250918,"AX];; 8672 struct vec uri_vec, filename_vec;; 8673 const char *list;; 8674 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8675 int authorized = 1, truncated;; 8676 ; 8677 if (!conn || !conn->dom_ctx) {; 8678 return 0;; 8679 }; 8680 ; 8681 list = conn->dom_ctx->config[PROTECT_URI];; 8682 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 8683 if (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {; 8684 mg_snprintf(conn,; 8685 &truncated,; 8686 fname,; 8687 sizeof(fname),; 8688 ""%.*s"",; 8689 (int)filename_vec.len,; 8690 filename_vec.ptr);; 8691 ; 8692 if (truncated; 8693 || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {; 8694 mg_cry_internal(conn,; 8695 ""%s: cannot open %s: %s"",; 8696 __func__,; 8697 fname,; 8698 strerror(errno));; 8699 }; 8700 break;; 8701 }; 8702 }; 8703 ; 8704 if (!is_file_opened(&file.access)) {; 8705 open_auth_file(conn, path, &file);; 8706 }; 8707 ; 8708 if (is_file_opened(&file.access)) {; 8709 authorized = authorize(conn, &file, NULL);; 8710 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8711 }; 8712 ; 8713 return authorized;; 8714#else; 8715 (void)conn;; 8716 (void)path;; 8717 return 1;; 8718#endif /* NO_FILESYSTEMS */; 8719}; 8720 ; 8721 ; 8722/* Internal function. Assumes conn is valid */; 8723static void; 8724send_authorization_request(struct mg_connection *conn, const char *realm); 8725{; 8726 uint64_t nonce = (uint64_t)(conn->phys_ctx->start_time);; 8727 int trunc = 0;; 8728 char buf[128];; 8729 ; 8730 if (!realm) {; 8731 realm = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8732 }; 8733 ; 8734 mg_lock_context(conn->phys_ctx);; 8735 nonce += conn->dom_ctx->nonce_count;; 8736 ++conn->dom_ctx->nonce_count;; 8737 mg_unlock_context(conn->phys_ctx);; 8738 ; 8739 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8740 conn->must_close = 1;; 8741 ; 8742 /* Create 401 response */; 8743 mg_response_header_start(conn, 401);; 8744 send_no_cache_header(conn);; 8745 send_additional_header(conn)",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:250931,Security,authoriz,authorize,250931,"AX];; 8672 struct vec uri_vec, filename_vec;; 8673 const char *list;; 8674 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8675 int authorized = 1, truncated;; 8676 ; 8677 if (!conn || !conn->dom_ctx) {; 8678 return 0;; 8679 }; 8680 ; 8681 list = conn->dom_ctx->config[PROTECT_URI];; 8682 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 8683 if (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {; 8684 mg_snprintf(conn,; 8685 &truncated,; 8686 fname,; 8687 sizeof(fname),; 8688 ""%.*s"",; 8689 (int)filename_vec.len,; 8690 filename_vec.ptr);; 8691 ; 8692 if (truncated; 8693 || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {; 8694 mg_cry_internal(conn,; 8695 ""%s: cannot open %s: %s"",; 8696 __func__,; 8697 fname,; 8698 strerror(errno));; 8699 }; 8700 break;; 8701 }; 8702 }; 8703 ; 8704 if (!is_file_opened(&file.access)) {; 8705 open_auth_file(conn, path, &file);; 8706 }; 8707 ; 8708 if (is_file_opened(&file.access)) {; 8709 authorized = authorize(conn, &file, NULL);; 8710 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8711 }; 8712 ; 8713 return authorized;; 8714#else; 8715 (void)conn;; 8716 (void)path;; 8717 return 1;; 8718#endif /* NO_FILESYSTEMS */; 8719}; 8720 ; 8721 ; 8722/* Internal function. Assumes conn is valid */; 8723static void; 8724send_authorization_request(struct mg_connection *conn, const char *realm); 8725{; 8726 uint64_t nonce = (uint64_t)(conn->phys_ctx->start_time);; 8727 int trunc = 0;; 8728 char buf[128];; 8729 ; 8730 if (!realm) {; 8731 realm = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8732 }; 8733 ; 8734 mg_lock_context(conn->phys_ctx);; 8735 nonce += conn->dom_ctx->nonce_count;; 8736 ++conn->dom_ctx->nonce_count;; 8737 mg_unlock_context(conn->phys_ctx);; 8738 ; 8739 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8740 conn->must_close = 1;; 8741 ; 8742 /* Create 401 response */; 8743 mg_response_header_start(conn, 401);; 8744 send_no_cache_header(conn);; 8745 send_additional_header(conn)",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:250989,Security,access,access,250989,"; 8676 ; 8677 if (!conn || !conn->dom_ctx) {; 8678 return 0;; 8679 }; 8680 ; 8681 list = conn->dom_ctx->config[PROTECT_URI];; 8682 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 8683 if (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {; 8684 mg_snprintf(conn,; 8685 &truncated,; 8686 fname,; 8687 sizeof(fname),; 8688 ""%.*s"",; 8689 (int)filename_vec.len,; 8690 filename_vec.ptr);; 8691 ; 8692 if (truncated; 8693 || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {; 8694 mg_cry_internal(conn,; 8695 ""%s: cannot open %s: %s"",; 8696 __func__,; 8697 fname,; 8698 strerror(errno));; 8699 }; 8700 break;; 8701 }; 8702 }; 8703 ; 8704 if (!is_file_opened(&file.access)) {; 8705 open_auth_file(conn, path, &file);; 8706 }; 8707 ; 8708 if (is_file_opened(&file.access)) {; 8709 authorized = authorize(conn, &file, NULL);; 8710 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8711 }; 8712 ; 8713 return authorized;; 8714#else; 8715 (void)conn;; 8716 (void)path;; 8717 return 1;; 8718#endif /* NO_FILESYSTEMS */; 8719}; 8720 ; 8721 ; 8722/* Internal function. Assumes conn is valid */; 8723static void; 8724send_authorization_request(struct mg_connection *conn, const char *realm); 8725{; 8726 uint64_t nonce = (uint64_t)(conn->phys_ctx->start_time);; 8727 int trunc = 0;; 8728 char buf[128];; 8729 ; 8730 if (!realm) {; 8731 realm = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8732 }; 8733 ; 8734 mg_lock_context(conn->phys_ctx);; 8735 nonce += conn->dom_ctx->nonce_count;; 8736 ++conn->dom_ctx->nonce_count;; 8737 mg_unlock_context(conn->phys_ctx);; 8738 ; 8739 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8740 conn->must_close = 1;; 8741 ; 8742 /* Create 401 response */; 8743 mg_response_header_start(conn, 401);; 8744 send_no_cache_header(conn);; 8745 send_additional_header(conn);; 8746 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 8747 ; 8748 /* Content for ""WWW-Authenticate"" header */; 8749 mg_snprintf(conn,; 8750 &trunc,",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:251063,Security,authoriz,authorized,251063,"; 8676 ; 8677 if (!conn || !conn->dom_ctx) {; 8678 return 0;; 8679 }; 8680 ; 8681 list = conn->dom_ctx->config[PROTECT_URI];; 8682 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 8683 if (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {; 8684 mg_snprintf(conn,; 8685 &truncated,; 8686 fname,; 8687 sizeof(fname),; 8688 ""%.*s"",; 8689 (int)filename_vec.len,; 8690 filename_vec.ptr);; 8691 ; 8692 if (truncated; 8693 || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {; 8694 mg_cry_internal(conn,; 8695 ""%s: cannot open %s: %s"",; 8696 __func__,; 8697 fname,; 8698 strerror(errno));; 8699 }; 8700 break;; 8701 }; 8702 }; 8703 ; 8704 if (!is_file_opened(&file.access)) {; 8705 open_auth_file(conn, path, &file);; 8706 }; 8707 ; 8708 if (is_file_opened(&file.access)) {; 8709 authorized = authorize(conn, &file, NULL);; 8710 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8711 }; 8712 ; 8713 return authorized;; 8714#else; 8715 (void)conn;; 8716 (void)path;; 8717 return 1;; 8718#endif /* NO_FILESYSTEMS */; 8719}; 8720 ; 8721 ; 8722/* Internal function. Assumes conn is valid */; 8723static void; 8724send_authorization_request(struct mg_connection *conn, const char *realm); 8725{; 8726 uint64_t nonce = (uint64_t)(conn->phys_ctx->start_time);; 8727 int trunc = 0;; 8728 char buf[128];; 8729 ; 8730 if (!realm) {; 8731 realm = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8732 }; 8733 ; 8734 mg_lock_context(conn->phys_ctx);; 8735 nonce += conn->dom_ctx->nonce_count;; 8736 ++conn->dom_ctx->nonce_count;; 8737 mg_unlock_context(conn->phys_ctx);; 8738 ; 8739 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8740 conn->must_close = 1;; 8741 ; 8742 /* Create 401 response */; 8743 mg_response_header_start(conn, 401);; 8744 send_no_cache_header(conn);; 8745 send_additional_header(conn);; 8746 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 8747 ; 8748 /* Content for ""WWW-Authenticate"" header */; 8749 mg_snprintf(conn,; 8750 &trunc,",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:253240,Security,authoriz,authorize,253240,"conn);; 8746 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 8747 ; 8748 /* Content for ""WWW-Authenticate"" header */; 8749 mg_snprintf(conn,; 8750 &trunc,; 8751 buf,; 8752 sizeof(buf),; 8753 ""Digest qop=\""auth\"", realm=\""%s\"", ""; 8754 ""nonce=\""%"" UINT64_FMT ""\"""",; 8755 realm,; 8756 nonce);; 8757 ; 8758 if (!trunc) {; 8759 /* !trunc should always be true */; 8760 mg_response_header_add(conn, ""WWW-Authenticate"", buf, -1);; 8761 }; 8762 ; 8763 /* Send all headers */; 8764 mg_response_header_send(conn);; 8765}; 8766 ; 8767 ; 8768/* Interface function. Parameters are provided by the user, so do; 8769 * at least some basic checks.; 8770 */; 8771int; 8772mg_send_digest_access_authentication_request(struct mg_connection *conn,; 8773 const char *realm); 8774{; 8775 if (conn && conn->dom_ctx) {; 8776 send_authorization_request(conn, realm);; 8777 return 0;; 8778 }; 8779 return -1;; 8780}; 8781 ; 8782 ; 8783#if !defined(NO_FILES); 8784static int; 8785is_authorized_for_put(struct mg_connection *conn); 8786{; 8787 if (conn) {; 8788 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8789 const char *passfile = conn->dom_ctx->config[PUT_DELETE_PASSWORDS_FILE];; 8790 int ret = 0;; 8791 ; 8792 if (passfile != NULL; 8793 && mg_fopen(conn, passfile, MG_FOPEN_MODE_READ, &file)) {; 8794 ret = authorize(conn, &file, NULL);; 8795 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8796 }; 8797 ; 8798 return ret;; 8799 }; 8800 return 0;; 8801}; 8802#endif; 8803 ; 8804 ; 8805static int; 8806modify_passwords_file(const char *fname,; 8807 const char *domain,; 8808 const char *user,; 8809 const char *pass,; 8810 const char *ha1); 8811{; 8812 int found, i;; 8813 char line[512], u[512] = """", d[512] = """", ha1buf[33],; 8814 tmp[UTF8_PATH_MAX + 8];; 8815 FILE *fp, *fp2;; 8816 ; 8817 found = 0;; 8818 fp = fp2 = NULL;; 8819 ; 8820 /* Regard empty password as no password - remove user record. */; 8821 if ((pass != NULL) && (pass[0] == '\0')) {; 8822 pass = NULL;; 8823 }; 8824 ;",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:253298,Security,access,access,253298,"checks.; 8770 */; 8771int; 8772mg_send_digest_access_authentication_request(struct mg_connection *conn,; 8773 const char *realm); 8774{; 8775 if (conn && conn->dom_ctx) {; 8776 send_authorization_request(conn, realm);; 8777 return 0;; 8778 }; 8779 return -1;; 8780}; 8781 ; 8782 ; 8783#if !defined(NO_FILES); 8784static int; 8785is_authorized_for_put(struct mg_connection *conn); 8786{; 8787 if (conn) {; 8788 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8789 const char *passfile = conn->dom_ctx->config[PUT_DELETE_PASSWORDS_FILE];; 8790 int ret = 0;; 8791 ; 8792 if (passfile != NULL; 8793 && mg_fopen(conn, passfile, MG_FOPEN_MODE_READ, &file)) {; 8794 ret = authorize(conn, &file, NULL);; 8795 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8796 }; 8797 ; 8798 return ret;; 8799 }; 8800 return 0;; 8801}; 8802#endif; 8803 ; 8804 ; 8805static int; 8806modify_passwords_file(const char *fname,; 8807 const char *domain,; 8808 const char *user,; 8809 const char *pass,; 8810 const char *ha1); 8811{; 8812 int found, i;; 8813 char line[512], u[512] = """", d[512] = """", ha1buf[33],; 8814 tmp[UTF8_PATH_MAX + 8];; 8815 FILE *fp, *fp2;; 8816 ; 8817 found = 0;; 8818 fp = fp2 = NULL;; 8819 ; 8820 /* Regard empty password as no password - remove user record. */; 8821 if ((pass != NULL) && (pass[0] == '\0')) {; 8822 pass = NULL;; 8823 }; 8824 ; 8825 /* Other arguments must not be empty */; 8826 if ((fname == NULL) || (domain == NULL) || (user == NULL)) {; 8827 return 0;; 8828 }; 8829 ; 8830 /* Using the given file format, user name and domain must not contain; 8831 * ':'; 8832 */; 8833 if (strchr(user, ':') != NULL) {; 8834 return 0;; 8835 }; 8836 if (strchr(domain, ':') != NULL) {; 8837 return 0;; 8838 }; 8839 ; 8840 /* Do not allow control characters like newline in user name and domain.; 8841 * Do not allow excessively long names either. */; 8842 for (i = 0; ((i < 255) && (user[i] != 0)); i++) {; 8843 if (iscntrl((unsigned char)user[i])) {; 8844 return 0;; 8845 }; ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:253808,Security,password,password,253808,"checks.; 8770 */; 8771int; 8772mg_send_digest_access_authentication_request(struct mg_connection *conn,; 8773 const char *realm); 8774{; 8775 if (conn && conn->dom_ctx) {; 8776 send_authorization_request(conn, realm);; 8777 return 0;; 8778 }; 8779 return -1;; 8780}; 8781 ; 8782 ; 8783#if !defined(NO_FILES); 8784static int; 8785is_authorized_for_put(struct mg_connection *conn); 8786{; 8787 if (conn) {; 8788 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8789 const char *passfile = conn->dom_ctx->config[PUT_DELETE_PASSWORDS_FILE];; 8790 int ret = 0;; 8791 ; 8792 if (passfile != NULL; 8793 && mg_fopen(conn, passfile, MG_FOPEN_MODE_READ, &file)) {; 8794 ret = authorize(conn, &file, NULL);; 8795 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8796 }; 8797 ; 8798 return ret;; 8799 }; 8800 return 0;; 8801}; 8802#endif; 8803 ; 8804 ; 8805static int; 8806modify_passwords_file(const char *fname,; 8807 const char *domain,; 8808 const char *user,; 8809 const char *pass,; 8810 const char *ha1); 8811{; 8812 int found, i;; 8813 char line[512], u[512] = """", d[512] = """", ha1buf[33],; 8814 tmp[UTF8_PATH_MAX + 8];; 8815 FILE *fp, *fp2;; 8816 ; 8817 found = 0;; 8818 fp = fp2 = NULL;; 8819 ; 8820 /* Regard empty password as no password - remove user record. */; 8821 if ((pass != NULL) && (pass[0] == '\0')) {; 8822 pass = NULL;; 8823 }; 8824 ; 8825 /* Other arguments must not be empty */; 8826 if ((fname == NULL) || (domain == NULL) || (user == NULL)) {; 8827 return 0;; 8828 }; 8829 ; 8830 /* Using the given file format, user name and domain must not contain; 8831 * ':'; 8832 */; 8833 if (strchr(user, ':') != NULL) {; 8834 return 0;; 8835 }; 8836 if (strchr(domain, ':') != NULL) {; 8837 return 0;; 8838 }; 8839 ; 8840 /* Do not allow control characters like newline in user name and domain.; 8841 * Do not allow excessively long names either. */; 8842 for (i = 0; ((i < 255) && (user[i] != 0)); i++) {; 8843 if (iscntrl((unsigned char)user[i])) {; 8844 return 0;; 8845 }; ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:253823,Security,password,password,253823,"checks.; 8770 */; 8771int; 8772mg_send_digest_access_authentication_request(struct mg_connection *conn,; 8773 const char *realm); 8774{; 8775 if (conn && conn->dom_ctx) {; 8776 send_authorization_request(conn, realm);; 8777 return 0;; 8778 }; 8779 return -1;; 8780}; 8781 ; 8782 ; 8783#if !defined(NO_FILES); 8784static int; 8785is_authorized_for_put(struct mg_connection *conn); 8786{; 8787 if (conn) {; 8788 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8789 const char *passfile = conn->dom_ctx->config[PUT_DELETE_PASSWORDS_FILE];; 8790 int ret = 0;; 8791 ; 8792 if (passfile != NULL; 8793 && mg_fopen(conn, passfile, MG_FOPEN_MODE_READ, &file)) {; 8794 ret = authorize(conn, &file, NULL);; 8795 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8796 }; 8797 ; 8798 return ret;; 8799 }; 8800 return 0;; 8801}; 8802#endif; 8803 ; 8804 ; 8805static int; 8806modify_passwords_file(const char *fname,; 8807 const char *domain,; 8808 const char *user,; 8809 const char *pass,; 8810 const char *ha1); 8811{; 8812 int found, i;; 8813 char line[512], u[512] = """", d[512] = """", ha1buf[33],; 8814 tmp[UTF8_PATH_MAX + 8];; 8815 FILE *fp, *fp2;; 8816 ; 8817 found = 0;; 8818 fp = fp2 = NULL;; 8819 ; 8820 /* Regard empty password as no password - remove user record. */; 8821 if ((pass != NULL) && (pass[0] == '\0')) {; 8822 pass = NULL;; 8823 }; 8824 ; 8825 /* Other arguments must not be empty */; 8826 if ((fname == NULL) || (domain == NULL) || (user == NULL)) {; 8827 return 0;; 8828 }; 8829 ; 8830 /* Using the given file format, user name and domain must not contain; 8831 * ':'; 8832 */; 8833 if (strchr(user, ':') != NULL) {; 8834 return 0;; 8835 }; 8836 if (strchr(domain, ':') != NULL) {; 8837 return 0;; 8838 }; 8839 ; 8840 /* Do not allow control characters like newline in user name and domain.; 8841 * Do not allow excessively long names either. */; 8842 for (i = 0; ((i < 255) && (user[i] != 0)); i++) {; 8843 if (iscntrl((unsigned char)user[i])) {; 8844 return 0;; 8845 }; ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:254866,Security,password,password,254866,"2;; 8816 ; 8817 found = 0;; 8818 fp = fp2 = NULL;; 8819 ; 8820 /* Regard empty password as no password - remove user record. */; 8821 if ((pass != NULL) && (pass[0] == '\0')) {; 8822 pass = NULL;; 8823 }; 8824 ; 8825 /* Other arguments must not be empty */; 8826 if ((fname == NULL) || (domain == NULL) || (user == NULL)) {; 8827 return 0;; 8828 }; 8829 ; 8830 /* Using the given file format, user name and domain must not contain; 8831 * ':'; 8832 */; 8833 if (strchr(user, ':') != NULL) {; 8834 return 0;; 8835 }; 8836 if (strchr(domain, ':') != NULL) {; 8837 return 0;; 8838 }; 8839 ; 8840 /* Do not allow control characters like newline in user name and domain.; 8841 * Do not allow excessively long names either. */; 8842 for (i = 0; ((i < 255) && (user[i] != 0)); i++) {; 8843 if (iscntrl((unsigned char)user[i])) {; 8844 return 0;; 8845 }; 8846 }; 8847 if (user[i]) {; 8848 return 0;; 8849 }; 8850 for (i = 0; ((i < 255) && (domain[i] != 0)); i++) {; 8851 if (iscntrl((unsigned char)domain[i])) {; 8852 return 0;; 8853 }; 8854 }; 8855 if (domain[i]) {; 8856 return 0;; 8857 }; 8858 ; 8859 /* The maximum length of the path to the password file is limited */; 8860 if ((strlen(fname) + 4) >= UTF8_PATH_MAX) {; 8861 return 0;; 8862 }; 8863 ; 8864 /* Create a temporary file name. Length has been checked before. */; 8865 strcpy(tmp, fname);; 8866 strcat(tmp, "".tmp"");; 8867 ; 8868 /* Create the file if does not exist */; 8869 /* Use of fopen here is OK, since fname is only ASCII */; 8870 if ((fp = fopen(fname, ""a+"")) != NULL) {; 8871 (void)fclose(fp);; 8872 }; 8873 ; 8874 /* Open the given file and temporary file */; 8875 if ((fp = fopen(fname, ""r"")) == NULL) {; 8876 return 0;; 8877 } else if ((fp2 = fopen(tmp, ""w+"")) == NULL) {; 8878 fclose(fp);; 8879 return 0;; 8880 }; 8881 ; 8882 /* Copy the stuff to temporary file */; 8883 while (fgets(line, sizeof(line), fp) != NULL) {; 8884 if (sscanf(line, ""%255[^:]:%255[^:]:%*s"", u, d) != 2) {; 8885 continue;; 8886 }; 8887 u[255] = 0;; 8888 d[",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:279046,Security,access,access,279046,"ata.entries != NULL) {; 9709 qsort(data.entries,; 9710 data.num_entries,; 9711 sizeof(data.entries[0]),; 9712 compare_dir_entries);; 9713 for (i = 0; i < data.num_entries; i++) {; 9714 print_dir_entry(&data.entries[i]);; 9715 mg_free(data.entries[i].file_name);; 9716 }; 9717 mg_free(data.entries);; 9718 }; 9719 ; 9720 mg_printf(conn, ""%s"", ""</table></pre></body></html>"");; 9721 conn->status_code = 200;; 9722}; 9723#endif /* NO_FILESYSTEMS */; 9724 ; 9725 ; 9726/* Send len bytes from the opened file to the client. */; 9727static void; 9728send_file_data(struct mg_connection *conn,; 9729 struct mg_file *filep,; 9730 int64_t offset,; 9731 int64_t len); 9732{; 9733 char buf[MG_BUF_LEN];; 9734 int to_read, num_read, num_written;; 9735 int64_t size;; 9736 ; 9737 if (!filep || !conn) {; 9738 return;; 9739 }; 9740 ; 9741 /* Sanity check the offset */; 9742 size = (filep->stat.size > INT64_MAX) ? INT64_MAX; 9743 : (int64_t)(filep->stat.size);; 9744 offset = (offset < 0) ? 0 : ((offset > size) ? size : offset);; 9745 ; 9746 if (len > 0 && filep->access.fp != NULL) {; 9747 /* file stored on disk */; 9748#if defined(__linux__); 9749 /* sendfile is only available for Linux */; 9750 if ((conn->ssl == 0) && (conn->throttle == 0); 9751 && (!mg_strcasecmp(conn->dom_ctx->config[ALLOW_SENDFILE_CALL],; 9752 ""yes""))) {; 9753 off_t sf_offs = (off_t)offset;; 9754 ssize_t sf_sent;; 9755 int sf_file = fileno(filep->access.fp);; 9756 int loop_cnt = 0;; 9757 ; 9758 do {; 9759 /* 2147479552 (0x7FFFF000) is a limit found by experiment on; 9760 * 64 bit Linux (2^31 minus one memory page of 4k?). */; 9761 size_t sf_tosend =; 9762 (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);; 9763 sf_sent =; 9764 sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);; 9765 if (sf_sent > 0) {; 9766 len -= sf_sent;; 9767 offset += sf_sent;; 9768 } else if (loop_cnt == 0) {; 9769 /* This file can not be sent using sendfile.; 9770 * This might be the case for pseudo-files in the; 9771 * /sys/ and /proc/ file s",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:279408,Security,access,access,279408,"ntries[i].file_name);; 9716 }; 9717 mg_free(data.entries);; 9718 }; 9719 ; 9720 mg_printf(conn, ""%s"", ""</table></pre></body></html>"");; 9721 conn->status_code = 200;; 9722}; 9723#endif /* NO_FILESYSTEMS */; 9724 ; 9725 ; 9726/* Send len bytes from the opened file to the client. */; 9727static void; 9728send_file_data(struct mg_connection *conn,; 9729 struct mg_file *filep,; 9730 int64_t offset,; 9731 int64_t len); 9732{; 9733 char buf[MG_BUF_LEN];; 9734 int to_read, num_read, num_written;; 9735 int64_t size;; 9736 ; 9737 if (!filep || !conn) {; 9738 return;; 9739 }; 9740 ; 9741 /* Sanity check the offset */; 9742 size = (filep->stat.size > INT64_MAX) ? INT64_MAX; 9743 : (int64_t)(filep->stat.size);; 9744 offset = (offset < 0) ? 0 : ((offset > size) ? size : offset);; 9745 ; 9746 if (len > 0 && filep->access.fp != NULL) {; 9747 /* file stored on disk */; 9748#if defined(__linux__); 9749 /* sendfile is only available for Linux */; 9750 if ((conn->ssl == 0) && (conn->throttle == 0); 9751 && (!mg_strcasecmp(conn->dom_ctx->config[ALLOW_SENDFILE_CALL],; 9752 ""yes""))) {; 9753 off_t sf_offs = (off_t)offset;; 9754 ssize_t sf_sent;; 9755 int sf_file = fileno(filep->access.fp);; 9756 int loop_cnt = 0;; 9757 ; 9758 do {; 9759 /* 2147479552 (0x7FFFF000) is a limit found by experiment on; 9760 * 64 bit Linux (2^31 minus one memory page of 4k?). */; 9761 size_t sf_tosend =; 9762 (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);; 9763 sf_sent =; 9764 sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);; 9765 if (sf_sent > 0) {; 9766 len -= sf_sent;; 9767 offset += sf_sent;; 9768 } else if (loop_cnt == 0) {; 9769 /* This file can not be sent using sendfile.; 9770 * This might be the case for pseudo-files in the; 9771 * /sys/ and /proc/ file system.; 9772 * Use the regular user mode copy code instead. */; 9773 break;; 9774 } else if (sf_sent == 0) {; 9775 /* No error, but 0 bytes sent. May be EOF? */; 9776 return;; 9777 }; 9778 loop_cnt++;; 9779 ; 9780 } while ((len > 0) && (sf_",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:280617,Security,access,access,280617,"y page of 4k?). */; 9761 size_t sf_tosend =; 9762 (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);; 9763 sf_sent =; 9764 sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);; 9765 if (sf_sent > 0) {; 9766 len -= sf_sent;; 9767 offset += sf_sent;; 9768 } else if (loop_cnt == 0) {; 9769 /* This file can not be sent using sendfile.; 9770 * This might be the case for pseudo-files in the; 9771 * /sys/ and /proc/ file system.; 9772 * Use the regular user mode copy code instead. */; 9773 break;; 9774 } else if (sf_sent == 0) {; 9775 /* No error, but 0 bytes sent. May be EOF? */; 9776 return;; 9777 }; 9778 loop_cnt++;; 9779 ; 9780 } while ((len > 0) && (sf_sent >= 0));; 9781 ; 9782 if (sf_sent > 0) {; 9783 return; /* OK */; 9784 }; 9785 ; 9786 /* sf_sent<0 means error, thus fall back to the classic way */; 9787 /* This is always the case, if sf_file is not a ""normal"" file,; 9788 * e.g., for sending data from the output of a CGI process. */; 9789 offset = (int64_t)sf_offs;; 9790 }; 9791#endif; 9792 if ((offset > 0) && (fseeko(filep->access.fp, offset, SEEK_SET) != 0)) {; 9793 mg_cry_internal(conn,; 9794 ""%s: fseeko() failed: %s"",; 9795 __func__,; 9796 strerror(ERRNO));; 9797 mg_send_http_error(; 9798 conn,; 9799 500,; 9800 ""%s"",; 9801 ""Error: Unable to access file at requested position."");; 9802 } else {; 9803 while (len > 0) {; 9804 /* Calculate how much to read from the file in the buffer */; 9805 to_read = sizeof(buf);; 9806 if ((int64_t)to_read > len) {; 9807 to_read = (int)len;; 9808 }; 9809 ; 9810 /* Read from file, exit the loop on error */; 9811 if ((num_read =; 9812 (int)fread(buf, 1, (size_t)to_read, filep->access.fp)); 9813 <= 0) {; 9814 break;; 9815 }; 9816 ; 9817 /* Send read bytes to the client, exit the loop on error */; 9818 if ((num_written = mg_write(conn, buf, (size_t)num_read)); 9819 != num_read) {; 9820 break;; 9821 }; 9822 ; 9823 /* Both read and were successful, adjust counters */; 9824 len -= num_written;; 9825 }; 9826 }; 9827 }; 9828}; 9829 ; 98",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:280841,Security,access,access,280841,";; 9765 if (sf_sent > 0) {; 9766 len -= sf_sent;; 9767 offset += sf_sent;; 9768 } else if (loop_cnt == 0) {; 9769 /* This file can not be sent using sendfile.; 9770 * This might be the case for pseudo-files in the; 9771 * /sys/ and /proc/ file system.; 9772 * Use the regular user mode copy code instead. */; 9773 break;; 9774 } else if (sf_sent == 0) {; 9775 /* No error, but 0 bytes sent. May be EOF? */; 9776 return;; 9777 }; 9778 loop_cnt++;; 9779 ; 9780 } while ((len > 0) && (sf_sent >= 0));; 9781 ; 9782 if (sf_sent > 0) {; 9783 return; /* OK */; 9784 }; 9785 ; 9786 /* sf_sent<0 means error, thus fall back to the classic way */; 9787 /* This is always the case, if sf_file is not a ""normal"" file,; 9788 * e.g., for sending data from the output of a CGI process. */; 9789 offset = (int64_t)sf_offs;; 9790 }; 9791#endif; 9792 if ((offset > 0) && (fseeko(filep->access.fp, offset, SEEK_SET) != 0)) {; 9793 mg_cry_internal(conn,; 9794 ""%s: fseeko() failed: %s"",; 9795 __func__,; 9796 strerror(ERRNO));; 9797 mg_send_http_error(; 9798 conn,; 9799 500,; 9800 ""%s"",; 9801 ""Error: Unable to access file at requested position."");; 9802 } else {; 9803 while (len > 0) {; 9804 /* Calculate how much to read from the file in the buffer */; 9805 to_read = sizeof(buf);; 9806 if ((int64_t)to_read > len) {; 9807 to_read = (int)len;; 9808 }; 9809 ; 9810 /* Read from file, exit the loop on error */; 9811 if ((num_read =; 9812 (int)fread(buf, 1, (size_t)to_read, filep->access.fp)); 9813 <= 0) {; 9814 break;; 9815 }; 9816 ; 9817 /* Send read bytes to the client, exit the loop on error */; 9818 if ((num_written = mg_write(conn, buf, (size_t)num_read)); 9819 != num_read) {; 9820 break;; 9821 }; 9822 ; 9823 /* Both read and were successful, adjust counters */; 9824 len -= num_written;; 9825 }; 9826 }; 9827 }; 9828}; 9829 ; 9830 ; 9831static int; 9832parse_range_header(const char *header, int64_t *a, int64_t *b); 9833{; 9834 return sscanf(header,; 9835 ""bytes=%"" INT64_FMT ""-%"" INT64_FMT,; 9836 a,; 983",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:281213,Security,access,access,281213,"stead. */; 9773 break;; 9774 } else if (sf_sent == 0) {; 9775 /* No error, but 0 bytes sent. May be EOF? */; 9776 return;; 9777 }; 9778 loop_cnt++;; 9779 ; 9780 } while ((len > 0) && (sf_sent >= 0));; 9781 ; 9782 if (sf_sent > 0) {; 9783 return; /* OK */; 9784 }; 9785 ; 9786 /* sf_sent<0 means error, thus fall back to the classic way */; 9787 /* This is always the case, if sf_file is not a ""normal"" file,; 9788 * e.g., for sending data from the output of a CGI process. */; 9789 offset = (int64_t)sf_offs;; 9790 }; 9791#endif; 9792 if ((offset > 0) && (fseeko(filep->access.fp, offset, SEEK_SET) != 0)) {; 9793 mg_cry_internal(conn,; 9794 ""%s: fseeko() failed: %s"",; 9795 __func__,; 9796 strerror(ERRNO));; 9797 mg_send_http_error(; 9798 conn,; 9799 500,; 9800 ""%s"",; 9801 ""Error: Unable to access file at requested position."");; 9802 } else {; 9803 while (len > 0) {; 9804 /* Calculate how much to read from the file in the buffer */; 9805 to_read = sizeof(buf);; 9806 if ((int64_t)to_read > len) {; 9807 to_read = (int)len;; 9808 }; 9809 ; 9810 /* Read from file, exit the loop on error */; 9811 if ((num_read =; 9812 (int)fread(buf, 1, (size_t)to_read, filep->access.fp)); 9813 <= 0) {; 9814 break;; 9815 }; 9816 ; 9817 /* Send read bytes to the client, exit the loop on error */; 9818 if ((num_written = mg_write(conn, buf, (size_t)num_read)); 9819 != num_read) {; 9820 break;; 9821 }; 9822 ; 9823 /* Both read and were successful, adjust counters */; 9824 len -= num_written;; 9825 }; 9826 }; 9827 }; 9828}; 9829 ; 9830 ; 9831static int; 9832parse_range_header(const char *header, int64_t *a, int64_t *b); 9833{; 9834 return sscanf(header,; 9835 ""bytes=%"" INT64_FMT ""-%"" INT64_FMT,; 9836 a,; 9837 b); // NOLINT(cert-err34-c) 'sscanf' used to convert a string; 9838 // to an integer value, but function will not report; 9839 // conversion errors; consider using 'strtol' instead; 9840}; 9841 ; 9842 ; 9843static void; 9844construct_etag(char *buf, size_t buf_len, const struct mg_file_stat *fil",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:286387,Security,access,access,286387,"h;; 9957 encoding = ""gzip"";; 9958 ; 9959#if defined(USE_ZLIB); 9960 /* File is already compressed. No ""on the fly"" compression. */; 9961 allow_on_the_fly_compression = 0;; 9962#endif; 9963 } else if ((conn->accept_gzip) && (range_hdr == NULL); 9964 && (filep->stat.size >= MG_FILE_COMPRESSION_SIZE_LIMIT)) {; 9965 struct mg_file_stat file_stat;; 9966 ; 9967 mg_snprintf(conn, &truncated, gz_path, sizeof(gz_path), ""%s.gz"", path);; 9968 ; 9969 if (!truncated && mg_stat(conn, gz_path, &file_stat); 9970 && !file_stat.is_directory) {; 9971 file_stat.is_gzipped = 1;; 9972 filep->stat = file_stat;; 9973 cl = (int64_t)filep->stat.size;; 9974 path = gz_path;; 9975 encoding = ""gzip"";; 9976 ; 9977#if defined(USE_ZLIB); 9978 /* File is already compressed. No ""on the fly"" compression. */; 9979 allow_on_the_fly_compression = 0;; 9980#endif; 9981 }; 9982 }; 9983 ; 9984 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {; 9985 mg_send_http_error(conn,; 9986 500,; 9987 ""Error: Cannot open file\nfopen(%s): %s"",; 9988 path,; 9989 strerror(ERRNO));; 9990 return;; 9991 }; 9992 ; 9993 fclose_on_exec(&filep->access, conn);; 9994 ; 9995 /* If ""Range"" request was made: parse header, send only selected part; 9996 * of the file. */; 9997 r1 = r2 = 0;; 9998 if ((range_hdr != NULL); 9999 && ((n = parse_range_header(range_hdr, &r1, &r2)) > 0) && (r1 >= 0); 10000 && (r2 >= 0)) {; 10001 /* actually, range requests don't play well with a pre-gzipped; 10002 * file (since the range is specified in the uncompressed space) */; 10003 if (filep->stat.is_gzipped) {; 10004 mg_send_http_error(; 10005 conn,; 10006 416, /* 416 = Range Not Satisfiable */; 10007 ""%s"",; 10008 ""Error: Range requests in gzipped files are not supported"");; 10009 (void)mg_fclose(; 10010 &filep->access); /* ignore error on read only file */; 10011 return;; 10012 }; 10013 conn->status_code = 206;; 10014 cl = (n == 2) ? (((r2 > cl) ? cl : r2) - r1 + 1) : (cl - r1);; 10015 mg_snprintf(conn,; 10016 NULL, /* range buffer is big enough */;",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:287042,Security,access,access,287042,"2 }; 9983 ; 9984 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {; 9985 mg_send_http_error(conn,; 9986 500,; 9987 ""Error: Cannot open file\nfopen(%s): %s"",; 9988 path,; 9989 strerror(ERRNO));; 9990 return;; 9991 }; 9992 ; 9993 fclose_on_exec(&filep->access, conn);; 9994 ; 9995 /* If ""Range"" request was made: parse header, send only selected part; 9996 * of the file. */; 9997 r1 = r2 = 0;; 9998 if ((range_hdr != NULL); 9999 && ((n = parse_range_header(range_hdr, &r1, &r2)) > 0) && (r1 >= 0); 10000 && (r2 >= 0)) {; 10001 /* actually, range requests don't play well with a pre-gzipped; 10002 * file (since the range is specified in the uncompressed space) */; 10003 if (filep->stat.is_gzipped) {; 10004 mg_send_http_error(; 10005 conn,; 10006 416, /* 416 = Range Not Satisfiable */; 10007 ""%s"",; 10008 ""Error: Range requests in gzipped files are not supported"");; 10009 (void)mg_fclose(; 10010 &filep->access); /* ignore error on read only file */; 10011 return;; 10012 }; 10013 conn->status_code = 206;; 10014 cl = (n == 2) ? (((r2 > cl) ? cl : r2) - r1 + 1) : (cl - r1);; 10015 mg_snprintf(conn,; 10016 NULL, /* range buffer is big enough */; 10017 range,; 10018 sizeof(range),; 10019 ""bytes ""; 10020 ""%"" INT64_FMT ""-%"" INT64_FMT ""/%"" INT64_FMT,; 10021 r1,; 10022 r1 + cl - 1,; 10023 filep->stat.size);; 10024 ; 10025#if defined(USE_ZLIB); 10026 /* Do not compress ranges. */; 10027 allow_on_the_fly_compression = 0;; 10028#endif; 10029 }; 10030 ; 10031 /* Do not compress small files. Small files do not benefit from file; 10032 * compression, but there is still some overhead. */; 10033#if defined(USE_ZLIB); 10034 if (filep->stat.size < MG_FILE_COMPRESSION_SIZE_LIMIT) {; 10035 /* File is below the size limit. */; 10036 allow_on_the_fly_compression = 0;; 10037 }; 10038#endif; 10039 ; 10040 /* Standard CORS header */; 10041 cors_orig_cfg = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];; 10042 origin_hdr = mg_get_header(conn, ""Origin"");; 10043 if (cors_orig_cfg && *cors_orig_c",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:291568,Security,access,access,291568,"7#endif; 10098 {; 10099 /* Without on-the-fly compression, we know the content-length; 10100 * and we can use ranges (with on-the-fly compression we cannot).; 10101 * So we send these response headers only in this case. */; 10102 char len[32];; 10103 int trunc = 0;; 10104 mg_snprintf(conn, &trunc, len, sizeof(len), ""%"" INT64_FMT, cl);; 10105 ; 10106 if (!trunc) {; 10107 mg_response_header_add(conn, ""Content-Length"", len, -1);; 10108 }; 10109 ; 10110 mg_response_header_add(conn, ""Accept-Ranges"", ""bytes"", -1);; 10111 }; 10112 ; 10113 if (encoding) {; 10114 mg_response_header_add(conn, ""Content-Encoding"", encoding, -1);; 10115 }; 10116 if (range[0] != 0) {; 10117 mg_response_header_add(conn, ""Content-Range"", range, -1);; 10118 }; 10119 ; 10120 /* The code above does not add any header starting with X- to make; 10121 * sure no one of the additional_headers is included twice */; 10122 if ((additional_headers != NULL) && (*additional_headers != 0)) {; 10123 mg_response_header_add_lines(conn, additional_headers);; 10124 }; 10125 ; 10126 /* Send all headers */; 10127 mg_response_header_send(conn);; 10128 ; 10129 if (!is_head_request) {; 10130#if defined(USE_ZLIB); 10131 if (allow_on_the_fly_compression) {; 10132 /* Compress and send */; 10133 send_compressed_data(conn, filep);; 10134 } else; 10135#endif; 10136 {; 10137 /* Send file directly */; 10138 send_file_data(conn, filep, r1, cl);; 10139 }; 10140 }; 10141 (void)mg_fclose(&filep->access); /* ignore error on read only file */; 10142}; 10143 ; 10144 ; 10145int; 10146mg_send_file_body(struct mg_connection *conn, const char *path); 10147{; 10148 struct mg_file file = STRUCT_FILE_INITIALIZER;; 10149 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {; 10150 return -1;; 10151 }; 10152 fclose_on_exec(&file.access, conn);; 10153 send_file_data(conn, &file, 0, INT64_MAX);; 10154 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 10155 return 0; /* >= 0 for OK */; 10156}; 10157#endif /* NO_FILESYSTEMS */;",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:291898,Security,access,access,291898,"ure no one of the additional_headers is included twice */; 10122 if ((additional_headers != NULL) && (*additional_headers != 0)) {; 10123 mg_response_header_add_lines(conn, additional_headers);; 10124 }; 10125 ; 10126 /* Send all headers */; 10127 mg_response_header_send(conn);; 10128 ; 10129 if (!is_head_request) {; 10130#if defined(USE_ZLIB); 10131 if (allow_on_the_fly_compression) {; 10132 /* Compress and send */; 10133 send_compressed_data(conn, filep);; 10134 } else; 10135#endif; 10136 {; 10137 /* Send file directly */; 10138 send_file_data(conn, filep, r1, cl);; 10139 }; 10140 }; 10141 (void)mg_fclose(&filep->access); /* ignore error on read only file */; 10142}; 10143 ; 10144 ; 10145int; 10146mg_send_file_body(struct mg_connection *conn, const char *path); 10147{; 10148 struct mg_file file = STRUCT_FILE_INITIALIZER;; 10149 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {; 10150 return -1;; 10151 }; 10152 fclose_on_exec(&file.access, conn);; 10153 send_file_data(conn, &file, 0, INT64_MAX);; 10154 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 10155 return 0; /* >= 0 for OK */; 10156}; 10157#endif /* NO_FILESYSTEMS */; 10158 ; 10159 ; 10160#if !defined(NO_CACHING); 10161/* Return True if we should reply 304 Not Modified. */; 10162static int; 10163is_not_modified(const struct mg_connection *conn,; 10164 const struct mg_file_stat *filestat); 10165{; 10166 char etag[64];; 10167 const char *ims = mg_get_header(conn, ""If-Modified-Since"");; 10168 const char *inm = mg_get_header(conn, ""If-None-Match"");; 10169 construct_etag(etag, sizeof(etag), filestat);; 10170 ; 10171 return ((inm != NULL) && !mg_strcasecmp(etag, inm)); 10172 || ((ims != NULL); 10173 && (filestat->last_modified <= parse_date_string(ims)));; 10174}; 10175 ; 10176 ; 10177static void; 10178handle_not_modified_static_file_request(struct mg_connection *conn,; 10179 struct mg_file *filep); 10180{; 10181 char lm[64], etag[64];; 10182 ; 10183 if ((conn == NULL) || (filep == NUL",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:291992,Security,access,access,291992,"lines(conn, additional_headers);; 10124 }; 10125 ; 10126 /* Send all headers */; 10127 mg_response_header_send(conn);; 10128 ; 10129 if (!is_head_request) {; 10130#if defined(USE_ZLIB); 10131 if (allow_on_the_fly_compression) {; 10132 /* Compress and send */; 10133 send_compressed_data(conn, filep);; 10134 } else; 10135#endif; 10136 {; 10137 /* Send file directly */; 10138 send_file_data(conn, filep, r1, cl);; 10139 }; 10140 }; 10141 (void)mg_fclose(&filep->access); /* ignore error on read only file */; 10142}; 10143 ; 10144 ; 10145int; 10146mg_send_file_body(struct mg_connection *conn, const char *path); 10147{; 10148 struct mg_file file = STRUCT_FILE_INITIALIZER;; 10149 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {; 10150 return -1;; 10151 }; 10152 fclose_on_exec(&file.access, conn);; 10153 send_file_data(conn, &file, 0, INT64_MAX);; 10154 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 10155 return 0; /* >= 0 for OK */; 10156}; 10157#endif /* NO_FILESYSTEMS */; 10158 ; 10159 ; 10160#if !defined(NO_CACHING); 10161/* Return True if we should reply 304 Not Modified. */; 10162static int; 10163is_not_modified(const struct mg_connection *conn,; 10164 const struct mg_file_stat *filestat); 10165{; 10166 char etag[64];; 10167 const char *ims = mg_get_header(conn, ""If-Modified-Since"");; 10168 const char *inm = mg_get_header(conn, ""If-None-Match"");; 10169 construct_etag(etag, sizeof(etag), filestat);; 10170 ; 10171 return ((inm != NULL) && !mg_strcasecmp(etag, inm)); 10172 || ((ims != NULL); 10173 && (filestat->last_modified <= parse_date_string(ims)));; 10174}; 10175 ; 10176 ; 10177static void; 10178handle_not_modified_static_file_request(struct mg_connection *conn,; 10179 struct mg_file *filep); 10180{; 10181 char lm[64], etag[64];; 10182 ; 10183 if ((conn == NULL) || (filep == NULL)) {; 10184 return;; 10185 }; 10186 ; 10187 gmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);; 10188 construct_etag(etag, sizeof(etag), &filep->stat);",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:297403,Security,access,access,297403,"07 if (r != 0) {; 10308 mg_cry_internal(conn,; 10309 ""%s: Cannot remove invalid file %s"",; 10310 __func__,; 10311 path);; 10312 }; 10313}; 10314 ; 10315 ; 10316long long; 10317mg_store_body(struct mg_connection *conn, const char *path); 10318{; 10319 char buf[MG_BUF_LEN];; 10320 long long len = 0;; 10321 int ret, n;; 10322 struct mg_file fi;; 10323 ; 10324 if (conn->consumed_content != 0) {; 10325 mg_cry_internal(conn, ""%s: Contents already consumed"", __func__);; 10326 return -11;; 10327 }; 10328 ; 10329 ret = put_dir(conn, path);; 10330 if (ret < 0) {; 10331 /* -1 for path too long,; 10332 * -2 for path can not be created. */; 10333 return ret;; 10334 }; 10335 if (ret != 1) {; 10336 /* Return 0 means, path itself is a directory. */; 10337 return 0;; 10338 }; 10339 ; 10340 if (mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &fi) == 0) {; 10341 return -12;; 10342 }; 10343 ; 10344 ret = mg_read(conn, buf, sizeof(buf));; 10345 while (ret > 0) {; 10346 n = (int)fwrite(buf, 1, (size_t)ret, fi.access.fp);; 10347 if (n != ret) {; 10348 (void)mg_fclose(; 10349 &fi.access); /* File is bad and will be removed anyway. */; 10350 remove_bad_file(conn, path);; 10351 return -13;; 10352 }; 10353 len += ret;; 10354 ret = mg_read(conn, buf, sizeof(buf));; 10355 }; 10356 ; 10357 /* File is open for writing. If fclose fails, there was probably an; 10358 * error flushing the buffer to disk, so the file on disk might be; 10359 * broken. Delete it and return an error to the caller. */; 10360 if (mg_fclose(&fi.access) != 0) {; 10361 remove_bad_file(conn, path);; 10362 return -14;; 10363 }; 10364 ; 10365 return len;; 10366}; 10367#endif /* NO_FILESYSTEMS */; 10368 ; 10369 ; 10370/* Parse a buffer:; 10371 * Forward the string pointer till the end of a word, then; 10372 * terminate it and forward till the begin of the next word.; 10373 */; 10374static int; 10375skip_to_end_of_word_and_terminate(char **ppw, int eol); 10376{; 10377 /* Forward until a space is found - use isgraph here */; 10378 /* See ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:297473,Security,access,access,297473,"0310 __func__,; 10311 path);; 10312 }; 10313}; 10314 ; 10315 ; 10316long long; 10317mg_store_body(struct mg_connection *conn, const char *path); 10318{; 10319 char buf[MG_BUF_LEN];; 10320 long long len = 0;; 10321 int ret, n;; 10322 struct mg_file fi;; 10323 ; 10324 if (conn->consumed_content != 0) {; 10325 mg_cry_internal(conn, ""%s: Contents already consumed"", __func__);; 10326 return -11;; 10327 }; 10328 ; 10329 ret = put_dir(conn, path);; 10330 if (ret < 0) {; 10331 /* -1 for path too long,; 10332 * -2 for path can not be created. */; 10333 return ret;; 10334 }; 10335 if (ret != 1) {; 10336 /* Return 0 means, path itself is a directory. */; 10337 return 0;; 10338 }; 10339 ; 10340 if (mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &fi) == 0) {; 10341 return -12;; 10342 }; 10343 ; 10344 ret = mg_read(conn, buf, sizeof(buf));; 10345 while (ret > 0) {; 10346 n = (int)fwrite(buf, 1, (size_t)ret, fi.access.fp);; 10347 if (n != ret) {; 10348 (void)mg_fclose(; 10349 &fi.access); /* File is bad and will be removed anyway. */; 10350 remove_bad_file(conn, path);; 10351 return -13;; 10352 }; 10353 len += ret;; 10354 ret = mg_read(conn, buf, sizeof(buf));; 10355 }; 10356 ; 10357 /* File is open for writing. If fclose fails, there was probably an; 10358 * error flushing the buffer to disk, so the file on disk might be; 10359 * broken. Delete it and return an error to the caller. */; 10360 if (mg_fclose(&fi.access) != 0) {; 10361 remove_bad_file(conn, path);; 10362 return -14;; 10363 }; 10364 ; 10365 return len;; 10366}; 10367#endif /* NO_FILESYSTEMS */; 10368 ; 10369 ; 10370/* Parse a buffer:; 10371 * Forward the string pointer till the end of a word, then; 10372 * terminate it and forward till the begin of the next word.; 10373 */; 10374static int; 10375skip_to_end_of_word_and_terminate(char **ppw, int eol); 10376{; 10377 /* Forward until a space is found - use isgraph here */; 10378 /* See http://www.cplusplus.com/reference/cctype/ */; 10379 while (isgraph((unsigned char)**ppw)) {",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:297912,Security,access,access,297912,"335 if (ret != 1) {; 10336 /* Return 0 means, path itself is a directory. */; 10337 return 0;; 10338 }; 10339 ; 10340 if (mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &fi) == 0) {; 10341 return -12;; 10342 }; 10343 ; 10344 ret = mg_read(conn, buf, sizeof(buf));; 10345 while (ret > 0) {; 10346 n = (int)fwrite(buf, 1, (size_t)ret, fi.access.fp);; 10347 if (n != ret) {; 10348 (void)mg_fclose(; 10349 &fi.access); /* File is bad and will be removed anyway. */; 10350 remove_bad_file(conn, path);; 10351 return -13;; 10352 }; 10353 len += ret;; 10354 ret = mg_read(conn, buf, sizeof(buf));; 10355 }; 10356 ; 10357 /* File is open for writing. If fclose fails, there was probably an; 10358 * error flushing the buffer to disk, so the file on disk might be; 10359 * broken. Delete it and return an error to the caller. */; 10360 if (mg_fclose(&fi.access) != 0) {; 10361 remove_bad_file(conn, path);; 10362 return -14;; 10363 }; 10364 ; 10365 return len;; 10366}; 10367#endif /* NO_FILESYSTEMS */; 10368 ; 10369 ; 10370/* Parse a buffer:; 10371 * Forward the string pointer till the end of a word, then; 10372 * terminate it and forward till the begin of the next word.; 10373 */; 10374static int; 10375skip_to_end_of_word_and_terminate(char **ppw, int eol); 10376{; 10377 /* Forward until a space is found - use isgraph here */; 10378 /* See http://www.cplusplus.com/reference/cctype/ */; 10379 while (isgraph((unsigned char)**ppw)) {; 10380 (*ppw)++;; 10381 }; 10382 ; 10383 /* Check end of word */; 10384 if (eol) {; 10385 /* must be a end of line */; 10386 if ((**ppw != '\r') && (**ppw != '\n')) {; 10387 return -1;; 10388 }; 10389 } else {; 10390 /* must be a end of a word, but not a line */; 10391 if (**ppw != ' ') {; 10392 return -1;; 10393 }; 10394 }; 10395 ; 10396 /* Terminate and forward to the next word */; 10397 do {; 10398 **ppw = 0;; 10399 (*ppw)++;; 10400 } while (isspace((unsigned char)**ppw));; 10401 ; 10402 /* Check after term */; 10403 if (!eol) {; 10404 /* if it's not the end of li",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:301900,Security,secur,security,301900," -1;; 10472 }; 10473 }; 10474 ; 10475 /* here *dp is either 0 or '\n' */; 10476 /* in any case, we have a new header */; 10477 num_headers = i + 1;; 10478 ; 10479 if (*dp) {; 10480 *dp = 0;; 10481 dp++;; 10482 *buf = dp;; 10483 ; 10484 if ((dp[0] == '\r') || (dp[0] == '\n')) {; 10485 /* This is the end of the header */; 10486 break;; 10487 }; 10488 } else {; 10489 *buf = dp;; 10490 break;; 10491 }; 10492 }; 10493 return num_headers;; 10494}; 10495 ; 10496 ; 10497struct mg_http_method_info {; 10498 const char *name;; 10499 int request_has_body;; 10500 int response_has_body;; 10501 int is_safe;; 10502 int is_idempotent;; 10503 int is_cacheable;; 10504};; 10505 ; 10506 ; 10507/* https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods */; 10508static const struct mg_http_method_info http_methods[] = {; 10509 /* HTTP (RFC 2616) */; 10510 {""GET"", 0, 1, 1, 1, 1},; 10511 {""POST"", 1, 1, 0, 0, 0},; 10512 {""PUT"", 1, 0, 0, 1, 0},; 10513 {""DELETE"", 0, 0, 0, 1, 0},; 10514 {""HEAD"", 0, 0, 1, 1, 1},; 10515 {""OPTIONS"", 0, 0, 1, 1, 0},; 10516 {""CONNECT"", 1, 1, 0, 0, 0},; 10517 /* TRACE method (RFC 2616) is not supported for security reasons */; 10518 ; 10519 /* PATCH method (RFC 5789) */; 10520 {""PATCH"", 1, 0, 0, 0, 0},; 10521 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10522 ; 10523 /* WEBDAV (RFC 2518) */; 10524 {""PROPFIND"", 0, 1, 1, 1, 0},; 10525 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10526 * Some PROPFIND results MAY be cached, with care,; 10527 * as there is no cache validation mechanism for; 10528 * most properties. This method is both safe and; 10529 * idempotent (see Section 9.1 of [RFC2616]). */; 10530 {""MKCOL"", 0, 0, 0, 1, 0},; 10531 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10532 * When MKCOL is invoked without a request body,; 10533 * the newly created collection SHOULD have no; 10534 * members. A MKCOL request message may contain; 10535 * a message body. The precise behavior of a MKCOL; 10536 * request when the body is present is",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:302287,Security,validat,validation,302287,"o {; 10498 const char *name;; 10499 int request_has_body;; 10500 int response_has_body;; 10501 int is_safe;; 10502 int is_idempotent;; 10503 int is_cacheable;; 10504};; 10505 ; 10506 ; 10507/* https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods */; 10508static const struct mg_http_method_info http_methods[] = {; 10509 /* HTTP (RFC 2616) */; 10510 {""GET"", 0, 1, 1, 1, 1},; 10511 {""POST"", 1, 1, 0, 0, 0},; 10512 {""PUT"", 1, 0, 0, 1, 0},; 10513 {""DELETE"", 0, 0, 0, 1, 0},; 10514 {""HEAD"", 0, 0, 1, 1, 1},; 10515 {""OPTIONS"", 0, 0, 1, 1, 0},; 10516 {""CONNECT"", 1, 1, 0, 0, 0},; 10517 /* TRACE method (RFC 2616) is not supported for security reasons */; 10518 ; 10519 /* PATCH method (RFC 5789) */; 10520 {""PATCH"", 1, 0, 0, 0, 0},; 10521 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10522 ; 10523 /* WEBDAV (RFC 2518) */; 10524 {""PROPFIND"", 0, 1, 1, 1, 0},; 10525 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10526 * Some PROPFIND results MAY be cached, with care,; 10527 * as there is no cache validation mechanism for; 10528 * most properties. This method is both safe and; 10529 * idempotent (see Section 9.1 of [RFC2616]). */; 10530 {""MKCOL"", 0, 0, 0, 1, 0},; 10531 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10532 * When MKCOL is invoked without a request body,; 10533 * the newly created collection SHOULD have no; 10534 * members. A MKCOL request message may contain; 10535 * a message body. The precise behavior of a MKCOL; 10536 * request when the body is present is undefined,; 10537 * ... ==> We do not support MKCOL with body data.; 10538 * This method is idempotent, but not safe (see; 10539 * Section 9.1 of [RFC2616]). Responses to this; 10540 * method MUST NOT be cached. */; 10541 ; 10542 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10543 {""LOCK"", 1, 1, 0, 0, 0},; 10544 {""UNLOCK"", 1, 0, 0, 0, 0},; 10545 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10546 ; 10547 /* Unsupported WEBDAV Methods: */; 10548 /* COPY, MOVE (RFC 2518) */; 10549 /* + 1",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:303027,Security,access,access,303027,"ROPFIND results MAY be cached, with care,; 10527 * as there is no cache validation mechanism for; 10528 * most properties. This method is both safe and; 10529 * idempotent (see Section 9.1 of [RFC2616]). */; 10530 {""MKCOL"", 0, 0, 0, 1, 0},; 10531 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10532 * When MKCOL is invoked without a request body,; 10533 * the newly created collection SHOULD have no; 10534 * members. A MKCOL request message may contain; 10535 * a message body. The precise behavior of a MKCOL; 10536 * request when the body is present is undefined,; 10537 * ... ==> We do not support MKCOL with body data.; 10538 * This method is idempotent, but not safe (see; 10539 * Section 9.1 of [RFC2616]). Responses to this; 10540 * method MUST NOT be cached. */; 10541 ; 10542 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10543 {""LOCK"", 1, 1, 0, 0, 0},; 10544 {""UNLOCK"", 1, 0, 0, 0, 0},; 10545 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10546 ; 10547 /* Unsupported WEBDAV Methods: */; 10548 /* COPY, MOVE (RFC 2518) */; 10549 /* + 11 methods from RFC 3253 */; 10550 /* ORDERPATCH (RFC 3648) */; 10551 /* ACL (RFC 3744) */; 10552 /* SEARCH (RFC 5323) */; 10553 /* + MicroSoft extensions; 10554 * https://msdn.microsoft.com/en-us/library/aa142917.aspx */; 10555 ; 10556 /* REPORT method (RFC 3253) */; 10557 {""REPORT"", 1, 1, 1, 1, 1},; 10558 /* REPORT method only allowed for CGI/Lua/LSP and callbacks. */; 10559 /* It was defined for WEBDAV in RFC 3253, Sec. 3.6; 10560 * (https://tools.ietf.org/html/rfc3253#section-3.6), but seems; 10561 * to be useful for REST in case a ""GET request with body"" is; 10562 * required. */; 10563 ; 10564 {NULL, 0, 0, 0, 0, 0}; 10565 /* end of list */; 10566};; 10567 ; 10568 ; 10569static const struct mg_http_method_info *; 10570get_http_method_info(const char *method); 10571{; 10572 /* Check if the method is known to the server. The list of all known; 10573 * HTTP methods can be found here at; 10574 * http://www.iana.org/assignments/http-met",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:330356,Security,access,access,330356,"1389 (void *)proc,; 11390 NULL);; 11391 }; 11392#endif; 11393 ; 11394 /* Parent closes only one side of the pipes.; 11395 * If we don't mark them as closed, close() attempt before; 11396 * return from this function throws an exception on Windows.; 11397 * Windows does not like when closed descriptor is closed again. */; 11398 (void)close(fdin[0]);; 11399 (void)close(fdout[1]);; 11400 (void)close(fderr[1]);; 11401 fdin[0] = fdout[1] = fderr[1] = -1;; 11402 ; 11403 if (((in = fdopen(fdin[1], ""wb"")) == NULL); 11404 || ((out = fdopen(fdout[0], ""rb"")) == NULL); 11405 || ((err = fdopen(fderr[0], ""rb"")) == NULL)) {; 11406 status = strerror(ERRNO);; 11407 mg_cry_internal(conn,; 11408 ""Error: CGI program \""%s\"": Can not open fd: %s"",; 11409 prog,; 11410 status);; 11411 mg_send_http_error(conn,; 11412 500,; 11413 ""Error: CGI can not open fd\nfdopen: %s"",; 11414 status);; 11415 goto done;; 11416 }; 11417 ; 11418 setbuf(in, NULL);; 11419 setbuf(out, NULL);; 11420 setbuf(err, NULL);; 11421 fout.access.fp = out;; 11422 ; 11423 if ((conn->content_len != 0) || (conn->is_chunked)) {; 11424 DEBUG_TRACE(""CGI: send body data (%"" INT64_FMT "")\n"",; 11425 conn->content_len);; 11426 ; 11427 /* This is a POST/PUT request, or another request with body data. */; 11428 if (!forward_body_data(conn, in, INVALID_SOCKET, NULL)) {; 11429 /* Error sending the body data */; 11430 mg_cry_internal(; 11431 conn,; 11432 ""Error: CGI program \""%s\"": Forward body data failed"",; 11433 prog);; 11434 goto done;; 11435 }; 11436 }; 11437 ; 11438 /* Close so child gets an EOF. */; 11439 fclose(in);; 11440 in = NULL;; 11441 fdin[1] = -1;; 11442 ; 11443 /* Now read CGI reply into a buffer. We need to set correct; 11444 * status code, thus we need to see all HTTP headers first.; 11445 * Do not send anything back to client, until we buffer in all; 11446 * HTTP headers. */; 11447 data_len = 0;; 11448 buf = (char *)mg_malloc_ctx(buflen, conn->phys_ctx);; 11449 if (buf == NULL) {; 11450 mg_send_http_error(conn,; 11451 50",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:338369,Security,access,access,338369,"mg_file file = STRUCT_FILE_INITIALIZER;; 11673 const char *range;; 11674 int64_t r1, r2;; 11675 int rc;; 11676 ; 11677 if (conn == NULL) {; 11678 return;; 11679 }; 11680 ; 11681 if (mg_stat(conn, path, &file.stat)) {; 11682 /* File already exists */; 11683 conn->status_code = 200;; 11684 ; 11685 if (file.stat.is_directory) {; 11686 /* This is an already existing directory,; 11687 * so there is nothing to do for the server. */; 11688 rc = 0;; 11689 ; 11690 } else {; 11691 /* File exists and is not a directory. */; 11692 /* Can it be replaced? */; 11693 ; 11694 /* Check if the server may write this file */; 11695 if (access(path, W_OK) == 0) {; 11696 /* Access granted */; 11697 rc = 1;; 11698 } else {; 11699 mg_send_http_error(; 11700 conn,; 11701 403,; 11702 ""Error: Put not possible\nReplacing %s is not allowed"",; 11703 path);; 11704 return;; 11705 }; 11706 }; 11707 } else {; 11708 /* File should be created */; 11709 conn->status_code = 201;; 11710 rc = put_dir(conn, path);; 11711 }; 11712 ; 11713 if (rc == 0) {; 11714 /* put_dir returns 0 if path is a directory */; 11715 ; 11716 /* Create response */; 11717 mg_response_header_start(conn, conn->status_code);; 11718 send_no_cache_header(conn);; 11719 send_additional_header(conn);; 11720 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11721 ; 11722 /* Send all headers - there is no body */; 11723 mg_response_header_send(conn);; 11724 ; 11725 /* Request to create a directory has been fulfilled successfully.; 11726 * No need to put a file. */; 11727 return;; 11728 }; 11729 ; 11730 if (rc == -1) {; 11731 /* put_dir returns -1 if the path is too long */; 11732 mg_send_http_error(conn,; 11733 414,; 11734 ""Error: Path too long\nput_dir(%s): %s"",; 11735 path,; 11736 strerror(ERRNO));; 11737 return;; 11738 }; 11739 ; 11740 if (rc == -2) {; 11741 /* put_dir returns -2 if the directory can not be created */; 11742 mg_send_http_error(conn,; 11743 500,; 11744 ""Error: Can not create directory\nput_dir(%s): %s"",; 11745 path",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:339914,Security,access,access,339914,"r_start(conn, conn->status_code);; 11718 send_no_cache_header(conn);; 11719 send_additional_header(conn);; 11720 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11721 ; 11722 /* Send all headers - there is no body */; 11723 mg_response_header_send(conn);; 11724 ; 11725 /* Request to create a directory has been fulfilled successfully.; 11726 * No need to put a file. */; 11727 return;; 11728 }; 11729 ; 11730 if (rc == -1) {; 11731 /* put_dir returns -1 if the path is too long */; 11732 mg_send_http_error(conn,; 11733 414,; 11734 ""Error: Path too long\nput_dir(%s): %s"",; 11735 path,; 11736 strerror(ERRNO));; 11737 return;; 11738 }; 11739 ; 11740 if (rc == -2) {; 11741 /* put_dir returns -2 if the directory can not be created */; 11742 mg_send_http_error(conn,; 11743 500,; 11744 ""Error: Can not create directory\nput_dir(%s): %s"",; 11745 path,; 11746 strerror(ERRNO));; 11747 return;; 11748 }; 11749 ; 11750 /* A file should be created or overwritten. */; 11751 /* Currently CivetWeb does not nead read+write access. */; 11752 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11753 || file.access.fp == NULL) {; 11754 (void)mg_fclose(&file.access);; 11755 mg_send_http_error(conn,; 11756 500,; 11757 ""Error: Can not create file\nfopen(%s): %s"",; 11758 path,; 11759 strerror(ERRNO));; 11760 return;; 11761 }; 11762 ; 11763 fclose_on_exec(&file.access, conn);; 11764 range = mg_get_header(conn, ""Content-Range"");; 11765 r1 = r2 = 0;; 11766 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11767 conn->status_code = 206; /* Partial content */; 11768 fseeko(file.access.fp, r1, SEEK_SET);; 11769 }; 11770 ; 11771 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11772 /* forward_body_data failed.; 11773 * The error code has already been sent to the client,; 11774 * and conn->status_code is already set. */; 11775 (void)mg_fclose(&file.access);; 11776 return;; 11777 }; 11778 ; 11779 if (mg_fclose(&file.access) != 0) {; 11780 /* fclose fail",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:340001,Security,access,access,340001,"response_header_add(conn, ""Content-Length"", ""0"", -1);; 11721 ; 11722 /* Send all headers - there is no body */; 11723 mg_response_header_send(conn);; 11724 ; 11725 /* Request to create a directory has been fulfilled successfully.; 11726 * No need to put a file. */; 11727 return;; 11728 }; 11729 ; 11730 if (rc == -1) {; 11731 /* put_dir returns -1 if the path is too long */; 11732 mg_send_http_error(conn,; 11733 414,; 11734 ""Error: Path too long\nput_dir(%s): %s"",; 11735 path,; 11736 strerror(ERRNO));; 11737 return;; 11738 }; 11739 ; 11740 if (rc == -2) {; 11741 /* put_dir returns -2 if the directory can not be created */; 11742 mg_send_http_error(conn,; 11743 500,; 11744 ""Error: Can not create directory\nput_dir(%s): %s"",; 11745 path,; 11746 strerror(ERRNO));; 11747 return;; 11748 }; 11749 ; 11750 /* A file should be created or overwritten. */; 11751 /* Currently CivetWeb does not nead read+write access. */; 11752 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11753 || file.access.fp == NULL) {; 11754 (void)mg_fclose(&file.access);; 11755 mg_send_http_error(conn,; 11756 500,; 11757 ""Error: Can not create file\nfopen(%s): %s"",; 11758 path,; 11759 strerror(ERRNO));; 11760 return;; 11761 }; 11762 ; 11763 fclose_on_exec(&file.access, conn);; 11764 range = mg_get_header(conn, ""Content-Range"");; 11765 r1 = r2 = 0;; 11766 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11767 conn->status_code = 206; /* Partial content */; 11768 fseeko(file.access.fp, r1, SEEK_SET);; 11769 }; 11770 ; 11771 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11772 /* forward_body_data failed.; 11773 * The error code has already been sent to the client,; 11774 * and conn->status_code is already set. */; 11775 (void)mg_fclose(&file.access);; 11776 return;; 11777 }; 11778 ; 11779 if (mg_fclose(&file.access) != 0) {; 11780 /* fclose failed. This might have different reasons, but a likely; 11781 * one is ""no space on disk"", http 507. */; 11782 conn->st",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:340051,Security,access,access,340051,"; 11724 ; 11725 /* Request to create a directory has been fulfilled successfully.; 11726 * No need to put a file. */; 11727 return;; 11728 }; 11729 ; 11730 if (rc == -1) {; 11731 /* put_dir returns -1 if the path is too long */; 11732 mg_send_http_error(conn,; 11733 414,; 11734 ""Error: Path too long\nput_dir(%s): %s"",; 11735 path,; 11736 strerror(ERRNO));; 11737 return;; 11738 }; 11739 ; 11740 if (rc == -2) {; 11741 /* put_dir returns -2 if the directory can not be created */; 11742 mg_send_http_error(conn,; 11743 500,; 11744 ""Error: Can not create directory\nput_dir(%s): %s"",; 11745 path,; 11746 strerror(ERRNO));; 11747 return;; 11748 }; 11749 ; 11750 /* A file should be created or overwritten. */; 11751 /* Currently CivetWeb does not nead read+write access. */; 11752 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11753 || file.access.fp == NULL) {; 11754 (void)mg_fclose(&file.access);; 11755 mg_send_http_error(conn,; 11756 500,; 11757 ""Error: Can not create file\nfopen(%s): %s"",; 11758 path,; 11759 strerror(ERRNO));; 11760 return;; 11761 }; 11762 ; 11763 fclose_on_exec(&file.access, conn);; 11764 range = mg_get_header(conn, ""Content-Range"");; 11765 r1 = r2 = 0;; 11766 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11767 conn->status_code = 206; /* Partial content */; 11768 fseeko(file.access.fp, r1, SEEK_SET);; 11769 }; 11770 ; 11771 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11772 /* forward_body_data failed.; 11773 * The error code has already been sent to the client,; 11774 * and conn->status_code is already set. */; 11775 (void)mg_fclose(&file.access);; 11776 return;; 11777 }; 11778 ; 11779 if (mg_fclose(&file.access) != 0) {; 11780 /* fclose failed. This might have different reasons, but a likely; 11781 * one is ""no space on disk"", http 507. */; 11782 conn->status_code = 507;; 11783 }; 11784 ; 11785 /* Create response (status_code has been set before) */; 11786 mg_response_header_start(conn, conn->status_",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:340254,Security,access,access,340254," long */; 11732 mg_send_http_error(conn,; 11733 414,; 11734 ""Error: Path too long\nput_dir(%s): %s"",; 11735 path,; 11736 strerror(ERRNO));; 11737 return;; 11738 }; 11739 ; 11740 if (rc == -2) {; 11741 /* put_dir returns -2 if the directory can not be created */; 11742 mg_send_http_error(conn,; 11743 500,; 11744 ""Error: Can not create directory\nput_dir(%s): %s"",; 11745 path,; 11746 strerror(ERRNO));; 11747 return;; 11748 }; 11749 ; 11750 /* A file should be created or overwritten. */; 11751 /* Currently CivetWeb does not nead read+write access. */; 11752 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11753 || file.access.fp == NULL) {; 11754 (void)mg_fclose(&file.access);; 11755 mg_send_http_error(conn,; 11756 500,; 11757 ""Error: Can not create file\nfopen(%s): %s"",; 11758 path,; 11759 strerror(ERRNO));; 11760 return;; 11761 }; 11762 ; 11763 fclose_on_exec(&file.access, conn);; 11764 range = mg_get_header(conn, ""Content-Range"");; 11765 r1 = r2 = 0;; 11766 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11767 conn->status_code = 206; /* Partial content */; 11768 fseeko(file.access.fp, r1, SEEK_SET);; 11769 }; 11770 ; 11771 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11772 /* forward_body_data failed.; 11773 * The error code has already been sent to the client,; 11774 * and conn->status_code is already set. */; 11775 (void)mg_fclose(&file.access);; 11776 return;; 11777 }; 11778 ; 11779 if (mg_fclose(&file.access) != 0) {; 11780 /* fclose failed. This might have different reasons, but a likely; 11781 * one is ""no space on disk"", http 507. */; 11782 conn->status_code = 507;; 11783 }; 11784 ; 11785 /* Create response (status_code has been set before) */; 11786 mg_response_header_start(conn, conn->status_code);; 11787 send_no_cache_header(conn);; 11788 send_additional_header(conn);; 11789 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11790 ; 11791 /* Send all headers - there is no body */; 11792 mg_response",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:340488,Security,access,access,340488," strerror(ERRNO));; 11737 return;; 11738 }; 11739 ; 11740 if (rc == -2) {; 11741 /* put_dir returns -2 if the directory can not be created */; 11742 mg_send_http_error(conn,; 11743 500,; 11744 ""Error: Can not create directory\nput_dir(%s): %s"",; 11745 path,; 11746 strerror(ERRNO));; 11747 return;; 11748 }; 11749 ; 11750 /* A file should be created or overwritten. */; 11751 /* Currently CivetWeb does not nead read+write access. */; 11752 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11753 || file.access.fp == NULL) {; 11754 (void)mg_fclose(&file.access);; 11755 mg_send_http_error(conn,; 11756 500,; 11757 ""Error: Can not create file\nfopen(%s): %s"",; 11758 path,; 11759 strerror(ERRNO));; 11760 return;; 11761 }; 11762 ; 11763 fclose_on_exec(&file.access, conn);; 11764 range = mg_get_header(conn, ""Content-Range"");; 11765 r1 = r2 = 0;; 11766 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11767 conn->status_code = 206; /* Partial content */; 11768 fseeko(file.access.fp, r1, SEEK_SET);; 11769 }; 11770 ; 11771 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11772 /* forward_body_data failed.; 11773 * The error code has already been sent to the client,; 11774 * and conn->status_code is already set. */; 11775 (void)mg_fclose(&file.access);; 11776 return;; 11777 }; 11778 ; 11779 if (mg_fclose(&file.access) != 0) {; 11780 /* fclose failed. This might have different reasons, but a likely; 11781 * one is ""no space on disk"", http 507. */; 11782 conn->status_code = 507;; 11783 }; 11784 ; 11785 /* Create response (status_code has been set before) */; 11786 mg_response_header_start(conn, conn->status_code);; 11787 send_no_cache_header(conn);; 11788 send_additional_header(conn);; 11789 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11790 ; 11791 /* Send all headers - there is no body */; 11792 mg_response_header_send(conn);; 11793}; 11794 ; 11795 ; 11796static void; 11797delete_file(struct mg_connection *conn, const char *p",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:340572,Security,access,access,340572,"put_dir returns -2 if the directory can not be created */; 11742 mg_send_http_error(conn,; 11743 500,; 11744 ""Error: Can not create directory\nput_dir(%s): %s"",; 11745 path,; 11746 strerror(ERRNO));; 11747 return;; 11748 }; 11749 ; 11750 /* A file should be created or overwritten. */; 11751 /* Currently CivetWeb does not nead read+write access. */; 11752 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11753 || file.access.fp == NULL) {; 11754 (void)mg_fclose(&file.access);; 11755 mg_send_http_error(conn,; 11756 500,; 11757 ""Error: Can not create file\nfopen(%s): %s"",; 11758 path,; 11759 strerror(ERRNO));; 11760 return;; 11761 }; 11762 ; 11763 fclose_on_exec(&file.access, conn);; 11764 range = mg_get_header(conn, ""Content-Range"");; 11765 r1 = r2 = 0;; 11766 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11767 conn->status_code = 206; /* Partial content */; 11768 fseeko(file.access.fp, r1, SEEK_SET);; 11769 }; 11770 ; 11771 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11772 /* forward_body_data failed.; 11773 * The error code has already been sent to the client,; 11774 * and conn->status_code is already set. */; 11775 (void)mg_fclose(&file.access);; 11776 return;; 11777 }; 11778 ; 11779 if (mg_fclose(&file.access) != 0) {; 11780 /* fclose failed. This might have different reasons, but a likely; 11781 * one is ""no space on disk"", http 507. */; 11782 conn->status_code = 507;; 11783 }; 11784 ; 11785 /* Create response (status_code has been set before) */; 11786 mg_response_header_start(conn, conn->status_code);; 11787 send_no_cache_header(conn);; 11788 send_additional_header(conn);; 11789 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11790 ; 11791 /* Send all headers - there is no body */; 11792 mg_response_header_send(conn);; 11793}; 11794 ; 11795 ; 11796static void; 11797delete_file(struct mg_connection *conn, const char *path); 11798{; 11799 struct de de;; 11800 memset(&de.file, 0, sizeof(de.file));; 1180",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:340784,Security,access,access,340784,"file should be created or overwritten. */; 11751 /* Currently CivetWeb does not nead read+write access. */; 11752 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11753 || file.access.fp == NULL) {; 11754 (void)mg_fclose(&file.access);; 11755 mg_send_http_error(conn,; 11756 500,; 11757 ""Error: Can not create file\nfopen(%s): %s"",; 11758 path,; 11759 strerror(ERRNO));; 11760 return;; 11761 }; 11762 ; 11763 fclose_on_exec(&file.access, conn);; 11764 range = mg_get_header(conn, ""Content-Range"");; 11765 r1 = r2 = 0;; 11766 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11767 conn->status_code = 206; /* Partial content */; 11768 fseeko(file.access.fp, r1, SEEK_SET);; 11769 }; 11770 ; 11771 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11772 /* forward_body_data failed.; 11773 * The error code has already been sent to the client,; 11774 * and conn->status_code is already set. */; 11775 (void)mg_fclose(&file.access);; 11776 return;; 11777 }; 11778 ; 11779 if (mg_fclose(&file.access) != 0) {; 11780 /* fclose failed. This might have different reasons, but a likely; 11781 * one is ""no space on disk"", http 507. */; 11782 conn->status_code = 507;; 11783 }; 11784 ; 11785 /* Create response (status_code has been set before) */; 11786 mg_response_header_start(conn, conn->status_code);; 11787 send_no_cache_header(conn);; 11788 send_additional_header(conn);; 11789 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11790 ; 11791 /* Send all headers - there is no body */; 11792 mg_response_header_send(conn);; 11793}; 11794 ; 11795 ; 11796static void; 11797delete_file(struct mg_connection *conn, const char *path); 11798{; 11799 struct de de;; 11800 memset(&de.file, 0, sizeof(de.file));; 11801 if (!mg_stat(conn, path, &de.file)) {; 11802 /* mg_stat returns 0 if the file does not exist */; 11803 mg_send_http_error(conn,; 11804 404,; 11805 ""Error: Cannot delete file\nFile %s not found"",; 11806 path);; 11807 return;; 11808 }; 11809 ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:340852,Security,access,access,340852,"rrently CivetWeb does not nead read+write access. */; 11752 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11753 || file.access.fp == NULL) {; 11754 (void)mg_fclose(&file.access);; 11755 mg_send_http_error(conn,; 11756 500,; 11757 ""Error: Can not create file\nfopen(%s): %s"",; 11758 path,; 11759 strerror(ERRNO));; 11760 return;; 11761 }; 11762 ; 11763 fclose_on_exec(&file.access, conn);; 11764 range = mg_get_header(conn, ""Content-Range"");; 11765 r1 = r2 = 0;; 11766 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11767 conn->status_code = 206; /* Partial content */; 11768 fseeko(file.access.fp, r1, SEEK_SET);; 11769 }; 11770 ; 11771 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11772 /* forward_body_data failed.; 11773 * The error code has already been sent to the client,; 11774 * and conn->status_code is already set. */; 11775 (void)mg_fclose(&file.access);; 11776 return;; 11777 }; 11778 ; 11779 if (mg_fclose(&file.access) != 0) {; 11780 /* fclose failed. This might have different reasons, but a likely; 11781 * one is ""no space on disk"", http 507. */; 11782 conn->status_code = 507;; 11783 }; 11784 ; 11785 /* Create response (status_code has been set before) */; 11786 mg_response_header_start(conn, conn->status_code);; 11787 send_no_cache_header(conn);; 11788 send_additional_header(conn);; 11789 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11790 ; 11791 /* Send all headers - there is no body */; 11792 mg_response_header_send(conn);; 11793}; 11794 ; 11795 ; 11796static void; 11797delete_file(struct mg_connection *conn, const char *path); 11798{; 11799 struct de de;; 11800 memset(&de.file, 0, sizeof(de.file));; 11801 if (!mg_stat(conn, path, &de.file)) {; 11802 /* mg_stat returns 0 if the file does not exist */; 11803 mg_send_http_error(conn,; 11804 404,; 11805 ""Error: Cannot delete file\nFile %s not found"",; 11806 path);; 11807 return;; 11808 }; 11809 ; 11810 if (de.file.is_directory) {; 11811 if (remove_",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:342320,Security,access,access,342320,"797delete_file(struct mg_connection *conn, const char *path); 11798{; 11799 struct de de;; 11800 memset(&de.file, 0, sizeof(de.file));; 11801 if (!mg_stat(conn, path, &de.file)) {; 11802 /* mg_stat returns 0 if the file does not exist */; 11803 mg_send_http_error(conn,; 11804 404,; 11805 ""Error: Cannot delete file\nFile %s not found"",; 11806 path);; 11807 return;; 11808 }; 11809 ; 11810 if (de.file.is_directory) {; 11811 if (remove_directory(conn, path)) {; 11812 /* Delete is successful: Return 204 without content. */; 11813 mg_send_http_error(conn, 204, ""%s"", """");; 11814 } else {; 11815 /* Delete is not successful: Return 500 (Server error). */; 11816 mg_send_http_error(conn, 500, ""Error: Could not delete %s"", path);; 11817 }; 11818 return;; 11819 }; 11820 ; 11821 /* This is an existing file (not a directory).; 11822 * Check if write permission is granted. */; 11823 if (access(path, W_OK) != 0) {; 11824 /* File is read only */; 11825 mg_send_http_error(; 11826 conn,; 11827 403,; 11828 ""Error: Delete not possible\nDeleting %s is not allowed"",; 11829 path);; 11830 return;; 11831 }; 11832 ; 11833 /* Try to delete it. */; 11834 if (mg_remove(conn, path) == 0) {; 11835 /* Delete was successful: Return 204 without content. */; 11836 mg_response_header_start(conn, 204);; 11837 send_no_cache_header(conn);; 11838 send_additional_header(conn);; 11839 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11840 mg_response_header_send(conn);; 11841 ; 11842 } else {; 11843 /* Delete not successful (file locked). */; 11844 mg_send_http_error(conn,; 11845 423,; 11846 ""Error: Cannot delete file\nremove(%s): %s"",; 11847 path,; 11848 strerror(ERRNO));; 11849 }; 11850}; 11851#endif /* !NO_FILES */; 11852 ; 11853 ; 11854#if !defined(NO_FILESYSTEMS); 11855static void; 11856send_ssi_file(struct mg_connection *, const char *, struct mg_file *, int);; 11857 ; 11858 ; 11859static void; 11860do_ssi_include(struct mg_connection *conn,; 11861 const char *ssi,; 11862 char *tag,; 11863 int i",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:345533,Security,access,access,345533,"1898 file_name[511] = 0;; 11899 (void)mg_snprintf(conn, &truncated, path, sizeof(path), ""%s"", ssi);; 11900 ; 11901 if (!truncated) {; 11902 if ((p = strrchr(path, '/')) != NULL) {; 11903 p[1] = '\0';; 11904 }; 11905 len = strlen(path);; 11906 (void)mg_snprintf(conn,; 11907 &truncated,; 11908 path + len,; 11909 sizeof(path) - len,; 11910 ""%s"",; 11911 file_name);; 11912 }; 11913 ; 11914 } else {; 11915 mg_cry_internal(conn, ""Bad SSI #include: [%s]"", tag);; 11916 return;; 11917 }; 11918 ; 11919 if (truncated) {; 11920 mg_cry_internal(conn, ""SSI #include path length overflow: [%s]"", tag);; 11921 return;; 11922 }; 11923 ; 11924 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {; 11925 mg_cry_internal(conn,; 11926 ""Cannot open SSI #include: [%s]: fopen(%s): %s"",; 11927 tag,; 11928 path,; 11929 strerror(ERRNO));; 11930 } else {; 11931 fclose_on_exec(&file.access, conn);; 11932 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], path); 11933 > 0) {; 11934 send_ssi_file(conn, path, &file, include_level + 1);; 11935 } else {; 11936 send_file_data(conn, &file, 0, INT64_MAX);; 11937 }; 11938 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 11939 }; 11940}; 11941 ; 11942 ; 11943#if !defined(NO_POPEN); 11944static void; 11945do_ssi_exec(struct mg_connection *conn, char *tag); 11946{; 11947 char cmd[1024] = """";; 11948 struct mg_file file = STRUCT_FILE_INITIALIZER;; 11949 ; 11950 if (sscanf(tag, "" \""%1023[^\""]\"""", cmd) != 1) {; 11951 mg_cry_internal(conn, ""Bad SSI #exec: [%s]"", tag);; 11952 } else {; 11953 cmd[1023] = 0;; 11954 if ((file.access.fp = popen(cmd, ""r"")) == NULL) {; 11955 mg_cry_internal(conn,; 11956 ""Cannot SSI #exec: [%s]: %s"",; 11957 cmd,; 11958 strerror(ERRNO));; 11959 } else {; 11960 send_file_data(conn, &file, 0, INT64_MAX);; 11961 pclose(file.access.fp);; 11962 }; 11963 }; 11964}; 11965#endif /* !NO_POPEN */; 11966 ; 11967 ; 11968static int; 11969mg_fgetc(struct mg_file *filep); 11970{; 11971 if (filep == NULL) {; 11972 return",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:345802,Security,access,access,345802,"e);; 11912 }; 11913 ; 11914 } else {; 11915 mg_cry_internal(conn, ""Bad SSI #include: [%s]"", tag);; 11916 return;; 11917 }; 11918 ; 11919 if (truncated) {; 11920 mg_cry_internal(conn, ""SSI #include path length overflow: [%s]"", tag);; 11921 return;; 11922 }; 11923 ; 11924 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {; 11925 mg_cry_internal(conn,; 11926 ""Cannot open SSI #include: [%s]: fopen(%s): %s"",; 11927 tag,; 11928 path,; 11929 strerror(ERRNO));; 11930 } else {; 11931 fclose_on_exec(&file.access, conn);; 11932 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], path); 11933 > 0) {; 11934 send_ssi_file(conn, path, &file, include_level + 1);; 11935 } else {; 11936 send_file_data(conn, &file, 0, INT64_MAX);; 11937 }; 11938 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 11939 }; 11940}; 11941 ; 11942 ; 11943#if !defined(NO_POPEN); 11944static void; 11945do_ssi_exec(struct mg_connection *conn, char *tag); 11946{; 11947 char cmd[1024] = """";; 11948 struct mg_file file = STRUCT_FILE_INITIALIZER;; 11949 ; 11950 if (sscanf(tag, "" \""%1023[^\""]\"""", cmd) != 1) {; 11951 mg_cry_internal(conn, ""Bad SSI #exec: [%s]"", tag);; 11952 } else {; 11953 cmd[1023] = 0;; 11954 if ((file.access.fp = popen(cmd, ""r"")) == NULL) {; 11955 mg_cry_internal(conn,; 11956 ""Cannot SSI #exec: [%s]: %s"",; 11957 cmd,; 11958 strerror(ERRNO));; 11959 } else {; 11960 send_file_data(conn, &file, 0, INT64_MAX);; 11961 pclose(file.access.fp);; 11962 }; 11963 }; 11964}; 11965#endif /* !NO_POPEN */; 11966 ; 11967 ; 11968static int; 11969mg_fgetc(struct mg_file *filep); 11970{; 11971 if (filep == NULL) {; 11972 return EOF;; 11973 }; 11974 ; 11975 if (filep->access.fp != NULL) {; 11976 return fgetc(filep->access.fp);; 11977 } else {; 11978 return EOF;; 11979 }; 11980}; 11981 ; 11982 ; 11983static void; 11984send_ssi_file(struct mg_connection *conn,; 11985 const char *path,; 11986 struct mg_file *filep,; 11987 int include_level); 11988{; 11989 char buf[MG_BUF_LEN];; 11990 ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:346253,Security,access,access,346253,");; 11921 return;; 11922 }; 11923 ; 11924 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {; 11925 mg_cry_internal(conn,; 11926 ""Cannot open SSI #include: [%s]: fopen(%s): %s"",; 11927 tag,; 11928 path,; 11929 strerror(ERRNO));; 11930 } else {; 11931 fclose_on_exec(&file.access, conn);; 11932 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], path); 11933 > 0) {; 11934 send_ssi_file(conn, path, &file, include_level + 1);; 11935 } else {; 11936 send_file_data(conn, &file, 0, INT64_MAX);; 11937 }; 11938 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 11939 }; 11940}; 11941 ; 11942 ; 11943#if !defined(NO_POPEN); 11944static void; 11945do_ssi_exec(struct mg_connection *conn, char *tag); 11946{; 11947 char cmd[1024] = """";; 11948 struct mg_file file = STRUCT_FILE_INITIALIZER;; 11949 ; 11950 if (sscanf(tag, "" \""%1023[^\""]\"""", cmd) != 1) {; 11951 mg_cry_internal(conn, ""Bad SSI #exec: [%s]"", tag);; 11952 } else {; 11953 cmd[1023] = 0;; 11954 if ((file.access.fp = popen(cmd, ""r"")) == NULL) {; 11955 mg_cry_internal(conn,; 11956 ""Cannot SSI #exec: [%s]: %s"",; 11957 cmd,; 11958 strerror(ERRNO));; 11959 } else {; 11960 send_file_data(conn, &file, 0, INT64_MAX);; 11961 pclose(file.access.fp);; 11962 }; 11963 }; 11964}; 11965#endif /* !NO_POPEN */; 11966 ; 11967 ; 11968static int; 11969mg_fgetc(struct mg_file *filep); 11970{; 11971 if (filep == NULL) {; 11972 return EOF;; 11973 }; 11974 ; 11975 if (filep->access.fp != NULL) {; 11976 return fgetc(filep->access.fp);; 11977 } else {; 11978 return EOF;; 11979 }; 11980}; 11981 ; 11982 ; 11983static void; 11984send_ssi_file(struct mg_connection *conn,; 11985 const char *path,; 11986 struct mg_file *filep,; 11987 int include_level); 11988{; 11989 char buf[MG_BUF_LEN];; 11990 int ch, len, in_tag, in_ssi_tag;; 11991 ; 11992 if (include_level > 10) {; 11993 mg_cry_internal(conn, ""SSI #include level is too deep (%s)"", path);; 11994 return;; 11995 }; 11996 ; 11997 in_tag = in_ssi_tag = len = 0;; 11998 ; 1",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:346481,Security,access,access,346481,"O));; 11930 } else {; 11931 fclose_on_exec(&file.access, conn);; 11932 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], path); 11933 > 0) {; 11934 send_ssi_file(conn, path, &file, include_level + 1);; 11935 } else {; 11936 send_file_data(conn, &file, 0, INT64_MAX);; 11937 }; 11938 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 11939 }; 11940}; 11941 ; 11942 ; 11943#if !defined(NO_POPEN); 11944static void; 11945do_ssi_exec(struct mg_connection *conn, char *tag); 11946{; 11947 char cmd[1024] = """";; 11948 struct mg_file file = STRUCT_FILE_INITIALIZER;; 11949 ; 11950 if (sscanf(tag, "" \""%1023[^\""]\"""", cmd) != 1) {; 11951 mg_cry_internal(conn, ""Bad SSI #exec: [%s]"", tag);; 11952 } else {; 11953 cmd[1023] = 0;; 11954 if ((file.access.fp = popen(cmd, ""r"")) == NULL) {; 11955 mg_cry_internal(conn,; 11956 ""Cannot SSI #exec: [%s]: %s"",; 11957 cmd,; 11958 strerror(ERRNO));; 11959 } else {; 11960 send_file_data(conn, &file, 0, INT64_MAX);; 11961 pclose(file.access.fp);; 11962 }; 11963 }; 11964}; 11965#endif /* !NO_POPEN */; 11966 ; 11967 ; 11968static int; 11969mg_fgetc(struct mg_file *filep); 11970{; 11971 if (filep == NULL) {; 11972 return EOF;; 11973 }; 11974 ; 11975 if (filep->access.fp != NULL) {; 11976 return fgetc(filep->access.fp);; 11977 } else {; 11978 return EOF;; 11979 }; 11980}; 11981 ; 11982 ; 11983static void; 11984send_ssi_file(struct mg_connection *conn,; 11985 const char *path,; 11986 struct mg_file *filep,; 11987 int include_level); 11988{; 11989 char buf[MG_BUF_LEN];; 11990 int ch, len, in_tag, in_ssi_tag;; 11991 ; 11992 if (include_level > 10) {; 11993 mg_cry_internal(conn, ""SSI #include level is too deep (%s)"", path);; 11994 return;; 11995 }; 11996 ; 11997 in_tag = in_ssi_tag = len = 0;; 11998 ; 11999 /* Read file, byte by byte, and look for SSI include tags */; 12000 while ((ch = mg_fgetc(filep)) != EOF) {; 12001 ; 12002 if (in_tag) {; 12003 /* We are in a tag, either SSI tag or html tag */; 12004 ; 12005 if (ch == '>')",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:346709,Security,access,access,346709,"SI_EXTENSIONS], path); 11933 > 0) {; 11934 send_ssi_file(conn, path, &file, include_level + 1);; 11935 } else {; 11936 send_file_data(conn, &file, 0, INT64_MAX);; 11937 }; 11938 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 11939 }; 11940}; 11941 ; 11942 ; 11943#if !defined(NO_POPEN); 11944static void; 11945do_ssi_exec(struct mg_connection *conn, char *tag); 11946{; 11947 char cmd[1024] = """";; 11948 struct mg_file file = STRUCT_FILE_INITIALIZER;; 11949 ; 11950 if (sscanf(tag, "" \""%1023[^\""]\"""", cmd) != 1) {; 11951 mg_cry_internal(conn, ""Bad SSI #exec: [%s]"", tag);; 11952 } else {; 11953 cmd[1023] = 0;; 11954 if ((file.access.fp = popen(cmd, ""r"")) == NULL) {; 11955 mg_cry_internal(conn,; 11956 ""Cannot SSI #exec: [%s]: %s"",; 11957 cmd,; 11958 strerror(ERRNO));; 11959 } else {; 11960 send_file_data(conn, &file, 0, INT64_MAX);; 11961 pclose(file.access.fp);; 11962 }; 11963 }; 11964}; 11965#endif /* !NO_POPEN */; 11966 ; 11967 ; 11968static int; 11969mg_fgetc(struct mg_file *filep); 11970{; 11971 if (filep == NULL) {; 11972 return EOF;; 11973 }; 11974 ; 11975 if (filep->access.fp != NULL) {; 11976 return fgetc(filep->access.fp);; 11977 } else {; 11978 return EOF;; 11979 }; 11980}; 11981 ; 11982 ; 11983static void; 11984send_ssi_file(struct mg_connection *conn,; 11985 const char *path,; 11986 struct mg_file *filep,; 11987 int include_level); 11988{; 11989 char buf[MG_BUF_LEN];; 11990 int ch, len, in_tag, in_ssi_tag;; 11991 ; 11992 if (include_level > 10) {; 11993 mg_cry_internal(conn, ""SSI #include level is too deep (%s)"", path);; 11994 return;; 11995 }; 11996 ; 11997 in_tag = in_ssi_tag = len = 0;; 11998 ; 11999 /* Read file, byte by byte, and look for SSI include tags */; 12000 while ((ch = mg_fgetc(filep)) != EOF) {; 12001 ; 12002 if (in_tag) {; 12003 /* We are in a tag, either SSI tag or html tag */; 12004 ; 12005 if (ch == '>') {; 12006 /* Tag is closing */; 12007 buf[len++] = '>';; 12008 ; 12009 if (in_ssi_tag) {; 12010 /* Handle SSI tag */;",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:346757,Security,access,access,346757,", &file, 0, INT64_MAX);; 11937 }; 11938 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 11939 }; 11940}; 11941 ; 11942 ; 11943#if !defined(NO_POPEN); 11944static void; 11945do_ssi_exec(struct mg_connection *conn, char *tag); 11946{; 11947 char cmd[1024] = """";; 11948 struct mg_file file = STRUCT_FILE_INITIALIZER;; 11949 ; 11950 if (sscanf(tag, "" \""%1023[^\""]\"""", cmd) != 1) {; 11951 mg_cry_internal(conn, ""Bad SSI #exec: [%s]"", tag);; 11952 } else {; 11953 cmd[1023] = 0;; 11954 if ((file.access.fp = popen(cmd, ""r"")) == NULL) {; 11955 mg_cry_internal(conn,; 11956 ""Cannot SSI #exec: [%s]: %s"",; 11957 cmd,; 11958 strerror(ERRNO));; 11959 } else {; 11960 send_file_data(conn, &file, 0, INT64_MAX);; 11961 pclose(file.access.fp);; 11962 }; 11963 }; 11964}; 11965#endif /* !NO_POPEN */; 11966 ; 11967 ; 11968static int; 11969mg_fgetc(struct mg_file *filep); 11970{; 11971 if (filep == NULL) {; 11972 return EOF;; 11973 }; 11974 ; 11975 if (filep->access.fp != NULL) {; 11976 return fgetc(filep->access.fp);; 11977 } else {; 11978 return EOF;; 11979 }; 11980}; 11981 ; 11982 ; 11983static void; 11984send_ssi_file(struct mg_connection *conn,; 11985 const char *path,; 11986 struct mg_file *filep,; 11987 int include_level); 11988{; 11989 char buf[MG_BUF_LEN];; 11990 int ch, len, in_tag, in_ssi_tag;; 11991 ; 11992 if (include_level > 10) {; 11993 mg_cry_internal(conn, ""SSI #include level is too deep (%s)"", path);; 11994 return;; 11995 }; 11996 ; 11997 in_tag = in_ssi_tag = len = 0;; 11998 ; 11999 /* Read file, byte by byte, and look for SSI include tags */; 12000 while ((ch = mg_fgetc(filep)) != EOF) {; 12001 ; 12002 if (in_tag) {; 12003 /* We are in a tag, either SSI tag or html tag */; 12004 ; 12005 if (ch == '>') {; 12006 /* Tag is closing */; 12007 buf[len++] = '>';; 12008 ; 12009 if (in_ssi_tag) {; 12010 /* Handle SSI tag */; 12011 buf[len] = 0;; 12012 ; 12013 if ((len > 12) && !memcmp(buf + 5, ""include"", 7)) {; 12014 do_ssi_include(conn, path, buf + 12, includ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:351077,Security,access,access,351077,"als"";; 12116 cors4 = cors_cred_cfg;; 12117 } else {; 12118 cors3 = cors4 = """";; 12119 }; 12120 ; 12121 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {; 12122 /* File exists (precondition for calling this function),; 12123 * but can not be opened by the server. */; 12124 mg_send_http_error(conn,; 12125 500,; 12126 ""Error: Cannot read file\nfopen(%s): %s"",; 12127 path,; 12128 strerror(ERRNO));; 12129 } else {; 12130 /* Set ""must_close"" for HTTP/1.x, since we do not know the; 12131 * content length */; 12132 conn->must_close = 1;; 12133 gmt_time_string(date, sizeof(date), &curtime);; 12134 fclose_on_exec(&filep->access, conn);; 12135 ; 12136 /* 200 OK response */; 12137 mg_response_header_start(conn, 200);; 12138 send_no_cache_header(conn);; 12139 send_additional_header(conn);; 12140 mg_response_header_add(conn, ""Content-Type"", ""text/html"", -1);; 12141 if (cors1[0]) {; 12142 mg_response_header_add(conn, cors1, cors2, -1);; 12143 }; 12144 if (cors3[0]) {; 12145 mg_response_header_add(conn, cors3, cors4, -1);; 12146 }; 12147 mg_response_header_send(conn);; 12148 ; 12149 /* Header sent, now send body */; 12150 send_ssi_file(conn, path, filep, 0);; 12151 (void)mg_fclose(&filep->access); /* Ignore errors for readonly files */; 12152 }; 12153}; 12154#endif /* NO_FILESYSTEMS */; 12155 ; 12156 ; 12157#if !defined(NO_FILES); 12158static void; 12159send_options(struct mg_connection *conn); 12160{; 12161 if (!conn) {; 12162 return;; 12163 }; 12164 ; 12165 /* We do not set a ""Cache-Control"" header here, but leave the default.; 12166 * Since browsers do not send an OPTIONS request, we can not test the; 12167 * effect anyway. */; 12168 ; 12169 mg_response_header_start(conn, 200);; 12170 mg_response_header_add(conn, ""Content-Type"", ""text/html"", -1);; 12171 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 12172 /* Use the same as before */; 12173 mg_response_header_add(; 12174 conn,; 12175 ""Allow"",; 12176 ""GET, POST, HEAD, CONNECT, PUT, DELETE, OPTIONS, PROPFIND, MKCOL"",; 121",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:351650,Security,access,access,351650,"als"";; 12116 cors4 = cors_cred_cfg;; 12117 } else {; 12118 cors3 = cors4 = """";; 12119 }; 12120 ; 12121 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {; 12122 /* File exists (precondition for calling this function),; 12123 * but can not be opened by the server. */; 12124 mg_send_http_error(conn,; 12125 500,; 12126 ""Error: Cannot read file\nfopen(%s): %s"",; 12127 path,; 12128 strerror(ERRNO));; 12129 } else {; 12130 /* Set ""must_close"" for HTTP/1.x, since we do not know the; 12131 * content length */; 12132 conn->must_close = 1;; 12133 gmt_time_string(date, sizeof(date), &curtime);; 12134 fclose_on_exec(&filep->access, conn);; 12135 ; 12136 /* 200 OK response */; 12137 mg_response_header_start(conn, 200);; 12138 send_no_cache_header(conn);; 12139 send_additional_header(conn);; 12140 mg_response_header_add(conn, ""Content-Type"", ""text/html"", -1);; 12141 if (cors1[0]) {; 12142 mg_response_header_add(conn, cors1, cors2, -1);; 12143 }; 12144 if (cors3[0]) {; 12145 mg_response_header_add(conn, cors3, cors4, -1);; 12146 }; 12147 mg_response_header_send(conn);; 12148 ; 12149 /* Header sent, now send body */; 12150 send_ssi_file(conn, path, filep, 0);; 12151 (void)mg_fclose(&filep->access); /* Ignore errors for readonly files */; 12152 }; 12153}; 12154#endif /* NO_FILESYSTEMS */; 12155 ; 12156 ; 12157#if !defined(NO_FILES); 12158static void; 12159send_options(struct mg_connection *conn); 12160{; 12161 if (!conn) {; 12162 return;; 12163 }; 12164 ; 12165 /* We do not set a ""Cache-Control"" header here, but leave the default.; 12166 * Since browsers do not send an OPTIONS request, we can not test the; 12167 * effect anyway. */; 12168 ; 12169 mg_response_header_start(conn, 200);; 12170 mg_response_header_add(conn, ""Content-Type"", ""text/html"", -1);; 12171 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 12172 /* Use the same as before */; 12173 mg_response_header_add(; 12174 conn,; 12175 ""Allow"",; 12176 ""GET, POST, HEAD, CONNECT, PUT, DELETE, OPTIONS, PROPFIND, MKCOL"",; 121",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:390285,Security,validat,validation,390285,"3312 if (sscanf(vec->ptr, ""[%49[^]]]%n"", ad, &n) != 1) {; 13313 n = 0;; 13314 }; 13315 }; 13316 ; 13317 if ((n <= 0) && no_strict) {; 13318 /* no square brackets? */; 13319 p = strchr(vec->ptr, '/');; 13320 if (p && (p < (vec->ptr + vec->len))) {; 13321 if (((size_t)(p - vec->ptr) < sizeof(ad)); 13322 && (sscanf(p, ""/%u%n"", &slash, &n) == 1)) {; 13323 n += (int)(p - vec->ptr);; 13324 mg_strlcpy(ad, vec->ptr, (size_t)(p - vec->ptr) + 1);; 13325 } else {; 13326 n = 0;; 13327 }; 13328 } else if (vec->len < sizeof(ad)) {; 13329 n = (int)vec->len;; 13330 slash = 128;; 13331 mg_strlcpy(ad, vec->ptr, vec->len + 1);; 13332 }; 13333 }; 13334 ; 13335 if ((n > 0) && ((size_t)n == vec->len) && (slash < 129)) {; 13336 p = ad;; 13337 c = 0;; 13338 /* zone indexes are unsupported, at least two colons are needed */; 13339 while (isxdigit((unsigned char)*p) || (*p == '.') || (*p == ':')) {; 13340 if (*(p++) == ':') {; 13341 c++;; 13342 }; 13343 }; 13344 if ((*p == '\0') && (c >= 2)) {; 13345 struct sockaddr_in6 sin6;; 13346 unsigned int i;; 13347 ; 13348 /* for strict validation, an actual IPv6 argument is needed */; 13349 if (sa->sa.sa_family != AF_INET6) {; 13350 return 0;; 13351 }; 13352 if (mg_inet_pton(AF_INET6, ad, &sin6, sizeof(sin6), 0)) {; 13353 /* IPv6 format */; 13354 for (i = 0; i < 16; i++) {; 13355 uint8_t ip = sa->sin6.sin6_addr.s6_addr[i];; 13356 uint8_t net = sin6.sin6_addr.s6_addr[i];; 13357 uint8_t mask = 0;; 13358 ; 13359 if (8 * i + 8 < slash) {; 13360 mask = 0xFFu;; 13361 } else if (8 * i < slash) {; 13362 mask = (uint8_t)(0xFFu << (8 * i + 8 - slash));; 13363 }; 13364 if ((ip & mask) != net) {; 13365 return 0;; 13366 }; 13367 }; 13368 return 1;; 13369 }; 13370 }; 13371 }; 13372 }; 13373#else; 13374 (void)no_strict;; 13375#endif; 13376 ; 13377 /* malformed */; 13378 return -1;; 13379}; 13380 ; 13381 ; 13382static int; 13383set_throttle(const char *spec, const union usa *rsa, const char *uri); 13384{; 13385 int throttle = 0;; 13386 struct vec vec, val;; 13387 ch",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:409917,Security,validat,validated,409917," assume ""OK"" */; 13976 return 1;; 13977}; 13978 ; 13979 ; 13980static void; 13981experimental_websocket_client_close_wrapper(const struct mg_connection *conn,; 13982 void *cbdata); 13983{; 13984 struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;; 13985 if (pcallbacks->connection_close) {; 13986 pcallbacks->connection_close(conn);; 13987 }; 13988}; 13989#endif; 13990 ; 13991 ; 13992/* Decrement recount of handler. conn must not be NULL, handler_info may be NULL; 13993 */; 13994static void; 13995release_handler_ref(struct mg_connection *conn,; 13996 struct mg_handler_info *handler_info); 13997{; 13998 if (handler_info != NULL) {; 13999 /* Use context lock for ref counter */; 14000 mg_lock_context(conn->phys_ctx);; 14001 handler_info->refcount--;; 14002 mg_unlock_context(conn->phys_ctx);; 14003 }; 14004}; 14005 ; 14006 ; 14007/* This is the heart of the Civetweb's logic.; 14008 * This function is called when the request is read, parsed and validated,; 14009 * and Civetweb must decide what action to take: serve a file, or; 14010 * a directory, or call embedded function, etcetera. */; 14011static void; 14012handle_request(struct mg_connection *conn); 14013{; 14014 struct mg_request_info *ri = &conn->request_info;; 14015 char path[UTF8_PATH_MAX];; 14016 int uri_len, ssl_index;; 14017 int is_found = 0, is_script_resource = 0, is_websocket_request = 0,; 14018 is_put_or_delete_request = 0, is_callback_resource = 0,; 14019 is_template_text_file = 0;; 14020 int i;; 14021 struct mg_file file = STRUCT_FILE_INITIALIZER;; 14022 mg_request_handler callback_handler = NULL;; 14023 struct mg_handler_info *handler_info = NULL;; 14024 struct mg_websocket_subprotocols *subprotocols;; 14025 mg_websocket_connect_handler ws_connect_handler = NULL;; 14026 mg_websocket_ready_handler ws_ready_handler = NULL;; 14027 mg_websocket_data_handler ws_data_handler = NULL;; 14028 mg_websocket_close_handler ws_close_handler = NULL;; 14029 void *callback_data = NULL;; 14030 mg_authorization",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:413961,Security,authoriz,authorization,413961,"the; 14086 * pointer to ri->local_ur and ri->local_uri_raw are now different.; 14087 * ri->local_uri_raw still points to memory allocated in; 14088 * worker_thread_run(). ri->local_uri is private to the request so we; 14089 * don't have to use preallocated memory here. */; 14090 tmp = mg_strdup(ri->local_uri_raw);; 14091 if (!tmp) {; 14092 /* Out of memory. We cannot do anything reasonable here. */; 14093 return;; 14094 }; 14095 remove_dot_segments(tmp);; 14096 ri->local_uri = tmp;; 14097 ; 14098 /* step 1. completed, the url is known now */; 14099 DEBUG_TRACE(""URL: %s"", ri->local_uri);; 14100 ; 14101 /* 2. if this ip has limited speed, set it for this connection */; 14102 conn->throttle = set_throttle(conn->dom_ctx->config[THROTTLE],; 14103 &conn->client.rsa,; 14104 ri->local_uri);; 14105 ; 14106 /* 3. call a ""handle everything"" callback, if registered */; 14107 if (conn->phys_ctx->callbacks.begin_request != NULL) {; 14108 /* Note that since V1.7 the ""begin_request"" function is called; 14109 * before an authorization check. If an authorization check is; 14110 * required, use a request_handler instead. */; 14111 i = conn->phys_ctx->callbacks.begin_request(conn);; 14112 if (i > 0) {; 14113 /* callback already processed the request. Store the; 14114 return value as a status code for the access log. */; 14115 conn->status_code = i;; 14116 if (!conn->must_close) {; 14117 discard_unread_request_data(conn);; 14118 }; 14119 return;; 14120 } else if (i == 0) {; 14121 /* civetweb should process the request */; 14122 } else {; 14123 /* unspecified - may change with the next version */; 14124 return;; 14125 }; 14126 }; 14127 ; 14128 /* request not yet handled by a handler or redirect, so the request; 14129 * is processed here */; 14130 ; 14131 /* 4. Check for CORS preflight requests and handle them (if configured).; 14132 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS; 14133 */; 14134 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14135 /* Send a respo",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:413988,Security,authoriz,authorization,413988,"14087 * ri->local_uri_raw still points to memory allocated in; 14088 * worker_thread_run(). ri->local_uri is private to the request so we; 14089 * don't have to use preallocated memory here. */; 14090 tmp = mg_strdup(ri->local_uri_raw);; 14091 if (!tmp) {; 14092 /* Out of memory. We cannot do anything reasonable here. */; 14093 return;; 14094 }; 14095 remove_dot_segments(tmp);; 14096 ri->local_uri = tmp;; 14097 ; 14098 /* step 1. completed, the url is known now */; 14099 DEBUG_TRACE(""URL: %s"", ri->local_uri);; 14100 ; 14101 /* 2. if this ip has limited speed, set it for this connection */; 14102 conn->throttle = set_throttle(conn->dom_ctx->config[THROTTLE],; 14103 &conn->client.rsa,; 14104 ri->local_uri);; 14105 ; 14106 /* 3. call a ""handle everything"" callback, if registered */; 14107 if (conn->phys_ctx->callbacks.begin_request != NULL) {; 14108 /* Note that since V1.7 the ""begin_request"" function is called; 14109 * before an authorization check. If an authorization check is; 14110 * required, use a request_handler instead. */; 14111 i = conn->phys_ctx->callbacks.begin_request(conn);; 14112 if (i > 0) {; 14113 /* callback already processed the request. Store the; 14114 return value as a status code for the access log. */; 14115 conn->status_code = i;; 14116 if (!conn->must_close) {; 14117 discard_unread_request_data(conn);; 14118 }; 14119 return;; 14120 } else if (i == 0) {; 14121 /* civetweb should process the request */; 14122 } else {; 14123 /* unspecified - may change with the next version */; 14124 return;; 14125 }; 14126 }; 14127 ; 14128 /* request not yet handled by a handler or redirect, so the request; 14129 * is processed here */; 14130 ; 14131 /* 4. Check for CORS preflight requests and handle them (if configured).; 14132 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS; 14133 */; 14134 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14135 /* Send a response to CORS preflights only if; 14136 * access_control_allow_methods is not NULL",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:414247,Security,access,access,414247," = mg_strdup(ri->local_uri_raw);; 14091 if (!tmp) {; 14092 /* Out of memory. We cannot do anything reasonable here. */; 14093 return;; 14094 }; 14095 remove_dot_segments(tmp);; 14096 ri->local_uri = tmp;; 14097 ; 14098 /* step 1. completed, the url is known now */; 14099 DEBUG_TRACE(""URL: %s"", ri->local_uri);; 14100 ; 14101 /* 2. if this ip has limited speed, set it for this connection */; 14102 conn->throttle = set_throttle(conn->dom_ctx->config[THROTTLE],; 14103 &conn->client.rsa,; 14104 ri->local_uri);; 14105 ; 14106 /* 3. call a ""handle everything"" callback, if registered */; 14107 if (conn->phys_ctx->callbacks.begin_request != NULL) {; 14108 /* Note that since V1.7 the ""begin_request"" function is called; 14109 * before an authorization check. If an authorization check is; 14110 * required, use a request_handler instead. */; 14111 i = conn->phys_ctx->callbacks.begin_request(conn);; 14112 if (i > 0) {; 14113 /* callback already processed the request. Store the; 14114 return value as a status code for the access log. */; 14115 conn->status_code = i;; 14116 if (!conn->must_close) {; 14117 discard_unread_request_data(conn);; 14118 }; 14119 return;; 14120 } else if (i == 0) {; 14121 /* civetweb should process the request */; 14122 } else {; 14123 /* unspecified - may change with the next version */; 14124 return;; 14125 }; 14126 }; 14127 ; 14128 /* request not yet handled by a handler or redirect, so the request; 14129 * is processed here */; 14130 ; 14131 /* 4. Check for CORS preflight requests and handle them (if configured).; 14132 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS; 14133 */; 14134 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14135 /* Send a response to CORS preflights only if; 14136 * access_control_allow_methods is not NULL and not an empty string.; 14137 * In this case, scripts can still handle CORS. */; 14138 const char *cors_meth_cfg =; 14139 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_METHODS];; 14140 const char *cors_or",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:419316,Security,authoriz,authorization,419316,"ols,; 14227 &ws_connect_handler,; 14228 &ws_ready_handler,; 14229 &ws_data_handler,; 14230 &ws_close_handler,; 14231 NULL,; 14232 &callback_data,; 14233 &handler_info)) {; 14234 /* 5.2.1. A callback will handle this request. All requests; 14235 * handled by a callback have to be considered as requests; 14236 * to a script resource. */; 14237 is_callback_resource = 1;; 14238 is_script_resource = 1;; 14239 is_put_or_delete_request = is_put_or_delete_method(conn);; 14240 } else {; 14241 no_callback_resource:; 14242 ; 14243 /* 5.2.2. No callback is responsible for this request. The URI; 14244 * addresses a file based resource (static content or Lua/cgi; 14245 * scripts in the file system). */; 14246 is_callback_resource = 0;; 14247 interpret_uri(conn,; 14248 path,; 14249 sizeof(path),; 14250 &file.stat,; 14251 &is_found,; 14252 &is_script_resource,; 14253 &is_websocket_request,; 14254 &is_put_or_delete_request,; 14255 &is_template_text_file);; 14256 }; 14257 ; 14258 /* 6. authorization check */; 14259 /* 6.1. a custom authorization handler is installed */; 14260 if (get_request_handler(conn,; 14261 AUTH_HANDLER,; 14262 NULL,; 14263 NULL,; 14264 NULL,; 14265 NULL,; 14266 NULL,; 14267 NULL,; 14268 &auth_handler,; 14269 &auth_callback_data,; 14270 NULL)) {; 14271 if (!auth_handler(conn, auth_callback_data)) {; 14272 ; 14273 /* Callback handler will not be used anymore. Release it */; 14274 release_handler_ref(conn, handler_info);; 14275 ; 14276 return;; 14277 }; 14278 } else if (is_put_or_delete_request && !is_script_resource; 14279 && !is_callback_resource) {; 14280 HTTP1_only;; 14281 /* 6.2. this request is a PUT/DELETE to a real file */; 14282 /* 6.2.1. thus, the server must have real files */; 14283#if defined(NO_FILES); 14284 if (1) {; 14285#else; 14286 if (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {; 14287#endif; 14288 /* This code path will not be called for request handlers */; 14289 DEBUG_ASSERT(handler_info == NULL);; 14290 ; 14291 /* This server does not hav",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:419363,Security,authoriz,authorization,419363,"l handle this request. All requests; 14235 * handled by a callback have to be considered as requests; 14236 * to a script resource. */; 14237 is_callback_resource = 1;; 14238 is_script_resource = 1;; 14239 is_put_or_delete_request = is_put_or_delete_method(conn);; 14240 } else {; 14241 no_callback_resource:; 14242 ; 14243 /* 5.2.2. No callback is responsible for this request. The URI; 14244 * addresses a file based resource (static content or Lua/cgi; 14245 * scripts in the file system). */; 14246 is_callback_resource = 0;; 14247 interpret_uri(conn,; 14248 path,; 14249 sizeof(path),; 14250 &file.stat,; 14251 &is_found,; 14252 &is_script_resource,; 14253 &is_websocket_request,; 14254 &is_put_or_delete_request,; 14255 &is_template_text_file);; 14256 }; 14257 ; 14258 /* 6. authorization check */; 14259 /* 6.1. a custom authorization handler is installed */; 14260 if (get_request_handler(conn,; 14261 AUTH_HANDLER,; 14262 NULL,; 14263 NULL,; 14264 NULL,; 14265 NULL,; 14266 NULL,; 14267 NULL,; 14268 &auth_handler,; 14269 &auth_callback_data,; 14270 NULL)) {; 14271 if (!auth_handler(conn, auth_callback_data)) {; 14272 ; 14273 /* Callback handler will not be used anymore. Release it */; 14274 release_handler_ref(conn, handler_info);; 14275 ; 14276 return;; 14277 }; 14278 } else if (is_put_or_delete_request && !is_script_resource; 14279 && !is_callback_resource) {; 14280 HTTP1_only;; 14281 /* 6.2. this request is a PUT/DELETE to a real file */; 14282 /* 6.2.1. thus, the server must have real files */; 14283#if defined(NO_FILES); 14284 if (1) {; 14285#else; 14286 if (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {; 14287#endif; 14288 /* This code path will not be called for request handlers */; 14289 DEBUG_ASSERT(handler_info == NULL);; 14290 ; 14291 /* This server does not have any real files, thus the; 14292 * PUT/DELETE methods are not valid. */; 14293 mg_send_http_error(conn,; 14294 405,; 14295 ""%s method not allowed"",; 14296 conn->request_info.request_method);; 14297 ret",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:420616,Security,authoriz,authorization,420616,"uth_callback_data)) {; 14272 ; 14273 /* Callback handler will not be used anymore. Release it */; 14274 release_handler_ref(conn, handler_info);; 14275 ; 14276 return;; 14277 }; 14278 } else if (is_put_or_delete_request && !is_script_resource; 14279 && !is_callback_resource) {; 14280 HTTP1_only;; 14281 /* 6.2. this request is a PUT/DELETE to a real file */; 14282 /* 6.2.1. thus, the server must have real files */; 14283#if defined(NO_FILES); 14284 if (1) {; 14285#else; 14286 if (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {; 14287#endif; 14288 /* This code path will not be called for request handlers */; 14289 DEBUG_ASSERT(handler_info == NULL);; 14290 ; 14291 /* This server does not have any real files, thus the; 14292 * PUT/DELETE methods are not valid. */; 14293 mg_send_http_error(conn,; 14294 405,; 14295 ""%s method not allowed"",; 14296 conn->request_info.request_method);; 14297 return;; 14298 }; 14299 ; 14300#if !defined(NO_FILES); 14301 /* 6.2.2. Check if put authorization for static files is; 14302 * available.; 14303 */; 14304 if (!is_authorized_for_put(conn)) {; 14305 send_authorization_request(conn, NULL);; 14306 return;; 14307 }; 14308#endif; 14309 ; 14310 } else {; 14311 /* 6.3. This is either a OPTIONS, GET, HEAD or POST request,; 14312 * or it is a PUT or DELETE request to a resource that does not; 14313 * correspond to a file. Check authorization. */; 14314 if (!check_authorization(conn, path)) {; 14315 send_authorization_request(conn, NULL);; 14316 ; 14317 /* Callback handler will not be used anymore. Release it */; 14318 release_handler_ref(conn, handler_info);; 14319 ; 14320 return;; 14321 }; 14322 }; 14323 ; 14324 /* request is authorized or does not need authorization */; 14325 ; 14326 /* 7. check if there are request handlers for this uri */; 14327 if (is_callback_resource) {; 14328 HTTP1_only;; 14329 if (!is_websocket_request) {; 14330 i = callback_handler(conn, callback_data);; 14331 ; 14332 /* Callback handler will not be used anymore. Releas",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:421006,Security,authoriz,authorization,421006,". thus, the server must have real files */; 14283#if defined(NO_FILES); 14284 if (1) {; 14285#else; 14286 if (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {; 14287#endif; 14288 /* This code path will not be called for request handlers */; 14289 DEBUG_ASSERT(handler_info == NULL);; 14290 ; 14291 /* This server does not have any real files, thus the; 14292 * PUT/DELETE methods are not valid. */; 14293 mg_send_http_error(conn,; 14294 405,; 14295 ""%s method not allowed"",; 14296 conn->request_info.request_method);; 14297 return;; 14298 }; 14299 ; 14300#if !defined(NO_FILES); 14301 /* 6.2.2. Check if put authorization for static files is; 14302 * available.; 14303 */; 14304 if (!is_authorized_for_put(conn)) {; 14305 send_authorization_request(conn, NULL);; 14306 return;; 14307 }; 14308#endif; 14309 ; 14310 } else {; 14311 /* 6.3. This is either a OPTIONS, GET, HEAD or POST request,; 14312 * or it is a PUT or DELETE request to a resource that does not; 14313 * correspond to a file. Check authorization. */; 14314 if (!check_authorization(conn, path)) {; 14315 send_authorization_request(conn, NULL);; 14316 ; 14317 /* Callback handler will not be used anymore. Release it */; 14318 release_handler_ref(conn, handler_info);; 14319 ; 14320 return;; 14321 }; 14322 }; 14323 ; 14324 /* request is authorized or does not need authorization */; 14325 ; 14326 /* 7. check if there are request handlers for this uri */; 14327 if (is_callback_resource) {; 14328 HTTP1_only;; 14329 if (!is_websocket_request) {; 14330 i = callback_handler(conn, callback_data);; 14331 ; 14332 /* Callback handler will not be used anymore. Release it */; 14333 release_handler_ref(conn, handler_info);; 14334 ; 14335 if (i > 0) {; 14336 /* Do nothing, callback has served the request. Store; 14337 * then return value as status code for the log and discard; 14338 * all data from the client not used by the callback. */; 14339 conn->status_code = i;; 14340 if (!conn->must_close) {; 14341 discard_unread_request_data(con",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:421311,Security,authoriz,authorized,421311,"nfo == NULL);; 14290 ; 14291 /* This server does not have any real files, thus the; 14292 * PUT/DELETE methods are not valid. */; 14293 mg_send_http_error(conn,; 14294 405,; 14295 ""%s method not allowed"",; 14296 conn->request_info.request_method);; 14297 return;; 14298 }; 14299 ; 14300#if !defined(NO_FILES); 14301 /* 6.2.2. Check if put authorization for static files is; 14302 * available.; 14303 */; 14304 if (!is_authorized_for_put(conn)) {; 14305 send_authorization_request(conn, NULL);; 14306 return;; 14307 }; 14308#endif; 14309 ; 14310 } else {; 14311 /* 6.3. This is either a OPTIONS, GET, HEAD or POST request,; 14312 * or it is a PUT or DELETE request to a resource that does not; 14313 * correspond to a file. Check authorization. */; 14314 if (!check_authorization(conn, path)) {; 14315 send_authorization_request(conn, NULL);; 14316 ; 14317 /* Callback handler will not be used anymore. Release it */; 14318 release_handler_ref(conn, handler_info);; 14319 ; 14320 return;; 14321 }; 14322 }; 14323 ; 14324 /* request is authorized or does not need authorization */; 14325 ; 14326 /* 7. check if there are request handlers for this uri */; 14327 if (is_callback_resource) {; 14328 HTTP1_only;; 14329 if (!is_websocket_request) {; 14330 i = callback_handler(conn, callback_data);; 14331 ; 14332 /* Callback handler will not be used anymore. Release it */; 14333 release_handler_ref(conn, handler_info);; 14334 ; 14335 if (i > 0) {; 14336 /* Do nothing, callback has served the request. Store; 14337 * then return value as status code for the log and discard; 14338 * all data from the client not used by the callback. */; 14339 conn->status_code = i;; 14340 if (!conn->must_close) {; 14341 discard_unread_request_data(conn);; 14342 }; 14343 } else {; 14344 /* The handler did NOT handle the request. */; 14345 /* Some proper reactions would be:; 14346 * a) close the connections without sending anything; 14347 * b) send a 404 not found; 14348 * c) try if there is a file matching the URI",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:421339,Security,authoriz,authorization,421339,"nfo == NULL);; 14290 ; 14291 /* This server does not have any real files, thus the; 14292 * PUT/DELETE methods are not valid. */; 14293 mg_send_http_error(conn,; 14294 405,; 14295 ""%s method not allowed"",; 14296 conn->request_info.request_method);; 14297 return;; 14298 }; 14299 ; 14300#if !defined(NO_FILES); 14301 /* 6.2.2. Check if put authorization for static files is; 14302 * available.; 14303 */; 14304 if (!is_authorized_for_put(conn)) {; 14305 send_authorization_request(conn, NULL);; 14306 return;; 14307 }; 14308#endif; 14309 ; 14310 } else {; 14311 /* 6.3. This is either a OPTIONS, GET, HEAD or POST request,; 14312 * or it is a PUT or DELETE request to a resource that does not; 14313 * correspond to a file. Check authorization. */; 14314 if (!check_authorization(conn, path)) {; 14315 send_authorization_request(conn, NULL);; 14316 ; 14317 /* Callback handler will not be used anymore. Release it */; 14318 release_handler_ref(conn, handler_info);; 14319 ; 14320 return;; 14321 }; 14322 }; 14323 ; 14324 /* request is authorized or does not need authorization */; 14325 ; 14326 /* 7. check if there are request handlers for this uri */; 14327 if (is_callback_resource) {; 14328 HTTP1_only;; 14329 if (!is_websocket_request) {; 14330 i = callback_handler(conn, callback_data);; 14331 ; 14332 /* Callback handler will not be used anymore. Release it */; 14333 release_handler_ref(conn, handler_info);; 14334 ; 14335 if (i > 0) {; 14336 /* Do nothing, callback has served the request. Store; 14337 * then return value as status code for the log and discard; 14338 * all data from the client not used by the callback. */; 14339 conn->status_code = i;; 14340 if (!conn->must_close) {; 14341 discard_unread_request_data(conn);; 14342 }; 14343 } else {; 14344 /* The handler did NOT handle the request. */; 14345 /* Some proper reactions would be:; 14346 * a) close the connections without sending anything; 14347 * b) send a 404 not found; 14348 * c) try if there is a file matching the URI",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:422760,Security,authoriz,authorization,422760,"34 ; 14335 if (i > 0) {; 14336 /* Do nothing, callback has served the request. Store; 14337 * then return value as status code for the log and discard; 14338 * all data from the client not used by the callback. */; 14339 conn->status_code = i;; 14340 if (!conn->must_close) {; 14341 discard_unread_request_data(conn);; 14342 }; 14343 } else {; 14344 /* The handler did NOT handle the request. */; 14345 /* Some proper reactions would be:; 14346 * a) close the connections without sending anything; 14347 * b) send a 404 not found; 14348 * c) try if there is a file matching the URI; 14349 * It would be possible to do a, b or c in the callback; 14350 * implementation, and return 1 - we cannot do anything; 14351 * here, that is not possible in the callback.; 14352 *; 14353 * TODO: What would be the best reaction here?; 14354 * (Note: The reaction may change, if there is a better; 14355 * idea.); 14356 */; 14357 ; 14358 /* For the moment, use option c: We look for a proper file,; 14359 * but since a file request is not always a script resource,; 14360 * the authorization check might be different. */; 14361 interpret_uri(conn,; 14362 path,; 14363 sizeof(path),; 14364 &file.stat,; 14365 &is_found,; 14366 &is_script_resource,; 14367 &is_websocket_request,; 14368 &is_put_or_delete_request,; 14369 &is_template_text_file);; 14370 callback_handler = NULL;; 14371 ; 14372 /* Here we are at a dead end:; 14373 * According to URI matching, a callback should be; 14374 * responsible for handling the request,; 14375 * we called it, but the callback declared itself; 14376 * not responsible.; 14377 * We use a goto here, to get out of this dead end,; 14378 * and continue with the default handling.; 14379 * A goto here is simpler and better to understand; 14380 * than some curious loop. */; 14381 goto no_callback_resource;; 14382 }; 14383 } else {; 14384#if defined(USE_WEBSOCKET); 14385 handle_websocket_request(conn,; 14386 path,; 14387 is_callback_resource,; 14388 subprotocols,; 14389 ws_conne",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:428330,Security,access,access,428330,"od, ""PROPFIND"")) {; 14510 handle_propfind(conn, path, &file.stat);; 14511 return;; 14512 }; 14513 /* 13.2. Handle OPTIONS for files */; 14514 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14515 /* This standard handler is only used for real files.; 14516 * Scripts should support the OPTIONS method themselves, to allow a; 14517 * maximum flexibility.; 14518 * Lua and CGI scripts may fully support CORS this way (including; 14519 * preflights). */; 14520 send_options(conn);; 14521 return;; 14522 }; 14523 /* 13.3. everything but GET and HEAD (e.g. POST) */; 14524 if ((0 != strcmp(ri->request_method, ""GET"")); 14525 && (0 != strcmp(ri->request_method, ""HEAD""))) {; 14526 mg_send_http_error(conn,; 14527 405,; 14528 ""%s method not allowed"",; 14529 conn->request_info.request_method);; 14530 return;; 14531 }; 14532 ; 14533 /* 14. directories */; 14534 if (file.stat.is_directory) {; 14535 /* Substitute files have already been handled above. */; 14536 /* Here we can either generate and send a directory listing,; 14537 * or send an ""access denied"" error. */; 14538 if (!mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],; 14539 ""yes"")) {; 14540 handle_directory_request(conn, path);; 14541 } else {; 14542 mg_send_http_error(conn,; 14543 403,; 14544 ""%s"",; 14545 ""Error: Directory listing denied"");; 14546 }; 14547 return;; 14548 }; 14549 ; 14550 /* 15. Files with search/replace patterns: LSP and SSI */; 14551 if (is_template_text_file) {; 14552 HTTP1_only;; 14553 handle_file_based_request(conn, path, &file);; 14554 return;; 14555 }; 14556 ; 14557 /* 16. Static file - maybe cached */; 14558#if !defined(NO_CACHING); 14559 if ((!conn->in_error_handler) && is_not_modified(conn, &file.stat)) {; 14560 /* Send 304 ""Not Modified"" - this must not send any body data */; 14561 handle_not_modified_static_file_request(conn, &file);; 14562 return;; 14563 }; 14564#endif /* !NO_CACHING */; 14565 ; 14566 /* 17. Static file - not cached */; 14567 handle_static_file_request(conn, path, &fil",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:453810,Security,access,access,453810,"returned false: do not log */; 15320 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15321 return;; 15322 }; 15323 /* log returned true: continue logging */; 15324 } else if (t == LUA_TSTRING) {; 15325 size_t len;; 15326 const char *txt = lua_tolstring(lstate, -1, &len);; 15327 if ((len == 0) || (*txt == 0)) {; 15328 /* log() returned empty string: do not log */; 15329 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15330 return;; 15331 }; 15332 /* Copy test from Lua into log_buf */; 15333 if (len >= sizeof(log_buf)) {; 15334 len = sizeof(log_buf) - 1;; 15335 }; 15336 memcpy(log_buf, txt, len);; 15337 log_buf[len] = 0;; 15338 }; 15339 } else {; 15340 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15341 }; 15342 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15343 }; 15344#endif; 15345 ; 15346 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15347 if (mg_fopen(conn,; 15348 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15349 MG_FOPEN_MODE_APPEND,; 15350 &fi); 15351 == 0) {; 15352 fi.access.fp = NULL;; 15353 }; 15354 } else {; 15355 fi.access.fp = NULL;; 15356 }; 15357 ; 15358 /* Log is written to a file and/or a callback. If both are not set,; 15359 * executing the rest of the function is pointless. */; 15360 if ((fi.access.fp == NULL); 15361 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15362 return;; 15363 }; 15364 ; 15365 /* If we did not get a log message from Lua, create it here. */; 15366 if (!log_buf[0]) {; 15367 tm = localtime(&conn->conn_birth_time);; 15368 if (tm != NULL) {; 15369 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15370 } else {; 15371 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15372 date[sizeof(date) - 1] = '\0';; 15373 }; 15374 ; 15375 ri = &conn->request_info;; 15376 ; 15377 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15378 referer = header_val(conn, ""Referer"");; 15379 user_agent = header_val(conn, ""User-Agent"");; 15380 ; 15381 mg_snprintf(conn,; 15382 NULL, /* Ignore truncation ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:453863,Security,access,access,453863,"lock(&ctx->lua_bg_mutex);; 15321 return;; 15322 }; 15323 /* log returned true: continue logging */; 15324 } else if (t == LUA_TSTRING) {; 15325 size_t len;; 15326 const char *txt = lua_tolstring(lstate, -1, &len);; 15327 if ((len == 0) || (*txt == 0)) {; 15328 /* log() returned empty string: do not log */; 15329 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15330 return;; 15331 }; 15332 /* Copy test from Lua into log_buf */; 15333 if (len >= sizeof(log_buf)) {; 15334 len = sizeof(log_buf) - 1;; 15335 }; 15336 memcpy(log_buf, txt, len);; 15337 log_buf[len] = 0;; 15338 }; 15339 } else {; 15340 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15341 }; 15342 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15343 }; 15344#endif; 15345 ; 15346 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15347 if (mg_fopen(conn,; 15348 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15349 MG_FOPEN_MODE_APPEND,; 15350 &fi); 15351 == 0) {; 15352 fi.access.fp = NULL;; 15353 }; 15354 } else {; 15355 fi.access.fp = NULL;; 15356 }; 15357 ; 15358 /* Log is written to a file and/or a callback. If both are not set,; 15359 * executing the rest of the function is pointless. */; 15360 if ((fi.access.fp == NULL); 15361 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15362 return;; 15363 }; 15364 ; 15365 /* If we did not get a log message from Lua, create it here. */; 15366 if (!log_buf[0]) {; 15367 tm = localtime(&conn->conn_birth_time);; 15368 if (tm != NULL) {; 15369 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15370 } else {; 15371 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15372 date[sizeof(date) - 1] = '\0';; 15373 }; 15374 ; 15375 ri = &conn->request_info;; 15376 ; 15377 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15378 referer = header_val(conn, ""Referer"");; 15379 user_agent = header_val(conn, ""User-Agent"");; 15380 ; 15381 mg_snprintf(conn,; 15382 NULL, /* Ignore truncation in access log */; 15383 log_buf,; 15384 sizeof(log_bu",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:454049,Security,access,access,454049,"olstring(lstate, -1, &len);; 15327 if ((len == 0) || (*txt == 0)) {; 15328 /* log() returned empty string: do not log */; 15329 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15330 return;; 15331 }; 15332 /* Copy test from Lua into log_buf */; 15333 if (len >= sizeof(log_buf)) {; 15334 len = sizeof(log_buf) - 1;; 15335 }; 15336 memcpy(log_buf, txt, len);; 15337 log_buf[len] = 0;; 15338 }; 15339 } else {; 15340 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15341 }; 15342 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15343 }; 15344#endif; 15345 ; 15346 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15347 if (mg_fopen(conn,; 15348 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15349 MG_FOPEN_MODE_APPEND,; 15350 &fi); 15351 == 0) {; 15352 fi.access.fp = NULL;; 15353 }; 15354 } else {; 15355 fi.access.fp = NULL;; 15356 }; 15357 ; 15358 /* Log is written to a file and/or a callback. If both are not set,; 15359 * executing the rest of the function is pointless. */; 15360 if ((fi.access.fp == NULL); 15361 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15362 return;; 15363 }; 15364 ; 15365 /* If we did not get a log message from Lua, create it here. */; 15366 if (!log_buf[0]) {; 15367 tm = localtime(&conn->conn_birth_time);; 15368 if (tm != NULL) {; 15369 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15370 } else {; 15371 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15372 date[sizeof(date) - 1] = '\0';; 15373 }; 15374 ; 15375 ri = &conn->request_info;; 15376 ; 15377 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15378 referer = header_val(conn, ""Referer"");; 15379 user_agent = header_val(conn, ""User-Agent"");; 15380 ; 15381 mg_snprintf(conn,; 15382 NULL, /* Ignore truncation in access log */; 15383 log_buf,; 15384 sizeof(log_buf),; 15385 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15386 "" %s %s"",; 15387 src_addr,; 15388 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15389 date,; 15390 ri->request",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:454817,Security,access,access,454817,"ntless. */; 15360 if ((fi.access.fp == NULL); 15361 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15362 return;; 15363 }; 15364 ; 15365 /* If we did not get a log message from Lua, create it here. */; 15366 if (!log_buf[0]) {; 15367 tm = localtime(&conn->conn_birth_time);; 15368 if (tm != NULL) {; 15369 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15370 } else {; 15371 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15372 date[sizeof(date) - 1] = '\0';; 15373 }; 15374 ; 15375 ri = &conn->request_info;; 15376 ; 15377 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15378 referer = header_val(conn, ""Referer"");; 15379 user_agent = header_val(conn, ""User-Agent"");; 15380 ; 15381 mg_snprintf(conn,; 15382 NULL, /* Ignore truncation in access log */; 15383 log_buf,; 15384 sizeof(log_buf),; 15385 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15386 "" %s %s"",; 15387 src_addr,; 15388 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15389 date,; 15390 ri->request_method ? ri->request_method : ""-"",; 15391 ri->request_uri ? ri->request_uri : ""-"",; 15392 ri->query_string ? ""?"" : """",; 15393 ri->query_string ? ri->query_string : """",; 15394 ri->http_version,; 15395 conn->status_code,; 15396 conn->num_bytes_sent,; 15397 referer,; 15398 user_agent);; 15399 }; 15400 ; 15401 /* Here we have a log message in log_buf. Call the callback */; 15402 if (conn->phys_ctx->callbacks.log_access) {; 15403 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15404 /* do not log if callack returns non-zero */; 15405 if (fi.access.fp) {; 15406 mg_fclose(&fi.access);; 15407 }; 15408 return;; 15409 }; 15410 }; 15411 ; 15412 /* Store in file */; 15413 if (fi.access.fp) {; 15414 int ok = 1;; 15415 flockfile(fi.access.fp);; 15416 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15417 ok = 0;; 15418 }; 15419 if (fflush(fi.access.fp) != 0) {; 15420 ok = 0;; 15421 }; 15422 funlockfile(fi.access.fp);; 15423 if (mg_fclose(&fi.access) != 0)",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:455608,Security,access,access,455608,"sizeof(src_addr), &conn->client.rsa);; 15378 referer = header_val(conn, ""Referer"");; 15379 user_agent = header_val(conn, ""User-Agent"");; 15380 ; 15381 mg_snprintf(conn,; 15382 NULL, /* Ignore truncation in access log */; 15383 log_buf,; 15384 sizeof(log_buf),; 15385 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15386 "" %s %s"",; 15387 src_addr,; 15388 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15389 date,; 15390 ri->request_method ? ri->request_method : ""-"",; 15391 ri->request_uri ? ri->request_uri : ""-"",; 15392 ri->query_string ? ""?"" : """",; 15393 ri->query_string ? ri->query_string : """",; 15394 ri->http_version,; 15395 conn->status_code,; 15396 conn->num_bytes_sent,; 15397 referer,; 15398 user_agent);; 15399 }; 15400 ; 15401 /* Here we have a log message in log_buf. Call the callback */; 15402 if (conn->phys_ctx->callbacks.log_access) {; 15403 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15404 /* do not log if callack returns non-zero */; 15405 if (fi.access.fp) {; 15406 mg_fclose(&fi.access);; 15407 }; 15408 return;; 15409 }; 15410 }; 15411 ; 15412 /* Store in file */; 15413 if (fi.access.fp) {; 15414 int ok = 1;; 15415 flockfile(fi.access.fp);; 15416 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15417 ok = 0;; 15418 }; 15419 if (fflush(fi.access.fp) != 0) {; 15420 ok = 0;; 15421 }; 15422 funlockfile(fi.access.fp);; 15423 if (mg_fclose(&fi.access) != 0) {; 15424 ok = 0;; 15425 }; 15426 if (!ok) {; 15427 mg_cry_internal(conn,; 15428 ""Error writing log file %s"",; 15429 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15430 }; 15431 }; 15432}; 15433#else; 15434#error ""Either enable filesystems or provide a custom log_access implementation""; 15435#endif /* Externally provided function */; 15436 ; 15437 ; 15438/* Verify given socket address against the ACL.; 15439 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15440 */; 15441static int; 15442check_acl(struct mg_context *phys_ctx, const union usa *sa); 15443{; 1544",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:455642,Security,access,access,455642,");; 15379 user_agent = header_val(conn, ""User-Agent"");; 15380 ; 15381 mg_snprintf(conn,; 15382 NULL, /* Ignore truncation in access log */; 15383 log_buf,; 15384 sizeof(log_buf),; 15385 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15386 "" %s %s"",; 15387 src_addr,; 15388 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15389 date,; 15390 ri->request_method ? ri->request_method : ""-"",; 15391 ri->request_uri ? ri->request_uri : ""-"",; 15392 ri->query_string ? ""?"" : """",; 15393 ri->query_string ? ri->query_string : """",; 15394 ri->http_version,; 15395 conn->status_code,; 15396 conn->num_bytes_sent,; 15397 referer,; 15398 user_agent);; 15399 }; 15400 ; 15401 /* Here we have a log message in log_buf. Call the callback */; 15402 if (conn->phys_ctx->callbacks.log_access) {; 15403 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15404 /* do not log if callack returns non-zero */; 15405 if (fi.access.fp) {; 15406 mg_fclose(&fi.access);; 15407 }; 15408 return;; 15409 }; 15410 }; 15411 ; 15412 /* Store in file */; 15413 if (fi.access.fp) {; 15414 int ok = 1;; 15415 flockfile(fi.access.fp);; 15416 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15417 ok = 0;; 15418 }; 15419 if (fflush(fi.access.fp) != 0) {; 15420 ok = 0;; 15421 }; 15422 funlockfile(fi.access.fp);; 15423 if (mg_fclose(&fi.access) != 0) {; 15424 ok = 0;; 15425 }; 15426 if (!ok) {; 15427 mg_cry_internal(conn,; 15428 ""Error writing log file %s"",; 15429 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15430 }; 15431 }; 15432}; 15433#else; 15434#error ""Either enable filesystems or provide a custom log_access implementation""; 15435#endif /* Externally provided function */; 15436 ; 15437 ; 15438/* Verify given socket address against the ACL.; 15439 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15440 */; 15441static int; 15442check_acl(struct mg_context *phys_ctx, const union usa *sa); 15443{; 15444 int allowed, flag, matched;; 15445 struct vec vec;; 15446 ; 15447 if (phys_ctx",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:455742,Security,access,access,455742,";; 15380 ; 15381 mg_snprintf(conn,; 15382 NULL, /* Ignore truncation in access log */; 15383 log_buf,; 15384 sizeof(log_buf),; 15385 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15386 "" %s %s"",; 15387 src_addr,; 15388 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15389 date,; 15390 ri->request_method ? ri->request_method : ""-"",; 15391 ri->request_uri ? ri->request_uri : ""-"",; 15392 ri->query_string ? ""?"" : """",; 15393 ri->query_string ? ri->query_string : """",; 15394 ri->http_version,; 15395 conn->status_code,; 15396 conn->num_bytes_sent,; 15397 referer,; 15398 user_agent);; 15399 }; 15400 ; 15401 /* Here we have a log message in log_buf. Call the callback */; 15402 if (conn->phys_ctx->callbacks.log_access) {; 15403 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15404 /* do not log if callack returns non-zero */; 15405 if (fi.access.fp) {; 15406 mg_fclose(&fi.access);; 15407 }; 15408 return;; 15409 }; 15410 }; 15411 ; 15412 /* Store in file */; 15413 if (fi.access.fp) {; 15414 int ok = 1;; 15415 flockfile(fi.access.fp);; 15416 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15417 ok = 0;; 15418 }; 15419 if (fflush(fi.access.fp) != 0) {; 15420 ok = 0;; 15421 }; 15422 funlockfile(fi.access.fp);; 15423 if (mg_fclose(&fi.access) != 0) {; 15424 ok = 0;; 15425 }; 15426 if (!ok) {; 15427 mg_cry_internal(conn,; 15428 ""Error writing log file %s"",; 15429 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15430 }; 15431 }; 15432}; 15433#else; 15434#error ""Either enable filesystems or provide a custom log_access implementation""; 15435#endif /* Externally provided function */; 15436 ; 15437 ; 15438/* Verify given socket address against the ACL.; 15439 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15440 */; 15441static int; 15442check_acl(struct mg_context *phys_ctx, const union usa *sa); 15443{; 15444 int allowed, flag, matched;; 15445 struct vec vec;; 15446 ; 15447 if (phys_ctx) {; 15448 const char *list = phys_ctx->dd.config[ACCE",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:455794,Security,access,access,455794,"gnore truncation in access log */; 15383 log_buf,; 15384 sizeof(log_buf),; 15385 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15386 "" %s %s"",; 15387 src_addr,; 15388 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15389 date,; 15390 ri->request_method ? ri->request_method : ""-"",; 15391 ri->request_uri ? ri->request_uri : ""-"",; 15392 ri->query_string ? ""?"" : """",; 15393 ri->query_string ? ri->query_string : """",; 15394 ri->http_version,; 15395 conn->status_code,; 15396 conn->num_bytes_sent,; 15397 referer,; 15398 user_agent);; 15399 }; 15400 ; 15401 /* Here we have a log message in log_buf. Call the callback */; 15402 if (conn->phys_ctx->callbacks.log_access) {; 15403 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15404 /* do not log if callack returns non-zero */; 15405 if (fi.access.fp) {; 15406 mg_fclose(&fi.access);; 15407 }; 15408 return;; 15409 }; 15410 }; 15411 ; 15412 /* Store in file */; 15413 if (fi.access.fp) {; 15414 int ok = 1;; 15415 flockfile(fi.access.fp);; 15416 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15417 ok = 0;; 15418 }; 15419 if (fflush(fi.access.fp) != 0) {; 15420 ok = 0;; 15421 }; 15422 funlockfile(fi.access.fp);; 15423 if (mg_fclose(&fi.access) != 0) {; 15424 ok = 0;; 15425 }; 15426 if (!ok) {; 15427 mg_cry_internal(conn,; 15428 ""Error writing log file %s"",; 15429 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15430 }; 15431 }; 15432}; 15433#else; 15434#error ""Either enable filesystems or provide a custom log_access implementation""; 15435#endif /* Externally provided function */; 15436 ; 15437 ; 15438/* Verify given socket address against the ACL.; 15439 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15440 */; 15441static int; 15442check_acl(struct mg_context *phys_ctx, const union usa *sa); 15443{; 15444 int allowed, flag, matched;; 15445 struct vec vec;; 15446 ; 15447 if (phys_ctx) {; 15448 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15449 ; 15450 /* If any ACL is se",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:455828,Security,access,access,455828," 15383 log_buf,; 15384 sizeof(log_buf),; 15385 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15386 "" %s %s"",; 15387 src_addr,; 15388 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15389 date,; 15390 ri->request_method ? ri->request_method : ""-"",; 15391 ri->request_uri ? ri->request_uri : ""-"",; 15392 ri->query_string ? ""?"" : """",; 15393 ri->query_string ? ri->query_string : """",; 15394 ri->http_version,; 15395 conn->status_code,; 15396 conn->num_bytes_sent,; 15397 referer,; 15398 user_agent);; 15399 }; 15400 ; 15401 /* Here we have a log message in log_buf. Call the callback */; 15402 if (conn->phys_ctx->callbacks.log_access) {; 15403 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15404 /* do not log if callack returns non-zero */; 15405 if (fi.access.fp) {; 15406 mg_fclose(&fi.access);; 15407 }; 15408 return;; 15409 }; 15410 }; 15411 ; 15412 /* Store in file */; 15413 if (fi.access.fp) {; 15414 int ok = 1;; 15415 flockfile(fi.access.fp);; 15416 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15417 ok = 0;; 15418 }; 15419 if (fflush(fi.access.fp) != 0) {; 15420 ok = 0;; 15421 }; 15422 funlockfile(fi.access.fp);; 15423 if (mg_fclose(&fi.access) != 0) {; 15424 ok = 0;; 15425 }; 15426 if (!ok) {; 15427 mg_cry_internal(conn,; 15428 ""Error writing log file %s"",; 15429 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15430 }; 15431 }; 15432}; 15433#else; 15434#error ""Either enable filesystems or provide a custom log_access implementation""; 15435#endif /* Externally provided function */; 15436 ; 15437 ; 15438/* Verify given socket address against the ACL.; 15439 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15440 */; 15441static int; 15442check_acl(struct mg_context *phys_ctx, const union usa *sa); 15443{; 15444 int allowed, flag, matched;; 15445 struct vec vec;; 15446 ; 15447 if (phys_ctx) {; 15448 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15449 ; 15450 /* If any ACL is set, deny by default */; 15451 allow",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:455908,Security,access,access,455908,"\"" %d %"" INT64_FMT; 15386 "" %s %s"",; 15387 src_addr,; 15388 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15389 date,; 15390 ri->request_method ? ri->request_method : ""-"",; 15391 ri->request_uri ? ri->request_uri : ""-"",; 15392 ri->query_string ? ""?"" : """",; 15393 ri->query_string ? ri->query_string : """",; 15394 ri->http_version,; 15395 conn->status_code,; 15396 conn->num_bytes_sent,; 15397 referer,; 15398 user_agent);; 15399 }; 15400 ; 15401 /* Here we have a log message in log_buf. Call the callback */; 15402 if (conn->phys_ctx->callbacks.log_access) {; 15403 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15404 /* do not log if callack returns non-zero */; 15405 if (fi.access.fp) {; 15406 mg_fclose(&fi.access);; 15407 }; 15408 return;; 15409 }; 15410 }; 15411 ; 15412 /* Store in file */; 15413 if (fi.access.fp) {; 15414 int ok = 1;; 15415 flockfile(fi.access.fp);; 15416 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15417 ok = 0;; 15418 }; 15419 if (fflush(fi.access.fp) != 0) {; 15420 ok = 0;; 15421 }; 15422 funlockfile(fi.access.fp);; 15423 if (mg_fclose(&fi.access) != 0) {; 15424 ok = 0;; 15425 }; 15426 if (!ok) {; 15427 mg_cry_internal(conn,; 15428 ""Error writing log file %s"",; 15429 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15430 }; 15431 }; 15432}; 15433#else; 15434#error ""Either enable filesystems or provide a custom log_access implementation""; 15435#endif /* Externally provided function */; 15436 ; 15437 ; 15438/* Verify given socket address against the ACL.; 15439 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15440 */; 15441static int; 15442check_acl(struct mg_context *phys_ctx, const union usa *sa); 15443{; 15444 int allowed, flag, matched;; 15445 struct vec vec;; 15446 ; 15447 if (phys_ctx) {; 15448 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15449 ; 15450 /* If any ACL is set, deny by default */; 15451 allowed = (list == NULL) ? '+' : '-';; 15452 ; 15453 while ((list = next_option(list,",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:455973,Security,access,access,455973,"remote_user == NULL) ? ""-"" : ri->remote_user,; 15389 date,; 15390 ri->request_method ? ri->request_method : ""-"",; 15391 ri->request_uri ? ri->request_uri : ""-"",; 15392 ri->query_string ? ""?"" : """",; 15393 ri->query_string ? ri->query_string : """",; 15394 ri->http_version,; 15395 conn->status_code,; 15396 conn->num_bytes_sent,; 15397 referer,; 15398 user_agent);; 15399 }; 15400 ; 15401 /* Here we have a log message in log_buf. Call the callback */; 15402 if (conn->phys_ctx->callbacks.log_access) {; 15403 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15404 /* do not log if callack returns non-zero */; 15405 if (fi.access.fp) {; 15406 mg_fclose(&fi.access);; 15407 }; 15408 return;; 15409 }; 15410 }; 15411 ; 15412 /* Store in file */; 15413 if (fi.access.fp) {; 15414 int ok = 1;; 15415 flockfile(fi.access.fp);; 15416 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15417 ok = 0;; 15418 }; 15419 if (fflush(fi.access.fp) != 0) {; 15420 ok = 0;; 15421 }; 15422 funlockfile(fi.access.fp);; 15423 if (mg_fclose(&fi.access) != 0) {; 15424 ok = 0;; 15425 }; 15426 if (!ok) {; 15427 mg_cry_internal(conn,; 15428 ""Error writing log file %s"",; 15429 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15430 }; 15431 }; 15432}; 15433#else; 15434#error ""Either enable filesystems or provide a custom log_access implementation""; 15435#endif /* Externally provided function */; 15436 ; 15437 ; 15438/* Verify given socket address against the ACL.; 15439 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15440 */; 15441static int; 15442check_acl(struct mg_context *phys_ctx, const union usa *sa); 15443{; 15444 int allowed, flag, matched;; 15445 struct vec vec;; 15446 ; 15447 if (phys_ctx) {; 15448 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15449 ; 15450 /* If any ACL is set, deny by default */; 15451 allowed = (list == NULL) ? '+' : '-';; 15452 ; 15453 while ((list = next_option(list, &vec, NULL)) != NULL) {; 15454 flag = vec.ptr[0];; 15455 matched",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:456010,Security,access,access,456010,": """",; 15394 ri->http_version,; 15395 conn->status_code,; 15396 conn->num_bytes_sent,; 15397 referer,; 15398 user_agent);; 15399 }; 15400 ; 15401 /* Here we have a log message in log_buf. Call the callback */; 15402 if (conn->phys_ctx->callbacks.log_access) {; 15403 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15404 /* do not log if callack returns non-zero */; 15405 if (fi.access.fp) {; 15406 mg_fclose(&fi.access);; 15407 }; 15408 return;; 15409 }; 15410 }; 15411 ; 15412 /* Store in file */; 15413 if (fi.access.fp) {; 15414 int ok = 1;; 15415 flockfile(fi.access.fp);; 15416 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15417 ok = 0;; 15418 }; 15419 if (fflush(fi.access.fp) != 0) {; 15420 ok = 0;; 15421 }; 15422 funlockfile(fi.access.fp);; 15423 if (mg_fclose(&fi.access) != 0) {; 15424 ok = 0;; 15425 }; 15426 if (!ok) {; 15427 mg_cry_internal(conn,; 15428 ""Error writing log file %s"",; 15429 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15430 }; 15431 }; 15432}; 15433#else; 15434#error ""Either enable filesystems or provide a custom log_access implementation""; 15435#endif /* Externally provided function */; 15436 ; 15437 ; 15438/* Verify given socket address against the ACL.; 15439 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15440 */; 15441static int; 15442check_acl(struct mg_context *phys_ctx, const union usa *sa); 15443{; 15444 int allowed, flag, matched;; 15445 struct vec vec;; 15446 ; 15447 if (phys_ctx) {; 15448 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15449 ; 15450 /* If any ACL is set, deny by default */; 15451 allowed = (list == NULL) ? '+' : '-';; 15452 ; 15453 while ((list = next_option(list, &vec, NULL)) != NULL) {; 15454 flag = vec.ptr[0];; 15455 matched = -1;; 15456 if ((vec.len > 0) && ((flag == '+') || (flag == '-'))) {; 15457 vec.ptr++;; 15458 vec.len--;; 15459 matched = parse_match_net(&vec, sa, 1);; 15460 }; 15461 if (matched < 0) {; 15462 mg_cry_ctx_internal(phys_ctx,; 15463 ""%s: su",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:477141,Security,certificate,certificate,477141,"* OPENSSL_API_1_1 || OPENSSL_API_3_0 */; 16120 ; 16121#if !defined(NO_SSL_DL); 16122 if (!ssllib_dll_handle) {; 16123 ssllib_dll_handle =; 16124 load_tls_dll(ebuf, ebuf_len, SSL_LIB, ssl_sw, tls_feature_missing);; 16125 if (!ssllib_dll_handle) {; 16126#if !defined(OPENSSL_API_1_1); 16127 mg_free(ssl_mutexes);; 16128#endif; 16129 DEBUG_TRACE(""%s"", ebuf);; 16130 return 0;; 16131 }; 16132 }; 16133#endif /* NO_SSL_DL */; 16134 ; 16135#if (defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0)) \; 16136 && !defined(NO_SSL_DL); 16137 /* Initialize SSL library */; 16138 OPENSSL_init_ssl(0, NULL);; 16139 OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS; 16140 | OPENSSL_INIT_LOAD_CRYPTO_STRINGS,; 16141 NULL);; 16142#else; 16143 /* Initialize SSL library */; 16144 SSL_library_init();; 16145 SSL_load_error_strings();; 16146#endif; 16147 ; 16148 return 1;; 16149}; 16150 ; 16151 ; 16152static int; 16153ssl_use_pem_file(struct mg_context *phys_ctx,; 16154 struct mg_domain_context *dom_ctx,; 16155 const char *pem,; 16156 const char *chain); 16157{; 16158 if (SSL_CTX_use_certificate_file(dom_ctx->ssl_ctx, pem, 1) == 0) {; 16159 mg_cry_ctx_internal(phys_ctx,; 16160 ""%s: cannot open certificate file %s: %s"",; 16161 __func__,; 16162 pem,; 16163 ssl_error());; 16164 return 0;; 16165 }; 16166 ; 16167 /* could use SSL_CTX_set_default_passwd_cb_userdata */; 16168 if (SSL_CTX_use_PrivateKey_file(dom_ctx->ssl_ctx, pem, 1) == 0) {; 16169 mg_cry_ctx_internal(phys_ctx,; 16170 ""%s: cannot open private key file %s: %s"",; 16171 __func__,; 16172 pem,; 16173 ssl_error());; 16174 return 0;; 16175 }; 16176 ; 16177 if (SSL_CTX_check_private_key(dom_ctx->ssl_ctx) == 0) {; 16178 mg_cry_ctx_internal(phys_ctx,; 16179 ""%s: certificate and private key do not match: %s"",; 16180 __func__,; 16181 pem);; 16182 return 0;; 16183 }; 16184 ; 16185 /* In contrast to OpenSSL, wolfSSL does not support certificate; 16186 * chain files that contain private keys and certificates in; 16187 * SSL_CTX_use_certificate_chain_file.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:477669,Security,certificate,certificate,477669,"* OPENSSL_API_1_1 || OPENSSL_API_3_0 */; 16120 ; 16121#if !defined(NO_SSL_DL); 16122 if (!ssllib_dll_handle) {; 16123 ssllib_dll_handle =; 16124 load_tls_dll(ebuf, ebuf_len, SSL_LIB, ssl_sw, tls_feature_missing);; 16125 if (!ssllib_dll_handle) {; 16126#if !defined(OPENSSL_API_1_1); 16127 mg_free(ssl_mutexes);; 16128#endif; 16129 DEBUG_TRACE(""%s"", ebuf);; 16130 return 0;; 16131 }; 16132 }; 16133#endif /* NO_SSL_DL */; 16134 ; 16135#if (defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0)) \; 16136 && !defined(NO_SSL_DL); 16137 /* Initialize SSL library */; 16138 OPENSSL_init_ssl(0, NULL);; 16139 OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS; 16140 | OPENSSL_INIT_LOAD_CRYPTO_STRINGS,; 16141 NULL);; 16142#else; 16143 /* Initialize SSL library */; 16144 SSL_library_init();; 16145 SSL_load_error_strings();; 16146#endif; 16147 ; 16148 return 1;; 16149}; 16150 ; 16151 ; 16152static int; 16153ssl_use_pem_file(struct mg_context *phys_ctx,; 16154 struct mg_domain_context *dom_ctx,; 16155 const char *pem,; 16156 const char *chain); 16157{; 16158 if (SSL_CTX_use_certificate_file(dom_ctx->ssl_ctx, pem, 1) == 0) {; 16159 mg_cry_ctx_internal(phys_ctx,; 16160 ""%s: cannot open certificate file %s: %s"",; 16161 __func__,; 16162 pem,; 16163 ssl_error());; 16164 return 0;; 16165 }; 16166 ; 16167 /* could use SSL_CTX_set_default_passwd_cb_userdata */; 16168 if (SSL_CTX_use_PrivateKey_file(dom_ctx->ssl_ctx, pem, 1) == 0) {; 16169 mg_cry_ctx_internal(phys_ctx,; 16170 ""%s: cannot open private key file %s: %s"",; 16171 __func__,; 16172 pem,; 16173 ssl_error());; 16174 return 0;; 16175 }; 16176 ; 16177 if (SSL_CTX_check_private_key(dom_ctx->ssl_ctx) == 0) {; 16178 mg_cry_ctx_internal(phys_ctx,; 16179 ""%s: certificate and private key do not match: %s"",; 16180 __func__,; 16181 pem);; 16182 return 0;; 16183 }; 16184 ; 16185 /* In contrast to OpenSSL, wolfSSL does not support certificate; 16186 * chain files that contain private keys and certificates in; 16187 * SSL_CTX_use_certificate_chain_file.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:477839,Security,certificate,certificate,477839,"* OPENSSL_API_1_1 || OPENSSL_API_3_0 */; 16120 ; 16121#if !defined(NO_SSL_DL); 16122 if (!ssllib_dll_handle) {; 16123 ssllib_dll_handle =; 16124 load_tls_dll(ebuf, ebuf_len, SSL_LIB, ssl_sw, tls_feature_missing);; 16125 if (!ssllib_dll_handle) {; 16126#if !defined(OPENSSL_API_1_1); 16127 mg_free(ssl_mutexes);; 16128#endif; 16129 DEBUG_TRACE(""%s"", ebuf);; 16130 return 0;; 16131 }; 16132 }; 16133#endif /* NO_SSL_DL */; 16134 ; 16135#if (defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0)) \; 16136 && !defined(NO_SSL_DL); 16137 /* Initialize SSL library */; 16138 OPENSSL_init_ssl(0, NULL);; 16139 OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS; 16140 | OPENSSL_INIT_LOAD_CRYPTO_STRINGS,; 16141 NULL);; 16142#else; 16143 /* Initialize SSL library */; 16144 SSL_library_init();; 16145 SSL_load_error_strings();; 16146#endif; 16147 ; 16148 return 1;; 16149}; 16150 ; 16151 ; 16152static int; 16153ssl_use_pem_file(struct mg_context *phys_ctx,; 16154 struct mg_domain_context *dom_ctx,; 16155 const char *pem,; 16156 const char *chain); 16157{; 16158 if (SSL_CTX_use_certificate_file(dom_ctx->ssl_ctx, pem, 1) == 0) {; 16159 mg_cry_ctx_internal(phys_ctx,; 16160 ""%s: cannot open certificate file %s: %s"",; 16161 __func__,; 16162 pem,; 16163 ssl_error());; 16164 return 0;; 16165 }; 16166 ; 16167 /* could use SSL_CTX_set_default_passwd_cb_userdata */; 16168 if (SSL_CTX_use_PrivateKey_file(dom_ctx->ssl_ctx, pem, 1) == 0) {; 16169 mg_cry_ctx_internal(phys_ctx,; 16170 ""%s: cannot open private key file %s: %s"",; 16171 __func__,; 16172 pem,; 16173 ssl_error());; 16174 return 0;; 16175 }; 16176 ; 16177 if (SSL_CTX_check_private_key(dom_ctx->ssl_ctx) == 0) {; 16178 mg_cry_ctx_internal(phys_ctx,; 16179 ""%s: certificate and private key do not match: %s"",; 16180 __func__,; 16181 pem);; 16182 return 0;; 16183 }; 16184 ; 16185 /* In contrast to OpenSSL, wolfSSL does not support certificate; 16186 * chain files that contain private keys and certificates in; 16187 * SSL_CTX_use_certificate_chain_file.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:477902,Security,certificate,certificates,477902,"* OPENSSL_API_1_1 || OPENSSL_API_3_0 */; 16120 ; 16121#if !defined(NO_SSL_DL); 16122 if (!ssllib_dll_handle) {; 16123 ssllib_dll_handle =; 16124 load_tls_dll(ebuf, ebuf_len, SSL_LIB, ssl_sw, tls_feature_missing);; 16125 if (!ssllib_dll_handle) {; 16126#if !defined(OPENSSL_API_1_1); 16127 mg_free(ssl_mutexes);; 16128#endif; 16129 DEBUG_TRACE(""%s"", ebuf);; 16130 return 0;; 16131 }; 16132 }; 16133#endif /* NO_SSL_DL */; 16134 ; 16135#if (defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0)) \; 16136 && !defined(NO_SSL_DL); 16137 /* Initialize SSL library */; 16138 OPENSSL_init_ssl(0, NULL);; 16139 OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS; 16140 | OPENSSL_INIT_LOAD_CRYPTO_STRINGS,; 16141 NULL);; 16142#else; 16143 /* Initialize SSL library */; 16144 SSL_library_init();; 16145 SSL_load_error_strings();; 16146#endif; 16147 ; 16148 return 1;; 16149}; 16150 ; 16151 ; 16152static int; 16153ssl_use_pem_file(struct mg_context *phys_ctx,; 16154 struct mg_domain_context *dom_ctx,; 16155 const char *pem,; 16156 const char *chain); 16157{; 16158 if (SSL_CTX_use_certificate_file(dom_ctx->ssl_ctx, pem, 1) == 0) {; 16159 mg_cry_ctx_internal(phys_ctx,; 16160 ""%s: cannot open certificate file %s: %s"",; 16161 __func__,; 16162 pem,; 16163 ssl_error());; 16164 return 0;; 16165 }; 16166 ; 16167 /* could use SSL_CTX_set_default_passwd_cb_userdata */; 16168 if (SSL_CTX_use_PrivateKey_file(dom_ctx->ssl_ctx, pem, 1) == 0) {; 16169 mg_cry_ctx_internal(phys_ctx,; 16170 ""%s: cannot open private key file %s: %s"",; 16171 __func__,; 16172 pem,; 16173 ssl_error());; 16174 return 0;; 16175 }; 16176 ; 16177 if (SSL_CTX_check_private_key(dom_ctx->ssl_ctx) == 0) {; 16178 mg_cry_ctx_internal(phys_ctx,; 16179 ""%s: certificate and private key do not match: %s"",; 16180 __func__,; 16181 pem);; 16182 return 0;; 16183 }; 16184 ; 16185 /* In contrast to OpenSSL, wolfSSL does not support certificate; 16186 * chain files that contain private keys and certificates in; 16187 * SSL_CTX_use_certificate_chain_file.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:478146,Security,certificate,certificate,478146,"16161 __func__,; 16162 pem,; 16163 ssl_error());; 16164 return 0;; 16165 }; 16166 ; 16167 /* could use SSL_CTX_set_default_passwd_cb_userdata */; 16168 if (SSL_CTX_use_PrivateKey_file(dom_ctx->ssl_ctx, pem, 1) == 0) {; 16169 mg_cry_ctx_internal(phys_ctx,; 16170 ""%s: cannot open private key file %s: %s"",; 16171 __func__,; 16172 pem,; 16173 ssl_error());; 16174 return 0;; 16175 }; 16176 ; 16177 if (SSL_CTX_check_private_key(dom_ctx->ssl_ctx) == 0) {; 16178 mg_cry_ctx_internal(phys_ctx,; 16179 ""%s: certificate and private key do not match: %s"",; 16180 __func__,; 16181 pem);; 16182 return 0;; 16183 }; 16184 ; 16185 /* In contrast to OpenSSL, wolfSSL does not support certificate; 16186 * chain files that contain private keys and certificates in; 16187 * SSL_CTX_use_certificate_chain_file.; 16188 * The CivetWeb-Server used pem-Files that contained both information.; 16189 * In order to make wolfSSL work, it is split in two files.; 16190 * One file that contains key and certificate used by the server and; 16191 * an optional chain file for the ssl stack.; 16192 */; 16193 if (chain) {; 16194 if (SSL_CTX_use_certificate_chain_file(dom_ctx->ssl_ctx, chain) == 0) {; 16195 mg_cry_ctx_internal(phys_ctx,; 16196 ""%s: cannot use certificate chain file %s: %s"",; 16197 __func__,; 16198 chain,; 16199 ssl_error());; 16200 return 0;; 16201 }; 16202 }; 16203 return 1;; 16204}; 16205 ; 16206 ; 16207#if defined(OPENSSL_API_1_1); 16208static unsigned long; 16209ssl_get_protocol(int version_id); 16210{; 16211 long unsigned ret = (long unsigned)SSL_OP_ALL;; 16212 if (version_id > 0); 16213 ret |= SSL_OP_NO_SSLv2;; 16214 if (version_id > 1); 16215 ret |= SSL_OP_NO_SSLv3;; 16216 if (version_id > 2); 16217 ret |= SSL_OP_NO_TLSv1;; 16218 if (version_id > 3); 16219 ret |= SSL_OP_NO_TLSv1_1;; 16220 if (version_id > 4); 16221 ret |= SSL_OP_NO_TLSv1_2;; 16222#if defined(SSL_OP_NO_TLSv1_3); 16223 if (version_id > 5); 16224 ret |= SSL_OP_NO_TLSv1_3;; 16225#endif; 16226 return ret;; 16227}; 16228#else; ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:478401,Security,certificate,certificate,478401,"rmation.; 16189 * In order to make wolfSSL work, it is split in two files.; 16190 * One file that contains key and certificate used by the server and; 16191 * an optional chain file for the ssl stack.; 16192 */; 16193 if (chain) {; 16194 if (SSL_CTX_use_certificate_chain_file(dom_ctx->ssl_ctx, chain) == 0) {; 16195 mg_cry_ctx_internal(phys_ctx,; 16196 ""%s: cannot use certificate chain file %s: %s"",; 16197 __func__,; 16198 chain,; 16199 ssl_error());; 16200 return 0;; 16201 }; 16202 }; 16203 return 1;; 16204}; 16205 ; 16206 ; 16207#if defined(OPENSSL_API_1_1); 16208static unsigned long; 16209ssl_get_protocol(int version_id); 16210{; 16211 long unsigned ret = (long unsigned)SSL_OP_ALL;; 16212 if (version_id > 0); 16213 ret |= SSL_OP_NO_SSLv2;; 16214 if (version_id > 1); 16215 ret |= SSL_OP_NO_SSLv3;; 16216 if (version_id > 2); 16217 ret |= SSL_OP_NO_TLSv1;; 16218 if (version_id > 3); 16219 ret |= SSL_OP_NO_TLSv1_1;; 16220 if (version_id > 4); 16221 ret |= SSL_OP_NO_TLSv1_2;; 16222#if defined(SSL_OP_NO_TLSv1_3); 16223 if (version_id > 5); 16224 ret |= SSL_OP_NO_TLSv1_3;; 16225#endif; 16226 return ret;; 16227}; 16228#else; 16229static long; 16230ssl_get_protocol(int version_id); 16231{; 16232 unsigned long ret = (unsigned long)SSL_OP_ALL;; 16233 if (version_id > 0); 16234 ret |= SSL_OP_NO_SSLv2;; 16235 if (version_id > 1); 16236 ret |= SSL_OP_NO_SSLv3;; 16237 if (version_id > 2); 16238 ret |= SSL_OP_NO_TLSv1;; 16239 if (version_id > 3); 16240 ret |= SSL_OP_NO_TLSv1_1;; 16241 if (version_id > 4); 16242 ret |= SSL_OP_NO_TLSv1_2;; 16243#if defined(SSL_OP_NO_TLSv1_3); 16244 if (version_id > 5); 16245 ret |= SSL_OP_NO_TLSv1_3;; 16246#endif; 16247 return (long)ret;; 16248}; 16249#endif /* OPENSSL_API_1_1 */; 16250 ; 16251 ; 16252/* SSL callback documentation:; 16253 * https://www.openssl.org/docs/man1.1.0/ssl/SSL_set_info_callback.html; 16254 * https://wiki.openssl.org/index.php/Manual:SSL_CTX_set_info_callback(3); 16255 * https://linux.die.net/man/3/ssl_set_info_callback */; ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:481897,Security,certificate,certificate,481897,"IATE_CIPHERS;; 16274 }; 16275}; 16276 ; 16277 ; 16278static int; 16279ssl_servername_callback(SSL *ssl, int *ad, void *arg); 16280{; 16281#if defined(GCC_DIAGNOSTIC); 16282#pragma GCC diagnostic push; 16283#pragma GCC diagnostic ignored ""-Wcast-align""; 16284#endif /* defined(GCC_DIAGNOSTIC) */; 16285 ; 16286 /* We used an aligned pointer in SSL_set_app_data */; 16287 struct mg_connection *conn = (struct mg_connection *)SSL_get_app_data(ssl);; 16288 ; 16289#if defined(GCC_DIAGNOSTIC); 16290#pragma GCC diagnostic pop; 16291#endif /* defined(GCC_DIAGNOSTIC) */; 16292 ; 16293 const char *servername = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);; 16294 ; 16295 (void)ad;; 16296 (void)arg;; 16297 ; 16298 if ((conn == NULL) || (conn->phys_ctx == NULL)) {; 16299 DEBUG_ASSERT(0);; 16300 return SSL_TLSEXT_ERR_NOACK;; 16301 }; 16302 conn->dom_ctx = &(conn->phys_ctx->dd);; 16303 ; 16304 /* Old clients (Win XP) will not support SNI. Then, there; 16305 * is no server name available in the request - we can; 16306 * only work with the default certificate.; 16307 * Multiple HTTPS hosts on one IP+port are only possible; 16308 * with a certificate containing all alternative names.; 16309 */; 16310 if ((servername == NULL) || (*servername == 0)) {; 16311 DEBUG_TRACE(""%s"", ""SSL connection not supporting SNI"");; 16312 mg_lock_context(conn->phys_ctx);; 16313 SSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);; 16314 mg_unlock_context(conn->phys_ctx);; 16315 return SSL_TLSEXT_ERR_NOACK;; 16316 }; 16317 ; 16318 DEBUG_TRACE(""TLS connection to host %s"", servername);; 16319 ; 16320 while (conn->dom_ctx) {; 16321 if (!mg_strcasecmp(servername,; 16322 conn->dom_ctx->config[AUTHENTICATION_DOMAIN])) {; 16323 /* Found matching domain */; 16324 DEBUG_TRACE(""TLS domain %s found"",; 16325 conn->dom_ctx->config[AUTHENTICATION_DOMAIN]);; 16326 break;; 16327 }; 16328 mg_lock_context(conn->phys_ctx);; 16329 conn->dom_ctx = conn->dom_ctx->next;; 16330 mg_unlock_context(conn->phys_ctx);; 16331 }; 16332 ; 163",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:481989,Security,certificate,certificate,481989,"; 16280{; 16281#if defined(GCC_DIAGNOSTIC); 16282#pragma GCC diagnostic push; 16283#pragma GCC diagnostic ignored ""-Wcast-align""; 16284#endif /* defined(GCC_DIAGNOSTIC) */; 16285 ; 16286 /* We used an aligned pointer in SSL_set_app_data */; 16287 struct mg_connection *conn = (struct mg_connection *)SSL_get_app_data(ssl);; 16288 ; 16289#if defined(GCC_DIAGNOSTIC); 16290#pragma GCC diagnostic pop; 16291#endif /* defined(GCC_DIAGNOSTIC) */; 16292 ; 16293 const char *servername = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);; 16294 ; 16295 (void)ad;; 16296 (void)arg;; 16297 ; 16298 if ((conn == NULL) || (conn->phys_ctx == NULL)) {; 16299 DEBUG_ASSERT(0);; 16300 return SSL_TLSEXT_ERR_NOACK;; 16301 }; 16302 conn->dom_ctx = &(conn->phys_ctx->dd);; 16303 ; 16304 /* Old clients (Win XP) will not support SNI. Then, there; 16305 * is no server name available in the request - we can; 16306 * only work with the default certificate.; 16307 * Multiple HTTPS hosts on one IP+port are only possible; 16308 * with a certificate containing all alternative names.; 16309 */; 16310 if ((servername == NULL) || (*servername == 0)) {; 16311 DEBUG_TRACE(""%s"", ""SSL connection not supporting SNI"");; 16312 mg_lock_context(conn->phys_ctx);; 16313 SSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);; 16314 mg_unlock_context(conn->phys_ctx);; 16315 return SSL_TLSEXT_ERR_NOACK;; 16316 }; 16317 ; 16318 DEBUG_TRACE(""TLS connection to host %s"", servername);; 16319 ; 16320 while (conn->dom_ctx) {; 16321 if (!mg_strcasecmp(servername,; 16322 conn->dom_ctx->config[AUTHENTICATION_DOMAIN])) {; 16323 /* Found matching domain */; 16324 DEBUG_TRACE(""TLS domain %s found"",; 16325 conn->dom_ctx->config[AUTHENTICATION_DOMAIN]);; 16326 break;; 16327 }; 16328 mg_lock_context(conn->phys_ctx);; 16329 conn->dom_ctx = conn->dom_ctx->next;; 16330 mg_unlock_context(conn->phys_ctx);; 16331 }; 16332 ; 16333 if (conn->dom_ctx == NULL) {; 16334 /* Default domain */; 16335 DEBUG_TRACE(""TLS default domain %s used"",; 16336 conn->ph",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:489904,Security,certificate,certificate,489904,"6517 * https://www.openssl.org/docs/man1.1.0/ssl/ssl.html; 16518 * But in the source code const SSL is used:; 16519 * 'void (*)(const SSL *, int, int)' See:; 16520 * https://github.com/openssl/openssl/blob/1d97c8435171a7af575f73c526d79e1ef0ee5960/ssl/ssl.h#L1173; 16521 * Problem about wrong documentation described, but not resolved:; 16522 * https://bugs.launchpad.net/ubuntu/+source/openssl/+bug/1147526; 16523 * Wrong const cast ignored on C or can be suppressed by compiler flags.; 16524 * But when compiled with modern C++ compiler, correct const should be; 16525 * provided; 16526 */; 16527 SSL_CTX_set_info_callback(dom_ctx->ssl_ctx, ssl_info_callback);; 16528 ; 16529 SSL_CTX_set_tlsext_servername_callback(dom_ctx->ssl_ctx,; 16530 ssl_servername_callback);; 16531 ; 16532 /* If a callback has been specified, call it. */; 16533 callback_ret = (phys_ctx->callbacks.init_ssl == NULL); 16534 ? 0; 16535 : (phys_ctx->callbacks.init_ssl(dom_ctx->ssl_ctx,; 16536 phys_ctx->user_data));; 16537 ; 16538 /* If callback returns 0, civetweb sets up the SSL certificate.; 16539 * If it returns 1, civetweb assumes the calback already did this.; 16540 * If it returns -1, initializing ssl fails. */; 16541 if (callback_ret < 0) {; 16542 mg_cry_ctx_internal(phys_ctx,; 16543 ""SSL callback returned error: %i"",; 16544 callback_ret);; 16545 return 0;; 16546 }; 16547 if (callback_ret > 0) {; 16548 /* Callback did everything. */; 16549 return 1;; 16550 }; 16551 ; 16552 /* If a domain callback has been specified, call it. */; 16553 callback_ret = (phys_ctx->callbacks.init_ssl_domain == NULL); 16554 ? 0; 16555 : (phys_ctx->callbacks.init_ssl_domain(; 16556 dom_ctx->config[AUTHENTICATION_DOMAIN],; 16557 dom_ctx->ssl_ctx,; 16558 phys_ctx->user_data));; 16559 ; 16560 /* If domain callback returns 0, civetweb sets up the SSL certificate.; 16561 * If it returns 1, civetweb assumes the calback already did this.; 16562 * If it returns -1, initializing ssl fails. */; 16563 if (callback_ret < 0) {; 16564 mg",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:490669,Security,certificate,certificate,490669,"x,; 16530 ssl_servername_callback);; 16531 ; 16532 /* If a callback has been specified, call it. */; 16533 callback_ret = (phys_ctx->callbacks.init_ssl == NULL); 16534 ? 0; 16535 : (phys_ctx->callbacks.init_ssl(dom_ctx->ssl_ctx,; 16536 phys_ctx->user_data));; 16537 ; 16538 /* If callback returns 0, civetweb sets up the SSL certificate.; 16539 * If it returns 1, civetweb assumes the calback already did this.; 16540 * If it returns -1, initializing ssl fails. */; 16541 if (callback_ret < 0) {; 16542 mg_cry_ctx_internal(phys_ctx,; 16543 ""SSL callback returned error: %i"",; 16544 callback_ret);; 16545 return 0;; 16546 }; 16547 if (callback_ret > 0) {; 16548 /* Callback did everything. */; 16549 return 1;; 16550 }; 16551 ; 16552 /* If a domain callback has been specified, call it. */; 16553 callback_ret = (phys_ctx->callbacks.init_ssl_domain == NULL); 16554 ? 0; 16555 : (phys_ctx->callbacks.init_ssl_domain(; 16556 dom_ctx->config[AUTHENTICATION_DOMAIN],; 16557 dom_ctx->ssl_ctx,; 16558 phys_ctx->user_data));; 16559 ; 16560 /* If domain callback returns 0, civetweb sets up the SSL certificate.; 16561 * If it returns 1, civetweb assumes the calback already did this.; 16562 * If it returns -1, initializing ssl fails. */; 16563 if (callback_ret < 0) {; 16564 mg_cry_ctx_internal(phys_ctx,; 16565 ""Domain SSL callback returned error: %i"",; 16566 callback_ret);; 16567 return 0;; 16568 }; 16569 if (callback_ret > 0) {; 16570 /* Domain callback did everything. */; 16571 return 1;; 16572 }; 16573 ; 16574 /* Use some combination of start time, domain and port as a SSL; 16575 * context ID. This should be unique on the current machine. */; 16576 md5_init(&md5state);; 16577 clock_gettime(CLOCK_MONOTONIC, &now_mt);; 16578 md5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));; 16579 md5_append(&md5state,; 16580 (const md5_byte_t *)phys_ctx->dd.config[LISTENING_PORTS],; 16581 strlen(phys_ctx->dd.config[LISTENING_PORTS]));; 16582 md5_append(&md5state,; 16583 (const md5_byte_t *",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:492189,Security,certificate,certificates,492189,"al(phys_ctx,; 16565 ""Domain SSL callback returned error: %i"",; 16566 callback_ret);; 16567 return 0;; 16568 }; 16569 if (callback_ret > 0) {; 16570 /* Domain callback did everything. */; 16571 return 1;; 16572 }; 16573 ; 16574 /* Use some combination of start time, domain and port as a SSL; 16575 * context ID. This should be unique on the current machine. */; 16576 md5_init(&md5state);; 16577 clock_gettime(CLOCK_MONOTONIC, &now_mt);; 16578 md5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));; 16579 md5_append(&md5state,; 16580 (const md5_byte_t *)phys_ctx->dd.config[LISTENING_PORTS],; 16581 strlen(phys_ctx->dd.config[LISTENING_PORTS]));; 16582 md5_append(&md5state,; 16583 (const md5_byte_t *)dom_ctx->config[AUTHENTICATION_DOMAIN],; 16584 strlen(dom_ctx->config[AUTHENTICATION_DOMAIN]));; 16585 md5_append(&md5state, (const md5_byte_t *)phys_ctx, sizeof(*phys_ctx));; 16586 md5_append(&md5state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16587 md5_finish(&md5state, ssl_context_id);; 16588 ; 16589 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16590 (unsigned char *)ssl_context_id,; 16591 sizeof(ssl_context_id));; 16592 ; 16593 if (pem != NULL) {; 16594 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16595 return 0;; 16596 }; 16597 }; 16598 ; 16599 /* Should we support client certificates? */; 16600 /* Default is ""no"". */; 16601 should_verify_peer = 0;; 16602 peer_certificate_optional = 0;; 16603 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16604 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16605 /* Yes, they are mandatory */; 16606 should_verify_peer = 1;; 16607 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16608 ""optional""); 16609 == 0) {; 16610 /* Yes, they are optional */; 16611 should_verify_peer = 1;; 16612 peer_certificate_optional = 1;; 16613 }; 16614 }; 16615 ; 16616 use_default_verify_paths =; 16617 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16618 && (mg_strcasecmp(dom_c",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:498091,Security,certificate,certificate,498091,"tx->user_data));; 16752 ; 16753 if (callback_ret < 0) {; 16754 /* Callback < 0: Error. Abort init. */; 16755 mg_cry_ctx_internal(; 16756 phys_ctx,; 16757 ""external_ssl_ctx_domain callback returned error: %i"",; 16758 callback_ret);; 16759 return 0;; 16760 } else if (callback_ret > 0) {; 16761 /* Callback > 0: Consider init done. */; 16762 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16763 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16764 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16765 return 0;; 16766 }; 16767 return 1;; 16768 }; 16769 /* else: external_ssl_ctx/external_ssl_ctx_domain do not exist or return; 16770 * 0, CivetWeb should continue initializing SSL */; 16771 ; 16772 /* If PEM file is not specified and the init_ssl callbacks; 16773 * are not specified, setup will fail. */; 16774 if (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL); 16775 && (phys_ctx->callbacks.init_ssl == NULL); 16776 && (phys_ctx->callbacks.init_ssl_domain == NULL)) {; 16777 /* No certificate and no init_ssl callbacks:; 16778 * Essential data to set up TLS is missing.; 16779 */; 16780 mg_cry_ctx_internal(phys_ctx,; 16781 ""Initializing SSL failed: -%s is not set"",; 16782 config_options[SSL_CERTIFICATE].name);; 16783 return 0;; 16784 }; 16785 ; 16786 /* If a certificate chain is configured, use it. */; 16787 chain = dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 16788 if (chain == NULL) {; 16789 /* Default: certificate chain in PEM file */; 16790 chain = pem;; 16791 }; 16792 if ((chain != NULL) && (*chain == 0)) {; 16793 /* If the chain is an empty string, don't use it. */; 16794 chain = NULL;; 16795 }; 16796 ; 16797 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16798 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16799 return 0;; 16800 }; 16801 ; 16802 return init_ssl_ctx_impl(phys_ctx, dom_ctx, pem, chain);; 16803}; 16804 ; 16805 ; 16806static void; 16807uninitialize_openssl(void); 16808{; 16809#if defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0); 16810 ; 16811 if (mg_atomic_dec(&cryptoli",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:498372,Security,certificate,certificate,498372,"6760 } else if (callback_ret > 0) {; 16761 /* Callback > 0: Consider init done. */; 16762 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16763 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16764 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16765 return 0;; 16766 }; 16767 return 1;; 16768 }; 16769 /* else: external_ssl_ctx/external_ssl_ctx_domain do not exist or return; 16770 * 0, CivetWeb should continue initializing SSL */; 16771 ; 16772 /* If PEM file is not specified and the init_ssl callbacks; 16773 * are not specified, setup will fail. */; 16774 if (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL); 16775 && (phys_ctx->callbacks.init_ssl == NULL); 16776 && (phys_ctx->callbacks.init_ssl_domain == NULL)) {; 16777 /* No certificate and no init_ssl callbacks:; 16778 * Essential data to set up TLS is missing.; 16779 */; 16780 mg_cry_ctx_internal(phys_ctx,; 16781 ""Initializing SSL failed: -%s is not set"",; 16782 config_options[SSL_CERTIFICATE].name);; 16783 return 0;; 16784 }; 16785 ; 16786 /* If a certificate chain is configured, use it. */; 16787 chain = dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 16788 if (chain == NULL) {; 16789 /* Default: certificate chain in PEM file */; 16790 chain = pem;; 16791 }; 16792 if ((chain != NULL) && (*chain == 0)) {; 16793 /* If the chain is an empty string, don't use it. */; 16794 chain = NULL;; 16795 }; 16796 ; 16797 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16798 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16799 return 0;; 16800 }; 16801 ; 16802 return init_ssl_ctx_impl(phys_ctx, dom_ctx, pem, chain);; 16803}; 16804 ; 16805 ; 16806static void; 16807uninitialize_openssl(void); 16808{; 16809#if defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0); 16810 ; 16811 if (mg_atomic_dec(&cryptolib_users) == 0) {; 16812 ; 16813 /* Shutdown according to; 16814 * https://wiki.openssl.org/index.php/Library_Initialization#Cleanup; 16815 * http://stackoverflow.com/questions/29845527/how-to-properly-uninitialize-openssl; 16816 */; 16817 CONF_modul",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:498518,Security,certificate,certificate,498518," 16764 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16765 return 0;; 16766 }; 16767 return 1;; 16768 }; 16769 /* else: external_ssl_ctx/external_ssl_ctx_domain do not exist or return; 16770 * 0, CivetWeb should continue initializing SSL */; 16771 ; 16772 /* If PEM file is not specified and the init_ssl callbacks; 16773 * are not specified, setup will fail. */; 16774 if (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL); 16775 && (phys_ctx->callbacks.init_ssl == NULL); 16776 && (phys_ctx->callbacks.init_ssl_domain == NULL)) {; 16777 /* No certificate and no init_ssl callbacks:; 16778 * Essential data to set up TLS is missing.; 16779 */; 16780 mg_cry_ctx_internal(phys_ctx,; 16781 ""Initializing SSL failed: -%s is not set"",; 16782 config_options[SSL_CERTIFICATE].name);; 16783 return 0;; 16784 }; 16785 ; 16786 /* If a certificate chain is configured, use it. */; 16787 chain = dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 16788 if (chain == NULL) {; 16789 /* Default: certificate chain in PEM file */; 16790 chain = pem;; 16791 }; 16792 if ((chain != NULL) && (*chain == 0)) {; 16793 /* If the chain is an empty string, don't use it. */; 16794 chain = NULL;; 16795 }; 16796 ; 16797 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16798 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16799 return 0;; 16800 }; 16801 ; 16802 return init_ssl_ctx_impl(phys_ctx, dom_ctx, pem, chain);; 16803}; 16804 ; 16805 ; 16806static void; 16807uninitialize_openssl(void); 16808{; 16809#if defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0); 16810 ; 16811 if (mg_atomic_dec(&cryptolib_users) == 0) {; 16812 ; 16813 /* Shutdown according to; 16814 * https://wiki.openssl.org/index.php/Library_Initialization#Cleanup; 16815 * http://stackoverflow.com/questions/29845527/how-to-properly-uninitialize-openssl; 16816 */; 16817 CONF_modules_unload(1);; 16818#else; 16819 int i;; 16820 ; 16821 if (mg_atomic_dec(&cryptolib_users) == 0) {; 16822 ; 16823 /* Shutdown according to; 16824 * https://wiki.openssl.org/index.php/L",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:515614,Security,certificate,certificate,515614,"client.rsa.sin);; 17322#endif; 17323 ; 17324 conn->client.sock = sock;; 17325 conn->client.lsa = sa;; 17326 ; 17327 if (getsockname(sock, psa, &len) != 0) {; 17328 mg_cry_internal(conn,; 17329 ""%s: getsockname() failed: %s"",; 17330 __func__,; 17331 strerror(ERRNO));; 17332 }; 17333 ; 17334 conn->client.is_ssl = use_ssl ? 1 : 0;; 17335 if (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {; 17336 mg_snprintf(NULL,; 17337 NULL, /* No truncation check for ebuf */; 17338 ebuf,; 17339 ebuf_len,; 17340 ""Can not create mutex"");; 17341#if !defined(NO_SSL) && !defined(USE_MBEDTLS) // TODO: mbedTLS client; 17342 SSL_CTX_free(conn->dom_ctx->ssl_ctx);; 17343#endif; 17344 closesocket(sock);; 17345 mg_free(conn);; 17346 return NULL;; 17347 }; 17348 ; 17349 ; 17350#if !defined(NO_SSL) && !defined(USE_MBEDTLS) // TODO: mbedTLS client; 17351 if (use_ssl) {; 17352 /* TODO: Check ssl_verify_peer and ssl_ca_path here.; 17353 * SSL_CTX_set_verify call is needed to switch off server; 17354 * certificate checking, which is off by default in OpenSSL and; 17355 * on in yaSSL. */; 17356 /* TODO: SSL_CTX_set_verify(conn->dom_ctx,; 17357 * SSL_VERIFY_PEER, verify_ssl_server); */; 17358 ; 17359 if (client_options->client_cert) {; 17360 if (!ssl_use_pem_file(conn->phys_ctx,; 17361 conn->dom_ctx,; 17362 client_options->client_cert,; 17363 NULL)) {; 17364 mg_snprintf(NULL,; 17365 NULL, /* No truncation check for ebuf */; 17366 ebuf,; 17367 ebuf_len,; 17368 ""Can not use SSL client certificate"");; 17369 SSL_CTX_free(conn->dom_ctx->ssl_ctx);; 17370 closesocket(sock);; 17371 mg_free(conn);; 17372 return NULL;; 17373 }; 17374 }; 17375 ; 17376 if (client_options->server_cert) {; 17377 if (SSL_CTX_load_verify_locations(conn->dom_ctx->ssl_ctx,; 17378 client_options->server_cert,; 17379 NULL); 17380 != 1) {; 17381 mg_cry_internal(conn,; 17382 ""SSL_CTX_load_verify_locations error: %s "",; 17383 ssl_error());; 17384 SSL_CTX_free(conn->dom_ctx->ssl_ctx);; 17385 closesocket(sock);; 17386 mg_free(conn",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:516102,Security,certificate,certificate,516102,,MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:525224,Security,authenticat,authentication,525224,"stend = strchr(hostbegin, '/');; 17647 if (!hostend) {; 17648 return 0;; 17649 }; 17650 portbegin = strchr(hostbegin, ':');; 17651 if ((!portbegin) || (portbegin > hostend)) {; 17652 port = abs_uri_protocols[i].default_port;; 17653 request_domain_len = (size_t)(hostend - hostbegin);; 17654 } else {; 17655 port = strtoul(portbegin + 1, &portend, 10);; 17656 if ((portend != hostend) || (port <= 0); 17657 || !is_valid_port(port)) {; 17658 return 0;; 17659 }; 17660 request_domain_len = (size_t)(portbegin - hostbegin);; 17661 }; 17662 /* protocol found, port set */; 17663 break;; 17664 }; 17665 }; 17666 ; 17667 if (!port) {; 17668 /* port remains 0 if the protocol is not found */; 17669 return 0;; 17670 }; 17671 ; 17672 /* Check if the request is directed to a different server. */; 17673 /* First check if the port is the same. */; 17674 if (ntohs(USA_IN_PORT_UNSAFE(&conn->client.lsa)) != port) {; 17675 /* Request is directed to a different port */; 17676 return 0;; 17677 }; 17678 ; 17679 /* Finally check if the server corresponds to the authentication; 17680 * domain of the server (the server domain).; 17681 * Allow full matches (like http://mydomain.com/path/file.ext), and; 17682 * allow subdomain matches (like http://www.mydomain.com/path/file.ext),; 17683 * but do not allow substrings (like; 17684 * http://notmydomain.com/path/file.ext; 17685 * or http://mydomain.com.fake/path/file.ext).; 17686 */; 17687 if (auth_domain_check_enabled) {; 17688 server_domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 17689 server_domain_len = strlen(server_domain);; 17690 if ((server_domain_len == 0) || (hostbegin == NULL)) {; 17691 return 0;; 17692 }; 17693 if ((request_domain_len == server_domain_len); 17694 && (!memcmp(server_domain, hostbegin, server_domain_len))) {; 17695 /* Request is directed to this server - full name match. */; 17696 } else {; 17697 if (request_domain_len < (server_domain_len + 2)) {; 17698 /* Request is directed to another server: The server name; 17699",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:562209,Security,access,access,562209,"re-allocated */; 18880 thread_index = (int)(conn - ctx->worker_connections);; 18881 if ((thread_index < 0); 18882 || ((unsigned)thread_index >= (unsigned)ctx->cfg_worker_threads)) {; 18883 mg_cry_ctx_internal(ctx,; 18884 ""Internal error: Invalid worker index %i"",; 18885 thread_index);; 18886 return;; 18887 }; 18888 ; 18889 /* Request buffers are not pre-allocated. They are private to the; 18890 * request and do not contain any state information that might be; 18891 * of interest to anyone observing a server status. */; 18892 conn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->phys_ctx);; 18893 if (conn->buf == NULL) {; 18894 mg_cry_ctx_internal(; 18895 ctx,; 18896 ""Out of memory: Cannot allocate buffer for worker %i"",; 18897 thread_index);; 18898 return;; 18899 }; 18900 conn->buf_size = (int)ctx->max_request_size;; 18901 ; 18902 conn->dom_ctx = &(ctx->dd); /* Use default domain and default host */; 18903 ; 18904 conn->tls_user_ptr = tls.user_ptr; /* store ptr for quick access */; 18905 ; 18906 conn->request_info.user_data = ctx->user_data;; 18907 /* Allocate a mutex for this connection to allow communication both; 18908 * within the request handler and from elsewhere in the application; 18909 */; 18910 if (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {; 18911 mg_free(conn->buf);; 18912 mg_cry_ctx_internal(ctx, ""%s"", ""Cannot create mutex"");; 18913 return;; 18914 }; 18915 ; 18916#if defined(USE_SERVER_STATS); 18917 conn->conn_state = 1; /* not consumed */; 18918#endif; 18919 ; 18920 /* Call consume_socket() even when ctx->stop_flag > 0, to let it; 18921 * signal sq_empty condvar to wake up the master waiting in; 18922 * produce_socket() */; 18923 while (consume_socket(ctx, &conn->client, thread_index)) {; 18924 ; 18925 /* New connections must start with new protocol negotiation */; 18926 tls.alpn_proto = NULL;; 18927 ; 18928#if defined(USE_SERVER_STATS); 18929 conn->conn_close_time = 0;; 18930#endif; 18931 conn->conn_birth_time = time(NULL);; ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:564793,Security,certificate,certificate,564793," ntohs(USA_IN_PORT_UNSAFE(&conn->client.lsa));; 18942 ; 18943 sockaddr_to_string(conn->request_info.remote_addr,; 18944 sizeof(conn->request_info.remote_addr),; 18945 &conn->client.rsa);; 18946 ; 18947 DEBUG_TRACE(""Incomming %sconnection from %s"",; 18948 (conn->client.is_ssl ? ""SSL "" : """"),; 18949 conn->request_info.remote_addr);; 18950 ; 18951 conn->request_info.is_ssl = conn->client.is_ssl;; 18952 ; 18953 if (conn->client.is_ssl) {; 18954 ; 18955#if defined(USE_MBEDTLS); 18956 /* HTTPS connection */; 18957 if (mbed_ssl_accept(&(conn->ssl),; 18958 conn->dom_ctx->ssl_ctx,; 18959 (int *)&(conn->client.sock),; 18960 conn->phys_ctx); 18961 == 0) {; 18962 /* conn->dom_ctx is set in get_request */; 18963 /* process HTTPS connection */; 18964 init_connection(conn);; 18965 conn->connection_type = CONNECTION_TYPE_REQUEST;; 18966 conn->protocol_type = PROTOCOL_TYPE_HTTP1;; 18967 process_new_connection(conn);; 18968 } else {; 18969 /* make sure the connection is cleaned up on SSL failure */; 18970 close_connection(conn);; 18971 }; 18972 ; 18973#elif !defined(NO_SSL); 18974 /* HTTPS connection */; 18975 if (sslize(conn, SSL_accept, NULL)) {; 18976 /* conn->dom_ctx is set in get_request */; 18977 ; 18978 /* Get SSL client certificate information (if set) */; 18979 struct mg_client_cert client_cert;; 18980 if (ssl_get_client_cert_info(conn, &client_cert)) {; 18981 conn->request_info.client_cert = &client_cert;; 18982 }; 18983 ; 18984 /* process HTTPS connection */; 18985#if defined(USE_HTTP2); 18986 if ((tls.alpn_proto != NULL); 18987 && (!memcmp(tls.alpn_proto, ""\x02h2"", 3))) {; 18988 /* process HTTPS/2 connection */; 18989 init_connection(conn);; 18990 conn->connection_type = CONNECTION_TYPE_REQUEST;; 18991 conn->protocol_type = PROTOCOL_TYPE_HTTP2;; 18992 conn->content_len =; 18993 -1; /* content length is not predefined */; 18994 conn->is_chunked = 0; /* HTTP2 is never chunked */; 18995 process_new_http2_connection(conn);; 18996 } else; 18997#endif; 18998 {; 18999 /* process ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:565888,Security,certificate,certificate,565888,"t */; 18977 ; 18978 /* Get SSL client certificate information (if set) */; 18979 struct mg_client_cert client_cert;; 18980 if (ssl_get_client_cert_info(conn, &client_cert)) {; 18981 conn->request_info.client_cert = &client_cert;; 18982 }; 18983 ; 18984 /* process HTTPS connection */; 18985#if defined(USE_HTTP2); 18986 if ((tls.alpn_proto != NULL); 18987 && (!memcmp(tls.alpn_proto, ""\x02h2"", 3))) {; 18988 /* process HTTPS/2 connection */; 18989 init_connection(conn);; 18990 conn->connection_type = CONNECTION_TYPE_REQUEST;; 18991 conn->protocol_type = PROTOCOL_TYPE_HTTP2;; 18992 conn->content_len =; 18993 -1; /* content length is not predefined */; 18994 conn->is_chunked = 0; /* HTTP2 is never chunked */; 18995 process_new_http2_connection(conn);; 18996 } else; 18997#endif; 18998 {; 18999 /* process HTTPS/1.x or WEBSOCKET-SECURE connection */; 19000 init_connection(conn);; 19001 conn->connection_type = CONNECTION_TYPE_REQUEST;; 19002 /* Start with HTTP, WS will be an ""upgrade"" request later */; 19003 conn->protocol_type = PROTOCOL_TYPE_HTTP1;; 19004 process_new_connection(conn);; 19005 }; 19006 ; 19007 /* Free client certificate info */; 19008 if (conn->request_info.client_cert) {; 19009 mg_free((void *)(conn->request_info.client_cert->subject));; 19010 mg_free((void *)(conn->request_info.client_cert->issuer));; 19011 mg_free((void *)(conn->request_info.client_cert->serial));; 19012 mg_free((void *)(conn->request_info.client_cert->finger));; 19013 /* Free certificate memory */; 19014 X509_free(; 19015 (X509 *)conn->request_info.client_cert->peer_cert);; 19016 conn->request_info.client_cert->peer_cert = 0;; 19017 conn->request_info.client_cert->subject = 0;; 19018 conn->request_info.client_cert->issuer = 0;; 19019 conn->request_info.client_cert->serial = 0;; 19020 conn->request_info.client_cert->finger = 0;; 19021 conn->request_info.client_cert = 0;; 19022 }; 19023 } else {; 19024 /* make sure the connection is cleaned up on SSL failure */; 19025 close_connection(conn)",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:566233,Security,certificate,certificate,566233,"ype = CONNECTION_TYPE_REQUEST;; 18991 conn->protocol_type = PROTOCOL_TYPE_HTTP2;; 18992 conn->content_len =; 18993 -1; /* content length is not predefined */; 18994 conn->is_chunked = 0; /* HTTP2 is never chunked */; 18995 process_new_http2_connection(conn);; 18996 } else; 18997#endif; 18998 {; 18999 /* process HTTPS/1.x or WEBSOCKET-SECURE connection */; 19000 init_connection(conn);; 19001 conn->connection_type = CONNECTION_TYPE_REQUEST;; 19002 /* Start with HTTP, WS will be an ""upgrade"" request later */; 19003 conn->protocol_type = PROTOCOL_TYPE_HTTP1;; 19004 process_new_connection(conn);; 19005 }; 19006 ; 19007 /* Free client certificate info */; 19008 if (conn->request_info.client_cert) {; 19009 mg_free((void *)(conn->request_info.client_cert->subject));; 19010 mg_free((void *)(conn->request_info.client_cert->issuer));; 19011 mg_free((void *)(conn->request_info.client_cert->serial));; 19012 mg_free((void *)(conn->request_info.client_cert->finger));; 19013 /* Free certificate memory */; 19014 X509_free(; 19015 (X509 *)conn->request_info.client_cert->peer_cert);; 19016 conn->request_info.client_cert->peer_cert = 0;; 19017 conn->request_info.client_cert->subject = 0;; 19018 conn->request_info.client_cert->issuer = 0;; 19019 conn->request_info.client_cert->serial = 0;; 19020 conn->request_info.client_cert->finger = 0;; 19021 conn->request_info.client_cert = 0;; 19022 }; 19023 } else {; 19024 /* make sure the connection is cleaned up on SSL failure */; 19025 close_connection(conn);; 19026 }; 19027#endif; 19028 ; 19029 } else {; 19030 /* process HTTP connection */; 19031 init_connection(conn);; 19032 conn->connection_type = CONNECTION_TYPE_REQUEST;; 19033 /* Start with HTTP, WS will be an ""upgrade"" request later */; 19034 conn->protocol_type = PROTOCOL_TYPE_HTTP1;; 19035 process_new_connection(conn);; 19036 }; 19037 ; 19038 DEBUG_TRACE(""%s"", ""Connection closed"");; 19039 ; 19040#if defined(USE_SERVER_STATS); 19041 conn->conn_close_time = time(NULL);; 19042#endif; 19043",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:596654,Security,password,password,596654,"r, opt_vec.len) == 0); 19922 break;; 19923 }; 19924 lua_rawset(state, -3);; 19925 lua_pop(state, 1);; 19926 }; 19927 ; 19928 /* Call script */; 19929 state = mg_lua_context_script_run(state,; 19930 ctx->dd.config[LUA_BACKGROUND_SCRIPT],; 19931 ctx,; 19932 ebuf,; 19933 sizeof(ebuf));; 19934 if (!state) {; 19935 mg_cry_ctx_internal(ctx,; 19936 ""lua_background_script start error: %s"",; 19937 ebuf);; 19938 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19939 mg_snprintf(NULL,; 19940 NULL, /* No truncation check for error buffers */; 19941 error->text,; 19942 error->text_buffer_size,; 19943 ""Error in script %s: %s"",; 19944 config_options[DOCUMENT_ROOT].name,; 19945 ebuf);; 19946 }; 19947 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19948 ; 19949 free_context(ctx);; 19950 pthread_setspecific(sTlsKey, NULL);; 19951 return NULL;; 19952 }; 19953 ; 19954 /* state remains valid */; 19955 ctx->lua_background_state = (void *)state;; 19956 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19957 ; 19958 } else {; 19959 ctx->lua_background_state = 0;; 19960 }; 19961#endif; 19962 ; 19963 /* Step by step initialization of ctx - depending on build options */; 19964#if !defined(NO_FILESYSTEMS); 19965 if (!set_gpass_option(ctx, NULL)) {; 19966 const char *err_msg = ""Invalid global password file"";; 19967 /* Fatal error - abort start. */; 19968 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19969 ; 19970 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19971 mg_snprintf(NULL,; 19972 NULL, /* No truncation check for error buffers */; 19973 error->text,; 19974 error->text_buffer_size,; 19975 ""%s"",; 19976 err_msg);; 19977 }; 19978 free_context(ctx);; 19979 pthread_setspecific(sTlsKey, NULL);; 19980 return NULL;; 19981 }; 19982#endif; 19983 ; 19984#if defined(USE_MBEDTLS); 19985 if (!mg_sslctx_init(ctx, NULL)) {; 19986 const char *err_msg = ""Error initializing SSL context"";; 19987 /* Fatal error - abort start. */; 19988 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19989 ; 19990 if ((error !=",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:599503,Security,access,access,599503,"f (!set_ports_option(ctx)) {; 20024 const char *err_msg = ""Failed to setup server ports"";; 20025 /* Fatal error - abort start. */; 20026 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20027 ; 20028 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20029 mg_snprintf(NULL,; 20030 NULL, /* No truncation check for error buffers */; 20031 error->text,; 20032 error->text_buffer_size,; 20033 ""%s"",; 20034 err_msg);; 20035 }; 20036 free_context(ctx);; 20037 pthread_setspecific(sTlsKey, NULL);; 20038 return NULL;; 20039 }; 20040 ; 20041 ; 20042#if !defined(_WIN32) && !defined(__ZEPHYR__); 20043 if (!set_uid_option(ctx)) {; 20044 const char *err_msg = ""Failed to run as configured user"";; 20045 /* Fatal error - abort start. */; 20046 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20047 ; 20048 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20049 mg_snprintf(NULL,; 20050 NULL, /* No truncation check for error buffers */; 20051 error->text,; 20052 error->text_buffer_size,; 20053 ""%s"",; 20054 err_msg);; 20055 }; 20056 free_context(ctx);; 20057 pthread_setspecific(sTlsKey, NULL);; 20058 return NULL;; 20059 }; 20060#endif; 20061 ; 20062 if (!set_acl_option(ctx)) {; 20063 const char *err_msg = ""Failed to setup access control list"";; 20064 /* Fatal error - abort start. */; 20065 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20066 ; 20067 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20068 mg_snprintf(NULL,; 20069 NULL, /* No truncation check for error buffers */; 20070 error->text,; 20071 error->text_buffer_size,; 20072 ""%s"",; 20073 err_msg);; 20074 }; 20075 free_context(ctx);; 20076 pthread_setspecific(sTlsKey, NULL);; 20077 return NULL;; 20078 }; 20079 ; 20080 ctx->cfg_worker_threads = ((unsigned int)(workerthreadcount));; 20081 ctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20082 sizeof(pthread_t),; 20083 ctx);; 20084 ; 20085 if (ctx->worker_threadids == NULL) {; 20086 const char *err_msg = ""Not enough memory for worker thread ID array"";;",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:609873,Security,authenticat,authentication,609873,"nvalid option: %s"",; 20367 name);; 20368 }; 20369 mg_free(new_dom);; 20370 return -2;; 20371 } else if ((value = *options++) == NULL) {; 20372 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20373 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20374 mg_snprintf(NULL,; 20375 NULL, /* No truncation check for error buffers */; 20376 error->text,; 20377 error->text_buffer_size,; 20378 ""Invalid option value: %s"",; 20379 name);; 20380 }; 20381 mg_free(new_dom);; 20382 return -2;; 20383 }; 20384 if (new_dom->config[idx] != NULL) {; 20385 /* Duplicate option: Later values overwrite earlier ones. */; 20386 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 20387 mg_free(new_dom->config[idx]);; 20388 }; 20389 new_dom->config[idx] = mg_strdup_ctx(value, ctx);; 20390 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 20391 }; 20392 ; 20393 /* Authentication domain is mandatory */; 20394 /* TODO: Maybe use a new option hostname? */; 20395 if (!new_dom->config[AUTHENTICATION_DOMAIN]) {; 20396 mg_cry_ctx_internal(ctx, ""%s"", ""authentication domain required"");; 20397 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20398 mg_snprintf(NULL,; 20399 NULL, /* No truncation check for error buffers */; 20400 error->text,; 20401 error->text_buffer_size,; 20402 ""Mandatory option %s missing"",; 20403 config_options[AUTHENTICATION_DOMAIN].name);; 20404 }; 20405 mg_free(new_dom);; 20406 return -4;; 20407 }; 20408 ; 20409 /* Set default value if needed. Take the config value from; 20410 * ctx as a default value. */; 20411 for (i = 0; config_options[i].name != NULL; i++) {; 20412 default_value = ctx->dd.config[i];; 20413 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20414 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20415 }; 20416 }; 20417 ; 20418 new_dom->handlers = NULL;; 20419 new_dom->next = NULL;; 20420 new_dom->nonce_count = 0;; 20421 new_dom->auth_nonce_mask =; 20422 (uint64_t)get_random() ^ ((uint64_t)get_random() <<",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:675100,Security,authoriz,authorizestatic,675100,"(struct mg_connection *conn, const char *fmt, va_list ap)Definition civetweb.c:6918; mg_realloc_ctx#define mg_realloc_ctx(a, b, c)Definition civetweb.c:1496; send_additional_headerstatic void send_additional_header(struct mg_connection *conn)Definition civetweb.c:4117; push_allstatic int push_all(struct mg_context *ctx, FILE *fp, SOCKET sock, SSL *ssl, const char *buf, int len)Definition civetweb.c:6136; is_put_or_delete_methodstatic int is_put_or_delete_method(const struct mg_connection *conn)Definition civetweb.c:7305; read_messagestatic int read_message(FILE *fp, struct mg_connection *conn, char *buf, int bufsiz, int *nread)Definition civetweb.c:10798; print_dir_entrystatic int print_dir_entry(struct de *de)Definition civetweb.c:9289; MG_FOPEN_MODE_WRITE#define MG_FOPEN_MODE_WRITEDefinition civetweb.c:2810; mg_get_user_connection_datavoid * mg_get_user_connection_data(const struct mg_connection *conn)Definition civetweb.c:3202; authorizestatic int authorize(struct mg_connection *conn, struct mg_file *filep, const char *realm)Definition civetweb.c:8615; send_ssi_filestatic void send_ssi_file(struct mg_connection *, const char *, struct mg_file *, int)Definition civetweb.c:11984; mg_static_assert#define mg_static_assert(cond, txt)Definition civetweb.c:124; SOCKET_TIMEOUT_QUANTUM#define SOCKET_TIMEOUT_QUANTUMDefinition civetweb.c:471; produce_socketstatic void produce_socket(struct mg_context *ctx, const struct socket *sp)Definition civetweb.c:18809; match_prefixstatic ptrdiff_t match_prefix(const char *pattern, size_t pattern_len, const char *str)Definition civetweb.c:3921; mg_send_chunkint mg_send_chunk(struct mg_connection *conn, const char *chunk, unsigned int chunk_len)Definition civetweb.c:6776; remove_dot_segmentsstatic void remove_dot_segments(char *inout)Definition civetweb.c:7872; get_request_handlerstatic int get_request_handler(struct mg_connection *conn, int handler_type, mg_request_handler *handler, struct mg_websocket_subprotocols **subprotocols, mg_we",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:675120,Security,authoriz,authorize,675120,"(struct mg_connection *conn, const char *fmt, va_list ap)Definition civetweb.c:6918; mg_realloc_ctx#define mg_realloc_ctx(a, b, c)Definition civetweb.c:1496; send_additional_headerstatic void send_additional_header(struct mg_connection *conn)Definition civetweb.c:4117; push_allstatic int push_all(struct mg_context *ctx, FILE *fp, SOCKET sock, SSL *ssl, const char *buf, int len)Definition civetweb.c:6136; is_put_or_delete_methodstatic int is_put_or_delete_method(const struct mg_connection *conn)Definition civetweb.c:7305; read_messagestatic int read_message(FILE *fp, struct mg_connection *conn, char *buf, int bufsiz, int *nread)Definition civetweb.c:10798; print_dir_entrystatic int print_dir_entry(struct de *de)Definition civetweb.c:9289; MG_FOPEN_MODE_WRITE#define MG_FOPEN_MODE_WRITEDefinition civetweb.c:2810; mg_get_user_connection_datavoid * mg_get_user_connection_data(const struct mg_connection *conn)Definition civetweb.c:3202; authorizestatic int authorize(struct mg_connection *conn, struct mg_file *filep, const char *realm)Definition civetweb.c:8615; send_ssi_filestatic void send_ssi_file(struct mg_connection *, const char *, struct mg_file *, int)Definition civetweb.c:11984; mg_static_assert#define mg_static_assert(cond, txt)Definition civetweb.c:124; SOCKET_TIMEOUT_QUANTUM#define SOCKET_TIMEOUT_QUANTUMDefinition civetweb.c:471; produce_socketstatic void produce_socket(struct mg_context *ctx, const struct socket *sp)Definition civetweb.c:18809; match_prefixstatic ptrdiff_t match_prefix(const char *pattern, size_t pattern_len, const char *str)Definition civetweb.c:3921; mg_send_chunkint mg_send_chunk(struct mg_connection *conn, const char *chunk, unsigned int chunk_len)Definition civetweb.c:6776; remove_dot_segmentsstatic void remove_dot_segments(char *inout)Definition civetweb.c:7872; get_request_handlerstatic int get_request_handler(struct mg_connection *conn, int handler_type, mg_request_handler *handler, struct mg_websocket_subprotocols **subprotocols, mg_we",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:708730,Security,access,accessstruct,708730,; mg_domain_context::ssl_ctxSSL_CTX * ssl_ctxDefinition civetweb.c:2252; mg_domain_context::handlersstruct mg_handler_info * handlersDefinition civetweb.c:2254; mg_error_dataDefinition civetweb.h:1671; mg_error_data::codeunsigned * codeDefinition civetweb.h:1672; mg_error_data::text_buffer_sizesize_t text_buffer_sizeDefinition civetweb.h:1674; mg_error_data::textchar * textDefinition civetweb.h:1673; mg_file_accessDefinition civetweb.c:1871; mg_file_access::fpFILE * fpDefinition civetweb.c:1873; mg_file_statDefinition civetweb.c:1860; mg_file_stat::sizeuint64_t sizeDefinition civetweb.c:1862; mg_file_stat::locationint locationDefinition civetweb.c:1867; mg_file_stat::is_directoryint is_directoryDefinition civetweb.c:1864; mg_file_stat::last_modifiedtime_t last_modifiedDefinition civetweb.c:1863; mg_file_stat::is_gzippedint is_gzippedDefinition civetweb.c:1865; mg_fileDefinition civetweb.c:1876; mg_file::statstruct mg_file_stat statDefinition civetweb.c:1877; mg_file::accessstruct mg_file_access accessDefinition civetweb.c:1878; mg_handler_infoDefinition civetweb.c:2210; mg_handler_info::handlermg_request_handler handlerDefinition civetweb.c:2219; mg_handler_info::uri_lensize_t uri_lenDefinition civetweb.c:2213; mg_handler_info::auth_handlermg_authorization_handler auth_handlerDefinition civetweb.c:2233; mg_handler_info::close_handlermg_websocket_close_handler close_handlerDefinition civetweb.c:2227; mg_handler_info::nextstruct mg_handler_info * nextDefinition civetweb.c:2239; mg_handler_info::urichar * uriDefinition civetweb.c:2212; mg_handler_info::refcountunsigned int refcountDefinition civetweb.c:2220; mg_handler_info::connect_handlermg_websocket_connect_handler connect_handlerDefinition civetweb.c:2224; mg_handler_info::cbdatavoid * cbdataDefinition civetweb.c:2236; mg_handler_info::subprotocolsstruct mg_websocket_subprotocols * subprotocolsDefinition civetweb.c:2230; mg_handler_info::handler_typeint handler_typeDefinition civetweb.c:2216; mg_handler_info::removi,MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:708758,Security,access,accessDefinition,708758,; mg_domain_context::ssl_ctxSSL_CTX * ssl_ctxDefinition civetweb.c:2252; mg_domain_context::handlersstruct mg_handler_info * handlersDefinition civetweb.c:2254; mg_error_dataDefinition civetweb.h:1671; mg_error_data::codeunsigned * codeDefinition civetweb.h:1672; mg_error_data::text_buffer_sizesize_t text_buffer_sizeDefinition civetweb.h:1674; mg_error_data::textchar * textDefinition civetweb.h:1673; mg_file_accessDefinition civetweb.c:1871; mg_file_access::fpFILE * fpDefinition civetweb.c:1873; mg_file_statDefinition civetweb.c:1860; mg_file_stat::sizeuint64_t sizeDefinition civetweb.c:1862; mg_file_stat::locationint locationDefinition civetweb.c:1867; mg_file_stat::is_directoryint is_directoryDefinition civetweb.c:1864; mg_file_stat::last_modifiedtime_t last_modifiedDefinition civetweb.c:1863; mg_file_stat::is_gzippedint is_gzippedDefinition civetweb.c:1865; mg_fileDefinition civetweb.c:1876; mg_file::statstruct mg_file_stat statDefinition civetweb.c:1877; mg_file::accessstruct mg_file_access accessDefinition civetweb.c:1878; mg_handler_infoDefinition civetweb.c:2210; mg_handler_info::handlermg_request_handler handlerDefinition civetweb.c:2219; mg_handler_info::uri_lensize_t uri_lenDefinition civetweb.c:2213; mg_handler_info::auth_handlermg_authorization_handler auth_handlerDefinition civetweb.c:2233; mg_handler_info::close_handlermg_websocket_close_handler close_handlerDefinition civetweb.c:2227; mg_handler_info::nextstruct mg_handler_info * nextDefinition civetweb.c:2239; mg_handler_info::urichar * uriDefinition civetweb.c:2212; mg_handler_info::refcountunsigned int refcountDefinition civetweb.c:2220; mg_handler_info::connect_handlermg_websocket_connect_handler connect_handlerDefinition civetweb.c:2224; mg_handler_info::cbdatavoid * cbdataDefinition civetweb.c:2236; mg_handler_info::subprotocolsstruct mg_websocket_subprotocols * subprotocolsDefinition civetweb.c:2230; mg_handler_info::handler_typeint handler_typeDefinition civetweb.c:2216; mg_handler_info::removi,MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:6576,Testability,log,log,6576,"lementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping between URLs and local; 161 * file names.; 162 * NO_FILESYSTEM = do not access any file at all. Useful for embedded; 163 * devices without file system. Logging to files in not available; 164 * (use callbacks instead) and API functions like mg_send_file are not; 165 * available.; 166 * If NO_FILESYSTEM is set, NO_FILES must be set as well.; 167 */; 168#error ""Inconsistent build flags, NO_FILESYSTEMS requires NO_FILES""; 169#endif; 170 ; 171/* DTL -- including winsock2.h works better if lean and mean */; 172#if !defined(WIN32_LEAN_AND_MEAN); 173#define WIN32_LEAN_AND_MEAN; 174#endif; 175 ; 176#if defined(__SYMBIAN32__); 177/* According to https://en.wikipedia.org/wiki/Symbian#History,; 178 * Symbian is no longer maintained since 2014-01-01.; 179 * Support for Symbian has been removed from CivetWeb; 180 */; 181#error ""S",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:58079,Testability,test,tested,58079,"ed; /* Set to 1 if the content is gzipped, in which; 1866 * case we need a ""Content-Eencoding: gzip"" header */; 1867 int location; /* 0 = nowhere, 1 = on disk, 2 = in memory */; 1868};; 1869 ; 1870 ; 1871struct mg_file_access {; 1872 /* File properties filled by mg_fopen: */; 1873 FILE *fp;; 1874};; 1875 ; 1876struct mg_file {; 1877 struct mg_file_stat stat;; 1878 struct mg_file_access access;; 1879};; 1880 ; 1881 ; 1882#define STRUCT_FILE_INITIALIZER \; 1883 { \; 1884 {(uint64_t)0, (time_t)0, 0, 0, 0}, \; 1885 { \; 1886 (FILE *)NULL \; 1887 } \; 1888 }; 1889 ; 1890 ; 1891/* Describes listening socket, or socket which was accept()-ed by the master; 1892 * thread and queued for future handling by the worker thread. */; 1893struct socket {; 1894 SOCKET sock; /* Listening socket */; 1895 union usa lsa; /* Local socket address */; 1896 union usa rsa; /* Remote socket address */; 1897 unsigned char is_ssl; /* Is port SSL-ed */; 1898 unsigned char ssl_redir; /* Is port supposed to redirect everything to SSL; 1899 * port */; 1900 unsigned char in_use; /* 0: invalid, 1: valid, 2: free */; 1901};; 1902 ; 1903 ; 1904/* Enum const for all options must be in sync with; 1905 * static struct mg_option config_options[]; 1906 * This is tested in the unit test (test/private.c); 1907 * ""Private Config Options""; 1908 */; 1909enum {; 1910 /* Once for each server */; 1911 LISTENING_PORTS,; 1912 NUM_THREADS,; 1913 RUN_AS_USER,; 1914 CONFIG_TCP_NODELAY, /* Prepended CONFIG_ to avoid conflict with the; 1915 * socket option typedef TCP_NODELAY. */; 1916 MAX_REQUEST_SIZE,; 1917 LINGER_TIMEOUT,; 1918 CONNECTION_QUEUE_SIZE,; 1919 LISTEN_BACKLOG_SIZE,; 1920#if defined(__linux__); 1921 ALLOW_SENDFILE_CALL,; 1922#endif; 1923#if defined(_WIN32); 1924 CASE_SENSITIVE_FILES,; 1925#endif; 1926 THROTTLE,; 1927 ENABLE_KEEP_ALIVE,; 1928 REQUEST_TIMEOUT,; 1929 KEEP_ALIVE_TIMEOUT,; 1930#if defined(USE_WEBSOCKET); 1931 WEBSOCKET_TIMEOUT,; 1932 ENABLE_WEBSOCKET_PING_PONG,; 1933#endif; 1934 DECODE_URL,; 1935 D",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:58098,Testability,test,test,58098,"ed; /* Set to 1 if the content is gzipped, in which; 1866 * case we need a ""Content-Eencoding: gzip"" header */; 1867 int location; /* 0 = nowhere, 1 = on disk, 2 = in memory */; 1868};; 1869 ; 1870 ; 1871struct mg_file_access {; 1872 /* File properties filled by mg_fopen: */; 1873 FILE *fp;; 1874};; 1875 ; 1876struct mg_file {; 1877 struct mg_file_stat stat;; 1878 struct mg_file_access access;; 1879};; 1880 ; 1881 ; 1882#define STRUCT_FILE_INITIALIZER \; 1883 { \; 1884 {(uint64_t)0, (time_t)0, 0, 0, 0}, \; 1885 { \; 1886 (FILE *)NULL \; 1887 } \; 1888 }; 1889 ; 1890 ; 1891/* Describes listening socket, or socket which was accept()-ed by the master; 1892 * thread and queued for future handling by the worker thread. */; 1893struct socket {; 1894 SOCKET sock; /* Listening socket */; 1895 union usa lsa; /* Local socket address */; 1896 union usa rsa; /* Remote socket address */; 1897 unsigned char is_ssl; /* Is port SSL-ed */; 1898 unsigned char ssl_redir; /* Is port supposed to redirect everything to SSL; 1899 * port */; 1900 unsigned char in_use; /* 0: invalid, 1: valid, 2: free */; 1901};; 1902 ; 1903 ; 1904/* Enum const for all options must be in sync with; 1905 * static struct mg_option config_options[]; 1906 * This is tested in the unit test (test/private.c); 1907 * ""Private Config Options""; 1908 */; 1909enum {; 1910 /* Once for each server */; 1911 LISTENING_PORTS,; 1912 NUM_THREADS,; 1913 RUN_AS_USER,; 1914 CONFIG_TCP_NODELAY, /* Prepended CONFIG_ to avoid conflict with the; 1915 * socket option typedef TCP_NODELAY. */; 1916 MAX_REQUEST_SIZE,; 1917 LINGER_TIMEOUT,; 1918 CONNECTION_QUEUE_SIZE,; 1919 LISTEN_BACKLOG_SIZE,; 1920#if defined(__linux__); 1921 ALLOW_SENDFILE_CALL,; 1922#endif; 1923#if defined(_WIN32); 1924 CASE_SENSITIVE_FILES,; 1925#endif; 1926 THROTTLE,; 1927 ENABLE_KEEP_ALIVE,; 1928 REQUEST_TIMEOUT,; 1929 KEEP_ALIVE_TIMEOUT,; 1930#if defined(USE_WEBSOCKET); 1931 WEBSOCKET_TIMEOUT,; 1932 ENABLE_WEBSOCKET_PING_PONG,; 1933#endif; 1934 DECODE_URL,; 1935 D",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:58104,Testability,test,test,58104,"ed; /* Set to 1 if the content is gzipped, in which; 1866 * case we need a ""Content-Eencoding: gzip"" header */; 1867 int location; /* 0 = nowhere, 1 = on disk, 2 = in memory */; 1868};; 1869 ; 1870 ; 1871struct mg_file_access {; 1872 /* File properties filled by mg_fopen: */; 1873 FILE *fp;; 1874};; 1875 ; 1876struct mg_file {; 1877 struct mg_file_stat stat;; 1878 struct mg_file_access access;; 1879};; 1880 ; 1881 ; 1882#define STRUCT_FILE_INITIALIZER \; 1883 { \; 1884 {(uint64_t)0, (time_t)0, 0, 0, 0}, \; 1885 { \; 1886 (FILE *)NULL \; 1887 } \; 1888 }; 1889 ; 1890 ; 1891/* Describes listening socket, or socket which was accept()-ed by the master; 1892 * thread and queued for future handling by the worker thread. */; 1893struct socket {; 1894 SOCKET sock; /* Listening socket */; 1895 union usa lsa; /* Local socket address */; 1896 union usa rsa; /* Remote socket address */; 1897 unsigned char is_ssl; /* Is port SSL-ed */; 1898 unsigned char ssl_redir; /* Is port supposed to redirect everything to SSL; 1899 * port */; 1900 unsigned char in_use; /* 0: invalid, 1: valid, 2: free */; 1901};; 1902 ; 1903 ; 1904/* Enum const for all options must be in sync with; 1905 * static struct mg_option config_options[]; 1906 * This is tested in the unit test (test/private.c); 1907 * ""Private Config Options""; 1908 */; 1909enum {; 1910 /* Once for each server */; 1911 LISTENING_PORTS,; 1912 NUM_THREADS,; 1913 RUN_AS_USER,; 1914 CONFIG_TCP_NODELAY, /* Prepended CONFIG_ to avoid conflict with the; 1915 * socket option typedef TCP_NODELAY. */; 1916 MAX_REQUEST_SIZE,; 1917 LINGER_TIMEOUT,; 1918 CONNECTION_QUEUE_SIZE,; 1919 LISTEN_BACKLOG_SIZE,; 1920#if defined(__linux__); 1921 ALLOW_SENDFILE_CALL,; 1922#endif; 1923#if defined(_WIN32); 1924 CASE_SENSITIVE_FILES,; 1925#endif; 1926 THROTTLE,; 1927 ENABLE_KEEP_ALIVE,; 1928 REQUEST_TIMEOUT,; 1929 KEEP_ALIVE_TIMEOUT,; 1930#if defined(USE_WEBSOCKET); 1931 WEBSOCKET_TIMEOUT,; 1932 ENABLE_WEBSOCKET_PING_PONG,; 1933#endif; 1934 DECODE_URL,; 1935 D",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:74221,Testability,log,log,74221,"60 int sq_size; /* No of elements in socket queue */; 2361#if defined(USE_SERVER_STATS); 2362 int sq_max_fill;; 2363#endif /* USE_SERVER_STATS */; 2364#endif /* ALTERNATIVE_QUEUE */; 2365 ; 2366 /* Memory related */; 2367 unsigned int max_request_size; /* The max request size */; 2368 ; 2369#if defined(USE_SERVER_STATS); 2370 struct mg_memory_stat ctx_memory;; 2371#endif; 2372 ; 2373 /* Operating system related */; 2374 char *systemName; /* What operating system is running */; 2375 time_t start_time; /* Server start time, used for authentication; 2376 * and for diagnstics. */; 2377 ; 2378#if defined(USE_TIMERS); 2379 struct ttimers *timers;; 2380#endif; 2381 ; 2382 /* Lua specific: Background operations and shared websockets */; 2383#if defined(USE_LUA); 2384 void *lua_background_state; /* lua_State (here as void *) */; 2385 pthread_mutex_t lua_bg_mutex; /* Protect background state */; 2386 int lua_bg_log_available; /* Use Lua background state for access log */; 2387#endif; 2388 ; 2389 /* Server nonce */; 2390 pthread_mutex_t nonce_mutex; /* Protects ssl_ctx, handlers,; 2391 * ssl_cert_last_mtime, nonce_count, and; 2392 * next (linked list) */; 2393 ; 2394 /* Server callbacks */; 2395 struct mg_callbacks callbacks; /* User-defined callback function */; 2396 void *user_data; /* User-defined data */; 2397 ; 2398 /* Part 2 - Logical domain:; 2399 * This holds hostname, TLS certificate, document root, ...; 2400 * set for a domain hosted at the server.; 2401 * There may be multiple domains hosted at one physical server.; 2402 * The default domain ""dd"" is the first element of a list of; 2403 * domains.; 2404 */; 2405 struct mg_domain_context dd; /* default domain */; 2406};; 2407 ; 2408 ; 2409#if defined(USE_SERVER_STATS); 2410static struct mg_memory_stat mg_common_memory = {0, 0, 0};; 2411 ; 2412static struct mg_memory_stat *; 2413get_memory_stat(struct mg_context *ctx); 2414{; 2415 if (ctx) {; 2416 return &(ctx->ctx_memory);; 2417 }; 2418 return &mg_common_memory;; 2419}",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:99691,Testability,log,log,99691,"ULL);; 3312 if (tm != NULL) {; 3313#else; 3314 struct tm _tm;; 3315 struct tm *tm = &_tm;; 3316 ; 3317 if (t != NULL) {; 3318 gmtime_r(t, tm);; 3319#endif; 3320 strftime(buf, buf_len, ""%a, %d %b %Y %H:%M:%S GMT"", tm);; 3321 } else {; 3322 mg_strlcpy(buf, ""Thu, 01 Jan 1970 00:00:00 GMT"", buf_len);; 3323 buf[buf_len - 1] = '\0';; 3324 }; 3325}; 3326 ; 3327 ; 3328/* difftime for struct timespec. Return value is in seconds. */; 3329static double; 3330mg_difftimespec(const struct timespec *ts_now, const struct timespec *ts_before); 3331{; 3332 return (double)(ts_now->tv_nsec - ts_before->tv_nsec) * 1.0E-9; 3333 + (double)(ts_now->tv_sec - ts_before->tv_sec);; 3334}; 3335 ; 3336 ; 3337#if defined(MG_EXTERNAL_FUNCTION_mg_cry_internal_impl); 3338static void mg_cry_internal_impl(const struct mg_connection *conn,; 3339 const char *func,; 3340 unsigned line,; 3341 const char *fmt,; 3342 va_list ap);; 3343#include ""external_mg_cry_internal_impl.inl""; 3344#elif !defined(NO_FILESYSTEMS); 3345 ; 3346/* Print error message to the opened error log stream. */; 3347static void; 3348mg_cry_internal_impl(const struct mg_connection *conn,; 3349 const char *func,; 3350 unsigned line,; 3351 const char *fmt,; 3352 va_list ap); 3353{; 3354 char buf[MG_BUF_LEN], src_addr[IP_ADDR_STR_LEN];; 3355 struct mg_file fi;; 3356 time_t timestamp;; 3357 ; 3358 /* Unused, in the RELEASE build */; 3359 (void)func;; 3360 (void)line;; 3361 ; 3362#if defined(GCC_DIAGNOSTIC); 3363#pragma GCC diagnostic push; 3364#pragma GCC diagnostic ignored ""-Wformat-nonliteral""; 3365#endif; 3366 ; 3367 IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));; 3368 ; 3369#if defined(GCC_DIAGNOSTIC); 3370#pragma GCC diagnostic pop; 3371#endif; 3372 ; 3373 buf[sizeof(buf) - 1] = 0;; 3374 ; 3375 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3376 ; 3377 if (!conn) {; 3378 puts(buf);; 3379 return;; 3380 }; 3381 ; 3382 /* Do not lock when getting the callback value, here and below.; 3383 * I suppose this i",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:102168,Testability,log,logging,102168,"s.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endif /* Externally provided function */; 3431 ; 3432 ; 3433/* Construct fake connection structure. Used for logging, if connection; 3434 * is not applicable at the moment of logging. */; 3435static struct mg_connection *; 3436fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3437{; 3438 static const struct mg_connection conn_zero = {0};; 3439 *fc = conn_zero;; 3440 fc->phys_ctx = ctx;; 3441 fc->dom_ctx = &(ctx->dd);; 3442 return fc;; 3443}; 3444 ; 3445 ; 3446static void; 3447mg_cry_internal_wrap(const struct mg_connection *conn,; 3448 struct mg_context *ctx,; 3449 const char *func,; 3450 unsigned line,; 3451 const char *fmt,; 3452 ...); 3453{; 3454 va_list ap;; 3455 va_start(ap, fmt);; 3456 if (!conn && ctx) {; 3457 struct mg_connection fc;; 3458 mg_cry_internal_impl(fake_connection(&fc, ctx), func, line, fmt, ap);; 3459 } else {; 3460 mg_cry_internal_impl(conn, func, line, fmt, ap);; 3461 }; 3462 va_end(ap);; 3463}; 3464 ; 3465 ; 3466void; 3467mg_cry(const struct mg_connection *conn, const char *fmt, ...); 3468{; 3469 va_list ap;; 3470 va_start(ap, fmt);; 3471 mg_cry_internal_impl(conn, ""user"", 0, fmt, ap",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:102234,Testability,log,logging,102234,"s.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endif /* Externally provided function */; 3431 ; 3432 ; 3433/* Construct fake connection structure. Used for logging, if connection; 3434 * is not applicable at the moment of logging. */; 3435static struct mg_connection *; 3436fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3437{; 3438 static const struct mg_connection conn_zero = {0};; 3439 *fc = conn_zero;; 3440 fc->phys_ctx = ctx;; 3441 fc->dom_ctx = &(ctx->dd);; 3442 return fc;; 3443}; 3444 ; 3445 ; 3446static void; 3447mg_cry_internal_wrap(const struct mg_connection *conn,; 3448 struct mg_context *ctx,; 3449 const char *func,; 3450 unsigned line,; 3451 const char *fmt,; 3452 ...); 3453{; 3454 va_list ap;; 3455 va_start(ap, fmt);; 3456 if (!conn && ctx) {; 3457 struct mg_connection fc;; 3458 mg_cry_internal_impl(fake_connection(&fc, ctx), func, line, fmt, ap);; 3459 } else {; 3460 mg_cry_internal_impl(conn, func, line, fmt, ap);; 3461 }; 3462 va_end(ap);; 3463}; 3464 ; 3465 ; 3466void; 3467mg_cry(const struct mg_connection *conn, const char *fmt, ...); 3468{; 3469 va_list ap;; 3470 va_start(ap, fmt);; 3471 mg_cry_internal_impl(conn, ""user"", 0, fmt, ap",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:130505,Testability,log,log,130505,"ode: %u"",; 4318 response_code);; 4319 }; 4320 ; 4321 /* Return at least a category according to RFC 2616 Section 10. */; 4322 if (response_code >= 100 && response_code < 200) {; 4323 /* Unknown informational status code */; 4324 return ""Information"";; 4325 }; 4326 if (response_code >= 200 && response_code < 300) {; 4327 /* Unknown success code */; 4328 return ""Success"";; 4329 }; 4330 if (response_code >= 300 && response_code < 400) {; 4331 /* Unknown redirection code */; 4332 return ""Redirection"";; 4333 }; 4334 if (response_code >= 400 && response_code < 500) {; 4335 /* Unknown request error code */; 4336 return ""Client Error"";; 4337 }; 4338 if (response_code >= 500 && response_code < 600) {; 4339 /* Unknown server error code */; 4340 return ""Server Error"";; 4341 }; 4342 ; 4343 /* Response code not even within reasonable range */; 4344 return """";; 4345 }; 4346}; 4347 ; 4348 ; 4349static int; 4350mg_send_http_error_impl(struct mg_connection *conn,; 4351 int status,; 4352 const char *fmt,; 4353 va_list args); 4354{; 4355 char errmsg_buf[MG_BUF_LEN];; 4356 va_list ap;; 4357 int has_body;; 4358 ; 4359#if !defined(NO_FILESYSTEMS); 4360 char path_buf[UTF8_PATH_MAX];; 4361 int len, i, page_handler_found, scope, truncated;; 4362 const char *error_handler = NULL;; 4363 struct mg_file error_page_file = STRUCT_FILE_INITIALIZER;; 4364 const char *error_page_file_ext, *tstr;; 4365#endif /* NO_FILESYSTEMS */; 4366 int handled_by_callback = 0;; 4367 ; 4368 if ((conn == NULL) || (fmt == NULL)) {; 4369 return -2;; 4370 }; 4371 ; 4372 /* Set status (for log) */; 4373 conn->status_code = status;; 4374 ; 4375 /* Errors 1xx, 204 and 304 MUST NOT send a body */; 4376 has_body = ((status > 199) && (status != 204) && (status != 304));; 4377 ; 4378 /* Prepare message in buf, if required */; 4379 if (has_body; 4380 || (!conn->in_error_handler; 4381 && (conn->phys_ctx->callbacks.http_error != NULL))) {; 4382 /* Store error message in errmsg_buf */; 4383 va_copy(ap, args);; 4384 mg_vsnprintf(co",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:170063,Testability,log,log,170063,"e the child-side immediately. */; 5759 set_close_on_exec(fdin[1], conn, NULL); /* stdin write */; 5760 set_close_on_exec(fdout[0], conn, NULL); /* stdout read */; 5761 set_close_on_exec(fderr[0], conn, NULL); /* stderr read */; 5762 } else {; 5763 /* Child */; 5764 if (chdir(dir) != 0) {; 5765 mg_cry_internal(; 5766 conn, ""%s: chdir(%s): %s"", __func__, dir, strerror(ERRNO));; 5767 } else if (dup2(fdin[0], 0) == -1) {; 5768 mg_cry_internal(conn,; 5769 ""%s: dup2(%d, 0): %s"",; 5770 __func__,; 5771 fdin[0],; 5772 strerror(ERRNO));; 5773 } else if (dup2(fdout[1], 1) == -1) {; 5774 mg_cry_internal(conn,; 5775 ""%s: dup2(%d, 1): %s"",; 5776 __func__,; 5777 fdout[1],; 5778 strerror(ERRNO));; 5779 } else if (dup2(fderr[1], 2) == -1) {; 5780 mg_cry_internal(conn,; 5781 ""%s: dup2(%d, 2): %s"",; 5782 __func__,; 5783 fderr[1],; 5784 strerror(ERRNO));; 5785 } else {; 5786 struct sigaction sa;; 5787 ; 5788 /* Keep stderr and stdout in two different pipes.; 5789 * Stdout will be sent back to the client,; 5790 * stderr should go into a server error log. */; 5791 (void)close(fdin[0]);; 5792 (void)close(fdout[1]);; 5793 (void)close(fderr[1]);; 5794 ; 5795 /* Close write end fdin and read end fdout and fderr */; 5796 (void)close(fdin[1]);; 5797 (void)close(fdout[0]);; 5798 (void)close(fderr[0]);; 5799 ; 5800 /* After exec, all signal handlers are restored to their default; 5801 * values, with one exception of SIGCHLD. According to; 5802 * POSIX.1-2001 and Linux's implementation, SIGCHLD's handler; 5803 * will leave unchanged after exec if it was set to be ignored.; 5804 * Restore it to default action. */; 5805 memset(&sa, 0, sizeof(sa));; 5806 sa.sa_handler = SIG_DFL;; 5807 sigaction(SIGCHLD, &sa, NULL);; 5808 ; 5809 interp = conn->dom_ctx->config[CGI_INTERPRETER + cgi_config_idx];; 5810 if (interp == NULL) {; 5811 /* no interpreter configured, call the programm directly */; 5812 (void)execle(prog, prog, NULL, envp);; 5813 mg_cry_internal(conn,; 5814 ""%s: execle(%s): %s"",; 5815 __func__,;",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:190282,Testability,log,log,190282,"ed_len = len64;; 6506 }; 6507 body = conn->buf + conn->request_len + conn->consumed_content;; 6508 memcpy(buf, body, (size_t)buffered_len);; 6509 len64 -= buffered_len;; 6510 conn->consumed_content += buffered_len;; 6511 nread += buffered_len;; 6512 buf = (char *)buf + buffered_len;; 6513 }; 6514 ; 6515 /* We have returned all buffered data. Read new data from the remote; 6516 * socket.; 6517 */; 6518 if ((n = pull_all(NULL, conn, (char *)buf, (int)len64)) >= 0) {; 6519 conn->consumed_content += n;; 6520 nread += n;; 6521 } else {; 6522 nread = ((nread > 0) ? nread : n);; 6523 }; 6524 }; 6525 return (int)nread;; 6526}; 6527 ; 6528 ; 6529/* Forward declarations */; 6530static void handle_request(struct mg_connection *);; 6531static void log_access(const struct mg_connection *);; 6532 ; 6533 ; 6534/* Handle request, update statistics and call access log */; 6535static void; 6536handle_request_stat_log(struct mg_connection *conn); 6537{; 6538#if defined(USE_SERVER_STATS); 6539 struct timespec tnow;; 6540 conn->conn_state = 4; /* processing */; 6541#endif; 6542 ; 6543 handle_request(conn);; 6544 ; 6545 ; 6546#if defined(USE_SERVER_STATS); 6547 conn->conn_state = 5; /* processed */; 6548 ; 6549 clock_gettime(CLOCK_MONOTONIC, &tnow);; 6550 conn->processing_time = mg_difftimespec(&tnow, &(conn->req_time));; 6551 ; 6552 mg_atomic_add64(&(conn->phys_ctx->total_data_read), conn->consumed_content);; 6553 mg_atomic_add64(&(conn->phys_ctx->total_data_written),; 6554 conn->num_bytes_sent);; 6555#endif; 6556 ; 6557 DEBUG_TRACE(""%s"", ""handle_request done"");; 6558 ; 6559 if (conn->phys_ctx->callbacks.end_request != NULL) {; 6560 conn->phys_ctx->callbacks.end_request(conn, conn->status_code);; 6561 DEBUG_TRACE(""%s"", ""end_request callback done"");; 6562 }; 6563 log_access(conn);; 6564}; 6565 ; 6566 ; 6567#if defined(USE_HTTP2); 6568#if defined(NO_SSL); 6569#error ""HTTP2 requires ALPN, APLN requires SSL/TLS""; 6570#endif; 6571#define USE_ALPN; 6572#include ""mod_http2.inl""; 6573/* Not sup",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:239323,Testability,test,test,239323,",; 8258 nc,; 8259 "":"",; 8260 cnonce,; 8261 "":"",; 8262 qop,; 8263 "":"",; 8264 ha2,; 8265 NULL);; 8266 ; 8267 return mg_strcasecmp(response, expected_response) == 0;; 8268}; 8269 ; 8270 ; 8271#if !defined(NO_FILESYSTEMS); 8272/* Use the global passwords file, if specified by auth_gpass option,; 8273 * or search for .htpasswd in the requested directory. */; 8274static void; 8275open_auth_file(struct mg_connection *conn,; 8276 const char *path,; 8277 struct mg_file *filep); 8278{; 8279 if ((conn != NULL) && (conn->dom_ctx != NULL)) {; 8280 char name[UTF8_PATH_MAX];; 8281 const char *p, *e,; 8282 *gpass = conn->dom_ctx->config[GLOBAL_PASSWORDS_FILE];; 8283 int truncated;; 8284 ; 8285 if (gpass != NULL) {; 8286 /* Use global passwords file */; 8287 if (!mg_fopen(conn, gpass, MG_FOPEN_MODE_READ, filep)) {; 8288#if defined(DEBUG); 8289 /* Use mg_cry_internal here, since gpass has been; 8290 * configured. */; 8291 mg_cry_internal(conn, ""fopen(%s): %s"", gpass, strerror(ERRNO));; 8292#endif; 8293 }; 8294 /* Important: using local struct mg_file to test path for; 8295 * is_directory flag. If filep is used, mg_stat() makes it; 8296 * appear as if auth file was opened.; 8297 * TODO(mid): Check if this is still required after rewriting; 8298 * mg_stat */; 8299 } else if (mg_stat(conn, path, &filep->stat); 8300 && filep->stat.is_directory) {; 8301 mg_snprintf(conn,; 8302 &truncated,; 8303 name,; 8304 sizeof(name),; 8305 ""%s/%s"",; 8306 path,; 8307 PASSWORDS_FILE_NAME);; 8308 ; 8309 if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {; 8310#if defined(DEBUG); 8311 /* Don't use mg_cry_internal here, but only a trace, since; 8312 * this is a typical case. It will occur for every directory; 8313 * without a password file. */; 8314 DEBUG_TRACE(""fopen(%s): %s"", name, strerror(ERRNO));; 8315#endif; 8316 }; 8317 } else {; 8318 /* Try to find .htpasswd in requested directory. */; 8319 for (p = path, e = p + strlen(p) - 1; e > p; e--) {; 8320 if (e[0] == '/') {; 8321 break;; 83",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:243654,Testability,log,login,243654,"->qop = value;; 8411 } else if (!strcmp(name, ""nc"")) {; 8412 ah->nc = value;; 8413 } else if (!strcmp(name, ""nonce"")) {; 8414 ah->nonce = value;; 8415 }; 8416 }; 8417 ; 8418#if !defined(NO_NONCE_CHECK); 8419 /* Read the nonce from the response. */; 8420 if (ah->nonce == NULL) {; 8421 return 0;; 8422 }; 8423 s = NULL;; 8424 nonce = strtoull(ah->nonce, &s, 10);; 8425 if ((s == NULL) || (*s != 0)) {; 8426 return 0;; 8427 }; 8428 ; 8429 /* Convert the nonce from the client to a number. */; 8430 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8431 ; 8432 /* The converted number corresponds to the time the nounce has been; 8433 * created. This should not be earlier than the server start. */; 8434 /* Server side nonce check is valuable in all situations but one:; 8435 * if the server restarts frequently, but the client should not see; 8436 * that, so the server should accept nonces from previous starts. */; 8437 /* However, the reasonable default is to not accept a nonce from a; 8438 * previous start, so if anyone changed the access rights between; 8439 * two restarts, a new login is required. */; 8440 if (nonce < (uint64_t)conn->phys_ctx->start_time) {; 8441 /* nonce is from a previous start of the server and no longer valid; 8442 * (replay attack?) */; 8443 return 0;; 8444 }; 8445 /* Check if the nonce is too high, so it has not (yet) been used by the; 8446 * server. */; 8447 if (nonce >= ((uint64_t)conn->phys_ctx->start_time; 8448 + conn->dom_ctx->nonce_count)) {; 8449 return 0;; 8450 }; 8451#else; 8452 (void)nonce;; 8453#endif; 8454 ; 8455 /* CGI needs it as REMOTE_USER */; 8456 if (ah->user != NULL) {; 8457 conn->request_info.remote_user =; 8458 mg_strdup_ctx(ah->user, conn->phys_ctx);; 8459 } else {; 8460 return 0;; 8461 }; 8462 ; 8463 return 1;; 8464}; 8465 ; 8466 ; 8467static const char *; 8468mg_fgets(char *buf, size_t size, struct mg_file *filep); 8469{; 8470 if (!filep) {; 8471 return NULL;; 8472 }; 8473 ; 8474 if (filep->access.fp != NULL) {; 8475 return fgets(buf, (",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:332163,Testability,log,log,332163,"o not send anything back to client, until we buffer in all; 11446 * HTTP headers. */; 11447 data_len = 0;; 11448 buf = (char *)mg_malloc_ctx(buflen, conn->phys_ctx);; 11449 if (buf == NULL) {; 11450 mg_send_http_error(conn,; 11451 500,; 11452 ""Error: Not enough memory for CGI buffer (%u bytes)"",; 11453 (unsigned int)buflen);; 11454 mg_cry_internal(; 11455 conn,; 11456 ""Error: CGI program \""%s\"": Not enough memory for buffer (%u ""; 11457 ""bytes)"",; 11458 prog,; 11459 (unsigned int)buflen);; 11460 goto done;; 11461 }; 11462 ; 11463 DEBUG_TRACE(""CGI: %s"", ""wait for response"");; 11464 headers_len = read_message(out, conn, buf, (int)buflen, &data_len);; 11465 DEBUG_TRACE(""CGI: response: %li"", (signed long)headers_len);; 11466 ; 11467 if (headers_len <= 0) {; 11468 ; 11469 /* Could not parse the CGI response. Check if some error message on; 11470 * stderr. */; 11471 i = pull_all(err, conn, buf, (int)buflen);; 11472 if (i > 0) {; 11473 /* CGI program explicitly sent an error */; 11474 /* Write the error message to the internal log */; 11475 mg_cry_internal(conn,; 11476 ""Error: CGI program \""%s\"" sent error ""; 11477 ""message: [%.*s]"",; 11478 prog,; 11479 i,; 11480 buf);; 11481 /* Don't send the error message back to the client */; 11482 mg_send_http_error(conn,; 11483 500,; 11484 ""Error: CGI program \""%s\"" failed."",; 11485 prog);; 11486 } else {; 11487 /* CGI program did not explicitly send an error, but a broken; 11488 * respon header */; 11489 mg_cry_internal(conn,; 11490 ""Error: CGI program sent malformed or too big ""; 11491 ""(>%u bytes) HTTP headers: [%.*s]"",; 11492 (unsigned)buflen,; 11493 data_len,; 11494 buf);; 11495 ; 11496 mg_send_http_error(conn,; 11497 500,; 11498 ""Error: CGI program sent malformed or too big ""; 11499 ""(>%u bytes) HTTP headers: [%.*s]"",; 11500 (unsigned)buflen,; 11501 data_len,; 11502 buf);; 11503 }; 11504 ; 11505 /* in both cases, abort processing CGI */; 11506 goto done;; 11507 }; 11508 ; 11509 pbuf = buf;; 11510 buf[headers_len - 1] = '\0';; 11",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:336308,Testability,test,test,336308,"[1]);; 11580 }; 11581 ; 11582 if (out != NULL) {; 11583 fclose(out);; 11584 } else if (fdout[0] != -1) {; 11585 close(fdout[0]);; 11586 }; 11587 ; 11588 if (err != NULL) {; 11589 fclose(err);; 11590 } else if (fderr[0] != -1) {; 11591 close(fderr[0]);; 11592 }; 11593 ; 11594 mg_free(buf);; 11595}; 11596#endif /* !NO_CGI */; 11597 ; 11598 ; 11599#if !defined(NO_FILES); 11600static void; 11601mkcol(struct mg_connection *conn, const char *path); 11602{; 11603 int rc, body_len;; 11604 struct de de;; 11605 ; 11606 if (conn == NULL) {; 11607 return;; 11608 }; 11609 ; 11610 /* TODO (mid): Check the mg_send_http_error situations in this function; 11611 */; 11612 ; 11613 memset(&de.file, 0, sizeof(de.file));; 11614 if (!mg_stat(conn, path, &de.file)) {; 11615 mg_cry_internal(conn,; 11616 ""%s: mg_stat(%s) failed: %s"",; 11617 __func__,; 11618 path,; 11619 strerror(ERRNO));; 11620 }; 11621 ; 11622 if (de.file.last_modified) {; 11623 /* TODO (mid): This check does not seem to make any sense ! */; 11624 /* TODO (mid): Add a webdav unit test first, before changing; 11625 * anything here. */; 11626 mg_send_http_error(; 11627 conn, 405, ""Error: mkcol(%s): %s"", path, strerror(ERRNO));; 11628 return;; 11629 }; 11630 ; 11631 body_len = conn->data_len - conn->request_len;; 11632 if (body_len > 0) {; 11633 mg_send_http_error(; 11634 conn, 415, ""Error: mkcol(%s): %s"", path, strerror(ERRNO));; 11635 return;; 11636 }; 11637 ; 11638 rc = mg_mkdir(conn, path, 0755);; 11639 ; 11640 if (rc == 0) {; 11641 ; 11642 /* Create 201 ""Created"" response */; 11643 mg_response_header_start(conn, 201);; 11644 send_static_cache_header(conn);; 11645 send_additional_header(conn);; 11646 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11647 ; 11648 /* Send all headers - there is no body */; 11649 mg_response_header_send(conn);; 11650 ; 11651 } else {; 11652 if (errno == EEXIST) {; 11653 mg_send_http_error(; 11654 conn, 405, ""Error: mkcol(%s): %s"", path, strerror(ERRNO));; 11655 } else if (errno == EA",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:352064,Testability,test,test,352064,"; 12134 fclose_on_exec(&filep->access, conn);; 12135 ; 12136 /* 200 OK response */; 12137 mg_response_header_start(conn, 200);; 12138 send_no_cache_header(conn);; 12139 send_additional_header(conn);; 12140 mg_response_header_add(conn, ""Content-Type"", ""text/html"", -1);; 12141 if (cors1[0]) {; 12142 mg_response_header_add(conn, cors1, cors2, -1);; 12143 }; 12144 if (cors3[0]) {; 12145 mg_response_header_add(conn, cors3, cors4, -1);; 12146 }; 12147 mg_response_header_send(conn);; 12148 ; 12149 /* Header sent, now send body */; 12150 send_ssi_file(conn, path, filep, 0);; 12151 (void)mg_fclose(&filep->access); /* Ignore errors for readonly files */; 12152 }; 12153}; 12154#endif /* NO_FILESYSTEMS */; 12155 ; 12156 ; 12157#if !defined(NO_FILES); 12158static void; 12159send_options(struct mg_connection *conn); 12160{; 12161 if (!conn) {; 12162 return;; 12163 }; 12164 ; 12165 /* We do not set a ""Cache-Control"" header here, but leave the default.; 12166 * Since browsers do not send an OPTIONS request, we can not test the; 12167 * effect anyway. */; 12168 ; 12169 mg_response_header_start(conn, 200);; 12170 mg_response_header_add(conn, ""Content-Type"", ""text/html"", -1);; 12171 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 12172 /* Use the same as before */; 12173 mg_response_header_add(; 12174 conn,; 12175 ""Allow"",; 12176 ""GET, POST, HEAD, CONNECT, PUT, DELETE, OPTIONS, PROPFIND, MKCOL"",; 12177 -1);; 12178 mg_response_header_add(conn, ""DAV"", ""1"", -1);; 12179 } else {; 12180 /* TODO: Check this later for HTTP/2 */; 12181 mg_response_header_add(conn, ""Allow"", ""GET, POST"", -1);; 12182 }; 12183 send_additional_header(conn);; 12184 mg_response_header_send(conn);; 12185}; 12186 ; 12187 ; 12188/* Writes PROPFIND properties for a collection element */; 12189static int; 12190print_props(struct mg_connection *conn,; 12191 const char *uri,; 12192 const char *name,; 12193 struct mg_file_stat *filep); 12194{; 12195 size_t href_size, i, j;; 12196 int len;; 12197 char *href, mtime[64];; 1",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:409840,Testability,log,logic,409840,"data_wrapper(struct mg_connection *conn,; 13966 int bits,; 13967 char *data,; 13968 size_t len,; 13969 void *cbdata); 13970{; 13971 struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;; 13972 if (pcallbacks->websocket_data) {; 13973 return pcallbacks->websocket_data(conn, bits, data, len);; 13974 }; 13975 /* No handler set - assume ""OK"" */; 13976 return 1;; 13977}; 13978 ; 13979 ; 13980static void; 13981experimental_websocket_client_close_wrapper(const struct mg_connection *conn,; 13982 void *cbdata); 13983{; 13984 struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;; 13985 if (pcallbacks->connection_close) {; 13986 pcallbacks->connection_close(conn);; 13987 }; 13988}; 13989#endif; 13990 ; 13991 ; 13992/* Decrement recount of handler. conn must not be NULL, handler_info may be NULL; 13993 */; 13994static void; 13995release_handler_ref(struct mg_connection *conn,; 13996 struct mg_handler_info *handler_info); 13997{; 13998 if (handler_info != NULL) {; 13999 /* Use context lock for ref counter */; 14000 mg_lock_context(conn->phys_ctx);; 14001 handler_info->refcount--;; 14002 mg_unlock_context(conn->phys_ctx);; 14003 }; 14004}; 14005 ; 14006 ; 14007/* This is the heart of the Civetweb's logic.; 14008 * This function is called when the request is read, parsed and validated,; 14009 * and Civetweb must decide what action to take: serve a file, or; 14010 * a directory, or call embedded function, etcetera. */; 14011static void; 14012handle_request(struct mg_connection *conn); 14013{; 14014 struct mg_request_info *ri = &conn->request_info;; 14015 char path[UTF8_PATH_MAX];; 14016 int uri_len, ssl_index;; 14017 int is_found = 0, is_script_resource = 0, is_websocket_request = 0,; 14018 is_put_or_delete_request = 0, is_callback_resource = 0,; 14019 is_template_text_file = 0;; 14020 int i;; 14021 struct mg_file file = STRUCT_FILE_INITIALIZER;; 14022 mg_request_handler callback_handler = NULL;; 14023 struct mg_handler_info *handler_info = NULL;; 14024 struct",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:414254,Testability,log,log,414254," = mg_strdup(ri->local_uri_raw);; 14091 if (!tmp) {; 14092 /* Out of memory. We cannot do anything reasonable here. */; 14093 return;; 14094 }; 14095 remove_dot_segments(tmp);; 14096 ri->local_uri = tmp;; 14097 ; 14098 /* step 1. completed, the url is known now */; 14099 DEBUG_TRACE(""URL: %s"", ri->local_uri);; 14100 ; 14101 /* 2. if this ip has limited speed, set it for this connection */; 14102 conn->throttle = set_throttle(conn->dom_ctx->config[THROTTLE],; 14103 &conn->client.rsa,; 14104 ri->local_uri);; 14105 ; 14106 /* 3. call a ""handle everything"" callback, if registered */; 14107 if (conn->phys_ctx->callbacks.begin_request != NULL) {; 14108 /* Note that since V1.7 the ""begin_request"" function is called; 14109 * before an authorization check. If an authorization check is; 14110 * required, use a request_handler instead. */; 14111 i = conn->phys_ctx->callbacks.begin_request(conn);; 14112 if (i > 0) {; 14113 /* callback already processed the request. Store the; 14114 return value as a status code for the access log. */; 14115 conn->status_code = i;; 14116 if (!conn->must_close) {; 14117 discard_unread_request_data(conn);; 14118 }; 14119 return;; 14120 } else if (i == 0) {; 14121 /* civetweb should process the request */; 14122 } else {; 14123 /* unspecified - may change with the next version */; 14124 return;; 14125 }; 14126 }; 14127 ; 14128 /* request not yet handled by a handler or redirect, so the request; 14129 * is processed here */; 14130 ; 14131 /* 4. Check for CORS preflight requests and handle them (if configured).; 14132 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS; 14133 */; 14134 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14135 /* Send a response to CORS preflights only if; 14136 * access_control_allow_methods is not NULL and not an empty string.; 14137 * In this case, scripts can still handle CORS. */; 14138 const char *cors_meth_cfg =; 14139 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_METHODS];; 14140 const char *cors_or",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:417660,Testability,test,test,417660,"conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_HEADERS];; 14180 ; 14181 if ((cors_hdr_cfg != NULL) && (*cors_hdr_cfg != 0)) {; 14182 /* Allow only if access_control_allow_headers is; 14183 * not NULL and not an empty string. If this; 14184 * configuration is set to *, allow everything.; 14185 * Otherwise this configuration must be a list; 14186 * of allowed HTTP header names. */; 14187 mg_printf(conn,; 14188 ""Access-Control-Allow-Headers: %s\r\n"",; 14189 ((cors_hdr_cfg[0] == '*') ? cors_acrh; 14190 : cors_hdr_cfg));; 14191 }; 14192 }; 14193 if (cors_cred_cfg && *cors_cred_cfg) {; 14194 mg_printf(conn,; 14195 ""Access-Control-Allow-Credentials: %s\r\n"",; 14196 cors_cred_cfg);; 14197 }; 14198 ; 14199 mg_printf(conn, ""Access-Control-Max-Age: 60\r\n"");; 14200 ; 14201 mg_printf(conn, ""\r\n"");; 14202 return;; 14203 }; 14204 }; 14205 ; 14206 /* 5. interpret the url to find out how the request must be handled; 14207 */; 14208 /* 5.1. first test, if the request targets the regular http(s)://; 14209 * protocol namespace or the websocket ws(s):// protocol namespace.; 14210 */; 14211 is_websocket_request = (conn->protocol_type == PROTOCOL_TYPE_WEBSOCKET);; 14212#if defined(USE_WEBSOCKET); 14213 handler_type = is_websocket_request ? WEBSOCKET_HANDLER : REQUEST_HANDLER;; 14214#else; 14215 handler_type = REQUEST_HANDLER;; 14216#endif /* defined(USE_WEBSOCKET) */; 14217 ; 14218 if (is_websocket_request) {; 14219 HTTP1_only;; 14220 }; 14221 ; 14222 /* 5.2. check if the request will be handled by a callback */; 14223 if (get_request_handler(conn,; 14224 handler_type,; 14225 &callback_handler,; 14226 &subprotocols,; 14227 &ws_connect_handler,; 14228 &ws_ready_handler,; 14229 &ws_data_handler,; 14230 &ws_close_handler,; 14231 NULL,; 14232 &callback_data,; 14233 &handler_info)) {; 14234 /* 5.2.1. A callback will handle this request. All requests; 14235 * handled by a callback have to be considered as requests; 14236 * to a script resource. */; 14237 is_callback_resource = 1;; 14238 is_script",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:421831,Testability,log,log,421831," 6.3. This is either a OPTIONS, GET, HEAD or POST request,; 14312 * or it is a PUT or DELETE request to a resource that does not; 14313 * correspond to a file. Check authorization. */; 14314 if (!check_authorization(conn, path)) {; 14315 send_authorization_request(conn, NULL);; 14316 ; 14317 /* Callback handler will not be used anymore. Release it */; 14318 release_handler_ref(conn, handler_info);; 14319 ; 14320 return;; 14321 }; 14322 }; 14323 ; 14324 /* request is authorized or does not need authorization */; 14325 ; 14326 /* 7. check if there are request handlers for this uri */; 14327 if (is_callback_resource) {; 14328 HTTP1_only;; 14329 if (!is_websocket_request) {; 14330 i = callback_handler(conn, callback_data);; 14331 ; 14332 /* Callback handler will not be used anymore. Release it */; 14333 release_handler_ref(conn, handler_info);; 14334 ; 14335 if (i > 0) {; 14336 /* Do nothing, callback has served the request. Store; 14337 * then return value as status code for the log and discard; 14338 * all data from the client not used by the callback. */; 14339 conn->status_code = i;; 14340 if (!conn->must_close) {; 14341 discard_unread_request_data(conn);; 14342 }; 14343 } else {; 14344 /* The handler did NOT handle the request. */; 14345 /* Some proper reactions would be:; 14346 * a) close the connections without sending anything; 14347 * b) send a 404 not found; 14348 * c) try if there is a file matching the URI; 14349 * It would be possible to do a, b or c in the callback; 14350 * implementation, and return 1 - we cannot do anything; 14351 * here, that is not possible in the callback.; 14352 *; 14353 * TODO: What would be the best reaction here?; 14354 * (Note: The reaction may change, if there is a better; 14355 * idea.); 14356 */; 14357 ; 14358 /* For the moment, use option c: We look for a proper file,; 14359 * but since a file request is not always a script resource,; 14360 * the authorization check might be different. */; 14361 interpret_uri(conn,; 14362 pat",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:434412,Testability,test,tested,434412,"h));; 14696 }; 14697#endif; 14698 ctx->listening_sockets[i].sock = INVALID_SOCKET;; 14699 }; 14700 mg_free(ctx->listening_sockets);; 14701 ctx->listening_sockets = NULL;; 14702 mg_free(ctx->listening_socket_fds);; 14703 ctx->listening_socket_fds = NULL;; 14704}; 14705 ; 14706 ; 14707/* Valid listening port specification is: [ip_address:]port[s]; 14708 * Examples for IPv4: 80, 443s, 127.0.0.1:3128, 192.0.2.3:8080s; 14709 * Examples for IPv6: [::]:80, [::1]:80,; 14710 * [2001:0db8:7654:3210:FEDC:BA98:7654:3210]:443s; 14711 * see https://tools.ietf.org/html/rfc3513#section-2.2; 14712 * In order to bind to both, IPv4 and IPv6, you can either add; 14713 * both ports using 8080,[::]:8080, or the short form +8080.; 14714 * Both forms differ in detail: 8080,[::]:8080 create two sockets,; 14715 * one only accepting IPv4 the other only IPv6. +8080 creates; 14716 * one socket accepting IPv4 and IPv6. Depending on the IPv6; 14717 * environment, they might work differently, or might not work; 14718 * at all - it must be tested what options work best in the; 14719 * relevant network environment.; 14720 */; 14721static int; 14722parse_port_string(const struct vec *vec, struct socket *so, int *ip_version); 14723{; 14724 unsigned int a, b, c, d;; 14725 unsigned port;; 14726 unsigned long portUL;; 14727 int ch, len;; 14728 const char *cb;; 14729 char *endptr;; 14730#if defined(USE_IPV6); 14731 char buf[100] = {0};; 14732#endif; 14733 ; 14734 /* MacOS needs that. If we do not zero it, subsequent bind() will fail.; 14735 * Also, all-zeroes in the socket address means binding to all addresses; 14736 * for both IPv4 and IPv6 (INADDR_ANY and IN6ADDR_ANY_INIT). */; 14737 memset(so, 0, sizeof(*so));; 14738 so->lsa.sin.sin_family = AF_INET;; 14739 *ip_version = 0;; 14740 ; 14741 /* Initialize len as invalid. */; 14742 port = 0;; 14743 len = 0;; 14744 ; 14745 /* Test for different ways to format this string */; 14746 if (sscanf(vec->ptr,; 14747 ""%u.%u.%u.%u:%u%n"",; 14748 &a,; 14749 &b,; 14750",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:452101,Testability,log,log,452101,,MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:452430,Testability,log,log,452430,,MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:452477,Testability,log,log,452477,,MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:452807,Testability,log,log,452807,"; 15287 struct mg_file fi;; 15288 char date[64], src_addr[IP_ADDR_STR_LEN];; 15289 struct tm *tm;; 15290 ; 15291 const char *referer;; 15292 const char *user_agent;; 15293 ; 15294 char log_buf[4096];; 15295 ; 15296 if (!conn || !conn->dom_ctx) {; 15297 return;; 15298 }; 15299 ; 15300 /* Set log message to ""empty"" */; 15301 log_buf[0] = 0;; 15302 ; 15303#if defined(USE_LUA); 15304 if (conn->phys_ctx->lua_bg_log_available) {; 15305 int ret;; 15306 struct mg_context *ctx = conn->phys_ctx;; 15307 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 15308 pthread_mutex_lock(&ctx->lua_bg_mutex);; 15309 /* call ""log()"" in Lua */; 15310 lua_getglobal(lstate, ""log"");; 15311 prepare_lua_request_info_inner(conn, lstate);; 15312 push_lua_response_log_data(conn, lstate);; 15313 ; 15314 ret = lua_pcall(lstate, /* args */ 2, /* results */ 1, 0);; 15315 if (ret == 0) {; 15316 int t = lua_type(lstate, -1);; 15317 if (t == LUA_TBOOLEAN) {; 15318 if (lua_toboolean(lstate, -1) == 0) {; 15319 /* log() returned false: do not log */; 15320 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15321 return;; 15322 }; 15323 /* log returned true: continue logging */; 15324 } else if (t == LUA_TSTRING) {; 15325 size_t len;; 15326 const char *txt = lua_tolstring(lstate, -1, &len);; 15327 if ((len == 0) || (*txt == 0)) {; 15328 /* log() returned empty string: do not log */; 15329 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15330 return;; 15331 }; 15332 /* Copy test from Lua into log_buf */; 15333 if (len >= sizeof(log_buf)) {; 15334 len = sizeof(log_buf) - 1;; 15335 }; 15336 memcpy(log_buf, txt, len);; 15337 log_buf[len] = 0;; 15338 }; 15339 } else {; 15340 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15341 }; 15342 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15343 }; 15344#endif; 15345 ; 15346 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15347 if (mg_fopen(conn,; 15348 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15349 MG_FOPEN_MODE_APPEND,; 15350 &fi); 15351 == 0) {; 15352 fi",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:452836,Testability,log,log,452836,"; 15287 struct mg_file fi;; 15288 char date[64], src_addr[IP_ADDR_STR_LEN];; 15289 struct tm *tm;; 15290 ; 15291 const char *referer;; 15292 const char *user_agent;; 15293 ; 15294 char log_buf[4096];; 15295 ; 15296 if (!conn || !conn->dom_ctx) {; 15297 return;; 15298 }; 15299 ; 15300 /* Set log message to ""empty"" */; 15301 log_buf[0] = 0;; 15302 ; 15303#if defined(USE_LUA); 15304 if (conn->phys_ctx->lua_bg_log_available) {; 15305 int ret;; 15306 struct mg_context *ctx = conn->phys_ctx;; 15307 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 15308 pthread_mutex_lock(&ctx->lua_bg_mutex);; 15309 /* call ""log()"" in Lua */; 15310 lua_getglobal(lstate, ""log"");; 15311 prepare_lua_request_info_inner(conn, lstate);; 15312 push_lua_response_log_data(conn, lstate);; 15313 ; 15314 ret = lua_pcall(lstate, /* args */ 2, /* results */ 1, 0);; 15315 if (ret == 0) {; 15316 int t = lua_type(lstate, -1);; 15317 if (t == LUA_TBOOLEAN) {; 15318 if (lua_toboolean(lstate, -1) == 0) {; 15319 /* log() returned false: do not log */; 15320 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15321 return;; 15322 }; 15323 /* log returned true: continue logging */; 15324 } else if (t == LUA_TSTRING) {; 15325 size_t len;; 15326 const char *txt = lua_tolstring(lstate, -1, &len);; 15327 if ((len == 0) || (*txt == 0)) {; 15328 /* log() returned empty string: do not log */; 15329 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15330 return;; 15331 }; 15332 /* Copy test from Lua into log_buf */; 15333 if (len >= sizeof(log_buf)) {; 15334 len = sizeof(log_buf) - 1;; 15335 }; 15336 memcpy(log_buf, txt, len);; 15337 log_buf[len] = 0;; 15338 }; 15339 } else {; 15340 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15341 }; 15342 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15343 }; 15344#endif; 15345 ; 15346 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15347 if (mg_fopen(conn,; 15348 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15349 MG_FOPEN_MODE_APPEND,; 15350 &fi); 15351 == 0) {; 15352 fi.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:452926,Testability,log,log,452926,"; 15287 struct mg_file fi;; 15288 char date[64], src_addr[IP_ADDR_STR_LEN];; 15289 struct tm *tm;; 15290 ; 15291 const char *referer;; 15292 const char *user_agent;; 15293 ; 15294 char log_buf[4096];; 15295 ; 15296 if (!conn || !conn->dom_ctx) {; 15297 return;; 15298 }; 15299 ; 15300 /* Set log message to ""empty"" */; 15301 log_buf[0] = 0;; 15302 ; 15303#if defined(USE_LUA); 15304 if (conn->phys_ctx->lua_bg_log_available) {; 15305 int ret;; 15306 struct mg_context *ctx = conn->phys_ctx;; 15307 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 15308 pthread_mutex_lock(&ctx->lua_bg_mutex);; 15309 /* call ""log()"" in Lua */; 15310 lua_getglobal(lstate, ""log"");; 15311 prepare_lua_request_info_inner(conn, lstate);; 15312 push_lua_response_log_data(conn, lstate);; 15313 ; 15314 ret = lua_pcall(lstate, /* args */ 2, /* results */ 1, 0);; 15315 if (ret == 0) {; 15316 int t = lua_type(lstate, -1);; 15317 if (t == LUA_TBOOLEAN) {; 15318 if (lua_toboolean(lstate, -1) == 0) {; 15319 /* log() returned false: do not log */; 15320 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15321 return;; 15322 }; 15323 /* log returned true: continue logging */; 15324 } else if (t == LUA_TSTRING) {; 15325 size_t len;; 15326 const char *txt = lua_tolstring(lstate, -1, &len);; 15327 if ((len == 0) || (*txt == 0)) {; 15328 /* log() returned empty string: do not log */; 15329 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15330 return;; 15331 }; 15332 /* Copy test from Lua into log_buf */; 15333 if (len >= sizeof(log_buf)) {; 15334 len = sizeof(log_buf) - 1;; 15335 }; 15336 memcpy(log_buf, txt, len);; 15337 log_buf[len] = 0;; 15338 }; 15339 } else {; 15340 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15341 }; 15342 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15343 }; 15344#endif; 15345 ; 15346 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15347 if (mg_fopen(conn,; 15348 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15349 MG_FOPEN_MODE_APPEND,; 15350 &fi); 15351 == 0) {; 15352 fi.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:452954,Testability,log,logging,452954,"; 15287 struct mg_file fi;; 15288 char date[64], src_addr[IP_ADDR_STR_LEN];; 15289 struct tm *tm;; 15290 ; 15291 const char *referer;; 15292 const char *user_agent;; 15293 ; 15294 char log_buf[4096];; 15295 ; 15296 if (!conn || !conn->dom_ctx) {; 15297 return;; 15298 }; 15299 ; 15300 /* Set log message to ""empty"" */; 15301 log_buf[0] = 0;; 15302 ; 15303#if defined(USE_LUA); 15304 if (conn->phys_ctx->lua_bg_log_available) {; 15305 int ret;; 15306 struct mg_context *ctx = conn->phys_ctx;; 15307 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 15308 pthread_mutex_lock(&ctx->lua_bg_mutex);; 15309 /* call ""log()"" in Lua */; 15310 lua_getglobal(lstate, ""log"");; 15311 prepare_lua_request_info_inner(conn, lstate);; 15312 push_lua_response_log_data(conn, lstate);; 15313 ; 15314 ret = lua_pcall(lstate, /* args */ 2, /* results */ 1, 0);; 15315 if (ret == 0) {; 15316 int t = lua_type(lstate, -1);; 15317 if (t == LUA_TBOOLEAN) {; 15318 if (lua_toboolean(lstate, -1) == 0) {; 15319 /* log() returned false: do not log */; 15320 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15321 return;; 15322 }; 15323 /* log returned true: continue logging */; 15324 } else if (t == LUA_TSTRING) {; 15325 size_t len;; 15326 const char *txt = lua_tolstring(lstate, -1, &len);; 15327 if ((len == 0) || (*txt == 0)) {; 15328 /* log() returned empty string: do not log */; 15329 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15330 return;; 15331 }; 15332 /* Copy test from Lua into log_buf */; 15333 if (len >= sizeof(log_buf)) {; 15334 len = sizeof(log_buf) - 1;; 15335 }; 15336 memcpy(log_buf, txt, len);; 15337 log_buf[len] = 0;; 15338 }; 15339 } else {; 15340 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15341 }; 15342 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15343 }; 15344#endif; 15345 ; 15346 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15347 if (mg_fopen(conn,; 15348 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15349 MG_FOPEN_MODE_APPEND,; 15350 &fi); 15351 == 0) {; 15352 fi.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:453130,Testability,log,log,453130,"; 15287 struct mg_file fi;; 15288 char date[64], src_addr[IP_ADDR_STR_LEN];; 15289 struct tm *tm;; 15290 ; 15291 const char *referer;; 15292 const char *user_agent;; 15293 ; 15294 char log_buf[4096];; 15295 ; 15296 if (!conn || !conn->dom_ctx) {; 15297 return;; 15298 }; 15299 ; 15300 /* Set log message to ""empty"" */; 15301 log_buf[0] = 0;; 15302 ; 15303#if defined(USE_LUA); 15304 if (conn->phys_ctx->lua_bg_log_available) {; 15305 int ret;; 15306 struct mg_context *ctx = conn->phys_ctx;; 15307 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 15308 pthread_mutex_lock(&ctx->lua_bg_mutex);; 15309 /* call ""log()"" in Lua */; 15310 lua_getglobal(lstate, ""log"");; 15311 prepare_lua_request_info_inner(conn, lstate);; 15312 push_lua_response_log_data(conn, lstate);; 15313 ; 15314 ret = lua_pcall(lstate, /* args */ 2, /* results */ 1, 0);; 15315 if (ret == 0) {; 15316 int t = lua_type(lstate, -1);; 15317 if (t == LUA_TBOOLEAN) {; 15318 if (lua_toboolean(lstate, -1) == 0) {; 15319 /* log() returned false: do not log */; 15320 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15321 return;; 15322 }; 15323 /* log returned true: continue logging */; 15324 } else if (t == LUA_TSTRING) {; 15325 size_t len;; 15326 const char *txt = lua_tolstring(lstate, -1, &len);; 15327 if ((len == 0) || (*txt == 0)) {; 15328 /* log() returned empty string: do not log */; 15329 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15330 return;; 15331 }; 15332 /* Copy test from Lua into log_buf */; 15333 if (len >= sizeof(log_buf)) {; 15334 len = sizeof(log_buf) - 1;; 15335 }; 15336 memcpy(log_buf, txt, len);; 15337 log_buf[len] = 0;; 15338 }; 15339 } else {; 15340 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15341 }; 15342 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15343 }; 15344#endif; 15345 ; 15346 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15347 if (mg_fopen(conn,; 15348 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15349 MG_FOPEN_MODE_APPEND,; 15350 &fi); 15351 == 0) {; 15352 fi.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:453166,Testability,log,log,453166,"; 15287 struct mg_file fi;; 15288 char date[64], src_addr[IP_ADDR_STR_LEN];; 15289 struct tm *tm;; 15290 ; 15291 const char *referer;; 15292 const char *user_agent;; 15293 ; 15294 char log_buf[4096];; 15295 ; 15296 if (!conn || !conn->dom_ctx) {; 15297 return;; 15298 }; 15299 ; 15300 /* Set log message to ""empty"" */; 15301 log_buf[0] = 0;; 15302 ; 15303#if defined(USE_LUA); 15304 if (conn->phys_ctx->lua_bg_log_available) {; 15305 int ret;; 15306 struct mg_context *ctx = conn->phys_ctx;; 15307 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 15308 pthread_mutex_lock(&ctx->lua_bg_mutex);; 15309 /* call ""log()"" in Lua */; 15310 lua_getglobal(lstate, ""log"");; 15311 prepare_lua_request_info_inner(conn, lstate);; 15312 push_lua_response_log_data(conn, lstate);; 15313 ; 15314 ret = lua_pcall(lstate, /* args */ 2, /* results */ 1, 0);; 15315 if (ret == 0) {; 15316 int t = lua_type(lstate, -1);; 15317 if (t == LUA_TBOOLEAN) {; 15318 if (lua_toboolean(lstate, -1) == 0) {; 15319 /* log() returned false: do not log */; 15320 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15321 return;; 15322 }; 15323 /* log returned true: continue logging */; 15324 } else if (t == LUA_TSTRING) {; 15325 size_t len;; 15326 const char *txt = lua_tolstring(lstate, -1, &len);; 15327 if ((len == 0) || (*txt == 0)) {; 15328 /* log() returned empty string: do not log */; 15329 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15330 return;; 15331 }; 15332 /* Copy test from Lua into log_buf */; 15333 if (len >= sizeof(log_buf)) {; 15334 len = sizeof(log_buf) - 1;; 15335 }; 15336 memcpy(log_buf, txt, len);; 15337 log_buf[len] = 0;; 15338 }; 15339 } else {; 15340 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15341 }; 15342 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15343 }; 15344#endif; 15345 ; 15346 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15347 if (mg_fopen(conn,; 15348 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15349 MG_FOPEN_MODE_APPEND,; 15350 &fi); 15351 == 0) {; 15352 fi.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:453261,Testability,test,test,453261,"; 15287 struct mg_file fi;; 15288 char date[64], src_addr[IP_ADDR_STR_LEN];; 15289 struct tm *tm;; 15290 ; 15291 const char *referer;; 15292 const char *user_agent;; 15293 ; 15294 char log_buf[4096];; 15295 ; 15296 if (!conn || !conn->dom_ctx) {; 15297 return;; 15298 }; 15299 ; 15300 /* Set log message to ""empty"" */; 15301 log_buf[0] = 0;; 15302 ; 15303#if defined(USE_LUA); 15304 if (conn->phys_ctx->lua_bg_log_available) {; 15305 int ret;; 15306 struct mg_context *ctx = conn->phys_ctx;; 15307 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 15308 pthread_mutex_lock(&ctx->lua_bg_mutex);; 15309 /* call ""log()"" in Lua */; 15310 lua_getglobal(lstate, ""log"");; 15311 prepare_lua_request_info_inner(conn, lstate);; 15312 push_lua_response_log_data(conn, lstate);; 15313 ; 15314 ret = lua_pcall(lstate, /* args */ 2, /* results */ 1, 0);; 15315 if (ret == 0) {; 15316 int t = lua_type(lstate, -1);; 15317 if (t == LUA_TBOOLEAN) {; 15318 if (lua_toboolean(lstate, -1) == 0) {; 15319 /* log() returned false: do not log */; 15320 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15321 return;; 15322 }; 15323 /* log returned true: continue logging */; 15324 } else if (t == LUA_TSTRING) {; 15325 size_t len;; 15326 const char *txt = lua_tolstring(lstate, -1, &len);; 15327 if ((len == 0) || (*txt == 0)) {; 15328 /* log() returned empty string: do not log */; 15329 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15330 return;; 15331 }; 15332 /* Copy test from Lua into log_buf */; 15333 if (len >= sizeof(log_buf)) {; 15334 len = sizeof(log_buf) - 1;; 15335 }; 15336 memcpy(log_buf, txt, len);; 15337 log_buf[len] = 0;; 15338 }; 15339 } else {; 15340 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15341 }; 15342 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15343 }; 15344#endif; 15345 ; 15346 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15347 if (mg_fopen(conn,; 15348 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15349 MG_FOPEN_MODE_APPEND,; 15350 &fi); 15351 == 0) {; 15352 fi.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:453515,Testability,log,log,453515,"; 15287 struct mg_file fi;; 15288 char date[64], src_addr[IP_ADDR_STR_LEN];; 15289 struct tm *tm;; 15290 ; 15291 const char *referer;; 15292 const char *user_agent;; 15293 ; 15294 char log_buf[4096];; 15295 ; 15296 if (!conn || !conn->dom_ctx) {; 15297 return;; 15298 }; 15299 ; 15300 /* Set log message to ""empty"" */; 15301 log_buf[0] = 0;; 15302 ; 15303#if defined(USE_LUA); 15304 if (conn->phys_ctx->lua_bg_log_available) {; 15305 int ret;; 15306 struct mg_context *ctx = conn->phys_ctx;; 15307 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 15308 pthread_mutex_lock(&ctx->lua_bg_mutex);; 15309 /* call ""log()"" in Lua */; 15310 lua_getglobal(lstate, ""log"");; 15311 prepare_lua_request_info_inner(conn, lstate);; 15312 push_lua_response_log_data(conn, lstate);; 15313 ; 15314 ret = lua_pcall(lstate, /* args */ 2, /* results */ 1, 0);; 15315 if (ret == 0) {; 15316 int t = lua_type(lstate, -1);; 15317 if (t == LUA_TBOOLEAN) {; 15318 if (lua_toboolean(lstate, -1) == 0) {; 15319 /* log() returned false: do not log */; 15320 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15321 return;; 15322 }; 15323 /* log returned true: continue logging */; 15324 } else if (t == LUA_TSTRING) {; 15325 size_t len;; 15326 const char *txt = lua_tolstring(lstate, -1, &len);; 15327 if ((len == 0) || (*txt == 0)) {; 15328 /* log() returned empty string: do not log */; 15329 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15330 return;; 15331 }; 15332 /* Copy test from Lua into log_buf */; 15333 if (len >= sizeof(log_buf)) {; 15334 len = sizeof(log_buf) - 1;; 15335 }; 15336 memcpy(log_buf, txt, len);; 15337 log_buf[len] = 0;; 15338 }; 15339 } else {; 15340 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15341 }; 15342 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15343 }; 15344#endif; 15345 ; 15346 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15347 if (mg_fopen(conn,; 15348 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15349 MG_FOPEN_MODE_APPEND,; 15350 &fi); 15351 == 0) {; 15352 fi.",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:454190,Testability,log,log,454190,"log */; 15329 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15330 return;; 15331 }; 15332 /* Copy test from Lua into log_buf */; 15333 if (len >= sizeof(log_buf)) {; 15334 len = sizeof(log_buf) - 1;; 15335 }; 15336 memcpy(log_buf, txt, len);; 15337 log_buf[len] = 0;; 15338 }; 15339 } else {; 15340 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15341 }; 15342 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15343 }; 15344#endif; 15345 ; 15346 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15347 if (mg_fopen(conn,; 15348 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15349 MG_FOPEN_MODE_APPEND,; 15350 &fi); 15351 == 0) {; 15352 fi.access.fp = NULL;; 15353 }; 15354 } else {; 15355 fi.access.fp = NULL;; 15356 }; 15357 ; 15358 /* Log is written to a file and/or a callback. If both are not set,; 15359 * executing the rest of the function is pointless. */; 15360 if ((fi.access.fp == NULL); 15361 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15362 return;; 15363 }; 15364 ; 15365 /* If we did not get a log message from Lua, create it here. */; 15366 if (!log_buf[0]) {; 15367 tm = localtime(&conn->conn_birth_time);; 15368 if (tm != NULL) {; 15369 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15370 } else {; 15371 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15372 date[sizeof(date) - 1] = '\0';; 15373 }; 15374 ; 15375 ri = &conn->request_info;; 15376 ; 15377 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15378 referer = header_val(conn, ""Referer"");; 15379 user_agent = header_val(conn, ""User-Agent"");; 15380 ; 15381 mg_snprintf(conn,; 15382 NULL, /* Ignore truncation in access log */; 15383 log_buf,; 15384 sizeof(log_buf),; 15385 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15386 "" %s %s"",; 15387 src_addr,; 15388 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15389 date,; 15390 ri->request_method ? ri->request_method : ""-"",; 15391 ri->request_uri ? ri->request_uri : ""-"",; 15392 ri->query_string ? ""?""",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:454824,Testability,log,log,454824,"ntless. */; 15360 if ((fi.access.fp == NULL); 15361 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15362 return;; 15363 }; 15364 ; 15365 /* If we did not get a log message from Lua, create it here. */; 15366 if (!log_buf[0]) {; 15367 tm = localtime(&conn->conn_birth_time);; 15368 if (tm != NULL) {; 15369 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15370 } else {; 15371 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15372 date[sizeof(date) - 1] = '\0';; 15373 }; 15374 ; 15375 ri = &conn->request_info;; 15376 ; 15377 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15378 referer = header_val(conn, ""Referer"");; 15379 user_agent = header_val(conn, ""User-Agent"");; 15380 ; 15381 mg_snprintf(conn,; 15382 NULL, /* Ignore truncation in access log */; 15383 log_buf,; 15384 sizeof(log_buf),; 15385 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15386 "" %s %s"",; 15387 src_addr,; 15388 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15389 date,; 15390 ri->request_method ? ri->request_method : ""-"",; 15391 ri->request_uri ? ri->request_uri : ""-"",; 15392 ri->query_string ? ""?"" : """",; 15393 ri->query_string ? ri->query_string : """",; 15394 ri->http_version,; 15395 conn->status_code,; 15396 conn->num_bytes_sent,; 15397 referer,; 15398 user_agent);; 15399 }; 15400 ; 15401 /* Here we have a log message in log_buf. Call the callback */; 15402 if (conn->phys_ctx->callbacks.log_access) {; 15403 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15404 /* do not log if callack returns non-zero */; 15405 if (fi.access.fp) {; 15406 mg_fclose(&fi.access);; 15407 }; 15408 return;; 15409 }; 15410 }; 15411 ; 15412 /* Store in file */; 15413 if (fi.access.fp) {; 15414 int ok = 1;; 15415 flockfile(fi.access.fp);; 15416 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15417 ok = 0;; 15418 }; 15419 if (fflush(fi.access.fp) != 0) {; 15420 ok = 0;; 15421 }; 15422 funlockfile(fi.access.fp);; 15423 if (mg_fclose(&fi.access) != 0)",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:455380,Testability,log,log,455380,"ntless. */; 15360 if ((fi.access.fp == NULL); 15361 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15362 return;; 15363 }; 15364 ; 15365 /* If we did not get a log message from Lua, create it here. */; 15366 if (!log_buf[0]) {; 15367 tm = localtime(&conn->conn_birth_time);; 15368 if (tm != NULL) {; 15369 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15370 } else {; 15371 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15372 date[sizeof(date) - 1] = '\0';; 15373 }; 15374 ; 15375 ri = &conn->request_info;; 15376 ; 15377 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15378 referer = header_val(conn, ""Referer"");; 15379 user_agent = header_val(conn, ""User-Agent"");; 15380 ; 15381 mg_snprintf(conn,; 15382 NULL, /* Ignore truncation in access log */; 15383 log_buf,; 15384 sizeof(log_buf),; 15385 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15386 "" %s %s"",; 15387 src_addr,; 15388 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15389 date,; 15390 ri->request_method ? ri->request_method : ""-"",; 15391 ri->request_uri ? ri->request_uri : ""-"",; 15392 ri->query_string ? ""?"" : """",; 15393 ri->query_string ? ri->query_string : """",; 15394 ri->http_version,; 15395 conn->status_code,; 15396 conn->num_bytes_sent,; 15397 referer,; 15398 user_agent);; 15399 }; 15400 ; 15401 /* Here we have a log message in log_buf. Call the callback */; 15402 if (conn->phys_ctx->callbacks.log_access) {; 15403 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15404 /* do not log if callack returns non-zero */; 15405 if (fi.access.fp) {; 15406 mg_fclose(&fi.access);; 15407 }; 15408 return;; 15409 }; 15410 }; 15411 ; 15412 /* Store in file */; 15413 if (fi.access.fp) {; 15414 int ok = 1;; 15415 flockfile(fi.access.fp);; 15416 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15417 ok = 0;; 15418 }; 15419 if (fflush(fi.access.fp) != 0) {; 15420 ok = 0;; 15421 }; 15422 funlockfile(fi.access.fp);; 15423 if (mg_fclose(&fi.access) != 0)",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:455559,Testability,log,log,455559,"_info;; 15376 ; 15377 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15378 referer = header_val(conn, ""Referer"");; 15379 user_agent = header_val(conn, ""User-Agent"");; 15380 ; 15381 mg_snprintf(conn,; 15382 NULL, /* Ignore truncation in access log */; 15383 log_buf,; 15384 sizeof(log_buf),; 15385 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15386 "" %s %s"",; 15387 src_addr,; 15388 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15389 date,; 15390 ri->request_method ? ri->request_method : ""-"",; 15391 ri->request_uri ? ri->request_uri : ""-"",; 15392 ri->query_string ? ""?"" : """",; 15393 ri->query_string ? ri->query_string : """",; 15394 ri->http_version,; 15395 conn->status_code,; 15396 conn->num_bytes_sent,; 15397 referer,; 15398 user_agent);; 15399 }; 15400 ; 15401 /* Here we have a log message in log_buf. Call the callback */; 15402 if (conn->phys_ctx->callbacks.log_access) {; 15403 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15404 /* do not log if callack returns non-zero */; 15405 if (fi.access.fp) {; 15406 mg_fclose(&fi.access);; 15407 }; 15408 return;; 15409 }; 15410 }; 15411 ; 15412 /* Store in file */; 15413 if (fi.access.fp) {; 15414 int ok = 1;; 15415 flockfile(fi.access.fp);; 15416 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15417 ok = 0;; 15418 }; 15419 if (fflush(fi.access.fp) != 0) {; 15420 ok = 0;; 15421 }; 15422 funlockfile(fi.access.fp);; 15423 if (mg_fclose(&fi.access) != 0) {; 15424 ok = 0;; 15425 }; 15426 if (!ok) {; 15427 mg_cry_internal(conn,; 15428 ""Error writing log file %s"",; 15429 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15430 }; 15431 }; 15432}; 15433#else; 15434#error ""Either enable filesystems or provide a custom log_access implementation""; 15435#endif /* Externally provided function */; 15436 ; 15437 ; 15438/* Verify given socket address against the ACL.; 15439 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15440 */; 15441static int; 15442check_acl(struct mg_co",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:456119,Testability,log,log,456119,": """",; 15394 ri->http_version,; 15395 conn->status_code,; 15396 conn->num_bytes_sent,; 15397 referer,; 15398 user_agent);; 15399 }; 15400 ; 15401 /* Here we have a log message in log_buf. Call the callback */; 15402 if (conn->phys_ctx->callbacks.log_access) {; 15403 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15404 /* do not log if callack returns non-zero */; 15405 if (fi.access.fp) {; 15406 mg_fclose(&fi.access);; 15407 }; 15408 return;; 15409 }; 15410 }; 15411 ; 15412 /* Store in file */; 15413 if (fi.access.fp) {; 15414 int ok = 1;; 15415 flockfile(fi.access.fp);; 15416 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15417 ok = 0;; 15418 }; 15419 if (fflush(fi.access.fp) != 0) {; 15420 ok = 0;; 15421 }; 15422 funlockfile(fi.access.fp);; 15423 if (mg_fclose(&fi.access) != 0) {; 15424 ok = 0;; 15425 }; 15426 if (!ok) {; 15427 mg_cry_internal(conn,; 15428 ""Error writing log file %s"",; 15429 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15430 }; 15431 }; 15432}; 15433#else; 15434#error ""Either enable filesystems or provide a custom log_access implementation""; 15435#endif /* Externally provided function */; 15436 ; 15437 ; 15438/* Verify given socket address against the ACL.; 15439 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15440 */; 15441static int; 15442check_acl(struct mg_context *phys_ctx, const union usa *sa); 15443{; 15444 int allowed, flag, matched;; 15445 struct vec vec;; 15446 ; 15447 if (phys_ctx) {; 15448 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15449 ; 15450 /* If any ACL is set, deny by default */; 15451 allowed = (list == NULL) ? '+' : '-';; 15452 ; 15453 while ((list = next_option(list, &vec, NULL)) != NULL) {; 15454 flag = vec.ptr[0];; 15455 matched = -1;; 15456 if ((vec.len > 0) && ((flag == '+') || (flag == '-'))) {; 15457 vec.ptr++;; 15458 vec.len--;; 15459 matched = parse_match_net(&vec, sa, 1);; 15460 }; 15461 if (matched < 0) {; 15462 mg_cry_ctx_internal(phys_ctx,; 15463 ""%s: su",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:505983,Testability,test,test,505983,"C); 17004#pragma GCC diagnostic push; 17005#pragma GCC diagnostic ignored ""-Wconversion""; 17006#endif; 17007 /* Data type of linger structure elements may differ,; 17008 * so we don't know what cast we need here.; 17009 * Disable type conversion warnings. */; 17010 ; 17011 linger.l_linger = (linger_timeout + 999) / 1000;; 17012 ; 17013#if defined(GCC_DIAGNOSTIC); 17014#pragma GCC diagnostic pop; 17015#endif; 17016#if defined(_MSC_VER); 17017#pragma warning(pop); 17018#endif; 17019 ; 17020 } else {; 17021 linger.l_onoff = 0;; 17022 linger.l_linger = 0;; 17023 }; 17024 ; 17025 if (linger_timeout < -1) {; 17026 /* Default: don't configure any linger */; 17027 } else if (getsockopt(conn->client.sock,; 17028 SOL_SOCKET,; 17029 SO_ERROR,; 17030#if defined(_WIN32) /* WinSock uses different data type here */; 17031 (char *)&error_code,; 17032#else; 17033 &error_code,; 17034#endif; 17035 &opt_len); 17036 != 0) {; 17037 /* Cannot determine if socket is already closed. This should; 17038 * not occur and never did in a test. Log an error message; 17039 * and continue. */; 17040 mg_cry_internal(conn,; 17041 ""%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s"",; 17042 __func__,; 17043 strerror(ERRNO));; 17044#if defined(_WIN32); 17045 } else if (error_code == WSAECONNRESET) {; 17046#else; 17047 } else if (error_code == ECONNRESET) {; 17048#endif; 17049 /* Socket already closed by client/peer, close socket without linger; 17050 */; 17051 } else {; 17052 ; 17053 /* Set linger timeout */; 17054 if (setsockopt(conn->client.sock,; 17055 SOL_SOCKET,; 17056 SO_LINGER,; 17057 (char *)&linger,; 17058 sizeof(linger)); 17059 != 0) {; 17060 mg_cry_internal(; 17061 conn,; 17062 ""%s: setsockopt(SOL_SOCKET SO_LINGER(%i,%i)) failed: %s"",; 17063 __func__,; 17064 linger.l_onoff,; 17065 linger.l_linger,; 17066 strerror(ERRNO));; 17067 }; 17068 }; 17069 ; 17070 /* Now we know that our FIN is ACK-ed, safe to close */; 17071 closesocket(conn->client.sock);; 17072 conn->client.sock = INVALID_SOCKET;; 17073",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:519757,Testability,test,test,519757,"e,; 17467 ""%s"",; 17468 ""Invalid parameters"");; 17469 }; 17470 return NULL;; 17471 }; 17472 ; 17473 /* check all known protocolls */; 17474 if (!mg_strcasecmp(protocol, ""http"")) {; 17475 is_ssl = 0;; 17476 is_ws = 0;; 17477 } else if (!mg_strcasecmp(protocol, ""https"")) {; 17478 is_ssl = 1;; 17479 is_ws = 0;; 17480#if defined(USE_WEBSOCKET); 17481 } else if (!mg_strcasecmp(protocol, ""ws"")) {; 17482 is_ssl = 0;; 17483 is_ws = 1;; 17484 } else if (!mg_strcasecmp(protocol, ""wss"")) {; 17485 is_ssl = 1;; 17486 is_ws = 1;; 17487#endif; 17488 } else {; 17489 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17490 mg_snprintf(NULL,; 17491 NULL, /* No truncation check for error buffers */; 17492 error->text,; 17493 error->text_buffer_size,; 17494 ""Protocol %s not supported"",; 17495 protocol);; 17496 }; 17497 return NULL;; 17498 }; 17499 ; 17500 /* TODO: The current implementation here just calls the old; 17501 * implementations, without using any new options. This is just a first; 17502 * step to test the new interfaces. */; 17503#if defined(USE_WEBSOCKET); 17504 if (is_ws) {; 17505 /* TODO: implement all options */; 17506 return mg_connect_websocket_client(; 17507 host,; 17508 port,; 17509 is_ssl,; 17510 ((error != NULL) ? error->text : NULL),; 17511 ((error != NULL) ? error->text_buffer_size : 0),; 17512 (path ? path : """"),; 17513 NULL /* TODO: origin */,; 17514 experimental_websocket_client_data_wrapper,; 17515 experimental_websocket_client_close_wrapper,; 17516 (void *)init->callbacks);; 17517 }; 17518#endif; 17519 ; 17520 /* TODO: all additional options */; 17521 struct mg_client_options opts;; 17522 memset(&opts, 0, sizeof(opts));; 17523 opts.host = host;; 17524 opts.port = port;; 17525 return mg_connect_client_impl(&opts,; 17526 is_ssl,; 17527 ((error != NULL) ? error->text : NULL),; 17528 ((error != NULL) ? error->text_buffer_size; 17529 : 0));; 17530}; 17531#endif; 17532 ; 17533 ; 17534static const struct {; 17535 const char *proto;; 17536 size_t proto_len;; 175",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:535248,Testability,test,test,535248,"or"");; 18000 return -1;; 18001 }; 18002 ; 18003 /* Reset the previous responses */; 18004 conn->data_len = 0;; 18005 ; 18006 /* Implementation of API function for HTTP clients */; 18007 save_timeout = conn->dom_ctx->config[REQUEST_TIMEOUT];; 18008 ; 18009 if (timeout >= 0) {; 18010 mg_snprintf(conn, NULL, txt, sizeof(txt), ""%i"", timeout);; 18011 new_timeout = txt;; 18012 } else {; 18013 new_timeout = NULL;; 18014 }; 18015 ; 18016 conn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;; 18017 ret = get_response(conn, ebuf, ebuf_len, &err);; 18018 conn->dom_ctx->config[REQUEST_TIMEOUT] = save_timeout;; 18019 ; 18020 /* TODO: here, the URI is the http response code */; 18021 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18022 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18023 ; 18024 /* TODO (mid): Define proper return values - maybe return length?; 18025 * For the first test use <0 for error and >0 for OK */; 18026 return (ret == 0) ? -1 : +1;; 18027}; 18028 ; 18029 ; 18030struct mg_connection *; 18031mg_download(const char *host,; 18032 int port,; 18033 int use_ssl,; 18034 char *ebuf,; 18035 size_t ebuf_len,; 18036 const char *fmt,; 18037 ...); 18038{; 18039 struct mg_connection *conn;; 18040 va_list ap;; 18041 int i;; 18042 int reqerr;; 18043 ; 18044 if (ebuf_len > 0) {; 18045 ebuf[0] = '\0';; 18046 }; 18047 ; 18048 va_start(ap, fmt);; 18049 ; 18050 /* open a connection */; 18051 conn = mg_connect_client(host, port, use_ssl, ebuf, ebuf_len);; 18052 ; 18053 if (conn != NULL) {; 18054 i = mg_vprintf(conn, fmt, ap);; 18055 if (i <= 0) {; 18056 mg_snprintf(conn,; 18057 NULL, /* No truncation check for ebuf */; 18058 ebuf,; 18059 ebuf_len,; 18060 ""%s"",; 18061 ""Error sending request"");; 18062 } else {; 18063 /* make sure the buffer is clear */; 18064 conn->data_len = 0;; 18065 get_response(conn, ebuf, ebuf_len, &reqerr);; 18066 ; 18067 /* TODO: here, the URI is the http response code */; 18068 conn->request_info.local_uri = conn->re",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:552441,Testability,test,test,552441,"est_uri, conn);; 18582 if (hostend) {; 18583 conn->request_info.local_uri_raw = hostend;; 18584 } else {; 18585 conn->request_info.local_uri_raw = NULL;; 18586 }; 18587 break;; 18588 default:; 18589 mg_snprintf(conn,; 18590 NULL, /* No truncation check for ebuf */; 18591 ebuf,; 18592 sizeof(ebuf),; 18593 ""Invalid URI"");; 18594 mg_send_http_error(conn, 400, ""%s"", ebuf);; 18595 conn->request_info.local_uri_raw = NULL;; 18596 break;; 18597 }; 18598 conn->request_info.local_uri =; 18599 (char *)conn->request_info.local_uri_raw;; 18600 }; 18601 ; 18602 if (ebuf[0] != '\0') {; 18603 conn->protocol_type = -1;; 18604 ; 18605 } else {; 18606 /* HTTP/1 allows protocol upgrade */; 18607 conn->protocol_type = should_switch_to_protocol(conn);; 18608 ; 18609 if (conn->protocol_type == PROTOCOL_TYPE_HTTP2) {; 18610 /* This will occur, if a HTTP/1.1 request should be upgraded; 18611 * to HTTP/2 - but not if HTTP/2 is negotiated using ALPN.; 18612 * Since most (all?) major browsers only support HTTP/2 using; 18613 * ALPN, this is hard to test and very low priority.; 18614 * Deactivate it (at least for now).; 18615 */; 18616 conn->protocol_type = PROTOCOL_TYPE_HTTP1;; 18617 }; 18618 }; 18619 ; 18620 DEBUG_TRACE(""http: %s, error: %s"",; 18621 (ri->http_version ? ri->http_version : ""none""),; 18622 (ebuf[0] ? ebuf : ""none""));; 18623 ; 18624 if (ebuf[0] == '\0') {; 18625 if (conn->request_info.local_uri) {; 18626 ; 18627 /* handle request to local server */; 18628 handle_request_stat_log(conn);; 18629 ; 18630 } else {; 18631 /* TODO: handle non-local request (PROXY) */; 18632 conn->must_close = 1;; 18633 }; 18634 } else {; 18635 conn->must_close = 1;; 18636 }; 18637 ; 18638 /* Response complete. Free header buffer */; 18639 free_buffered_response_header_list(conn);; 18640 ; 18641 if (ri->remote_user != NULL) {; 18642 mg_free((void *)ri->remote_user);; 18643 /* Important! When having connections with and without auth; 18644 * would cause double free and then crash */; 18645 ri->remote_user ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:574202,Testability,log,log,574202,"222 tls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);; 19223#endif; 19224 tls.is_master = 1;; 19225 pthread_setspecific(sTlsKey, &tls);; 19226 ; 19227 if (ctx->callbacks.init_thread) {; 19228 /* Callback for the master thread (type 0) */; 19229 tls.user_ptr = ctx->callbacks.init_thread(ctx, 0);; 19230 } else {; 19231 tls.user_ptr = NULL;; 19232 }; 19233 ; 19234 /* Lua background script ""start"" event */; 19235#if defined(USE_LUA); 19236 if (ctx->lua_background_state) {; 19237 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 19238 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19239 ; 19240 /* call ""start()"" in Lua */; 19241 lua_getglobal(lstate, ""start"");; 19242 if (lua_type(lstate, -1) == LUA_TFUNCTION) {; 19243 int ret = lua_pcall(lstate, /* args */ 0, /* results */ 0, 0);; 19244 if (ret != 0) {; 19245 struct mg_connection fc;; 19246 lua_cry(fake_connection(&fc, ctx),; 19247 ret,; 19248 lstate,; 19249 ""lua_background_script"",; 19250 ""start"");; 19251 }; 19252 } else {; 19253 lua_pop(lstate, 1);; 19254 }; 19255 ; 19256 /* determine if there is a ""log()"" function in Lua background script */; 19257 lua_getglobal(lstate, ""log"");; 19258 if (lua_type(lstate, -1) == LUA_TFUNCTION) {; 19259 ctx->lua_bg_log_available = 1;; 19260 }; 19261 lua_pop(lstate, 1);; 19262 ; 19263 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19264 }; 19265#endif; 19266 ; 19267 /* Server starts *now* */; 19268 ctx->start_time = time(NULL);; 19269 ; 19270 /* Server accept loop */; 19271 pfd = ctx->listening_socket_fds;; 19272 while (STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 19273 for (i = 0; i < ctx->num_listening_sockets; i++) {; 19274 pfd[i].fd = ctx->listening_sockets[i].sock;; 19275 pfd[i].events = POLLIN;; 19276 }; 19277 ; 19278 if (mg_poll(pfd,; 19279 ctx->num_listening_sockets,; 19280 SOCKET_TIMEOUT_QUANTUM,; 19281 &(ctx->stop_flag)); 19282 > 0) {; 19283 for (i = 0; i < ctx->num_listening_sockets; i++) {; 19284 /* NOTE(lsm): on QNX, poll() returns POLLRDNORM after the; 19285",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:574276,Testability,log,log,574276,"222 tls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);; 19223#endif; 19224 tls.is_master = 1;; 19225 pthread_setspecific(sTlsKey, &tls);; 19226 ; 19227 if (ctx->callbacks.init_thread) {; 19228 /* Callback for the master thread (type 0) */; 19229 tls.user_ptr = ctx->callbacks.init_thread(ctx, 0);; 19230 } else {; 19231 tls.user_ptr = NULL;; 19232 }; 19233 ; 19234 /* Lua background script ""start"" event */; 19235#if defined(USE_LUA); 19236 if (ctx->lua_background_state) {; 19237 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 19238 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19239 ; 19240 /* call ""start()"" in Lua */; 19241 lua_getglobal(lstate, ""start"");; 19242 if (lua_type(lstate, -1) == LUA_TFUNCTION) {; 19243 int ret = lua_pcall(lstate, /* args */ 0, /* results */ 0, 0);; 19244 if (ret != 0) {; 19245 struct mg_connection fc;; 19246 lua_cry(fake_connection(&fc, ctx),; 19247 ret,; 19248 lstate,; 19249 ""lua_background_script"",; 19250 ""start"");; 19251 }; 19252 } else {; 19253 lua_pop(lstate, 1);; 19254 }; 19255 ; 19256 /* determine if there is a ""log()"" function in Lua background script */; 19257 lua_getglobal(lstate, ""log"");; 19258 if (lua_type(lstate, -1) == LUA_TFUNCTION) {; 19259 ctx->lua_bg_log_available = 1;; 19260 }; 19261 lua_pop(lstate, 1);; 19262 ; 19263 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19264 }; 19265#endif; 19266 ; 19267 /* Server starts *now* */; 19268 ctx->start_time = time(NULL);; 19269 ; 19270 /* Server accept loop */; 19271 pfd = ctx->listening_socket_fds;; 19272 while (STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 19273 for (i = 0; i < ctx->num_listening_sockets; i++) {; 19274 pfd[i].fd = ctx->listening_sockets[i].sock;; 19275 pfd[i].events = POLLIN;; 19276 }; 19277 ; 19278 if (mg_poll(pfd,; 19279 ctx->num_listening_sockets,; 19280 SOCKET_TIMEOUT_QUANTUM,; 19281 &(ctx->stop_flag)); 19282 > 0) {; 19283 for (i = 0; i < ctx->num_listening_sockets; i++) {; 19284 /* NOTE(lsm): on QNX, poll() returns POLLRDNORM after the; 19285",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:50751,Usability,simpl,simple,50751,"ostic ignored ""-Wunreachable-code""; 1627 /* For every compiler, either ""sizeof(pthread_t) > sizeof(unsigned long)""; 1628 * or not, so one of the two conditions will be unreachable by construction.; 1629 * Unfortunately the C standard does not define a way to check this at; 1630 * compile time, since the #if preprocessor conditions can not use the; 1631 * sizeof operator as an argument. */; 1632#endif; 1633 ; 1634 if (sizeof(pthread_t) > sizeof(unsigned long)) {; 1635 /* This is the problematic case for CRYPTO_set_id_callback:; 1636 * The OS pthread_t can not be cast to unsigned long. */; 1637 struct mg_workerTLS *tls =; 1638 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 1639 if (tls == NULL) {; 1640 /* SSL called from an unknown thread: Create some thread index.; 1641 */; 1642 tls = (struct mg_workerTLS *)mg_malloc(sizeof(struct mg_workerTLS));; 1643 tls->is_master = -2; /* -2 means ""3rd party thread"" */; 1644 tls->thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);; 1645 pthread_setspecific(sTlsKey, tls);; 1646 }; 1647 return tls->thread_idx;; 1648 } else {; 1649 /* pthread_t may be any data type, so a simple cast to unsigned long; 1650 * can rise a warning/error, depending on the platform.; 1651 * Here memcpy is used as an anything-to-anything cast. */; 1652 unsigned long ret = 0;; 1653 pthread_t t = pthread_self();; 1654 memcpy(&ret, &t, sizeof(pthread_t));; 1655 return ret;; 1656 }; 1657 ; 1658#if defined(__clang__); 1659#pragma clang diagnostic pop; 1660#endif; 1661 ; 1662#endif; 1663}; 1664 ; 1665 ; 1666FUNCTION_MAY_BE_UNUSED; 1667static uint64_t; 1668mg_get_current_time_ns(void); 1669{; 1670 struct timespec tsnow;; 1671 clock_gettime(CLOCK_REALTIME, &tsnow);; 1672 return (((uint64_t)tsnow.tv_sec) * 1000000000) + (uint64_t)tsnow.tv_nsec;; 1673}; 1674 ; 1675 ; 1676#if defined(GCC_DIAGNOSTIC); 1677/* Show no warning in case system functions are not used. */; 1678#pragma GCC diagnostic pop; 1679#endif /* defined(GCC_DIAGNOSTIC) */; 1680#if defined(__cla",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:54194,Usability,simpl,simply,54194,"f struct SSL SSL; /* dummy for SSL argument to push/pull */; 1739typedef struct SSL_CTX SSL_CTX;; 1740 ; 1741#elif defined(NO_SSL_DL); 1742/* OpenSSL without dynamic loading */; 1743#include <openssl/bn.h>; 1744#include <openssl/conf.h>; 1745#include <openssl/crypto.h>; 1746#include <openssl/dh.h>; 1747#include <openssl/err.h>; 1748#include <openssl/opensslv.h>; 1749#include <openssl/pem.h>; 1750#include <openssl/ssl.h>; 1751#include <openssl/tls1.h>; 1752#include <openssl/x509.h>; 1753 ; 1754#if defined(WOLFSSL_VERSION); 1755/* Additional defines for WolfSSL, see; 1756 * https://github.com/civetweb/civetweb/issues/583 */; 1757#include ""wolfssl_extras.inl""; 1758#endif; 1759 ; 1760#if defined(OPENSSL_IS_BORINGSSL); 1761/* From boringssl/src/include/openssl/mem.h:; 1762 *; 1763 * OpenSSL has, historically, had a complex set of malloc debugging options.; 1764 * However, that was written in a time before Valgrind and ASAN. Since we now; 1765 * have those tools, the OpenSSL allocation functions are simply macros around; 1766 * the standard memory functions.; 1767 *; 1768 * #define OPENSSL_free free */; 1769#define free free; 1770// disable for boringssl; 1771#define CONF_modules_unload(a) ((void)0); 1772#define ENGINE_cleanup() ((void)0); 1773#endif; 1774 ; 1775/* If OpenSSL headers are included, automatically select the API version */; 1776#if (OPENSSL_VERSION_NUMBER >= 0x30000000L); 1777#if !defined(OPENSSL_API_3_0); 1778#define OPENSSL_API_3_0; 1779#endif; 1780#define OPENSSL_REMOVE_THREAD_STATE(); 1781#else; 1782#if (OPENSSL_VERSION_NUMBER >= 0x10100000L); 1783#if !defined(OPENSSL_API_1_1); 1784#define OPENSSL_API_1_1; 1785#endif; 1786#define OPENSSL_REMOVE_THREAD_STATE(); 1787#else; 1788#if !defined(OPENSSL_API_1_0); 1789#define OPENSSL_API_1_0; 1790#endif; 1791#define OPENSSL_REMOVE_THREAD_STATE() ERR_remove_thread_state(NULL); 1792#endif; 1793#endif; 1794 ; 1795 ; 1796#else; 1797/* SSL loaded dynamically from DLL / shared object */; 1798/* Add all prototypes here,",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:172502,Usability,feedback,feedback,172502,"NO));; 5835 }; 5836 }; 5837 exit(EXIT_FAILURE);; 5838 }; 5839 ; 5840 return pid;; 5841}; 5842#endif /* !NO_CGI */; 5843 ; 5844 ; 5845static int; 5846set_non_blocking_mode(SOCKET sock); 5847{; 5848 int flags = fcntl(sock, F_GETFL, 0);; 5849 if (flags < 0) {; 5850 return -1;; 5851 }; 5852 ; 5853 if (fcntl(sock, F_SETFL, (flags | O_NONBLOCK)) < 0) {; 5854 return -1;; 5855 }; 5856 return 0;; 5857}; 5858 ; 5859static int; 5860set_blocking_mode(SOCKET sock); 5861{; 5862 int flags = fcntl(sock, F_GETFL, 0);; 5863 if (flags < 0) {; 5864 return -1;; 5865 }; 5866 ; 5867 if (fcntl(sock, F_SETFL, flags & (~(int)(O_NONBLOCK))) < 0) {; 5868 return -1;; 5869 }; 5870 return 0;; 5871}; 5872#endif /* _WIN32 / else */; 5873 ; 5874/* End of initial operating system specific define block. */; 5875 ; 5876 ; 5877/* Get a random number (independent of C rand function) */; 5878static uint64_t; 5879get_random(void); 5880{; 5881 static uint64_t lfsr = 0; /* Linear feedback shift register */; 5882 static uint64_t lcg = 0; /* Linear congruential generator */; 5883 uint64_t now = mg_get_current_time_ns();; 5884 ; 5885 if (lfsr == 0) {; 5886 /* lfsr will be only 0 if has not been initialized,; 5887 * so this code is called only once. */; 5888 lfsr = mg_get_current_time_ns();; 5889 lcg = mg_get_current_time_ns();; 5890 } else {; 5891 /* Get the next step of both random number generators. */; 5892 lfsr = (lfsr >> 1); 5893 | ((((lfsr >> 0) ^ (lfsr >> 1) ^ (lfsr >> 3) ^ (lfsr >> 4)) & 1); 5894 << 63);; 5895 lcg = lcg * 6364136223846793005LL + 1442695040888963407LL;; 5896 }; 5897 ; 5898 /* Combining two pseudo-random number generators and a high resolution; 5899 * part; 5900 * of the current server time will make it hard (impossible?) to guess; 5901 * the; 5902 * next number. */; 5903 return (lfsr ^ lcg ^ now);; 5904}; 5905 ; 5906 ; 5907static int; 5908mg_poll(struct mg_pollfd *pfd,; 5909 unsigned int n,; 5910 int milliseconds,; 5911 const stop_flag_t *stop_flag); 5912{; 5913 /* Call poll, but only fo",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:423419,Usability,simpl,simpler,423419,"n the callback.; 14352 *; 14353 * TODO: What would be the best reaction here?; 14354 * (Note: The reaction may change, if there is a better; 14355 * idea.); 14356 */; 14357 ; 14358 /* For the moment, use option c: We look for a proper file,; 14359 * but since a file request is not always a script resource,; 14360 * the authorization check might be different. */; 14361 interpret_uri(conn,; 14362 path,; 14363 sizeof(path),; 14364 &file.stat,; 14365 &is_found,; 14366 &is_script_resource,; 14367 &is_websocket_request,; 14368 &is_put_or_delete_request,; 14369 &is_template_text_file);; 14370 callback_handler = NULL;; 14371 ; 14372 /* Here we are at a dead end:; 14373 * According to URI matching, a callback should be; 14374 * responsible for handling the request,; 14375 * we called it, but the callback declared itself; 14376 * not responsible.; 14377 * We use a goto here, to get out of this dead end,; 14378 * and continue with the default handling.; 14379 * A goto here is simpler and better to understand; 14380 * than some curious loop. */; 14381 goto no_callback_resource;; 14382 }; 14383 } else {; 14384#if defined(USE_WEBSOCKET); 14385 handle_websocket_request(conn,; 14386 path,; 14387 is_callback_resource,; 14388 subprotocols,; 14389 ws_connect_handler,; 14390 ws_ready_handler,; 14391 ws_data_handler,; 14392 ws_close_handler,; 14393 callback_data);; 14394#endif; 14395 }; 14396 return;; 14397 }; 14398 ; 14399 /* 8. handle websocket requests */; 14400#if defined(USE_WEBSOCKET); 14401 if (is_websocket_request) {; 14402 HTTP1_only;; 14403 if (is_script_resource) {; 14404 ; 14405 if (is_in_script_path(conn, path)) {; 14406 /* Websocket Lua script */; 14407 handle_websocket_request(conn,; 14408 path,; 14409 0 /* Lua Script */,; 14410 NULL,; 14411 NULL,; 14412 NULL,; 14413 NULL,; 14414 NULL,; 14415 conn->phys_ctx->user_data);; 14416 } else {; 14417 /* Script was in an illegal path */; 14418 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14419 }; 14420 } else {; 14421 mg_sen",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:442335,Usability,simpl,simple,442335,"ions; 14914 *; 14915 * If we just look for 's' anywhere in the string, ""localhost:80""; 14916 * will be detected as SSL (false positive).; 14917 * Looking for 's' after a digit may cause false positives in; 14918 * ""my24service:8080"".; 14919 * Looking from 's' backward if there are only ':' and numbers; 14920 * before will not work for ""24service:8080"" (non SSL, port 8080); 14921 * or ""24s"" (SSL, port 24).; 14922 *; 14923 * Remark: Initially hostnames were not allowed to start with a; 14924 * digit (according to RFC 952), this was allowed later (RFC 1123,; 14925 * Section 2.1).; 14926 *; 14927 * To get this correct, the entire string must be parsed as a whole,; 14928 * reading it as a list element for element and parsing with an; 14929 * algorithm equivalent to parse_port_string.; 14930 *; 14931 * In fact, we use local interface names here, not arbitrary; 14932 * hostnames, so in most cases the only name will be ""localhost"".; 14933 *; 14934 * So, for now, we use this simple algorithm, that may still return; 14935 * a false positive in bizarre cases.; 14936 */; 14937 int i;; 14938 int portslen = (int)strlen(ports);; 14939 char prevIsNumber = 0;; 14940 ; 14941 for (i = 0; i < portslen; i++) {; 14942 if (prevIsNumber && (ports[i] == 's' || ports[i] == 'r')) {; 14943 return 1;; 14944 }; 14945 if (ports[i] >= '0' && ports[i] <= '9') {; 14946 prevIsNumber = 1;; 14947 } else {; 14948 prevIsNumber = 0;; 14949 }; 14950 }; 14951 }; 14952 return 0;; 14953}; 14954 ; 14955 ; 14956static int; 14957set_ports_option(struct mg_context *phys_ctx); 14958{; 14959 const char *list;; 14960 int on = 1;; 14961#if defined(USE_IPV6); 14962 int off = 0;; 14963#endif; 14964 struct vec vec;; 14965 struct socket so, *ptr;; 14966 ; 14967 struct mg_pollfd *pfd;; 14968 union usa usa;; 14969 socklen_t len;; 14970 int ip_version;; 14971 ; 14972 int portsTotal = 0;; 14973 int portsOk = 0;; 14974 ; 14975 const char *opt_txt;; 14976 long opt_listen_backlog;; 14977 ; 14978 if (!phys_ctx) {; 14979 return 0;",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/civetweb_8c_source.html:536126,Usability,clear,clear,536126," save_timeout;; 18019 ; 18020 /* TODO: here, the URI is the http response code */; 18021 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18022 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18023 ; 18024 /* TODO (mid): Define proper return values - maybe return length?; 18025 * For the first test use <0 for error and >0 for OK */; 18026 return (ret == 0) ? -1 : +1;; 18027}; 18028 ; 18029 ; 18030struct mg_connection *; 18031mg_download(const char *host,; 18032 int port,; 18033 int use_ssl,; 18034 char *ebuf,; 18035 size_t ebuf_len,; 18036 const char *fmt,; 18037 ...); 18038{; 18039 struct mg_connection *conn;; 18040 va_list ap;; 18041 int i;; 18042 int reqerr;; 18043 ; 18044 if (ebuf_len > 0) {; 18045 ebuf[0] = '\0';; 18046 }; 18047 ; 18048 va_start(ap, fmt);; 18049 ; 18050 /* open a connection */; 18051 conn = mg_connect_client(host, port, use_ssl, ebuf, ebuf_len);; 18052 ; 18053 if (conn != NULL) {; 18054 i = mg_vprintf(conn, fmt, ap);; 18055 if (i <= 0) {; 18056 mg_snprintf(conn,; 18057 NULL, /* No truncation check for ebuf */; 18058 ebuf,; 18059 ebuf_len,; 18060 ""%s"",; 18061 ""Error sending request"");; 18062 } else {; 18063 /* make sure the buffer is clear */; 18064 conn->data_len = 0;; 18065 get_response(conn, ebuf, ebuf_len, &reqerr);; 18066 ; 18067 /* TODO: here, the URI is the http response code */; 18068 conn->request_info.local_uri = conn->request_info.request_uri;; 18069 }; 18070 }; 18071 ; 18072 /* if an error occurred, close the connection */; 18073 if ((ebuf[0] != '\0') && (conn != NULL)) {; 18074 mg_close_connection(conn);; 18075 conn = NULL;; 18076 }; 18077 ; 18078 va_end(ap);; 18079 return conn;; 18080}; 18081 ; 18082 ; 18083struct websocket_client_thread_data {; 18084 struct mg_connection *conn;; 18085 mg_websocket_data_handler data_handler;; 18086 mg_websocket_close_handler close_handler;; 18087 void *callback_data;; 18088};; 18089 ; 18090 ; 18091#if defined(USE_WEBSOCKET); 18092#if defined(_WIN32); 18093static ",MatchSource.WIKI,doc/master/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html
https://root.cern/doc/master/classAxis2.html:10606,Availability,error,error,10606,"; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () co",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:10695,Availability,error,error,10695,"st;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:10850,Availability,error,error,10850,"graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this obj",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:11027,Availability,error,error,11027,"heck and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info ",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:15024,Availability,error,error,15024,"d must be overridden if a class wants to paint itself. ;  ; virtual void Pop ();  Pop on object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TAttAxis;  TAttAxis ();  ; virtual ~TAttAxis ();  Destructor. ;  ; void Copy (TAttAxis &attaxis) const;  Copy of the object. ;  ; virtual Color_t GetAxisColor () const;  ; virtual Color_t GetLabelColor () const;  ; virtual Style_t GetLabelFont () const;  ; virtual Float_t GetLabelOffset () cons",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:10612,Integrability,message,message,10612,"; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () co",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:11033,Integrability,message,message,11033,"heck and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info ",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:12023,Integrability,message,message,12023,"ssue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class shou",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:15030,Integrability,message,message,15030,"d must be overridden if a class wants to paint itself. ;  ; virtual void Pop ();  Pop on object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TAttAxis;  TAttAxis ();  ; virtual ~TAttAxis ();  Destructor. ;  ; void Copy (TAttAxis &attaxis) const;  Copy of the object. ;  ; virtual Color_t GetAxisColor () const;  ; virtual Color_t GetLabelColor () const;  ; virtual Style_t GetLabelFont () const;  ; virtual Float_t GetLabelOffset () cons",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:15403,Integrability,message,message,15403,"Int_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TAttAxis;  TAttAxis ();  ; virtual ~TAttAxis ();  Destructor. ;  ; void Copy (TAttAxis &attaxis) const;  Copy of the object. ;  ; virtual Color_t GetAxisColor () const;  ; virtual Color_t GetLabelColor () const;  ; virtual Style_t GetLabelFont () const;  ; virtual Float_t GetLabelOffset () const;  ; virtual Float_t GetLabelSize () const;  ; virtual Int_t GetMaxDigits () const;  ; virtual Int_t GetNdivisions () const;  ; virtual Float_t GetTickLength () const;  ; virtual Color_t GetTitleColor () const;  ; virtual Style_t GetTitleFont () const;  ; virtual Float_t GetTitleOffset () const;  ; virtual Float_t GetTitleSize () const;  ; virtual void ResetAttAxis (Optio",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:907,Modifiability,variab,variable,907,". ROOT: Axis2 Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Member Functions |; List of all members ; Axis2 Class Reference. . Definition at line 843 of file xRooNode.cxx. Public Member Functions; const RooAbsBinning * binning () const;  ; Int_t FindFixBin (const char *label) const override;  Find bin number with label. ;  ; Int_t FindFixBin (double x) const override;  Find bin number corresponding to abscissa x. ;  ; double GetBinLowEdge (Int_t bin) const override;  Return low edge of bin. ;  ; double GetBinUpEdge (Int_t bin) const override;  Return up edge of bin. ;  ; double GetBinWidth (Int_t bin) const override;  Return bin width. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; void Set (Int_t nbins, const double *xbins) override;  Initialize axis with variable bins. ;  ; void Set (Int_t nbins, const float *xbins) override;  Initialize axis with variable bins. ;  ; void Set (Int_t nbins, double xmin, double xmax) override;  Initialize axis with fix bins. ;  ; void SetTitle (const char *title) override;  Set the title of the TNamed. ;  ;  TAxis ();  Default constructor. ;  ;  TAxis (const TAxis &axis);  Copy constructor. ;  ;  TAxis (Int_t nbins, const Double_t *xbins);  Axis constructor for variable bin size. ;  ;  TAxis (Int_t nbins, Double_t xmin, Double_t xmax);  Axis constructor for axis with fix bin size. ;  ;  Public Member Functions inherited from TAxis;  TAxis ();  Default constructor. ;  ;  TAxis (const TAxis &axis);  Copy constructor. ;  ;  TAxis (Int_t nbins, const Double_t *xbins);  Axis constructor for variable bin size. ;  ;  TAxis (Int_t nbins, Double_t xmin, Double_t xmax);  Axis constructor for axis with fix bin size. ;  ;  ~TAxis () override;  Destructor. ;  ; Bool_t CanBeAlphanumeric ();  ; Bool_t CanExtend () const;  ; void CenterLabels (Bool_t center=kTRUE);  Center axis labels. ;  ; void CenterTitle (Boo",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:1002,Modifiability,variab,variable,1002,". ROOT: Axis2 Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Member Functions |; List of all members ; Axis2 Class Reference. . Definition at line 843 of file xRooNode.cxx. Public Member Functions; const RooAbsBinning * binning () const;  ; Int_t FindFixBin (const char *label) const override;  Find bin number with label. ;  ; Int_t FindFixBin (double x) const override;  Find bin number corresponding to abscissa x. ;  ; double GetBinLowEdge (Int_t bin) const override;  Return low edge of bin. ;  ; double GetBinUpEdge (Int_t bin) const override;  Return up edge of bin. ;  ; double GetBinWidth (Int_t bin) const override;  Return bin width. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; void Set (Int_t nbins, const double *xbins) override;  Initialize axis with variable bins. ;  ; void Set (Int_t nbins, const float *xbins) override;  Initialize axis with variable bins. ;  ; void Set (Int_t nbins, double xmin, double xmax) override;  Initialize axis with fix bins. ;  ; void SetTitle (const char *title) override;  Set the title of the TNamed. ;  ;  TAxis ();  Default constructor. ;  ;  TAxis (const TAxis &axis);  Copy constructor. ;  ;  TAxis (Int_t nbins, const Double_t *xbins);  Axis constructor for variable bin size. ;  ;  TAxis (Int_t nbins, Double_t xmin, Double_t xmax);  Axis constructor for axis with fix bin size. ;  ;  Public Member Functions inherited from TAxis;  TAxis ();  Default constructor. ;  ;  TAxis (const TAxis &axis);  Copy constructor. ;  ;  TAxis (Int_t nbins, const Double_t *xbins);  Axis constructor for variable bin size. ;  ;  TAxis (Int_t nbins, Double_t xmin, Double_t xmax);  Axis constructor for axis with fix bin size. ;  ;  ~TAxis () override;  Destructor. ;  ; Bool_t CanBeAlphanumeric ();  ; Bool_t CanExtend () const;  ; void CenterLabels (Bool_t center=kTRUE);  Center axis labels. ;  ; void CenterTitle (Boo",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:1354,Modifiability,variab,variable,1354," * binning () const;  ; Int_t FindFixBin (const char *label) const override;  Find bin number with label. ;  ; Int_t FindFixBin (double x) const override;  Find bin number corresponding to abscissa x. ;  ; double GetBinLowEdge (Int_t bin) const override;  Return low edge of bin. ;  ; double GetBinUpEdge (Int_t bin) const override;  Return up edge of bin. ;  ; double GetBinWidth (Int_t bin) const override;  Return bin width. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; void Set (Int_t nbins, const double *xbins) override;  Initialize axis with variable bins. ;  ; void Set (Int_t nbins, const float *xbins) override;  Initialize axis with variable bins. ;  ; void Set (Int_t nbins, double xmin, double xmax) override;  Initialize axis with fix bins. ;  ; void SetTitle (const char *title) override;  Set the title of the TNamed. ;  ;  TAxis ();  Default constructor. ;  ;  TAxis (const TAxis &axis);  Copy constructor. ;  ;  TAxis (Int_t nbins, const Double_t *xbins);  Axis constructor for variable bin size. ;  ;  TAxis (Int_t nbins, Double_t xmin, Double_t xmax);  Axis constructor for axis with fix bin size. ;  ;  Public Member Functions inherited from TAxis;  TAxis ();  Default constructor. ;  ;  TAxis (const TAxis &axis);  Copy constructor. ;  ;  TAxis (Int_t nbins, const Double_t *xbins);  Axis constructor for variable bin size. ;  ;  TAxis (Int_t nbins, Double_t xmin, Double_t xmax);  Axis constructor for axis with fix bin size. ;  ;  ~TAxis () override;  Destructor. ;  ; Bool_t CanBeAlphanumeric ();  ; Bool_t CanExtend () const;  ; void CenterLabels (Bool_t center=kTRUE);  Center axis labels. ;  ; void CenterTitle (Bool_t center=kTRUE);  Center axis title. ;  ; void ChangeLabel (Int_t labNum=0, Double_t labAngle=-1., Double_t labSize=-1., Int_t labAlign=-1, Int_t labColor=-1, Int_t labFont=-1, const TString &labText="""");  Define new text attributes for the label number ""labNum"". ;  ; void ChangeLabelByValue (Double_t labValue, Double_t la",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:1506,Modifiability,inherit,inherited,1506,"scissa x. ;  ; double GetBinLowEdge (Int_t bin) const override;  Return low edge of bin. ;  ; double GetBinUpEdge (Int_t bin) const override;  Return up edge of bin. ;  ; double GetBinWidth (Int_t bin) const override;  Return bin width. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; void Set (Int_t nbins, const double *xbins) override;  Initialize axis with variable bins. ;  ; void Set (Int_t nbins, const float *xbins) override;  Initialize axis with variable bins. ;  ; void Set (Int_t nbins, double xmin, double xmax) override;  Initialize axis with fix bins. ;  ; void SetTitle (const char *title) override;  Set the title of the TNamed. ;  ;  TAxis ();  Default constructor. ;  ;  TAxis (const TAxis &axis);  Copy constructor. ;  ;  TAxis (Int_t nbins, const Double_t *xbins);  Axis constructor for variable bin size. ;  ;  TAxis (Int_t nbins, Double_t xmin, Double_t xmax);  Axis constructor for axis with fix bin size. ;  ;  Public Member Functions inherited from TAxis;  TAxis ();  Default constructor. ;  ;  TAxis (const TAxis &axis);  Copy constructor. ;  ;  TAxis (Int_t nbins, const Double_t *xbins);  Axis constructor for variable bin size. ;  ;  TAxis (Int_t nbins, Double_t xmin, Double_t xmax);  Axis constructor for axis with fix bin size. ;  ;  ~TAxis () override;  Destructor. ;  ; Bool_t CanBeAlphanumeric ();  ; Bool_t CanExtend () const;  ; void CenterLabels (Bool_t center=kTRUE);  Center axis labels. ;  ; void CenterTitle (Bool_t center=kTRUE);  Center axis title. ;  ; void ChangeLabel (Int_t labNum=0, Double_t labAngle=-1., Double_t labSize=-1., Int_t labAlign=-1, Int_t labColor=-1, Int_t labFont=-1, const TString &labText="""");  Define new text attributes for the label number ""labNum"". ;  ; void ChangeLabelByValue (Double_t labValue, Double_t labAngle=-1., Double_t labSize=-1., Int_t labAlign=-1, Int_t labColor=-1, Int_t labFont=-1, const TString &labText="""");  Define new text attributes for the label value ""labValue"". ;  ; const ch",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:1685,Modifiability,variab,variable,1685,";  Return up edge of bin. ;  ; double GetBinWidth (Int_t bin) const override;  Return bin width. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; void Set (Int_t nbins, const double *xbins) override;  Initialize axis with variable bins. ;  ; void Set (Int_t nbins, const float *xbins) override;  Initialize axis with variable bins. ;  ; void Set (Int_t nbins, double xmin, double xmax) override;  Initialize axis with fix bins. ;  ; void SetTitle (const char *title) override;  Set the title of the TNamed. ;  ;  TAxis ();  Default constructor. ;  ;  TAxis (const TAxis &axis);  Copy constructor. ;  ;  TAxis (Int_t nbins, const Double_t *xbins);  Axis constructor for variable bin size. ;  ;  TAxis (Int_t nbins, Double_t xmin, Double_t xmax);  Axis constructor for axis with fix bin size. ;  ;  Public Member Functions inherited from TAxis;  TAxis ();  Default constructor. ;  ;  TAxis (const TAxis &axis);  Copy constructor. ;  ;  TAxis (Int_t nbins, const Double_t *xbins);  Axis constructor for variable bin size. ;  ;  TAxis (Int_t nbins, Double_t xmin, Double_t xmax);  Axis constructor for axis with fix bin size. ;  ;  ~TAxis () override;  Destructor. ;  ; Bool_t CanBeAlphanumeric ();  ; Bool_t CanExtend () const;  ; void CenterLabels (Bool_t center=kTRUE);  Center axis labels. ;  ; void CenterTitle (Bool_t center=kTRUE);  Center axis title. ;  ; void ChangeLabel (Int_t labNum=0, Double_t labAngle=-1., Double_t labSize=-1., Int_t labAlign=-1, Int_t labColor=-1, Int_t labFont=-1, const TString &labText="""");  Define new text attributes for the label number ""labNum"". ;  ; void ChangeLabelByValue (Double_t labValue, Double_t labAngle=-1., Double_t labSize=-1., Int_t labAlign=-1, Int_t labColor=-1, Int_t labFont=-1, const TString &labText="""");  Define new text attributes for the label value ""labValue"". ;  ; const char * ChooseTimeFormat (Double_t axislength=0);  Choose a reasonable time format from the coordinates in the active pad and the number of div",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:7825,Modifiability,inherit,inherited,7825,"ufirst, Double_t ulast);  Set the viewing range for the axis from ufirst to ulast (in user coordinates, that is, the ""natural"" axis coordinates). ;  ; virtual void SetTicks (Option_t *option=""+"");  Set ticks orientation. ;  ; virtual void SetTimeDisplay (Int_t value);  ; virtual void SetTimeFormat (const char *format="""");  Change the format used for time plotting. ;  ; virtual void SetTimeOffset (Double_t toffset, Option_t *option=""local"");  Change the time offset If option = ""gmt"", set display mode to GMT. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TAxis. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UnZoom ();  Reset first & last bin to the full range. ;  ; virtual void ZoomOut (Double_t factor=0, Double_t offset=0);  Zoom out by a factor of 'factor' (default =2) uses previous zoom factor by default Keep center defined by 'offset' fixed ie. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ; ",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:9484,Modifiability,inherit,inherited,9484,"fer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtua",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:10394,Modifiability,inherit,inheritance,10394," StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:12121,Modifiability,inherit,inherits,12121,"e) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:12238,Modifiability,inherit,inherits,12238,"t be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is necessary). ;  ; virtual Bool_t Notify ();  This method must be overridden to handle object notification (the base ",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:15710,Modifiability,inherit,inherited,15710,"_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TAttAxis;  TAttAxis ();  ; virtual ~TAttAxis ();  Destructor. ;  ; void Copy (TAttAxis &attaxis) const;  Copy of the object. ;  ; virtual Color_t GetAxisColor () const;  ; virtual Color_t GetLabelColor () const;  ; virtual Style_t GetLabelFont () const;  ; virtual Float_t GetLabelOffset () const;  ; virtual Float_t GetLabelSize () const;  ; virtual Int_t GetMaxDigits () const;  ; virtual Int_t GetNdivisions () const;  ; virtual Float_t GetTickLength () const;  ; virtual Color_t GetTitleColor () const;  ; virtual Style_t GetTitleFont () const;  ; virtual Float_t GetTitleOffset () const;  ; virtual Float_t GetTitleSize () const;  ; virtual void ResetAttAxis (Option_t *option="""");  Reset axis attributes. ;  ; virtual void SetAxisColor (Color_t color=1, Float_t alpha=1.);  Set color of the line axis and tick marks. ;  ; virtual void SetLabelColor (Color_t color=1, Float_t alpha=1.);  Set color of labels. ;  ; virtual void SetLabelFont (Style_t font=62);  Set labels' font. ;  ; virtual void SetLabe",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:18002,Modifiability,inherit,inherited,18002,"(Int_t n=510, Bool_t optim=kTRUE);  Set the number of divisions for this axis. ;  ; virtual void SetTickLength (Float_t length=0.03);  Set tick mark length. ;  ; virtual void SetTickSize (Float_t size=0.03);  ; virtual void SetTitleColor (Color_t color=1);  Set color of axis title. ;  ; virtual void SetTitleFont (Style_t font=62);  Set the title font. ;  ; virtual void SetTitleOffset (Float_t offset=1);  Set distance between the axis and the axis title. ;  ; virtual void SetTitleSize (Float_t size=0.04);  Set size of axis title. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Private Member Functions; RooAbsRealLValue * rvar () const;  ; RooAbsLValue * var () const;  . Additional Inherited Members;  Public Types inherited from TAxis; enum  EStatusBits { ;   kDecimals = (1ULL << ( 7 )); , kTickPlus = (1ULL << ( 9 )); , kTickMinus = (1ULL << ( 10 )); , kAxisRange = (1ULL << ( 11 )); , ;   kCenterTitle = (1ULL << ( 12 )); , kCenterLabels = (1ULL << ( 14 )); , kRotateTitle = (1ULL << ( 15 )); , kPalette = (1ULL << ( 16 )); , ;   kNoExponent = (1ULL << ( 17 )); , kLabelsHori = (1ULL << ( 18 )); , kLabelsVert = (1ULL << ( 19 )); , kLabelsDown = (1ULL << ( 20 )); , ;   kLabelsUp = (1ULL << ( 21 )); , kIsInteger = (1ULL << ( 22 )); , kMoreLogLabels = (1ULL << ( 23 )). };  TAxis status bits. More...;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Fun",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:18610,Modifiability,inherit,inherited,18610,"n the axis and the axis title. ;  ; virtual void SetTitleSize (Float_t size=0.04);  Set size of axis title. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Private Member Functions; RooAbsRealLValue * rvar () const;  ; RooAbsLValue * var () const;  . Additional Inherited Members;  Public Types inherited from TAxis; enum  EStatusBits { ;   kDecimals = (1ULL << ( 7 )); , kTickPlus = (1ULL << ( 9 )); , kTickMinus = (1ULL << ( 10 )); , kAxisRange = (1ULL << ( 11 )); , ;   kCenterTitle = (1ULL << ( 12 )); , kCenterLabels = (1ULL << ( 14 )); , kRotateTitle = (1ULL << ( 15 )); , kPalette = (1ULL << ( 16 )); , ;   kNoExponent = (1ULL << ( 17 )); , kLabelsHori = (1ULL << ( 18 )); , kLabelsVert = (1ULL << ( 19 )); , kLabelsDown = (1ULL << ( 20 )); , ;   kLabelsUp = (1ULL << ( 21 )); , kIsInteger = (1ULL << ( 22 )); , kMoreLogLabels = (1ULL << ( 23 )). };  TAxis status bits. More...;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TAxis; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions i",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:19266,Modifiability,inherit,inherited,19266,"s bits. More...;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TAxis; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttAxis; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location,",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:19475,Modifiability,inherit,inherited,19475,"s bits. More...;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TAxis; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttAxis; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location,",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:19685,Modifiability,inherit,inherited,19685,"s bits. More...;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TAxis; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttAxis; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location,",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:20203,Modifiability,inherit,inherited,20203," const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttAxis; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttAxis; Color_t fAxisColor;  Color of the line axis. ;  ; Color_t fLabelColor;  Color of labels. ;  ; Style_t fLabelFont;  Font for labels. ;  ; Float_t fLabelOffset;  Offset of labels. ;  ; Float_t fLabelSize;  Size of labels. ;  ; Int_t fNdivisions;  Number of divisions(10000*n3 + 100*n2 + n1) ;  ; Float_t fTickLength;  Length of tick marks. ;  ; Color_t fTitleColor;  Color of axis title. ;  ; Style_t fTitleFont;  Font for axis title. ;  ; Float_t fTitleOffset;  Offset of axis title. ;  ; Float_t fTitleSize;  Size of axis title. ;  . Inheritance diagram for Axis2:. This browser is not able to show",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:20400,Modifiability,inherit,inherited,20400," const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttAxis; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttAxis; Color_t fAxisColor;  Color of the line axis. ;  ; Color_t fLabelColor;  Color of labels. ;  ; Style_t fLabelFont;  Font for labels. ;  ; Float_t fLabelOffset;  Offset of labels. ;  ; Float_t fLabelSize;  Size of labels. ;  ; Int_t fNdivisions;  Number of divisions(10000*n3 + 100*n2 + n1) ;  ; Float_t fTickLength;  Length of tick marks. ;  ; Color_t fTitleColor;  Color of axis title. ;  ; Style_t fTitleFont;  Font for axis title. ;  ; Float_t fTitleOffset;  Offset of axis title. ;  ; Float_t fTitleSize;  Size of axis title. ;  . Inheritance diagram for Axis2:. This browser is not able to show",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:20499,Modifiability,inherit,inherited,20499," const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttAxis; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttAxis; Color_t fAxisColor;  Color of the line axis. ;  ; Color_t fLabelColor;  Color of labels. ;  ; Style_t fLabelFont;  Font for labels. ;  ; Float_t fLabelOffset;  Offset of labels. ;  ; Float_t fLabelSize;  Size of labels. ;  ; Int_t fNdivisions;  Number of divisions(10000*n3 + 100*n2 + n1) ;  ; Float_t fTickLength;  Length of tick marks. ;  ; Color_t fTitleColor;  Color of axis title. ;  ; Style_t fTitleFont;  Font for axis title. ;  ; Float_t fTitleOffset;  Offset of axis title. ;  ; Float_t fTitleSize;  Size of axis title. ;  . Inheritance diagram for Axis2:. This browser is not able to show",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:20704,Modifiability,inherit,inherited,20704,"r * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttAxis; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttAxis; Color_t fAxisColor;  Color of the line axis. ;  ; Color_t fLabelColor;  Color of labels. ;  ; Style_t fLabelFont;  Font for labels. ;  ; Float_t fLabelOffset;  Offset of labels. ;  ; Float_t fLabelSize;  Size of labels. ;  ; Int_t fNdivisions;  Number of divisions(10000*n3 + 100*n2 + n1) ;  ; Float_t fTickLength;  Length of tick marks. ;  ; Color_t fTitleColor;  Color of axis title. ;  ; Style_t fTitleFont;  Font for axis title. ;  ; Float_t fTitleOffset;  Offset of axis title. ;  ; Float_t fTitleSize;  Size of axis title. ;  . Inheritance diagram for Axis2:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Function Documentation. ◆ binning(). const RooAbsBinning * Axis2::binning ; (; ); const. inline . Definition at line 901 of file xRooNode.cxx. ◆ FindFixBin() [1/2]. Int_t Axis2::FindFixBin ; (; const char * ; label); const. inlineoverridevirtual . Find bin number with label",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:20786,Modifiability,inherit,inherited,20786,"r * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttAxis; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttAxis; Color_t fAxisColor;  Color of the line axis. ;  ; Color_t fLabelColor;  Color of labels. ;  ; Style_t fLabelFont;  Font for labels. ;  ; Float_t fLabelOffset;  Offset of labels. ;  ; Float_t fLabelSize;  Size of labels. ;  ; Int_t fNdivisions;  Number of divisions(10000*n3 + 100*n2 + n1) ;  ; Float_t fTickLength;  Length of tick marks. ;  ; Color_t fTitleColor;  Color of axis title. ;  ; Style_t fTitleFont;  Font for axis title. ;  ; Float_t fTitleOffset;  Offset of axis title. ;  ; Float_t fTitleSize;  Size of axis title. ;  . Inheritance diagram for Axis2:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Function Documentation. ◆ binning(). const RooAbsBinning * Axis2::binning ; (; ); const. inline . Definition at line 901 of file xRooNode.cxx. ◆ FindFixBin() [1/2]. Int_t Axis2::FindFixBin ; (; const char * ; label); const. inlineoverridevirtual . Find bin number with label",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:22214,Modifiability,extend,extend,22214,"  Color of axis title. ;  ; Style_t fTitleFont;  Font for axis title. ;  ; Float_t fTitleOffset;  Offset of axis title. ;  ; Float_t fTitleSize;  Size of axis title. ;  . Inheritance diagram for Axis2:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Function Documentation. ◆ binning(). const RooAbsBinning * Axis2::binning ; (; ); const. inline . Definition at line 901 of file xRooNode.cxx. ◆ FindFixBin() [1/2]. Int_t Axis2::FindFixBin ; (; const char * ; label); const. inlineoverridevirtual . Find bin number with label. ; If the List of labels does not exist or the label does not exist just return -1 . Do not attempt to modify the axis. This is different than FindBin ; Reimplemented from TAxis.; Definition at line 903 of file xRooNode.cxx. ◆ FindFixBin() [2/2]. Int_t Axis2::FindFixBin ; (; double ; x); const. inlineoverridevirtual . Find bin number corresponding to abscissa x. ; Identical to TAxis::FindBin except that if x is an underflow/overflow no attempt is made to extend the axis. ; Reimplemented from TAxis.; Definition at line 904 of file xRooNode.cxx. ◆ GetBinLowEdge(). double Axis2::GetBinLowEdge ; (; Int_t ; bin); const. inlineoverridevirtual . Return low edge of bin. ; Reimplemented from TAxis.; Definition at line 853 of file xRooNode.cxx. ◆ GetBinUpEdge(). double Axis2::GetBinUpEdge ; (; Int_t ; bin); const. inlineoverridevirtual . Return up edge of bin. ; Reimplemented from TAxis.; Definition at line 861 of file xRooNode.cxx. ◆ GetBinWidth(). double Axis2::GetBinWidth ; (; Int_t ; bin); const. inlineoverridevirtual . Return bin width. ; Reimplemented from TAxis.; Definition at line 847 of file xRooNode.cxx. ◆ GetTitle(). const char * Axis2::GetTitle ; (; ); const. inlineoverridevirtual . Returns title of object. ; This default method returns the class title (i.e. description). Classes that give objects a title should override this method. ; Reimplemented from TObject.; Definition at line 868 of file ",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:23432,Modifiability,variab,variable,23432,"Reimplemented from TAxis.; Definition at line 853 of file xRooNode.cxx. ◆ GetBinUpEdge(). double Axis2::GetBinUpEdge ; (; Int_t ; bin); const. inlineoverridevirtual . Return up edge of bin. ; Reimplemented from TAxis.; Definition at line 861 of file xRooNode.cxx. ◆ GetBinWidth(). double Axis2::GetBinWidth ; (; Int_t ; bin); const. inlineoverridevirtual . Return bin width. ; Reimplemented from TAxis.; Definition at line 847 of file xRooNode.cxx. ◆ GetTitle(). const char * Axis2::GetTitle ; (; ); const. inlineoverridevirtual . Returns title of object. ; This default method returns the class title (i.e. description). Classes that give objects a title should override this method. ; Reimplemented from TObject.; Definition at line 868 of file xRooNode.cxx. ◆ rvar(). RooAbsRealLValue * Axis2::rvar ; (; ); const. inlineprivate . Definition at line 908 of file xRooNode.cxx. ◆ Set() [1/3]. void Axis2::Set ; (; Int_t ; nbins, . const double * ; xbins . ). inlineoverridevirtual . Initialize axis with variable bins. ; Reimplemented from TAxis.; Definition at line 881 of file xRooNode.cxx. ◆ Set() [2/3]. void Axis2::Set ; (; Int_t ; nbins, . const float * ; xbins . ). inlineoverridevirtual . Initialize axis with variable bins. ; Reimplemented from TAxis.; Definition at line 887 of file xRooNode.cxx. ◆ Set() [3/3]. void Axis2::Set ; (; Int_t ; nbins, . double ; xmin, . double ; xmax . ). inlineoverridevirtual . Initialize axis with fix bins. ; Reimplemented from TAxis.; Definition at line 894 of file xRooNode.cxx. ◆ SetTitle(). void Axis2::SetTitle ; (; const char * ; title). inlineoverridevirtual . Set the title of the TNamed. ; Reimplemented from TNamed.; Definition at line 872 of file xRooNode.cxx. ◆ TAxis() [1/4]. TAxis::TAxis ; (; ). Default constructor. ; Definition at line 79 of file TAxis.cxx. ◆ TAxis() [2/4]. TAxis::TAxis ; (; const TAxis & ; axis). Copy constructor. ; Definition at line 82 of file TAxis.cxx. ◆ TAxis() [3/4]. TAxis::TAxis ; (; Int_t ; nbins, . const Doubl",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:23646,Modifiability,variab,variable,23646,"is.; Definition at line 861 of file xRooNode.cxx. ◆ GetBinWidth(). double Axis2::GetBinWidth ; (; Int_t ; bin); const. inlineoverridevirtual . Return bin width. ; Reimplemented from TAxis.; Definition at line 847 of file xRooNode.cxx. ◆ GetTitle(). const char * Axis2::GetTitle ; (; ); const. inlineoverridevirtual . Returns title of object. ; This default method returns the class title (i.e. description). Classes that give objects a title should override this method. ; Reimplemented from TObject.; Definition at line 868 of file xRooNode.cxx. ◆ rvar(). RooAbsRealLValue * Axis2::rvar ; (; ); const. inlineprivate . Definition at line 908 of file xRooNode.cxx. ◆ Set() [1/3]. void Axis2::Set ; (; Int_t ; nbins, . const double * ; xbins . ). inlineoverridevirtual . Initialize axis with variable bins. ; Reimplemented from TAxis.; Definition at line 881 of file xRooNode.cxx. ◆ Set() [2/3]. void Axis2::Set ; (; Int_t ; nbins, . const float * ; xbins . ). inlineoverridevirtual . Initialize axis with variable bins. ; Reimplemented from TAxis.; Definition at line 887 of file xRooNode.cxx. ◆ Set() [3/3]. void Axis2::Set ; (; Int_t ; nbins, . double ; xmin, . double ; xmax . ). inlineoverridevirtual . Initialize axis with fix bins. ; Reimplemented from TAxis.; Definition at line 894 of file xRooNode.cxx. ◆ SetTitle(). void Axis2::SetTitle ; (; const char * ; title). inlineoverridevirtual . Set the title of the TNamed. ; Reimplemented from TNamed.; Definition at line 872 of file xRooNode.cxx. ◆ TAxis() [1/4]. TAxis::TAxis ; (; ). Default constructor. ; Definition at line 79 of file TAxis.cxx. ◆ TAxis() [2/4]. TAxis::TAxis ; (; const TAxis & ; axis). Copy constructor. ; Definition at line 82 of file TAxis.cxx. ◆ TAxis() [3/4]. TAxis::TAxis ; (; Int_t ; nbins, . const Double_t * ; xbins . ). Axis constructor for variable bin size. ; Definition at line 81 of file TAxis.cxx. ◆ TAxis() [4/4]. TAxis::TAxis ; (; Int_t ; nbins, . Double_t ; xmin, . Double_t ; xmax . ). Axis constructor for",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:24468,Modifiability,variab,variable,24468,"s title of object. ; This default method returns the class title (i.e. description). Classes that give objects a title should override this method. ; Reimplemented from TObject.; Definition at line 868 of file xRooNode.cxx. ◆ rvar(). RooAbsRealLValue * Axis2::rvar ; (; ); const. inlineprivate . Definition at line 908 of file xRooNode.cxx. ◆ Set() [1/3]. void Axis2::Set ; (; Int_t ; nbins, . const double * ; xbins . ). inlineoverridevirtual . Initialize axis with variable bins. ; Reimplemented from TAxis.; Definition at line 881 of file xRooNode.cxx. ◆ Set() [2/3]. void Axis2::Set ; (; Int_t ; nbins, . const float * ; xbins . ). inlineoverridevirtual . Initialize axis with variable bins. ; Reimplemented from TAxis.; Definition at line 887 of file xRooNode.cxx. ◆ Set() [3/3]. void Axis2::Set ; (; Int_t ; nbins, . double ; xmin, . double ; xmax . ). inlineoverridevirtual . Initialize axis with fix bins. ; Reimplemented from TAxis.; Definition at line 894 of file xRooNode.cxx. ◆ SetTitle(). void Axis2::SetTitle ; (; const char * ; title). inlineoverridevirtual . Set the title of the TNamed. ; Reimplemented from TNamed.; Definition at line 872 of file xRooNode.cxx. ◆ TAxis() [1/4]. TAxis::TAxis ; (; ). Default constructor. ; Definition at line 79 of file TAxis.cxx. ◆ TAxis() [2/4]. TAxis::TAxis ; (; const TAxis & ; axis). Copy constructor. ; Definition at line 82 of file TAxis.cxx. ◆ TAxis() [3/4]. TAxis::TAxis ; (; Int_t ; nbins, . const Double_t * ; xbins . ). Axis constructor for variable bin size. ; Definition at line 81 of file TAxis.cxx. ◆ TAxis() [4/4]. TAxis::TAxis ; (; Int_t ; nbins, . Double_t ; xmin, . Double_t ; xmax . ). Axis constructor for axis with fix bin size. ; Definition at line 80 of file TAxis.cxx. ◆ var(). RooAbsLValue * Axis2::var ; (; ); const. inlineprivate . Definition at line 907 of file xRooNode.cxx. roofit/xroofit/src/xRooNode.cxx. Axis2. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:8693,Security,hash,hash,8693," factor of 'factor' (default =2) uses previous zoom factor by default Keep center defined by 'offset' fixed ie. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const cha",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:3637,Testability,log,log,3637,"and the number of divisions in this axis If orientation = ""X"", the horizontal axis of the pad will be used for ref. ;  ; void Copy (TObject &axis) const override;  Copy axis structure to another axis. ;  ; void Delete (Option_t *="""") override;  Delete this object. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to an axis. ;  ; TObject * DrawClone (Option_t *="""") const override;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; void ExecuteEvent (Int_t event, Int_t px, Int_t py) override;  Execute action corresponding to one event. ;  ; virtual Int_t FindBin (const char *label);  Find bin number with label. ;  ; virtual Int_t FindBin (Double_t x);  Find bin number corresponding to abscissa x. ;  ; virtual Int_t FindBin (Double_t x) const;  ; virtual Double_t GetBinCenter (Int_t bin) const;  Return center of bin. ;  ; virtual Double_t GetBinCenterLog (Int_t bin) const;  Return center of bin in log With a log-equidistant binning for a bin with low and up edges, the mean is : 0.5*(ln low + ln up) i.e. ;  ; const char * GetBinLabel (Int_t bin) const;  Return label for bin. ;  ; virtual void GetCenter (Double_t *center) const;  Return an array with the center of all bins. ;  ; Bool_t GetCenterLabels () const;  ; Bool_t GetCenterTitle () const;  ; Bool_t GetDecimals () const;  ; Int_t GetFirst () const;  Return first bin on the axis i.e. ;  ; THashList * GetLabels () const;  ; Int_t GetLast () const;  Return last bin on the axis i.e. ;  ; virtual void GetLowEdge (Double_t *edge) const;  Return an array with the low edge of all bins. ;  ; TList * GetModifiedLabels () const;  ; Bool_t GetMoreLogLabels () const;  ; Int_t GetNbins () const;  ; Int_t GetNlabels () const;  Return the number of axis labels. ;  ; Bool_t GetNoExponent () const;  ; virtual TObject * GetParent () const;  ; Bool_t GetRotateTitle () const;  ; virtual const char * GetTicks () const;  Return the ticks option (se",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:3648,Testability,log,log-equidistant,3648,"and the number of divisions in this axis If orientation = ""X"", the horizontal axis of the pad will be used for ref. ;  ; void Copy (TObject &axis) const override;  Copy axis structure to another axis. ;  ; void Delete (Option_t *="""") override;  Delete this object. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to an axis. ;  ; TObject * DrawClone (Option_t *="""") const override;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; void ExecuteEvent (Int_t event, Int_t px, Int_t py) override;  Execute action corresponding to one event. ;  ; virtual Int_t FindBin (const char *label);  Find bin number with label. ;  ; virtual Int_t FindBin (Double_t x);  Find bin number corresponding to abscissa x. ;  ; virtual Int_t FindBin (Double_t x) const;  ; virtual Double_t GetBinCenter (Int_t bin) const;  Return center of bin. ;  ; virtual Double_t GetBinCenterLog (Int_t bin) const;  Return center of bin in log With a log-equidistant binning for a bin with low and up edges, the mean is : 0.5*(ln low + ln up) i.e. ;  ; const char * GetBinLabel (Int_t bin) const;  Return label for bin. ;  ; virtual void GetCenter (Double_t *center) const;  Return an array with the center of all bins. ;  ; Bool_t GetCenterLabels () const;  ; Bool_t GetCenterTitle () const;  ; Bool_t GetDecimals () const;  ; Int_t GetFirst () const;  Return first bin on the axis i.e. ;  ; THashList * GetLabels () const;  ; Int_t GetLast () const;  Return last bin on the axis i.e. ;  ; virtual void GetLowEdge (Double_t *edge) const;  Return an array with the low edge of all bins. ;  ; TList * GetModifiedLabels () const;  ; Bool_t GetMoreLogLabels () const;  ; Int_t GetNbins () const;  ; Int_t GetNlabels () const;  Return the number of axis labels. ;  ; Bool_t GetNoExponent () const;  ; virtual TObject * GetParent () const;  ; Bool_t GetRotateTitle () const;  ; virtual const char * GetTicks () const;  Return the ticks option (se",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classAxis2.html:6390,Testability,log,log,6390,"n_t *option=""h"");  Set option(s) to draw axis with labels option can be: ;  ; TAxis & operator= (const TAxis &);  Assignment operator. ;  ; void RotateTitle (Bool_t rotate=kTRUE);  Rotate title by 180 degrees. ;  ; void SaveAttributes (std::ostream &out, const char *name, const char *subname) override;  Save axis attributes as C++ statement(s) on output stream out. ;  ; void SetAlphanumeric (Bool_t alphanumeric=kTRUE);  Set axis alphanumeric. ;  ; virtual void SetBinLabel (Int_t bin, const char *label);  Set label for bin. ;  ; void SetCanExtend (Bool_t canExtend);  ; void SetDecimals (Bool_t dot=kTRUE);  Sets the decimals flag By default, blank characters are stripped, and then the label is correctly aligned. ;  ; virtual void SetDefaults ();  Set axis default values (from TStyle) ;  ; void SetDrawOption (Option_t *="""") override;  Set drawing option for object. ;  ; virtual void SetLimits (Double_t xmin, Double_t xmax);  ; void SetMoreLogLabels (Bool_t more=kTRUE);  Set the kMoreLogLabels bit flag When this option is selected more labels are drawn when in log scale and there is a small number of decades (<3). ;  ; void SetNoAlphanumeric (Bool_t noalpha=kTRUE);  ; void SetNoExponent (Bool_t noExponent=kTRUE);  Set the NoExponent flag By default, an exponent of the form 10^N is used when the label value are either all very small or very large. ;  ; virtual void SetParent (TObject *obj);  ; virtual void SetRange (Int_t first=0, Int_t last=0);  Set the viewing range for the axis using bin numbers. ;  ; virtual void SetRangeUser (Double_t ufirst, Double_t ulast);  Set the viewing range for the axis from ufirst to ulast (in user coordinates, that is, the ""natural"" axis coordinates). ;  ; virtual void SetTicks (Option_t *option=""+"");  Set ticks orientation. ;  ; virtual void SetTimeDisplay (Int_t value);  ; virtual void SetTimeFormat (const char *format="""");  Change the format used for time plotting. ;  ; virtual void SetTimeOffset (Double_t toffset, Option_t *option=""loca",MatchSource.WIKI,doc/master/classAxis2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classAxis2.html
https://root.cern/doc/master/classDummyObject.html:2105,Availability,error,error,2105,"object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Return",MatchSource.WIKI,doc/master/classDummyObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classDummyObject.html
https://root.cern/doc/master/classDummyObject.html:2194,Availability,error,error,2194,"ar *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns strin",MatchSource.WIKI,doc/master/classDummyObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classDummyObject.html
https://root.cern/doc/master/classDummyObject.html:2349,Availability,error,error,2349,";  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title o",MatchSource.WIKI,doc/master/classDummyObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classDummyObject.html
https://root.cern/doc/master/classDummyObject.html:2646,Availability,error,error,2646,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash",MatchSource.WIKI,doc/master/classDummyObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classDummyObject.html
https://root.cern/doc/master/classDummyObject.html:7320,Availability,error,error,7320,"ead (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum",MatchSource.WIKI,doc/master/classDummyObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classDummyObject.html
https://root.cern/doc/master/classDummyObject.html:2111,Integrability,message,message,2111,"object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Return",MatchSource.WIKI,doc/master/classDummyObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classDummyObject.html
https://root.cern/doc/master/classDummyObject.html:2652,Integrability,message,message,2652,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash",MatchSource.WIKI,doc/master/classDummyObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classDummyObject.html
https://root.cern/doc/master/classDummyObject.html:3854,Integrability,message,message,3854,"ived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; virtual TClass * IsA () const;  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const ch",MatchSource.WIKI,doc/master/classDummyObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classDummyObject.html
https://root.cern/doc/master/classDummyObject.html:7326,Integrability,message,message,7326,"ead (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum",MatchSource.WIKI,doc/master/classDummyObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classDummyObject.html
https://root.cern/doc/master/classDummyObject.html:7699,Integrability,message,message,7699,"rimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited ",MatchSource.WIKI,doc/master/classDummyObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classDummyObject.html
https://root.cern/doc/master/classDummyObject.html:344,Modifiability,inherit,inherited,344,". ROOT: DummyObject Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; List of all members ; DummyObject Class Reference. . Definition at line 56 of file rootqt5.cpp. Public Member Functions;  ~DummyObject () override;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents ",MatchSource.WIKI,doc/master/classDummyObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classDummyObject.html
https://root.cern/doc/master/classDummyObject.html:1741,Modifiability,inherit,inheritance,1741,"pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in de",MatchSource.WIKI,doc/master/classDummyObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classDummyObject.html
https://root.cern/doc/master/classDummyObject.html:3952,Modifiability,inherit,inherits,3952,"ed by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; virtual TClass * IsA () const;  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a b",MatchSource.WIKI,doc/master/classDummyObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classDummyObject.html
https://root.cern/doc/master/classDummyObject.html:4069,Modifiability,inherit,inherits,4069,"ame of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; virtual TClass * IsA () const;  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not pro",MatchSource.WIKI,doc/master/classDummyObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classDummyObject.html
https://root.cern/doc/master/classDummyObject.html:8025,Modifiability,inherit,inherited,8025,"  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObject",MatchSource.WIKI,doc/master/classDummyObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classDummyObject.html
https://root.cern/doc/master/classDummyObject.html:8681,Modifiability,inherit,inherited,8681,"bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Inheritance diagram for DummyObject:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ~DummyObject(). DummyObject::~DummyObject ; (; ). inlineoverride . Definition at line 58 of file rootqt5.cpp. gui/qt5webdisplay/rootqt5.cpp.",MatchSource.WIKI,doc/master/classDummyObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classDummyObject.html
https://root.cern/doc/master/classDummyObject.html:9184,Modifiability,inherit,inherited,9184,"ion=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Inheritance diagram for DummyObject:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ~DummyObject(). DummyObject::~DummyObject ; (; ). inlineoverride . Definition at line 58 of file rootqt5.cpp. gui/qt5webdisplay/rootqt5.cpp. DummyObject. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:35 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/classDummyObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classDummyObject.html
https://root.cern/doc/master/classDummyObject.html:9283,Modifiability,inherit,inherited,9283,"ion=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Inheritance diagram for DummyObject:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ~DummyObject(). DummyObject::~DummyObject ; (; ). inlineoverride . Definition at line 58 of file rootqt5.cpp. gui/qt5webdisplay/rootqt5.cpp. DummyObject. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:35 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/classDummyObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classDummyObject.html
https://root.cern/doc/master/classDummyObject.html:3583,Security,hash,hash,3583," Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; virtual TClass * IsA () const;  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other obje",MatchSource.WIKI,doc/master/classDummyObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classDummyObject.html
https://root.cern/doc/master/classfileDesc.html:3681,Availability,error,error,3681,"ject. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t ",MatchSource.WIKI,doc/master/classfileDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classfileDesc.html
https://root.cern/doc/master/classfileDesc.html:3770,Availability,error,error,3770,"ecord whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual ",MatchSource.WIKI,doc/master/classfileDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classfileDesc.html
https://root.cern/doc/master/classfileDesc.html:3925,Availability,error,error,3925,"Name () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute ",MatchSource.WIKI,doc/master/classfileDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classfileDesc.html
https://root.cern/doc/master/classfileDesc.html:4222,Availability,error,error,4222,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info ",MatchSource.WIKI,doc/master/classfileDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classfileDesc.html
https://root.cern/doc/master/classfileDesc.html:8306,Availability,error,error,8306,"n object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Public Attributes; TString fDesc;  ; Long_t fMtime;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL ",MatchSource.WIKI,doc/master/classfileDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classfileDesc.html
https://root.cern/doc/master/classfileDesc.html:3687,Integrability,message,message,3687,"ject. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t ",MatchSource.WIKI,doc/master/classfileDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classfileDesc.html
https://root.cern/doc/master/classfileDesc.html:4228,Integrability,message,message,4228,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info ",MatchSource.WIKI,doc/master/classfileDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classfileDesc.html
https://root.cern/doc/master/classfileDesc.html:5218,Integrability,message,message,5218,"ssue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class shou",MatchSource.WIKI,doc/master/classfileDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classfileDesc.html
https://root.cern/doc/master/classfileDesc.html:8312,Integrability,message,message,8312,"n object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Public Attributes; TString fDesc;  ; Long_t fMtime;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL ",MatchSource.WIKI,doc/master/classfileDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classfileDesc.html
https://root.cern/doc/master/classfileDesc.html:8685,Integrability,message,message,8685," Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Public Attributes; TString fDesc;  ; Long_t fMtime;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( ",MatchSource.WIKI,doc/master/classfileDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classfileDesc.html
https://root.cern/doc/master/classfileDesc.html:484,Modifiability,inherit,inherited,484,". ROOT: fileDesc Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; fileDesc Class Reference. . Definition at line 741 of file TProofBench.cxx. Public Member Functions;  fileDesc (const char *n, const char *o, Long_t t, const char *d);  ; Int_t Compare (const TObject *o) const override;  Compare abstract method. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () cons",MatchSource.WIKI,doc/master/classfileDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classfileDesc.html
https://root.cern/doc/master/classfileDesc.html:2224,Modifiability,inherit,inherited,2224,"ide;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw",MatchSource.WIKI,doc/master/classfileDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classfileDesc.html
https://root.cern/doc/master/classfileDesc.html:3317,Modifiability,inherit,inheritance,3317,"  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in de",MatchSource.WIKI,doc/master/classfileDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classfileDesc.html
https://root.cern/doc/master/classfileDesc.html:5316,Modifiability,inherit,inherits,5316,"e) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is",MatchSource.WIKI,doc/master/classfileDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classfileDesc.html
https://root.cern/doc/master/classfileDesc.html:5433,Modifiability,inherit,inherits,5433,"t be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is necessary). ;  ; virtual Bool_t Notify ();  This method must be overridden to handle object notification (the base ",MatchSource.WIKI,doc/master/classfileDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classfileDesc.html
https://root.cern/doc/master/classfileDesc.html:9066,Modifiability,inherit,inherited,9066,"e unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Public Attributes; TString fDesc;  ; Long_t fMtime;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t G",MatchSource.WIKI,doc/master/classfileDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classfileDesc.html
https://root.cern/doc/master/classfileDesc.html:9722,Modifiability,inherit,inherited,9722," object to the current directory. ;  . Public Attributes; TString fDesc;  ; Long_t fMtime;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Inheritance diagram for fileDesc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]",MatchSource.WIKI,doc/master/classfileDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classfileDesc.html
https://root.cern/doc/master/classfileDesc.html:9932,Modifiability,inherit,inherited,9932," object to the current directory. ;  . Public Attributes; TString fDesc;  ; Long_t fMtime;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Inheritance diagram for fileDesc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]",MatchSource.WIKI,doc/master/classfileDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classfileDesc.html
https://root.cern/doc/master/classfileDesc.html:10435,Modifiability,inherit,inherited,10435,"UUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Inheritance diagram for fileDesc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ fileDesc(). fileDesc::fileDesc ; (; const char * ; n, . const char * ; o, . Long_t ; t, . const char * ; d . ). inline . Definition at line 745 of file TProofBench.cxx. Member Function Documentation. ◆ Compare(). Int_t fileDesc::Compare ; (; const TObject * ; obj); const. inlineoverridevirtual . Compare abstract method. ; Must be overridden if a class wants to be able to compare itself with other objects. Must return -1 if this is smaller than obj, 0 if objects are equal and 1 if this is larger than obj. ; Reimplemented from TObject.; Definition at line 747 of file TProof",MatchSource.WIKI,doc/master/classfileDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classfileDesc.html
https://root.cern/doc/master/classfileDesc.html:10534,Modifiability,inherit,inherited,10534,"UUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Inheritance diagram for fileDesc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ fileDesc(). fileDesc::fileDesc ; (; const char * ; n, . const char * ; o, . Long_t ; t, . const char * ; d . ). inline . Definition at line 745 of file TProofBench.cxx. Member Function Documentation. ◆ Compare(). Int_t fileDesc::Compare ; (; const TObject * ; obj); const. inlineoverridevirtual . Compare abstract method. ; Must be overridden if a class wants to be able to compare itself with other objects. Must return -1 if this is smaller than obj, 0 if objects are equal and 1 if this is larger than obj. ; Reimplemented from TObject.; Definition at line 747 of file TProof",MatchSource.WIKI,doc/master/classfileDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classfileDesc.html
https://root.cern/doc/master/classfileDesc.html:10739,Modifiability,inherit,inherited,10739,"; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Inheritance diagram for fileDesc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ fileDesc(). fileDesc::fileDesc ; (; const char * ; n, . const char * ; o, . Long_t ; t, . const char * ; d . ). inline . Definition at line 745 of file TProofBench.cxx. Member Function Documentation. ◆ Compare(). Int_t fileDesc::Compare ; (; const TObject * ; obj); const. inlineoverridevirtual . Compare abstract method. ; Must be overridden if a class wants to be able to compare itself with other objects. Must return -1 if this is smaller than obj, 0 if objects are equal and 1 if this is larger than obj. ; Reimplemented from TObject.; Definition at line 747 of file TProofBench.cxx. Member Data Documentation. ◆ fDesc. TString fileDesc::fDesc. Definition at line 744 of file TProofBench.cxx. ◆ fMtime. Long_t fileDesc::fMtime. Definition at line 743 of file TProofB",MatchSource.WIKI,doc/master/classfileDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classfileDesc.html
https://root.cern/doc/master/classfileDesc.html:1352,Security,hash,hash,1352,"har *o, Long_t t, const char *d);  ; Int_t Compare (const TObject *o) const override;  Compare abstract method. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,doc/master/classfileDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classfileDesc.html
https://root.cern/doc/master/classh1analysis.html:4213,Availability,error,error,4213,"object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Return",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:4302,Availability,error,error,4302,"ar *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns strin",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:4457,Availability,error,error,4457,";  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID ",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:4754,Availability,error,error,4754,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of thi",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:9147,Availability,error,error,9147," must be overridden when a class wants to print itself. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TSelector; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Versio",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:18939,Availability,avail,available,18939,"   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TSelector; EAbort fAbort;  Abort status. ;  ; TList * fInput;  List of objects available during processing. ;  ; TObject * fObject;  ! Current object if processing object (vs. TTree) ;  ; TString fOption;  Option given to TTree::Process. ;  ; TSelectorList * fOutput;  ! List of objects created during processing ;  ; Long64_t fStatus;  Selector status. ;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/h1analysis.h>. Inheritance diagram for h1analysis:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ h1analysis(). h1analysis::h1analysis ; (; TTree * ; tree = nullptr). Definition at line 369 of file h1analysis.h. ◆ ~h1analysis(). h1analysis::~h1analysis ; (; ). inlineoverride . Definition at line 345 of file h1analysis.h. Member Function Documentation. ◆ Begin(). void h1analysis::Begin ; (; TTree * ; tree). overridevirtual . Reimplemented from TSelector. ◆ Class(). static TClass * h1analysis::Class ; (; ). static . Ret",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:22086,Availability,avail,available,22086,"ification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject.; Definition at line 554 of file h1analysis.h. ◆ Process(). Bool_t h1analysis::Process ; (; Long64_t ; ). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used.; WARNING when a selector is used with a TChain, you must use the pointer to the current TTree to call GetEntry(entry). The entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use: fChain->GetTree()->GetEntry(entry). ; Reimplemented from TSelector. ◆ Reset(). void h1analysis::Reset ; (; ). Definition at line 376 of file h1analysis.h. ◆ SetInputList(). void h1analysis::SetInputList ; (; TList * ; input). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 356 of file h1analysis.h. ◆ SetObject(). void h1analys",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:4219,Integrability,message,message,4219,"object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Return",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:4760,Integrability,message,message,4760,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of thi",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:5920,Integrability,message,message,5920,"ect *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this metho",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:9153,Integrability,message,message,9153," must be overridden when a class wants to print itself. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TSelector; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Versio",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:9526,Integrability,message,message,9526," Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TSelector; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TSelector * GetSelector (const char *filename);  The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from TSelector. ;  ; static bool IsStandardDraw (const char *selec);  Find out if this is a standard selection used for Draw a",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:1334,Modifiability,inherit,inherited,1334,"at line 24 of file h1analysis.h. Public Member Functions;  h1analysis (TTree *tree=nullptr);  ;  ~h1analysis () override;  ; void Begin (TTree *tree) override;  ; TList * GetOutputList () const override;  ; void Init (TTree *tree) override;  ; TClass * IsA () const override;  ; Bool_t Notify () override;  This method must be overridden to handle object notification (the base implementation is no-op). ;  ; Bool_t Process (Long64_t entry) override;  The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ;  ; void Reset ();  ; void SetInputList (TList *input) override;  ; void SetObject (TObject *obj) override;  ; void SetOption (const char *option) override;  ; void SlaveBegin (TTree *tree) override;  ; void SlaveTerminate () override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Terminate () override;  ; int Version () const override;  ;  Public Member Functions inherited from TSelector;  TSelector ();  Default selector ctor. ;  ;  ~TSelector () override;  Selector destructor. ;  ; virtual void Abort (const char *why, EAbort what=kAbortProcess);  Abort processing. ;  ; virtual EAbort GetAbort () const;  ; virtual Int_t GetEntry (Long64_t, Int_t=0);  ; virtual TList * GetInputList () const;  ; const char * GetOption () const override;  ; virtual Long64_t GetStatus () const;  ; virtual void ImportOutput (TList *output);  Imports the content of 'output' in the internal output list. ;  ; TClass * IsA () const override;  ; bool Notify () override;  This method must be overridden to handle object notification (the base implementation is no-op). ;  ; virtual bool ProcessCut (Long64_t);  This method is called before processing entry. ;  ; virtual void ProcessFill (Long64_t);  This method is called for all selected entries. ;  ; virtual void ResetAbort ();  ; virtual void SetStatus (Long64_t status);  ; v",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:2452,Modifiability,inherit,inherited,2452,"ector destructor. ;  ; virtual void Abort (const char *why, EAbort what=kAbortProcess);  Abort processing. ;  ; virtual EAbort GetAbort () const;  ; virtual Int_t GetEntry (Long64_t, Int_t=0);  ; virtual TList * GetInputList () const;  ; const char * GetOption () const override;  ; virtual Long64_t GetStatus () const;  ; virtual void ImportOutput (TList *output);  Imports the content of 'output' in the internal output list. ;  ; TClass * IsA () const override;  ; bool Notify () override;  This method must be overridden to handle object notification (the base implementation is no-op). ;  ; virtual bool ProcessCut (Long64_t);  This method is called before processing entry. ;  ; virtual void ProcessFill (Long64_t);  This method is called for all selected entries. ;  ; virtual void ResetAbort ();  ; virtual void SetStatus (Long64_t status);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) c",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:3849,Modifiability,inherit,inheritance,3849,"pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in de",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:6018,Modifiability,inherit,inherits,6018,"t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a ",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:6135,Modifiability,inherit,inherits,6135,"GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its p",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:10027,Modifiability,inherit,inherited,10027," char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TSelector; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TSelector * GetSelector (const char *filename);  The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from TSelector. ;  ; static bool IsStandardDraw (const char *selec);  Find out if this is a standard selection used for Draw actions (either TSelectorDraw, TProofDraw or deriving from them). ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . P",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:10620,Modifiability,inherit,inherited,10620,"_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TSelector; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TSelector * GetSelector (const char *filename);  The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from TSelector. ;  ; static bool IsStandardDraw (const char *selec);  Find out if this is a standard selection used for Draw actions (either TSelectorDraw, TProofDraw or deriving from them). ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Public Attributes; Float_t aplan;  ; TBranch * b_aplan;  ; TBranch * b_covar;  ; TBranch * b_cpvtx_d;  ; TBranch * b_cpvtx_t;  ; TBranch * b_cvtxd0_r;  ; TBranch * b_dca;  ; TBranch * b_dca_d;  ; TBranch * b_dca_t;  ; TBranch * b_ddca_d;  ; TBranch * b_ddca_t;  ; TBranch * b_ddm_d;  ; TBranch * b_ddm_t;  ; TBranch * b_de33;  ; TBranch * b_de44;  ; TBranch * b_dept;  ; TBranch * b_dm_d;  ; TBranch * b_dm_t;  ; TBranch * b_dmd0_d;  ; TBranch * b_dmd0_t;  ; TBranch * b_drd0_d;  ; TBranch * b_drd0_dt;  ; TBranch * b_drd0_t;  ; TBranch * b_drd0_tt;  ; TBranch * b_drpd0_d;  ; TBranch * b_drpd0_t;  ; TBranch * b_dx3",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:17797,Modifiability,inherit,inherited,17797,"oat_t Q2elec [20];  ; Float_t Q2jbc;  ; Float_t Q2jbct;  ; Float_t Q2sigma [20];  ; Int_t qds;  ; Int_t rankds;  ; UChar_t rawtr [128];  ; Float_t rd0_d;  ; Float_t rd0_dt;  ; Float_t rd0_t;  ; Float_t rd0_tt;  ; Float_t rend [200];  ; Float_t rpd0_d;  ; Float_t rpd0_t;  ; Float_t rstart [200];  ; Float_t spher;  ; UChar_t subtr [128];  ; Float_t sumc [4];  ; Float_t sumct [4];  ; Float_t sumetc;  ; Float_t sumetct;  ; Float_t theta [200];  ; Float_t theta_j [20];  ; Float_t thetelec [20];  ; Float_t thrust;  ; Float_t thrust2;  ; UChar_t trelem [192];  ; Bool_t useList;  ; Float_t Vtxd0_r [3];  ; Float_t x33;  ; Float_t x44;  ; Float_t xeelec;  ; Float_t xelec [20];  ; Float_t xpt;  ; Float_t xsigma [20];  ; Float_t y33;  ; Float_t y44;  ; Float_t yeelec;  ; Float_t yjbc;  ; Float_t yjbct;  ; Float_t ypt;  ; Float_t z0 [200];  . Additional Inherited Members;  Public Types inherited from TSelector; enum  EAbort { kContinue; , kAbortProcess; , kAbortFile; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TSelector; EAbort fAbort;  Abort status. ;  ; TList",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:17900,Modifiability,inherit,inherited,17900,"oat_t Q2elec [20];  ; Float_t Q2jbc;  ; Float_t Q2jbct;  ; Float_t Q2sigma [20];  ; Int_t qds;  ; Int_t rankds;  ; UChar_t rawtr [128];  ; Float_t rd0_d;  ; Float_t rd0_dt;  ; Float_t rd0_t;  ; Float_t rd0_tt;  ; Float_t rend [200];  ; Float_t rpd0_d;  ; Float_t rpd0_t;  ; Float_t rstart [200];  ; Float_t spher;  ; UChar_t subtr [128];  ; Float_t sumc [4];  ; Float_t sumct [4];  ; Float_t sumetc;  ; Float_t sumetct;  ; Float_t theta [200];  ; Float_t theta_j [20];  ; Float_t thetelec [20];  ; Float_t thrust;  ; Float_t thrust2;  ; UChar_t trelem [192];  ; Bool_t useList;  ; Float_t Vtxd0_r [3];  ; Float_t x33;  ; Float_t x44;  ; Float_t xeelec;  ; Float_t xelec [20];  ; Float_t xpt;  ; Float_t xsigma [20];  ; Float_t y33;  ; Float_t y44;  ; Float_t yeelec;  ; Float_t yjbc;  ; Float_t yjbct;  ; Float_t ypt;  ; Float_t z0 [200];  . Additional Inherited Members;  Public Types inherited from TSelector; enum  EAbort { kContinue; , kAbortProcess; , kAbortFile; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TSelector; EAbort fAbort;  Abort status. ;  ; TList",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:18541,Modifiability,inherit,inherited,18541,"44;  ; Float_t yeelec;  ; Float_t yjbc;  ; Float_t yjbct;  ; Float_t ypt;  ; Float_t z0 [200];  . Additional Inherited Members;  Public Types inherited from TSelector; enum  EAbort { kContinue; , kAbortProcess; , kAbortFile; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TSelector; EAbort fAbort;  Abort status. ;  ; TList * fInput;  List of objects available during processing. ;  ; TObject * fObject;  ! Current object if processing object (vs. TTree) ;  ; TString fOption;  Option given to TTree::Process. ;  ; TSelectorList * fOutput;  ! List of objects created during processing ;  ; Long64_t fStatus;  Selector status. ;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/h1analysis.h>. Inheritance diagram for h1analysis:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ h1analysis(). h1analysis::h1analysis ; (; TTree * ; tree = nullptr). Definition at line 369 of file h1analysis.h. ◆ ~h1analysis(). h1analysis::~h1a",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:18640,Modifiability,inherit,inherited,18640,"44;  ; Float_t yeelec;  ; Float_t yjbc;  ; Float_t yjbct;  ; Float_t ypt;  ; Float_t z0 [200];  . Additional Inherited Members;  Public Types inherited from TSelector; enum  EAbort { kContinue; , kAbortProcess; , kAbortFile; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TSelector; EAbort fAbort;  Abort status. ;  ; TList * fInput;  List of objects available during processing. ;  ; TObject * fObject;  ! Current object if processing object (vs. TTree) ;  ; TString fOption;  Option given to TTree::Process. ;  ; TSelectorList * fOutput;  ! List of objects created during processing ;  ; Long64_t fStatus;  Selector status. ;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/h1analysis.h>. Inheritance diagram for h1analysis:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ h1analysis(). h1analysis::h1analysis ; (; TTree * ; tree = nullptr). Definition at line 369 of file h1analysis.h. ◆ ~h1analysis(). h1analysis::~h1a",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:18845,Modifiability,inherit,inherited,18845,"; , kAbortProcess; , kAbortFile; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TSelector; EAbort fAbort;  Abort status. ;  ; TList * fInput;  List of objects available during processing. ;  ; TObject * fObject;  ! Current object if processing object (vs. TTree) ;  ; TString fOption;  Option given to TTree::Process. ;  ; TSelectorList * fOutput;  ! List of objects created during processing ;  ; Long64_t fStatus;  Selector status. ;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/h1analysis.h>. Inheritance diagram for h1analysis:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ h1analysis(). h1analysis::h1analysis ; (; TTree * ; tree = nullptr). Definition at line 369 of file h1analysis.h. ◆ ~h1analysis(). h1analysis::~h1analysis ; (; ). inlineoverride . Definition at line 345 of file h1analysis.h. Member Function Documentation. ◆ Begin(). void h1analysis::Begin ; (; TTree * ; tree). overridevirtual . Reimplem",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:10288,Performance,load,loaded,10288," char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TSelector; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TSelector * GetSelector (const char *filename);  The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from TSelector. ;  ; static bool IsStandardDraw (const char *selec);  Find out if this is a standard selection used for Draw actions (either TSelectorDraw, TProofDraw or deriving from them). ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . P",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:21296,Performance,load,load,21296,"ation ; Definition at line 361 of file h1analysis.h. ◆ GetOutputList(). TList * h1analysis::GetOutputList ; (; ); const. inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 357 of file h1analysis.h. ◆ Init(). void h1analysis::Init ; (; TTree * ; tree). overridevirtual . Reimplemented from TSelector.; Definition at line 390 of file h1analysis.h. ◆ IsA(). TClass * h1analysis::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 361 of file h1analysis.h. ◆ Notify(). Bool_t h1analysis::Notify ; (; ). overridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject.; Definition at line 554 of file h1analysis.h. ◆ Process(). Bool_t h1analysis::Process ; (; Long64_t ; ). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return valu",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:21334,Performance,load,load,21334,"ation ; Definition at line 361 of file h1analysis.h. ◆ GetOutputList(). TList * h1analysis::GetOutputList ; (; ); const. inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 357 of file h1analysis.h. ◆ Init(). void h1analysis::Init ; (; TTree * ; tree). overridevirtual . Reimplemented from TSelector.; Definition at line 390 of file h1analysis.h. ◆ IsA(). TClass * h1analysis::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 361 of file h1analysis.h. ◆ Notify(). Bool_t h1analysis::Notify ; (; ). overridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject.; Definition at line 554 of file h1analysis.h. ◆ Process(). Bool_t h1analysis::Process ; (; Long64_t ; ). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return valu",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:21856,Performance,load,loaded,21856,"lass describing current object ; Reimplemented from TObject.; Definition at line 361 of file h1analysis.h. ◆ Notify(). Bool_t h1analysis::Notify ; (; ). overridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject.; Definition at line 554 of file h1analysis.h. ◆ Process(). Bool_t h1analysis::Process ; (; Long64_t ; ). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used.; WARNING when a selector is used with a TChain, you must use the pointer to the current TTree to call GetEntry(entry). The entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use: fChain->GetTree()->GetEntry(entry). ; Reimplemented from TSelector. ◆ Reset(). void h1analysis::Reset ; (; ). Definition at line 37",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:22072,Performance,load,loaded,22072,"ification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject.; Definition at line 554 of file h1analysis.h. ◆ Process(). Bool_t h1analysis::Process ; (; Long64_t ; ). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used.; WARNING when a selector is used with a TChain, you must use the pointer to the current TTree to call GetEntry(entry). The entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use: fChain->GetTree()->GetEntry(entry). ; Reimplemented from TSelector. ◆ Reset(). void h1analysis::Reset ; (; ). Definition at line 376 of file h1analysis.h. ◆ SetInputList(). void h1analysis::SetInputList ; (; TList * ; input). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 356 of file h1analysis.h. ◆ SetObject(). void h1analys",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:5649,Security,hash,hash,5649," to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysis.html:22194,Usability,simpl,simple,22194,"t the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject.; Definition at line 554 of file h1analysis.h. ◆ Process(). Bool_t h1analysis::Process ; (; Long64_t ; ). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used.; WARNING when a selector is used with a TChain, you must use the pointer to the current TTree to call GetEntry(entry). The entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use: fChain->GetTree()->GetEntry(entry). ; Reimplemented from TSelector. ◆ Reset(). void h1analysis::Reset ; (; ). Definition at line 376 of file h1analysis.h. ◆ SetInputList(). void h1analysis::SetInputList ; (; TList * ; input). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 356 of file h1analysis.h. ◆ SetObject(). void h1analysis::SetObject ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 355 of file h1analysis.h. ◆ SetOption(). void h1analysis::SetOptio",MatchSource.WIKI,doc/master/classh1analysis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysis.html
https://root.cern/doc/master/classh1analysisTreeReader.html:4253,Availability,error,error,4253,"object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Return",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:4342,Availability,error,error,4342,"ar *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns strin",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:4497,Availability,error,error,4497,";  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID ",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:4794,Availability,error,error,4794,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of thi",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:9187,Availability,error,error,9187," must be overridden when a class wants to print itself. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TSelector; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Versio",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:13069,Availability,avail,available,13069,"   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TSelector; EAbort fAbort;  Abort status. ;  ; TList * fInput;  List of objects available during processing. ;  ; TObject * fObject;  ! Current object if processing object (vs. TTree) ;  ; TString fOption;  Option given to TTree::Process. ;  ; TSelectorList * fOutput;  ! List of objects created during processing ;  ; Long64_t fStatus;  Selector status. ;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/h1analysisTreeReader.h>. Inheritance diagram for h1analysisTreeReader:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ h1analysisTreeReader(). h1analysisTreeReader::h1analysisTreeReader ; (; TTree * ; = nullptr). inline . Definition at line 40 of file h1analysisTreeReader.h. ◆ ~h1analysisTreeReader(). h1analysisTreeReader::~h1analysisTreeReader ; (; ). inlineoverride . Definition at line 61 of file h1analysisTreeReader.h. Member Function Documentation. ◆ Begin(). void h1analysisTreeReader::Begin ; (; TTree * ; ). overr",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:16421,Availability,avail,available,16421,"t be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject. ◆ Process(). Bool_t h1analysisTreeReader::Process ; (; Long64_t ; ). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used.; WARNING when a selector is used with a TChain, you must use the pointer to the current TTree to call GetEntry(entry). The entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use: fChain->GetTree()->GetEntry(entry). ; Reimplemented from TSelector. ◆ Reset(). void h1analysisTreeReader::Reset ; (; ). Definition at line 81 of file h1analysisTreeReader.h. ◆ SetInputList(). void h1analysisTreeReader::SetInputList ; (; TList * ; input). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 72 of file h1analysisTree",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:4259,Integrability,message,message,4259,"object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Return",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:4800,Integrability,message,message,4800,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of thi",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:5960,Integrability,message,message,5960,"ect *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this metho",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:9193,Integrability,message,message,9193," must be overridden when a class wants to print itself. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TSelector; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Versio",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:9566,Integrability,message,message,9566," Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TSelector; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TSelector * GetSelector (const char *filename);  The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from TSelector. ;  ; static bool IsStandardDraw (const char *selec);  Find out if this is a standard selection used for Draw a",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:1374,Modifiability,inherit,inherited,1374,"1analysisTreeReader.h. Public Member Functions;  h1analysisTreeReader (TTree *=nullptr);  ;  ~h1analysisTreeReader () override;  ; void Begin (TTree *) override;  ; TList * GetOutputList () const override;  ; void Init (TTree *myTree) override;  ; TClass * IsA () const override;  ; Bool_t Notify () override;  This method must be overridden to handle object notification (the base implementation is no-op). ;  ; Bool_t Process (Long64_t entry) override;  The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ;  ; void Reset ();  ; void SetInputList (TList *input) override;  ; void SetObject (TObject *obj) override;  ; void SetOption (const char *option) override;  ; void SlaveBegin (TTree *) override;  ; void SlaveTerminate () override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Terminate () override;  ; int Version () const override;  ;  Public Member Functions inherited from TSelector;  TSelector ();  Default selector ctor. ;  ;  ~TSelector () override;  Selector destructor. ;  ; virtual void Abort (const char *why, EAbort what=kAbortProcess);  Abort processing. ;  ; virtual EAbort GetAbort () const;  ; virtual Int_t GetEntry (Long64_t, Int_t=0);  ; virtual TList * GetInputList () const;  ; const char * GetOption () const override;  ; virtual Long64_t GetStatus () const;  ; virtual void ImportOutput (TList *output);  Imports the content of 'output' in the internal output list. ;  ; TClass * IsA () const override;  ; bool Notify () override;  This method must be overridden to handle object notification (the base implementation is no-op). ;  ; virtual bool ProcessCut (Long64_t);  This method is called before processing entry. ;  ; virtual void ProcessFill (Long64_t);  This method is called for all selected entries. ;  ; virtual void ResetAbort ();  ; virtual void SetStatus (Long64_t status);  ; v",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:2492,Modifiability,inherit,inherited,2492,"ector destructor. ;  ; virtual void Abort (const char *why, EAbort what=kAbortProcess);  Abort processing. ;  ; virtual EAbort GetAbort () const;  ; virtual Int_t GetEntry (Long64_t, Int_t=0);  ; virtual TList * GetInputList () const;  ; const char * GetOption () const override;  ; virtual Long64_t GetStatus () const;  ; virtual void ImportOutput (TList *output);  Imports the content of 'output' in the internal output list. ;  ; TClass * IsA () const override;  ; bool Notify () override;  This method must be overridden to handle object notification (the base implementation is no-op). ;  ; virtual bool ProcessCut (Long64_t);  This method is called before processing entry. ;  ; virtual void ProcessFill (Long64_t);  This method is called for all selected entries. ;  ; virtual void ResetAbort ();  ; virtual void SetStatus (Long64_t status);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) c",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:3889,Modifiability,inherit,inheritance,3889,"pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in de",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:6058,Modifiability,inherit,inherits,6058,"t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a ",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:6175,Modifiability,inherit,inherits,6175,"GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its p",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:10067,Modifiability,inherit,inherited,10067," char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TSelector; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TSelector * GetSelector (const char *filename);  The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from TSelector. ;  ; static bool IsStandardDraw (const char *selec);  Find out if this is a standard selection used for Draw actions (either TSelectorDraw, TProofDraw or deriving from them). ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . P",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:10660,Modifiability,inherit,inherited,10660,"_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TSelector; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TSelector * GetSelector (const char *filename);  The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from TSelector. ;  ; static bool IsStandardDraw (const char *selec);  Find out if this is a standard selection used for Draw actions (either TSelectorDraw, TProofDraw or deriving from them). ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Public Attributes; TEntryList * elist;  ; TTreeReaderValue< Float_t > fDm_d;  ; TTreeReaderValue< Float_t > fEtads_d;  ; TTreeReaderValue< Int_t > fIk;  ; Bool_t fillList;  ; TTreeReaderValue< Int_t > fIpi;  ; TTreeReaderValue< Int_t > fIpis;  ; TTreeReaderValue< Float_t > fMd0_d;  ; TTreeReaderArray< Int_t > fNhitrp;  ; TTreeReaderValue< Int_t > fNjets;  ; TTreeReaderArray< Float_t > fNlhk;  ; TTreeReaderArray< Float_t > fNlhpi;  ; Long64_t fProcessed;  ; TTreeReaderValue< Float_t > fPtd0_d;  ; TTreeReaderValue< Float_t > fPtds_d;  ; TTreeReaderArray< Float_t > fRend;  ; TTreeReaderValue< Float_t > fRpd0_t; ",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:11927,Modifiability,inherit,inherited,11927,";  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Public Attributes; TEntryList * elist;  ; TTreeReaderValue< Float_t > fDm_d;  ; TTreeReaderValue< Float_t > fEtads_d;  ; TTreeReaderValue< Int_t > fIk;  ; Bool_t fillList;  ; TTreeReaderValue< Int_t > fIpi;  ; TTreeReaderValue< Int_t > fIpis;  ; TTreeReaderValue< Float_t > fMd0_d;  ; TTreeReaderArray< Int_t > fNhitrp;  ; TTreeReaderValue< Int_t > fNjets;  ; TTreeReaderArray< Float_t > fNlhk;  ; TTreeReaderArray< Float_t > fNlhpi;  ; Long64_t fProcessed;  ; TTreeReaderValue< Float_t > fPtd0_d;  ; TTreeReaderValue< Float_t > fPtds_d;  ; TTreeReaderArray< Float_t > fRend;  ; TTreeReaderValue< Float_t > fRpd0_t;  ; TTreeReaderArray< Float_t > fRstart;  ; TH2F * h2;  ; TH1F * hdmd;  ; TTreeReader myTreeReader;  ; Bool_t useList;  . Additional Inherited Members;  Public Types inherited from TSelector; enum  EAbort { kContinue; , kAbortProcess; , kAbortFile; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TSelector; EAbort fAbort;  Abort status. ;  ; TList",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:12030,Modifiability,inherit,inherited,12030,";  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Public Attributes; TEntryList * elist;  ; TTreeReaderValue< Float_t > fDm_d;  ; TTreeReaderValue< Float_t > fEtads_d;  ; TTreeReaderValue< Int_t > fIk;  ; Bool_t fillList;  ; TTreeReaderValue< Int_t > fIpi;  ; TTreeReaderValue< Int_t > fIpis;  ; TTreeReaderValue< Float_t > fMd0_d;  ; TTreeReaderArray< Int_t > fNhitrp;  ; TTreeReaderValue< Int_t > fNjets;  ; TTreeReaderArray< Float_t > fNlhk;  ; TTreeReaderArray< Float_t > fNlhpi;  ; Long64_t fProcessed;  ; TTreeReaderValue< Float_t > fPtd0_d;  ; TTreeReaderValue< Float_t > fPtds_d;  ; TTreeReaderArray< Float_t > fRend;  ; TTreeReaderValue< Float_t > fRpd0_t;  ; TTreeReaderArray< Float_t > fRstart;  ; TH2F * h2;  ; TH1F * hdmd;  ; TTreeReader myTreeReader;  ; Bool_t useList;  . Additional Inherited Members;  Public Types inherited from TSelector; enum  EAbort { kContinue; , kAbortProcess; , kAbortFile; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TSelector; EAbort fAbort;  Abort status. ;  ; TList",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:12671,Modifiability,inherit,inherited,12671,"oat_t > fRstart;  ; TH2F * h2;  ; TH1F * hdmd;  ; TTreeReader myTreeReader;  ; Bool_t useList;  . Additional Inherited Members;  Public Types inherited from TSelector; enum  EAbort { kContinue; , kAbortProcess; , kAbortFile; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TSelector; EAbort fAbort;  Abort status. ;  ; TList * fInput;  List of objects available during processing. ;  ; TObject * fObject;  ! Current object if processing object (vs. TTree) ;  ; TString fOption;  Option given to TTree::Process. ;  ; TSelectorList * fOutput;  ! List of objects created during processing ;  ; Long64_t fStatus;  Selector status. ;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/h1analysisTreeReader.h>. Inheritance diagram for h1analysisTreeReader:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ h1analysisTreeReader(). h1analysisTreeReader::h1analysisTreeReader ; (; TTree * ; = nullptr). inline . Definition at line 40 of",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:12770,Modifiability,inherit,inherited,12770,"oat_t > fRstart;  ; TH2F * h2;  ; TH1F * hdmd;  ; TTreeReader myTreeReader;  ; Bool_t useList;  . Additional Inherited Members;  Public Types inherited from TSelector; enum  EAbort { kContinue; , kAbortProcess; , kAbortFile; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TSelector; EAbort fAbort;  Abort status. ;  ; TList * fInput;  List of objects available during processing. ;  ; TObject * fObject;  ! Current object if processing object (vs. TTree) ;  ; TString fOption;  Option given to TTree::Process. ;  ; TSelectorList * fOutput;  ! List of objects created during processing ;  ; Long64_t fStatus;  Selector status. ;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/h1analysisTreeReader.h>. Inheritance diagram for h1analysisTreeReader:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ h1analysisTreeReader(). h1analysisTreeReader::h1analysisTreeReader ; (; TTree * ; = nullptr). inline . Definition at line 40 of",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:12975,Modifiability,inherit,inherited,12975,"; , kAbortProcess; , kAbortFile; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TSelector; EAbort fAbort;  Abort status. ;  ; TList * fInput;  List of objects available during processing. ;  ; TObject * fObject;  ! Current object if processing object (vs. TTree) ;  ; TString fOption;  Option given to TTree::Process. ;  ; TSelectorList * fOutput;  ! List of objects created during processing ;  ; Long64_t fStatus;  Selector status. ;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/h1analysisTreeReader.h>. Inheritance diagram for h1analysisTreeReader:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ h1analysisTreeReader(). h1analysisTreeReader::h1analysisTreeReader ; (; TTree * ; = nullptr). inline . Definition at line 40 of file h1analysisTreeReader.h. ◆ ~h1analysisTreeReader(). h1analysisTreeReader::~h1analysisTreeReader ; (; ). inlineoverride . Definition at line 61 of file h1analysisTreeReader.h. Member Func",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:10328,Performance,load,loaded,10328," char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TSelector; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TSelector * GetSelector (const char *filename);  The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from TSelector. ;  ; static bool IsStandardDraw (const char *selec);  Find out if this is a standard selection used for Draw actions (either TSelectorDraw, TProofDraw or deriving from them). ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . P",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:15667,Performance,load,load,15667,"st * h1analysisTreeReader::GetOutputList ; (; ); const. inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 73 of file h1analysisTreeReader.h. ◆ Init(). void h1analysisTreeReader::Init ; (; TTree * ; myTree). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 67 of file h1analysisTreeReader.h. ◆ IsA(). TClass * h1analysisTreeReader::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 77 of file h1analysisTreeReader.h. ◆ Notify(). Bool_t h1analysisTreeReader::Notify ; (; ). overridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject. ◆ Process(). Bool_t h1analysisTreeReader::Process ; (; Long64_t ; ). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return v",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:15705,Performance,load,load,15705,"st * h1analysisTreeReader::GetOutputList ; (; ); const. inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 73 of file h1analysisTreeReader.h. ◆ Init(). void h1analysisTreeReader::Init ; (; TTree * ; myTree). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 67 of file h1analysisTreeReader.h. ◆ IsA(). TClass * h1analysisTreeReader::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 77 of file h1analysisTreeReader.h. ◆ Notify(). Bool_t h1analysisTreeReader::Notify ; (; ). overridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject. ◆ Process(). Bool_t h1analysisTreeReader::Process ; (; Long64_t ; ). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return v",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:16191,Performance,load,loaded,16191,"rtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 77 of file h1analysisTreeReader.h. ◆ Notify(). Bool_t h1analysisTreeReader::Notify ; (; ). overridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject. ◆ Process(). Bool_t h1analysisTreeReader::Process ; (; Long64_t ; ). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used.; WARNING when a selector is used with a TChain, you must use the pointer to the current TTree to call GetEntry(entry). The entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use: fChain->GetTree()->GetEntry(entry). ; Reimplemented from TSelector. ◆ Reset(). void h1analysisTreeReader::Reset ; (; ). Definition ",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:16407,Performance,load,loaded,16407,"t be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject. ◆ Process(). Bool_t h1analysisTreeReader::Process ; (; Long64_t ; ). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used.; WARNING when a selector is used with a TChain, you must use the pointer to the current TTree to call GetEntry(entry). The entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use: fChain->GetTree()->GetEntry(entry). ; Reimplemented from TSelector. ◆ Reset(). void h1analysisTreeReader::Reset ; (; ). Definition at line 81 of file h1analysisTreeReader.h. ◆ SetInputList(). void h1analysisTreeReader::SetInputList ; (; TList * ; input). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 72 of file h1analysisTree",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:5689,Security,hash,hash,5689," to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classh1analysisTreeReader.html:16529,Usability,simpl,simple,16529,"ther objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject. ◆ Process(). Bool_t h1analysisTreeReader::Process ; (; Long64_t ; ). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used.; WARNING when a selector is used with a TChain, you must use the pointer to the current TTree to call GetEntry(entry). The entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use: fChain->GetTree()->GetEntry(entry). ; Reimplemented from TSelector. ◆ Reset(). void h1analysisTreeReader::Reset ; (; ). Definition at line 81 of file h1analysisTreeReader.h. ◆ SetInputList(). void h1analysisTreeReader::SetInputList ; (; TList * ; input). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 72 of file h1analysisTreeReader.h. ◆ SetObject(). void h1analysisTreeReader::SetObject ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 71 of file h1analy",MatchSource.WIKI,doc/master/classh1analysisTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html
https://root.cern/doc/master/classHit.html:2113,Availability,error,error,2113,"object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Return",MatchSource.WIKI,doc/master/classHit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classHit.html
https://root.cern/doc/master/classHit.html:2202,Availability,error,error,2202,"ar *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns strin",MatchSource.WIKI,doc/master/classHit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classHit.html
https://root.cern/doc/master/classHit.html:2357,Availability,error,error,2357,";  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title o",MatchSource.WIKI,doc/master/classHit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classHit.html
https://root.cern/doc/master/classHit.html:2654,Availability,error,error,2654,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash",MatchSource.WIKI,doc/master/classHit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classHit.html
https://root.cern/doc/master/classHit.html:7328,Availability,error,error,7328,"ead (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Public Attributes; Float_t fX;  ; Float_t fY;  ; Float_t fZ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite",MatchSource.WIKI,doc/master/classHit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classHit.html
https://root.cern/doc/master/classHit.html:2119,Integrability,message,message,2119,"object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Return",MatchSource.WIKI,doc/master/classHit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classHit.html
https://root.cern/doc/master/classHit.html:2660,Integrability,message,message,2660,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash",MatchSource.WIKI,doc/master/classHit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classHit.html
https://root.cern/doc/master/classHit.html:3862,Integrability,message,message,3862,"ived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; virtual TClass * IsA () const;  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const ch",MatchSource.WIKI,doc/master/classHit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classHit.html
https://root.cern/doc/master/classHit.html:7334,Integrability,message,message,7334,"ead (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Public Attributes; Float_t fX;  ; Float_t fY;  ; Float_t fZ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite",MatchSource.WIKI,doc/master/classHit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classHit.html
https://root.cern/doc/master/classHit.html:7707,Integrability,message,message,7707,"rimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Public Attributes; Float_t fX;  ; Float_t fY;  ; Float_t fZ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1",MatchSource.WIKI,doc/master/classHit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classHit.html
https://root.cern/doc/master/classHit.html:352,Modifiability,inherit,inherited,352,". ROOT: Hit Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; Hit Class Reference. . Definition at line 16 of file JetEvent.h. Public Member Functions;  Hit ();  ;  ~Hit () override;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump c",MatchSource.WIKI,doc/master/classHit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classHit.html
https://root.cern/doc/master/classHit.html:1749,Modifiability,inherit,inheritance,1749,"pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in de",MatchSource.WIKI,doc/master/classHit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classHit.html
https://root.cern/doc/master/classHit.html:3960,Modifiability,inherit,inherits,3960,"ed by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; virtual TClass * IsA () const;  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a b",MatchSource.WIKI,doc/master/classHit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classHit.html
https://root.cern/doc/master/classHit.html:4077,Modifiability,inherit,inherits,4077,"ame of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; virtual TClass * IsA () const;  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not pro",MatchSource.WIKI,doc/master/classHit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classHit.html
https://root.cern/doc/master/classHit.html:8097,Modifiability,inherit,inherited,8097,"s TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Public Attributes; Float_t fX;  ; Float_t fY;  ; Float_t fZ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObject",MatchSource.WIKI,doc/master/classHit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classHit.html
https://root.cern/doc/master/classHit.html:8753,Modifiability,inherit,inherited,8753,"rtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Public Attributes; Float_t fX;  ; Float_t fY;  ; Float_t fZ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/JetEvent.h>. Inheritance diagram for Hit:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ Hit(). Hit::Hit ; (; ). inline . De",MatchSource.WIKI,doc/master/classHit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classHit.html
https://root.cern/doc/master/classHit.html:9256,Modifiability,inherit,inherited,9256," )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/JetEvent.h>. Inheritance diagram for Hit:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ Hit(). Hit::Hit ; (; ). inline . Definition at line 24 of file JetEvent.h. ◆ ~Hit(). Hit::~Hit ; (; ). inlineoverride . Definition at line 25 of file JetEvent.h. Member Data Documentation. ◆ fX. Float_t Hit::fX. Definition at line 19 of file JetEvent.h. ◆ fY. Float_t Hit::fY. Definition at line 20 of file JetEvent.h. ◆ fZ. Float_t Hit::fZ. Definition at line 21 of file JetEvent.h. tutorials/tree/JetEvent.h. Hit. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:36 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/classHit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classHit.html
https://root.cern/doc/master/classHit.html:9355,Modifiability,inherit,inherited,9355," )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/JetEvent.h>. Inheritance diagram for Hit:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ Hit(). Hit::Hit ; (; ). inline . Definition at line 24 of file JetEvent.h. ◆ ~Hit(). Hit::~Hit ; (; ). inlineoverride . Definition at line 25 of file JetEvent.h. Member Data Documentation. ◆ fX. Float_t Hit::fX. Definition at line 19 of file JetEvent.h. ◆ fY. Float_t Hit::fY. Definition at line 20 of file JetEvent.h. ◆ fZ. Float_t Hit::fZ. Definition at line 21 of file JetEvent.h. tutorials/tree/JetEvent.h. Hit. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:36 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/classHit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classHit.html
https://root.cern/doc/master/classHit.html:3591,Security,hash,hash,3591," Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; virtual TClass * IsA () const;  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other obje",MatchSource.WIKI,doc/master/classHit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classHit.html
https://root.cern/doc/master/ClassificationKeras_8py.html:542,Modifiability,layers,layers,542,". ROOT: tutorials/tmva/keras/ClassificationKeras.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; ClassificationKeras.py File ReferenceTutorials » TMVA tutorials » TMVA Keras tutorials. Detailed Description; This tutorial shows how to do classification in TMVA with neural networks trained with keras. ; ; from ROOT import TMVA, TFile, TTree, TCut; from subprocess import call; from os.path import isfile; ; from tensorflow.keras.models import Sequential; from tensorflow.keras.layers import Dense, Activation; from tensorflow.keras.optimizers import SGD; ; # Setup TMVA; TMVA.Tools.Instance(); TMVA.PyMethodBase.PyInitialize(); ; output = TFile.Open('TMVA_Classification_Keras.root', 'RECREATE'); factory = TMVA.Factory('TMVAClassification', output,; '!V:!Silent:Color:DrawProgressBar:Transformations=D,G:AnalysisType=Classification'); ; # Load data; if not isfile('tmva_class_example.root'):; call(['curl', '-L', '-O', 'http://root.cern/files/tmva_class_example.root']); ; data = TFile.Open('tmva_class_example.root'); signal = data.Get('TreeS'); background = data.Get('TreeB'); ; dataloader = TMVA.DataLoader('dataset'); for branch in signal.GetListOfBranches():; dataloader.AddVariable(branch.GetName()); ; dataloader.AddSignalTree(signal, 1.0); dataloader.AddBackgroundTree(background, 1.0); dataloader.PrepareTrainingAndTestTree(TCut(''),; 'nTrain_Signal=4000:nTrain_Background=4000:SplitMode=Random:NormMode=NumEvents:!V'); ; # Generate model; ; # Define model; model = Sequential(); model.add(Dense(64, activation='relu', input_dim=4)); model.add(Dense(2, activation='softmax')); ; # Set loss and optimizer; model.compile(loss='categorical_crossentropy',; optimizer=SGD(learning_rate=0.01), weighted_metrics=['accuracy', ]); ; # Store model to file; model.save('modelClassification.h5'); model.summary(); ; # Book methods; factory.BookMethod(dataloader, TMVA.Types.kFisher, 'Fisher',; '!H:!V:Fisher:VarTransform=D,G'); factory.Bo",MatchSource.WIKI,doc/master/ClassificationKeras_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ClassificationKeras_8py.html
https://root.cern/doc/master/ClassificationKeras_8py.html:597,Performance,optimiz,optimizers,597,". ROOT: tutorials/tmva/keras/ClassificationKeras.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; ClassificationKeras.py File ReferenceTutorials » TMVA tutorials » TMVA Keras tutorials. Detailed Description; This tutorial shows how to do classification in TMVA with neural networks trained with keras. ; ; from ROOT import TMVA, TFile, TTree, TCut; from subprocess import call; from os.path import isfile; ; from tensorflow.keras.models import Sequential; from tensorflow.keras.layers import Dense, Activation; from tensorflow.keras.optimizers import SGD; ; # Setup TMVA; TMVA.Tools.Instance(); TMVA.PyMethodBase.PyInitialize(); ; output = TFile.Open('TMVA_Classification_Keras.root', 'RECREATE'); factory = TMVA.Factory('TMVAClassification', output,; '!V:!Silent:Color:DrawProgressBar:Transformations=D,G:AnalysisType=Classification'); ; # Load data; if not isfile('tmva_class_example.root'):; call(['curl', '-L', '-O', 'http://root.cern/files/tmva_class_example.root']); ; data = TFile.Open('tmva_class_example.root'); signal = data.Get('TreeS'); background = data.Get('TreeB'); ; dataloader = TMVA.DataLoader('dataset'); for branch in signal.GetListOfBranches():; dataloader.AddVariable(branch.GetName()); ; dataloader.AddSignalTree(signal, 1.0); dataloader.AddBackgroundTree(background, 1.0); dataloader.PrepareTrainingAndTestTree(TCut(''),; 'nTrain_Signal=4000:nTrain_Background=4000:SplitMode=Random:NormMode=NumEvents:!V'); ; # Generate model; ; # Define model; model = Sequential(); model.add(Dense(64, activation='relu', input_dim=4)); model.add(Dense(2, activation='softmax')); ; # Set loss and optimizer; model.compile(loss='categorical_crossentropy',; optimizer=SGD(learning_rate=0.01), weighted_metrics=['accuracy', ]); ; # Store model to file; model.save('modelClassification.h5'); model.summary(); ; # Book methods; factory.BookMethod(dataloader, TMVA.Types.kFisher, 'Fisher',; '!H:!V:Fisher:VarTransform=D,G'); factory.Bo",MatchSource.WIKI,doc/master/ClassificationKeras_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ClassificationKeras_8py.html
https://root.cern/doc/master/ClassificationKeras_8py.html:1669,Performance,optimiz,optimizer,1669,"tance(); TMVA.PyMethodBase.PyInitialize(); ; output = TFile.Open('TMVA_Classification_Keras.root', 'RECREATE'); factory = TMVA.Factory('TMVAClassification', output,; '!V:!Silent:Color:DrawProgressBar:Transformations=D,G:AnalysisType=Classification'); ; # Load data; if not isfile('tmva_class_example.root'):; call(['curl', '-L', '-O', 'http://root.cern/files/tmva_class_example.root']); ; data = TFile.Open('tmva_class_example.root'); signal = data.Get('TreeS'); background = data.Get('TreeB'); ; dataloader = TMVA.DataLoader('dataset'); for branch in signal.GetListOfBranches():; dataloader.AddVariable(branch.GetName()); ; dataloader.AddSignalTree(signal, 1.0); dataloader.AddBackgroundTree(background, 1.0); dataloader.PrepareTrainingAndTestTree(TCut(''),; 'nTrain_Signal=4000:nTrain_Background=4000:SplitMode=Random:NormMode=NumEvents:!V'); ; # Generate model; ; # Define model; model = Sequential(); model.add(Dense(64, activation='relu', input_dim=4)); model.add(Dense(2, activation='softmax')); ; # Set loss and optimizer; model.compile(loss='categorical_crossentropy',; optimizer=SGD(learning_rate=0.01), weighted_metrics=['accuracy', ]); ; # Store model to file; model.save('modelClassification.h5'); model.summary(); ; # Book methods; factory.BookMethod(dataloader, TMVA.Types.kFisher, 'Fisher',; '!H:!V:Fisher:VarTransform=D,G'); factory.BookMethod(dataloader, TMVA.Types.kPyKeras, 'PyKeras',; 'H:!V:VarTransform=D,G:FilenameModel=modelClassification.h5:FilenameTrainedModel=trainedModelClassification.h5:NumEpochs=20:BatchSize=32'); ; # Run training, test and evaluation; factory.TrainAllMethods(); factory.TestAllMethods(); factory.EvaluateAllMethods(); TCutA specialized string object used for TTree selections.Definition TCut.h:25; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TMVA::DataLoaderDefiniti",MatchSource.WIKI,doc/master/ClassificationKeras_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ClassificationKeras_8py.html
https://root.cern/doc/master/ClassificationKeras_8py.html:1728,Performance,optimiz,optimizer,1728,"lassification_Keras.root', 'RECREATE'); factory = TMVA.Factory('TMVAClassification', output,; '!V:!Silent:Color:DrawProgressBar:Transformations=D,G:AnalysisType=Classification'); ; # Load data; if not isfile('tmva_class_example.root'):; call(['curl', '-L', '-O', 'http://root.cern/files/tmva_class_example.root']); ; data = TFile.Open('tmva_class_example.root'); signal = data.Get('TreeS'); background = data.Get('TreeB'); ; dataloader = TMVA.DataLoader('dataset'); for branch in signal.GetListOfBranches():; dataloader.AddVariable(branch.GetName()); ; dataloader.AddSignalTree(signal, 1.0); dataloader.AddBackgroundTree(background, 1.0); dataloader.PrepareTrainingAndTestTree(TCut(''),; 'nTrain_Signal=4000:nTrain_Background=4000:SplitMode=Random:NormMode=NumEvents:!V'); ; # Generate model; ; # Define model; model = Sequential(); model.add(Dense(64, activation='relu', input_dim=4)); model.add(Dense(2, activation='softmax')); ; # Set loss and optimizer; model.compile(loss='categorical_crossentropy',; optimizer=SGD(learning_rate=0.01), weighted_metrics=['accuracy', ]); ; # Store model to file; model.save('modelClassification.h5'); model.summary(); ; # Book methods; factory.BookMethod(dataloader, TMVA.Types.kFisher, 'Fisher',; '!H:!V:Fisher:VarTransform=D,G'); factory.BookMethod(dataloader, TMVA.Types.kPyKeras, 'PyKeras',; 'H:!V:VarTransform=D,G:FilenameModel=modelClassification.h5:FilenameTrainedModel=trainedModelClassification.h5:NumEpochs=20:BatchSize=32'); ; # Run training, test and evaluation; factory.TrainAllMethods(); factory.TestAllMethods(); factory.EvaluateAllMethods(); TCutA specialized string object used for TTree selections.Definition TCut.h:25; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::FactoryThis is the main MVA steering class.De",MatchSource.WIKI,doc/master/ClassificationKeras_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ClassificationKeras_8py.html
https://root.cern/doc/master/ClassificationKeras_8py.html:2213,Testability,test,test,2213,"er = TMVA.DataLoader('dataset'); for branch in signal.GetListOfBranches():; dataloader.AddVariable(branch.GetName()); ; dataloader.AddSignalTree(signal, 1.0); dataloader.AddBackgroundTree(background, 1.0); dataloader.PrepareTrainingAndTestTree(TCut(''),; 'nTrain_Signal=4000:nTrain_Background=4000:SplitMode=Random:NormMode=NumEvents:!V'); ; # Generate model; ; # Define model; model = Sequential(); model.add(Dense(64, activation='relu', input_dim=4)); model.add(Dense(2, activation='softmax')); ; # Set loss and optimizer; model.compile(loss='categorical_crossentropy',; optimizer=SGD(learning_rate=0.01), weighted_metrics=['accuracy', ]); ; # Store model to file; model.save('modelClassification.h5'); model.summary(); ; # Book methods; factory.BookMethod(dataloader, TMVA.Types.kFisher, 'Fisher',; '!H:!V:Fisher:VarTransform=D,G'); factory.BookMethod(dataloader, TMVA.Types.kPyKeras, 'PyKeras',; 'H:!V:VarTransform=D,G:FilenameModel=modelClassification.h5:FilenameTrainedModel=trainedModelClassification.h5:NumEpochs=20:BatchSize=32'); ; # Run training, test and evaluation; factory.TrainAllMethods(); factory.TestAllMethods(); factory.EvaluateAllMethods(); TCutA specialized string object used for TTree selections.Definition TCut.h:25; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::PyMethodBase::PyInitializestatic void PyInitialize()Initialize Python interpreter.Definition PyMethodBase.cxx:153; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; Date2017 ; AuthorTMVA Team ; Definition in file ClassificationKeras.py. tutorialstmvakerasClassificationKeras.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/ClassificationKeras_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ClassificationKeras_8py.html
https://root.cern/doc/master/ClassificationKeras_8py_source.html:662,Modifiability,layers,layers,662,". ROOT: tutorials/tmva/keras/ClassificationKeras.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ClassificationKeras.py. Go to the documentation of this file. 1#!/usr/bin/env python; 2## \file; 3## \ingroup tutorial_tmva_keras; 4## \notebook -nodraw; 5## This tutorial shows how to do classification in TMVA with neural networks; 6## trained with keras.; 7##; 8## \macro_code; 9##; 10## \date 2017; 11## \author TMVA Team; 12 ; 13from ROOT import TMVA, TFile, TTree, TCut; 14from subprocess import call; 15from os.path import isfile; 16 ; 17from tensorflow.keras.models import Sequential; 18from tensorflow.keras.layers import Dense, Activation; 19from tensorflow.keras.optimizers import SGD; 20 ; 21# Setup TMVA; 22TMVA.Tools.Instance(); 23TMVA.PyMethodBase.PyInitialize(); 24 ; 25output = TFile.Open('TMVA_Classification_Keras.root', 'RECREATE'); 26factory = TMVA.Factory('TMVAClassification', output,; 27 '!V:!Silent:Color:DrawProgressBar:Transformations=D,G:AnalysisType=Classification'); 28 ; 29# Load data; 30if not isfile('tmva_class_example.root'):; 31 call(['curl', '-L', '-O', 'http://root.cern/files/tmva_class_example.root']); 32 ; 33data = TFile.Open('tmva_class_example.root'); 34signal = data.Get('TreeS'); 35background = data.Get('TreeB'); 36 ; 37dataloader = TMVA.DataLoader('dataset'); 38for branch in signal.GetListOfBranches():; 39 dataloader.AddVariable(branch.GetName()); 40 ; 41dataloader.AddSignalTree(signal, 1.0); 42dataloader.AddBackgroundTree(background, 1.0); 43dataloader.PrepareTrainingAndTestTree(TCut(''),; 44 'nTrain_Signal=4000:nTrain_Background=4000:SplitMode=Random:NormMode=NumEvents:!V'); 45 ; 46# Generate model; 47 ; 48# Define model; 49model = Sequential(); 50model.add(Dense(64, activation='relu', input_dim=4)); 51model.add(Dense(2, activation='softmax')); 52 ; 53# Set loss and optimizer; 54model.compile(loss='categorical_crossentropy',; 55 optimizer=SGD(learning_rate=0.01), weighted_metrics=['accuracy', ",MatchSource.WIKI,doc/master/ClassificationKeras_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ClassificationKeras_8py_source.html
https://root.cern/doc/master/ClassificationKeras_8py_source.html:719,Performance,optimiz,optimizers,719,". ROOT: tutorials/tmva/keras/ClassificationKeras.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ClassificationKeras.py. Go to the documentation of this file. 1#!/usr/bin/env python; 2## \file; 3## \ingroup tutorial_tmva_keras; 4## \notebook -nodraw; 5## This tutorial shows how to do classification in TMVA with neural networks; 6## trained with keras.; 7##; 8## \macro_code; 9##; 10## \date 2017; 11## \author TMVA Team; 12 ; 13from ROOT import TMVA, TFile, TTree, TCut; 14from subprocess import call; 15from os.path import isfile; 16 ; 17from tensorflow.keras.models import Sequential; 18from tensorflow.keras.layers import Dense, Activation; 19from tensorflow.keras.optimizers import SGD; 20 ; 21# Setup TMVA; 22TMVA.Tools.Instance(); 23TMVA.PyMethodBase.PyInitialize(); 24 ; 25output = TFile.Open('TMVA_Classification_Keras.root', 'RECREATE'); 26factory = TMVA.Factory('TMVAClassification', output,; 27 '!V:!Silent:Color:DrawProgressBar:Transformations=D,G:AnalysisType=Classification'); 28 ; 29# Load data; 30if not isfile('tmva_class_example.root'):; 31 call(['curl', '-L', '-O', 'http://root.cern/files/tmva_class_example.root']); 32 ; 33data = TFile.Open('tmva_class_example.root'); 34signal = data.Get('TreeS'); 35background = data.Get('TreeB'); 36 ; 37dataloader = TMVA.DataLoader('dataset'); 38for branch in signal.GetListOfBranches():; 39 dataloader.AddVariable(branch.GetName()); 40 ; 41dataloader.AddSignalTree(signal, 1.0); 42dataloader.AddBackgroundTree(background, 1.0); 43dataloader.PrepareTrainingAndTestTree(TCut(''),; 44 'nTrain_Signal=4000:nTrain_Background=4000:SplitMode=Random:NormMode=NumEvents:!V'); 45 ; 46# Generate model; 47 ; 48# Define model; 49model = Sequential(); 50model.add(Dense(64, activation='relu', input_dim=4)); 51model.add(Dense(2, activation='softmax')); 52 ; 53# Set loss and optimizer; 54model.compile(loss='categorical_crossentropy',; 55 optimizer=SGD(learning_rate=0.01), weighted_metrics=['accuracy', ",MatchSource.WIKI,doc/master/ClassificationKeras_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ClassificationKeras_8py_source.html
https://root.cern/doc/master/ClassificationKeras_8py_source.html:1872,Performance,optimiz,optimizer,1872,"TMVA_Classification_Keras.root', 'RECREATE'); 26factory = TMVA.Factory('TMVAClassification', output,; 27 '!V:!Silent:Color:DrawProgressBar:Transformations=D,G:AnalysisType=Classification'); 28 ; 29# Load data; 30if not isfile('tmva_class_example.root'):; 31 call(['curl', '-L', '-O', 'http://root.cern/files/tmva_class_example.root']); 32 ; 33data = TFile.Open('tmva_class_example.root'); 34signal = data.Get('TreeS'); 35background = data.Get('TreeB'); 36 ; 37dataloader = TMVA.DataLoader('dataset'); 38for branch in signal.GetListOfBranches():; 39 dataloader.AddVariable(branch.GetName()); 40 ; 41dataloader.AddSignalTree(signal, 1.0); 42dataloader.AddBackgroundTree(background, 1.0); 43dataloader.PrepareTrainingAndTestTree(TCut(''),; 44 'nTrain_Signal=4000:nTrain_Background=4000:SplitMode=Random:NormMode=NumEvents:!V'); 45 ; 46# Generate model; 47 ; 48# Define model; 49model = Sequential(); 50model.add(Dense(64, activation='relu', input_dim=4)); 51model.add(Dense(2, activation='softmax')); 52 ; 53# Set loss and optimizer; 54model.compile(loss='categorical_crossentropy',; 55 optimizer=SGD(learning_rate=0.01), weighted_metrics=['accuracy', ]); 56 ; 57# Store model to file; 58model.save('modelClassification.h5'); 59model.summary(); 60 ; 61# Book methods; 62factory.BookMethod(dataloader, TMVA.Types.kFisher, 'Fisher',; 63 '!H:!V:Fisher:VarTransform=D,G'); 64factory.BookMethod(dataloader, TMVA.Types.kPyKeras, 'PyKeras',; 65 'H:!V:VarTransform=D,G:FilenameModel=modelClassification.h5:FilenameTrainedModel=trainedModelClassification.h5:NumEpochs=20:BatchSize=32'); 66 ; 67# Run training, test and evaluation; 68factory.TrainAllMethods(); 69factory.TestAllMethods(); 70factory.EvaluateAllMethods(); TCutA specialized string object used for TTree selections.Definition TCut.h:25; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definitio",MatchSource.WIKI,doc/master/ClassificationKeras_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ClassificationKeras_8py_source.html
https://root.cern/doc/master/ClassificationKeras_8py_source.html:1936,Performance,optimiz,optimizer,1936,"Classification', output,; 27 '!V:!Silent:Color:DrawProgressBar:Transformations=D,G:AnalysisType=Classification'); 28 ; 29# Load data; 30if not isfile('tmva_class_example.root'):; 31 call(['curl', '-L', '-O', 'http://root.cern/files/tmva_class_example.root']); 32 ; 33data = TFile.Open('tmva_class_example.root'); 34signal = data.Get('TreeS'); 35background = data.Get('TreeB'); 36 ; 37dataloader = TMVA.DataLoader('dataset'); 38for branch in signal.GetListOfBranches():; 39 dataloader.AddVariable(branch.GetName()); 40 ; 41dataloader.AddSignalTree(signal, 1.0); 42dataloader.AddBackgroundTree(background, 1.0); 43dataloader.PrepareTrainingAndTestTree(TCut(''),; 44 'nTrain_Signal=4000:nTrain_Background=4000:SplitMode=Random:NormMode=NumEvents:!V'); 45 ; 46# Generate model; 47 ; 48# Define model; 49model = Sequential(); 50model.add(Dense(64, activation='relu', input_dim=4)); 51model.add(Dense(2, activation='softmax')); 52 ; 53# Set loss and optimizer; 54model.compile(loss='categorical_crossentropy',; 55 optimizer=SGD(learning_rate=0.01), weighted_metrics=['accuracy', ]); 56 ; 57# Store model to file; 58model.save('modelClassification.h5'); 59model.summary(); 60 ; 61# Book methods; 62factory.BookMethod(dataloader, TMVA.Types.kFisher, 'Fisher',; 63 '!H:!V:Fisher:VarTransform=D,G'); 64factory.BookMethod(dataloader, TMVA.Types.kPyKeras, 'PyKeras',; 65 'H:!V:VarTransform=D,G:FilenameModel=modelClassification.h5:FilenameTrainedModel=trainedModelClassification.h5:NumEpochs=20:BatchSize=32'); 66 ; 67# Run training, test and evaluation; 68factory.TrainAllMethods(); 69factory.TestAllMethods(); 70factory.EvaluateAllMethods(); TCutA specialized string object used for TTree selections.Definition TCut.h:25; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::FactoryTh",MatchSource.WIKI,doc/master/ClassificationKeras_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ClassificationKeras_8py_source.html
https://root.cern/doc/master/ClassificationKeras_8py_source.html:2450,Testability,test,test,2450,"MVA.DataLoader('dataset'); 38for branch in signal.GetListOfBranches():; 39 dataloader.AddVariable(branch.GetName()); 40 ; 41dataloader.AddSignalTree(signal, 1.0); 42dataloader.AddBackgroundTree(background, 1.0); 43dataloader.PrepareTrainingAndTestTree(TCut(''),; 44 'nTrain_Signal=4000:nTrain_Background=4000:SplitMode=Random:NormMode=NumEvents:!V'); 45 ; 46# Generate model; 47 ; 48# Define model; 49model = Sequential(); 50model.add(Dense(64, activation='relu', input_dim=4)); 51model.add(Dense(2, activation='softmax')); 52 ; 53# Set loss and optimizer; 54model.compile(loss='categorical_crossentropy',; 55 optimizer=SGD(learning_rate=0.01), weighted_metrics=['accuracy', ]); 56 ; 57# Store model to file; 58model.save('modelClassification.h5'); 59model.summary(); 60 ; 61# Book methods; 62factory.BookMethod(dataloader, TMVA.Types.kFisher, 'Fisher',; 63 '!H:!V:Fisher:VarTransform=D,G'); 64factory.BookMethod(dataloader, TMVA.Types.kPyKeras, 'PyKeras',; 65 'H:!V:VarTransform=D,G:FilenameModel=modelClassification.h5:FilenameTrainedModel=trainedModelClassification.h5:NumEpochs=20:BatchSize=32'); 66 ; 67# Run training, test and evaluation; 68factory.TrainAllMethods(); 69factory.TestAllMethods(); 70factory.EvaluateAllMethods(); TCutA specialized string object used for TTree selections.Definition TCut.h:25; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::PyMethodBase::PyInitializestatic void PyInitialize()Initialize Python interpreter.Definition PyMethodBase.cxx:153; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71. tutorialstmvakerasClassificationKeras.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/ClassificationKeras_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ClassificationKeras_8py_source.html
https://root.cern/doc/master/classiterplugin.html:2782,Availability,error,error,2782,"object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Return",MatchSource.WIKI,doc/master/classiterplugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classiterplugin.html
https://root.cern/doc/master/classiterplugin.html:2871,Availability,error,error,2871,"ar *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns strin",MatchSource.WIKI,doc/master/classiterplugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classiterplugin.html
https://root.cern/doc/master/classiterplugin.html:3026,Availability,error,error,3026,";  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title o",MatchSource.WIKI,doc/master/classiterplugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classiterplugin.html
https://root.cern/doc/master/classiterplugin.html:3323,Availability,error,error,3323,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash",MatchSource.WIKI,doc/master/classiterplugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classiterplugin.html
https://root.cern/doc/master/classiterplugin.html:7887,Availability,error,error,7887," must be overridden when a class wants to print itself. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TGeoIteratorPlugin; static TClass * Class ();  ; static const char * Class_Name ();  ; static constex",MatchSource.WIKI,doc/master/classiterplugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classiterplugin.html
https://root.cern/doc/master/classiterplugin.html:2788,Integrability,message,message,2788,"object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Return",MatchSource.WIKI,doc/master/classiterplugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classiterplugin.html
https://root.cern/doc/master/classiterplugin.html:3329,Integrability,message,message,3329,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash",MatchSource.WIKI,doc/master/classiterplugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classiterplugin.html
https://root.cern/doc/master/classiterplugin.html:4531,Integrability,message,message,4531,"ived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this metho",MatchSource.WIKI,doc/master/classiterplugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classiterplugin.html
https://root.cern/doc/master/classiterplugin.html:7893,Integrability,message,message,7893," must be overridden when a class wants to print itself. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TGeoIteratorPlugin; static TClass * Class ();  ; static const char * Class_Name ();  ; static constex",MatchSource.WIKI,doc/master/classiterplugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classiterplugin.html
https://root.cern/doc/master/classiterplugin.html:8266,Integrability,message,message,8266," Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TGeoIteratorPlugin; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjec",MatchSource.WIKI,doc/master/classiterplugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classiterplugin.html
https://root.cern/doc/master/classiterplugin.html:672,Modifiability,inherit,inherited,672,". ROOT: iterplugin Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Public Attributes |; List of all members ; iterplugin Class Reference. . Definition at line 9 of file iterplugin.cxx. Public Member Functions;  iterplugin ();  ;  ~iterplugin () override;  ; TClass * IsA () const override;  ; void ProcessNode () override;  ; void Select (Int_t replica, Int_t color);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoIteratorPlugin;  TGeoIteratorPlugin ();  ;  ~TGeoIteratorPlugin () override;  ; TClass * IsA () const override;  ; void SetIterator (const TGeoIterator *iter);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) ",MatchSource.WIKI,doc/master/classiterplugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classiterplugin.html
https://root.cern/doc/master/classiterplugin.html:1021,Modifiability,inherit,inherited,1021,"ROOT: iterplugin Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Public Attributes |; List of all members ; iterplugin Class Reference. . Definition at line 9 of file iterplugin.cxx. Public Member Functions;  iterplugin ();  ;  ~iterplugin () override;  ; TClass * IsA () const override;  ; void ProcessNode () override;  ; void Select (Int_t replica, Int_t color);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGeoIteratorPlugin;  TGeoIteratorPlugin ();  ;  ~TGeoIteratorPlugin () override;  ; TClass * IsA () const override;  ; void SetIterator (const TGeoIterator *iter);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) c",MatchSource.WIKI,doc/master/classiterplugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classiterplugin.html
https://root.cern/doc/master/classiterplugin.html:2418,Modifiability,inherit,inheritance,2418,"pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in de",MatchSource.WIKI,doc/master/classiterplugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classiterplugin.html
https://root.cern/doc/master/classiterplugin.html:4629,Modifiability,inherit,inherits,4629,"ed by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a ",MatchSource.WIKI,doc/master/classiterplugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classiterplugin.html
https://root.cern/doc/master/classiterplugin.html:4746,Modifiability,inherit,inherits,4746,"ame of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its p",MatchSource.WIKI,doc/master/classiterplugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classiterplugin.html
https://root.cern/doc/master/classiterplugin.html:8767,Modifiability,inherit,inherited,8767,"rror message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TGeoIteratorPlugin; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Public Attributes; Int_t fColor;  ; Int_t fReplica;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits ",MatchSource.WIKI,doc/master/classiterplugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classiterplugin.html
https://root.cern/doc/master/classiterplugin.html:8989,Modifiability,inherit,inherited,8989,"rror message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TGeoIteratorPlugin; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Public Attributes; Int_t fColor;  ; Int_t fReplica;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits ",MatchSource.WIKI,doc/master/classiterplugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classiterplugin.html
https://root.cern/doc/master/classiterplugin.html:9574,Modifiability,inherit,inherited,9574,"ame ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TGeoIteratorPlugin; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Public Attributes; Int_t fColor;  ; Int_t fReplica;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TGeoIteratorPlugin; const TGeoIterator * fIterator = nullptr;  . Inheritance diagram for iterplugin:. T",MatchSource.WIKI,doc/master/classiterplugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classiterplugin.html
https://root.cern/doc/master/classiterplugin.html:10215,Modifiability,inherit,inherited,10215," (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Public Attributes; Int_t fColor;  ; Int_t fReplica;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TGeoIteratorPlugin; const TGeoIterator * fIterator = nullptr;  . Inheritance diagram for iterplugin:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ iterplugin(). iterplugin::iterplugin ; (; ). inline . Definition at line 12 of file iterplugin.cxx. ◆ ~iterplugin(). iterplugin::~iterplugin ; (; ). inlineoverride . Definition at line 13 of file iterplugin.cxx. Member Function Documentation. ◆ Class(). static TClass * iterplugin::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * iterplugin::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t iterplugin::Class_Version ; (; ). inlinestaticconstexpr . Retur",MatchSource.WIKI,doc/master/classiterplugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classiterplugin.html
https://root.cern/doc/master/classiterplugin.html:10314,Modifiability,inherit,inherited,10314," (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Public Attributes; Int_t fColor;  ; Int_t fReplica;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TGeoIteratorPlugin; const TGeoIterator * fIterator = nullptr;  . Inheritance diagram for iterplugin:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ iterplugin(). iterplugin::iterplugin ; (; ). inline . Definition at line 12 of file iterplugin.cxx. ◆ ~iterplugin(). iterplugin::~iterplugin ; (; ). inlineoverride . Definition at line 13 of file iterplugin.cxx. Member Function Documentation. ◆ Class(). static TClass * iterplugin::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * iterplugin::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t iterplugin::Class_Version ; (; ). inlinestaticconstexpr . Retur",MatchSource.WIKI,doc/master/classiterplugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classiterplugin.html
https://root.cern/doc/master/classiterplugin.html:10519,Modifiability,inherit,inherited,10519,"itional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TGeoIteratorPlugin; const TGeoIterator * fIterator = nullptr;  . Inheritance diagram for iterplugin:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ iterplugin(). iterplugin::iterplugin ; (; ). inline . Definition at line 12 of file iterplugin.cxx. ◆ ~iterplugin(). iterplugin::~iterplugin ; (; ). inlineoverride . Definition at line 13 of file iterplugin.cxx. Member Function Documentation. ◆ Class(). static TClass * iterplugin::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * iterplugin::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t iterplugin::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 21 of file iterplugin.cxx. ◆ DeclFileName(). static const char * iterplugin::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class ",MatchSource.WIKI,doc/master/classiterplugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classiterplugin.html
https://root.cern/doc/master/classiterplugin.html:4260,Security,hash,hash,4260," Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t",MatchSource.WIKI,doc/master/classiterplugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classiterplugin.html
https://root.cern/doc/master/classJet.html:6687,Availability,error,error,6687,"lar Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () co",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:6776,Availability,error,error,6776,"f class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:6931,Availability,error,error,6931,"ect using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; B",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:7108,Availability,error,error,7108,"py this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual vo",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:11298,Availability,error,error,11298,"n object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TAttLine;  TAttLine ();  AttLine default constructor. ;  ;  TAttLine (Color_t lcolor, Style_t lstyle, Width_t lwidth);  AttLine normal constructor. ;  ; virtual ~TAttLine ();  AttLine destructor. ;  ; void Copy (TAttLine &attline) const;  Copy this line attributes to a new TAttLine. ;  ; Int_t ",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:6693,Integrability,message,message,6693,"lar Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () co",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:7114,Integrability,message,message,7114,"py this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual vo",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:8176,Integrability,message,message,8176,"*name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this metho",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:11304,Integrability,message,message,11304,"n object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TAttLine;  TAttLine ();  AttLine default constructor. ;  ;  TAttLine (Color_t lcolor, Style_t lstyle, Width_t lwidth);  AttLine normal constructor. ;  ; virtual ~TAttLine ();  AttLine destructor. ;  ; void Copy (TAttLine &attline) const;  Copy this line attributes to a new TAttLine. ;  ; Int_t ",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:11677,Integrability,message,message,11677," Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TAttLine;  TAttLine ();  AttLine default constructor. ;  ;  TAttLine (Color_t lcolor, Style_t lstyle, Width_t lwidth);  AttLine normal constructor. ;  ; virtual ~TAttLine ();  AttLine destructor. ;  ; void Copy (TAttLine &attline) const;  Copy this line attributes to a new TAttLine. ;  ; Int_t DistancetoLine (Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2);  Compute distance from point px,py to a line. ;  ; virtual Color_t GetLineColor () const;  Return the line color. ;  ; virtual Style_t GetLineStyle () const;  Return the line style. ;  ; virtual Width_t GetLineWidth () const;  Return the line width. ;  ; virtual void Modify ();  Ch",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:887,Modifiability,inherit,inherited,887,"tic Public Member Functions |; Public Attributes |; List of all members ; Jet Class Reference. . Definition at line 69 of file collection_proxies.C. Public Member Functions;  Jet ();  ;  Jet (Int_t pdg, Int_t status, Int_t mother1, Int_t mother2, Int_t daughter1, Int_t daughter2, Double_t px, Double_t py, Double_t pz, Double_t etot);  ;  ~Jet () override;  ; float GetEtaSize () const;  ; float GetPhiSize () const;  ; TRefArray & GetTracks ();  ; virtual TClass * IsA () const;  ; void SetEtaSize (float iEtaSize);  ; void SetPhiSize (float iPhiSize);  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TParticle;  TParticle ();  reference to the particle record in PDG database ;  ;  TParticle (const TParticle &part);  copy constructor ;  ;  TParticle (Int_t pdg, Int_t status, Int_t mother1, Int_t mother2, Int_t daughter1, Int_t daughter2, const TLorentzVector &p, const TLorentzVector &v);  constructor ;  ;  TParticle (Int_t pdg, Int_t status, Int_t mother1, Int_t mother2, Int_t daughter1, Int_t daughter2, Double_t px, Double_t py, Double_t pz, Double_t etot, Double_t vx, Double_t vy, Double_t vz, Double_t time);  constructor ;  ;  ~TParticle () override;  destructor ;  ; Int_t Beauty () const;  Return beauty quantum number. ;  ; Int_t Charm () const;  Return charm quantum number. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to a primary track. ;  ; Double_t Ek () const;  ; Double_t Energy () const;  ; Double_t Eta () const;  ; void ExecuteEvent (Int_t event, Int_t px, Int_t py) override;  Execute action corresponding to one event. ;  ; Double_t GetCalcMass () const;  ; Int_t GetDaughter (Int_t i) const;  ; Int_t GetFirstDaughter () const;  ; Int_t GetFirstMother () const;  ; Int_t GetLastDaughter () const;  ; Double_t GetMass () const;  Return nominal particle mass from PDG table. ;  ; In",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:5040,Modifiability,inherit,inherited,5040,"; void SetPdgCode (Int_t pdg);  Change the PDG code for this particle. ;  ; void SetPolarisation (const TVector3 &v);  ; void SetPolarisation (Double_t polx, Double_t poly, Double_t polz);  Set particle polarisation. ;  ; void SetPolarisation (Double_t theta, Double_t phi);  ; void SetPolarPhi (Double_t phi);  ; void SetPolarTheta (Double_t theta);  ; void SetProductionVertex (const TLorentzVector &v);  ; void SetProductionVertex (Double_t vx, Double_t vy, Double_t vz, Double_t t);  ; void SetStatusCode (int status);  ; void SetWeight (Float_t weight=1);  ; void Sizeof3D () const override;  Return total X3D size of this primary. ;  ; Int_t Strangeness () const;  Return strangeness quantum number. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TParticle. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Double_t T () const;  ; Double_t Theta () const;  ; Double_t Theta (const TParticle &p);  ; Double_t ThetaX () const;  ; Double_t ThetaY () const;  ; Double_t ThetaZ () const;  ; Double_t Vx () const;  ; Double_t Vy () const;  ; Double_t Vz () const;  ; Double_t Y () const;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clon",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:6323,Modifiability,inherit,inheritance,6323,"t to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ;",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:8274,Modifiability,inherit,inherits,8274,"FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a ",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:8391,Modifiability,inherit,inherits,8391," () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its p",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:11984,Modifiability,inherit,inherited,11984,"tDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TAttLine;  TAttLine ();  AttLine default constructor. ;  ;  TAttLine (Color_t lcolor, Style_t lstyle, Width_t lwidth);  AttLine normal constructor. ;  ; virtual ~TAttLine ();  AttLine destructor. ;  ; void Copy (TAttLine &attline) const;  Copy this line attributes to a new TAttLine. ;  ; Int_t DistancetoLine (Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2);  Compute distance from point px,py to a line. ;  ; virtual Color_t GetLineColor () const;  Return the line color. ;  ; virtual Style_t GetLineStyle () const;  Return the line style. ;  ; virtual Width_t GetLineWidth () const;  Return the line width. ;  ; virtual void Modify ();  Change current line attributes if necessary. ;  ; virtual void ResetAttLine (Option_t *option="""");  Reset this line attributes to default values. ;  ; virtual void SaveLineAttributes (std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t widdef=1);  Save line attributes as C++ statement(s) on output stream out. ; ",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:13489,Modifiability,inherit,inherited,13489," ; virtual Style_t GetLineStyle () const;  Return the line style. ;  ; virtual Width_t GetLineWidth () const;  Return the line width. ;  ; virtual void Modify ();  Change current line attributes if necessary. ;  ; virtual void ResetAttLine (Option_t *option="""");  Reset this line attributes to default values. ;  ; virtual void SaveLineAttributes (std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t widdef=1);  Save line attributes as C++ statement(s) on output stream out. ;  ; virtual void SetLineAttributes ();  Invoke the DialogCanvas Line attributes. ;  ; virtual void SetLineColor (Color_t lcolor);  Set the line color. ;  ; virtual void SetLineColorAlpha (Color_t lcolor, Float_t lalpha);  Set a transparent line color. ;  ; virtual void SetLineStyle (Style_t lstyle);  Set the line style. ;  ; virtual void SetLineWidth (Width_t lwidth);  Set the line width. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TAtt3D;  TAtt3D ();  ; virtual ~TAtt3D ();  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TParticle; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objec",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:13834,Modifiability,inherit,inherited,13834,"ributes as C++ statement(s) on output stream out. ;  ; virtual void SetLineAttributes ();  Invoke the DialogCanvas Line attributes. ;  ; virtual void SetLineColor (Color_t lcolor);  Set the line color. ;  ; virtual void SetLineColorAlpha (Color_t lcolor, Float_t lalpha);  Set a transparent line color. ;  ; virtual void SetLineStyle (Style_t lstyle);  Set the line style. ;  ; virtual void SetLineWidth (Width_t lwidth);  Set the line width. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TAtt3D;  TAtt3D ();  ; virtual ~TAtt3D ();  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TParticle; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAtt3D; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:14047,Modifiability,inherit,inherited,14047,"ributes as C++ statement(s) on output stream out. ;  ; virtual void SetLineAttributes ();  Invoke the DialogCanvas Line attributes. ;  ; virtual void SetLineColor (Color_t lcolor);  Set the line color. ;  ; virtual void SetLineColorAlpha (Color_t lcolor, Float_t lalpha);  Set a transparent line color. ;  ; virtual void SetLineStyle (Style_t lstyle);  Set the line style. ;  ; virtual void SetLineWidth (Width_t lwidth);  Set the line width. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TAtt3D;  TAtt3D ();  ; virtual ~TAtt3D ();  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TParticle; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAtt3D; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:14565,Modifiability,inherit,inherited,14565," Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TParticle; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAtt3D; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Public Attributes; float fEtaSize {0};  ; Double_t fPhi;  ; float fPhiSize {0};  ; Double_t fPt;  ; TRefArray fTracks;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:14777,Modifiability,inherit,inherited,14777," Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TParticle; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAtt3D; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Public Attributes; float fEtaSize {0};  ; Double_t fPhi;  ; float fPhiSize {0};  ; Double_t fPt;  ; TRefArray fTracks;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:15121,Modifiability,inherit,inherited,15121," ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAtt3D; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Public Attributes; float fEtaSize {0};  ; Double_t fPhi;  ; float fPhiSize {0};  ; Double_t fPt;  ; TRefArray fTracks;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TParticle; Double_t fCalcMass;  ; Int_t fDaughter [2];  ; Double_t fE;  ; Int_t fMother [2];  ; TPartic",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:15762,Modifiability,inherit,inherited,15762,"nstexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Public Attributes; float fEtaSize {0};  ; Double_t fPhi;  ; float fPhiSize {0};  ; Double_t fPt;  ; TRefArray fTracks;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TParticle; Double_t fCalcMass;  ; Int_t fDaughter [2];  ; Double_t fE;  ; Int_t fMother [2];  ; TParticlePDG * fParticlePDG;  ; Int_t fPdgCode;  ; Double_t fPolarPhi;  ; Double_t fPolarTheta;  ; Double_t fPx;  ; Double_t fPy;  ; Double_t fPz;  ; Int_t fStatusCode;  ; Double_t fVt;  ; Double_t fVx;  ; Double_t fVy;  ; Double_t fVz;  ; Float_t fWeight;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/JetEvent.h>. Inheritance diagram for Jet:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:15861,Modifiability,inherit,inherited,15861,"nstexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Public Attributes; float fEtaSize {0};  ; Double_t fPhi;  ; float fPhiSize {0};  ; Double_t fPt;  ; TRefArray fTracks;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TParticle; Double_t fCalcMass;  ; Int_t fDaughter [2];  ; Double_t fE;  ; Int_t fMother [2];  ; TParticlePDG * fParticlePDG;  ; Int_t fPdgCode;  ; Double_t fPolarPhi;  ; Double_t fPolarTheta;  ; Double_t fPx;  ; Double_t fPy;  ; Double_t fPz;  ; Int_t fStatusCode;  ; Double_t fVt;  ; Double_t fVx;  ; Double_t fVy;  ; Double_t fVz;  ; Float_t fWeight;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/JetEvent.h>. Inheritance diagram for Jet:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:16066,Modifiability,inherit,inherited,16066,";   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TParticle; Double_t fCalcMass;  ; Int_t fDaughter [2];  ; Double_t fE;  ; Int_t fMother [2];  ; TParticlePDG * fParticlePDG;  ; Int_t fPdgCode;  ; Double_t fPolarPhi;  ; Double_t fPolarTheta;  ; Double_t fPx;  ; Double_t fPy;  ; Double_t fPz;  ; Int_t fStatusCode;  ; Double_t fVt;  ; Double_t fVx;  ; Double_t fVy;  ; Double_t fVz;  ; Float_t fWeight;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/JetEvent.h>. Inheritance diagram for Jet:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ Jet() [1/2]. Jet::Jet ; (; Int_t ; pdg, . Int_t ; status, . Int_t ; mother1, . Int_t ; mother2, . Int_t ; daughter1, . Int_t ; daughter2, . Double_t ; px, . Double_t ; py, . Double_t ; pz, . Double_t ; etot . ). inline . Definition at line 80 of file collection_proxies.C. ◆ Jet() [2/2]. Jet::Jet ; (; ). inline . Definition at line 57 of file JetEvent.h. ◆ ~Jet(). Jet::~Jet ; (; ). inl",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:16459,Modifiability,inherit,inherited,16459,";   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TParticle; Double_t fCalcMass;  ; Int_t fDaughter [2];  ; Double_t fE;  ; Int_t fMother [2];  ; TParticlePDG * fParticlePDG;  ; Int_t fPdgCode;  ; Double_t fPolarPhi;  ; Double_t fPolarTheta;  ; Double_t fPx;  ; Double_t fPy;  ; Double_t fPz;  ; Int_t fStatusCode;  ; Double_t fVt;  ; Double_t fVx;  ; Double_t fVy;  ; Double_t fVz;  ; Float_t fWeight;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/JetEvent.h>. Inheritance diagram for Jet:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ Jet() [1/2]. Jet::Jet ; (; Int_t ; pdg, . Int_t ; status, . Int_t ; mother1, . Int_t ; mother2, . Int_t ; daughter1, . Int_t ; daughter2, . Double_t ; px, . Double_t ; py, . Double_t ; pz, . Double_t ; etot . ). inline . Definition at line 80 of file collection_proxies.C. ◆ Jet() [2/2]. Jet::Jet ; (; ). inline . Definition at line 57 of file JetEvent.h. ◆ ~Jet(). Jet::~Jet ; (; ). inl",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJet.html:7905,Security,hash,hash,7905,"*method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t",MatchSource.WIKI,doc/master/classJet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJet.html
https://root.cern/doc/master/classJetEvent.html:2849,Availability,error,error,2849,"t;  Returns name of class to which the object belongs. ;  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Return",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classJetEvent.html:2938,Availability,error,error,2938,"ar *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns strin",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classJetEvent.html:3093,Availability,error,error,3093,";  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title o",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classJetEvent.html:3390,Availability,error,error,3390,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classJetEvent.html:8064,Availability,error,error,8064,"ead (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Private Attributes; TClonesArray * fHitsA;  ; TClonesArray * fHitsB;  ; TClonesArray * fJets;  ; Int_t fNhitA;  ; Int_t fNhitB;  ; Int_t fNjet;  ; Int_t fNtrack;  ; TClonesArray * fTracks;  ; TVector3 fVertex;  . Static Private Attributes; static TClonesArray * fgHitsA = nullptr;  ; static TClonesArray * fgHitsB = nullptr;  ; static ",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classJetEvent.html:2855,Integrability,message,message,2855,"t;  Returns name of class to which the object belongs. ;  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Return",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classJetEvent.html:3396,Integrability,message,message,3396,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classJetEvent.html:4598,Integrability,message,message,4598,"ived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; virtual TClass * IsA () const;  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const ch",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classJetEvent.html:8070,Integrability,message,message,8070,"ead (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Private Attributes; TClonesArray * fHitsA;  ; TClonesArray * fHitsB;  ; TClonesArray * fJets;  ; Int_t fNhitA;  ; Int_t fNhitB;  ; Int_t fNjet;  ; Int_t fNtrack;  ; TClonesArray * fTracks;  ; TVector3 fVertex;  . Static Private Attributes; static TClonesArray * fgHitsA = nullptr;  ; static TClonesArray * fgHitsB = nullptr;  ; static ",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classJetEvent.html:8443,Integrability,message,message,8443,"rimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Private Attributes; TClonesArray * fHitsA;  ; TClonesArray * fHitsB;  ; TClonesArray * fJets;  ; Int_t fNhitA;  ; Int_t fNhitB;  ; Int_t fNjet;  ; Int_t fNtrack;  ; TClonesArray * fTracks;  ; TVector3 fVertex;  . Static Private Attributes; static TClonesArray * fgHitsA = nullptr;  ; static TClonesArray * fgHitsB = nullptr;  ; static TClonesArray * fgJets = nullptr;  ; static TClonesArray * fgTracks = nullptr;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , k",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classJetEvent.html:1127,Modifiability,inherit,inherited,1127,"blic Member Functions |; Private Attributes |; Static Private Attributes |; List of all members ; JetEvent Class Reference. . Definition at line 64 of file JetEvent.h. Public Member Functions;  JetEvent ();  Create a JetEvent object. ;  ;  ~JetEvent () override;  ; Hit * AddHitA ();  Add a new hit to the list of hits in detector A. ;  ; Hit * AddHitB ();  Add a new hit to the list of hits in detector B. ;  ; Jet * AddJet ();  Add a new Jet to the list of tracks for this event. ;  ; Track * AddTrack ();  Add a new track to the list of tracks for this event. ;  ; void Build (Int_t jetm=3, Int_t trackm=10, Int_t hitam=100, Int_t hitbm=10);  Build one event. ;  ; void Clear (Option_t *option="""") override;  ; TClonesArray * GetJets () const;  ; Int_t GetNhitA () const;  ; Int_t GetNhitB () const;  ; Int_t GetNjet () const;  ; Int_t GetNtrack () const;  ; void Reset (Option_t *option="""");  Static function to reset all static objects for this event. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object)",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classJetEvent.html:2485,Modifiability,inherit,inheritance,2485,""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in de",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classJetEvent.html:4696,Modifiability,inherit,inherits,4696,"ed by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; virtual TClass * IsA () const;  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a b",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classJetEvent.html:4813,Modifiability,inherit,inherits,4813,"ame of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; virtual TClass * IsA () const;  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not pro",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classJetEvent.html:9185,Modifiability,inherit,inherited,9185,"t This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Private Attributes; TClonesArray * fHitsA;  ; TClonesArray * fHitsB;  ; TClonesArray * fJets;  ; Int_t fNhitA;  ; Int_t fNhitB;  ; Int_t fNjet;  ; Int_t fNtrack;  ; TClonesArray * fTracks;  ; TVector3 fVertex;  . Static Private Attributes; static TClonesArray * fgHitsA = nullptr;  ; static TClonesArray * fgHitsB = nullptr;  ; static TClonesArray * fgJets = nullptr;  ; static TClonesArray * fgTracks = nullptr;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObject",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classJetEvent.html:9841,Modifiability,inherit,inherited,9841,"ic Private Attributes; static TClonesArray * fgHitsA = nullptr;  ; static TClonesArray * fgHitsB = nullptr;  ; static TClonesArray * fgJets = nullptr;  ; static TClonesArray * fgTracks = nullptr;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/JetEvent.h>. Inheritance diagram for JetEvent:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ JetEvent(). JetEvent::JetEvent",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classJetEvent.html:10344,Modifiability,inherit,inherited,10344," 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/JetEvent.h>. Inheritance diagram for JetEvent:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ JetEvent(). JetEvent::JetEvent ; (; ). Create a JetEvent object. ; When the constructor is invoked for the first time, the class static variables fgxxx are 0 and the TClonesArray fgxxx are created. ; Definition at line 24 of file JetEvent.cxx. ◆ ~JetEvent(). JetEvent::~JetEvent ; (; ). override . Definition at line 38 of file JetEvent.cxx. Member Function Documentation. ◆ AddHitA(). Hit * JetEvent::AddHitA ; (; ). Add a new hit to the list of hits in detector A. ; Definition at line 124 of file JetEvent.cxx. ◆ AddHitB(). Hit * JetEvent::AddH",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classJetEvent.html:10443,Modifiability,inherit,inherited,10443," 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/JetEvent.h>. Inheritance diagram for JetEvent:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ JetEvent(). JetEvent::JetEvent ; (; ). Create a JetEvent object. ; When the constructor is invoked for the first time, the class static variables fgxxx are 0 and the TClonesArray fgxxx are created. ; Definition at line 24 of file JetEvent.cxx. ◆ ~JetEvent(). JetEvent::~JetEvent ; (; ). override . Definition at line 38 of file JetEvent.cxx. Member Function Documentation. ◆ AddHitA(). Hit * JetEvent::AddHitA ; (; ). Add a new hit to the list of hits in detector A. ; Definition at line 124 of file JetEvent.cxx. ◆ AddHitB(). Hit * JetEvent::AddH",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classJetEvent.html:11048,Modifiability,variab,variables,11048,"orOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/JetEvent.h>. Inheritance diagram for JetEvent:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ JetEvent(). JetEvent::JetEvent ; (; ). Create a JetEvent object. ; When the constructor is invoked for the first time, the class static variables fgxxx are 0 and the TClonesArray fgxxx are created. ; Definition at line 24 of file JetEvent.cxx. ◆ ~JetEvent(). JetEvent::~JetEvent ; (; ). override . Definition at line 38 of file JetEvent.cxx. Member Function Documentation. ◆ AddHitA(). Hit * JetEvent::AddHitA ; (; ). Add a new hit to the list of hits in detector A. ; Definition at line 124 of file JetEvent.cxx. ◆ AddHitB(). Hit * JetEvent::AddHitB ; (; ). Add a new hit to the list of hits in detector B. ; Definition at line 134 of file JetEvent.cxx. ◆ AddJet(). Jet * JetEvent::AddJet ; (; ). Add a new Jet to the list of tracks for this event. ; Definition at line 102 of file JetEvent.cxx. ◆ AddTrack(). Track * JetEvent::AddTrack ; (; ). Add a new track to the list of tracks for this event. ; Definition at line 113 of file JetEvent.cxx. ◆ Build(). void JetEvent::Build ; (; Int_t ; jetm = 3, . Int_t ; trackm = 10, . Int_t ; hitam = 100, . Int_t ; hitbm = 10 . ). Build one event. ; Definition at line 46 of file JetEvent",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classJetEvent.html:462,Safety,detect,detector,462,". ROOT: JetEvent Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Attributes |; Static Private Attributes |; List of all members ; JetEvent Class Reference. . Definition at line 64 of file JetEvent.h. Public Member Functions;  JetEvent ();  Create a JetEvent object. ;  ;  ~JetEvent () override;  ; Hit * AddHitA ();  Add a new hit to the list of hits in detector A. ;  ; Hit * AddHitB ();  Add a new hit to the list of hits in detector B. ;  ; Jet * AddJet ();  Add a new Jet to the list of tracks for this event. ;  ; Track * AddTrack ();  Add a new track to the list of tracks for this event. ;  ; void Build (Int_t jetm=3, Int_t trackm=10, Int_t hitam=100, Int_t hitbm=10);  Build one event. ;  ; void Clear (Option_t *option="""") override;  ; TClonesArray * GetJets () const;  ; Int_t GetNhitA () const;  ; Int_t GetNhitB () const;  ; Int_t GetNjet () const;  ; Int_t GetNtrack () const;  ; void Reset (Option_t *option="""");  Static function to reset all static objects for this event. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the ",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classJetEvent.html:535,Safety,detect,detector,535,". ROOT: JetEvent Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Attributes |; Static Private Attributes |; List of all members ; JetEvent Class Reference. . Definition at line 64 of file JetEvent.h. Public Member Functions;  JetEvent ();  Create a JetEvent object. ;  ;  ~JetEvent () override;  ; Hit * AddHitA ();  Add a new hit to the list of hits in detector A. ;  ; Hit * AddHitB ();  Add a new hit to the list of hits in detector B. ;  ; Jet * AddJet ();  Add a new Jet to the list of tracks for this event. ;  ; Track * AddTrack ();  Add a new track to the list of tracks for this event. ;  ; void Build (Int_t jetm=3, Int_t trackm=10, Int_t hitam=100, Int_t hitbm=10);  Build one event. ;  ; void Clear (Option_t *option="""") override;  ; TClonesArray * GetJets () const;  ; Int_t GetNhitA () const;  ; Int_t GetNhitB () const;  ; Int_t GetNjet () const;  ; Int_t GetNtrack () const;  ; void Reset (Option_t *option="""");  Static function to reset all static objects for this event. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the ",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classJetEvent.html:11367,Safety,detect,detector,11367," from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/JetEvent.h>. Inheritance diagram for JetEvent:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ JetEvent(). JetEvent::JetEvent ; (; ). Create a JetEvent object. ; When the constructor is invoked for the first time, the class static variables fgxxx are 0 and the TClonesArray fgxxx are created. ; Definition at line 24 of file JetEvent.cxx. ◆ ~JetEvent(). JetEvent::~JetEvent ; (; ). override . Definition at line 38 of file JetEvent.cxx. Member Function Documentation. ◆ AddHitA(). Hit * JetEvent::AddHitA ; (; ). Add a new hit to the list of hits in detector A. ; Definition at line 124 of file JetEvent.cxx. ◆ AddHitB(). Hit * JetEvent::AddHitB ; (; ). Add a new hit to the list of hits in detector B. ; Definition at line 134 of file JetEvent.cxx. ◆ AddJet(). Jet * JetEvent::AddJet ; (; ). Add a new Jet to the list of tracks for this event. ; Definition at line 102 of file JetEvent.cxx. ◆ AddTrack(). Track * JetEvent::AddTrack ; (; ). Add a new track to the list of tracks for this event. ; Definition at line 113 of file JetEvent.cxx. ◆ Build(). void JetEvent::Build ; (; Int_t ; jetm = 3, . Int_t ; trackm = 10, . Int_t ; hitam = 100, . Int_t ; hitbm = 10 . ). Build one event. ; Definition at line 46 of file JetEvent.cxx. ◆ Clear(). void JetEvent::Clear ; (; Option_t * ; option = """"). overridevirtual . Reimplemented from TObject.; Definition at line 143 of file JetEvent.cxx. ◆ GetJets(). TClonesArray * JetEvent::GetJets ; (; ); const. inline . Definition at line 96 of file JetEvent.h. ◆ GetNhitA(). Int_t JetEvent::GetNhit",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classJetEvent.html:11508,Safety,detect,detector,11508,"evel, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tree/JetEvent.h>. Inheritance diagram for JetEvent:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ JetEvent(). JetEvent::JetEvent ; (; ). Create a JetEvent object. ; When the constructor is invoked for the first time, the class static variables fgxxx are 0 and the TClonesArray fgxxx are created. ; Definition at line 24 of file JetEvent.cxx. ◆ ~JetEvent(). JetEvent::~JetEvent ; (; ). override . Definition at line 38 of file JetEvent.cxx. Member Function Documentation. ◆ AddHitA(). Hit * JetEvent::AddHitA ; (; ). Add a new hit to the list of hits in detector A. ; Definition at line 124 of file JetEvent.cxx. ◆ AddHitB(). Hit * JetEvent::AddHitB ; (; ). Add a new hit to the list of hits in detector B. ; Definition at line 134 of file JetEvent.cxx. ◆ AddJet(). Jet * JetEvent::AddJet ; (; ). Add a new Jet to the list of tracks for this event. ; Definition at line 102 of file JetEvent.cxx. ◆ AddTrack(). Track * JetEvent::AddTrack ; (; ). Add a new track to the list of tracks for this event. ; Definition at line 113 of file JetEvent.cxx. ◆ Build(). void JetEvent::Build ; (; Int_t ; jetm = 3, . Int_t ; trackm = 10, . Int_t ; hitam = 100, . Int_t ; hitbm = 10 . ). Build one event. ; Definition at line 46 of file JetEvent.cxx. ◆ Clear(). void JetEvent::Clear ; (; Option_t * ; option = """"). overridevirtual . Reimplemented from TObject.; Definition at line 143 of file JetEvent.cxx. ◆ GetJets(). TClonesArray * JetEvent::GetJets ; (; ); const. inline . Definition at line 96 of file JetEvent.h. ◆ GetNhitA(). Int_t JetEvent::GetNhitA ; (; ); const. inline . Definition at line 90 of file JetEvent.h. ◆ GetNhitB(). Int_t JetEvent::GetNhitB ; (; ); const. inline . Definition",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classJetEvent.html:4327,Security,hash,hash,4327," Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; virtual TClass * IsA () const;  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other obje",MatchSource.WIKI,doc/master/classJetEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classJetEvent.html
https://root.cern/doc/master/classParamHistFunc.html:15644,Availability,error,error,15644,"of function for given set of observables. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual double getValV (const RooArgSet *normalisationSet=nullptr) const;  Return value of object. ;  ; virtual void gradient (double *) const;  ; virtual bool hasGradient () const;  ; TClass * IsA () const override;  ; bool isIdentical (const RooAbsArg &other, bool assumeSameType=false) const override;  ; virtual bool isOffsetting () const;  ; bool isSelectedComp () const;  If true, the current pdf is a selected component (for use in plotting) ;  ; void logEvalError (const char *message, const char *serverValueString=nullptr) const;  Log evaluation error message. ;  ; virtual double maxVal (Int_t code) const;  Return maximum value for set of observables identified by code assigned in getMaxVal. ;  ; RooAbsMoment * mean (RooRealVar &obs);  ; RooAbsMoment * mean (RooRealVar &obs, const RooArgSet &nset);  ; virtual Int_t minTrialSamples (const RooArgSet &) const;  ; RooAbsMoment * moment (RooRealVar &obs, const RooArgSet &normObs, Int_t order, bool central, bool takeRoot, bool intNormObs);  Return function representing moment of p.d.f (normalized w.r.t given observables) of given order. ;  ; RooAbsMoment * moment (RooRealVar &obs, Int_t order, bool central, bool takeRoot);  Return function representing moment of function of given order. ;  ; virtual double offset () const;  ; bool operator== (const RooAbsArg &other",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:33799,Availability,mask,mask,33799,"s);  Replace some servers of this object. ;  ; bool recursiveRedirectServers (const RooAbsCollection &newServerList, bool mustReplaceAll=false, bool nameChange=false, bool recurseInNewSet=true);  Recursively replace all servers with the new servers in newSet. ;  ; virtual void serverNameChangeHook (const RooAbsArg *, const RooAbsArg *);  ; void addServer (RooAbsArg &server, bool valueProp=true, bool shapeProp=false, std::size_t refCount=1);  Register another RooAbsArg as a server to us, ie, declare that we depend on it. ;  ; void addServerList (RooAbsCollection &serverList, bool valueProp=true, bool shapeProp=false);  Register a list of RooAbsArg as servers to us by calling addServer() for each arg in the list. ;  ; void replaceServer (RooAbsArg &oldServer, RooAbsArg &newServer, bool valueProp, bool shapeProp);  Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const Ro",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:40056,Availability,error,error,40056,"ject. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:40145,Availability,error,error,40145,"ecord whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:40300,Availability,error,error,40300,"Name () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:40597,Availability,error,error,40597,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:44681,Availability,error,error,44681,"n object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption s",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:46970,Availability,error,error,46970,"tentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static RooArgList createParamSet (const std::string &, Int_t, double, double);  Create the list of RooRealVar parameters which represent the height of the histogram bins. ;  ; static RooArgList createParamSet (RooWorkspace &w, const std::string &, const RooArgList &Vars);  Create the list of RooRealVar parameters which represent the height of the histogram bins. ;  ; static RooArgList createParamSet (RooWorkspace &w, const std::string &, const RooArgList &Vars, double, double);  Create the list of RooRealVar parameters which scale the height of histogram bins. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static voi",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:47370,Availability,error,error,47370,"histogram bins. ;  ; static RooArgList createParamSet (RooWorkspace &w, const std::string &, const RooArgList &Vars);  Create the list of RooRealVar parameters which represent the height of the histogram bins. ;  ; static RooArgList createParamSet (RooWorkspace &w, const std::string &, const RooArgList &Vars, double, double);  Create the list of RooRealVar parameters which scale the height of histogram bins. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static vo",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:47592,Availability,error,error,47592,"pace &w, const std::string &, const RooArgList &Vars, double, double);  Create the list of RooRealVar parameters which scale the height of histogram bins. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Versi",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:47652,Availability,error,error,47652,"pace &w, const std::string &, const RooArgList &Vars, double, double);  Create the list of RooRealVar parameters which scale the height of histogram bins. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Versi",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:47788,Availability,error,errors,47788,"Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version (",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:47951,Availability,error,error,47951,"();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get st",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:48058,Availability,error,error,48058,"  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bo",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:54800,Availability,error,error,54800,"bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  Function that is called at the end of redirectServers(). ;  ; virtual void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; virtual void selectNormalizationRange (const char *rangeName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:1930,Deployability,integrat,integrations,1930,"vention (as compared to the RooDataHist convention, which is used internally and one must map between the two).; All indices include '0':; \( \gamma_{i,j} \) = paramSet[ size(i)*j + i ]; ie assuming the dimensions are 5*5:; \( \gamma_{2,1} \) = paramSet[ 5*1 + 2 ] = paramSet[7] ; Definition at line 24 of file ParamHistFunc.h. Classes; class  CacheElem;  ; struct  NumBins;  . Public Member Functions;  ParamHistFunc ();  ;  ParamHistFunc (const char *name, const char *title, const RooArgList &vars, const RooArgList &paramSet);  Create a function which returns binewise-values This class contains N RooAbsReals's, one for each bin from the given RooRealVar. ;  ;  ParamHistFunc (const char *name, const char *title, const RooArgList &vars, const RooArgList &paramSet, const TH1 *hist);  Create a function which returns bin-wise values. ;  ;  ParamHistFunc (const ParamHistFunc &other, const char *name=nullptr);  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Implement analytical integrations by doing appropriate weighting from component integrals functions to integrators of components. ;  ; std::list< double > * binBoundaries (RooAbsRealLValue &, double, double) const override;  Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ;  ; double binVolume () const;  ; TObject * clone (const char *newname) const override;  ; bool forceAnalyticalInt (const RooAbsArg &) const override;  ; const RooArgSet * get (const RooArgSet &coord) const;  ; const RooArgSet * get (Int_t masterIdx) const;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise that all integrals can be handled internally. ;  ; RooAbsReal & getParameter () const;  ; RooAbsReal & getParame",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:2012,Deployability,integrat,integrators,2012,"vention (as compared to the RooDataHist convention, which is used internally and one must map between the two).; All indices include '0':; \( \gamma_{i,j} \) = paramSet[ size(i)*j + i ]; ie assuming the dimensions are 5*5:; \( \gamma_{2,1} \) = paramSet[ 5*1 + 2 ] = paramSet[7] ; Definition at line 24 of file ParamHistFunc.h. Classes; class  CacheElem;  ; struct  NumBins;  . Public Member Functions;  ParamHistFunc ();  ;  ParamHistFunc (const char *name, const char *title, const RooArgList &vars, const RooArgList &paramSet);  Create a function which returns binewise-values This class contains N RooAbsReals's, one for each bin from the given RooRealVar. ;  ;  ParamHistFunc (const char *name, const char *title, const RooArgList &vars, const RooArgList &paramSet, const TH1 *hist);  Create a function which returns bin-wise values. ;  ;  ParamHistFunc (const ParamHistFunc &other, const char *name=nullptr);  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Implement analytical integrations by doing appropriate weighting from component integrals functions to integrators of components. ;  ; std::list< double > * binBoundaries (RooAbsRealLValue &, double, double) const override;  Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ;  ; double binVolume () const;  ; TObject * clone (const char *newname) const override;  ; bool forceAnalyticalInt (const RooAbsArg &) const override;  ; const RooArgSet * get (const RooArgSet &coord) const;  ; const RooArgSet * get (Int_t masterIdx) const;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise that all integrals can be handled internally. ;  ; RooAbsReal & getParameter () const;  ; RooAbsReal & getParame",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:9033,Deployability,configurat,configuration,9033,"f this function. ;  ; TH1 * createHistogram (const char *name, const RooAbsRealLValue &xvar, RooLinkedList &argList) const;  Internal method implementing createHistogram. ;  ; TH1 * createHistogram (RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) const;  Create and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables with given names. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const char *rangeName) const;  Create integral over observables in iset in range named rangeName. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet &nset, const char *rangeName=nullptr) const;  Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet &nset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) const;  Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset while using specified configuration for any numeric integration. ;  ; virtual RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet *nset=nullptr, const RooNumIntConfig *cfg=nullptr, const char *rangeName=nullptr) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooNumIntConfig &cfg, const char *rangeName=nullpt",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:9063,Deployability,integrat,integration,9063,"f this function. ;  ; TH1 * createHistogram (const char *name, const RooAbsRealLValue &xvar, RooLinkedList &argList) const;  Internal method implementing createHistogram. ;  ; TH1 * createHistogram (RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) const;  Create and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables with given names. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const char *rangeName) const;  Create integral over observables in iset in range named rangeName. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet &nset, const char *rangeName=nullptr) const;  Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet &nset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) const;  Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset while using specified configuration for any numeric integration. ;  ; virtual RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet *nset=nullptr, const RooNumIntConfig *cfg=nullptr, const char *rangeName=nullptr) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooNumIntConfig &cfg, const char *rangeName=nullpt",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:9994,Deployability,configurat,configuration,9994,"ntegral over observables in iset in range named rangeName with integrand normalized over observables in nset while using specified configuration for any numeric integration. ;  ; virtual RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet *nset=nullptr, const RooNumIntConfig *cfg=nullptr, const char *rangeName=nullptr) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) const;  Create integral over observables in iset in range named rangeName using specified configuration for any numeric integration. ;  ; RooFit::OwningPtr< RooAbsReal > createIntRI (const RooArgSet &iset, const RooArgSet &nset={});  Utility function for createRunningIntegral. ;  ; const RooAbsReal * createPlotProjection (const RooArgSet &dependentVars, const RooArgSet *projectedVars, RooArgSet *&cloneSet, const char *rangeName=nullptr, const RooArgSet *condObs=nullptr) const;  Utility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a RooPlot. ;  ; const RooAbsReal * createPlotProjection (const RooArgSet &depVars, const RooArgSet &projVars, RooArgSet *&cloneSet) const;  Utility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a RooPlot. ;  ; virtual RooFit::OwningPtr< RooAbsReal > createProfile (const RooArgSet &paramsOfInterest);  Create a RooProfileLL object that eliminates all nuisance parameters in the",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:10024,Deployability,integrat,integration,10024,"ntegral over observables in iset in range named rangeName with integrand normalized over observables in nset while using specified configuration for any numeric integration. ;  ; virtual RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet *nset=nullptr, const RooNumIntConfig *cfg=nullptr, const char *rangeName=nullptr) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) const;  Create integral over observables in iset in range named rangeName using specified configuration for any numeric integration. ;  ; RooFit::OwningPtr< RooAbsReal > createIntRI (const RooArgSet &iset, const RooArgSet &nset={});  Utility function for createRunningIntegral. ;  ; const RooAbsReal * createPlotProjection (const RooArgSet &dependentVars, const RooArgSet *projectedVars, RooArgSet *&cloneSet, const char *rangeName=nullptr, const RooArgSet *condObs=nullptr) const;  Utility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a RooPlot. ;  ; const RooAbsReal * createPlotProjection (const RooArgSet &depVars, const RooArgSet &projVars, RooArgSet *&cloneSet) const;  Utility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a RooPlot. ;  ; virtual RooFit::OwningPtr< RooAbsReal > createProfile (const RooArgSet &paramsOfInterest);  Create a RooProfileLL object that eliminates all nuisance parameters in the",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:14138,Deployability,integrat,integration,14138,"et &addNormSet=RooArgSet(), bool force=true);  Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by this object to the given set of observables. ;  ; virtual void fixAddCoefRange (const char *rangeName=nullptr, bool force=true);  Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by this object to the given set of observables. ;  ; virtual void forceNumInt (bool flag=true);  ; RooFunctor * functor (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a RooFunctor object bound to this RooAbsReal with given definition of observables and parameters. ;  ; virtual Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; bool getForceNumInt () const;  ; RooNumIntConfig * getIntegratorConfig ();  Return the numeric integration configuration used for this object. ;  ; const RooNumIntConfig * getIntegratorConfig () const;  Return the numeric integration configuration used for this object. ;  ; virtual Int_t getMaxVal (const RooArgSet &vars) const;  Advertise capability to determine maximum value of function for given set of observables. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual double getValV ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:14150,Deployability,configurat,configuration,14150,"et &addNormSet=RooArgSet(), bool force=true);  Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by this object to the given set of observables. ;  ; virtual void fixAddCoefRange (const char *rangeName=nullptr, bool force=true);  Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by this object to the given set of observables. ;  ; virtual void forceNumInt (bool flag=true);  ; RooFunctor * functor (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a RooFunctor object bound to this RooAbsReal with given definition of observables and parameters. ;  ; virtual Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; bool getForceNumInt () const;  ; RooNumIntConfig * getIntegratorConfig ();  Return the numeric integration configuration used for this object. ;  ; const RooNumIntConfig * getIntegratorConfig () const;  Return the numeric integration configuration used for this object. ;  ; virtual Int_t getMaxVal (const RooArgSet &vars) const;  Advertise capability to determine maximum value of function for given set of observables. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual double getValV ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:14265,Deployability,integrat,integration,14265,"e headed by this object to the given set of observables. ;  ; virtual void fixAddCoefRange (const char *rangeName=nullptr, bool force=true);  Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by this object to the given set of observables. ;  ; virtual void forceNumInt (bool flag=true);  ; RooFunctor * functor (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a RooFunctor object bound to this RooAbsReal with given definition of observables and parameters. ;  ; virtual Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; bool getForceNumInt () const;  ; RooNumIntConfig * getIntegratorConfig ();  Return the numeric integration configuration used for this object. ;  ; const RooNumIntConfig * getIntegratorConfig () const;  Return the numeric integration configuration used for this object. ;  ; virtual Int_t getMaxVal (const RooArgSet &vars) const;  Advertise capability to determine maximum value of function for given set of observables. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual double getValV (const RooArgSet *normalisationSet=nullptr) const;  Return value of object. ;  ; virtual void gradient (double *) const;  ; virtual bool h",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:14277,Deployability,configurat,configuration,14277,"e headed by this object to the given set of observables. ;  ; virtual void fixAddCoefRange (const char *rangeName=nullptr, bool force=true);  Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by this object to the given set of observables. ;  ; virtual void forceNumInt (bool flag=true);  ; RooFunctor * functor (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a RooFunctor object bound to this RooAbsReal with given definition of observables and parameters. ;  ; virtual Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; bool getForceNumInt () const;  ; RooNumIntConfig * getIntegratorConfig ();  Return the numeric integration configuration used for this object. ;  ; const RooNumIntConfig * getIntegratorConfig () const;  Return the numeric integration configuration used for this object. ;  ; virtual Int_t getMaxVal (const RooArgSet &vars) const;  Advertise capability to determine maximum value of function for given set of observables. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual double getValV (const RooArgSet *normalisationSet=nullptr) const;  Return value of object. ;  ; virtual void gradient (double *) const;  ; virtual bool h",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:17966,Deployability,integrat,integration,17966,". ;  ; virtual RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const;  Internal back-end function of plotOn() with named arguments. ;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &o",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:17978,Deployability,configurat,configuration,17978,". ;  ; virtual RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const;  Internal back-end function of plotOn() with named arguments. ;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &o",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:18099,Deployability,integrat,integrator,18099,"dObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for now) ;  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constru",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:18110,Deployability,configurat,configuration,18110,"dObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for now) ;  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constru",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:18143,Deployability,integrat,integration,18143,"dObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for now) ;  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constru",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:18155,Deployability,configurat,configuration,18155,"dObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for now) ;  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constru",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:18565,Deployability,integrat,integrator,18565,"ing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for now) ;  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constructor. ;  ;  RooAbsArg (const char *name, const char *title);  Create an object with the specified name and descriptive title. ;  ;  RooAbsArg (const RooAbsArg &other, const char *name=nullptr);  Copy constructor transfers all boolean and string properties of the original object. ;  ;  ~RooAbsArg () override;  Destructor. ;  ; bool addOwnedComponents (const RooAbsCollec",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:18576,Deployability,configurat,configuration,18576,"ing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for now) ;  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constructor. ;  ;  RooAbsArg (const char *name, const char *title);  Create an object with the specified name and descriptive title. ;  ;  RooAbsArg (const RooAbsArg &other, const char *name=nullptr);  Copy constructor transfers all boolean and string properties of the original object. ;  ;  ~RooAbsArg () override;  Destructor. ;  ; bool addOwnedComponents (const RooAbsCollec",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:18706,Deployability,integrat,integrator,18706,"mmy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for now) ;  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constructor. ;  ;  RooAbsArg (const char *name, const char *title);  Create an object with the specified name and descriptive title. ;  ;  RooAbsArg (const RooAbsArg &other, const char *name=nullptr);  Copy constructor transfers all boolean and string properties of the original object. ;  ;  ~RooAbsArg () override;  Destructor. ;  ; bool addOwnedComponents (const RooAbsCollection &comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooAbsCollection &&comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooArgList &&comps",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:18717,Deployability,configurat,configuration,18717,"mmy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for now) ;  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constructor. ;  ;  RooAbsArg (const char *name, const char *title);  Create an object with the specified name and descriptive title. ;  ;  RooAbsArg (const RooAbsArg &other, const char *name=nullptr);  Copy constructor transfers all boolean and string properties of the original object. ;  ;  ~RooAbsArg () override;  Destructor. ;  ; bool addOwnedComponents (const RooAbsCollection &comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooAbsCollection &&comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooArgList &&comps",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:30362,Deployability,update,updates,30362,"ode. For internal use only. ;  ; void setLocalNoDirtyInhibit (bool flag) const;  ; void SetName (const char *name) override;  Set the name of the TNamed. ;  ; void SetNameTitle (const char *name, const char *title) override;  Set all the TNamed parameters (name and title). ;  ; void setProhibitServerRedirect (bool flag);  ; void setStringAttribute (const Text_t *key, const Text_t *value);  Associate string 'value' to this object under key 'key'. ;  ; void setTransientAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setWorkspace (RooWorkspace &ws);  ; const std::map< std::string, std::string > & stringAttributes () const;  ; const std::set< std::string > & transientAttributes () const;  ; RooWorkspace * workspace () const;  ; const RefCountList_t & clients () const;  List of all clients of this object. ;  ; const RefCountList_t & valueClients () const;  List of all value clients of this object. Value clients receive value updates. ;  ; const RefCountList_t & shapeClients () const;  List of all shape clients of this object. ;  ; const RefCountList_t & servers () const;  List of all servers of this object. ;  ; RooAbsArg * findServer (const char *name) const;  Return server of this with name name. Returns nullptr if not found. ;  ; RooAbsArg * findServer (const RooAbsArg &arg) const;  Return server of this that has the same name as arg. Returns nullptr if not found. ;  ; RooAbsArg * findServer (Int_t index) const;  Return i-th server from server list. ;  ; bool isValueServer (const RooAbsArg &arg) const;  Check if this is serving values to arg. ;  ; bool isValueServer (const char *name) const;  Check if this is serving values to an object with name name. ;  ; bool isShapeServer (const RooAbsArg &arg) const;  Check if this is serving shape to arg. ;  ; bool isShapeServer (const char *name) const;  Check if this is serving shape to an object with name name. ;  ; void leafNodeServerList (RooAbsColl",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:32413,Deployability,integrat,integrated,32413," *list, const RooAbsArg *arg=nullptr, bool recurseNonDerived=false) const;  Fill supplied list with all leaf nodes of the arg tree, starting with ourself as top node. ;  ; void branchNodeServerList (RooAbsCollection *list, const RooAbsArg *arg=nullptr, bool recurseNonDerived=false) const;  Fill supplied list with all branch nodes of the arg tree starting with ourself as top node. ;  ; void treeNodeServerList (RooAbsCollection *list, const RooAbsArg *arg=nullptr, bool doBranch=true, bool doLeaf=true, bool valueOnly=false, bool recurseNonDerived=false) const;  Fill supplied list with nodes of the arg tree, following all server links, starting with ourself as top node. ;  ; virtual bool isFundamental () const;  Is this object a fundamental type that can be added to a dataset? Fundamental-type subclasses override this method to return true. ;  ; virtual bool isLValue () const;  Is this argument an l-value, i.e., can it appear on the left-hand side of an assignment expression? LValues are also special since they can potentially be analytically integrated and generated. ;  ; bool redirectServers (const RooAbsCollection &newServerList, bool mustReplaceAll=false, bool nameChange=false, bool isRecursionStep=false);  Replace all direct servers of this object with the new servers in newServerList. ;  ; bool redirectServers (std::unordered_map< RooAbsArg *, RooAbsArg * > const &replacements);  Replace some servers of this object. ;  ; bool recursiveRedirectServers (const RooAbsCollection &newServerList, bool mustReplaceAll=false, bool nameChange=false, bool recurseInNewSet=true);  Recursively replace all servers with the new servers in newSet. ;  ; virtual void serverNameChangeHook (const RooAbsArg *, const RooAbsArg *);  ; void addServer (RooAbsArg &server, bool valueProp=true, bool shapeProp=false, std::size_t refCount=1);  Register another RooAbsArg as a server to us, ie, declare that we depend on it. ;  ; void addServerList (RooAbsCollection &serverList, bool valueProp=true",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:47113,Deployability,integrat,integration,47113,"tatic constexpr Version_t Class_Version ();  ; static RooArgList createParamSet (const std::string &, Int_t, double, double);  Create the list of RooRealVar parameters which represent the height of the histogram bins. ;  ; static RooArgList createParamSet (RooWorkspace &w, const std::string &, const RooArgList &Vars);  Create the list of RooRealVar parameters which represent the height of the histogram bins. ;  ; static RooArgList createParamSet (RooWorkspace &w, const std::string &, const RooArgList &Vars, double, double);  Create the list of RooRealVar parameters which scale the height of histogram bins. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:47125,Deployability,configurat,configuration,47125,"tatic constexpr Version_t Class_Version ();  ; static RooArgList createParamSet (const std::string &, Int_t, double, double);  Create the list of RooRealVar parameters which represent the height of the histogram bins. ;  ; static RooArgList createParamSet (RooWorkspace &w, const std::string &, const RooArgList &Vars);  Create the list of RooRealVar parameters which represent the height of the histogram bins. ;  ; static RooArgList createParamSet (RooWorkspace &w, const std::string &, const RooArgList &Vars, double, double);  Create the list of RooRealVar parameters which scale the height of histogram bins. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:51572,Deployability,integrat,integrated,51572,"ttachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, normalization observables and the integration range name. ;  ; bool isValid () const override;  Check if current value is valid. ;  ; virtual bool isValidReal (double, bool printError=false) const;  Interface function to check if given value is a valid value for this object. Returns true unless overridden. ;  ; void makeProjectionSet (const RooAbsArg *plotVar, const RooArgSet *allVars, RooArgSet &projectedVars, bool silent) const;  Utility function for plotOn() that constructs the set of observables to project when plotting ourselves as function of 'plotVar'. ;  ; bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a, const RooArgProxy &b) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matc",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:51630,Deployability,integrat,integration,51630,"ttachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, normalization observables and the integration range name. ;  ; bool isValid () const override;  Check if current value is valid. ;  ; virtual bool isValidReal (double, bool printError=false) const;  Interface function to check if given value is a valid value for this object. Returns true unless overridden. ;  ; void makeProjectionSet (const RooAbsArg *plotVar, const RooArgSet *allVars, RooArgSet &projectedVars, bool silent) const;  Utility function for plotOn() that constructs the set of observables to project when plotting ourselves as function of 'plotVar'. ;  ; bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a, const RooArgProxy &b) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matc",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:57820,Deployability,integrat,integration,57820,"y &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static Int_t GetNumBins (const RooArgSet &vars);  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  . Protected Attributes; RooDataHist _dataSet;  ; RooListProxy _dataVars;  The RooRealVars. ;  ; RooObjCacheManager _normIntMgr;  ! The integration cache manager ;  ; Int_t _numBins = 0;  ; NumBins _numBinsPerDim;  ; RooListProxy _paramSet;  interpolation parameters ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clie",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:58049,Deployability,integrat,integration,58049,"y &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static Int_t GetNumBins (const RooArgSet &vars);  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  . Protected Attributes; RooDataHist _dataSet;  ; RooListProxy _dataVars;  The RooRealVars. ;  ; RooObjCacheManager _normIntMgr;  ! The integration cache manager ;  ; Int_t _numBins = 0;  ; NumBins _numBinsPerDim;  ; RooListProxy _paramSet;  interpolation parameters ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clie",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:64680,Deployability,integrat,integrations,64680,"ich returns bin-wise values. ; This class allows to multiply bin contents of histograms with the values of a set of RooAbsReal.; The value of the function in the ith bin is given by: ; \[; F(i) = \gamma_{i} * \mathrm{nominal}(i); \]. Where the nominal values are taken from the histogram, and the \( \gamma_{i} \) can be set from the outside. ; Definition at line 124 of file ParamHistFunc.cxx. ◆ ParamHistFunc() [4/4]. ParamHistFunc::ParamHistFunc ; (; const ParamHistFunc & ; other, . const char * ; name = nullptr . ). Definition at line 173 of file ParamHistFunc.cxx. Member Function Documentation. ◆ addParamSet(). Int_t ParamHistFunc::addParamSet ; (; const RooArgList & ; params). protected . Definition at line 524 of file ParamHistFunc.cxx. ◆ analyticalIntegralWN(). double ParamHistFunc::analyticalIntegralWN ; (; Int_t ; code, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Implement analytical integrations by doing appropriate weighting from component integrals functions to integrators of components. ; Reimplemented from RooAbsReal.; Definition at line 655 of file ParamHistFunc.cxx. ◆ binBoundaries(). std::list< double > * ParamHistFunc::binBoundaries ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ; Reimplemented from RooAbsReal.; Definition at line 721 of file ParamHistFunc.cxx. ◆ binVolume(). double ParamHistFunc::binVolume ; (; ); const. inline . Definition at line 49 of file ParamHistFunc.h. ◆ Class(). static TClass * ParamHistFunc::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * ParamHistFunc::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t ParamHistFunc::Cla",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:64762,Deployability,integrat,integrators,64762,"ich returns bin-wise values. ; This class allows to multiply bin contents of histograms with the values of a set of RooAbsReal.; The value of the function in the ith bin is given by: ; \[; F(i) = \gamma_{i} * \mathrm{nominal}(i); \]. Where the nominal values are taken from the histogram, and the \( \gamma_{i} \) can be set from the outside. ; Definition at line 124 of file ParamHistFunc.cxx. ◆ ParamHistFunc() [4/4]. ParamHistFunc::ParamHistFunc ; (; const ParamHistFunc & ; other, . const char * ; name = nullptr . ). Definition at line 173 of file ParamHistFunc.cxx. Member Function Documentation. ◆ addParamSet(). Int_t ParamHistFunc::addParamSet ; (; const RooArgList & ; params). protected . Definition at line 524 of file ParamHistFunc.cxx. ◆ analyticalIntegralWN(). double ParamHistFunc::analyticalIntegralWN ; (; Int_t ; code, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Implement analytical integrations by doing appropriate weighting from component integrals functions to integrators of components. ; Reimplemented from RooAbsReal.; Definition at line 655 of file ParamHistFunc.cxx. ◆ binBoundaries(). std::list< double > * ParamHistFunc::binBoundaries ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ; Reimplemented from RooAbsReal.; Definition at line 721 of file ParamHistFunc.cxx. ◆ binVolume(). double ParamHistFunc::binVolume ; (; ); const. inline . Definition at line 49 of file ParamHistFunc.h. ◆ Class(). static TClass * ParamHistFunc::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * ParamHistFunc::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t ParamHistFunc::Cla",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:74362,Deployability,integrat,integration,74362,"rNVirtual_b). inline . Definition at line 111 of file ParamHistFunc.h. ◆ translate(). void ParamHistFunc::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overrideprotectedvirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 563 of file ParamHistFunc.cxx. Member Data Documentation. ◆ _dataSet. RooDataHist ParamHistFunc::_dataSet. mutableprotected . Definition at line 98 of file ParamHistFunc.h. ◆ _dataVars. RooListProxy ParamHistFunc::_dataVars. protected . The RooRealVars. ; Definition at line 82 of file ParamHistFunc.h. ◆ _normIntMgr. RooObjCacheManager ParamHistFunc::_normIntMgr. mutableprotected . ! The integration cache manager ; Definition at line 80 of file ParamHistFunc.h. ◆ _numBins. Int_t ParamHistFunc::_numBins = 0. protected . Definition at line 85 of file ParamHistFunc.h. ◆ _numBinsPerDim. NumBins ParamHistFunc::_numBinsPerDim. mutableprotected . Definition at line 97 of file ParamHistFunc.h. ◆ _paramSet. RooListProxy ParamHistFunc::_paramSet. protected . interpolation parameters ; Definition at line 83 of file ParamHistFunc.h. Libraries for ParamHistFunc:. [legend]; The documentation for this class was generated from the following files:; roofit/histfactory/inc/RooStats/HistFactory/ParamHistFunc.h; roofit/histfactory/src/ParamHistFunc.cxx. ParamHistFunc. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:36 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:2266,Energy Efficiency,efficient,efficiently,2266,"mHistFunc.h. Classes; class  CacheElem;  ; struct  NumBins;  . Public Member Functions;  ParamHistFunc ();  ;  ParamHistFunc (const char *name, const char *title, const RooArgList &vars, const RooArgList &paramSet);  Create a function which returns binewise-values This class contains N RooAbsReals's, one for each bin from the given RooRealVar. ;  ;  ParamHistFunc (const char *name, const char *title, const RooArgList &vars, const RooArgList &paramSet, const TH1 *hist);  Create a function which returns bin-wise values. ;  ;  ParamHistFunc (const ParamHistFunc &other, const char *name=nullptr);  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Implement analytical integrations by doing appropriate weighting from component integrals functions to integrators of components. ;  ; std::list< double > * binBoundaries (RooAbsRealLValue &, double, double) const override;  Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ;  ; double binVolume () const;  ; TObject * clone (const char *newname) const override;  ; bool forceAnalyticalInt (const RooAbsArg &) const override;  ; const RooArgSet * get (const RooArgSet &coord) const;  ; const RooArgSet * get (Int_t masterIdx) const;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise that all integrals can be handled internally. ;  ; RooAbsReal & getParameter () const;  ; RooAbsReal & getParameter (Int_t masterIdx) const;  Get the parameter associated with the index. ;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ;  ; Int_t numBins () const;  ; c",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:3469,Energy Efficiency,efficient,efficiently,3469,"uble binVolume () const;  ; TObject * clone (const char *newname) const override;  ; bool forceAnalyticalInt (const RooAbsArg &) const override;  ; const RooArgSet * get (const RooArgSet &coord) const;  ; const RooArgSet * get (Int_t masterIdx) const;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise that all integrals can be handled internally. ;  ; RooAbsReal & getParameter () const;  ; RooAbsReal & getParameter (Int_t masterIdx) const;  Get the parameter associated with the index. ;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ;  ; Int_t numBins () const;  ; const RooArgList & paramList () const;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const override;  Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ;  ; void setConstant (bool constant);  ; void setParamConst (Int_t, bool=true);  ; void setShape (TH1 *shape);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:4862,Energy Efficiency,adapt,adaptor,4862,"ctions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parameters. ;  ; RooFit::OwningPtr< RooAbsFunc > bindVars (const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) const;  Create an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order). ;  ; virtual std::string buildCallToAnalyticIntegral (Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const;  This function defines the analytical integral translation for the class. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a \( \chi^2 \) fit to given histogram. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooLinkedList &cmdList);  Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={},",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:65167,Energy Efficiency,efficient,efficiently,65167,"]. ParamHistFunc::ParamHistFunc ; (; const ParamHistFunc & ; other, . const char * ; name = nullptr . ). Definition at line 173 of file ParamHistFunc.cxx. Member Function Documentation. ◆ addParamSet(). Int_t ParamHistFunc::addParamSet ; (; const RooArgList & ; params). protected . Definition at line 524 of file ParamHistFunc.cxx. ◆ analyticalIntegralWN(). double ParamHistFunc::analyticalIntegralWN ; (; Int_t ; code, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Implement analytical integrations by doing appropriate weighting from component integrals functions to integrators of components. ; Reimplemented from RooAbsReal.; Definition at line 655 of file ParamHistFunc.cxx. ◆ binBoundaries(). std::list< double > * ParamHistFunc::binBoundaries ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ; Reimplemented from RooAbsReal.; Definition at line 721 of file ParamHistFunc.cxx. ◆ binVolume(). double ParamHistFunc::binVolume ; (; ); const. inline . Definition at line 49 of file ParamHistFunc.h. ◆ Class(). static TClass * ParamHistFunc::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * ParamHistFunc::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t ParamHistFunc::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 111 of file ParamHistFunc.h. ◆ clone(). TObject * ParamHistFunc::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 32 of file ParamHistFunc.h. ◆ createParamSet() [1/3]. RooArgList ParamHistFunc::createParamSet ; (; const std::string & ; Prefix, . Int_t ; numBins, .",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:72345,Energy Efficiency,efficient,efficiently,72345,"ramHistFunc::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 111 of file ParamHistFunc.h. ◆ isBinnedDistribution(). bool ParamHistFunc::isBinnedDistribution ; (; const RooArgSet & ; ); const. inlineoverridevirtual . Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ; Reimplemented from RooAbsReal.; Definition at line 62 of file ParamHistFunc.h. ◆ numBins(). Int_t ParamHistFunc::numBins ; (; ); const. inline . Definition at line 36 of file ParamHistFunc.h. ◆ paramList(). const RooArgList & ParamHistFunc::paramList ; (; ); const. inline . Definition at line 34 of file ParamHistFunc.h. ◆ plotSamplingHint(). std::list< double > * ParamHistFunc::plotSamplingHint ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ; Reimplemented from RooAbsReal.; Definition at line 686 of file ParamHistFunc.cxx. ◆ setConstant(). void ParamHistFunc::setConstant ; (; bool ; constant). Definition at line 233 of file ParamHistFunc.cxx. ◆ setParamConst(). void ParamHistFunc::setParamConst ; (; Int_t ; index, . bool ; varConst = true . ). Definition at line 227 of file ParamHistFunc.cxx. ◆ setShape(). void ParamHistFunc::setShape ; (; TH1 * ; shape). Definition at line 242 of file ParamHistFunc.cxx. ◆ Streamer(). void ParamHistFunc::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void ParamHistFunc::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 111 of file ParamHistFunc.h. ◆ translate(). void ParamHistFunc::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overri",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:1930,Integrability,integrat,integrations,1930,"vention (as compared to the RooDataHist convention, which is used internally and one must map between the two).; All indices include '0':; \( \gamma_{i,j} \) = paramSet[ size(i)*j + i ]; ie assuming the dimensions are 5*5:; \( \gamma_{2,1} \) = paramSet[ 5*1 + 2 ] = paramSet[7] ; Definition at line 24 of file ParamHistFunc.h. Classes; class  CacheElem;  ; struct  NumBins;  . Public Member Functions;  ParamHistFunc ();  ;  ParamHistFunc (const char *name, const char *title, const RooArgList &vars, const RooArgList &paramSet);  Create a function which returns binewise-values This class contains N RooAbsReals's, one for each bin from the given RooRealVar. ;  ;  ParamHistFunc (const char *name, const char *title, const RooArgList &vars, const RooArgList &paramSet, const TH1 *hist);  Create a function which returns bin-wise values. ;  ;  ParamHistFunc (const ParamHistFunc &other, const char *name=nullptr);  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Implement analytical integrations by doing appropriate weighting from component integrals functions to integrators of components. ;  ; std::list< double > * binBoundaries (RooAbsRealLValue &, double, double) const override;  Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ;  ; double binVolume () const;  ; TObject * clone (const char *newname) const override;  ; bool forceAnalyticalInt (const RooAbsArg &) const override;  ; const RooArgSet * get (const RooArgSet &coord) const;  ; const RooArgSet * get (Int_t masterIdx) const;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise that all integrals can be handled internally. ;  ; RooAbsReal & getParameter () const;  ; RooAbsReal & getParame",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:2012,Integrability,integrat,integrators,2012,"vention (as compared to the RooDataHist convention, which is used internally and one must map between the two).; All indices include '0':; \( \gamma_{i,j} \) = paramSet[ size(i)*j + i ]; ie assuming the dimensions are 5*5:; \( \gamma_{2,1} \) = paramSet[ 5*1 + 2 ] = paramSet[7] ; Definition at line 24 of file ParamHistFunc.h. Classes; class  CacheElem;  ; struct  NumBins;  . Public Member Functions;  ParamHistFunc ();  ;  ParamHistFunc (const char *name, const char *title, const RooArgList &vars, const RooArgList &paramSet);  Create a function which returns binewise-values This class contains N RooAbsReals's, one for each bin from the given RooRealVar. ;  ;  ParamHistFunc (const char *name, const char *title, const RooArgList &vars, const RooArgList &paramSet, const TH1 *hist);  Create a function which returns bin-wise values. ;  ;  ParamHistFunc (const ParamHistFunc &other, const char *name=nullptr);  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Implement analytical integrations by doing appropriate weighting from component integrals functions to integrators of components. ;  ; std::list< double > * binBoundaries (RooAbsRealLValue &, double, double) const override;  Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ;  ; double binVolume () const;  ; TObject * clone (const char *newname) const override;  ; bool forceAnalyticalInt (const RooAbsArg &) const override;  ; const RooArgSet * get (const RooArgSet &coord) const;  ; const RooArgSet * get (Int_t masterIdx) const;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise that all integrals can be handled internally. ;  ; RooAbsReal & getParameter () const;  ; RooAbsReal & getParame",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:4852,Integrability,interface,interface,4852,"ctions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parameters. ;  ; RooFit::OwningPtr< RooAbsFunc > bindVars (const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) const;  Create an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order). ;  ; virtual std::string buildCallToAnalyticIntegral (Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const;  This function defines the analytical integral translation for the class. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a \( \chi^2 \) fit to given histogram. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooLinkedList &cmdList);  Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={},",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:9063,Integrability,integrat,integration,9063,"f this function. ;  ; TH1 * createHistogram (const char *name, const RooAbsRealLValue &xvar, RooLinkedList &argList) const;  Internal method implementing createHistogram. ;  ; TH1 * createHistogram (RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) const;  Create and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables with given names. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const char *rangeName) const;  Create integral over observables in iset in range named rangeName. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet &nset, const char *rangeName=nullptr) const;  Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet &nset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) const;  Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset while using specified configuration for any numeric integration. ;  ; virtual RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet *nset=nullptr, const RooNumIntConfig *cfg=nullptr, const char *rangeName=nullptr) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooNumIntConfig &cfg, const char *rangeName=nullpt",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:10024,Integrability,integrat,integration,10024,"ntegral over observables in iset in range named rangeName with integrand normalized over observables in nset while using specified configuration for any numeric integration. ;  ; virtual RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet *nset=nullptr, const RooNumIntConfig *cfg=nullptr, const char *rangeName=nullptr) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) const;  Create integral over observables in iset in range named rangeName using specified configuration for any numeric integration. ;  ; RooFit::OwningPtr< RooAbsReal > createIntRI (const RooArgSet &iset, const RooArgSet &nset={});  Utility function for createRunningIntegral. ;  ; const RooAbsReal * createPlotProjection (const RooArgSet &dependentVars, const RooArgSet *projectedVars, RooArgSet *&cloneSet, const char *rangeName=nullptr, const RooArgSet *condObs=nullptr) const;  Utility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a RooPlot. ;  ; const RooAbsReal * createPlotProjection (const RooArgSet &depVars, const RooArgSet &projVars, RooArgSet *&cloneSet) const;  Utility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a RooPlot. ;  ; virtual RooFit::OwningPtr< RooAbsReal > createProfile (const RooArgSet &paramsOfInterest);  Create a RooProfileLL object that eliminates all nuisance parameters in the",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:10245,Integrability,depend,dependentVars,10245,"nction over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) const;  Create integral over observables in iset in range named rangeName using specified configuration for any numeric integration. ;  ; RooFit::OwningPtr< RooAbsReal > createIntRI (const RooArgSet &iset, const RooArgSet &nset={});  Utility function for createRunningIntegral. ;  ; const RooAbsReal * createPlotProjection (const RooArgSet &dependentVars, const RooArgSet *projectedVars, RooArgSet *&cloneSet, const char *rangeName=nullptr, const RooArgSet *condObs=nullptr) const;  Utility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a RooPlot. ;  ; const RooAbsReal * createPlotProjection (const RooArgSet &depVars, const RooArgSet &projVars, RooArgSet *&cloneSet) const;  Utility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a RooPlot. ;  ; virtual RooFit::OwningPtr< RooAbsReal > createProfile (const RooArgSet &paramsOfInterest);  Create a RooProfileLL object that eliminates all nuisance parameters in the present function. ;  ; RooFit::OwningPtr< RooAbsReal > createRunningIntegral (const RooArgSet &iset, const RooArgSet &nset={});  Calls createRunningIntegral(const RooArgSet&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&) ;  ; RooFit::OwningPtr< RooAbsReal > createRunningIntegral (const RooArgSet &iset, const RooCmdArg &",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:14138,Integrability,integrat,integration,14138,"et &addNormSet=RooArgSet(), bool force=true);  Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by this object to the given set of observables. ;  ; virtual void fixAddCoefRange (const char *rangeName=nullptr, bool force=true);  Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by this object to the given set of observables. ;  ; virtual void forceNumInt (bool flag=true);  ; RooFunctor * functor (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a RooFunctor object bound to this RooAbsReal with given definition of observables and parameters. ;  ; virtual Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; bool getForceNumInt () const;  ; RooNumIntConfig * getIntegratorConfig ();  Return the numeric integration configuration used for this object. ;  ; const RooNumIntConfig * getIntegratorConfig () const;  Return the numeric integration configuration used for this object. ;  ; virtual Int_t getMaxVal (const RooArgSet &vars) const;  Advertise capability to determine maximum value of function for given set of observables. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual double getValV ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:14265,Integrability,integrat,integration,14265,"e headed by this object to the given set of observables. ;  ; virtual void fixAddCoefRange (const char *rangeName=nullptr, bool force=true);  Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by this object to the given set of observables. ;  ; virtual void forceNumInt (bool flag=true);  ; RooFunctor * functor (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a RooFunctor object bound to this RooAbsReal with given definition of observables and parameters. ;  ; virtual Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; bool getForceNumInt () const;  ; RooNumIntConfig * getIntegratorConfig ();  Return the numeric integration configuration used for this object. ;  ; const RooNumIntConfig * getIntegratorConfig () const;  Return the numeric integration configuration used for this object. ;  ; virtual Int_t getMaxVal (const RooArgSet &vars) const;  Advertise capability to determine maximum value of function for given set of observables. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual double getValV (const RooArgSet *normalisationSet=nullptr) const;  Return value of object. ;  ; virtual void gradient (double *) const;  ; virtual bool h",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:15573,Integrability,message,message,15573,"of function for given set of observables. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual double getValV (const RooArgSet *normalisationSet=nullptr) const;  Return value of object. ;  ; virtual void gradient (double *) const;  ; virtual bool hasGradient () const;  ; TClass * IsA () const override;  ; bool isIdentical (const RooAbsArg &other, bool assumeSameType=false) const override;  ; virtual bool isOffsetting () const;  ; bool isSelectedComp () const;  If true, the current pdf is a selected component (for use in plotting) ;  ; void logEvalError (const char *message, const char *serverValueString=nullptr) const;  Log evaluation error message. ;  ; virtual double maxVal (Int_t code) const;  Return maximum value for set of observables identified by code assigned in getMaxVal. ;  ; RooAbsMoment * mean (RooRealVar &obs);  ; RooAbsMoment * mean (RooRealVar &obs, const RooArgSet &nset);  ; virtual Int_t minTrialSamples (const RooArgSet &) const;  ; RooAbsMoment * moment (RooRealVar &obs, const RooArgSet &normObs, Int_t order, bool central, bool takeRoot, bool intNormObs);  Return function representing moment of p.d.f (normalized w.r.t given observables) of given order. ;  ; RooAbsMoment * moment (RooRealVar &obs, Int_t order, bool central, bool takeRoot);  Return function representing moment of function of given order. ;  ; virtual double offset () const;  ; bool operator== (const RooAbsArg &other",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:15650,Integrability,message,message,15650,"of function for given set of observables. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual double getValV (const RooArgSet *normalisationSet=nullptr) const;  Return value of object. ;  ; virtual void gradient (double *) const;  ; virtual bool hasGradient () const;  ; TClass * IsA () const override;  ; bool isIdentical (const RooAbsArg &other, bool assumeSameType=false) const override;  ; virtual bool isOffsetting () const;  ; bool isSelectedComp () const;  If true, the current pdf is a selected component (for use in plotting) ;  ; void logEvalError (const char *message, const char *serverValueString=nullptr) const;  Log evaluation error message. ;  ; virtual double maxVal (Int_t code) const;  Return maximum value for set of observables identified by code assigned in getMaxVal. ;  ; RooAbsMoment * mean (RooRealVar &obs);  ; RooAbsMoment * mean (RooRealVar &obs, const RooArgSet &nset);  ; virtual Int_t minTrialSamples (const RooArgSet &) const;  ; RooAbsMoment * moment (RooRealVar &obs, const RooArgSet &normObs, Int_t order, bool central, bool takeRoot, bool intNormObs);  Return function representing moment of p.d.f (normalized w.r.t given observables) of given order. ;  ; RooAbsMoment * moment (RooRealVar &obs, Int_t order, bool central, bool takeRoot);  Return function representing moment of function of given order. ;  ; virtual double offset () const;  ; bool operator== (const RooAbsArg &other",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:17966,Integrability,integrat,integration,17966,". ;  ; virtual RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const;  Internal back-end function of plotOn() with named arguments. ;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &o",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:18099,Integrability,integrat,integrator,18099,"dObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for now) ;  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constru",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:18143,Integrability,integrat,integration,18143,"dObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for now) ;  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constru",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:18565,Integrability,integrat,integrator,18565,"ing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for now) ;  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constructor. ;  ;  RooAbsArg (const char *name, const char *title);  Create an object with the specified name and descriptive title. ;  ;  RooAbsArg (const RooAbsArg &other, const char *name=nullptr);  Copy constructor transfers all boolean and string properties of the original object. ;  ;  ~RooAbsArg () override;  Destructor. ;  ; bool addOwnedComponents (const RooAbsCollec",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:18706,Integrability,integrat,integrator,18706,"mmy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for now) ;  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constructor. ;  ;  RooAbsArg (const char *name, const char *title);  Create an object with the specified name and descriptive title. ;  ;  RooAbsArg (const RooAbsArg &other, const char *name=nullptr);  Copy constructor transfers all boolean and string properties of the original object. ;  ;  ~RooAbsArg () override;  Destructor. ;  ; bool addOwnedComponents (const RooAbsCollection &comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooAbsCollection &&comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooArgList &&comps",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:20186,Integrability,depend,dependent,20186," ;  RooAbsArg (const char *name, const char *title);  Create an object with the specified name and descriptive title. ;  ;  RooAbsArg (const RooAbsArg &other, const char *name=nullptr);  Copy constructor transfers all boolean and string properties of the original object. ;  ;  ~RooAbsArg () override;  Destructor. ;  ; bool addOwnedComponents (const RooAbsCollection &comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooAbsCollection &&comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooArgList &&comps);  Take ownership of the contents of 'comps'. ;  ; template<typename... Args_t> ; bool addOwnedComponents (std::unique_ptr< Args_t >... comps);  ; virtual void applyWeightSquared (bool flag);  Disables or enables the usage of squared weights. ;  ; void attachArgs (const RooAbsCollection &set);  Bind this node to objects in set. ;  ; void attachDataSet (const RooAbsData &set);  Replace server nodes with names matching the dataset variable names with those data set variables, making this PDF directly dependent on the dataset. ;  ; void attachDataStore (const RooAbsDataStore &set);  Replace server nodes with names matching the dataset variable names with those data set variables, making this PDF directly dependent on the dataset. ;  ; const std::set< std::string > & attributes () const;  ; virtual bool canComputeBatchWithCuda () const;  ; virtual bool checkObservables (const RooArgSet *nset) const;  Overloadable function in which derived classes can implement consistency checks of the variables. ;  ; TObject * Clone (const char *newname=nullptr) const override;  Make a clone of an object using the Streamer facility. ;  ; virtual RooAbsArg * cloneTree (const char *newname=nullptr) const;  Clone tree expression of objects. ;  ; Int_t Compare (const TObject *other) const override;  Utility function used by TCollection::Sort to compare contained TObjects We implement comparison by name, resulting in alphabetical ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:20393,Integrability,depend,dependent,20393," transfers all boolean and string properties of the original object. ;  ;  ~RooAbsArg () override;  Destructor. ;  ; bool addOwnedComponents (const RooAbsCollection &comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooAbsCollection &&comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooArgList &&comps);  Take ownership of the contents of 'comps'. ;  ; template<typename... Args_t> ; bool addOwnedComponents (std::unique_ptr< Args_t >... comps);  ; virtual void applyWeightSquared (bool flag);  Disables or enables the usage of squared weights. ;  ; void attachArgs (const RooAbsCollection &set);  Bind this node to objects in set. ;  ; void attachDataSet (const RooAbsData &set);  Replace server nodes with names matching the dataset variable names with those data set variables, making this PDF directly dependent on the dataset. ;  ; void attachDataStore (const RooAbsDataStore &set);  Replace server nodes with names matching the dataset variable names with those data set variables, making this PDF directly dependent on the dataset. ;  ; const std::set< std::string > & attributes () const;  ; virtual bool canComputeBatchWithCuda () const;  ; virtual bool checkObservables (const RooArgSet *nset) const;  Overloadable function in which derived classes can implement consistency checks of the variables. ;  ; TObject * Clone (const char *newname=nullptr) const override;  Make a clone of an object using the Streamer facility. ;  ; virtual RooAbsArg * cloneTree (const char *newname=nullptr) const;  Clone tree expression of objects. ;  ; Int_t Compare (const TObject *other) const override;  Utility function used by TCollection::Sort to compare contained TObjects We implement comparison by name, resulting in alphabetical sorting by object name. ;  ; virtual std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const;  ; std::size_t dataToken () const;  Returns the t",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:21493,Integrability,depend,dependsOn,21493,"gSet *nset) const;  Overloadable function in which derived classes can implement consistency checks of the variables. ;  ; TObject * Clone (const char *newname=nullptr) const override;  Make a clone of an object using the Streamer facility. ;  ; virtual RooAbsArg * cloneTree (const char *newname=nullptr) const;  Clone tree expression of objects. ;  ; Int_t Compare (const TObject *other) const override;  Utility function used by TCollection::Sort to compare contained TObjects We implement comparison by name, resulting in alphabetical sorting by object name. ;  ; virtual std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const;  ; std::size_t dataToken () const;  Returns the token for retrieving results in the BatchMode. For internal use only. ;  ; Int_t defaultPrintContents (Option_t *opt) const override;  Define default contents to print. ;  ; bool dependsOn (const RooAbsArg &server, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) the specified object. ;  ; bool dependsOn (const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) any object in the specified collection. ;  ; bool dependsOn (TNamed const *namePtr, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) an object with a specific name. ;  ; bool dependsOnValue (const RooAbsArg &server, const RooAbsArg *ignoreArg=nullptr) const;  Check whether this object depends on values served from the object passed as server. ;  ; bool dependsOnValue (const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr) const;  Check whether this object depends on values from an element in the serverList. ;  ; bool getAttribute (const Text_t *name) const;  Check if a named attribute is set. By default, all attributes are unset. ;  ; RooFit::OwningPtr",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:21611,Integrability,depend,depend,21611,"gSet *nset) const;  Overloadable function in which derived classes can implement consistency checks of the variables. ;  ; TObject * Clone (const char *newname=nullptr) const override;  Make a clone of an object using the Streamer facility. ;  ; virtual RooAbsArg * cloneTree (const char *newname=nullptr) const;  Clone tree expression of objects. ;  ; Int_t Compare (const TObject *other) const override;  Utility function used by TCollection::Sort to compare contained TObjects We implement comparison by name, resulting in alphabetical sorting by object name. ;  ; virtual std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const;  ; std::size_t dataToken () const;  Returns the token for retrieving results in the BatchMode. For internal use only. ;  ; Int_t defaultPrintContents (Option_t *opt) const override;  Define default contents to print. ;  ; bool dependsOn (const RooAbsArg &server, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) the specified object. ;  ; bool dependsOn (const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) any object in the specified collection. ;  ; bool dependsOn (TNamed const *namePtr, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) an object with a specific name. ;  ; bool dependsOnValue (const RooAbsArg &server, const RooAbsArg *ignoreArg=nullptr) const;  Check whether this object depends on values served from the object passed as server. ;  ; bool dependsOnValue (const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr) const;  Check whether this object depends on values from an element in the serverList. ;  ; bool getAttribute (const Text_t *name) const;  Check if a named attribute is set. By default, all attributes are unset. ;  ; RooFit::OwningPtr",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:21673,Integrability,depend,dependsOn,21673,"lone of an object using the Streamer facility. ;  ; virtual RooAbsArg * cloneTree (const char *newname=nullptr) const;  Clone tree expression of objects. ;  ; Int_t Compare (const TObject *other) const override;  Utility function used by TCollection::Sort to compare contained TObjects We implement comparison by name, resulting in alphabetical sorting by object name. ;  ; virtual std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const;  ; std::size_t dataToken () const;  Returns the token for retrieving results in the BatchMode. For internal use only. ;  ; Int_t defaultPrintContents (Option_t *opt) const override;  Define default contents to print. ;  ; bool dependsOn (const RooAbsArg &server, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) the specified object. ;  ; bool dependsOn (const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) any object in the specified collection. ;  ; bool dependsOn (TNamed const *namePtr, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) an object with a specific name. ;  ; bool dependsOnValue (const RooAbsArg &server, const RooAbsArg *ignoreArg=nullptr) const;  Check whether this object depends on values served from the object passed as server. ;  ; bool dependsOnValue (const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr) const;  Check whether this object depends on values from an element in the serverList. ;  ; bool getAttribute (const Text_t *name) const;  Check if a named attribute is set. By default, all attributes are unset. ;  ; RooFit::OwningPtr< RooArgSet > getComponents () const;  Create a RooArgSet with all components (branch nodes) of the expression tree headed by this object. ;  ; bool getObservables (const RooAbsCollection *depLis",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:21802,Integrability,depend,depend,21802,"lone of an object using the Streamer facility. ;  ; virtual RooAbsArg * cloneTree (const char *newname=nullptr) const;  Clone tree expression of objects. ;  ; Int_t Compare (const TObject *other) const override;  Utility function used by TCollection::Sort to compare contained TObjects We implement comparison by name, resulting in alphabetical sorting by object name. ;  ; virtual std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const;  ; std::size_t dataToken () const;  Returns the token for retrieving results in the BatchMode. For internal use only. ;  ; Int_t defaultPrintContents (Option_t *opt) const override;  Define default contents to print. ;  ; bool dependsOn (const RooAbsArg &server, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) the specified object. ;  ; bool dependsOn (const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) any object in the specified collection. ;  ; bool dependsOn (TNamed const *namePtr, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) an object with a specific name. ;  ; bool dependsOnValue (const RooAbsArg &server, const RooAbsArg *ignoreArg=nullptr) const;  Check whether this object depends on values served from the object passed as server. ;  ; bool dependsOnValue (const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr) const;  Check whether this object depends on values from an element in the serverList. ;  ; bool getAttribute (const Text_t *name) const;  Check if a named attribute is set. By default, all attributes are unset. ;  ; RooFit::OwningPtr< RooArgSet > getComponents () const;  Create a RooArgSet with all components (branch nodes) of the expression tree headed by this object. ;  ; bool getObservables (const RooAbsCollection *depLis",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:21882,Integrability,depend,dependsOn,21882,"st override;  Utility function used by TCollection::Sort to compare contained TObjects We implement comparison by name, resulting in alphabetical sorting by object name. ;  ; virtual std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const;  ; std::size_t dataToken () const;  Returns the token for retrieving results in the BatchMode. For internal use only. ;  ; Int_t defaultPrintContents (Option_t *opt) const override;  Define default contents to print. ;  ; bool dependsOn (const RooAbsArg &server, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) the specified object. ;  ; bool dependsOn (const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) any object in the specified collection. ;  ; bool dependsOn (TNamed const *namePtr, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) an object with a specific name. ;  ; bool dependsOnValue (const RooAbsArg &server, const RooAbsArg *ignoreArg=nullptr) const;  Check whether this object depends on values served from the object passed as server. ;  ; bool dependsOnValue (const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr) const;  Check whether this object depends on values from an element in the serverList. ;  ; bool getAttribute (const Text_t *name) const;  Check if a named attribute is set. By default, all attributes are unset. ;  ; RooFit::OwningPtr< RooArgSet > getComponents () const;  Create a RooArgSet with all components (branch nodes) of the expression tree headed by this object. ;  ; bool getObservables (const RooAbsCollection *depList, RooArgSet &outputSet, bool valueOnly=true) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that match any of the names the args in the supplied argset. ;  ; ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:21998,Integrability,depend,depend,21998,"st override;  Utility function used by TCollection::Sort to compare contained TObjects We implement comparison by name, resulting in alphabetical sorting by object name. ;  ; virtual std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const;  ; std::size_t dataToken () const;  Returns the token for retrieving results in the BatchMode. For internal use only. ;  ; Int_t defaultPrintContents (Option_t *opt) const override;  Define default contents to print. ;  ; bool dependsOn (const RooAbsArg &server, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) the specified object. ;  ; bool dependsOn (const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) any object in the specified collection. ;  ; bool dependsOn (TNamed const *namePtr, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) an object with a specific name. ;  ; bool dependsOnValue (const RooAbsArg &server, const RooAbsArg *ignoreArg=nullptr) const;  Check whether this object depends on values served from the object passed as server. ;  ; bool dependsOnValue (const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr) const;  Check whether this object depends on values from an element in the serverList. ;  ; bool getAttribute (const Text_t *name) const;  Check if a named attribute is set. By default, all attributes are unset. ;  ; RooFit::OwningPtr< RooArgSet > getComponents () const;  Create a RooArgSet with all components (branch nodes) of the expression tree headed by this object. ;  ; bool getObservables (const RooAbsCollection *depList, RooArgSet &outputSet, bool valueOnly=true) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that match any of the names the args in the supplied argset. ;  ; ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:22070,Integrability,depend,dependsOnValue,22070,"td::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const;  ; std::size_t dataToken () const;  Returns the token for retrieving results in the BatchMode. For internal use only. ;  ; Int_t defaultPrintContents (Option_t *opt) const override;  Define default contents to print. ;  ; bool dependsOn (const RooAbsArg &server, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) the specified object. ;  ; bool dependsOn (const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) any object in the specified collection. ;  ; bool dependsOn (TNamed const *namePtr, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) an object with a specific name. ;  ; bool dependsOnValue (const RooAbsArg &server, const RooAbsArg *ignoreArg=nullptr) const;  Check whether this object depends on values served from the object passed as server. ;  ; bool dependsOnValue (const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr) const;  Check whether this object depends on values from an element in the serverList. ;  ; bool getAttribute (const Text_t *name) const;  Check if a named attribute is set. By default, all attributes are unset. ;  ; RooFit::OwningPtr< RooArgSet > getComponents () const;  Create a RooArgSet with all components (branch nodes) of the expression tree headed by this object. ;  ; bool getObservables (const RooAbsCollection *depList, RooArgSet &outputSet, bool valueOnly=true) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that match any of the names the args in the supplied argset. ;  ; RooFit::OwningPtr< RooArgSet > getObservables (const RooAbsData &data) const;  Return the observables of this pdf given the observables defined by data. ;  ; RooFit::OwningPtr< RooArgS",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:22181,Integrability,depend,depends,22181,"td::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const;  ; std::size_t dataToken () const;  Returns the token for retrieving results in the BatchMode. For internal use only. ;  ; Int_t defaultPrintContents (Option_t *opt) const override;  Define default contents to print. ;  ; bool dependsOn (const RooAbsArg &server, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) the specified object. ;  ; bool dependsOn (const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) any object in the specified collection. ;  ; bool dependsOn (TNamed const *namePtr, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) an object with a specific name. ;  ; bool dependsOnValue (const RooAbsArg &server, const RooAbsArg *ignoreArg=nullptr) const;  Check whether this object depends on values served from the object passed as server. ;  ; bool dependsOnValue (const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr) const;  Check whether this object depends on values from an element in the serverList. ;  ; bool getAttribute (const Text_t *name) const;  Check if a named attribute is set. By default, all attributes are unset. ;  ; RooFit::OwningPtr< RooArgSet > getComponents () const;  Create a RooArgSet with all components (branch nodes) of the expression tree headed by this object. ;  ; bool getObservables (const RooAbsCollection *depList, RooArgSet &outputSet, bool valueOnly=true) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that match any of the names the args in the supplied argset. ;  ; RooFit::OwningPtr< RooArgSet > getObservables (const RooAbsData &data) const;  Return the observables of this pdf given the observables defined by data. ;  ; RooFit::OwningPtr< RooArgS",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:22250,Integrability,depend,dependsOnValue,22250,"ing results in the BatchMode. For internal use only. ;  ; Int_t defaultPrintContents (Option_t *opt) const override;  Define default contents to print. ;  ; bool dependsOn (const RooAbsArg &server, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) the specified object. ;  ; bool dependsOn (const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) any object in the specified collection. ;  ; bool dependsOn (TNamed const *namePtr, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) an object with a specific name. ;  ; bool dependsOnValue (const RooAbsArg &server, const RooAbsArg *ignoreArg=nullptr) const;  Check whether this object depends on values served from the object passed as server. ;  ; bool dependsOnValue (const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr) const;  Check whether this object depends on values from an element in the serverList. ;  ; bool getAttribute (const Text_t *name) const;  Check if a named attribute is set. By default, all attributes are unset. ;  ; RooFit::OwningPtr< RooArgSet > getComponents () const;  Create a RooArgSet with all components (branch nodes) of the expression tree headed by this object. ;  ; bool getObservables (const RooAbsCollection *depList, RooArgSet &outputSet, bool valueOnly=true) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that match any of the names the args in the supplied argset. ;  ; RooFit::OwningPtr< RooArgSet > getObservables (const RooAbsData &data) const;  Return the observables of this pdf given the observables defined by data. ;  ; RooFit::OwningPtr< RooArgSet > getObservables (const RooAbsData *data) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that match any of the names of the variable list of ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:22372,Integrability,depend,depends,22372,"ing results in the BatchMode. For internal use only. ;  ; Int_t defaultPrintContents (Option_t *opt) const override;  Define default contents to print. ;  ; bool dependsOn (const RooAbsArg &server, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) the specified object. ;  ; bool dependsOn (const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) any object in the specified collection. ;  ; bool dependsOn (TNamed const *namePtr, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) const;  Test whether we depend on (ie, are served by) an object with a specific name. ;  ; bool dependsOnValue (const RooAbsArg &server, const RooAbsArg *ignoreArg=nullptr) const;  Check whether this object depends on values served from the object passed as server. ;  ; bool dependsOnValue (const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr) const;  Check whether this object depends on values from an element in the serverList. ;  ; bool getAttribute (const Text_t *name) const;  Check if a named attribute is set. By default, all attributes are unset. ;  ; RooFit::OwningPtr< RooArgSet > getComponents () const;  Create a RooArgSet with all components (branch nodes) of the expression tree headed by this object. ;  ; bool getObservables (const RooAbsCollection *depList, RooArgSet &outputSet, bool valueOnly=true) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that match any of the names the args in the supplied argset. ;  ; RooFit::OwningPtr< RooArgSet > getObservables (const RooAbsData &data) const;  Return the observables of this pdf given the observables defined by data. ;  ; RooFit::OwningPtr< RooArgSet > getObservables (const RooAbsData *data) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that match any of the names of the variable list of ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:23359,Integrability,depend,dependents,23359," bool dependsOnValue (const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr) const;  Check whether this object depends on values from an element in the serverList. ;  ; bool getAttribute (const Text_t *name) const;  Check if a named attribute is set. By default, all attributes are unset. ;  ; RooFit::OwningPtr< RooArgSet > getComponents () const;  Create a RooArgSet with all components (branch nodes) of the expression tree headed by this object. ;  ; bool getObservables (const RooAbsCollection *depList, RooArgSet &outputSet, bool valueOnly=true) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that match any of the names the args in the supplied argset. ;  ; RooFit::OwningPtr< RooArgSet > getObservables (const RooAbsData &data) const;  Return the observables of this pdf given the observables defined by data. ;  ; RooFit::OwningPtr< RooArgSet > getObservables (const RooAbsData *data) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that match any of the names of the variable list of the supplied data set (the dependents). ;  ; RooFit::OwningPtr< RooArgSet > getObservables (const RooArgSet &set, bool valueOnly=true) const;  Given a set of possible observables, return the observables that this PDF depends on. ;  ; RooFit::OwningPtr< RooArgSet > getObservables (const RooArgSet *depList, bool valueOnly=true) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that match any of the names the args in the supplied argset. ;  ; RooFit::OwningPtr< RooArgSet > getParameters (const RooAbsData &data, bool stripDisconnected=true) const;  Return the parameters of this p.d.f when used in conjunction with dataset 'data'. ;  ; RooFit::OwningPtr< RooArgSet > getParameters (const RooAbsData *data, bool stripDisconnected=true) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that don't match any of the names of the variable lis",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:23549,Integrability,depend,depends,23549,"me) const;  Check if a named attribute is set. By default, all attributes are unset. ;  ; RooFit::OwningPtr< RooArgSet > getComponents () const;  Create a RooArgSet with all components (branch nodes) of the expression tree headed by this object. ;  ; bool getObservables (const RooAbsCollection *depList, RooArgSet &outputSet, bool valueOnly=true) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that match any of the names the args in the supplied argset. ;  ; RooFit::OwningPtr< RooArgSet > getObservables (const RooAbsData &data) const;  Return the observables of this pdf given the observables defined by data. ;  ; RooFit::OwningPtr< RooArgSet > getObservables (const RooAbsData *data) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that match any of the names of the variable list of the supplied data set (the dependents). ;  ; RooFit::OwningPtr< RooArgSet > getObservables (const RooArgSet &set, bool valueOnly=true) const;  Given a set of possible observables, return the observables that this PDF depends on. ;  ; RooFit::OwningPtr< RooArgSet > getObservables (const RooArgSet *depList, bool valueOnly=true) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that match any of the names the args in the supplied argset. ;  ; RooFit::OwningPtr< RooArgSet > getParameters (const RooAbsData &data, bool stripDisconnected=true) const;  Return the parameters of this p.d.f when used in conjunction with dataset 'data'. ;  ; RooFit::OwningPtr< RooArgSet > getParameters (const RooAbsData *data, bool stripDisconnected=true) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that don't match any of the names of the variable list of the supplied data set (the dependents). ;  ; RooFit::OwningPtr< RooArgSet > getParameters (const RooArgSet &observables, bool stripDisconnected=true) const;  Return the parameters of the p.d.f given the provided set o",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:24276,Integrability,depend,dependents,24276,"oArgSet > getObservables (const RooAbsData *data) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that match any of the names of the variable list of the supplied data set (the dependents). ;  ; RooFit::OwningPtr< RooArgSet > getObservables (const RooArgSet &set, bool valueOnly=true) const;  Given a set of possible observables, return the observables that this PDF depends on. ;  ; RooFit::OwningPtr< RooArgSet > getObservables (const RooArgSet *depList, bool valueOnly=true) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that match any of the names the args in the supplied argset. ;  ; RooFit::OwningPtr< RooArgSet > getParameters (const RooAbsData &data, bool stripDisconnected=true) const;  Return the parameters of this p.d.f when used in conjunction with dataset 'data'. ;  ; RooFit::OwningPtr< RooArgSet > getParameters (const RooAbsData *data, bool stripDisconnected=true) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that don't match any of the names of the variable list of the supplied data set (the dependents). ;  ; RooFit::OwningPtr< RooArgSet > getParameters (const RooArgSet &observables, bool stripDisconnected=true) const;  Return the parameters of the p.d.f given the provided set of observables. ;  ; RooFit::OwningPtr< RooArgSet > getParameters (const RooArgSet *observables, bool stripDisconnected=true) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that don't match any of the names the args in the supplied argset. ;  ; virtual bool getParameters (const RooArgSet *observables, RooArgSet &outputSet, bool stripDisconnected=true) const;  Fills a list with leaf nodes in the arg tree starting with ourself as top node that don't match any of the names the args in the supplied argset. ;  ; RooAbsProxy * getProxy (Int_t index) const;  Return the nth proxy from the proxy list. ;  ; const Text_t * getStringAttribute (",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:26299,Integrability,depend,depend,26299,"connected=true) const;  Return RooArgSet with all variables (tree leaf nodes of expression tree) ;  ; void graphVizTree (const char *fileName, const char *delimiter=""\n"", bool useTitle=false, bool useLatex=false);  Create a GraphViz .dot file visualizing the expression tree headed by this RooAbsArg object. ;  ; void graphVizTree (std::ostream &os, const char *delimiter=""\n"", bool useTitle=false, bool useLatex=false);  Write the GraphViz representation of the expression tree headed by this RooAbsArg object to the given ostream. ;  ; bool hasClients () const;  ; bool hasDataToken () const;  ; virtual bool hasRange (const char *) const;  ; virtual bool importWorkspaceHook (RooWorkspace &ws);  ; virtual bool inRange (const char *) const;  ; virtual bool isCategory () const;  ; bool isConstant () const;  Check if the ""Constant"" attribute is set. ;  ; virtual bool isDerived () const;  Does value or shape of this arg depend on any other arg? ;  ; virtual bool isReducerNode () const;  ; bool IsSortable () const override;  ; bool localNoDirtyInhibit () const;  ; const TNamed * namePtr () const;  De-duplicated pointer to this object's name. ;  ; Int_t numProxies () const;  Return the number of registered proxies. ;  ; bool observableOverlaps (const RooAbsData *dset, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; bool observableOverlaps (const RooArgSet *depList, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; RooAbsArg & operator= (const RooAbsArg &other)=delete;  ; bool overlaps (const RooAbsArg &testArg, bool valueOnly=false) const;  Test if any of the nodes of tree are shared with that of the given tree. ;  ; const RooArgSet * ownedComponents () const;  ; void Print (Option_t *options=nullptr) const override;  Print the object to the defaultPrintStream(). ;  ; v",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:26705,Integrability,depend,dependents,26705,"izTree (std::ostream &os, const char *delimiter=""\n"", bool useTitle=false, bool useLatex=false);  Write the GraphViz representation of the expression tree headed by this RooAbsArg object to the given ostream. ;  ; bool hasClients () const;  ; bool hasDataToken () const;  ; virtual bool hasRange (const char *) const;  ; virtual bool importWorkspaceHook (RooWorkspace &ws);  ; virtual bool inRange (const char *) const;  ; virtual bool isCategory () const;  ; bool isConstant () const;  Check if the ""Constant"" attribute is set. ;  ; virtual bool isDerived () const;  Does value or shape of this arg depend on any other arg? ;  ; virtual bool isReducerNode () const;  ; bool IsSortable () const override;  ; bool localNoDirtyInhibit () const;  ; const TNamed * namePtr () const;  De-duplicated pointer to this object's name. ;  ; Int_t numProxies () const;  Return the number of registered proxies. ;  ; bool observableOverlaps (const RooAbsData *dset, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; bool observableOverlaps (const RooArgSet *depList, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; RooAbsArg & operator= (const RooAbsArg &other)=delete;  ; bool overlaps (const RooAbsArg &testArg, bool valueOnly=false) const;  Test if any of the nodes of tree are shared with that of the given tree. ;  ; const RooArgSet * ownedComponents () const;  ; void Print (Option_t *options=nullptr) const override;  Print the object to the defaultPrintStream(). ;  ; void printAddress (std::ostream &os) const override;  Print address of this RooAbsArg. ;  ; void printArgs (std::ostream &os) const override;  Print object arguments, ie its proxies. ;  ; void printClassName (std::ostream &os) const override;  Print object class name. ;  ; void printCompactTree (const char *indent="""", const",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:26911,Integrability,depend,dependents,26911,"am. ;  ; bool hasClients () const;  ; bool hasDataToken () const;  ; virtual bool hasRange (const char *) const;  ; virtual bool importWorkspaceHook (RooWorkspace &ws);  ; virtual bool inRange (const char *) const;  ; virtual bool isCategory () const;  ; bool isConstant () const;  Check if the ""Constant"" attribute is set. ;  ; virtual bool isDerived () const;  Does value or shape of this arg depend on any other arg? ;  ; virtual bool isReducerNode () const;  ; bool IsSortable () const override;  ; bool localNoDirtyInhibit () const;  ; const TNamed * namePtr () const;  De-duplicated pointer to this object's name. ;  ; Int_t numProxies () const;  Return the number of registered proxies. ;  ; bool observableOverlaps (const RooAbsData *dset, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; bool observableOverlaps (const RooArgSet *depList, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; RooAbsArg & operator= (const RooAbsArg &other)=delete;  ; bool overlaps (const RooAbsArg &testArg, bool valueOnly=false) const;  Test if any of the nodes of tree are shared with that of the given tree. ;  ; const RooArgSet * ownedComponents () const;  ; void Print (Option_t *options=nullptr) const override;  Print the object to the defaultPrintStream(). ;  ; void printAddress (std::ostream &os) const override;  Print address of this RooAbsArg. ;  ; void printArgs (std::ostream &os) const override;  Print object arguments, ie its proxies. ;  ; void printClassName (std::ostream &os) const override;  Print object class name. ;  ; void printCompactTree (const char *indent="""", const char *fileName=nullptr, const char *namePat=nullptr, RooAbsArg *client=nullptr);  Print tree structure of expression tree on stdout, or to file if filename is specified. ;  ; void printCompactTree (std::o",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:28149,Integrability,interface,interface,28149,"y of the nodes of tree are shared with that of the given tree. ;  ; const RooArgSet * ownedComponents () const;  ; void Print (Option_t *options=nullptr) const override;  Print the object to the defaultPrintStream(). ;  ; void printAddress (std::ostream &os) const override;  Print address of this RooAbsArg. ;  ; void printArgs (std::ostream &os) const override;  Print object arguments, ie its proxies. ;  ; void printClassName (std::ostream &os) const override;  Print object class name. ;  ; void printCompactTree (const char *indent="""", const char *fileName=nullptr, const char *namePat=nullptr, RooAbsArg *client=nullptr);  Print tree structure of expression tree on stdout, or to file if filename is specified. ;  ; void printCompactTree (std::ostream &os, const char *indent="""", const char *namePat=nullptr, RooAbsArg *client=nullptr);  Print tree structure of expression tree on given ostream. ;  ; virtual void printCompactTreeHook (std::ostream &os, const char *ind="""");  Hook function interface for object to insert additional information when printed in the context of a tree structure. ;  ; void printComponentTree (const char *indent="""", const char *namePat=nullptr, Int_t nLevel=999);  Print tree structure of expression tree on given ostream, only branch nodes are printed. ;  ; void printDirty (bool depth=true) const;  Print information about current value dirty state information. ;  ; virtual void printMetaArgs (std::ostream &) const;  ; void printName (std::ostream &os) const override;  Print object name. ;  ; void printTitle (std::ostream &os) const override;  Print object title. ;  ; void printTree (std::ostream &os, TString indent="""") const override;  Print object tree structure. ;  ; bool recursiveCheckObservables (const RooArgSet *nset) const;  Recursively call checkObservables on all nodes in the expression tree. ;  ; void removeStringAttribute (const Text_t *key);  Delete a string attribute with a given key. ;  ; void resetDataToken ();  ; void setAttribute (co",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:32413,Integrability,integrat,integrated,32413," *list, const RooAbsArg *arg=nullptr, bool recurseNonDerived=false) const;  Fill supplied list with all leaf nodes of the arg tree, starting with ourself as top node. ;  ; void branchNodeServerList (RooAbsCollection *list, const RooAbsArg *arg=nullptr, bool recurseNonDerived=false) const;  Fill supplied list with all branch nodes of the arg tree starting with ourself as top node. ;  ; void treeNodeServerList (RooAbsCollection *list, const RooAbsArg *arg=nullptr, bool doBranch=true, bool doLeaf=true, bool valueOnly=false, bool recurseNonDerived=false) const;  Fill supplied list with nodes of the arg tree, following all server links, starting with ourself as top node. ;  ; virtual bool isFundamental () const;  Is this object a fundamental type that can be added to a dataset? Fundamental-type subclasses override this method to return true. ;  ; virtual bool isLValue () const;  Is this argument an l-value, i.e., can it appear on the left-hand side of an assignment expression? LValues are also special since they can potentially be analytically integrated and generated. ;  ; bool redirectServers (const RooAbsCollection &newServerList, bool mustReplaceAll=false, bool nameChange=false, bool isRecursionStep=false);  Replace all direct servers of this object with the new servers in newServerList. ;  ; bool redirectServers (std::unordered_map< RooAbsArg *, RooAbsArg * > const &replacements);  Replace some servers of this object. ;  ; bool recursiveRedirectServers (const RooAbsCollection &newServerList, bool mustReplaceAll=false, bool nameChange=false, bool recurseInNewSet=true);  Recursively replace all servers with the new servers in newSet. ;  ; virtual void serverNameChangeHook (const RooAbsArg *, const RooAbsArg *);  ; void addServer (RooAbsArg &server, bool valueProp=true, bool shapeProp=false, std::size_t refCount=1);  Register another RooAbsArg as a server to us, ie, declare that we depend on it. ;  ; void addServerList (RooAbsCollection &serverList, bool valueProp=true",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:33270,Integrability,depend,depend,33270,"tal-type subclasses override this method to return true. ;  ; virtual bool isLValue () const;  Is this argument an l-value, i.e., can it appear on the left-hand side of an assignment expression? LValues are also special since they can potentially be analytically integrated and generated. ;  ; bool redirectServers (const RooAbsCollection &newServerList, bool mustReplaceAll=false, bool nameChange=false, bool isRecursionStep=false);  Replace all direct servers of this object with the new servers in newServerList. ;  ; bool redirectServers (std::unordered_map< RooAbsArg *, RooAbsArg * > const &replacements);  Replace some servers of this object. ;  ; bool recursiveRedirectServers (const RooAbsCollection &newServerList, bool mustReplaceAll=false, bool nameChange=false, bool recurseInNewSet=true);  Recursively replace all servers with the new servers in newSet. ;  ; virtual void serverNameChangeHook (const RooAbsArg *, const RooAbsArg *);  ; void addServer (RooAbsArg &server, bool valueProp=true, bool shapeProp=false, std::size_t refCount=1);  Register another RooAbsArg as a server to us, ie, declare that we depend on it. ;  ; void addServerList (RooAbsCollection &serverList, bool valueProp=true, bool shapeProp=false);  Register a list of RooAbsArg as servers to us by calling addServer() for each arg in the list. ;  ; void replaceServer (RooAbsArg &oldServer, RooAbsArg &newServer, bool valueProp, bool shapeProp);  Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old s",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:33967,Integrability,depend,depend,33967,"Change=false, bool recurseInNewSet=true);  Recursively replace all servers with the new servers in newSet. ;  ; virtual void serverNameChangeHook (const RooAbsArg *, const RooAbsArg *);  ; void addServer (RooAbsArg &server, bool valueProp=true, bool shapeProp=false, std::size_t refCount=1);  Register another RooAbsArg as a server to us, ie, declare that we depend on it. ;  ; void addServerList (RooAbsCollection &serverList, bool valueProp=true, bool shapeProp=false);  Register a list of RooAbsArg as servers to us by calling addServer() for each arg in the list. ;  ; void replaceServer (RooAbsArg &oldServer, RooAbsArg &newServer, bool valueProp, bool shapeProp);  Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:36632,Integrability,depend,dependentOverlaps,36632,"es. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooAbsData *dset;  ;  R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooArgSet *depList;  ;  R__DEPRECATED (6, 36, ""Use checkObservables()."") inline bool checkDependents(const RooArgSet *nset) const;  ;  R__DEPRECATED (6, 36, ""Use recursiveCheckObservables()."") inline bool recursiveCheckDependents(const RooArgSet *nset) const;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void F",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:36741,Integrability,depend,dependentOverlaps,36741,"operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooAbsData *dset;  ;  R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooArgSet *depList;  ;  R__DEPRECATED (6, 36, ""Use checkObservables()."") inline bool checkDependents(const RooArgSet *nset) const;  ;  R__DEPRECATED (6, 36, ""Use recursiveCheckObservables()."") inline bool recursiveCheckDependents(const RooArgSet *nset) const;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  R",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:40062,Integrability,message,message,40062,"ject. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:40603,Integrability,message,message,40603,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:41593,Integrability,message,message,41593,"ssue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class shou",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:44687,Integrability,message,message,44687,"n object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption s",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:45060,Integrability,message,message,45060," Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char *",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:46976,Integrability,message,messages,46976,"tentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static RooArgList createParamSet (const std::string &, Int_t, double, double);  Create the list of RooRealVar parameters which represent the height of the histogram bins. ;  ; static RooArgList createParamSet (RooWorkspace &w, const std::string &, const RooArgList &Vars);  Create the list of RooRealVar parameters which represent the height of the histogram bins. ;  ; static RooArgList createParamSet (RooWorkspace &w, const std::string &, const RooArgList &Vars, double, double);  Create the list of RooRealVar parameters which scale the height of histogram bins. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static voi",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:47113,Integrability,integrat,integration,47113,"tatic constexpr Version_t Class_Version ();  ; static RooArgList createParamSet (const std::string &, Int_t, double, double);  Create the list of RooRealVar parameters which represent the height of the histogram bins. ;  ; static RooArgList createParamSet (RooWorkspace &w, const std::string &, const RooArgList &Vars);  Create the list of RooRealVar parameters which represent the height of the histogram bins. ;  ; static RooArgList createParamSet (RooWorkspace &w, const std::string &, const RooArgList &Vars, double, double);  Create the list of RooRealVar parameters which scale the height of histogram bins. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:47515,Integrability,message,message,47515,"pace &w, const std::string &, const RooArgList &Vars, double, double);  Create the list of RooRealVar parameters which scale the height of histogram bins. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Versi",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:47606,Integrability,message,messages,47606,"pace &w, const std::string &, const RooArgList &Vars, double, double);  Create the list of RooRealVar parameters which scale the height of histogram bins. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Versi",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:51572,Integrability,integrat,integrated,51572,"ttachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, normalization observables and the integration range name. ;  ; bool isValid () const override;  Check if current value is valid. ;  ; virtual bool isValidReal (double, bool printError=false) const;  Interface function to check if given value is a valid value for this object. Returns true unless overridden. ;  ; void makeProjectionSet (const RooAbsArg *plotVar, const RooArgSet *allVars, RooArgSet &projectedVars, bool silent) const;  Utility function for plotOn() that constructs the set of observables to project when plotting ourselves as function of 'plotVar'. ;  ; bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a, const RooArgProxy &b) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matc",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:51630,Integrability,integrat,integration,51630,"ttachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, normalization observables and the integration range name. ;  ; bool isValid () const override;  Check if current value is valid. ;  ; virtual bool isValidReal (double, bool printError=false) const;  Interface function to check if given value is a valid value for this object. Returns true unless overridden. ;  ; void makeProjectionSet (const RooAbsArg *plotVar, const RooArgSet *allVars, RooArgSet &projectedVars, bool silent) const;  Utility function for plotOn() that constructs the set of observables to project when plotting ourselves as function of 'plotVar'. ;  ; bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a, const RooArgProxy &b) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matc",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:54814,Integrability,wrap,wrapper,54814,"bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  Function that is called at the end of redirectServers(). ;  ; virtual void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; virtual void selectNormalizationRange (const char *rangeName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:57820,Integrability,integrat,integration,57820,"y &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static Int_t GetNumBins (const RooArgSet &vars);  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  . Protected Attributes; RooDataHist _dataSet;  ; RooListProxy _dataVars;  The RooRealVars. ;  ; RooObjCacheManager _normIntMgr;  ! The integration cache manager ;  ; Int_t _numBins = 0;  ; NumBins _numBinsPerDim;  ; RooListProxy _paramSet;  interpolation parameters ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clie",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:58049,Integrability,integrat,integration,58049,"y &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static Int_t GetNumBins (const RooArgSet &vars);  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  . Protected Attributes; RooDataHist _dataSet;  ; RooListProxy _dataVars;  The RooRealVars. ;  ; RooObjCacheManager _normIntMgr;  ! The integration cache manager ;  ; Int_t _numBins = 0;  ; NumBins _numBinsPerDim;  ; RooListProxy _paramSet;  interpolation parameters ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clie",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:64680,Integrability,integrat,integrations,64680,"ich returns bin-wise values. ; This class allows to multiply bin contents of histograms with the values of a set of RooAbsReal.; The value of the function in the ith bin is given by: ; \[; F(i) = \gamma_{i} * \mathrm{nominal}(i); \]. Where the nominal values are taken from the histogram, and the \( \gamma_{i} \) can be set from the outside. ; Definition at line 124 of file ParamHistFunc.cxx. ◆ ParamHistFunc() [4/4]. ParamHistFunc::ParamHistFunc ; (; const ParamHistFunc & ; other, . const char * ; name = nullptr . ). Definition at line 173 of file ParamHistFunc.cxx. Member Function Documentation. ◆ addParamSet(). Int_t ParamHistFunc::addParamSet ; (; const RooArgList & ; params). protected . Definition at line 524 of file ParamHistFunc.cxx. ◆ analyticalIntegralWN(). double ParamHistFunc::analyticalIntegralWN ; (; Int_t ; code, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Implement analytical integrations by doing appropriate weighting from component integrals functions to integrators of components. ; Reimplemented from RooAbsReal.; Definition at line 655 of file ParamHistFunc.cxx. ◆ binBoundaries(). std::list< double > * ParamHistFunc::binBoundaries ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ; Reimplemented from RooAbsReal.; Definition at line 721 of file ParamHistFunc.cxx. ◆ binVolume(). double ParamHistFunc::binVolume ; (; ); const. inline . Definition at line 49 of file ParamHistFunc.h. ◆ Class(). static TClass * ParamHistFunc::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * ParamHistFunc::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t ParamHistFunc::Cla",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:64762,Integrability,integrat,integrators,64762,"ich returns bin-wise values. ; This class allows to multiply bin contents of histograms with the values of a set of RooAbsReal.; The value of the function in the ith bin is given by: ; \[; F(i) = \gamma_{i} * \mathrm{nominal}(i); \]. Where the nominal values are taken from the histogram, and the \( \gamma_{i} \) can be set from the outside. ; Definition at line 124 of file ParamHistFunc.cxx. ◆ ParamHistFunc() [4/4]. ParamHistFunc::ParamHistFunc ; (; const ParamHistFunc & ; other, . const char * ; name = nullptr . ). Definition at line 173 of file ParamHistFunc.cxx. Member Function Documentation. ◆ addParamSet(). Int_t ParamHistFunc::addParamSet ; (; const RooArgList & ; params). protected . Definition at line 524 of file ParamHistFunc.cxx. ◆ analyticalIntegralWN(). double ParamHistFunc::analyticalIntegralWN ; (; Int_t ; code, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Implement analytical integrations by doing appropriate weighting from component integrals functions to integrators of components. ; Reimplemented from RooAbsReal.; Definition at line 655 of file ParamHistFunc.cxx. ◆ binBoundaries(). std::list< double > * ParamHistFunc::binBoundaries ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ; Reimplemented from RooAbsReal.; Definition at line 721 of file ParamHistFunc.cxx. ◆ binVolume(). double ParamHistFunc::binVolume ; (; ); const. inline . Definition at line 49 of file ParamHistFunc.h. ◆ Class(). static TClass * ParamHistFunc::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * ParamHistFunc::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t ParamHistFunc::Cla",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:74362,Integrability,integrat,integration,74362,"rNVirtual_b). inline . Definition at line 111 of file ParamHistFunc.h. ◆ translate(). void ParamHistFunc::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overrideprotectedvirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 563 of file ParamHistFunc.cxx. Member Data Documentation. ◆ _dataSet. RooDataHist ParamHistFunc::_dataSet. mutableprotected . Definition at line 98 of file ParamHistFunc.h. ◆ _dataVars. RooListProxy ParamHistFunc::_dataVars. protected . The RooRealVars. ; Definition at line 82 of file ParamHistFunc.h. ◆ _normIntMgr. RooObjCacheManager ParamHistFunc::_normIntMgr. mutableprotected . ! The integration cache manager ; Definition at line 80 of file ParamHistFunc.h. ◆ _numBins. Int_t ParamHistFunc::_numBins = 0. protected . Definition at line 85 of file ParamHistFunc.h. ◆ _numBinsPerDim. NumBins ParamHistFunc::_numBinsPerDim. mutableprotected . Definition at line 97 of file ParamHistFunc.h. ◆ _paramSet. RooListProxy ParamHistFunc::_paramSet. protected . interpolation parameters ; Definition at line 83 of file ParamHistFunc.h. Libraries for ParamHistFunc:. [legend]; The documentation for this class was generated from the following files:; roofit/histfactory/inc/RooStats/HistFactory/ParamHistFunc.h; roofit/histfactory/src/ParamHistFunc.cxx. ParamHistFunc. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:36 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:3831,Modifiability,inherit,inherited,3831," (Int_t masterIdx) const;  Get the parameter associated with the index. ;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ;  ; Int_t numBins () const;  ; const RooArgList & paramList () const;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const override;  Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ;  ; void setConstant (bool constant);  ; void setParamConst (Int_t, bool=true);  ; void setShape (TH1 *shape);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parameters. ;  ; RooFit::OwningPtr< RooAbsFunc > bindVars (const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) const;  Create an interface adaptor f(vars) t",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:4862,Modifiability,adapt,adaptor,4862,"ctions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parameters. ;  ; RooFit::OwningPtr< RooAbsFunc > bindVars (const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) const;  Create an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order). ;  ; virtual std::string buildCallToAnalyticIntegral (Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const;  This function defines the analytical integral translation for the class. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a \( \chi^2 \) fit to given histogram. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooLinkedList &cmdList);  Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={},",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:4909,Modifiability,variab,variables,4909,"ctions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parameters. ;  ; RooFit::OwningPtr< RooAbsFunc > bindVars (const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) const;  Create an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order). ;  ; virtual std::string buildCallToAnalyticIntegral (Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const;  This function defines the analytical integral translation for the class. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a \( \chi^2 \) fit to given histogram. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooLinkedList &cmdList);  Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={},",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:6589,Modifiability,variab,variable,6589,"2 \) fit to given histogram. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooLinkedList &cmdList);  Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a 2-D \( \chi^2 \) fit using a series of x and y values stored in the dataset xydata. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataSet &xydata, const RooLinkedList &cmdList);  Perform a 2-D \( \chi^2 \) fit using a series of x and y values stored in the dataset xydata. ;  ; virtual RooFit::OwningPtr< RooAbsReal > createChi2 (RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Create a \( \chi^2 \) variable from a histogram and this function. ;  ; virtual RooFit::OwningPtr< RooAbsReal > createChi2 (RooDataHist &data, const RooLinkedList &cmdList);  ; virtual RooFit::OwningPtr< RooAbsReal > createChi2 (RooDataSet &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Create a \( \chi^2 \) from a series of x and y values stored in a dataset. ;  ; virtual RooFit::OwningPtr< RooAbsReal > createChi2 (RooDataSet &data, const RooLinkedList &cmdList);  See RooAbsReal::createChi2(RooDataSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&) ;  ; RooFit::OwningPtr< RooAbsArg > createFundamental (const char *newname=",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:8270,Modifiability,variab,variables,8270,"inkedList &cmdList);  See RooAbsReal::createChi2(RooDataSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&) ;  ; RooFit::OwningPtr< RooAbsArg > createFundamental (const char *newname=nullptr) const override;  Create a RooRealVar fundamental object with our properties. ;  ; TH1 * createHistogram (const char *name, const RooAbsRealLValue &xvar, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function. ;  ; TH1 * createHistogram (const char *name, const RooAbsRealLValue &xvar, RooLinkedList &argList) const;  Internal method implementing createHistogram. ;  ; TH1 * createHistogram (RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) const;  Create and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables with given names. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const char *rangeName) const;  Create integral over observables in iset in range named rangeName. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet &nset, const char *rangeName=nullptr) const;  Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet &nset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) const;  Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset while using specified configuration for any numeric integration. ;  ; virtual RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet *nset=nu",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:9033,Modifiability,config,configuration,9033,"f this function. ;  ; TH1 * createHistogram (const char *name, const RooAbsRealLValue &xvar, RooLinkedList &argList) const;  Internal method implementing createHistogram. ;  ; TH1 * createHistogram (RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) const;  Create and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables with given names. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const char *rangeName) const;  Create integral over observables in iset in range named rangeName. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet &nset, const char *rangeName=nullptr) const;  Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet &nset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) const;  Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset while using specified configuration for any numeric integration. ;  ; virtual RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet *nset=nullptr, const RooNumIntConfig *cfg=nullptr, const char *rangeName=nullptr) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooNumIntConfig &cfg, const char *rangeName=nullpt",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:9994,Modifiability,config,configuration,9994,"ntegral over observables in iset in range named rangeName with integrand normalized over observables in nset while using specified configuration for any numeric integration. ;  ; virtual RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet *nset=nullptr, const RooNumIntConfig *cfg=nullptr, const char *rangeName=nullptr) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) const;  Create integral over observables in iset in range named rangeName using specified configuration for any numeric integration. ;  ; RooFit::OwningPtr< RooAbsReal > createIntRI (const RooArgSet &iset, const RooArgSet &nset={});  Utility function for createRunningIntegral. ;  ; const RooAbsReal * createPlotProjection (const RooArgSet &dependentVars, const RooArgSet *projectedVars, RooArgSet *&cloneSet, const char *rangeName=nullptr, const RooArgSet *condObs=nullptr) const;  Utility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a RooPlot. ;  ; const RooAbsReal * createPlotProjection (const RooArgSet &depVars, const RooArgSet &projVars, RooArgSet *&cloneSet) const;  Utility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a RooPlot. ;  ; virtual RooFit::OwningPtr< RooAbsReal > createProfile (const RooArgSet &paramsOfInterest);  Create a RooProfileLL object that eliminates all nuisance parameters in the",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:14150,Modifiability,config,configuration,14150,"et &addNormSet=RooArgSet(), bool force=true);  Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by this object to the given set of observables. ;  ; virtual void fixAddCoefRange (const char *rangeName=nullptr, bool force=true);  Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by this object to the given set of observables. ;  ; virtual void forceNumInt (bool flag=true);  ; RooFunctor * functor (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a RooFunctor object bound to this RooAbsReal with given definition of observables and parameters. ;  ; virtual Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; bool getForceNumInt () const;  ; RooNumIntConfig * getIntegratorConfig ();  Return the numeric integration configuration used for this object. ;  ; const RooNumIntConfig * getIntegratorConfig () const;  Return the numeric integration configuration used for this object. ;  ; virtual Int_t getMaxVal (const RooArgSet &vars) const;  Advertise capability to determine maximum value of function for given set of observables. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual double getValV ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:14277,Modifiability,config,configuration,14277,"e headed by this object to the given set of observables. ;  ; virtual void fixAddCoefRange (const char *rangeName=nullptr, bool force=true);  Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by this object to the given set of observables. ;  ; virtual void forceNumInt (bool flag=true);  ; RooFunctor * functor (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a RooFunctor object bound to this RooAbsReal with given definition of observables and parameters. ;  ; virtual Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; bool getForceNumInt () const;  ; RooNumIntConfig * getIntegratorConfig ();  Return the numeric integration configuration used for this object. ;  ; const RooNumIntConfig * getIntegratorConfig () const;  Return the numeric integration configuration used for this object. ;  ; virtual Int_t getMaxVal (const RooArgSet &vars) const;  Advertise capability to determine maximum value of function for given set of observables. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual double getValV (const RooArgSet *normalisationSet=nullptr) const;  Return value of object. ;  ; virtual void gradient (double *) const;  ; virtual bool h",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:14540,Modifiability,variab,variable,14540," the given set of observables. ;  ; virtual void forceNumInt (bool flag=true);  ; RooFunctor * functor (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a RooFunctor object bound to this RooAbsReal with given definition of observables and parameters. ;  ; virtual Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; bool getForceNumInt () const;  ; RooNumIntConfig * getIntegratorConfig ();  Return the numeric integration configuration used for this object. ;  ; const RooNumIntConfig * getIntegratorConfig () const;  Return the numeric integration configuration used for this object. ;  ; virtual Int_t getMaxVal (const RooArgSet &vars) const;  Advertise capability to determine maximum value of function for given set of observables. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual double getValV (const RooArgSet *normalisationSet=nullptr) const;  Return value of object. ;  ; virtual void gradient (double *) const;  ; virtual bool hasGradient () const;  ; TClass * IsA () const override;  ; bool isIdentical (const RooAbsArg &other, bool assumeSameType=false) const override;  ; virtual bool isOffsetting () const;  ; bool isSelectedComp () const;  If true, the current pdf is a selected c",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:14789,Modifiability,variab,variable,14789,"th given definition of observables and parameters. ;  ; virtual Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; bool getForceNumInt () const;  ; RooNumIntConfig * getIntegratorConfig ();  Return the numeric integration configuration used for this object. ;  ; const RooNumIntConfig * getIntegratorConfig () const;  Return the numeric integration configuration used for this object. ;  ; virtual Int_t getMaxVal (const RooArgSet &vars) const;  Advertise capability to determine maximum value of function for given set of observables. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual double getValV (const RooArgSet *normalisationSet=nullptr) const;  Return value of object. ;  ; virtual void gradient (double *) const;  ; virtual bool hasGradient () const;  ; TClass * IsA () const override;  ; bool isIdentical (const RooAbsArg &other, bool assumeSameType=false) const override;  ; virtual bool isOffsetting () const;  ; bool isSelectedComp () const;  If true, the current pdf is a selected component (for use in plotting) ;  ; void logEvalError (const char *message, const char *serverValueString=nullptr) const;  Log evaluation error message. ;  ; virtual double maxVal (Int_t code) const;  Return maximum value for set of observables identified by cod",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:17978,Modifiability,config,configuration,17978,". ;  ; virtual RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const;  Internal back-end function of plotOn() with named arguments. ;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &o",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:18075,Modifiability,config,config,18075,"dObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for now) ;  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constru",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:18110,Modifiability,config,configuration,18110,"dObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for now) ;  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constru",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:18155,Modifiability,config,configuration,18155,"dObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for now) ;  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constru",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:18328,Modifiability,variab,variable,18328,"es for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for now) ;  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constructor. ;  ;  RooAbsArg (const char *name, const char *title);  Create an object with the specified name and descriptive title. ;  ;  RooAbsArg (const RooAbsArg",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:18576,Modifiability,config,configuration,18576,"ing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for now) ;  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constructor. ;  ;  RooAbsArg (const char *name, const char *title);  Create an object with the specified name and descriptive title. ;  ;  RooAbsArg (const RooAbsArg &other, const char *name=nullptr);  Copy constructor transfers all boolean and string properties of the original object. ;  ;  ~RooAbsArg () override;  Destructor. ;  ; bool addOwnedComponents (const RooAbsCollec",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:18717,Modifiability,config,configuration,18717,"mmy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for now) ;  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constructor. ;  ;  RooAbsArg (const char *name, const char *title);  Create an object with the specified name and descriptive title. ;  ;  RooAbsArg (const RooAbsArg &other, const char *name=nullptr);  Copy constructor transfers all boolean and string properties of the original object. ;  ;  ~RooAbsArg () override;  Destructor. ;  ; bool addOwnedComponents (const RooAbsCollection &comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooAbsCollection &&comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooArgList &&comps",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:19046,Modifiability,inherit,inherited,19046,"tegration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for now) ;  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constructor. ;  ;  RooAbsArg (const char *name, const char *title);  Create an object with the specified name and descriptive title. ;  ;  RooAbsArg (const RooAbsArg &other, const char *name=nullptr);  Copy constructor transfers all boolean and string properties of the original object. ;  ;  ~RooAbsArg () override;  Destructor. ;  ; bool addOwnedComponents (const RooAbsCollection &comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooAbsCollection &&comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooArgList &&comps);  Take ownership of the contents of 'comps'. ;  ; template<typename... Args_t> ; bool addOwnedComponents (std::unique_ptr< Args_t >... comps);  ; virtual void applyWeightSquared (bool flag);  Disables or enables the usage of squared weights. ;  ; void attachArgs (const RooAbsCollectio",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:20115,Modifiability,variab,variable,20115," ;  RooAbsArg (const char *name, const char *title);  Create an object with the specified name and descriptive title. ;  ;  RooAbsArg (const RooAbsArg &other, const char *name=nullptr);  Copy constructor transfers all boolean and string properties of the original object. ;  ;  ~RooAbsArg () override;  Destructor. ;  ; bool addOwnedComponents (const RooAbsCollection &comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooAbsCollection &&comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooArgList &&comps);  Take ownership of the contents of 'comps'. ;  ; template<typename... Args_t> ; bool addOwnedComponents (std::unique_ptr< Args_t >... comps);  ; virtual void applyWeightSquared (bool flag);  Disables or enables the usage of squared weights. ;  ; void attachArgs (const RooAbsCollection &set);  Bind this node to objects in set. ;  ; void attachDataSet (const RooAbsData &set);  Replace server nodes with names matching the dataset variable names with those data set variables, making this PDF directly dependent on the dataset. ;  ; void attachDataStore (const RooAbsDataStore &set);  Replace server nodes with names matching the dataset variable names with those data set variables, making this PDF directly dependent on the dataset. ;  ; const std::set< std::string > & attributes () const;  ; virtual bool canComputeBatchWithCuda () const;  ; virtual bool checkObservables (const RooArgSet *nset) const;  Overloadable function in which derived classes can implement consistency checks of the variables. ;  ; TObject * Clone (const char *newname=nullptr) const override;  Make a clone of an object using the Streamer facility. ;  ; virtual RooAbsArg * cloneTree (const char *newname=nullptr) const;  Clone tree expression of objects. ;  ; Int_t Compare (const TObject *other) const override;  Utility function used by TCollection::Sort to compare contained TObjects We implement comparison by name, resulting in alphabetical ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:20150,Modifiability,variab,variables,20150," ;  RooAbsArg (const char *name, const char *title);  Create an object with the specified name and descriptive title. ;  ;  RooAbsArg (const RooAbsArg &other, const char *name=nullptr);  Copy constructor transfers all boolean and string properties of the original object. ;  ;  ~RooAbsArg () override;  Destructor. ;  ; bool addOwnedComponents (const RooAbsCollection &comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooAbsCollection &&comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooArgList &&comps);  Take ownership of the contents of 'comps'. ;  ; template<typename... Args_t> ; bool addOwnedComponents (std::unique_ptr< Args_t >... comps);  ; virtual void applyWeightSquared (bool flag);  Disables or enables the usage of squared weights. ;  ; void attachArgs (const RooAbsCollection &set);  Bind this node to objects in set. ;  ; void attachDataSet (const RooAbsData &set);  Replace server nodes with names matching the dataset variable names with those data set variables, making this PDF directly dependent on the dataset. ;  ; void attachDataStore (const RooAbsDataStore &set);  Replace server nodes with names matching the dataset variable names with those data set variables, making this PDF directly dependent on the dataset. ;  ; const std::set< std::string > & attributes () const;  ; virtual bool canComputeBatchWithCuda () const;  ; virtual bool checkObservables (const RooArgSet *nset) const;  Overloadable function in which derived classes can implement consistency checks of the variables. ;  ; TObject * Clone (const char *newname=nullptr) const override;  Make a clone of an object using the Streamer facility. ;  ; virtual RooAbsArg * cloneTree (const char *newname=nullptr) const;  Clone tree expression of objects. ;  ; Int_t Compare (const TObject *other) const override;  Utility function used by TCollection::Sort to compare contained TObjects We implement comparison by name, resulting in alphabetical ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:20322,Modifiability,variab,variable,20322," transfers all boolean and string properties of the original object. ;  ;  ~RooAbsArg () override;  Destructor. ;  ; bool addOwnedComponents (const RooAbsCollection &comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooAbsCollection &&comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooArgList &&comps);  Take ownership of the contents of 'comps'. ;  ; template<typename... Args_t> ; bool addOwnedComponents (std::unique_ptr< Args_t >... comps);  ; virtual void applyWeightSquared (bool flag);  Disables or enables the usage of squared weights. ;  ; void attachArgs (const RooAbsCollection &set);  Bind this node to objects in set. ;  ; void attachDataSet (const RooAbsData &set);  Replace server nodes with names matching the dataset variable names with those data set variables, making this PDF directly dependent on the dataset. ;  ; void attachDataStore (const RooAbsDataStore &set);  Replace server nodes with names matching the dataset variable names with those data set variables, making this PDF directly dependent on the dataset. ;  ; const std::set< std::string > & attributes () const;  ; virtual bool canComputeBatchWithCuda () const;  ; virtual bool checkObservables (const RooArgSet *nset) const;  Overloadable function in which derived classes can implement consistency checks of the variables. ;  ; TObject * Clone (const char *newname=nullptr) const override;  Make a clone of an object using the Streamer facility. ;  ; virtual RooAbsArg * cloneTree (const char *newname=nullptr) const;  Clone tree expression of objects. ;  ; Int_t Compare (const TObject *other) const override;  Utility function used by TCollection::Sort to compare contained TObjects We implement comparison by name, resulting in alphabetical sorting by object name. ;  ; virtual std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const;  ; std::size_t dataToken () const;  Returns the t",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:20357,Modifiability,variab,variables,20357," transfers all boolean and string properties of the original object. ;  ;  ~RooAbsArg () override;  Destructor. ;  ; bool addOwnedComponents (const RooAbsCollection &comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooAbsCollection &&comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooArgList &&comps);  Take ownership of the contents of 'comps'. ;  ; template<typename... Args_t> ; bool addOwnedComponents (std::unique_ptr< Args_t >... comps);  ; virtual void applyWeightSquared (bool flag);  Disables or enables the usage of squared weights. ;  ; void attachArgs (const RooAbsCollection &set);  Bind this node to objects in set. ;  ; void attachDataSet (const RooAbsData &set);  Replace server nodes with names matching the dataset variable names with those data set variables, making this PDF directly dependent on the dataset. ;  ; void attachDataStore (const RooAbsDataStore &set);  Replace server nodes with names matching the dataset variable names with those data set variables, making this PDF directly dependent on the dataset. ;  ; const std::set< std::string > & attributes () const;  ; virtual bool canComputeBatchWithCuda () const;  ; virtual bool checkObservables (const RooArgSet *nset) const;  Overloadable function in which derived classes can implement consistency checks of the variables. ;  ; TObject * Clone (const char *newname=nullptr) const override;  Make a clone of an object using the Streamer facility. ;  ; virtual RooAbsArg * cloneTree (const char *newname=nullptr) const;  Clone tree expression of objects. ;  ; Int_t Compare (const TObject *other) const override;  Utility function used by TCollection::Sort to compare contained TObjects We implement comparison by name, resulting in alphabetical sorting by object name. ;  ; virtual std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const;  ; std::size_t dataToken () const;  Returns the t",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:20679,Modifiability,variab,variables,20679,"ponents (RooAbsCollection &&comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooArgList &&comps);  Take ownership of the contents of 'comps'. ;  ; template<typename... Args_t> ; bool addOwnedComponents (std::unique_ptr< Args_t >... comps);  ; virtual void applyWeightSquared (bool flag);  Disables or enables the usage of squared weights. ;  ; void attachArgs (const RooAbsCollection &set);  Bind this node to objects in set. ;  ; void attachDataSet (const RooAbsData &set);  Replace server nodes with names matching the dataset variable names with those data set variables, making this PDF directly dependent on the dataset. ;  ; void attachDataStore (const RooAbsDataStore &set);  Replace server nodes with names matching the dataset variable names with those data set variables, making this PDF directly dependent on the dataset. ;  ; const std::set< std::string > & attributes () const;  ; virtual bool canComputeBatchWithCuda () const;  ; virtual bool checkObservables (const RooArgSet *nset) const;  Overloadable function in which derived classes can implement consistency checks of the variables. ;  ; TObject * Clone (const char *newname=nullptr) const override;  Make a clone of an object using the Streamer facility. ;  ; virtual RooAbsArg * cloneTree (const char *newname=nullptr) const;  Clone tree expression of objects. ;  ; Int_t Compare (const TObject *other) const override;  Utility function used by TCollection::Sort to compare contained TObjects We implement comparison by name, resulting in alphabetical sorting by object name. ;  ; virtual std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const;  ; std::size_t dataToken () const;  Returns the token for retrieving results in the BatchMode. For internal use only. ;  ; Int_t defaultPrintContents (Option_t *opt) const override;  Define default contents to print. ;  ; bool dependsOn (const RooAbsArg &server, const RooAbsArg *ignoreAr",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:23315,Modifiability,variab,variable,23315," bool dependsOnValue (const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr) const;  Check whether this object depends on values from an element in the serverList. ;  ; bool getAttribute (const Text_t *name) const;  Check if a named attribute is set. By default, all attributes are unset. ;  ; RooFit::OwningPtr< RooArgSet > getComponents () const;  Create a RooArgSet with all components (branch nodes) of the expression tree headed by this object. ;  ; bool getObservables (const RooAbsCollection *depList, RooArgSet &outputSet, bool valueOnly=true) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that match any of the names the args in the supplied argset. ;  ; RooFit::OwningPtr< RooArgSet > getObservables (const RooAbsData &data) const;  Return the observables of this pdf given the observables defined by data. ;  ; RooFit::OwningPtr< RooArgSet > getObservables (const RooAbsData *data) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that match any of the names of the variable list of the supplied data set (the dependents). ;  ; RooFit::OwningPtr< RooArgSet > getObservables (const RooArgSet &set, bool valueOnly=true) const;  Given a set of possible observables, return the observables that this PDF depends on. ;  ; RooFit::OwningPtr< RooArgSet > getObservables (const RooArgSet *depList, bool valueOnly=true) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that match any of the names the args in the supplied argset. ;  ; RooFit::OwningPtr< RooArgSet > getParameters (const RooAbsData &data, bool stripDisconnected=true) const;  Return the parameters of this p.d.f when used in conjunction with dataset 'data'. ;  ; RooFit::OwningPtr< RooArgSet > getParameters (const RooAbsData *data, bool stripDisconnected=true) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that don't match any of the names of the variable lis",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:24232,Modifiability,variab,variable,24232,"oArgSet > getObservables (const RooAbsData *data) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that match any of the names of the variable list of the supplied data set (the dependents). ;  ; RooFit::OwningPtr< RooArgSet > getObservables (const RooArgSet &set, bool valueOnly=true) const;  Given a set of possible observables, return the observables that this PDF depends on. ;  ; RooFit::OwningPtr< RooArgSet > getObservables (const RooArgSet *depList, bool valueOnly=true) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that match any of the names the args in the supplied argset. ;  ; RooFit::OwningPtr< RooArgSet > getParameters (const RooAbsData &data, bool stripDisconnected=true) const;  Return the parameters of this p.d.f when used in conjunction with dataset 'data'. ;  ; RooFit::OwningPtr< RooArgSet > getParameters (const RooAbsData *data, bool stripDisconnected=true) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that don't match any of the names of the variable list of the supplied data set (the dependents). ;  ; RooFit::OwningPtr< RooArgSet > getParameters (const RooArgSet &observables, bool stripDisconnected=true) const;  Return the parameters of the p.d.f given the provided set of observables. ;  ; RooFit::OwningPtr< RooArgSet > getParameters (const RooArgSet *observables, bool stripDisconnected=true) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that don't match any of the names the args in the supplied argset. ;  ; virtual bool getParameters (const RooArgSet *observables, RooArgSet &outputSet, bool stripDisconnected=true) const;  Fills a list with leaf nodes in the arg tree starting with ourself as top node that don't match any of the names the args in the supplied argset. ;  ; RooAbsProxy * getProxy (Int_t index) const;  Return the nth proxy from the proxy list. ;  ; const Text_t * getStringAttribute (",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:25425,Modifiability,variab,variables,25425," set of observables. ;  ; RooFit::OwningPtr< RooArgSet > getParameters (const RooArgSet *observables, bool stripDisconnected=true) const;  Create a list of leaf nodes in the arg tree starting with ourself as top node that don't match any of the names the args in the supplied argset. ;  ; virtual bool getParameters (const RooArgSet *observables, RooArgSet &outputSet, bool stripDisconnected=true) const;  Fills a list with leaf nodes in the arg tree starting with ourself as top node that don't match any of the names the args in the supplied argset. ;  ; RooAbsProxy * getProxy (Int_t index) const;  Return the nth proxy from the proxy list. ;  ; const Text_t * getStringAttribute (const Text_t *key) const;  Get string attribute mapped under key 'key'. ;  ; bool getTransientAttribute (const Text_t *name) const;  Check if a named attribute is set. ;  ; RooFit::OwningPtr< RooArgSet > getVariables (bool stripDisconnected=true) const;  Return RooArgSet with all variables (tree leaf nodes of expression tree) ;  ; void graphVizTree (const char *fileName, const char *delimiter=""\n"", bool useTitle=false, bool useLatex=false);  Create a GraphViz .dot file visualizing the expression tree headed by this RooAbsArg object. ;  ; void graphVizTree (std::ostream &os, const char *delimiter=""\n"", bool useTitle=false, bool useLatex=false);  Write the GraphViz representation of the expression tree headed by this RooAbsArg object to the given ostream. ;  ; bool hasClients () const;  ; bool hasDataToken () const;  ; virtual bool hasRange (const char *) const;  ; virtual bool importWorkspaceHook (RooWorkspace &ws);  ; virtual bool inRange (const char *) const;  ; virtual bool isCategory () const;  ; bool isConstant () const;  Check if the ""Constant"" attribute is set. ;  ; virtual bool isDerived () const;  Does value or shape of this arg depend on any other arg? ;  ; virtual bool isReducerNode () const;  ; bool IsSortable () const override;  ; bool localNoDirtyInhibit () const;  ; const TNamed * ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:37053,Modifiability,inherit,inherited,37053," ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooAbsData *dset;  ;  R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooArgSet *depList;  ;  R__DEPRECATED (6, 36, ""Use checkObservables()."") inline bool checkDependents(const RooArgSet *nset) const;  ;  R__DEPRECATED (6, 36, ""Use recursiveCheckObservables()."") inline bool recursiveCheckDependents(const RooArgSet *nset) const;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:38599,Modifiability,inherit,inherited,38599,"ects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:39692,Modifiability,inherit,inheritance,39692,"  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in de",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:41691,Modifiability,inherit,inherits,41691,"e) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:41808,Modifiability,inherit,inherits,41808,"t be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is necessary). ;  ; virtual Bool_t Notify ();  This method must be overridden to handle object notification (the base ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:45367,Modifiability,inherit,inherited,45367,"id SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static RooArgList createParamSet (const std::string &, Int_t, double, double);  Create the list of RooRealVar parameters which represent the height of the histogram bins. ;  ; static RooArgList createParamSet (RooWorkspace &w, const std::string &, const RooArgList &Vars);  Create the list of RooRealVar parameters which represent the height of the",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:46763,Modifiability,inherit,inherited,46763,"tentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static RooArgList createParamSet (const std::string &, Int_t, double, double);  Create the list of RooRealVar parameters which represent the height of the histogram bins. ;  ; static RooArgList createParamSet (RooWorkspace &w, const std::string &, const RooArgList &Vars);  Create the list of RooRealVar parameters which represent the height of the histogram bins. ;  ; static RooArgList createParamSet (RooWorkspace &w, const std::string &, const RooArgList &Vars, double, double);  Create the list of RooRealVar parameters which scale the height of histogram bins. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static voi",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:47125,Modifiability,config,configuration,47125,"tatic constexpr Version_t Class_Version ();  ; static RooArgList createParamSet (const std::string &, Int_t, double, double);  Create the list of RooRealVar parameters which represent the height of the histogram bins. ;  ; static RooArgList createParamSet (RooWorkspace &w, const std::string &, const RooArgList &Vars);  Create the list of RooRealVar parameters which represent the height of the histogram bins. ;  ; static RooArgList createParamSet (RooWorkspace &w, const std::string &, const RooArgList &Vars, double, double);  Create the list of RooRealVar parameters which scale the height of histogram bins. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:48157,Modifiability,inherit,inherited,48157,"tic std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static T",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:48403,Modifiability,inherit,inherited,48403,"sages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given am",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:48613,Modifiability,inherit,inherited,48613,"sages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given am",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:49131,Modifiability,inherit,inherited,49131,"void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; Int_t addParamSet (const RooArgList &params);  ; void doEval (RooFit::EvalContext &) const override;  Find all bins corresponding to the values of the observables in evalData, and evaluate the associated parameters. ;  ; double evaluate () const override;  Find the bin corresponding to the current value of the observable, and evaluate the associated parameter. ;  ; Int_t getCurrentBin () const;  Get the index of the gamma parameter associated with the current bin. ;  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:50356,Modifiability,inherit,inherited,50356," to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; Int_t addParamSet (const RooArgList &params);  ; void doEval (RooFit::EvalContext &) const override;  Find all bins corresponding to the values of the observables in evalData, and evaluate the associated parameters. ;  ; double evaluate () const override;  Find the bin corresponding to the current value of the observable, and evaluate the associated parameter. ;  ; Int_t getCurrentBin () const;  Get the index of the gamma parameter associated with the current bin. ;  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:51321,Modifiability,parameteriz,parameterized,51321,"n defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, normalization observables and the integration range name. ;  ; bool isValid () const override;  Check if current value is valid. ;  ; virtual bool isValidReal (double, bool printError=false) const;  Interface function to check if given value is a valid value for this object. Returns true unless overridden. ;  ; void makeProjectionSet (const RooAbsArg *plotVar, const RooArgSet *allVars, RooArgSet &projectedVars, bool silent) const;  Utility function for plotOn() that constructs the set of observables to project when plotting ourselves as function of 'plotVar'. ;  ; bool matchArgs (const RooArgSet &allDeps, ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:54856,Modifiability,inherit,inherited,54856," general sanity check on frame to ensure safe plotting operations. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  Function that is called at the end of redirectServers(). ;  ; virtual void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; virtual void selectNormalizationRange (const char *rangeName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtua",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:56999,Modifiability,inherit,inherited,56999," attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static Int_t GetNumBins (const RooArgSet &vars);  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  . Protected Attributes; RooDataHist _dataSet;  ; RooListProxy _dataVars;  The RooRealVars. ;  ; RooObjCacheManager _normIntMgr;  ! The integration cache manager ;  ; Int_t _numBins = 0;  ; NumBins _numBinsPerDim;  ; RooListProxy _paramSet;  interpolation parameters ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integratio",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:57304,Modifiability,inherit,inherited,57304,"xy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static Int_t GetNumBins (const RooArgSet &vars);  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  . Protected Attributes; RooDataHist _dataSet;  ; RooListProxy _dataVars;  The RooRealVars. ;  ; RooObjCacheManager _normIntMgr;  ! The integration cache manager ;  ; Int_t _numBins = 0;  ; NumBins _numBinsPerDim;  ; RooListProxy _paramSet;  interpolation parameters ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number o",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:57490,Modifiability,inherit,inherited,57490,"shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static Int_t GetNumBins (const RooArgSet &vars);  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  . Protected Attributes; RooDataHist _dataSet;  ; RooListProxy _dataVars;  The RooRealVars. ;  ; RooObjCacheManager _normIntMgr;  ! The integration cache manager ;  ; Int_t _numBins = 0;  ; NumBins _numBinsPerDim;  ; RooListProxy _paramSet;  interpolation parameters ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:57978,Modifiability,inherit,inherited,57978,"y &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static Int_t GetNumBins (const RooArgSet &vars);  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  . Protected Attributes; RooDataHist _dataSet;  ; RooListProxy _dataVars;  The RooRealVars. ;  ; RooObjCacheManager _normIntMgr;  ! The integration cache manager ;  ; Int_t _numBins = 0;  ; NumBins _numBinsPerDim;  ; RooListProxy _paramSet;  interpolation parameters ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clie",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:58745,Modifiability,inherit,inherited,58745,"_paramSet;  interpolation parameters ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:60021,Modifiability,inherit,inherited,60021," RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Private Member Functions; static NumBins getNumBinsPerDim (RooArgSet const &vars);  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:60218,Modifiability,inherit,inherited,60218,"any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Private Member Functions; static NumBins getNumBinsPerDim (RooArgSet const &vars);  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:60448,Modifiability,inherit,inherited,60448,"any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Private Member Functions; static NumBins getNumBinsPerDim (RooArgSet const &vars);  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:60858,Modifiability,inherit,inherited,60858,"any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Private Member Functions; static NumBins getNumBinsPerDim (RooArgSet const &vars);  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:61496,Modifiability,inherit,inherited,61496,"ctivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:61820,Modifiability,inherit,inherited,61820," ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStats/HistFactory/ParamHistFunc.h>. Inheritance diagram for ParamHistFunc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [leg",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:62180,Modifiability,inherit,inherited,62180," ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStats/HistFactory/ParamHistFunc.h>. Inheritance diagram for ParamHistFunc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ParamHistFunc() [1/4]. ParamHistFunc::ParamHistFunc ; (; ). Definition at line 62 of file ParamHistFunc.cxx. ◆ ParamHistFunc() [2/4]. ParamHistFunc::ParamHistFunc ; (; const char * ; name, . const char * ; title, . const RooArgList & ; vars, . const RooArgList & ; paramSet . ). Create a function which retur",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:62280,Modifiability,inherit,inherited,62280," ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStats/HistFactory/ParamHistFunc.h>. Inheritance diagram for ParamHistFunc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ParamHistFunc() [1/4]. ParamHistFunc::ParamHistFunc ; (; ). Definition at line 62 of file ParamHistFunc.cxx. ◆ ParamHistFunc() [2/4]. ParamHistFunc::ParamHistFunc ; (; const char * ; name, . const char * ; title, . const RooArgList & ; vars, . const RooArgList & ; paramSet . ). Create a function which retur",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:62436,Modifiability,inherit,inherited,62436," };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStats/HistFactory/ParamHistFunc.h>. Inheritance diagram for ParamHistFunc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ParamHistFunc() [1/4]. ParamHistFunc::ParamHistFunc ; (; ). Definition at line 62 of file ParamHistFunc.cxx. ◆ ParamHistFunc() [2/4]. ParamHistFunc::ParamHistFunc ; (; const char * ; name, . const char * ; title, . const RooArgList & ; vars, . const RooArgList & ; paramSet . ). Create a function which returns binewise-values This class contains N RooAbsReals's, one for each bin from the given RooRealVar. ; The value of the function in the ith bin is given by:; F(i) = gamma_i * nominal(i); Where the nominal values are simply fixed numbers (default = 1.0 for all i) ; Definition at",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:62605,Modifiability,inherit,inherited,62605,"s =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStats/HistFactory/ParamHistFunc.h>. Inheritance diagram for ParamHistFunc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ParamHistFunc() [1/4]. ParamHistFunc::ParamHistFunc ; (; ). Definition at line 62 of file ParamHistFunc.cxx. ◆ ParamHistFunc() [2/4]. ParamHistFunc::ParamHistFunc ; (; const char * ; name, . const char * ; title, . const RooArgList & ; vars, . const RooArgList & ; paramSet . ). Create a function which returns binewise-values This class contains N RooAbsReals's, one for each bin from the given RooRealVar. ; The value of the function in the ith bin is given by:; F(i) = gamma_i * nominal(i); Where the nominal values are simply fixed numbers (default = 1.0 for all i) ; Definition at line 81 of file ParamHistFunc.cxx. ◆ ParamHistFunc() [3/4]. ParamHistFunc::ParamHistFunc ; (; const char * ; name, . const char * ; title, .",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:17842,Performance,cache,cache,17842,"={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const;  Plot (project) PDF on specified frame. ;  ; virtual RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const;  Internal back-end function of plotOn() with named arguments. ;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the special",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:34175,Performance,optimiz,optimizeCacheMode,34175,"sArg as a server to us, ie, declare that we depend on it. ;  ; void addServerList (RooAbsCollection &serverList, bool valueProp=true, bool shapeProp=false);  Register a list of RooAbsArg as servers to us by calling addServer() for each arg in the list. ;  ; void replaceServer (RooAbsArg &oldServer, RooAbsArg &newServer, bool valueProp, bool shapeProp);  Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void se",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:34235,Performance,cache,cache,34235,"sArg as a server to us, ie, declare that we depend on it. ;  ; void addServerList (RooAbsCollection &serverList, bool valueProp=true, bool shapeProp=false);  Register a list of RooAbsArg as servers to us by calling addServer() for each arg in the list. ;  ; void replaceServer (RooAbsArg &oldServer, RooAbsArg &newServer, bool valueProp, bool shapeProp);  Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void se",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:34246,Performance,optimiz,optimization,34246,"sArg as a server to us, ie, declare that we depend on it. ;  ; void addServerList (RooAbsCollection &serverList, bool valueProp=true, bool shapeProp=false);  Register a list of RooAbsArg as servers to us by calling addServer() for each arg in the list. ;  ; void replaceServer (RooAbsArg &oldServer, RooAbsArg &newServer, bool valueProp, bool shapeProp);  Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void se",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:34315,Performance,optimiz,optimizeCacheMode,34315," a list of RooAbsArg as servers to us by calling addServer() for each arg in the list. ;  ; void replaceServer (RooAbsArg &oldServer, RooAbsArg &newServer, bool valueProp, bool shapeProp);  Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAnd",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:34427,Performance,cache,cache,34427," a list of RooAbsArg as servers to us by calling addServer() for each arg in the list. ;  ; void replaceServer (RooAbsArg &oldServer, RooAbsArg &newServer, bool valueProp, bool shapeProp);  Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAnd",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:34438,Performance,optimiz,optimization,34438," a list of RooAbsArg as servers to us by calling addServer() for each arg in the list. ;  ; void replaceServer (RooAbsArg &oldServer, RooAbsArg &newServer, bool valueProp, bool shapeProp);  Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAnd",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:34559,Performance,cache,cacheList,34559,"th 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructo",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:34666,Performance,cache,cached,34666,"th 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructo",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:34791,Performance,cache,cacheList,34791,"ooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void set",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:34929,Performance,cache,cached,34929,"ooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void set",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:35123,Performance,perform,perform,35123,"eChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirt",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:35145,Performance,optimiz,optimization,35145,"eChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirt",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:35444,Performance,cache,cache,35444,"acheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache ()",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:35532,Performance,cache,cache,35532,"rgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:35667,Performance,cache,caches,35667,"list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependen",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:35743,Performance,cache,cache,35743,". ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooAbsData *dset;  ;  R__DEPRECATED (6, 36, ""Use observableOverl",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:36219,Performance,cache,cacheUniqueSuffix,36219,"ool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooAbsData *dset;  ;  R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooArgSet *depList;  ;  R__DEPRECATED (6, 36, ""Use checkObservables()."") inline bool checkDependents(const RooArgSet *nset) const;  ;  R__DEPRECATED (6, 36, ""Use recursiveCheckObservables()."") inline bool recursiveCheckDependents(const RooArgSet *nset) const;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ;",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:36399,Performance,cache,cache,36399,"ool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooAbsData *dset;  ;  R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooArgSet *depList;  ;  R__DEPRECATED (6, 36, ""Use checkObservables()."") inline bool checkDependents(const RooArgSet *nset) const;  ;  R__DEPRECATED (6, 36, ""Use recursiveCheckObservables()."") inline bool recursiveCheckDependents(const RooArgSet *nset) const;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ;",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:50659,Performance,cache,cached,50659,"ing to given amount. ;  . Protected Member Functions; Int_t addParamSet (const RooArgList &params);  ; void doEval (RooFit::EvalContext &) const override;  Find all bins corresponding to the values of the observables in evalData, and evaluate the associated parameters. ;  ; double evaluate () const override;  Find the bin corresponding to the current value of the observable, and evaluate the associated parameter. ;  ; Int_t getCurrentBin () const;  Get the index of the gamma parameter associated with the current bin. ;  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:50700,Performance,cache,cache,50700,"ing to given amount. ;  . Protected Member Functions; Int_t addParamSet (const RooArgList &params);  ; void doEval (RooFit::EvalContext &) const override;  Find all bins corresponding to the values of the observables in evalData, and evaluate the associated parameters. ;  ; double evaluate () const override;  Find the bin corresponding to the current value of the observable, and evaluate the associated parameter. ;  ; Int_t getCurrentBin () const;  Get the index of the gamma parameter associated with the current bin. ;  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:53905,Performance,perform,perform,53905,"bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgSet &set) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgsByName (const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;  Check if allArgs contains matching elements for each name in nameList. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  ; virtual RooPlot * plotOn (RooPlot *frame, PlotOpt o) const;  Plotting engine function for internal use. ;  ; void plotOnCompSelect (RooArgSet *selNodes) const;  Helper function for plotting of composite p.d.fs. ;  ; RooPlot * plotOnWithErrorBand (RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  Function that is called at the end of redirectServers(). ;  ; virtual void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; virtual void selectNormalizationRange (const char *rangeName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:55952,Performance,optimiz,optimizeDirtyHook,55952,";  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoErr",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:56440,Performance,cache,cached,56440,"id graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static Int_t GetNumBins (const RooArgSet &vars);  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectCom",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:57832,Performance,cache,cache,57832,"y &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static Int_t GetNumBins (const RooArgSet &vars);  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  . Protected Attributes; RooDataHist _dataSet;  ; RooListProxy _dataVars;  The RooRealVars. ;  ; RooObjCacheManager _normIntMgr;  ! The integration cache manager ;  ; Int_t _numBins = 0;  ; NumBins _numBinsPerDim;  ; RooListProxy _paramSet;  interpolation parameters ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clie",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:59582,Performance,cache,cache,59582," _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which workspace do I live, if any. ;  ; bool _deleteWatch = false;  ; RooExpensiveObjectCache * _eocache {nullptr};  Prohibit server redirects – Debugging tool. ;  ; bool _fast = false;  ; bool _isConstant = false;  De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Private Member Functions; static NumBins getNumBinsPerDim (RooArgSet const &vars);  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:62520,Performance,cache,cache,62520," };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStats/HistFactory/ParamHistFunc.h>. Inheritance diagram for ParamHistFunc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ParamHistFunc() [1/4]. ParamHistFunc::ParamHistFunc ; (; ). Definition at line 62 of file ParamHistFunc.cxx. ◆ ParamHistFunc() [2/4]. ParamHistFunc::ParamHistFunc ; (; const char * ; name, . const char * ; title, . const RooArgList & ; vars, . const RooArgList & ; paramSet . ). Create a function which returns binewise-values This class contains N RooAbsReals's, one for each bin from the given RooRealVar. ; The value of the function in the ith bin is given by:; F(i) = gamma_i * nominal(i); Where the nominal values are simply fixed numbers (default = 1.0 for all i) ; Definition at",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:74374,Performance,cache,cache,74374,"rNVirtual_b). inline . Definition at line 111 of file ParamHistFunc.h. ◆ translate(). void ParamHistFunc::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overrideprotectedvirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 563 of file ParamHistFunc.cxx. Member Data Documentation. ◆ _dataSet. RooDataHist ParamHistFunc::_dataSet. mutableprotected . Definition at line 98 of file ParamHistFunc.h. ◆ _dataVars. RooListProxy ParamHistFunc::_dataVars. protected . The RooRealVars. ; Definition at line 82 of file ParamHistFunc.h. ◆ _normIntMgr. RooObjCacheManager ParamHistFunc::_normIntMgr. mutableprotected . ! The integration cache manager ; Definition at line 80 of file ParamHistFunc.h. ◆ _numBins. Int_t ParamHistFunc::_numBins = 0. protected . Definition at line 85 of file ParamHistFunc.h. ◆ _numBinsPerDim. NumBins ParamHistFunc::_numBinsPerDim. mutableprotected . Definition at line 97 of file ParamHistFunc.h. ◆ _paramSet. RooListProxy ParamHistFunc::_paramSet. protected . interpolation parameters ; Definition at line 83 of file ParamHistFunc.h. Libraries for ParamHistFunc:. [legend]; The documentation for this class was generated from the following files:; roofit/histfactory/inc/RooStats/HistFactory/ParamHistFunc.h; roofit/histfactory/src/ParamHistFunc.cxx. ParamHistFunc. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:36 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:53921,Safety,sanity check,sanity check,53921,"bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgSet &set) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgsByName (const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;  Check if allArgs contains matching elements for each name in nameList. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  ; virtual RooPlot * plotOn (RooPlot *frame, PlotOpt o) const;  Plotting engine function for internal use. ;  ; void plotOnCompSelect (RooArgSet *selNodes) const;  Helper function for plotting of composite p.d.fs. ;  ; RooPlot * plotOnWithErrorBand (RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  Function that is called at the end of redirectServers(). ;  ; virtual void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; virtual void selectNormalizationRange (const char *rangeName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:53953,Safety,safe,safe,53953,"bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgSet &set) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgsByName (const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;  Check if allArgs contains matching elements for each name in nameList. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  ; virtual RooPlot * plotOn (RooPlot *frame, PlotOpt o) const;  Plotting engine function for internal use. ;  ; void plotOnCompSelect (RooArgSet *selNodes) const;  Helper function for plotting of composite p.d.fs. ;  ; RooPlot * plotOnWithErrorBand (RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  Function that is called at the end of redirectServers(). ;  ; virtual void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; virtual void selectNormalizationRange (const char *rangeName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:37921,Security,hash,hash,37921,"ED (6, 36, ""Use recursiveCheckObservables()."") inline bool recursiveCheckDependents(const RooArgSet *nset) const;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:15547,Testability,log,logEvalError,15547,"of function for given set of observables. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual double getValV (const RooArgSet *normalisationSet=nullptr) const;  Return value of object. ;  ; virtual void gradient (double *) const;  ; virtual bool hasGradient () const;  ; TClass * IsA () const override;  ; bool isIdentical (const RooAbsArg &other, bool assumeSameType=false) const override;  ; virtual bool isOffsetting () const;  ; bool isSelectedComp () const;  If true, the current pdf is a selected component (for use in plotting) ;  ; void logEvalError (const char *message, const char *serverValueString=nullptr) const;  Log evaluation error message. ;  ; virtual double maxVal (Int_t code) const;  Return maximum value for set of observables identified by code assigned in getMaxVal. ;  ; RooAbsMoment * mean (RooRealVar &obs);  ; RooAbsMoment * mean (RooRealVar &obs, const RooArgSet &nset);  ; virtual Int_t minTrialSamples (const RooArgSet &) const;  ; RooAbsMoment * moment (RooRealVar &obs, const RooArgSet &normObs, Int_t order, bool central, bool takeRoot, bool intNormObs);  Return function representing moment of p.d.f (normalized w.r.t given observables) of given order. ;  ; RooAbsMoment * moment (RooRealVar &obs, Int_t order, bool central, bool takeRoot);  Return function representing moment of function of given order. ;  ; virtual double offset () const;  ; bool operator== (const RooAbsArg &other",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:26669,Testability,test,testArg,26669,"izTree (std::ostream &os, const char *delimiter=""\n"", bool useTitle=false, bool useLatex=false);  Write the GraphViz representation of the expression tree headed by this RooAbsArg object to the given ostream. ;  ; bool hasClients () const;  ; bool hasDataToken () const;  ; virtual bool hasRange (const char *) const;  ; virtual bool importWorkspaceHook (RooWorkspace &ws);  ; virtual bool inRange (const char *) const;  ; virtual bool isCategory () const;  ; bool isConstant () const;  Check if the ""Constant"" attribute is set. ;  ; virtual bool isDerived () const;  Does value or shape of this arg depend on any other arg? ;  ; virtual bool isReducerNode () const;  ; bool IsSortable () const override;  ; bool localNoDirtyInhibit () const;  ; const TNamed * namePtr () const;  De-duplicated pointer to this object's name. ;  ; Int_t numProxies () const;  Return the number of registered proxies. ;  ; bool observableOverlaps (const RooAbsData *dset, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; bool observableOverlaps (const RooArgSet *depList, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; RooAbsArg & operator= (const RooAbsArg &other)=delete;  ; bool overlaps (const RooAbsArg &testArg, bool valueOnly=false) const;  Test if any of the nodes of tree are shared with that of the given tree. ;  ; const RooArgSet * ownedComponents () const;  ; void Print (Option_t *options=nullptr) const override;  Print the object to the defaultPrintStream(). ;  ; void printAddress (std::ostream &os) const override;  Print address of this RooAbsArg. ;  ; void printArgs (std::ostream &os) const override;  Print object arguments, ie its proxies. ;  ; void printClassName (std::ostream &os) const override;  Print object class name. ;  ; void printCompactTree (const char *indent="""", const",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:26793,Testability,test,testArg,26793,"izTree (std::ostream &os, const char *delimiter=""\n"", bool useTitle=false, bool useLatex=false);  Write the GraphViz representation of the expression tree headed by this RooAbsArg object to the given ostream. ;  ; bool hasClients () const;  ; bool hasDataToken () const;  ; virtual bool hasRange (const char *) const;  ; virtual bool importWorkspaceHook (RooWorkspace &ws);  ; virtual bool inRange (const char *) const;  ; virtual bool isCategory () const;  ; bool isConstant () const;  Check if the ""Constant"" attribute is set. ;  ; virtual bool isDerived () const;  Does value or shape of this arg depend on any other arg? ;  ; virtual bool isReducerNode () const;  ; bool IsSortable () const override;  ; bool localNoDirtyInhibit () const;  ; const TNamed * namePtr () const;  De-duplicated pointer to this object's name. ;  ; Int_t numProxies () const;  Return the number of registered proxies. ;  ; bool observableOverlaps (const RooAbsData *dset, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; bool observableOverlaps (const RooArgSet *depList, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; RooAbsArg & operator= (const RooAbsArg &other)=delete;  ; bool overlaps (const RooAbsArg &testArg, bool valueOnly=false) const;  Test if any of the nodes of tree are shared with that of the given tree. ;  ; const RooArgSet * ownedComponents () const;  ; void Print (Option_t *options=nullptr) const override;  Print the object to the defaultPrintStream(). ;  ; void printAddress (std::ostream &os) const override;  Print address of this RooAbsArg. ;  ; void printArgs (std::ostream &os) const override;  Print object arguments, ie its proxies. ;  ; void printClassName (std::ostream &os) const override;  Print object class name. ;  ; void printCompactTree (const char *indent="""", const",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:26875,Testability,test,testArg,26875,"am. ;  ; bool hasClients () const;  ; bool hasDataToken () const;  ; virtual bool hasRange (const char *) const;  ; virtual bool importWorkspaceHook (RooWorkspace &ws);  ; virtual bool inRange (const char *) const;  ; virtual bool isCategory () const;  ; bool isConstant () const;  Check if the ""Constant"" attribute is set. ;  ; virtual bool isDerived () const;  Does value or shape of this arg depend on any other arg? ;  ; virtual bool isReducerNode () const;  ; bool IsSortable () const override;  ; bool localNoDirtyInhibit () const;  ; const TNamed * namePtr () const;  De-duplicated pointer to this object's name. ;  ; Int_t numProxies () const;  Return the number of registered proxies. ;  ; bool observableOverlaps (const RooAbsData *dset, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; bool observableOverlaps (const RooArgSet *depList, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; RooAbsArg & operator= (const RooAbsArg &other)=delete;  ; bool overlaps (const RooAbsArg &testArg, bool valueOnly=false) const;  Test if any of the nodes of tree are shared with that of the given tree. ;  ; const RooArgSet * ownedComponents () const;  ; void Print (Option_t *options=nullptr) const override;  Print the object to the defaultPrintStream(). ;  ; void printAddress (std::ostream &os) const override;  Print address of this RooAbsArg. ;  ; void printArgs (std::ostream &os) const override;  Print object arguments, ie its proxies. ;  ; void printClassName (std::ostream &os) const override;  Print object class name. ;  ; void printCompactTree (const char *indent="""", const char *fileName=nullptr, const char *namePat=nullptr, RooAbsArg *client=nullptr);  Print tree structure of expression tree on stdout, or to file if filename is specified. ;  ; void printCompactTree (std::o",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:26999,Testability,test,testArg,26999,"am. ;  ; bool hasClients () const;  ; bool hasDataToken () const;  ; virtual bool hasRange (const char *) const;  ; virtual bool importWorkspaceHook (RooWorkspace &ws);  ; virtual bool inRange (const char *) const;  ; virtual bool isCategory () const;  ; bool isConstant () const;  Check if the ""Constant"" attribute is set. ;  ; virtual bool isDerived () const;  Does value or shape of this arg depend on any other arg? ;  ; virtual bool isReducerNode () const;  ; bool IsSortable () const override;  ; bool localNoDirtyInhibit () const;  ; const TNamed * namePtr () const;  De-duplicated pointer to this object's name. ;  ; Int_t numProxies () const;  Return the number of registered proxies. ;  ; bool observableOverlaps (const RooAbsData *dset, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; bool observableOverlaps (const RooArgSet *depList, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; RooAbsArg & operator= (const RooAbsArg &other)=delete;  ; bool overlaps (const RooAbsArg &testArg, bool valueOnly=false) const;  Test if any of the nodes of tree are shared with that of the given tree. ;  ; const RooArgSet * ownedComponents () const;  ; void Print (Option_t *options=nullptr) const override;  Print the object to the defaultPrintStream(). ;  ; void printAddress (std::ostream &os) const override;  Print address of this RooAbsArg. ;  ; void printArgs (std::ostream &os) const override;  Print object arguments, ie its proxies. ;  ; void printClassName (std::ostream &os) const override;  Print object class name. ;  ; void printCompactTree (const char *indent="""", const char *fileName=nullptr, const char *namePat=nullptr, RooAbsArg *client=nullptr);  Print tree structure of expression tree on stdout, or to file if filename is specified. ;  ; void printCompactTree (std::o",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:27103,Testability,test,testArg,27103,") const;  ; virtual bool isCategory () const;  ; bool isConstant () const;  Check if the ""Constant"" attribute is set. ;  ; virtual bool isDerived () const;  Does value or shape of this arg depend on any other arg? ;  ; virtual bool isReducerNode () const;  ; bool IsSortable () const override;  ; bool localNoDirtyInhibit () const;  ; const TNamed * namePtr () const;  De-duplicated pointer to this object's name. ;  ; Int_t numProxies () const;  Return the number of registered proxies. ;  ; bool observableOverlaps (const RooAbsData *dset, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; bool observableOverlaps (const RooArgSet *depList, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; RooAbsArg & operator= (const RooAbsArg &other)=delete;  ; bool overlaps (const RooAbsArg &testArg, bool valueOnly=false) const;  Test if any of the nodes of tree are shared with that of the given tree. ;  ; const RooArgSet * ownedComponents () const;  ; void Print (Option_t *options=nullptr) const override;  Print the object to the defaultPrintStream(). ;  ; void printAddress (std::ostream &os) const override;  Print address of this RooAbsArg. ;  ; void printArgs (std::ostream &os) const override;  Print object arguments, ie its proxies. ;  ; void printClassName (std::ostream &os) const override;  Print object class name. ;  ; void printCompactTree (const char *indent="""", const char *fileName=nullptr, const char *namePat=nullptr, RooAbsArg *client=nullptr);  Print tree structure of expression tree on stdout, or to file if filename is specified. ;  ; void printCompactTree (std::ostream &os, const char *indent="""", const char *namePat=nullptr, RooAbsArg *client=nullptr);  Print tree structure of expression tree on given ostream. ;  ; virtual void printCompactTreeHook (std::ostream &os",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:34693,Testability,test,test,34693,"th 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructo",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:34956,Testability,test,test,34956,"ooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void set",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:47376,Testability,log,logging,47376,"histogram bins. ;  ; static RooArgList createParamSet (RooWorkspace &w, const std::string &, const RooArgList &Vars);  Create the list of RooRealVar parameters which represent the height of the histogram bins. ;  ; static RooArgList createParamSet (RooWorkspace &w, const std::string &, const RooArgList &Vars, double, double);  Create the list of RooRealVar parameters which scale the height of histogram bins. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static vo",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:47437,Testability,log,logEvalError,47437,"pace &w, const std::string &, const RooArgList &Vars, double, double);  Create the list of RooRealVar parameters which scale the height of histogram bins. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Versi",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:47598,Testability,log,logging,47598,"pace &w, const std::string &, const RooArgList &Vars, double, double);  Create the list of RooRealVar parameters which scale the height of histogram bins. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Versi",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:47658,Testability,log,logging,47658,"pace &w, const std::string &, const RooArgList &Vars, double, double);  Create the list of RooRealVar parameters which scale the height of histogram bins. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Versi",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:47770,Testability,log,logged,47770,"Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version (",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:47933,Testability,log,logged,47933,"();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get st",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:48064,Testability,log,logging,48064,"  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bo",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:62022,Testability,test,testArg,62022," ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStats/HistFactory/ParamHistFunc.h>. Inheritance diagram for ParamHistFunc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ParamHistFunc() [1/4]. ParamHistFunc::ParamHistFunc ; (; ). Definition at line 62 of file ParamHistFunc.cxx. ◆ ParamHistFunc() [2/4]. ParamHistFunc::ParamHistFunc ; (; const char * ; name, . const char * ; title, . const RooArgList & ; vars, . const RooArgList & ; paramSet . ). Create a function which retur",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:62069,Testability,test,testArg,62069," ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStats/HistFactory/ParamHistFunc.h>. Inheritance diagram for ParamHistFunc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ParamHistFunc() [1/4]. ParamHistFunc::ParamHistFunc ; (; ). Definition at line 62 of file ParamHistFunc.cxx. ◆ ParamHistFunc() [2/4]. ParamHistFunc::ParamHistFunc ; (; const char * ; name, . const char * ; title, . const RooArgList & ; vars, . const RooArgList & ; paramSet . ). Create a function which retur",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:62099,Testability,test,testArg,62099," ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStats/HistFactory/ParamHistFunc.h>. Inheritance diagram for ParamHistFunc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ParamHistFunc() [1/4]. ParamHistFunc::ParamHistFunc ; (; ). Definition at line 62 of file ParamHistFunc.cxx. ◆ ParamHistFunc() [2/4]. ParamHistFunc::ParamHistFunc ; (; const char * ; name, . const char * ; title, . const RooArgList & ; vars, . const RooArgList & ; paramSet . ). Create a function which retur",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:62150,Testability,test,testArg,62150," ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStats/HistFactory/ParamHistFunc.h>. Inheritance diagram for ParamHistFunc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ParamHistFunc() [1/4]. ParamHistFunc::ParamHistFunc ; (; ). Definition at line 62 of file ParamHistFunc.cxx. ◆ ParamHistFunc() [2/4]. ParamHistFunc::ParamHistFunc ; (; const char * ; name, . const char * ; title, . const RooArgList & ; vars, . const RooArgList & ; paramSet . ). Create a function which retur",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:29207,Usability,clear,clear,29207,"ert additional information when printed in the context of a tree structure. ;  ; void printComponentTree (const char *indent="""", const char *namePat=nullptr, Int_t nLevel=999);  Print tree structure of expression tree on given ostream, only branch nodes are printed. ;  ; void printDirty (bool depth=true) const;  Print information about current value dirty state information. ;  ; virtual void printMetaArgs (std::ostream &) const;  ; void printName (std::ostream &os) const override;  Print object name. ;  ; void printTitle (std::ostream &os) const override;  Print object title. ;  ; void printTree (std::ostream &os, TString indent="""") const override;  Print object tree structure. ;  ; bool recursiveCheckObservables (const RooArgSet *nset) const;  Recursively call checkObservables on all nodes in the expression tree. ;  ; void removeStringAttribute (const Text_t *key);  Delete a string attribute with a given key. ;  ; void resetDataToken ();  ; void setAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setDataToken (std::size_t index);  Sets the token for retrieving results in the BatchMode. For internal use only. ;  ; void setLocalNoDirtyInhibit (bool flag) const;  ; void SetName (const char *name) override;  Set the name of the TNamed. ;  ; void SetNameTitle (const char *name, const char *title) override;  Set all the TNamed parameters (name and title). ;  ; void setProhibitServerRedirect (bool flag);  ; void setStringAttribute (const Text_t *key, const Text_t *value);  Associate string 'value' to this object under key 'key'. ;  ; void setTransientAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setWorkspace (RooWorkspace &ws);  ; const std::map< std::string, std::string > & stringAttributes () const;  ; const std::set< std::string > & transientAttributes () const;  ; RooWorkspace * workspace () const;  ; const RefCountL",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:29890,Usability,clear,clear,29890,"bool recursiveCheckObservables (const RooArgSet *nset) const;  Recursively call checkObservables on all nodes in the expression tree. ;  ; void removeStringAttribute (const Text_t *key);  Delete a string attribute with a given key. ;  ; void resetDataToken ();  ; void setAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setDataToken (std::size_t index);  Sets the token for retrieving results in the BatchMode. For internal use only. ;  ; void setLocalNoDirtyInhibit (bool flag) const;  ; void SetName (const char *name) override;  Set the name of the TNamed. ;  ; void SetNameTitle (const char *name, const char *title) override;  Set all the TNamed parameters (name and title). ;  ; void setProhibitServerRedirect (bool flag);  ; void setStringAttribute (const Text_t *key, const Text_t *value);  Associate string 'value' to this object under key 'key'. ;  ; void setTransientAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setWorkspace (RooWorkspace &ws);  ; const std::map< std::string, std::string > & stringAttributes () const;  ; const std::set< std::string > & transientAttributes () const;  ; RooWorkspace * workspace () const;  ; const RefCountList_t & clients () const;  List of all clients of this object. ;  ; const RefCountList_t & valueClients () const;  List of all value clients of this object. Value clients receive value updates. ;  ; const RefCountList_t & shapeClients () const;  List of all shape clients of this object. ;  ; const RefCountList_t & servers () const;  List of all servers of this object. ;  ; RooAbsArg * findServer (const char *name) const;  Return server of this with name name. Returns nullptr if not found. ;  ; RooAbsArg * findServer (const RooAbsArg &arg) const;  Return server of this that has the same name as arg. Returns nullptr if not found. ;  ; RooAbsArg * findServer (Int_t index) const;  Return",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:46917,Usability,clear,clearEvalErrorLog,46917,"tentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static RooArgList createParamSet (const std::string &, Int_t, double, double);  Create the list of RooRealVar parameters which represent the height of the histogram bins. ;  ; static RooArgList createParamSet (RooWorkspace &w, const std::string &, const RooArgList &Vars);  Create the list of RooRealVar parameters which represent the height of the histogram bins. ;  ; static RooArgList createParamSet (RooWorkspace &w, const std::string &, const RooArgList &Vars, double, double);  Create the list of RooRealVar parameters which scale the height of histogram bins. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static voi",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:47810,Usability,clear,clearing,47810,"Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version (",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:50306,Usability,simpl,simple,50306," ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; Int_t addParamSet (const RooArgList &params);  ; void doEval (RooFit::EvalContext &) const override;  Find all bins corresponding to the values of the observables in evalData, and evaluate the associated parameters. ;  ; double evaluate () const override;  Find the bin corresponding to the current value of the observable, and evaluate the associated parameter. ;  ; Int_t getCurrentBin () const;  Get the index of the gamma parameter associated with the current bin. ;  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntO",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:55168,Usability,clear,clearShapeDirty,55168,"eName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forw",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:55202,Usability,clear,clearValueAndShapeDirty,55202,"eName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forw",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:55244,Usability,clear,clearValueDirty,55244,"eName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forw",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:63413,Usability,simpl,simply,63413," = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStats/HistFactory/ParamHistFunc.h>. Inheritance diagram for ParamHistFunc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ParamHistFunc() [1/4]. ParamHistFunc::ParamHistFunc ; (; ). Definition at line 62 of file ParamHistFunc.cxx. ◆ ParamHistFunc() [2/4]. ParamHistFunc::ParamHistFunc ; (; const char * ; name, . const char * ; title, . const RooArgList & ; vars, . const RooArgList & ; paramSet . ). Create a function which returns binewise-values This class contains N RooAbsReals's, one for each bin from the given RooRealVar. ; The value of the function in the ith bin is given by:; F(i) = gamma_i * nominal(i); Where the nominal values are simply fixed numbers (default = 1.0 for all i) ; Definition at line 81 of file ParamHistFunc.cxx. ◆ ParamHistFunc() [3/4]. ParamHistFunc::ParamHistFunc ; (; const char * ; name, . const char * ; title, . const RooArgList & ; vars, . const RooArgList & ; paramSet, . const TH1 * ; Hist . ). Create a function which returns bin-wise values. ; This class allows to multiply bin contents of histograms with the values of a set of RooAbsReal.; The value of the function in the ith bin is given by: ; \[; F(i) = \gamma_{i} * \mathrm{nominal}(i); \]. Where the nominal values are taken from the histogram, and the \( \gamma_{i} \) can be set from the outside. ; Definition at line 124 of file ParamHistFunc.cxx. ◆ ParamHistFunc() [4/4]. ParamHistFunc::ParamHistFunc ; (; const ParamHistFunc & ; other, . const char * ; name = nullptr . ). Definition at line 173 of file ParamHistFunc.cxx. Member Function Documentation. ◆ addParamSet(). Int_t ParamHistFunc::addParam",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classParamHistFunc.html:73449,Usability,simpl,simple,73449,"interpolated histogram. ; Reimplemented from RooAbsReal.; Definition at line 686 of file ParamHistFunc.cxx. ◆ setConstant(). void ParamHistFunc::setConstant ; (; bool ; constant). Definition at line 233 of file ParamHistFunc.cxx. ◆ setParamConst(). void ParamHistFunc::setParamConst ; (; Int_t ; index, . bool ; varConst = true . ). Definition at line 227 of file ParamHistFunc.cxx. ◆ setShape(). void ParamHistFunc::setShape ; (; TH1 * ; shape). Definition at line 242 of file ParamHistFunc.cxx. ◆ Streamer(). void ParamHistFunc::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void ParamHistFunc::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 111 of file ParamHistFunc.h. ◆ translate(). void ParamHistFunc::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overrideprotectedvirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 563 of file ParamHistFunc.cxx. Member Data Documentation. ◆ _dataSet. RooDataHist ParamHistFunc::_dataSet. mutableprotected . Definition at line 98 of file ParamHistFunc.h. ◆ _dataVars. RooListProxy ParamHistFunc::_dataVars. protected . The RooRealVars. ; Definition at line 82 of file ParamHistFunc.h. ◆ _normIntMgr. RooObjCacheManager ParamHistFunc::_normIntMgr. mutableprotected . ! The integration cache manager ; Definition a",MatchSource.WIKI,doc/master/classParamHistFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html
https://root.cern/doc/master/classPdfWrapper.html:9044,Availability,error,error,9044,"ents);  Special generator interface for generation of 'global observables' – for RooStats tools. ;  ; RooArgSet * getAllConstraints (const RooArgSet &observables, RooArgSet &constrainedParams, bool stripDisconnected=true) const;  This helper function finds and collects all constraints terms of all component p.d.f.s and returns a RooArgSet with all those terms. ;  ; virtual RooArgSet * getConstraints (const RooArgSet &, RooArgSet const &, RooArgSet &) const;  ; virtual Int_t getGenerator (const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) const;  Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ;  ; const RooNumGenConfig * getGeneratorConfig () const;  Return the numeric MC generator configuration used for this object. ;  ; void getLogProbabilities (std::span< const double > pdfValues, double *output) const;  ; virtual double getLogVal (const RooArgSet *set=nullptr) const;  Return the log of the current value with given normalization An error message is printed if the argument of the log is negative. ;  ; double getNorm (const RooArgSet &nset) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; virtual double getNorm (const RooArgSet *set=nullptr) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; const RooAbsReal * getNormIntegral (const RooArgSet &nset) const;  ; virtual const RooAbsReal * getNormObj (const RooArgSet *set, const RooArgSet *iset, const TNamed *rangeName=nullptr) const;  Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range rangeName, optionally taking the integrand normalized over observables nset. ;  ; double getValV (const RooArgSet *set=nullptr) const override;  Return current value, normalized by integrating over the observables in nset. ;  ; virtual void initGenerator (Int_t code);  I",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:10680,Availability,error,errors,10680,"RooArgSet *iset, const TNamed *rangeName=nullptr) const;  Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range rangeName, optionally taking the integrand normalized over observables nset. ;  ; double getValV (const RooArgSet *set=nullptr) const override;  Return current value, normalized by integrating over the observables in nset. ;  ; virtual void initGenerator (Int_t code);  Interface for one-time initialization to setup the generator for the specified code. ;  ; TClass * IsA () const override;  ; virtual bool isDirectGenSafe (const RooAbsArg &arg) const;  Check if given observable can be safely generated using the pdfs internal generator mechanism (if that existsP). ;  ; bool mustBeExtended () const;  If true PDF must provide extended likelihood term. ;  ; const char * normRange () const;  ; virtual RooPlot * paramOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Add a box with parameter values (and errors) to the specified frame. ;  ; RooPlot * plotOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const override;  Helper calling plotOn(RooPlot*, RooLinkedList&) const. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Plot (project) PDF on specified frame. ;  ; GenSpec * prepareMultiGen (const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specificatio",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:11914,Availability,error,error,11914," const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const override;  Helper calling plotOn(RooPlot*, RooLinkedList&) const. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Plot (project) PDF on specified frame. ;  ; GenSpec * prepareMultiGen (const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Print multi line detailed information of this RooAbsPdf. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtua",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:11974,Availability,error,error,11974," const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const override;  Helper calling plotOn(RooPlot*, RooLinkedList&) const. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Plot (project) PDF on specified frame. ;  ; GenSpec * prepareMultiGen (const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Print multi line detailed information of this RooAbsPdf. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtua",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:25192,Availability,error,error,25192,"virtual Int_t getMaxVal (const RooArgSet &vars) const;  Advertise capability to determine maximum value of function for given set of observables. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual void gradient (double *) const;  ; virtual bool hasGradient () const;  ; TClass * IsA () const override;  ; bool isIdentical (const RooAbsArg &other, bool assumeSameType=false) const override;  ; virtual bool isOffsetting () const;  ; bool isSelectedComp () const;  If true, the current pdf is a selected component (for use in plotting) ;  ; void logEvalError (const char *message, const char *serverValueString=nullptr) const;  Log evaluation error message. ;  ; virtual double maxVal (Int_t code) const;  Return maximum value for set of observables identified by code assigned in getMaxVal. ;  ; RooAbsMoment * mean (RooRealVar &obs);  ; RooAbsMoment * mean (RooRealVar &obs, const RooArgSet &nset);  ; virtual Int_t minTrialSamples (const RooArgSet &) const;  ; RooAbsMoment * moment (RooRealVar &obs, const RooArgSet &normObs, Int_t order, bool central, bool takeRoot, bool intNormObs);  Return function representing moment of p.d.f (normalized w.r.t given observables) of given order. ;  ; RooAbsMoment * moment (RooRealVar &obs, Int_t order, bool central, bool takeRoot);  Return function representing moment of function of given order. ;  ; virtual double offset () const;  ; bool operator== (const RooAbsArg &other",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:43159,Availability,mask,mask,43159,"s);  Replace some servers of this object. ;  ; bool recursiveRedirectServers (const RooAbsCollection &newServerList, bool mustReplaceAll=false, bool nameChange=false, bool recurseInNewSet=true);  Recursively replace all servers with the new servers in newSet. ;  ; virtual void serverNameChangeHook (const RooAbsArg *, const RooAbsArg *);  ; void addServer (RooAbsArg &server, bool valueProp=true, bool shapeProp=false, std::size_t refCount=1);  Register another RooAbsArg as a server to us, ie, declare that we depend on it. ;  ; void addServerList (RooAbsCollection &serverList, bool valueProp=true, bool shapeProp=false);  Register a list of RooAbsArg as servers to us by calling addServer() for each arg in the list. ;  ; void replaceServer (RooAbsArg &oldServer, RooAbsArg &newServer, bool valueProp, bool shapeProp);  Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const Ro",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:49416,Availability,error,error,49416,"ject. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t ",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:49505,Availability,error,error,49505,"ecord whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual ",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:49660,Availability,error,error,49660,"Name () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute ",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:49957,Availability,error,error,49957,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info ",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:54041,Availability,error,error,54041,"n object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption s",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:57982,Availability,error,error,57982," << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Static Public Member Functions inherited from RooAbsPdf; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooNumGenConfig * defaultGeneratorConfig ();  Returns the default numeric MC generator configuration for all RooAbsReals. ;  ; static int verboseEval ();  Return global level of verbosity for p.d.f. evaluations. ;  ; static void verboseEval (Int_t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (s",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:58382,Availability,error,error,58382,");  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooNumGenConfig * defaultGeneratorConfig ();  Returns the default numeric MC generator configuration for all RooAbsReals. ;  ; static int verboseEval ();  Return global level of verbosity for p.d.f. evaluations. ;  ; static void verboseEval (Int_t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static vo",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:58604,Availability,error,error,58604,"ls. ;  ; static int verboseEval ();  Return global level of verbosity for p.d.f. evaluations. ;  ; static void verboseEval (Int_t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Versi",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:58664,Availability,error,error,58664,"ls. ;  ; static int verboseEval ();  Return global level of verbosity for p.d.f. evaluations. ;  ; static void verboseEval (Int_t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Versi",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:58800,Availability,error,errors,58800,"Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version (",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:58963,Availability,error,error,58963,"();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get st",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:59070,Availability,error,error,59070,"  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bo",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:66839,Availability,error,error,66839,"bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  Function that is called at the end of redirectServers(). ;  ; virtual void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; virtual void selectNormalizationRange (const char *rangeName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:69721,Availability,error,errors,69721,"rg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot ",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:3617,Deployability,integrat,integrated,3617," iset. ;  ; RooFit::OwningPtr< RooAbsReal > createCdf (const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; virtual std::unique_ptr< RooAbsReal > createExpectedEventsFunc (const RooArgSet *nset) const;  Returns an object that represents the expected number of events for a given normalization set, similar to how createIntegral() returns an object that returns the integral. ;  ; template<typename... CmdArgs_t> ; RooFit::OwningPtr< RooAbsReal > createNLL (RooAbsData &data, CmdArgs_t const &... cmdArgs);  Construct representation of -log(L) of PDF with given dataset. ;  ; virtual RooAbsPdf * createProjection (const RooArgSet &iset);  Return a p.d.f that represent a projection of this p.d.f integrated over given observables. ;  ; RooFit::OwningPtr< RooAbsReal > createScanCdf (const RooArgSet &iset, const RooArgSet &nset, Int_t numScanBins, Int_t intOrder);  ; double expectedEvents (const RooArgSet &nset) const;  Return expected number of events to be used in calculation of extended likelihood. ;  ; virtual double expectedEvents (const RooArgSet *nset) const;  Return expected number of events to be used in calculation of extended likelihood. ;  ; double extendedTerm (double sumEntries, double expected, double sumEntriesW2=0.0, bool doOffset=false) const;  ; double extendedTerm (double sumEntries, RooArgSet const *nset, double sumEntriesW2=0.0, bool doOffset=false) const;  Return the extended likelihood term ( \( N_\mathrm{expect} - N_\mathrm{observed} \cdot \log(N_\mathrm{expect} \)) of this PDF for the given number of observed events. ;  ; double extendedTerm (RooAbsData const &data, bool weightSquared, bool doOffset=false) const;  Return the extended likelihood term ( \( N_\mathrm{expec",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:8786,Deployability,configurat,configuration,8786,"nt_t code);  Interface for generation of an event using the algorithm corresponding to the specified code. ;  ; virtual RooFit::OwningPtr< RooDataSet > generateSimGlobal (const RooArgSet &whatVars, Int_t nEvents);  Special generator interface for generation of 'global observables' – for RooStats tools. ;  ; RooArgSet * getAllConstraints (const RooArgSet &observables, RooArgSet &constrainedParams, bool stripDisconnected=true) const;  This helper function finds and collects all constraints terms of all component p.d.f.s and returns a RooArgSet with all those terms. ;  ; virtual RooArgSet * getConstraints (const RooArgSet &, RooArgSet const &, RooArgSet &) const;  ; virtual Int_t getGenerator (const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) const;  Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ;  ; const RooNumGenConfig * getGeneratorConfig () const;  Return the numeric MC generator configuration used for this object. ;  ; void getLogProbabilities (std::span< const double > pdfValues, double *output) const;  ; virtual double getLogVal (const RooArgSet *set=nullptr) const;  Return the log of the current value with given normalization An error message is printed if the argument of the log is negative. ;  ; double getNorm (const RooArgSet &nset) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; virtual double getNorm (const RooArgSet *set=nullptr) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; const RooAbsReal * getNormIntegral (const RooArgSet &nset) const;  ; virtual const RooAbsReal * getNormObj (const RooArgSet *set, const RooArgSet *iset, const TNamed *rangeName=nullptr) const;  Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range rangeName, optionally taking the integrand normalized over obser",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:9875,Deployability,integrat,integrating,9875,"bilities (std::span< const double > pdfValues, double *output) const;  ; virtual double getLogVal (const RooArgSet *set=nullptr) const;  Return the log of the current value with given normalization An error message is printed if the argument of the log is negative. ;  ; double getNorm (const RooArgSet &nset) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; virtual double getNorm (const RooArgSet *set=nullptr) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; const RooAbsReal * getNormIntegral (const RooArgSet &nset) const;  ; virtual const RooAbsReal * getNormObj (const RooArgSet *set, const RooArgSet *iset, const TNamed *rangeName=nullptr) const;  Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range rangeName, optionally taking the integrand normalized over observables nset. ;  ; double getValV (const RooArgSet *set=nullptr) const override;  Return current value, normalized by integrating over the observables in nset. ;  ; virtual void initGenerator (Int_t code);  Interface for one-time initialization to setup the generator for the specified code. ;  ; TClass * IsA () const override;  ; virtual bool isDirectGenSafe (const RooAbsArg &arg) const;  Check if given observable can be safely generated using the pdfs internal generator mechanism (if that existsP). ;  ; bool mustBeExtended () const;  If true PDF must provide extended likelihood term. ;  ; const char * normRange () const;  ; virtual RooPlot * paramOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Add a box with parameter values (and errors) to the specified frame. ;  ; RooPlot * plotOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdAr",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:11436,Deployability,configurat,configuration,11436,"normRange () const;  ; virtual RooPlot * paramOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Add a box with parameter values (and errors) to the specified frame. ;  ; RooPlot * plotOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const override;  Helper calling plotOn(RooPlot*, RooLinkedList&) const. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Plot (project) PDF on specified frame. ;  ; GenSpec * prepareMultiGen (const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Print multi line detailed information of this RooAbsPdf. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverr",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:12097,Deployability,configurat,configuration,12097,"onst. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Plot (project) PDF on specified frame. ;  ; GenSpec * prepareMultiGen (const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Print multi line detailed information of this RooAbsPdf. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default con",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:12217,Deployability,configurat,configuration,12217,"* prepareMultiGen (const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Print multi line detailed information of this RooAbsPdf. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (con",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:12263,Deployability,configurat,configuration,12263,"* prepareMultiGen (const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Print multi line detailed information of this RooAbsPdf. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (con",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:12644,Deployability,integrat,integrator,12644,"nt="""") const override;  Print multi line detailed information of this RooAbsPdf. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:12655,Deployability,configurat,configuration,12655,"nt="""") const override;  Print multi line detailed information of this RooAbsPdf. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:12784,Deployability,integrat,integrator,12784,"e;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgS",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:12795,Deployability,configurat,configuration,12795,"e;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgS",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:18204,Deployability,configurat,configuration,18204,"f this function. ;  ; TH1 * createHistogram (const char *name, const RooAbsRealLValue &xvar, RooLinkedList &argList) const;  Internal method implementing createHistogram. ;  ; TH1 * createHistogram (RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) const;  Create and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables with given names. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const char *rangeName) const;  Create integral over observables in iset in range named rangeName. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet &nset, const char *rangeName=nullptr) const;  Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet &nset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) const;  Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset while using specified configuration for any numeric integration. ;  ; virtual RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet *nset=nullptr, const RooNumIntConfig *cfg=nullptr, const char *rangeName=nullptr) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooNumIntConfig &cfg, const char *rangeName=nullpt",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:18234,Deployability,integrat,integration,18234,"f this function. ;  ; TH1 * createHistogram (const char *name, const RooAbsRealLValue &xvar, RooLinkedList &argList) const;  Internal method implementing createHistogram. ;  ; TH1 * createHistogram (RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) const;  Create and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables with given names. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const char *rangeName) const;  Create integral over observables in iset in range named rangeName. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet &nset, const char *rangeName=nullptr) const;  Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet &nset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) const;  Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset while using specified configuration for any numeric integration. ;  ; virtual RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet *nset=nullptr, const RooNumIntConfig *cfg=nullptr, const char *rangeName=nullptr) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooNumIntConfig &cfg, const char *rangeName=nullpt",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:19165,Deployability,configurat,configuration,19165,"ntegral over observables in iset in range named rangeName with integrand normalized over observables in nset while using specified configuration for any numeric integration. ;  ; virtual RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet *nset=nullptr, const RooNumIntConfig *cfg=nullptr, const char *rangeName=nullptr) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) const;  Create integral over observables in iset in range named rangeName using specified configuration for any numeric integration. ;  ; RooFit::OwningPtr< RooAbsReal > createIntRI (const RooArgSet &iset, const RooArgSet &nset={});  Utility function for createRunningIntegral. ;  ; const RooAbsReal * createPlotProjection (const RooArgSet &dependentVars, const RooArgSet *projectedVars, RooArgSet *&cloneSet, const char *rangeName=nullptr, const RooArgSet *condObs=nullptr) const;  Utility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a RooPlot. ;  ; const RooAbsReal * createPlotProjection (const RooArgSet &depVars, const RooArgSet &projVars, RooArgSet *&cloneSet) const;  Utility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a RooPlot. ;  ; virtual RooFit::OwningPtr< RooAbsReal > createProfile (const RooArgSet &paramsOfInterest);  Create a RooProfileLL object that eliminates all nuisance parameters in the",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:19195,Deployability,integrat,integration,19195,"ntegral over observables in iset in range named rangeName with integrand normalized over observables in nset while using specified configuration for any numeric integration. ;  ; virtual RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooArgSet *nset=nullptr, const RooNumIntConfig *cfg=nullptr, const char *rangeName=nullptr) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const;  Create an object that represents the integral of the function over one or more observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createIntegral (const RooArgSet &iset, const RooNumIntConfig &cfg, const char *rangeName=nullptr) const;  Create integral over observables in iset in range named rangeName using specified configuration for any numeric integration. ;  ; RooFit::OwningPtr< RooAbsReal > createIntRI (const RooArgSet &iset, const RooArgSet &nset={});  Utility function for createRunningIntegral. ;  ; const RooAbsReal * createPlotProjection (const RooArgSet &dependentVars, const RooArgSet *projectedVars, RooArgSet *&cloneSet, const char *rangeName=nullptr, const RooArgSet *condObs=nullptr) const;  Utility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a RooPlot. ;  ; const RooAbsReal * createPlotProjection (const RooArgSet &depVars, const RooArgSet &projVars, RooArgSet *&cloneSet) const;  Utility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a RooPlot. ;  ; virtual RooFit::OwningPtr< RooAbsReal > createProfile (const RooArgSet &paramsOfInterest);  Create a RooProfileLL object that eliminates all nuisance parameters in the",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:23790,Deployability,integrat,integration,23790,"on tree headed by this object to the given set of observables. ;  ; virtual bool forceAnalyticalInt (const RooAbsArg &) const;  ; virtual void forceNumInt (bool flag=true);  ; RooFunctor * functor (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a RooFunctor object bound to this RooAbsReal with given definition of observables and parameters. ;  ; virtual Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; virtual Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const;  Variant of getAnalyticalIntegral that is also passed the normalization set that should be applied to the integrand of which the integral is requested. ;  ; bool getForceNumInt () const;  ; RooNumIntConfig * getIntegratorConfig ();  Return the numeric integration configuration used for this object. ;  ; const RooNumIntConfig * getIntegratorConfig () const;  Return the numeric integration configuration used for this object. ;  ; virtual Int_t getMaxVal (const RooArgSet &vars) const;  Advertise capability to determine maximum value of function for given set of observables. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual void gradient (",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:23802,Deployability,configurat,configuration,23802,"on tree headed by this object to the given set of observables. ;  ; virtual bool forceAnalyticalInt (const RooAbsArg &) const;  ; virtual void forceNumInt (bool flag=true);  ; RooFunctor * functor (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a RooFunctor object bound to this RooAbsReal with given definition of observables and parameters. ;  ; virtual Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; virtual Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const;  Variant of getAnalyticalIntegral that is also passed the normalization set that should be applied to the integrand of which the integral is requested. ;  ; bool getForceNumInt () const;  ; RooNumIntConfig * getIntegratorConfig ();  Return the numeric integration configuration used for this object. ;  ; const RooNumIntConfig * getIntegratorConfig () const;  Return the numeric integration configuration used for this object. ;  ; virtual Int_t getMaxVal (const RooArgSet &vars) const;  Advertise capability to determine maximum value of function for given set of observables. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual void gradient (",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:23917,Deployability,integrat,integration,23917," void forceNumInt (bool flag=true);  ; RooFunctor * functor (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a RooFunctor object bound to this RooAbsReal with given definition of observables and parameters. ;  ; virtual Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; virtual Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const;  Variant of getAnalyticalIntegral that is also passed the normalization set that should be applied to the integrand of which the integral is requested. ;  ; bool getForceNumInt () const;  ; RooNumIntConfig * getIntegratorConfig ();  Return the numeric integration configuration used for this object. ;  ; const RooNumIntConfig * getIntegratorConfig () const;  Return the numeric integration configuration used for this object. ;  ; virtual Int_t getMaxVal (const RooArgSet &vars) const;  Advertise capability to determine maximum value of function for given set of observables. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual void gradient (double *) const;  ; virtual bool hasGradient () const;  ; TClass * IsA () const override;  ; bool isIdentical (const RooAbsArg &other, boo",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:23929,Deployability,configurat,configuration,23929," void forceNumInt (bool flag=true);  ; RooFunctor * functor (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a RooFunctor object bound to this RooAbsReal with given definition of observables and parameters. ;  ; virtual Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; virtual Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const;  Variant of getAnalyticalIntegral that is also passed the normalization set that should be applied to the integrand of which the integral is requested. ;  ; bool getForceNumInt () const;  ; RooNumIntConfig * getIntegratorConfig ();  Return the numeric integration configuration used for this object. ;  ; const RooNumIntConfig * getIntegratorConfig () const;  Return the numeric integration configuration used for this object. ;  ; virtual Int_t getMaxVal (const RooArgSet &vars) const;  Advertise capability to determine maximum value of function for given set of observables. ;  ; const char * getPlotLabel () const;  Get the label associated with the variable. ;  ; double getPropagatedError (const RooFitResult &fr, const RooArgSet &nset={}) const;  Propagates parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual void gradient (double *) const;  ; virtual bool hasGradient () const;  ; TClass * IsA () const override;  ; bool isIdentical (const RooAbsArg &other, boo",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:27251,Deployability,integrat,integration,27251,"uble xhi) const;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &o",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:27263,Deployability,configurat,configuration,27263,"uble xhi) const;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &o",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:27384,Deployability,integrat,integrator,27384,"dObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for now) ;  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constru",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:27395,Deployability,configurat,configuration,27395,"dObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for now) ;  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constru",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
https://root.cern/doc/master/classPdfWrapper.html:27428,Deployability,integrat,integration,27428,"dObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for now) ;  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constru",MatchSource.WIKI,doc/master/classPdfWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/classPdfWrapper.html
